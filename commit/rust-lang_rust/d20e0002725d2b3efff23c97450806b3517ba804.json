{"sha": "d20e0002725d2b3efff23c97450806b3517ba804", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyMGUwMDAyNzI1ZDJiM2VmZmYyM2M5NzQ1MDgwNmIzNTE3YmE4MDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-28T02:00:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-28T02:00:57Z"}, "message": "Auto merge of #59471 - cuviper:rollup, r=cuviper\n\nRollup of 18 pull requests\n\nSuccessful merges:\n\n - #57293 (Make some lints incremental)\n - #57565 (syntax: Remove warning for unnecessary path disambiguators)\n - #58253 (librustc_driver => 2018)\n - #58837 (librustc_interface => 2018)\n - #59268 (Add suggestion to use `&*var` when `&str: From<String>` is expected)\n - #59283 (Make ASCII case conversions more than 4\u00d7 faster)\n - #59284 (adjust MaybeUninit API to discussions)\n - #59372 (add rustfix-able suggestions to trim_{left,right} deprecations)\n - #59390 (Make `ptr::eq` documentation mention fat-pointer behavior)\n - #59393 (Refactor tuple comparison tests)\n - #59420 ([CI] record docker image info for reuse)\n - #59421 (Reject integer suffix when tuple indexing)\n - #59430 (Renames `EvalContext` to `InterpretCx`)\n - #59439 (Generalize diagnostic for `x = y` where `bool` is the expected type)\n - #59449 (fix: Make incremental artifact deletion more robust)\n - #59451 (Add `Default` to `std::alloc::System`)\n - #59459 (Add some tests)\n - #59460 (Include id in Thread's Debug implementation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "30dcba1cf4ff7e25de3fd495278e0458ba6c5c98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30dcba1cf4ff7e25de3fd495278e0458ba6c5c98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d20e0002725d2b3efff23c97450806b3517ba804", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d20e0002725d2b3efff23c97450806b3517ba804", "html_url": "https://github.com/rust-lang/rust/commit/d20e0002725d2b3efff23c97450806b3517ba804", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d20e0002725d2b3efff23c97450806b3517ba804/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "html_url": "https://github.com/rust-lang/rust/commit/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf"}, {"sha": "a2c4562690db552c845804223e302d42efd48c98", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2c4562690db552c845804223e302d42efd48c98", "html_url": "https://github.com/rust-lang/rust/commit/a2c4562690db552c845804223e302d42efd48c98"}], "stats": {"total": 2164, "additions": 1470, "deletions": 694}, "files": [{"sha": "98a765e1cec9557c815dca50507ebeb5fe2def60", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -12,6 +12,9 @@ ci_dir=\"`dirname $docker_dir`\"\n src_dir=\"`dirname $ci_dir`\"\n root_dir=\"`dirname $src_dir`\"\n \n+objdir=$root_dir/obj\n+dist=$objdir/build/dist\n+\n source \"$ci_dir/shared.sh\"\n \n travis_fold start build_docker\n@@ -77,6 +80,11 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       else\n         echo \"Looks like docker image is the same as before, not uploading\"\n       fi\n+      # Record the container image for reuse, e.g. by rustup.rs builds\n+      info=\"$dist/image-$image.txt\"\n+      mkdir -p \"$dist\"\n+      echo \"$url\" >\"$info\"\n+      echo \"$digest\" >>\"$info\"\n     fi\n elif [ -f \"$docker_dir/disabled/$image/Dockerfile\" ]; then\n     if [ -n \"$TRAVIS_OS_NAME\" ]; then\n@@ -99,8 +107,6 @@ fi\n travis_fold end build_docker\n travis_time_finish\n \n-objdir=$root_dir/obj\n-\n mkdir -p $HOME/.cargo\n mkdir -p $objdir/tmp\n mkdir -p $objdir/cores"}, {"sha": "a770ab65c26f80d97e1de7ed2f9f9f578af6d458", "filename": "src/doc/unstable-book/src/language-features/on-unimplemented.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -138,3 +138,16 @@ error[E0277]: `&str` is not an iterator\n   = help: the trait `std::iter::Iterator` is not implemented for `&str`\n   = note: required by `std::iter::IntoIterator::into_iter`\n ```\n+\n+If you need to filter on multiple attributes, you can use `all`, `any` or\n+`not` in the following way:\n+\n+```rust,compile_fail\n+#[rustc_on_unimplemented(\n+    on(\n+        all(_Self=\"&str\", T=\"std::string::String\"),\n+        note=\"you can coerce a `{T}` into a `{Self}` by writing `&*variable`\"\n+    )\n+)]\n+pub trait From<T>: Sized { /* ... */ }\n+```"}, {"sha": "581c66c7086a5b9f0270e3aee54e80e757bda764", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -109,7 +109,7 @@ impl<K, V> LeafNode<K, V> {\n             keys: uninitialized_array![_; CAPACITY],\n             vals: uninitialized_array![_; CAPACITY],\n             parent: ptr::null(),\n-            parent_idx: MaybeUninit::uninitialized(),\n+            parent_idx: MaybeUninit::uninit(),\n             len: 0\n         }\n     }\n@@ -129,7 +129,7 @@ unsafe impl Sync for NodeHeader<(), ()> {}\n // ever take a pointer past the first key.\n static EMPTY_ROOT_NODE: NodeHeader<(), ()> = NodeHeader {\n     parent: ptr::null(),\n-    parent_idx: MaybeUninit::uninitialized(),\n+    parent_idx: MaybeUninit::uninit(),\n     len: 0,\n     keys_start: [],\n };\n@@ -261,7 +261,7 @@ impl<K, V> Root<K, V> {\n             -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         debug_assert!(!self.is_shared_root());\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n-        new_node.edges[0].set(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n+        new_node.edges[0].write(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n \n         self.node = BoxedNode::from_internal(new_node);\n         self.height += 1;\n@@ -737,7 +737,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         unsafe {\n             ptr::write(self.keys_mut().get_unchecked_mut(idx), key);\n             ptr::write(self.vals_mut().get_unchecked_mut(idx), val);\n-            self.as_internal_mut().edges.get_unchecked_mut(idx + 1).set(edge.node);\n+            self.as_internal_mut().edges.get_unchecked_mut(idx + 1).write(edge.node);\n \n             (*self.as_leaf_mut()).len += 1;\n \n@@ -1080,7 +1080,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         let mut child = self.descend();\n         unsafe {\n             (*child.as_leaf_mut()).parent = ptr;\n-            (*child.as_leaf_mut()).parent_idx.set(idx);\n+            (*child.as_leaf_mut()).parent_idx.write(idx);\n         }\n     }\n "}, {"sha": "635537e3121581ca31d6b86980f127c05ec338d5", "filename": "src/libcore/benches/ascii.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fbenches%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fbenches%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fascii.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -0,0 +1,349 @@\n+// Lower-case ASCII 'a' is the first byte that has its highest bit set\n+// after wrap-adding 0x1F:\n+//\n+//     b'a' + 0x1F == 0x80 == 0b1000_0000\n+//     b'z' + 0x1F == 0x98 == 0b10011000\n+//\n+// Lower-case ASCII 'z' is the last byte that has its highest bit unset\n+// after wrap-adding 0x05:\n+//\n+//     b'a' + 0x05 == 0x66 == 0b0110_0110\n+//     b'z' + 0x05 == 0x7F == 0b0111_1111\n+//\n+// \u2026 except for 0xFB to 0xFF, but those are in the range of bytes\n+// that have the highest bit unset again after adding 0x1F.\n+//\n+// So `(byte + 0x1f) & !(byte + 5)` has its highest bit set\n+// iff `byte` is a lower-case ASCII letter.\n+//\n+// Lower-case ASCII letters all have the 0x20 bit set.\n+// (Two positions right of 0x80, the highest bit.)\n+// Unsetting that bit produces the same letter, in upper-case.\n+//\n+// Therefore:\n+fn branchless_to_ascii_upper_case(byte: u8) -> u8 {\n+    byte &\n+    !(\n+        (\n+            byte.wrapping_add(0x1f) &\n+            !byte.wrapping_add(0x05) &\n+            0x80\n+        ) >> 2\n+    )\n+}\n+\n+\n+macro_rules! benches {\n+    ($( fn $name: ident($arg: ident: &mut [u8]) $body: block )+ @iter $( $is_: ident, )+) => {\n+        benches! {@\n+            $( fn $name($arg: &mut [u8]) $body )+\n+            $( fn $is_(bytes: &mut [u8]) { bytes.iter().all(u8::$is_) } )+\n+        }\n+    };\n+\n+    (@$( fn $name: ident($arg: ident: &mut [u8]) $body: block )+) => {\n+        benches!(mod short SHORT $($name $arg $body)+);\n+        benches!(mod medium MEDIUM $($name $arg $body)+);\n+        benches!(mod long LONG $($name $arg $body)+);\n+    };\n+\n+    (mod $mod_name: ident $input: ident $($name: ident $arg: ident $body: block)+) => {\n+        mod $mod_name {\n+            use super::*;\n+\n+            $(\n+                #[bench]\n+                fn $name(bencher: &mut Bencher) {\n+                    bencher.bytes = $input.len() as u64;\n+                    bencher.iter(|| {\n+                        let mut vec = $input.as_bytes().to_vec();\n+                        {\n+                            let $arg = &mut vec[..];\n+                            black_box($body);\n+                        }\n+                        vec\n+                    })\n+                }\n+            )+\n+        }\n+    }\n+}\n+\n+use test::black_box;\n+use test::Bencher;\n+\n+benches! {\n+    fn case00_alloc_only(_bytes: &mut [u8]) {}\n+\n+    fn case01_black_box_read_each_byte(bytes: &mut [u8]) {\n+        for byte in bytes {\n+            black_box(*byte);\n+        }\n+    }\n+\n+    fn case02_lookup_table(bytes: &mut [u8]) {\n+        for byte in bytes {\n+            *byte = ASCII_UPPERCASE_MAP[*byte as usize]\n+        }\n+    }\n+\n+    fn case03_branch_and_subtract(bytes: &mut [u8]) {\n+        for byte in bytes {\n+            *byte = if b'a' <= *byte && *byte <= b'z' {\n+                *byte - b'a' + b'A'\n+            } else {\n+                *byte\n+            }\n+        }\n+    }\n+\n+    fn case04_branch_and_mask(bytes: &mut [u8]) {\n+        for byte in bytes {\n+            *byte = if b'a' <= *byte && *byte <= b'z' {\n+                *byte & !0x20\n+            } else {\n+                *byte\n+            }\n+        }\n+    }\n+\n+    fn case05_branchless(bytes: &mut [u8]) {\n+        for byte in bytes {\n+            *byte = branchless_to_ascii_upper_case(*byte)\n+        }\n+    }\n+\n+    fn case06_libcore(bytes: &mut [u8]) {\n+        bytes.make_ascii_uppercase()\n+    }\n+\n+    fn case07_fake_simd_u32(bytes: &mut [u8]) {\n+        let (before, aligned, after) = unsafe {\n+            bytes.align_to_mut::<u32>()\n+        };\n+        for byte in before {\n+            *byte = branchless_to_ascii_upper_case(*byte)\n+        }\n+        for word in aligned {\n+            // FIXME: this is incorrect for some byte values:\n+            // addition within a byte can carry/overflow into the next byte.\n+            // Test case: b\"\\xFFz  \"\n+            *word &= !(\n+                (\n+                    word.wrapping_add(0x1f1f1f1f) &\n+                    !word.wrapping_add(0x05050505) &\n+                    0x80808080\n+                ) >> 2\n+            )\n+        }\n+        for byte in after {\n+            *byte = branchless_to_ascii_upper_case(*byte)\n+        }\n+    }\n+\n+    fn case08_fake_simd_u64(bytes: &mut [u8]) {\n+        let (before, aligned, after) = unsafe {\n+            bytes.align_to_mut::<u64>()\n+        };\n+        for byte in before {\n+            *byte = branchless_to_ascii_upper_case(*byte)\n+        }\n+        for word in aligned {\n+            // FIXME: like above, this is incorrect for some byte values.\n+            *word &= !(\n+                (\n+                    word.wrapping_add(0x1f1f1f1f_1f1f1f1f) &\n+                    !word.wrapping_add(0x05050505_05050505) &\n+                    0x80808080_80808080\n+                ) >> 2\n+            )\n+        }\n+        for byte in after {\n+            *byte = branchless_to_ascii_upper_case(*byte)\n+        }\n+    }\n+\n+    fn case09_mask_mult_bool_branchy_lookup_table(bytes: &mut [u8]) {\n+        fn is_ascii_lowercase(b: u8) -> bool {\n+            if b >= 0x80 { return false }\n+            match ASCII_CHARACTER_CLASS[b as usize] {\n+                L | Lx => true,\n+                _ => false,\n+            }\n+        }\n+        for byte in bytes {\n+            *byte &= !(0x20 * (is_ascii_lowercase(*byte) as u8))\n+        }\n+    }\n+\n+    fn case10_mask_mult_bool_lookup_table(bytes: &mut [u8]) {\n+        fn is_ascii_lowercase(b: u8) -> bool {\n+            match ASCII_CHARACTER_CLASS[b as usize] {\n+                L | Lx => true,\n+                _ => false\n+            }\n+        }\n+        for byte in bytes {\n+            *byte &= !(0x20 * (is_ascii_lowercase(*byte) as u8))\n+        }\n+    }\n+\n+    fn case11_mask_mult_bool_match_range(bytes: &mut [u8]) {\n+        fn is_ascii_lowercase(b: u8) -> bool {\n+            match b {\n+                b'a'...b'z' => true,\n+                _ => false\n+            }\n+        }\n+        for byte in bytes {\n+            *byte &= !(0x20 * (is_ascii_lowercase(*byte) as u8))\n+        }\n+    }\n+\n+    fn case12_mask_shifted_bool_match_range(bytes: &mut [u8]) {\n+        fn is_ascii_lowercase(b: u8) -> bool {\n+            match b {\n+                b'a'...b'z' => true,\n+                _ => false\n+            }\n+        }\n+        for byte in bytes {\n+            *byte &= !((is_ascii_lowercase(*byte) as u8) << 5)\n+        }\n+    }\n+\n+    fn case13_subtract_shifted_bool_match_range(bytes: &mut [u8]) {\n+        fn is_ascii_lowercase(b: u8) -> bool {\n+            match b {\n+                b'a'...b'z' => true,\n+                _ => false\n+            }\n+        }\n+        for byte in bytes {\n+            *byte -= (is_ascii_lowercase(*byte) as u8) << 5\n+        }\n+    }\n+\n+    fn case14_subtract_multiplied_bool_match_range(bytes: &mut [u8]) {\n+        fn is_ascii_lowercase(b: u8) -> bool {\n+            match b {\n+                b'a'...b'z' => true,\n+                _ => false\n+            }\n+        }\n+        for byte in bytes {\n+            *byte -= (b'a' - b'A') * is_ascii_lowercase(*byte) as u8\n+        }\n+    }\n+\n+    @iter\n+\n+    is_ascii,\n+    is_ascii_alphabetic,\n+    is_ascii_uppercase,\n+    is_ascii_lowercase,\n+    is_ascii_alphanumeric,\n+    is_ascii_digit,\n+    is_ascii_hexdigit,\n+    is_ascii_punctuation,\n+    is_ascii_graphic,\n+    is_ascii_whitespace,\n+    is_ascii_control,\n+}\n+\n+macro_rules! repeat {\n+    ($s: expr) => { concat!($s, $s, $s, $s, $s, $s, $s, $s, $s, $s) }\n+}\n+\n+const SHORT: &'static str = \"Alice's\";\n+const MEDIUM: &'static str = \"Alice's Adventures in Wonderland\";\n+const LONG: &'static str = repeat!(r#\"\n+    La Guida di Bragia, a Ballad Opera for the Marionette Theatre (around 1850)\n+    Alice's Adventures in Wonderland (1865)\n+    Phantasmagoria and Other Poems (1869)\n+    Through the Looking-Glass, and What Alice Found There\n+        (includes \"Jabberwocky\" and \"The Walrus and the Carpenter\") (1871)\n+    The Hunting of the Snark (1876)\n+    Rhyme? And Reason? (1883) \u2013 shares some contents with the 1869 collection,\n+        including the long poem \"Phantasmagoria\"\n+    A Tangled Tale (1885)\n+    Sylvie and Bruno (1889)\n+    Sylvie and Bruno Concluded (1893)\n+    Pillow Problems (1893)\n+    What the Tortoise Said to Achilles (1895)\n+    Three Sunsets and Other Poems (1898)\n+    The Manlet (1903)[106]\n+\"#);\n+\n+const ASCII_UPPERCASE_MAP: [u8; 256] = [\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n+    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n+    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n+    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n+    b'@', b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n+    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n+    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n+    b'X', b'Y', b'Z', b'[', b'\\\\', b']', b'^', b'_',\n+    b'`',\n+\n+          b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n+    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n+    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n+    b'X', b'Y', b'Z',\n+\n+                      b'{', b'|', b'}', b'~', 0x7f,\n+    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n+    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n+    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n+    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n+    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n+    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n+    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n+    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n+    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n+    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n+    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n+    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n+    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n+    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n+    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n+];\n+\n+enum AsciiCharacterClass {\n+    C,  // control\n+    Cw, // control whitespace\n+    W,  // whitespace\n+    D,  // digit\n+    L,  // lowercase\n+    Lx, // lowercase hex digit\n+    U,  // uppercase\n+    Ux, // uppercase hex digit\n+    P,  // punctuation\n+    N,  // Non-ASCII\n+}\n+use self::AsciiCharacterClass::*;\n+\n+static ASCII_CHARACTER_CLASS: [AsciiCharacterClass; 256] = [\n+//  _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _a _b _c _d _e _f\n+    C, C, C, C, C, C, C, C, C, Cw,Cw,C, Cw,Cw,C, C, // 0_\n+    C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, // 1_\n+    W, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, // 2_\n+    D, D, D, D, D, D, D, D, D, D, P, P, P, P, P, P, // 3_\n+    P, Ux,Ux,Ux,Ux,Ux,Ux,U, U, U, U, U, U, U, U, U, // 4_\n+    U, U, U, U, U, U, U, U, U, U, U, P, P, P, P, P, // 5_\n+    P, Lx,Lx,Lx,Lx,Lx,Lx,L, L, L, L, L, L, L, L, L, // 6_\n+    L, L, L, L, L, L, L, L, L, L, L, P, P, P, P, C, // 7_\n+    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n+    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n+    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n+    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n+    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n+    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n+    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n+    N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,\n+];"}, {"sha": "707cdd5f450ea970bb727235b2b87a600897fcfb", "filename": "src/libcore/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Flib.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -5,6 +5,7 @@ extern crate core;\n extern crate test;\n \n mod any;\n+mod ascii;\n mod char;\n mod hash;\n mod iter;"}, {"sha": "a6c65e890a5ed73bd7679e0ab8b47c94d81fc65d", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -363,6 +363,12 @@ pub trait Into<T>: Sized {\n /// [`from`]: trait.From.html#tymethod.from\n /// [book]: ../../book/ch09-00-error-handling.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented(\n+    on(\n+        all(_Self=\"&str\", T=\"std::string::String\"),\n+        note=\"to coerce a `{T}` into a `{Self}`, use `&*` as a prefix\",\n+    )\n+)]\n pub trait From<T>: Sized {\n     /// Performs the conversion.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "5f4c6f7b0a3f0a300bef7810bfc28b544e0e17b1", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -10,8 +10,8 @@ fn float_to_decimal_common_exact<T>(fmt: &mut Formatter, num: &T,\n     where T: flt2dec::DecodableFloat\n {\n     unsafe {\n-        let mut buf = MaybeUninit::<[u8; 1024]>::uninitialized(); // enough for f32 and f64\n-        let mut parts = MaybeUninit::<[flt2dec::Part; 4]>::uninitialized();\n+        let mut buf = MaybeUninit::<[u8; 1024]>::uninit(); // enough for f32 and f64\n+        let mut parts = MaybeUninit::<[flt2dec::Part; 4]>::uninit();\n         // FIXME(#53491): Technically, this is calling `get_mut` on an uninitialized\n         // `MaybeUninit` (here and elsewhere in this file).  Revisit this once\n         // we decided whether that is valid or not.\n@@ -32,8 +32,8 @@ fn float_to_decimal_common_shortest<T>(fmt: &mut Formatter, num: &T,\n {\n     unsafe {\n         // enough for f32 and f64\n-        let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninitialized();\n-        let mut parts = MaybeUninit::<[flt2dec::Part; 4]>::uninitialized();\n+        let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninit();\n+        let mut parts = MaybeUninit::<[flt2dec::Part; 4]>::uninit();\n         // FIXME(#53491)\n         let formatted = flt2dec::to_shortest_str(flt2dec::strategy::grisu::format_shortest, *num,\n                                                  sign, precision, false, buf.get_mut(),\n@@ -71,8 +71,8 @@ fn float_to_exponential_common_exact<T>(fmt: &mut Formatter, num: &T,\n     where T: flt2dec::DecodableFloat\n {\n     unsafe {\n-        let mut buf = MaybeUninit::<[u8; 1024]>::uninitialized(); // enough for f32 and f64\n-        let mut parts = MaybeUninit::<[flt2dec::Part; 6]>::uninitialized();\n+        let mut buf = MaybeUninit::<[u8; 1024]>::uninit(); // enough for f32 and f64\n+        let mut parts = MaybeUninit::<[flt2dec::Part; 6]>::uninit();\n         // FIXME(#53491)\n         let formatted = flt2dec::to_exact_exp_str(flt2dec::strategy::grisu::format_exact,\n                                                   *num, sign, precision,\n@@ -91,8 +91,8 @@ fn float_to_exponential_common_shortest<T>(fmt: &mut Formatter,\n {\n     unsafe {\n         // enough for f32 and f64\n-        let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninitialized();\n-        let mut parts = MaybeUninit::<[flt2dec::Part; 6]>::uninitialized();\n+        let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninit();\n+        let mut parts = MaybeUninit::<[flt2dec::Part; 6]>::uninit();\n         // FIXME(#53491)\n         let formatted = flt2dec::to_shortest_exp_str(flt2dec::strategy::grisu::format_shortest,\n                                                      *num, sign, (0, 0), upper,"}, {"sha": "e96dbcaa14416b984f1d32323f4b81bdb7f09d33", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -60,7 +60,7 @@ trait GenericRadix {\n             for byte in buf.iter_mut().rev() {\n                 let n = x % base;               // Get the current place value.\n                 x = x / base;                   // Deaccumulate the number.\n-                byte.set(Self::digit(n.to_u8())); // Store the digit in the buffer.\n+                byte.write(Self::digit(n.to_u8())); // Store the digit in the buffer.\n                 curr -= 1;\n                 if x == zero {\n                     // No more digits left to accumulate.\n@@ -72,7 +72,7 @@ trait GenericRadix {\n             for byte in buf.iter_mut().rev() {\n                 let n = zero - (x % base);      // Get the current place value.\n                 x = x / base;                   // Deaccumulate the number.\n-                byte.set(Self::digit(n.to_u8())); // Store the digit in the buffer.\n+                byte.write(Self::digit(n.to_u8())); // Store the digit in the buffer.\n                 curr -= 1;\n                 if x == zero {\n                     // No more digits left to accumulate."}, {"sha": "ad8ce1af1f6a11830a193b32f9c6eeb9ab95c43e", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -626,12 +626,12 @@ macro_rules! todo {\n #[macro_export]\n #[unstable(feature = \"maybe_uninit_array\", issue = \"53491\")]\n macro_rules! uninitialized_array {\n-    // This `into_initialized` is safe because an array of `MaybeUninit` does not\n+    // This `assume_init` is safe because an array of `MaybeUninit` does not\n     // require initialization.\n     // FIXME(#49147): Could be replaced by an array initializer, once those can\n     // be any const expression.\n     ($t:ty; $size:expr) => (unsafe {\n-        MaybeUninit::<[MaybeUninit<$t>; $size]>::uninitialized().into_initialized()\n+        MaybeUninit::<[MaybeUninit<$t>; $size]>::uninit().assume_init()\n     });\n }\n "}, {"sha": "66bcf1f7d0101c867d02e5b5cb56b526915062cc", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 72, "deletions": 38, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -622,7 +622,7 @@ pub unsafe fn zeroed<T>() -> T {\n /// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n /// [`Drop`]: ../ops/trait.Drop.html\n #[inline]\n-#[rustc_deprecated(since = \"2.0.0\", reason = \"use `mem::MaybeUninit::uninitialized` instead\")]\n+#[rustc_deprecated(since = \"2.0.0\", reason = \"use `mem::MaybeUninit::uninit` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::panic_if_uninhabited::<T>();\n@@ -1058,7 +1058,7 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n ///\n /// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n /// // The equivalent code with `MaybeUninit<&i32>`:\n-/// let x: &i32 = unsafe { MaybeUninit::zeroed().into_initialized() }; // undefined behavior!\n+/// let x: &i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior!\n /// ```\n ///\n /// This is exploited by the compiler for various optimizations, such as eliding\n@@ -1073,7 +1073,7 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n ///\n /// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n /// // The equivalent code with `MaybeUninit<bool>`:\n-/// let b: bool = unsafe { MaybeUninit::uninitialized().into_initialized() }; // undefined behavior!\n+/// let b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n /// ```\n ///\n /// Moreover, uninitialized memory is special in that the compiler knows that\n@@ -1087,7 +1087,7 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n ///\n /// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n /// // The equivalent code with `MaybeUninit<i32>`:\n-/// let x: i32 = unsafe { MaybeUninit::uninitialized().into_initialized() }; // undefined behavior!\n+/// let x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n /// ```\n /// (Notice that the rules around uninitialized integers are not finalized yet, but\n /// until they are, it is advisable to avoid them.)\n@@ -1102,12 +1102,12 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n ///\n /// // Create an explicitly uninitialized reference. The compiler knows that data inside\n /// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n-/// let mut x = MaybeUninit::<&i32>::uninitialized();\n+/// let mut x = MaybeUninit::<&i32>::uninit();\n /// // Set it to a valid value.\n-/// x.set(&0);\n+/// x.write(&0);\n /// // Extract the initialized data -- this is only allowed *after* properly\n /// // initializing `x`!\n-/// let x = unsafe { x.into_initialized() };\n+/// let x = unsafe { x.assume_init() };\n /// ```\n ///\n /// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n@@ -1148,10 +1148,19 @@ impl<T> MaybeUninit<T> {\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n-    pub const fn uninitialized() -> MaybeUninit<T> {\n+    pub const fn uninit() -> MaybeUninit<T> {\n         MaybeUninit { uninit: () }\n     }\n \n+    /// Deprecated before stabilization.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    // FIXME: still used by stdsimd\n+    // #[rustc_deprecated(since = \"1.35.0\", reason = \"use `uninit` instead\")]\n+    pub const fn uninitialized() -> MaybeUninit<T> {\n+        Self::uninit()\n+    }\n+\n     /// Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n     /// filled with `0` bytes. It depends on `T` whether that already makes for\n     /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n@@ -1171,7 +1180,7 @@ impl<T> MaybeUninit<T> {\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let x = MaybeUninit::<(u8, bool)>::zeroed();\n-    /// let x = unsafe { x.into_initialized() };\n+    /// let x = unsafe { x.assume_init() };\n     /// assert_eq!(x, (0, false));\n     /// ```\n     ///\n@@ -1185,14 +1194,14 @@ impl<T> MaybeUninit<T> {\n     /// enum NotZero { One = 1, Two = 2 };\n     ///\n     /// let x = MaybeUninit::<(u8, NotZero)>::zeroed();\n-    /// let x = unsafe { x.into_initialized() };\n+    /// let x = unsafe { x.assume_init() };\n     /// // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n     /// // This is undefined behavior.\n     /// ```\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline]\n     pub fn zeroed() -> MaybeUninit<T> {\n-        let mut u = MaybeUninit::<T>::uninitialized();\n+        let mut u = MaybeUninit::<T>::uninit();\n         unsafe {\n             u.as_mut_ptr().write_bytes(0u8, 1);\n         }\n@@ -1205,13 +1214,21 @@ impl<T> MaybeUninit<T> {\n     /// reference to the (now safely initialized) contents of `self`.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n-    pub fn set(&mut self, val: T) -> &mut T {\n+    pub fn write(&mut self, val: T) -> &mut T {\n         unsafe {\n             self.value = ManuallyDrop::new(val);\n             self.get_mut()\n         }\n     }\n \n+    /// Deprecated before stabilization.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    #[rustc_deprecated(since = \"1.35.0\", reason = \"use `write` instead\")]\n+    pub fn set(&mut self, val: T) -> &mut T {\n+        self.write(val)\n+    }\n+\n     /// Gets a pointer to the contained value. Reading from this pointer or turning it\n     /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n     ///\n@@ -1223,7 +1240,7 @@ impl<T> MaybeUninit<T> {\n     /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n-    /// let mut x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n     /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n     /// // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n     /// let x_vec = unsafe { &*x.as_ptr() };\n@@ -1236,7 +1253,7 @@ impl<T> MaybeUninit<T> {\n     /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n-    /// let x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n     /// let x_vec = unsafe { &*x.as_ptr() };\n     /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n     /// ```\n@@ -1260,7 +1277,7 @@ impl<T> MaybeUninit<T> {\n     /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n-    /// let mut x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n     /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n     /// // Create a reference into the `MaybeUninit<Vec<u32>>`.\n     /// // This is okay because we initialized it.\n@@ -1275,7 +1292,7 @@ impl<T> MaybeUninit<T> {\n     /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n-    /// let mut x = MaybeUninit::<Vec<u32>>::uninitialized();\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n     /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n     /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n     /// ```\n@@ -1306,9 +1323,9 @@ impl<T> MaybeUninit<T> {\n     /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n-    /// let mut x = MaybeUninit::<bool>::uninitialized();\n+    /// let mut x = MaybeUninit::<bool>::uninit();\n     /// unsafe { x.as_mut_ptr().write(true); }\n-    /// let x_init = unsafe { x.into_initialized() };\n+    /// let x_init = unsafe { x.assume_init() };\n     /// assert_eq!(x_init, true);\n     /// ```\n     ///\n@@ -1318,21 +1335,30 @@ impl<T> MaybeUninit<T> {\n     /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n-    /// let x = MaybeUninit::<Vec<u32>>::uninitialized();\n-    /// let x_init = unsafe { x.into_initialized() };\n+    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// let x_init = unsafe { x.assume_init() };\n     /// // `x` had not been initialized yet, so this last line caused undefined behavior.\n     /// ```\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n-    pub unsafe fn into_initialized(self) -> T {\n+    pub unsafe fn assume_init(self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();\n         ManuallyDrop::into_inner(self.value)\n     }\n \n+    /// Deprecated before stabilization.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    // FIXME: still used by stdsimd\n+    // #[rustc_deprecated(since = \"1.35.0\", reason = \"use `assume_init` instead\")]\n+    pub unsafe fn into_initialized(self) -> T {\n+        self.assume_init()\n+    }\n+\n     /// Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n     /// to the usual drop handling.\n     ///\n-    /// Whenever possible, it is preferrable to use [`into_initialized`] instead, which\n+    /// Whenever possible, it is preferrable to use [`assume_init`] instead, which\n     /// prevents duplicating the content of the `MaybeUninit<T>`.\n     ///\n     /// # Safety\n@@ -1342,11 +1368,11 @@ impl<T> MaybeUninit<T> {\n     /// behavior.\n     ///\n     /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n-    /// multiple copies of the data (by calling `read_initialized` multiple times, or first\n-    /// calling `read_initialized` and then [`into_initialized`]), it is your responsibility\n+    /// multiple copies of the data (by calling `read` multiple times, or first\n+    /// calling `read` and then [`assume_init`]), it is your responsibility\n     /// to ensure that that data may indeed be duplicated.\n     ///\n-    /// [`into_initialized`]: #method.into_initialized\n+    /// [`assume_init`]: #method.assume_init\n     ///\n     /// # Examples\n     ///\n@@ -1356,18 +1382,18 @@ impl<T> MaybeUninit<T> {\n     /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n-    /// let mut x = MaybeUninit::<u32>::uninitialized();\n-    /// x.set(13);\n-    /// let x1 = unsafe { x.read_initialized() };\n+    /// let mut x = MaybeUninit::<u32>::uninit();\n+    /// x.write(13);\n+    /// let x1 = unsafe { x.read() };\n     /// // `u32` is `Copy`, so we may read multiple times.\n-    /// let x2 = unsafe { x.read_initialized() };\n+    /// let x2 = unsafe { x.read() };\n     /// assert_eq!(x1, x2);\n     ///\n-    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninitialized();\n-    /// x.set(None);\n-    /// let x1 = unsafe { x.read_initialized() };\n+    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n+    /// x.write(None);\n+    /// let x1 = unsafe { x.read() };\n     /// // Duplicating a `None` value is okay, so we may read multiple times.\n-    /// let x2 = unsafe { x.read_initialized() };\n+    /// let x2 = unsafe { x.read() };\n     /// assert_eq!(x1, x2);\n     /// ```\n     ///\n@@ -1377,20 +1403,28 @@ impl<T> MaybeUninit<T> {\n     /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n-    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninitialized();\n-    /// x.set(Some(vec![0,1,2]));\n-    /// let x1 = unsafe { x.read_initialized() };\n-    /// let x2 = unsafe { x.read_initialized() };\n+    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n+    /// x.write(Some(vec![0,1,2]));\n+    /// let x1 = unsafe { x.read() };\n+    /// let x2 = unsafe { x.read() };\n     /// // We now created two copies of the same vector, leading to a double-free when\n     /// // they both get dropped!\n     /// ```\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n-    pub unsafe fn read_initialized(&self) -> T {\n+    pub unsafe fn read(&self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();\n         self.as_ptr().read()\n     }\n \n+    /// Deprecated before stabilization.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    #[rustc_deprecated(since = \"1.35.0\", reason = \"use `read` instead\")]\n+    pub unsafe fn read_initialized(&self) -> T {\n+        self.read()\n+    }\n+\n     /// Gets a reference to the contained value.\n     ///\n     /// # Safety"}, {"sha": "3fcae6b94b06d855c2d9fa291e879f79b8fe3863", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 24, "deletions": 135, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -3794,7 +3794,8 @@ impl u8 {\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_uppercase(&self) -> u8 {\n-        ASCII_UPPERCASE_MAP[*self as usize]\n+        // Unset the fith bit if this is a lowercase letter\n+        *self & !((self.is_ascii_lowercase() as u8) << 5)\n     }\n \n     /// Makes a copy of the value in its ASCII lower case equivalent.\n@@ -3816,7 +3817,8 @@ impl u8 {\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_lowercase(&self) -> u8 {\n-        ASCII_LOWERCASE_MAP[*self as usize]\n+        // Set the fith bit if this is an uppercase letter\n+        *self | ((self.is_ascii_uppercase() as u8) << 5)\n     }\n \n     /// Checks that two values are an ASCII case-insensitive match.\n@@ -3918,9 +3920,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_alphabetic(&self) -> bool {\n-        if *self >= 0x80 { return false; }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            L | Lx | U | Ux => true,\n+        match *self {\n+            b'A'...b'Z' | b'a'...b'z' => true,\n             _ => false\n         }\n     }\n@@ -3954,9 +3955,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_uppercase(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            U | Ux => true,\n+        match *self {\n+            b'A'...b'Z' => true,\n             _ => false\n         }\n     }\n@@ -3990,9 +3990,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_lowercase(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            L | Lx => true,\n+        match *self {\n+            b'a'...b'z' => true,\n             _ => false\n         }\n     }\n@@ -4029,9 +4028,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_alphanumeric(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            D | L | Lx | U | Ux => true,\n+        match *self {\n+            b'0'...b'9' | b'A'...b'Z' | b'a'...b'z' => true,\n             _ => false\n         }\n     }\n@@ -4065,9 +4063,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_digit(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            D => true,\n+        match *self {\n+            b'0'...b'9' => true,\n             _ => false\n         }\n     }\n@@ -4104,9 +4101,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_hexdigit(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            D | Lx | Ux => true,\n+        match *self {\n+            b'0'...b'9' | b'A'...b'F' | b'a'...b'f' => true,\n             _ => false\n         }\n     }\n@@ -4144,9 +4140,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_punctuation(&self) -> bool {\n-        if *self >= 0x80 { return false }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            P => true,\n+        match *self {\n+            b'!'...b'/' | b':'...b'@' | b'['...b'`' | b'{'...b'~' => true,\n             _ => false\n         }\n     }\n@@ -4180,9 +4175,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_graphic(&self) -> bool {\n-        if *self >= 0x80 { return false; }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            Ux | U | Lx | L | D | P => true,\n+        match *self {\n+            b'!'...b'~' => true,\n             _ => false\n         }\n     }\n@@ -4233,9 +4227,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_whitespace(&self) -> bool {\n-        if *self >= 0x80 { return false; }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            Cw | W => true,\n+        match *self {\n+            b'\\t' | b'\\n' | b'\\x0C' | b'\\r' | b' ' => true,\n             _ => false\n         }\n     }\n@@ -4271,9 +4264,8 @@ impl u8 {\n     #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_control(&self) -> bool {\n-        if *self >= 0x80 { return false; }\n-        match ASCII_CHARACTER_CLASS[*self as usize] {\n-            C | Cw => true,\n+        match *self {\n+            b'\\0'...b'\\x1F' | b'\\x7F' => true,\n             _ => false\n         }\n     }\n@@ -4939,106 +4931,3 @@ impl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\"\n \n // Float -> Float\n impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n-\n-static ASCII_LOWERCASE_MAP: [u8; 256] = [\n-    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n-    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n-    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n-    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n-    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n-    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n-    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n-    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n-    b'@',\n-\n-          b'a', b'b', b'c', b'd', b'e', b'f', b'g',\n-    b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o',\n-    b'p', b'q', b'r', b's', b't', b'u', b'v', b'w',\n-    b'x', b'y', b'z',\n-\n-                      b'[', b'\\\\', b']', b'^', b'_',\n-    b'`', b'a', b'b', b'c', b'd', b'e', b'f', b'g',\n-    b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o',\n-    b'p', b'q', b'r', b's', b't', b'u', b'v', b'w',\n-    b'x', b'y', b'z', b'{', b'|', b'}', b'~', 0x7f,\n-    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n-    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n-    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n-    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n-    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n-    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n-    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n-    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n-    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n-    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n-    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n-    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n-    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n-    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n-    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n-    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n-];\n-\n-static ASCII_UPPERCASE_MAP: [u8; 256] = [\n-    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n-    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n-    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n-    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n-    b' ', b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'',\n-    b'(', b')', b'*', b'+', b',', b'-', b'.', b'/',\n-    b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7',\n-    b'8', b'9', b':', b';', b'<', b'=', b'>', b'?',\n-    b'@', b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n-    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n-    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n-    b'X', b'Y', b'Z', b'[', b'\\\\', b']', b'^', b'_',\n-    b'`',\n-\n-          b'A', b'B', b'C', b'D', b'E', b'F', b'G',\n-    b'H', b'I', b'J', b'K', b'L', b'M', b'N', b'O',\n-    b'P', b'Q', b'R', b'S', b'T', b'U', b'V', b'W',\n-    b'X', b'Y', b'Z',\n-\n-                      b'{', b'|', b'}', b'~', 0x7f,\n-    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n-    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n-    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n-    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n-    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n-    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n-    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n-    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n-    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n-    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n-    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n-    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n-    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n-    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n-    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n-    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n-];\n-\n-enum AsciiCharacterClass {\n-    C,  // control\n-    Cw, // control whitespace\n-    W,  // whitespace\n-    D,  // digit\n-    L,  // lowercase\n-    Lx, // lowercase hex digit\n-    U,  // uppercase\n-    Ux, // uppercase hex digit\n-    P,  // punctuation\n-}\n-use self::AsciiCharacterClass::*;\n-\n-static ASCII_CHARACTER_CLASS: [AsciiCharacterClass; 128] = [\n-//  _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _a _b _c _d _e _f\n-    C, C, C, C, C, C, C, C, C, Cw,Cw,C, Cw,Cw,C, C, // 0_\n-    C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, // 1_\n-    W, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, // 2_\n-    D, D, D, D, D, D, D, D, D, D, P, P, P, P, P, P, // 3_\n-    P, Ux,Ux,Ux,Ux,Ux,Ux,U, U, U, U, U, U, U, U, U, // 4_\n-    U, U, U, U, U, U, U, U, U, U, U, P, P, P, P, P, // 5_\n-    P, Lx,Lx,Lx,Lx,Lx,Lx,L, L, L, L, L, L, L, L, L, // 6_\n-    L, L, L, L, L, L, L, L, L, L, L, P, P, P, P, C, // 7_\n-];"}, {"sha": "dabf914fdb2cd4eeedd761ac9b8f32f08319faa2", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 55, "deletions": 9, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -296,7 +296,7 @@ pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Give ourselves some scratch space to work with.\n     // We do not have to worry about drops: `MaybeUninit` does nothing when dropped.\n-    let mut tmp = MaybeUninit::<T>::uninitialized();\n+    let mut tmp = MaybeUninit::<T>::uninit();\n \n     // Perform the swap\n     copy_nonoverlapping(x, tmp.as_mut_ptr(), 1);\n@@ -388,7 +388,7 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n     while i + block_size <= len {\n         // Create some uninitialized memory as scratch space\n         // Declaring `t` here avoids aligning the stack when this loop is unused\n-        let mut t = mem::MaybeUninit::<Block>::uninitialized();\n+        let mut t = mem::MaybeUninit::<Block>::uninit();\n         let t = t.as_mut_ptr() as *mut u8;\n         let x = x.add(i);\n         let y = y.add(i);\n@@ -403,7 +403,7 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n \n     if i < len {\n         // Swap any remaining bytes\n-        let mut t = mem::MaybeUninit::<UnalignedBlock>::uninitialized();\n+        let mut t = mem::MaybeUninit::<UnalignedBlock>::uninit();\n         let rem = len - i;\n \n         let t = t.as_mut_ptr() as *mut u8;\n@@ -571,9 +571,9 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n-    let mut tmp = MaybeUninit::<T>::uninitialized();\n+    let mut tmp = MaybeUninit::<T>::uninit();\n     copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-    tmp.into_initialized()\n+    tmp.assume_init()\n }\n \n /// Reads the value from `src` without moving it. This leaves the\n@@ -638,11 +638,11 @@ pub unsafe fn read<T>(src: *const T) -> T {\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n-    let mut tmp = MaybeUninit::<T>::uninitialized();\n+    let mut tmp = MaybeUninit::<T>::uninit();\n     copy_nonoverlapping(src as *const u8,\n                         tmp.as_mut_ptr() as *mut u8,\n                         mem::size_of::<T>());\n-    tmp.into_initialized()\n+    tmp.assume_init()\n }\n \n /// Overwrites a memory location with the given value without reading or\n@@ -2495,11 +2495,57 @@ impl<T: ?Sized> Eq for *mut T {}\n /// let other_five_ref = &other_five;\n ///\n /// assert!(five_ref == same_five_ref);\n-/// assert!(five_ref == other_five_ref);\n-///\n /// assert!(ptr::eq(five_ref, same_five_ref));\n+///\n+/// assert!(five_ref == other_five_ref);\n /// assert!(!ptr::eq(five_ref, other_five_ref));\n /// ```\n+///\n+/// Slices are also compared by their length (fat pointers):\n+///\n+/// ```\n+/// let a = [1, 2, 3];\n+/// assert!(std::ptr::eq(&a[..3], &a[..3]));\n+/// assert!(!std::ptr::eq(&a[..2], &a[..3]));\n+/// assert!(!std::ptr::eq(&a[0..2], &a[1..3]));\n+/// ```\n+///\n+/// Traits are also compared by their implementation:\n+///\n+/// ```\n+/// #[repr(transparent)]\n+/// struct Wrapper { member: i32 }\n+///\n+/// trait Trait {}\n+/// impl Trait for Wrapper {}\n+/// impl Trait for i32 {}\n+///\n+/// fn main() {\n+///     let wrapper = Wrapper { member: 10 };\n+///\n+///     // Pointers have equal addresses.\n+///     assert!(std::ptr::eq(\n+///         &wrapper as *const Wrapper as *const u8,\n+///         &wrapper.member as *const i32 as *const u8\n+///     ));\n+///\n+///     // Objects have equal addresses, but `Trait` has different implementations.\n+///     assert!(!std::ptr::eq(\n+///         &wrapper as &dyn Trait,\n+///         &wrapper.member as &dyn Trait,\n+///     ));\n+///     assert!(!std::ptr::eq(\n+///         &wrapper as &dyn Trait as *const dyn Trait,\n+///         &wrapper.member as &dyn Trait as *const dyn Trait,\n+///     ));\n+///\n+///     // Converting the reference to a `*const u8` compares by address.\n+///     assert!(std::ptr::eq(\n+///         &wrapper as &dyn Trait as *const dyn Trait as *const u8,\n+///         &wrapper.member as &dyn Trait as *const dyn Trait as *const u8,\n+///     ));\n+/// }\n+/// ```\n #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n #[inline]\n pub fn eq<T: ?Sized>(a: *const T, b: *const T) -> bool {"}, {"sha": "8f10c3576a787b45bd4ca9a0af4f1468fc301fcc", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -72,7 +72,7 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mid: *mut T, mut right: usize) {\n         }\n     }\n \n-    let mut rawarray = MaybeUninit::<RawArray<T>>::uninitialized();\n+    let mut rawarray = MaybeUninit::<RawArray<T>>::uninit();\n     let buf = &mut (*rawarray.as_mut_ptr()).typed as *mut [T; 2] as *mut T;\n \n     let dim = mid.sub(left).add(right);"}, {"sha": "f54d7badc3ae0cb4a7286074b8721764fd43d319", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -3601,7 +3601,11 @@ impl str {\n     /// assert!(Some('\u05e2') == s.trim_left().chars().next());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(reason = \"superseded by `trim_start`\", since = \"1.33.0\")]\n+    #[rustc_deprecated(\n+        since = \"1.33.0\",\n+        reason = \"superseded by `trim_start`\",\n+        suggestion = \"trim_start\",\n+    )]\n     pub fn trim_left(&self) -> &str {\n         self.trim_start()\n     }\n@@ -3638,7 +3642,11 @@ impl str {\n     /// assert!(Some('\u05ea') == s.trim_right().chars().rev().next());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(reason = \"superseded by `trim_end`\", since = \"1.33.0\")]\n+    #[rustc_deprecated(\n+        since = \"1.33.0\",\n+        reason = \"superseded by `trim_end`\",\n+        suggestion = \"trim_end\",\n+    )]\n     pub fn trim_right(&self) -> &str {\n         self.trim_end()\n     }\n@@ -3802,7 +3810,11 @@ impl str {\n     /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(reason = \"superseded by `trim_start_matches`\", since = \"1.33.0\")]\n+    #[rustc_deprecated(\n+        since = \"1.33.0\",\n+        reason = \"superseded by `trim_start_matches`\",\n+        suggestion = \"trim_start_matches\",\n+    )]\n     pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n         self.trim_start_matches(pat)\n     }\n@@ -3840,7 +3852,11 @@ impl str {\n     /// assert_eq!(\"1fooX\".trim_right_matches(|c| c == '1' || c == 'X'), \"1foo\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(reason = \"superseded by `trim_end_matches`\", since = \"1.33.0\")]\n+    #[rustc_deprecated(\n+        since = \"1.33.0\",\n+        reason = \"superseded by `trim_end_matches`\",\n+        suggestion = \"trim_end_matches\",\n+    )]\n     pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n         where P::Searcher: ReverseSearcher<'a>\n     {"}, {"sha": "c7ed1612dd5eaa1ce96b5e4514cadf7c0bdd2edf", "filename": "src/libcore/tests/tuple.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Ftests%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibcore%2Ftests%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftuple.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -1,4 +1,5 @@\n use std::cmp::Ordering::{Equal, Less, Greater};\n+use std::f64::NAN;\n \n #[test]\n fn test_clone() {\n@@ -8,18 +9,18 @@ fn test_clone() {\n }\n \n #[test]\n-fn test_tuple_cmp() {\n+fn test_partial_eq() {\n     let (small, big) = ((1, 2, 3), (3, 2, 1));\n-\n-    let nan = 0.0f64/0.0;\n-\n-    // PartialEq\n     assert_eq!(small, small);\n     assert_eq!(big, big);\n-    assert!(small != big);\n-    assert!(big != small);\n+    assert_ne!(small, big);\n+    assert_ne!(big, small);\n+}\n+\n+#[test]\n+fn test_partial_ord() {\n+    let (small, big) = ((1, 2, 3), (3, 2, 1));\n \n-    // PartialOrd\n     assert!(small < big);\n     assert!(!(small < small));\n     assert!(!(big < small));\n@@ -33,18 +34,21 @@ fn test_tuple_cmp() {\n     assert!(big >= small);\n     assert!(big >= big);\n \n-    assert!(!((1.0f64, 2.0f64) < (nan, 3.0)));\n-    assert!(!((1.0f64, 2.0f64) <= (nan, 3.0)));\n-    assert!(!((1.0f64, 2.0f64) > (nan, 3.0)));\n-    assert!(!((1.0f64, 2.0f64) >= (nan, 3.0)));\n-    assert!(((1.0f64, 2.0f64) < (2.0, nan)));\n-    assert!(!((2.0f64, 2.0f64) < (2.0, nan)));\n-\n-    // Ord\n-    assert!(small.cmp(&small) == Equal);\n-    assert!(big.cmp(&big) == Equal);\n-    assert!(small.cmp(&big) == Less);\n-    assert!(big.cmp(&small) == Greater);\n+    assert!(!((1.0f64, 2.0f64) < (NAN, 3.0)));\n+    assert!(!((1.0f64, 2.0f64) <= (NAN, 3.0)));\n+    assert!(!((1.0f64, 2.0f64) > (NAN, 3.0)));\n+    assert!(!((1.0f64, 2.0f64) >= (NAN, 3.0)));\n+    assert!(((1.0f64, 2.0f64) < (2.0, NAN)));\n+    assert!(!((2.0f64, 2.0f64) < (2.0, NAN)));\n+}\n+\n+#[test]\n+fn test_ord() {\n+    let (small, big) = ((1, 2, 3), (3, 2, 1));\n+    assert_eq!(small.cmp(&small), Equal);\n+    assert_eq!(big.cmp(&big), Equal);\n+    assert_eq!(small.cmp(&big), Less);\n+    assert_eq!(big.cmp(&small), Greater);\n }\n \n #[test]"}, {"sha": "9c6d03af9f51bc4c9056c7b77e3682907d0ad004", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -469,6 +469,7 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     [] UnsafetyCheckResult(DefId),\n     [] UnsafeDeriveOnReprPacked(DefId),\n \n+    [] LintMod(DefId),\n     [] CheckModAttrs(DefId),\n     [] CheckModLoops(DefId),\n     [] CheckModUnstableApiUsage(DefId),"}, {"sha": "2ffb4959951b8896cefcb4eeaade5123baf2cef3", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -580,17 +580,17 @@ impl<'hir> Map<'hir> {\n         &self.forest.krate.attrs\n     }\n \n-    pub fn get_module(&self, module: DefId) -> (&'hir Mod, Span, NodeId)\n-    {\n+    pub fn get_module(&self, module: DefId) -> (&'hir Mod, Span, HirId) {\n         let node_id = self.as_local_node_id(module).unwrap();\n+        let hir_id = self.node_to_hir_id(node_id);\n         self.read(node_id);\n         match self.find_entry(node_id).unwrap().node {\n             Node::Item(&Item {\n                 span,\n                 node: ItemKind::Mod(ref m),\n                 ..\n-            }) => (m, span, node_id),\n-            Node::Crate => (&self.forest.krate.module, self.forest.krate.span, node_id),\n+            }) => (m, span, hir_id),\n+            Node::Crate => (&self.forest.krate.module, self.forest.krate.span, hir_id),\n             _ => panic!(\"not a module\")\n         }\n     }\n@@ -1013,7 +1013,7 @@ impl<'hir> Map<'hir> {\n     /// corresponding to the Node ID\n     pub fn attrs(&self, id: NodeId) -> &'hir [ast::Attribute] {\n         self.read(id); // reveals attributes on the node\n-        let attrs = match self.find(id) {\n+        let attrs = match self.find_entry(id).map(|entry| entry.node) {\n             Some(Node::Local(l)) => Some(&l.attrs[..]),\n             Some(Node::Item(i)) => Some(&i.attrs[..]),\n             Some(Node::ForeignItem(fi)) => Some(&fi.attrs[..]),\n@@ -1027,6 +1027,7 @@ impl<'hir> Map<'hir> {\n             // Unit/tuple structs/variants take the attributes straight from\n             // the struct/variant definition.\n             Some(Node::Ctor(..)) => return self.attrs(self.get_parent(id)),\n+            Some(Node::Crate) => Some(&self.forest.krate.attrs[..]),\n             _ => None\n         };\n         attrs.unwrap_or(&[])"}, {"sha": "953d0116aa2ba24d7706f8750d588fc91bcf856f", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 77, "deletions": 9, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -27,6 +27,7 @@ use crate::rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use crate::session::{config, early_error, Session};\n use crate::ty::{self, TyCtxt, Ty};\n use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n+use crate::ty::query::Providers;\n use crate::util::nodemap::FxHashMap;\n use crate::util::common::time;\n \n@@ -36,8 +37,9 @@ use syntax::edition;\n use syntax_pos::{MultiSpan, Span, symbol::{LocalInternedString, Symbol}};\n use errors::DiagnosticBuilder;\n use crate::hir;\n-use crate::hir::def_id::LOCAL_CRATE;\n+use crate::hir::def_id::{DefId, LOCAL_CRATE};\n use crate::hir::intravisit as hir_visit;\n+use crate::hir::intravisit::Visitor;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit as ast_visit;\n \n@@ -55,6 +57,7 @@ pub struct LintStore {\n     pre_expansion_passes: Option<Vec<EarlyLintPassObject>>,\n     early_passes: Option<Vec<EarlyLintPassObject>>,\n     late_passes: Option<Vec<LateLintPassObject>>,\n+    late_module_passes: Option<Vec<LateLintPassObject>>,\n \n     /// Lints indexed by name.\n     by_name: FxHashMap<String, TargetLint>,\n@@ -150,6 +153,7 @@ impl LintStore {\n             pre_expansion_passes: Some(vec![]),\n             early_passes: Some(vec![]),\n             late_passes: Some(vec![]),\n+            late_module_passes: Some(vec![]),\n             by_name: Default::default(),\n             future_incompatible: Default::default(),\n             lint_groups: Default::default(),\n@@ -199,9 +203,14 @@ impl LintStore {\n     pub fn register_late_pass(&mut self,\n                               sess: Option<&Session>,\n                               from_plugin: bool,\n+                              per_module: bool,\n                               pass: LateLintPassObject) {\n         self.push_pass(sess, from_plugin, &pass);\n-        self.late_passes.as_mut().unwrap().push(pass);\n+        if per_module {\n+            self.late_module_passes.as_mut().unwrap().push(pass);\n+        } else {\n+            self.late_passes.as_mut().unwrap().push(pass);\n+        }\n     }\n \n     // Helper method for register_early/late_pass\n@@ -508,6 +517,7 @@ pub struct LateContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     /// Side-tables for the body we are in.\n+    // FIXME: Make this lazy to avoid running the TypeckTables query?\n     pub tables: &'a ty::TypeckTables<'tcx>,\n \n     /// Parameter environment for the item we are in.\n@@ -523,6 +533,9 @@ pub struct LateContext<'a, 'tcx: 'a> {\n \n     /// Generic type parameters in scope for the item we are in.\n     pub generics: Option<&'tcx hir::Generics>,\n+\n+    /// We are only looking at one module\n+    only_module: bool,\n }\n \n /// Context for lint checking of the AST, after expansion, before lowering to\n@@ -803,6 +816,12 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     pub fn current_lint_root(&self) -> hir::HirId {\n         self.last_node_with_lint_attrs\n     }\n+\n+    fn process_mod(&mut self, m: &'tcx hir::Mod, s: Span, n: hir::HirId) {\n+        run_lints!(self, check_mod, m, s, n);\n+        hir_visit::walk_mod(self, m, n);\n+        run_lints!(self, check_mod_post, m, s, n);\n+    }\n }\n \n impl<'a, 'tcx> LayoutOf for LateContext<'a, 'tcx> {\n@@ -934,9 +953,9 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_mod(&mut self, m: &'tcx hir::Mod, s: Span, n: hir::HirId) {\n-        run_lints!(self, check_mod, m, s, n);\n-        hir_visit::walk_mod(self, m, n);\n-        run_lints!(self, check_mod_post, m, s, n);\n+        if !self.only_module {\n+            self.process_mod(m, s, n);\n+        }\n     }\n \n     fn visit_local(&mut self, l: &'tcx hir::Local) {\n@@ -1203,11 +1222,48 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n }\n \n+pub fn lint_mod<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n-/// Performs lint checking on a crate.\n-///\n-/// Consumes the `lint_store` field of the `Session`.\n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let store = &tcx.sess.lint_store;\n+    let passes = store.borrow_mut().late_module_passes.take();\n+\n+    let mut cx = LateContext {\n+        tcx,\n+        tables: &ty::TypeckTables::empty(None),\n+        param_env: ty::ParamEnv::empty(),\n+        access_levels,\n+        lint_sess: LintSession {\n+            lints: store.borrow(),\n+            passes,\n+        },\n+        last_node_with_lint_attrs: tcx.hir().as_local_hir_id(module_def_id).unwrap(),\n+        generics: None,\n+        only_module: true,\n+    };\n+\n+    let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n+    cx.process_mod(module, span, hir_id);\n+\n+    // Visit the crate attributes\n+    if hir_id == hir::CRATE_HIR_ID {\n+        walk_list!(cx, visit_attribute, cx.tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID));\n+    }\n+\n+    // Put the lint store levels and passes back in the session.\n+    let passes = cx.lint_sess.passes;\n+    drop(cx.lint_sess.lints);\n+    store.borrow_mut().late_module_passes = passes;\n+}\n+\n+pub(crate) fn provide(providers: &mut Providers<'_>) {\n+    *providers = Providers {\n+        lint_mod,\n+        ..*providers\n+    };\n+}\n+\n+fn lint_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     let krate = tcx.hir().krate();\n@@ -1225,6 +1281,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n             },\n             last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n             generics: None,\n+            only_module: false,\n         };\n \n         // Visit the whole crate.\n@@ -1244,6 +1301,17 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.sess.lint_store.borrow_mut().late_passes = passes;\n }\n \n+/// Performs lint checking on a crate.\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    // Run per-module lints\n+    for &module in tcx.hir().krate().modules.keys() {\n+        tcx.ensure().lint_mod(tcx.hir().local_def_id(module));\n+    }\n+\n+    // Run whole crate non-incremental lints\n+    lint_crate(tcx);\n+}\n+\n struct EarlyLintPassObjects<'a> {\n     lints: &'a mut [EarlyLintPassObject],\n }"}, {"sha": "cf1c5d50000fa9bd8453bb5a716521710c5e9e42", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -824,6 +824,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n \n pub fn provide(providers: &mut Providers<'_>) {\n     providers.lint_levels = lint_levels;\n+    context::provide(providers);\n }\n \n /// Returns whether `span` originates in a foreign crate's external macro."}, {"sha": "0dd8316852780b99c1a2e9fa44c3c624141ce682", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -344,7 +344,7 @@ impl<'tcx> AllocMap<'tcx> {\n         }\n     }\n \n-    /// Returns `None` in case the `AllocId` is dangling. An `EvalContext` can still have a\n+    /// Returns `None` in case the `AllocId` is dangling. An `InterpretCx` can still have a\n     /// local `Allocation` for that `AllocId`, but having such an `AllocId` in a constant is\n     /// illegal and will likely ICE.\n     /// This function exists to allow const eval to detect the difference between evaluation-"}, {"sha": "9c705104d1888dcd60decf29a68450f74304ebea", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -217,6 +217,8 @@ rustc_query_append! { [define_queries!][ <'tcx>\n     },\n \n     Other {\n+        [] fn lint_mod: LintMod(DefId) -> (),\n+\n         /// Checks the attributes in the module\n         [] fn check_mod_attrs: CheckModAttrs(DefId) -> (),\n "}, {"sha": "b2b141fd0f514c688d95043a9cefb3779f35ccd1", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -1262,6 +1262,7 @@ pub fn force_from_dep_node<'tcx>(\n         DepKind::MirBorrowCheck => { force!(mir_borrowck, def_id!()); }\n         DepKind::UnsafetyCheckResult => { force!(unsafety_check_result, def_id!()); }\n         DepKind::UnsafeDeriveOnReprPacked => { force!(unsafe_derive_on_repr_packed, def_id!()); }\n+        DepKind::LintMod => { force!(lint_mod, def_id!()); }\n         DepKind::CheckModAttrs => { force!(check_mod_attrs, def_id!()); }\n         DepKind::CheckModLoops => { force!(check_mod_loops, def_id!()); }\n         DepKind::CheckModUnstableApiUsage => { force!(check_mod_unstable_api_usage, def_id!()); }"}, {"sha": "5432f80a1712c076045f8ccb6f98721537a60999", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustc_driver\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"rustc_driver\"\n@@ -13,14 +14,14 @@ arena = { path = \"../libarena\" }\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.4\"\n env_logger = { version = \"0.5\", default-features = false }\n-rustc-rayon = \"0.1.2\"\n+rayon = { version = \"0.1.2\", package = \"rustc-rayon\" }\n scoped-tls = \"1.0\"\n rustc = { path = \"../librustc\" }\n rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_borrowck = { path = \"../librustc_borrowck\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n-rustc_errors = { path = \"../librustc_errors\" }\n+errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_lint = { path = \"../librustc_lint\" }\n rustc_metadata = { path = \"../librustc_metadata\" }"}, {"sha": "4b7cffaad5509711e6abea758d79171fe47ac9f4", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -16,40 +16,13 @@\n \n #![recursion_limit=\"256\"]\n \n-extern crate arena;\n+#![deny(rust_2018_idioms)]\n+\n pub extern crate getopts;\n-extern crate graphviz;\n-extern crate env_logger;\n #[cfg(unix)]\n extern crate libc;\n-extern crate rustc_rayon as rayon;\n-extern crate rustc;\n-extern crate rustc_allocator;\n-extern crate rustc_target;\n-extern crate rustc_borrowck;\n-extern crate rustc_data_structures;\n-extern crate rustc_errors as errors;\n-extern crate rustc_passes;\n-extern crate rustc_lint;\n-extern crate rustc_plugin;\n-extern crate rustc_privacy;\n-extern crate rustc_incremental;\n-extern crate rustc_metadata;\n-extern crate rustc_mir;\n-extern crate rustc_resolve;\n-extern crate rustc_save_analysis;\n-extern crate rustc_traits;\n-extern crate rustc_codegen_utils;\n-extern crate rustc_typeck;\n-extern crate rustc_interface;\n-extern crate scoped_tls;\n-extern crate serialize;\n-extern crate smallvec;\n #[macro_use]\n extern crate log;\n-extern crate syntax;\n-extern crate syntax_ext;\n-extern crate syntax_pos;\n \n use pretty::{PpMode, UserIdentifiedItem};\n "}, {"sha": "5cefc35607db07f9155b7979549152658ca5ce7c", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -35,9 +35,9 @@ pub use self::UserIdentifiedItem::*;\n pub use self::PpSourceMode::*;\n pub use self::PpMode::*;\n use self::NodesMatchingUII::*;\n-use abort_on_err;\n+use crate::abort_on_err;\n \n-use source_name;\n+use crate::source_name;\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpSourceMode {\n@@ -191,7 +191,7 @@ impl PpSourceMode {\n         tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         f: F\n     ) -> A\n-        where F: FnOnce(&dyn HirPrinterSupport, &hir::Crate) -> A\n+        where F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate) -> A\n     {\n         match *self {\n             PpmNormal => {\n@@ -296,7 +296,7 @@ impl<'hir> HirPrinterSupport<'hir> for NoAnn<'hir> {\n \n impl<'hir> pprust::PpAnn for NoAnn<'hir> {}\n impl<'hir> pprust_hir::PpAnn for NoAnn<'hir> {\n-    fn nested(&self, state: &mut pprust_hir::State, nested: pprust_hir::Nested)\n+    fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested)\n               -> io::Result<()> {\n         if let Some(tcx) = self.tcx {\n             pprust_hir::PpAnn::nested(tcx.hir(), state, nested)\n@@ -322,13 +322,13 @@ impl<'hir> PrinterSupport for IdentifiedAnnotation<'hir> {\n }\n \n impl<'hir> pprust::PpAnn for IdentifiedAnnotation<'hir> {\n-    fn pre(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n+    fn pre(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) -> io::Result<()> {\n         match node {\n             pprust::AnnNode::Expr(_) => s.popen(),\n             _ => Ok(()),\n         }\n     }\n-    fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n+    fn post(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) -> io::Result<()> {\n         match node {\n             pprust::AnnNode::Ident(_) |\n             pprust::AnnNode::Name(_) => Ok(()),\n@@ -373,21 +373,21 @@ impl<'hir> HirPrinterSupport<'hir> for IdentifiedAnnotation<'hir> {\n }\n \n impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n-    fn nested(&self, state: &mut pprust_hir::State, nested: pprust_hir::Nested)\n+    fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested)\n               -> io::Result<()> {\n         if let Some(ref tcx) = self.tcx {\n             pprust_hir::PpAnn::nested(tcx.hir(), state, nested)\n         } else {\n             Ok(())\n         }\n     }\n-    fn pre(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n+    fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) -> io::Result<()> {\n         match node {\n             pprust_hir::AnnNode::Expr(_) => s.popen(),\n             _ => Ok(()),\n         }\n     }\n-    fn post(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n+    fn post(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) -> io::Result<()> {\n         match node {\n             pprust_hir::AnnNode::Name(_) => Ok(()),\n             pprust_hir::AnnNode::Item(item) => {\n@@ -434,7 +434,7 @@ impl<'a> PrinterSupport for HygieneAnnotation<'a> {\n }\n \n impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n-    fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n+    fn post(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) -> io::Result<()> {\n         match node {\n             pprust::AnnNode::Ident(&ast::Ident { name, span }) => {\n                 s.s.space()?;\n@@ -476,7 +476,7 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n }\n \n impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n-    fn nested(&self, state: &mut pprust_hir::State, nested: pprust_hir::Nested)\n+    fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested)\n               -> io::Result<()> {\n         let old_tables = self.tables.get();\n         if let pprust_hir::Nested::Body(id) = nested {\n@@ -486,13 +486,13 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n         self.tables.set(old_tables);\n         Ok(())\n     }\n-    fn pre(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n+    fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) -> io::Result<()> {\n         match node {\n             pprust_hir::AnnNode::Expr(_) => s.popen(),\n             _ => Ok(()),\n         }\n     }\n-    fn post(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n+    fn post(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) -> io::Result<()> {\n         match node {\n             pprust_hir::AnnNode::Expr(expr) => {\n                 s.s.space()?;\n@@ -580,7 +580,11 @@ impl UserIdentifiedItem {\n         }\n     }\n \n-    fn to_one_node_id(self, user_option: &str, sess: &Session, map: &hir_map::Map) -> ast::NodeId {\n+    fn to_one_node_id(self,\n+                      user_option: &str,\n+                      sess: &Session,\n+                      map: &hir_map::Map<'_>)\n+                      -> ast::NodeId {\n         let fail_because = |is_wrong_because| -> ast::NodeId {\n             let message = format!(\"{} needs NodeId (int) or unique path suffix (b::c::d); got \\\n                                    {}, which {}\","}, {"sha": "7f697b5448464ca74bdf7541a736180392eb9556", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -886,7 +886,10 @@ fn safe_remove_dir_all(p: &Path) -> io::Result<()> {\n fn safe_remove_file(p: &Path) -> io::Result<()> {\n     if p.exists() {\n         let canonicalized = p.canonicalize()?;\n-        std_fs::remove_file(canonicalized)\n+        match std_fs::remove_file(canonicalized) {\n+            Err(ref err) if err.kind() == io::ErrorKind::NotFound => Ok(()),\n+            result => result,\n+        }\n     } else {\n         Ok(())\n     }"}, {"sha": "ec934ee48212c254badbd6b9d220a99387348ba8", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustc_interface\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"rustc_interface\"\n@@ -10,7 +11,7 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n log = \"0.4\"\n-rustc-rayon = \"0.1.1\"\n+rayon = { version = \"0.1.1\", package = \"rustc-rayon\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n scoped-tls = \"1.0\"\n syntax = { path = \"../libsyntax\" }"}, {"sha": "bec868be505b50ab86e78f4ffede21177aea71ee", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -1,4 +1,8 @@\n-use queries::Queries;\n+use crate::queries::Queries;\n+use crate::util;\n+use crate::profile;\n+pub use crate::passes::BoxedResolver;\n+\n use rustc::lint;\n use rustc::session::config::{self, Input};\n use rustc::session::{DiagnosticOutput, Session};\n@@ -15,10 +19,6 @@ use std::result;\n use std::sync::{Arc, Mutex};\n use syntax;\n use syntax::source_map::{FileLoader, SourceMap};\n-use util;\n-use profile;\n-\n-pub use passes::BoxedResolver;\n \n pub type Result<T> = result::Result<T, ErrorReported>;\n "}, {"sha": "3314681b6981a5096da6821cddaf61cfa40a13bb", "filename": "src/librustc_interface/lib.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_interface%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_interface%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Flib.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -6,37 +6,14 @@\n #![feature(generators)]\n #![cfg_attr(unix, feature(libc))]\n \n+#![deny(rust_2018_idioms)]\n+\n #![allow(unused_imports)]\n \n #![recursion_limit=\"256\"]\n \n #[cfg(unix)]\n extern crate libc;\n-#[macro_use]\n-extern crate log;\n-extern crate rustc;\n-extern crate rustc_codegen_utils;\n-extern crate rustc_allocator;\n-extern crate rustc_borrowck;\n-extern crate rustc_incremental;\n-extern crate rustc_traits;\n-#[macro_use]\n-extern crate rustc_data_structures;\n-extern crate rustc_errors;\n-extern crate rustc_lint;\n-extern crate rustc_metadata;\n-extern crate rustc_mir;\n-extern crate rustc_passes;\n-extern crate rustc_plugin;\n-extern crate rustc_privacy;\n-extern crate rustc_rayon as rayon;\n-extern crate rustc_resolve;\n-extern crate rustc_typeck;\n-extern crate smallvec;\n-extern crate serialize;\n-extern crate syntax;\n-extern crate syntax_pos;\n-extern crate syntax_ext;\n \n pub mod interface;\n mod passes;"}, {"sha": "44ca11df694a966dd4ca95c9ab0eca49ee71b2c5", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -1,7 +1,8 @@\n-use interface::{Compiler, Result};\n-use util;\n-use proc_macro_decls;\n+use crate::interface::{Compiler, Result};\n+use crate::util;\n+use crate::proc_macro_decls;\n \n+use log::{debug, info, warn, log_enabled};\n use rustc::dep_graph::DepGraph;\n use rustc::hir;\n use rustc::hir::lowering::lower_crate;\n@@ -20,6 +21,7 @@ use rustc::session::search_paths::PathKind;\n use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{Lrc, ParallelIterator, par_iter};\n@@ -328,7 +330,7 @@ pub fn register_plugins<'a>(\n         ls.register_early_pass(Some(sess), true, false, pass);\n     }\n     for pass in late_lint_passes {\n-        ls.register_late_pass(Some(sess), true, pass);\n+        ls.register_late_pass(Some(sess), true, false, pass);\n     }\n \n     for (name, (to, deprecated_name)) in lint_groups {\n@@ -758,7 +760,7 @@ pub fn prepare_outputs(\n     Ok(outputs)\n }\n \n-pub fn default_provide(providers: &mut ty::query::Providers) {\n+pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     providers.analysis = analysis;\n     proc_macro_decls::provide(providers);\n     plugin::build::provide(providers);\n@@ -783,7 +785,7 @@ pub fn default_provide(providers: &mut ty::query::Providers) {\n     lint::provide(providers);\n }\n \n-pub fn default_provide_extern(providers: &mut ty::query::Providers) {\n+pub fn default_provide_extern(providers: &mut ty::query::Providers<'_>) {\n     cstore::provide_extern(providers);\n }\n "}, {"sha": "d0c8dff207083d6773692a279fac5c8c2724c006", "filename": "src/librustc_interface/profile/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_interface%2Fprofile%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_interface%2Fprofile%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fprofile%2Fmod.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -1,8 +1,9 @@\n+use log::debug;\n+use rustc::dep_graph::DepNode;\n use rustc::session::Session;\n use rustc::util::common::{ProfQDumpParams, ProfileQueriesMsg, profq_msg, profq_set_chan};\n use std::sync::mpsc::{Receiver};\n use std::io::{Write};\n-use rustc::dep_graph::{DepNode};\n use std::time::{Duration, Instant};\n \n pub mod trace;"}, {"sha": "570509ffb2b8ca1b7e6b5915ec5041dec1ef76dc", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -1,5 +1,6 @@\n-use interface::{Compiler, Result};\n-use passes::{self, BoxedResolver, ExpansionResult, BoxedGlobalCtxt, PluginInfo};\n+use crate::interface::{Compiler, Result};\n+use crate::passes::{self, BoxedResolver, ExpansionResult, BoxedGlobalCtxt, PluginInfo};\n+\n use rustc_incremental::DepGraphFuture;\n use rustc_data_structures::sync::Lrc;\n use rustc::session::config::{Input, OutputFilenames, OutputType};"}, {"sha": "6e4f2bf24e32f0750ab4ecfbb231d73489ee6ef3", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -1,3 +1,4 @@\n+use log::info;\n use rustc::session::config::{Input, OutputFilenames, ErrorOutputType};\n use rustc::session::{self, config, early_error, filesearch, Session, DiagnosticOutput};\n use rustc::session::CrateDisambiguator;"}, {"sha": "492ac1bf14dcc88386375cc637e22466cb245e95", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -1360,6 +1360,7 @@ fn check_const(cx: &LateContext<'_, '_>, body_id: hir::BodyId) {\n         promoted: None\n     };\n     // trigger the query once for all constants since that will already report the errors\n+    // FIXME: Use ensure here\n     let _ = cx.tcx.const_eval(param_env.and(cid));\n }\n "}, {"sha": "4c624a267af9b676c1afd31987bf7212ea26801c", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 45, "deletions": 10, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -125,37 +125,72 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         store.register_early_pass(sess, false, true, box BuiltinCombinedEarlyLintPass::new());\n     }\n \n-    late_lint_methods!(declare_combined_late_lint_pass, [BuiltinCombinedLateLintPass, [\n+    late_lint_methods!(declare_combined_late_lint_pass, [BuiltinCombinedModuleLateLintPass, [\n         HardwiredLints: HardwiredLints,\n         WhileTrue: WhileTrue,\n         ImproperCTypes: ImproperCTypes,\n         VariantSizeDifferences: VariantSizeDifferences,\n         BoxPointers: BoxPointers,\n-        UnusedAttributes: UnusedAttributes,\n         PathStatements: PathStatements,\n+\n+        // Depends on referenced function signatures in expressions\n         UnusedResults: UnusedResults,\n-        NonSnakeCase: NonSnakeCase,\n+\n         NonUpperCaseGlobals: NonUpperCaseGlobals,\n         NonShorthandFieldPatterns: NonShorthandFieldPatterns,\n         UnusedAllocation: UnusedAllocation,\n+\n+        // Depends on types used in type definitions\n         MissingCopyImplementations: MissingCopyImplementations,\n-        UnstableFeatures: UnstableFeatures,\n-        InvalidNoMangleItems: InvalidNoMangleItems,\n+\n         PluginAsLibrary: PluginAsLibrary,\n+\n+        // Depends on referenced function signatures in expressions\n         MutableTransmutes: MutableTransmutes,\n+\n+        // Depends on types of fields, checks if they implement Drop\n         UnionsWithDropFields: UnionsWithDropFields,\n-        UnreachablePub: UnreachablePub,\n-        UnnameableTestItems: UnnameableTestItems::new(),\n+\n         TypeAliasBounds: TypeAliasBounds,\n-        UnusedBrokenConst: UnusedBrokenConst,\n+\n         TrivialConstraints: TrivialConstraints,\n         TypeLimits: TypeLimits::new(),\n+\n+        NonSnakeCase: NonSnakeCase,\n+        InvalidNoMangleItems: InvalidNoMangleItems,\n+\n+        // Depends on access levels\n+        UnreachablePub: UnreachablePub,\n+\n+        ExplicitOutlivesRequirements: ExplicitOutlivesRequirements,\n+    ]], ['tcx]);\n+\n+    store.register_late_pass(sess, false, true, box BuiltinCombinedModuleLateLintPass::new());\n+\n+    late_lint_methods!(declare_combined_late_lint_pass, [BuiltinCombinedLateLintPass, [\n+        // FIXME: Look into regression when this is used as a module lint\n+        // May Depend on constants elsewhere\n+        UnusedBrokenConst: UnusedBrokenConst,\n+\n+        // Uses attr::is_used which is untracked, can't be an incremental module pass.\n+        UnusedAttributes: UnusedAttributes,\n+\n+        // Needs to run after UnusedAttributes as it marks all `feature` attributes as used.\n+        UnstableFeatures: UnstableFeatures,\n+\n+        // Tracks state across modules\n+        UnnameableTestItems: UnnameableTestItems::new(),\n+\n+        // Tracks attributes of parents\n         MissingDoc: MissingDoc::new(),\n+\n+        // Depends on access levels\n+        // FIXME: Turn the computation of types which implement Debug into a query\n+        // and change this to a module lint pass\n         MissingDebugImplementations: MissingDebugImplementations::new(),\n-        ExplicitOutlivesRequirements: ExplicitOutlivesRequirements,\n     ]], ['tcx]);\n \n-    store.register_late_pass(sess, false, box BuiltinCombinedLateLintPass::new());\n+    store.register_late_pass(sess, false, false, box BuiltinCombinedLateLintPass::new());\n \n     add_lint_group!(sess,\n                     \"nonstandard_style\","}, {"sha": "7a164dbcdf12d15922f2d0452b26510bd476366c", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -267,11 +267,15 @@ impl LintPass for NonSnakeCase {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n-    fn check_crate(&mut self, cx: &LateContext<'_, '_>, cr: &hir::Crate) {\n+    fn check_mod(&mut self, cx: &LateContext<'_, '_>, _: &'tcx hir::Mod, _: Span, id: hir::HirId) {\n+        if id != hir::CRATE_HIR_ID {\n+            return;\n+        }\n+\n         let crate_ident = if let Some(name) = &cx.tcx.sess.opts.crate_name {\n             Some(Ident::from_str(name))\n         } else {\n-            attr::find_by_name(&cr.attrs, \"crate_name\")\n+            attr::find_by_name(&cx.tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID), \"crate_name\")\n                 .and_then(|attr| attr.meta())\n                 .and_then(|meta| {\n                     meta.name_value_literal().and_then(|lit| {"}, {"sha": "6ab89f80ef528433535e3d5e3a95558e328d1de0", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -22,7 +22,7 @@ use syntax::source_map::{Span, DUMMY_SP};\n use crate::interpret::{self,\n     PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Immediate, Scalar, Pointer,\n     RawConst, ConstValue,\n-    EvalResult, EvalError, EvalErrorKind, GlobalId, EvalContext, StackPopCleanup,\n+    EvalResult, EvalError, EvalErrorKind, GlobalId, InterpretCx, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking,\n };\n@@ -34,7 +34,7 @@ const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n /// Should be a power of two for performance reasons.\n const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n \n-/// The `EvalContext` is only meant to be used to do field and index projections into constants for\n+/// The `InterpretCx` is only meant to be used to do field and index projections into constants for\n /// `simd_shuffle` and const patterns in match arms.\n ///\n /// The function containing the `match` that is currently being analyzed may have generic bounds\n@@ -47,7 +47,7 @@ pub(crate) fn mk_eval_cx<'a, 'mir, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n ) -> CompileTimeEvalContext<'a, 'mir, 'tcx> {\n     debug!(\"mk_eval_cx: {:?}\", param_env);\n-    EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new())\n+    InterpretCx::new(tcx.at(span), param_env, CompileTimeInterpreter::new())\n }\n \n pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n@@ -116,7 +116,7 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     // and try improving it down the road when more information is available\n     let span = tcx.def_span(cid.instance.def_id());\n     let span = mir.map(|mir| mir.span).unwrap_or(span);\n-    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new());\n+    let mut ecx = InterpretCx::new(tcx.at(span), param_env, CompileTimeInterpreter::new());\n     let r = eval_body_using_ecx(&mut ecx, cid, mir, param_env);\n     (r, ecx)\n }\n@@ -292,7 +292,7 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n }\n \n type CompileTimeEvalContext<'a, 'mir, 'tcx> =\n-    EvalContext<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>;\n+    InterpretCx<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>;\n \n impl interpret::MayLeak for ! {\n     #[inline(always)]\n@@ -317,12 +317,12 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n \n     #[inline(always)]\n-    fn enforce_validity(_ecx: &EvalContext<'a, 'mir, 'tcx, Self>) -> bool {\n+    fn enforce_validity(_ecx: &InterpretCx<'a, 'mir, 'tcx, Self>) -> bool {\n         false // for now, we don't enforce validity\n     }\n \n     fn find_fn(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: Option<PlaceTy<'tcx>>,\n@@ -362,7 +362,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     fn call_intrinsic(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n@@ -378,7 +378,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     fn ptr_op(\n-        _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ecx: &InterpretCx<'a, 'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n         _left: ImmTy<'tcx>,\n         _right: ImmTy<'tcx>,\n@@ -406,15 +406,15 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     fn box_alloc(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n         Err(\n             ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into(),\n         )\n     }\n \n-    fn before_terminator(ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx> {\n+    fn before_terminator(ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx> {\n         {\n             let steps = &mut ecx.machine.steps_since_detector_enabled;\n \n@@ -440,7 +440,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n \n     #[inline(always)]\n     fn tag_new_allocation(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         ptr: Pointer,\n         _kind: MemoryKind<Self::MemoryKinds>,\n     ) -> Pointer {\n@@ -449,15 +449,15 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n \n     #[inline(always)]\n     fn stack_push(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n     ) -> EvalResult<'tcx> {\n         Ok(())\n     }\n \n     /// Called immediately before a stack frame gets popped.\n     #[inline(always)]\n     fn stack_pop(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         _extra: (),\n     ) -> EvalResult<'tcx> {\n         Ok(())\n@@ -504,7 +504,7 @@ pub fn const_variant_index<'a, 'tcx>(\n }\n \n pub fn error_to_const_error<'a, 'mir, 'tcx>(\n-    ecx: &EvalContext<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n+    ecx: &InterpretCx<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n     mut error: EvalError<'tcx>\n ) -> ConstEvalErr<'tcx> {\n     error.print_backtrace();"}, {"sha": "003c2182d0b45c4829bc592cf19a0c7a41ff0e42", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -9,9 +9,9 @@ use rustc::mir::interpret::{\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n \n-use super::{EvalContext, Machine, PlaceTy, OpTy, ImmTy, Immediate};\n+use super::{InterpretCx, Machine, PlaceTy, OpTy, ImmTy, Immediate};\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n             ty::RawPtr(ty::TypeAndMut { ty, .. }) |"}, {"sha": "8b7e28c3de077f5b2b054ec087c967aac7b7a148", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -26,7 +26,7 @@ use super::{\n     Memory, Machine\n };\n \n-pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n+pub struct InterpretCx<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n     pub machine: M,\n \n@@ -141,15 +141,15 @@ impl<'tcx, Tag> LocalState<'tcx, Tag> {\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n-    for EvalContext<'a, 'mir, 'tcx, M>\n+    for InterpretCx<'a, 'mir, 'tcx, M>\n {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for EvalContext<'a, 'mir, 'tcx, M>\n+impl<'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for InterpretCx<'a, 'mir, 'tcx, M>\n     where M: Machine<'a, 'mir, 'tcx>\n {\n     #[inline]\n@@ -159,7 +159,7 @@ impl<'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for EvalContext<'a, 'mir, 'tcx,\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n-    for EvalContext<'a, 'mir, 'tcx, M>\n+    for InterpretCx<'a, 'mir, 'tcx, M>\n {\n     type Ty = Ty<'tcx>;\n     type TyLayout = EvalResult<'tcx, TyLayout<'tcx>>;\n@@ -171,13 +171,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n     }\n }\n \n-impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     pub fn new(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         machine: M,\n     ) -> Self {\n-        EvalContext {\n+        InterpretCx {\n             machine,\n             tcx,\n             param_env,"}, {"sha": "99dd654df21e317ad6c82f26ee0016870469fe06", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -11,7 +11,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    Machine, PlaceTy, OpTy, EvalContext,\n+    Machine, PlaceTy, OpTy, InterpretCx,\n };\n \n \n@@ -36,7 +36,7 @@ fn numeric_intrinsic<'tcx, Tag>(\n     Ok(Scalar::from_uint(bits_out, size))\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     /// Returns `true` if emulation happened.\n     pub fn emulate_intrinsic(\n         &mut self,"}, {"sha": "09d403ab243d60f88fe8eb21167f97b4366bc42b", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -11,7 +11,7 @@ use rustc::ty::{self, query::TyCtxtAt};\n \n use super::{\n     Allocation, AllocId, EvalResult, Scalar, AllocationExtra,\n-    EvalContext, PlaceTy, MPlaceTy, OpTy, ImmTy, Pointer, MemoryKind,\n+    InterpretCx, PlaceTy, MPlaceTy, OpTy, ImmTy, Pointer, MemoryKind,\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -95,11 +95,11 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     const STATIC_KIND: Option<Self::MemoryKinds>;\n \n     /// Whether to enforce the validity invariant\n-    fn enforce_validity(ecx: &EvalContext<'a, 'mir, 'tcx, Self>) -> bool;\n+    fn enforce_validity(ecx: &InterpretCx<'a, 'mir, 'tcx, Self>) -> bool;\n \n     /// Called before a basic block terminator is executed.\n     /// You can use this to detect endlessly running programs.\n-    fn before_terminator(ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx>;\n+    fn before_terminator(ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx>;\n \n     /// Entry point to all function calls.\n     ///\n@@ -112,7 +112,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Passing `dest`and `ret` in the same `Option` proved very annoying when only one of them\n     /// was used.\n     fn find_fn(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n@@ -122,7 +122,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Directly process an intrinsic without pushing a stack frame.\n     /// If this returns successfully, the engine will take care of jumping to the next block.\n     fn call_intrinsic(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n@@ -156,21 +156,21 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     ///\n     /// Returns a (value, overflowed) pair if the operation succeeded\n     fn ptr_op(\n-        ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &InterpretCx<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Self::PointerTag>,\n         right: ImmTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n \n     /// Heap allocations via the `box` keyword.\n     fn box_alloc(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx>;\n \n     /// Adds the tag for a newly allocated pointer.\n     fn tag_new_allocation(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         ptr: Pointer,\n         kind: MemoryKind<Self::MemoryKinds>,\n     ) -> Pointer<Self::PointerTag>;\n@@ -180,7 +180,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// `mutability` can be `None` in case a raw ptr is being dereferenced.\n     #[inline]\n     fn tag_dereference(\n-        _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ecx: &InterpretCx<'a, 'mir, 'tcx, Self>,\n         place: MPlaceTy<'tcx, Self::PointerTag>,\n         _mutability: Option<hir::Mutability>,\n     ) -> EvalResult<'tcx, Scalar<Self::PointerTag>> {\n@@ -190,7 +190,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Executes a retagging operation\n     #[inline]\n     fn retag(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         _kind: mir::RetagKind,\n         _place: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx> {\n@@ -199,12 +199,12 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n \n     /// Called immediately before a new stack frame got pushed\n     fn stack_push(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n     ) -> EvalResult<'tcx, Self::FrameExtra>;\n \n     /// Called immediately after a stack frame gets popped\n     fn stack_pop(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         extra: Self::FrameExtra,\n     ) -> EvalResult<'tcx>;\n }"}, {"sha": "ea358389ddb761f41f213ccd47cba9b8d5bbfb2c", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -18,7 +18,7 @@ mod visitor;\n pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n pub use self::eval_context::{\n-    EvalContext, Frame, StackPopCleanup, LocalState, LocalValue,\n+    InterpretCx, Frame, StackPopCleanup, LocalState, LocalValue,\n };\n \n pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};"}, {"sha": "15b6d5c914d20c92f487adfbc51b8ddf4e570a71", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -13,7 +13,7 @@ use rustc::mir::interpret::{\n     sign_extend, truncate,\n };\n use super::{\n-    EvalContext, Machine,\n+    InterpretCx, Machine,\n     MemPlace, MPlaceTy, PlaceTy, Place, MemoryKind,\n };\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n@@ -267,7 +267,7 @@ pub(super) fn from_known_layout<'tcx>(\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     /// Try reading an immediate in memory; this is interesting particularly for ScalarPair.\n     /// Returns `None` if the layout does not permit loading this as a value.\n     fn try_read_immediate_from_mplace("}, {"sha": "ca93007788e0342ef9a8bb54931f90aa99b510a6", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -5,10 +5,10 @@ use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n use rustc::mir::interpret::{EvalResult, Scalar};\n \n-use super::{EvalContext, PlaceTy, Immediate, Machine, ImmTy};\n+use super::{InterpretCx, PlaceTy, Immediate, Machine, ImmTy};\n \n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n     pub fn binop_with_overflow(\n@@ -37,7 +37,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     fn binary_char_op(\n         &self,\n         bin_op: mir::BinOp,"}, {"sha": "82b92acdb764c4fb315f3c30a029118588656a95", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -14,7 +14,7 @@ use rustc::ty::TypeFoldable;\n \n use super::{\n     GlobalId, AllocId, Allocation, Scalar, EvalResult, Pointer, PointerArithmetic,\n-    EvalContext, Machine, AllocMap, AllocationExtra,\n+    InterpretCx, Machine, AllocMap, AllocationExtra,\n     RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind\n };\n \n@@ -305,7 +305,7 @@ impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n }\n \n // separating the pointer tag for `impl Trait`, see https://github.com/rust-lang/rust/issues/54385\n-impl<'a, 'mir, 'tcx, Tag, M> EvalContext<'a, 'mir, 'tcx, M>\n+impl<'a, 'mir, 'tcx, Tag, M> InterpretCx<'a, 'mir, 'tcx, M>\n where\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n     Tag: ::std::fmt::Debug+Default+Copy+Eq+Hash+'static,\n@@ -607,7 +607,7 @@ where\n                 // global table but not in its local memory: It calls back into tcx through\n                 // a query, triggering the CTFE machinery to actually turn this lazy reference\n                 // into a bunch of bytes.  IOW, statics are evaluated with CTFE even when\n-                // this EvalContext uses another Machine (e.g., in miri).  This is what we\n+                // this InterpretCx uses another Machine (e.g., in miri).  This is what we\n                 // want!  This way, computing statics works concistently between codegen\n                 // and miri: They use the same query to eventually obtain a `ty::Const`\n                 // and use that for further computation."}, {"sha": "29a8547035e4add17aa0967b75b14ef88966103f", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -1,12 +1,12 @@\n-//! This module contains the `EvalContext` methods for executing a single step of the interpreter.\n+//! This module contains the `InterpretCx` methods for executing a single step of the interpreter.\n //!\n //! The main entry point is the `step` method.\n \n use rustc::mir;\n use rustc::ty::layout::LayoutOf;\n use rustc::mir::interpret::{EvalResult, Scalar, PointerArithmetic};\n \n-use super::{EvalContext, Machine};\n+use super::{InterpretCx, Machine};\n \n /// Classify whether an operator is \"left-homogeneous\", i.e., the LHS has the\n /// same type as the result.\n@@ -35,7 +35,7 @@ fn binop_right_homogeneous(op: mir::BinOp) -> bool {\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     pub fn run(&mut self) -> EvalResult<'tcx> {\n         while self.step()? {}\n         Ok(())"}, {"sha": "01965f53c157d2bbac7ba046317df528b3c18e3e", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -7,10 +7,10 @@ use rustc_target::spec::abi::Abi;\n \n use rustc::mir::interpret::{EvalResult, PointerArithmetic, EvalErrorKind, Scalar};\n use super::{\n-    EvalContext, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n+    InterpretCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n };\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     #[inline]\n     pub fn goto_block(&mut self, target: Option<mir::BasicBlock>) -> EvalResult<'tcx> {\n         if let Some(target) = target {"}, {"sha": "cce6c95a31240f780feefccdc6e27f0fd87f3c9e", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -3,9 +3,9 @@ use rustc::ty::{self, Ty};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use rustc::mir::interpret::{Scalar, Pointer, EvalResult, PointerArithmetic};\n \n-use super::{EvalContext, Machine, MemoryKind};\n+use super::{InterpretCx, Machine, MemoryKind};\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n     ///"}, {"sha": "3323ec387bfd59b38633cc5dbb8ad17f9807b99a", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -11,7 +11,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    OpTy, Machine, EvalContext, ValueVisitor, MPlaceTy,\n+    OpTy, Machine, InterpretCx, ValueVisitor, MPlaceTy,\n };\n \n macro_rules! validation_failure {\n@@ -153,7 +153,7 @@ struct ValidityVisitor<'rt, 'a: 'rt, 'mir: 'rt, 'tcx: 'a+'rt+'mir, M: Machine<'a\n     path: Vec<PathElem>,\n     ref_tracking: Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>>>,\n     const_mode: bool,\n-    ecx: &'rt EvalContext<'a, 'mir, 'tcx, M>,\n+    ecx: &'rt InterpretCx<'a, 'mir, 'tcx, M>,\n }\n \n impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, 'mir, 'tcx, M> {\n@@ -224,7 +224,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n     type V = OpTy<'tcx, M::PointerTag>;\n \n     #[inline(always)]\n-    fn ecx(&self) -> &EvalContext<'a, 'mir, 'tcx, M> {\n+    fn ecx(&self) -> &InterpretCx<'a, 'mir, 'tcx, M> {\n         &self.ecx\n     }\n \n@@ -587,7 +587,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     /// This function checks the data at `op`. `op` is assumed to cover valid memory if it\n     /// is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout."}, {"sha": "90d4fff42183782bc610b1c7bde23a7ee61d287d", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -8,7 +8,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    Machine, EvalContext, MPlaceTy, OpTy,\n+    Machine, InterpretCx, MPlaceTy, OpTy,\n };\n \n // A thing that we can project into, and that has a layout.\n@@ -22,7 +22,7 @@ pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n     /// Makes this into an `OpTy`.\n     fn to_op(\n         self,\n-        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n \n     /// Creates this from an `MPlaceTy`.\n@@ -31,14 +31,14 @@ pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n     /// Projects to the given enum variant.\n     fn project_downcast(\n         self,\n-        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> EvalResult<'tcx, Self>;\n \n     /// Projects to the n-th field.\n     fn project_field(\n         self,\n-        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         field: u64,\n     ) -> EvalResult<'tcx, Self>;\n }\n@@ -56,7 +56,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn to_op(\n         self,\n-        _ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        _ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(self)\n     }\n@@ -69,7 +69,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_downcast(\n         self,\n-        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> EvalResult<'tcx, Self> {\n         ecx.operand_downcast(self, variant)\n@@ -78,7 +78,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_field(\n         self,\n-        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         field: u64,\n     ) -> EvalResult<'tcx, Self> {\n         ecx.operand_field(self, field)\n@@ -95,7 +95,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn to_op(\n         self,\n-        _ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        _ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(self.into())\n     }\n@@ -108,7 +108,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_downcast(\n         self,\n-        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> EvalResult<'tcx, Self> {\n         ecx.mplace_downcast(self, variant)\n@@ -117,7 +117,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_field(\n         self,\n-        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         field: u64,\n     ) -> EvalResult<'tcx, Self> {\n         ecx.mplace_field(self, field)\n@@ -130,9 +130,9 @@ macro_rules! make_value_visitor {\n         pub trait $visitor_trait_name<'a, 'mir, 'tcx: 'mir+'a, M: Machine<'a, 'mir, 'tcx>>: Sized {\n             type V: Value<'a, 'mir, 'tcx, M>;\n \n-            /// The visitor must have an `EvalContext` in it.\n+            /// The visitor must have an `InterpretCx` in it.\n             fn ecx(&$($mutability)? self)\n-                -> &$($mutability)? EvalContext<'a, 'mir, 'tcx, M>;\n+                -> &$($mutability)? InterpretCx<'a, 'mir, 'tcx, M>;\n \n             // Recursive actions, ready to be overloaded.\n             /// Visits the given value, dispatching as appropriate to more specialized visitors."}, {"sha": "b3ef7407a7c3dfb8234200bf314724f1ab7d67da", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::layout::{\n     HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n-use crate::interpret::{EvalContext, ScalarMaybeUndef, Immediate, OpTy, ImmTy, MemoryKind};\n+use crate::interpret::{InterpretCx, ScalarMaybeUndef, Immediate, OpTy, ImmTy, MemoryKind};\n use crate::const_eval::{\n     CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_eval_cx,\n };\n@@ -70,7 +70,7 @@ type Const<'tcx> = (OpTy<'tcx>, Span);\n \n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'a, 'mir, 'tcx:'a+'mir> {\n-    ecx: EvalContext<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n+    ecx: InterpretCx<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n     mir: &'mir Mir<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     source: MirSource<'tcx>,"}, {"sha": "b532e5c94d5318fe9ed0a4292a50d345cf8b28cb", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -1790,8 +1790,7 @@ fn check_mod_privacy<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n         current_item: hir::DUMMY_HIR_ID,\n         empty_tables: &empty_tables,\n     };\n-    let (module, span, node_id) = tcx.hir().get_module(module_def_id);\n-    let hir_id = tcx.hir().node_to_hir_id(node_id);\n+    let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n     intravisit::walk_mod(&mut visitor, module, hir_id);\n \n     // Check privacy of explicitly written types and traits as well as"}, {"sha": "ac8b639edbfa363556799a79a3579ee8c9d50605", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -1233,7 +1233,12 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                     augment_error(&mut db);\n                 }\n \n-                db.emit();\n+                if expression.filter(|e| fcx.is_assign_to_bool(e, expected)).is_some() {\n+                    // Error reported in `check_assign` so avoid emitting error again.\n+                    db.delay_as_bug();\n+                } else {\n+                    db.emit();\n+                }\n \n                 self.final_ty = Some(fcx.tcx.types.err);\n             }"}, {"sha": "60fa266f0bbe1350828f135aeffe57bea4702e05", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 52, "deletions": 31, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -119,44 +119,65 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n         let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e);\n \n-        // If the expected type is an enum (Issue #55250) with any variants whose\n-        // sole field is of the found type, suggest such variants. (Issue #42764)\n-        if let ty::Adt(expected_adt, substs) = expected.sty {\n-            if expected_adt.is_enum() {\n-                let mut compatible_variants = expected_adt.variants\n-                    .iter()\n-                    .filter(|variant| variant.fields.len() == 1)\n-                    .filter_map(|variant| {\n-                        let sole_field = &variant.fields[0];\n-                        let sole_field_ty = sole_field.ty(self.tcx, substs);\n-                        if self.can_coerce(expr_ty, sole_field_ty) {\n-                            let variant_path = self.tcx.def_path_str(variant.def_id);\n-                            // FIXME #56861: DRYer prelude filtering\n-                            Some(variant_path.trim_start_matches(\"std::prelude::v1::\").to_string())\n-                        } else {\n-                            None\n-                        }\n-                    }).peekable();\n-\n-                if compatible_variants.peek().is_some() {\n-                    let expr_text = print::to_string(print::NO_ANN, |s| s.print_expr(expr));\n-                    let suggestions = compatible_variants\n-                        .map(|v| format!(\"{}({})\", v, expr_text));\n-                    err.span_suggestions(\n-                        expr.span,\n-                        \"try using a variant of the expected type\",\n-                        suggestions,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-            }\n+        if self.is_assign_to_bool(expr, expected) {\n+            // Error reported in `check_assign` so avoid emitting error again.\n+            err.delay_as_bug();\n+            return (expected, None)\n         }\n \n+        self.suggest_compatible_variants(&mut err, expr, expected, expr_ty);\n         self.suggest_ref_or_into(&mut err, expr, expected, expr_ty);\n \n         (expected, Some(err))\n     }\n \n+    /// Returns whether the expected type is `bool` and the expression is `x = y`.\n+    pub fn is_assign_to_bool(&self, expr: &hir::Expr, expected: Ty<'tcx>) -> bool {\n+        if let hir::ExprKind::Assign(..) = expr.node {\n+            return expected == self.tcx.types.bool;\n+        }\n+        false\n+    }\n+\n+    /// If the expected type is an enum (Issue #55250) with any variants whose\n+    /// sole field is of the found type, suggest such variants. (Issue #42764)\n+    fn suggest_compatible_variants(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr,\n+        expected: Ty<'tcx>,\n+        expr_ty: Ty<'tcx>,\n+    ) {\n+        if let ty::Adt(expected_adt, substs) = expected.sty {\n+            if !expected_adt.is_enum() {\n+                return;\n+            }\n+\n+            let mut compatible_variants = expected_adt.variants\n+                .iter()\n+                .filter(|variant| variant.fields.len() == 1)\n+                .filter_map(|variant| {\n+                    let sole_field = &variant.fields[0];\n+                    let sole_field_ty = sole_field.ty(self.tcx, substs);\n+                    if self.can_coerce(expr_ty, sole_field_ty) {\n+                        let variant_path = self.tcx.def_path_str(variant.def_id);\n+                        // FIXME #56861: DRYer prelude filtering\n+                        Some(variant_path.trim_start_matches(\"std::prelude::v1::\").to_string())\n+                    } else {\n+                        None\n+                    }\n+                }).peekable();\n+\n+            if compatible_variants.peek().is_some() {\n+                let expr_text = print::to_string(print::NO_ANN, |s| s.print_expr(expr));\n+                let suggestions = compatible_variants\n+                    .map(|v| format!(\"{}({})\", v, expr_text));\n+                let msg = \"try using a variant of the expected type\";\n+                err.span_suggestions(expr.span, msg, suggestions, Applicability::MaybeIncorrect);\n+            }\n+        }\n+    }\n+\n     pub fn get_conversion_methods(&self, span: Span, expected: Ty<'tcx>, checked_ty: Ty<'tcx>)\n                               -> Vec<AssociatedItem> {\n         let mut methods = self.probe_for_return_type(span,"}, {"sha": "3d904d518ca8e6c300fd12295a8eeb3beef14b83", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -246,9 +246,6 @@ pub enum Expectation<'tcx> {\n     /// We know nothing about what type this expression should have.\n     NoExpectation,\n \n-    /// This expression is an `if` condition, it must resolve to `bool`.\n-    ExpectIfCondition,\n-\n     /// This expression should have the type given (or some subtype).\n     ExpectHasType(Ty<'tcx>),\n \n@@ -328,7 +325,6 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     fn resolve(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Expectation<'tcx> {\n         match self {\n             NoExpectation => NoExpectation,\n-            ExpectIfCondition => ExpectIfCondition,\n             ExpectCastableToType(t) => {\n                 ExpectCastableToType(fcx.resolve_type_vars_if_possible(&t))\n             }\n@@ -344,7 +340,6 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     fn to_option(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             NoExpectation => None,\n-            ExpectIfCondition => Some(fcx.tcx.types.bool),\n             ExpectCastableToType(ty) |\n             ExpectHasType(ty) |\n             ExpectRvalueLikeUnsized(ty) => Some(ty),\n@@ -358,7 +353,6 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     fn only_has_type(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             ExpectHasType(ty) => Some(ty),\n-            ExpectIfCondition => Some(fcx.tcx.types.bool),\n             NoExpectation | ExpectCastableToType(_) | ExpectRvalueLikeUnsized(_) => None,\n         }\n     }\n@@ -3148,25 +3142,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            // Add help to type error if this is an `if` condition with an assignment.\n-            if let (ExpectIfCondition, &ExprKind::Assign(ref lhs, ref rhs))\n-                 = (expected, &expr.node)\n-            {\n-                let msg = \"try comparing for equality\";\n-                if let (Ok(left), Ok(right)) = (\n-                    self.tcx.sess.source_map().span_to_snippet(lhs.span),\n-                    self.tcx.sess.source_map().span_to_snippet(rhs.span))\n-                {\n-                    err.span_suggestion(\n-                        expr.span,\n-                        msg,\n-                        format!(\"{} == {}\", left, right),\n-                        Applicability::MaybeIncorrect);\n-                } else {\n-                    err.help(msg);\n-                }\n+            if self.is_assign_to_bool(expr, expected_ty) {\n+                // Error reported in `check_assign` so avoid emitting error again.\n+                // FIXME(centril): Consider removing if/when `if` desugars to `match`.\n+                err.delay_as_bug();\n+            } else {\n+                err.emit();\n             }\n-            err.emit();\n         }\n         ty\n     }\n@@ -3337,7 +3319,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        opt_else_expr: Option<&'gcx hir::Expr>,\n                        sp: Span,\n                        expected: Expectation<'tcx>) -> Ty<'tcx> {\n-        let cond_ty = self.check_expr_meets_expectation_or_error(cond_expr, ExpectIfCondition);\n+        let cond_ty = self.check_expr_has_type_or_error(cond_expr, self.tcx.types.bool);\n         let cond_diverges = self.diverges.get();\n         self.diverges.set(Diverges::Maybe);\n \n@@ -4422,34 +4404,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 tcx.types.never\n             }\n             ExprKind::Assign(ref lhs, ref rhs) => {\n-                let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n-\n-                let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n-\n-                match expected {\n-                    ExpectIfCondition => {\n-                        self.tcx.sess.delay_span_bug(lhs.span, \"invalid lhs expression in if;\\\n-                                                                expected error elsehwere\");\n-                    }\n-                    _ => {\n-                        // Only check this if not in an `if` condition, as the\n-                        // mistyped comparison help is more appropriate.\n-                        if !lhs.is_place_expr() {\n-                            struct_span_err!(self.tcx.sess, expr.span, E0070,\n-                                                \"invalid left-hand side expression\")\n-                                .span_label(expr.span, \"left-hand of expression not valid\")\n-                                .emit();\n-                        }\n-                    }\n-                }\n-\n-                self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n-\n-                if lhs_ty.references_error() || rhs_ty.references_error() {\n-                    tcx.types.err\n-                } else {\n-                    tcx.mk_unit()\n-                }\n+                self.check_assign(expr, expected, lhs, rhs)\n             }\n             ExprKind::If(ref cond, ref then_expr, ref opt_else_expr) => {\n                 self.check_then_else(&cond, then_expr, opt_else_expr.as_ref().map(|e| &**e),\n@@ -4750,6 +4705,51 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Type check assignment expression `expr` of form `lhs = rhs`.\n+    /// The expected type is `()` and is passsed to the function for the purposes of diagnostics.\n+    fn check_assign(\n+        &self,\n+        expr: &'gcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+        lhs: &'gcx hir::Expr,\n+        rhs: &'gcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n+        let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n+\n+        let expected_ty = expected.coercion_target_type(self, expr.span);\n+        if expected_ty == self.tcx.types.bool {\n+            // The expected type is `bool` but this will result in `()` so we can reasonably\n+            // say that the user intended to write `lhs == rhs` instead of `lhs = rhs`.\n+            // The likely cause of this is `if foo = bar { .. }`.\n+            let actual_ty = self.tcx.mk_unit();\n+            let mut err = self.demand_suptype_diag(expr.span, expected_ty, actual_ty).unwrap();\n+            let msg = \"try comparing for equality\";\n+            let left = self.tcx.sess.source_map().span_to_snippet(lhs.span);\n+            let right = self.tcx.sess.source_map().span_to_snippet(rhs.span);\n+            if let (Ok(left), Ok(right)) = (left, right) {\n+                let help = format!(\"{} == {}\", left, right);\n+                err.span_suggestion(expr.span, msg, help, Applicability::MaybeIncorrect);\n+            } else {\n+                err.help(msg);\n+            }\n+            err.emit();\n+        } else if !lhs.is_place_expr() {\n+            struct_span_err!(self.tcx.sess, expr.span, E0070,\n+                                \"invalid left-hand side expression\")\n+                .span_label(expr.span, \"left-hand of expression not valid\")\n+                .emit();\n+        }\n+\n+        self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n+\n+        if lhs_ty.references_error() || rhs_ty.references_error() {\n+            self.tcx.types.err\n+        } else {\n+            self.tcx.mk_unit()\n+        }\n+    }\n+\n     // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n     // The newly resolved definition is written into `type_dependent_defs`.\n     fn finish_resolving_struct_path(&self,"}, {"sha": "4241f47b661d721b742a0b9bc8124592d7efeb8e", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -130,7 +130,7 @@ pub use alloc_crate::alloc::*;\n /// program opts in to using jemalloc as the global allocator, `System` will\n /// still allocate memory using `malloc` and `HeapAlloc`.\n #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-#[derive(Debug, Copy, Clone)]\n+#[derive(Debug, Default, Copy, Clone)]\n pub struct System;\n \n // The Alloc impl just forwards to the GlobalAlloc impl, which is in `std::sys::*::alloc`."}, {"sha": "5056e388112cedade9af31eb9f1bfd266019ff78", "filename": "src/libstd/sys/sgx/ext/arch.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Farch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Farch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Farch.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -28,7 +28,7 @@ const ENCLU_EGETKEY: u32 = 1;\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn egetkey(request: &Align512<[u8; 512]>) -> Result<Align16<[u8; 16]>, u32> {\n     unsafe {\n-        let mut out = MaybeUninit::uninitialized();\n+        let mut out = MaybeUninit::uninit();\n         let error;\n \n         asm!(\n@@ -41,7 +41,7 @@ pub fn egetkey(request: &Align512<[u8; 512]>) -> Result<Align16<[u8; 16]>, u32>\n         );\n \n         match error {\n-            0 => Ok(out.into_initialized()),\n+            0 => Ok(out.assume_init()),\n             err => Err(err),\n         }\n     }\n@@ -58,7 +58,7 @@ pub fn ereport(\n     reportdata: &Align128<[u8; 64]>,\n ) -> Align512<[u8; 432]> {\n     unsafe {\n-        let mut report = MaybeUninit::uninitialized();\n+        let mut report = MaybeUninit::uninit();\n \n         asm!(\n             \"enclu\"\n@@ -69,6 +69,6 @@ pub fn ereport(\n               \"{rdx}\"(report.as_mut_ptr())\n         );\n \n-        report.into_initialized()\n+        report.assume_init()\n     }\n }"}, {"sha": "7e2d13b9e24765865c2c5d8fe8eb99bb5839829d", "filename": "src/libstd/sys/sgx/rwlock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -280,7 +280,7 @@ mod tests {\n             let mut init = MaybeUninit::<RWLock>::zeroed();\n             rwlock_new(&mut init);\n             assert_eq!(\n-                mem::transmute::<_, [u8; 128]>(init.into_initialized()).as_slice(),\n+                mem::transmute::<_, [u8; 128]>(init.assume_init()).as_slice(),\n                 RWLOCK_INIT\n             )\n         };"}, {"sha": "37cbdcefcedcc6777eebdaa55026d9d5d9f5dc13", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -154,7 +154,7 @@ unsafe impl Sync for ReentrantMutex {}\n \n impl ReentrantMutex {\n     pub fn uninitialized() -> ReentrantMutex {\n-        ReentrantMutex { inner: UnsafeCell::new(MaybeUninit::uninitialized()) }\n+        ReentrantMutex { inner: UnsafeCell::new(MaybeUninit::uninit()) }\n     }\n \n     pub unsafe fn init(&mut self) {"}, {"sha": "058fee4484d68ba24219408a5e4bfe3813a5a00e", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -1257,7 +1257,10 @@ impl Thread {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Thread {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.name(), f)\n+        f.debug_struct(\"Thread\")\n+            .field(\"id\", &self.id())\n+            .field(\"name\", &self.name())\n+            .finish()\n     }\n }\n "}, {"sha": "ab5823eaca52af4f3d7443392ffd51636a3888ed", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -929,7 +929,7 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n             p.fatal(&format!(\"expected ident, found {}\", &token_str)).emit();\n             FatalError.raise()\n         }\n-        \"path\" => token::NtPath(panictry!(p.parse_path_common(PathStyle::Type, false))),\n+        \"path\" => token::NtPath(panictry!(p.parse_path(PathStyle::Type))),\n         \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n         \"vis\" => token::NtVis(panictry!(p.parse_visibility(true))),\n         \"lifetime\" => if p.check_lifetime() {"}, {"sha": "d3eadfeceb289df76c61c1fe46cc7b3d825a761e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 62, "deletions": 71, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -1119,9 +1119,8 @@ impl<'a> Parser<'a> {\n                 if text.is_empty() {\n                     self.span_bug(sp, \"found empty literal suffix in Some\")\n                 }\n-                let msg = format!(\"{} with a suffix is invalid\", kind);\n-                self.struct_span_err(sp, &msg)\n-                    .span_label(sp, msg)\n+                self.struct_span_err(sp, &format!(\"suffixes on {} are invalid\", kind))\n+                    .span_label(sp, format!(\"invalid suffix `{}`\", text))\n                     .emit();\n             }\n         }\n@@ -1903,7 +1902,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::ModSep)?;\n \n         let mut path = ast::Path { segments: Vec::new(), span: syntax_pos::DUMMY_SP };\n-        self.parse_path_segments(&mut path.segments, T::PATH_STYLE, true)?;\n+        self.parse_path_segments(&mut path.segments, T::PATH_STYLE)?;\n         path.span = ty_span.to(self.prev_span);\n \n         let ty_str = self.sess.source_map().span_to_snippet(ty_span)\n@@ -2150,7 +2149,7 @@ impl<'a> Parser<'a> {\n \n                 if suffix_illegal {\n                     let sp = self.span;\n-                    self.expect_no_suffix(sp, lit.literal_name(), suf)\n+                    self.expect_no_suffix(sp, &format!(\"a {}\", lit.literal_name()), suf)\n                 }\n \n                 result.unwrap()\n@@ -2294,7 +2293,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::ModSep)?;\n \n         let qself = QSelf { ty, path_span, position: path.segments.len() };\n-        self.parse_path_segments(&mut path.segments, style, true)?;\n+        self.parse_path_segments(&mut path.segments, style)?;\n \n         Ok((qself, ast::Path { segments: path.segments, span: lo.to(self.prev_span) }))\n     }\n@@ -2310,11 +2309,6 @@ impl<'a> Parser<'a> {\n     /// `Fn(Args)` (without disambiguator)\n     /// `Fn::(Args)` (with disambiguator)\n     pub fn parse_path(&mut self, style: PathStyle) -> PResult<'a, ast::Path> {\n-        self.parse_path_common(style, true)\n-    }\n-\n-    crate fn parse_path_common(&mut self, style: PathStyle, enable_warning: bool)\n-                             -> PResult<'a, ast::Path> {\n         maybe_whole!(self, NtPath, |path| {\n             if style == PathStyle::Mod &&\n                path.segments.iter().any(|segment| segment.args.is_some()) {\n@@ -2329,7 +2323,7 @@ impl<'a> Parser<'a> {\n         if self.eat(&token::ModSep) {\n             segments.push(PathSegment::path_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt)));\n         }\n-        self.parse_path_segments(&mut segments, style, enable_warning)?;\n+        self.parse_path_segments(&mut segments, style)?;\n \n         Ok(ast::Path { segments, span: lo.to(self.prev_span) })\n     }\n@@ -2357,11 +2351,10 @@ impl<'a> Parser<'a> {\n \n     fn parse_path_segments(&mut self,\n                            segments: &mut Vec<PathSegment>,\n-                           style: PathStyle,\n-                           enable_warning: bool)\n+                           style: PathStyle)\n                            -> PResult<'a, ()> {\n         loop {\n-            let segment = self.parse_path_segment(style, enable_warning)?;\n+            let segment = self.parse_path_segment(style)?;\n             if style == PathStyle::Expr {\n                 // In order to check for trailing angle brackets, we must have finished\n                 // recursing (`parse_path_segment` can indirectly call this function),\n@@ -2389,8 +2382,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_path_segment(&mut self, style: PathStyle, enable_warning: bool)\n-                          -> PResult<'a, PathSegment> {\n+    fn parse_path_segment(&mut self, style: PathStyle) -> PResult<'a, PathSegment> {\n         let ident = self.parse_path_segment_ident()?;\n \n         let is_args_start = |token: &token::Token| match *token {\n@@ -2407,13 +2399,6 @@ impl<'a> Parser<'a> {\n         Ok(if style == PathStyle::Type && check_args_start(self) ||\n               style != PathStyle::Mod && self.check(&token::ModSep)\n                                       && self.look_ahead(1, |t| is_args_start(t)) {\n-            // Generic arguments are found - `<`, `(`, `::<` or `::(`.\n-            if self.eat(&token::ModSep) && style == PathStyle::Type && enable_warning {\n-                self.diagnostic().struct_span_warn(self.prev_span, \"unnecessary path disambiguator\")\n-                                 .span_label(self.prev_span, \"try removing `::`\").emit();\n-            }\n-            let lo = self.span;\n-\n             // We use `style == PathStyle::Expr` to check if this is in a recursion or not. If\n             // it isn't, then we reset the unmatched angle bracket count as we're about to start\n             // parsing a new path.\n@@ -2422,6 +2407,9 @@ impl<'a> Parser<'a> {\n                 self.max_angle_bracket_count = 0;\n             }\n \n+            // Generic arguments are found - `<`, `(`, `::<` or `::(`.\n+            self.eat(&token::ModSep);\n+            let lo = self.span;\n             let args = if self.eat_lt() {\n                 // `<'a, T, A = U>`\n                 let (args, bindings) =\n@@ -2492,7 +2480,8 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_field_name(&mut self) -> PResult<'a, Ident> {\n-        if let token::Literal(token::Integer(name), None) = self.token {\n+        if let token::Literal(token::Integer(name), suffix) = self.token {\n+            self.expect_no_suffix(self.span, \"a tuple index\", suffix);\n             self.bump();\n             Ok(Ident::new(name, self.prev_span))\n         } else {\n@@ -3043,7 +3032,7 @@ impl<'a> Parser<'a> {\n \n     // Assuming we have just parsed `.`, continue parsing into an expression.\n     fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n-        let segment = self.parse_path_segment(PathStyle::Expr, true)?;\n+        let segment = self.parse_path_segment(PathStyle::Expr)?;\n         self.check_trailing_angle_brackets(&segment, token::OpenDelim(token::Paren));\n \n         Ok(match self.token {\n@@ -3196,51 +3185,53 @@ impl<'a> Parser<'a> {\n             // expr.f\n             if self.eat(&token::Dot) {\n                 match self.token {\n-                  token::Ident(..) => {\n-                    e = self.parse_dot_suffix(e, lo)?;\n-                  }\n-                  token::Literal(token::Integer(name), _) => {\n-                    let span = self.span;\n-                    self.bump();\n-                    let field = ExprKind::Field(e, Ident::new(name, span));\n-                    e = self.mk_expr(lo.to(span), field, ThinVec::new());\n-                  }\n-                  token::Literal(token::Float(n), _suf) => {\n-                    self.bump();\n-                    let fstr = n.as_str();\n-                    let mut err = self.diagnostic()\n-                        .struct_span_err(self.prev_span, &format!(\"unexpected token: `{}`\", n));\n-                    err.span_label(self.prev_span, \"unexpected token\");\n-                    if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n-                        let float = match fstr.parse::<f64>().ok() {\n-                            Some(f) => f,\n-                            None => continue,\n-                        };\n-                        let sugg = pprust::to_string(|s| {\n-                            use crate::print::pprust::PrintState;\n-                            s.popen()?;\n-                            s.print_expr(&e)?;\n-                            s.s.word( \".\")?;\n-                            s.print_usize(float.trunc() as usize)?;\n-                            s.pclose()?;\n-                            s.s.word(\".\")?;\n-                            s.s.word(fstr.splitn(2, \".\").last().unwrap().to_string())\n-                        });\n-                        err.span_suggestion(\n-                            lo.to(self.prev_span),\n-                            \"try parenthesizing the first index\",\n-                            sugg,\n-                            Applicability::MachineApplicable\n-                        );\n+                    token::Ident(..) => {\n+                        e = self.parse_dot_suffix(e, lo)?;\n                     }\n-                    return Err(err);\n+                    token::Literal(token::Integer(name), suffix) => {\n+                        let span = self.span;\n+                        self.bump();\n+                        let field = ExprKind::Field(e, Ident::new(name, span));\n+                        e = self.mk_expr(lo.to(span), field, ThinVec::new());\n+\n+                        self.expect_no_suffix(span, \"a tuple index\", suffix);\n+                    }\n+                    token::Literal(token::Float(n), _suf) => {\n+                      self.bump();\n+                      let fstr = n.as_str();\n+                      let mut err = self.diagnostic()\n+                          .struct_span_err(self.prev_span, &format!(\"unexpected token: `{}`\", n));\n+                      err.span_label(self.prev_span, \"unexpected token\");\n+                      if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n+                          let float = match fstr.parse::<f64>().ok() {\n+                              Some(f) => f,\n+                              None => continue,\n+                          };\n+                          let sugg = pprust::to_string(|s| {\n+                              use crate::print::pprust::PrintState;\n+                              s.popen()?;\n+                              s.print_expr(&e)?;\n+                              s.s.word( \".\")?;\n+                              s.print_usize(float.trunc() as usize)?;\n+                              s.pclose()?;\n+                              s.s.word(\".\")?;\n+                              s.s.word(fstr.splitn(2, \".\").last().unwrap().to_string())\n+                          });\n+                          err.span_suggestion(\n+                              lo.to(self.prev_span),\n+                              \"try parenthesizing the first index\",\n+                              sugg,\n+                              Applicability::MachineApplicable\n+                          );\n+                      }\n+                      return Err(err);\n \n-                  }\n-                  _ => {\n-                    // FIXME Could factor this out into non_fatal_unexpected or something.\n-                    let actual = self.this_token_to_string();\n-                    self.span_err(self.span, &format!(\"unexpected token: `{}`\", actual));\n-                  }\n+                    }\n+                    _ => {\n+                        // FIXME Could factor this out into non_fatal_unexpected or something.\n+                        let actual = self.this_token_to_string();\n+                        self.span_err(self.span, &format!(\"unexpected token: `{}`\", actual));\n+                    }\n                 }\n                 continue;\n             }\n@@ -7838,7 +7829,7 @@ impl<'a> Parser<'a> {\n         match self.token {\n             token::Literal(token::Str_(s), suf) | token::Literal(token::StrRaw(s, _), suf) => {\n                 let sp = self.span;\n-                self.expect_no_suffix(sp, \"ABI spec\", suf);\n+                self.expect_no_suffix(sp, \"an ABI spec\", suf);\n                 self.bump();\n                 match abi::lookup(&s.as_str()) {\n                     Some(abi) => Ok(Some(abi)),\n@@ -8659,7 +8650,7 @@ impl<'a> Parser<'a> {\n         match self.parse_optional_str() {\n             Some((s, style, suf)) => {\n                 let sp = self.prev_span;\n-                self.expect_no_suffix(sp, \"string literal\", suf);\n+                self.expect_no_suffix(sp, \"a string literal\", suf);\n                 Ok((s, style))\n             }\n             _ => {"}, {"sha": "0dd67bb95ccaa5d500d2ef6157eedbfc933985d9", "filename": "src/test/codegen/box-maybe-uninit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fcodegen%2Fbox-maybe-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fcodegen%2Fbox-maybe-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fbox-maybe-uninit.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -12,5 +12,8 @@ pub fn box_uninitialized() -> Box<MaybeUninit<usize>> {\n     // CHECK-NOT: alloca\n     // CHECK-NOT: memcpy\n     // CHECK-NOT: memset\n-    Box::new(MaybeUninit::uninitialized())\n+    Box::new(MaybeUninit::uninit())\n }\n+\n+// FIXME: add a test for a bigger box. Currently broken, see\n+// https://github.com/rust-lang/rust/issues/58201."}, {"sha": "7c93e46c30c23ff2fede4848337627b051629191", "filename": "src/test/run-pass/packed/packed-struct-generic-size.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Frun-pass%2Fpacked%2Fpacked-struct-generic-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Frun-pass%2Fpacked%2Fpacked-struct-generic-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked%2Fpacked-struct-generic-size.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -33,12 +33,12 @@ macro_rules! check {\n }\n \n pub fn main() {\n-    check!(P1::<u8, u8>, 1, 3);\n-    check!(P1::<u64, u16>, 1, 11);\n+    check!(P1<u8, u8>, 1, 3);\n+    check!(P1<u64, u16>, 1, 11);\n \n-    check!(P2::<u8, u8>, 1, 3);\n-    check!(P2::<u64, u16>, 2, 12);\n+    check!(P2<u8, u8>, 1, 3);\n+    check!(P2<u64, u16>, 2, 12);\n \n-    check!(P4C::<u8, u8>, 1, 3);\n-    check!(P4C::<u16, u64>, 4, 12);\n+    check!(P4C<u8, u8>, 1, 3);\n+    check!(P4C<u16, u64>, 4, 12);\n }"}, {"sha": "1af476c156866653129aecc797aa494b2f7b1c3d", "filename": "src/test/run-pass/packed/packed-struct-generic-size.stderr", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Ftest%2Frun-pass%2Fpacked%2Fpacked-struct-generic-size.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Ftest%2Frun-pass%2Fpacked%2Fpacked-struct-generic-size.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked%2Fpacked-struct-generic-size.stderr?ref=33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "patch": "@@ -1,36 +0,0 @@\n-warning: unnecessary path disambiguator\n-  --> $DIR/packed-struct-generic-size.rs:36:14\n-   |\n-LL |     check!(P1::<u8, u8>, 1, 3);\n-   |              ^^ try removing `::`\n-\n-warning: unnecessary path disambiguator\n-  --> $DIR/packed-struct-generic-size.rs:37:14\n-   |\n-LL |     check!(P1::<u64, u16>, 1, 11);\n-   |              ^^ try removing `::`\n-\n-warning: unnecessary path disambiguator\n-  --> $DIR/packed-struct-generic-size.rs:39:14\n-   |\n-LL |     check!(P2::<u8, u8>, 1, 3);\n-   |              ^^ try removing `::`\n-\n-warning: unnecessary path disambiguator\n-  --> $DIR/packed-struct-generic-size.rs:40:14\n-   |\n-LL |     check!(P2::<u64, u16>, 2, 12);\n-   |              ^^ try removing `::`\n-\n-warning: unnecessary path disambiguator\n-  --> $DIR/packed-struct-generic-size.rs:42:15\n-   |\n-LL |     check!(P4C::<u8, u8>, 1, 3);\n-   |               ^^ try removing `::`\n-\n-warning: unnecessary path disambiguator\n-  --> $DIR/packed-struct-generic-size.rs:43:15\n-   |\n-LL |     check!(P4C::<u16, u64>, 4, 12);\n-   |               ^^ try removing `::`\n-"}, {"sha": "3f6e489bb83275f6f7b7bbee03806579e91ea459", "filename": "src/test/run-pass/panic-uninitialized-zeroed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -36,7 +36,7 @@ fn main() {\n \n         assert_eq!(\n             panic::catch_unwind(|| {\n-                mem::MaybeUninit::<!>::uninitialized().into_initialized()\n+                mem::MaybeUninit::<!>::uninit().assume_init()\n             }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n                 s == \"Attempted to instantiate uninhabited type !\"\n             })),\n@@ -63,7 +63,7 @@ fn main() {\n \n         assert_eq!(\n             panic::catch_unwind(|| {\n-                mem::MaybeUninit::<Foo>::uninitialized().into_initialized()\n+                mem::MaybeUninit::<Foo>::uninit().assume_init()\n             }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n                 s == \"Attempted to instantiate uninhabited type Foo\"\n             })),\n@@ -90,7 +90,7 @@ fn main() {\n \n         assert_eq!(\n             panic::catch_unwind(|| {\n-                mem::MaybeUninit::<Bar>::uninitialized().into_initialized()\n+                mem::MaybeUninit::<Bar>::uninit().assume_init()\n             }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n                 s == \"Attempted to instantiate uninhabited type Bar\"\n             })),"}, {"sha": "3f0190892ebb3b54006b09167685948f62f10d5a", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -0,0 +1,12 @@\n+#![feature(existential_type)]\n+\n+existential type Foo: Fn() -> Foo;\n+//~^ ERROR: cycle detected when processing `Foo`\n+\n+fn crash(x: Foo) -> Foo {\n+    x\n+}\n+\n+fn main() {\n+\n+}"}, {"sha": "56057a9caa4a557bac5a984c77b5d0c6606344cd", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error.stderr?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -0,0 +1,30 @@\n+error[E0391]: cycle detected when processing `Foo`\n+  --> $DIR/existential-types-with-cycle-error.rs:3:1\n+   |\n+LL | existential type Foo: Fn() -> Foo;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: ...which requires processing `crash`...\n+  --> $DIR/existential-types-with-cycle-error.rs:6:25\n+   |\n+LL |   fn crash(x: Foo) -> Foo {\n+   |  _________________________^\n+LL | |     x\n+LL | | }\n+   | |_^\n+   = note: ...which again requires processing `Foo`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/existential-types-with-cycle-error.rs:1:1\n+   |\n+LL | / #![feature(existential_type)]\n+LL | |\n+LL | | existential type Foo: Fn() -> Foo;\n+LL | |\n+...  |\n+LL | |\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "29410309ef26ef596e4f0a65b0828fd25d38885c", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -0,0 +1,16 @@\n+#![feature(existential_type)]\n+\n+pub trait Bar<T> {\n+    type Item;\n+}\n+\n+existential type Foo: Bar<Foo, Item = Foo>;\n+//~^ ERROR: cycle detected when processing `Foo`\n+\n+fn crash(x: Foo) -> Foo {\n+    x\n+}\n+\n+fn main() {\n+\n+}"}, {"sha": "8c7bf52470ab2ea1cf8f41d14d6b4d0d10e23279", "filename": "src/test/ui/existential_types/existential-types-with-cycle-error2.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-cycle-error2.stderr?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -0,0 +1,30 @@\n+error[E0391]: cycle detected when processing `Foo`\n+  --> $DIR/existential-types-with-cycle-error2.rs:7:1\n+   |\n+LL | existential type Foo: Bar<Foo, Item = Foo>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: ...which requires processing `crash`...\n+  --> $DIR/existential-types-with-cycle-error2.rs:10:25\n+   |\n+LL |   fn crash(x: Foo) -> Foo {\n+   |  _________________________^\n+LL | |     x\n+LL | | }\n+   | |_^\n+   = note: ...which again requires processing `Foo`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/existential-types-with-cycle-error2.rs:1:1\n+   |\n+LL | / #![feature(existential_type)]\n+LL | |\n+LL | | pub trait Bar<T> {\n+LL | |     type Item;\n+...  |\n+LL | |\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "b4bfba4d6e5d7c2a4742c66394cc9afbb4fe82aa", "filename": "src/test/ui/issues/issue-36116.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fissues%2Fissue-36116.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fissues%2Fissue-36116.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36116.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -17,10 +17,10 @@ struct Foo<T> {\n struct S<T>(T);\n \n fn f() {\n-    let f = Some(Foo { _a: 42 }).map(|a| a as Foo::<i32>); //~ WARN unnecessary path disambiguator\n-    let g: Foo::<i32> = Foo { _a: 42 }; //~ WARN unnecessary path disambiguator\n+    let f = Some(Foo { _a: 42 }).map(|a| a as Foo::<i32>);\n+    let g: Foo::<i32> = Foo { _a: 42 };\n \n-    m!(S::<u8>); // OK, no warning\n+    m!(S::<u8>);\n }\n \n "}, {"sha": "5236db29ae4af1fcdc008a7a3035d49b10a5da12", "filename": "src/test/ui/issues/issue-36116.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Ftest%2Fui%2Fissues%2Fissue-36116.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf/src%2Ftest%2Fui%2Fissues%2Fissue-36116.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36116.stderr?ref=33ef0bad21d6bb646c7c3ab0dbf381ca96c324bf", "patch": "@@ -1,12 +0,0 @@\n-warning: unnecessary path disambiguator\n-  --> $DIR/issue-36116.rs:20:50\n-   |\n-LL |     let f = Some(Foo { _a: 42 }).map(|a| a as Foo::<i32>);\n-   |                                                  ^^ try removing `::`\n-\n-warning: unnecessary path disambiguator\n-  --> $DIR/issue-36116.rs:21:15\n-   |\n-LL |     let g: Foo::<i32> = Foo { _a: 42 };\n-   |               ^^ try removing `::`\n-"}, {"sha": "56f85111d428f9678787b045aa51d535c0f15b39", "filename": "src/test/ui/lint/lint-impl-fn.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Flint%2Flint-impl-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Flint%2Flint-impl-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-impl-fn.stderr?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -11,25 +11,25 @@ LL |     #[deny(while_true)]\n    |            ^^^^^^^^^^\n \n error: denote infinite loops with `loop { ... }`\n-  --> $DIR/lint-impl-fn.rs:18:25\n+  --> $DIR/lint-impl-fn.rs:27:5\n    |\n-LL |         fn foo(&self) { while true {} }\n-   |                         ^^^^^^^^^^ help: use `loop`\n+LL |     while true {}\n+   |     ^^^^^^^^^^ help: use `loop`\n    |\n note: lint level defined here\n-  --> $DIR/lint-impl-fn.rs:13:8\n+  --> $DIR/lint-impl-fn.rs:25:8\n    |\n LL | #[deny(while_true)]\n    |        ^^^^^^^^^^\n \n error: denote infinite loops with `loop { ... }`\n-  --> $DIR/lint-impl-fn.rs:27:5\n+  --> $DIR/lint-impl-fn.rs:18:25\n    |\n-LL |     while true {}\n-   |     ^^^^^^^^^^ help: use `loop`\n+LL |         fn foo(&self) { while true {} }\n+   |                         ^^^^^^^^^^ help: use `loop`\n    |\n note: lint level defined here\n-  --> $DIR/lint-impl-fn.rs:25:8\n+  --> $DIR/lint-impl-fn.rs:13:8\n    |\n LL | #[deny(while_true)]\n    |        ^^^^^^^^^^"}, {"sha": "5aaa9947f998a73e80a637f11a0faf47a75cb62a", "filename": "src/test/ui/lint/suggestions.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Flint%2Fsuggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Flint%2Fsuggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fsuggestions.stderr?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -65,6 +65,24 @@ LL | pub fn defiant<T>(_t: T) {}\n    |\n    = note: #[warn(no_mangle_generic_items)] on by default\n \n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/suggestions.rs:46:5\n+   |\n+LL |     while true {\n+   |     ^^^^^^^^^^ help: use `loop`\n+   |\n+   = note: #[warn(while_true)] on by default\n+\n+warning: the `warp_factor:` in this pattern is redundant\n+  --> $DIR/suggestions.rs:61:23\n+   |\n+LL |             Equinox { warp_factor: warp_factor } => {}\n+   |                       ------------^^^^^^^^^^^^\n+   |                       |\n+   |                       help: remove this\n+   |\n+   = note: #[warn(non_shorthand_field_patterns)] on by default\n+\n error: const items should never be #[no_mangle]\n   --> $DIR/suggestions.rs:22:18\n    |\n@@ -97,23 +115,5 @@ LL |     #[no_mangle] pub(crate) fn crossfield<T>() {}\n    |     |\n    |     help: remove this attribute\n \n-warning: denote infinite loops with `loop { ... }`\n-  --> $DIR/suggestions.rs:46:5\n-   |\n-LL |     while true {\n-   |     ^^^^^^^^^^ help: use `loop`\n-   |\n-   = note: #[warn(while_true)] on by default\n-\n-warning: the `warp_factor:` in this pattern is redundant\n-  --> $DIR/suggestions.rs:61:23\n-   |\n-LL |             Equinox { warp_factor: warp_factor } => {}\n-   |                       ------------^^^^^^^^^^^^\n-   |                       |\n-   |                       help: remove this\n-   |\n-   = note: #[warn(non_shorthand_field_patterns)] on by default\n-\n error: aborting due to 3 previous errors\n "}, {"sha": "75bed3088587ca3b4a577498d9d4fefc187c5275", "filename": "src/test/ui/parser/bad-lit-suffixes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -2,20 +2,20 @@\n \n \n extern\n-    \"C\"suffix //~ ERROR ABI spec with a suffix is invalid\n+    \"C\"suffix //~ ERROR suffixes on an ABI spec are invalid\n     fn foo() {}\n \n extern\n-    \"C\"suffix //~ ERROR ABI spec with a suffix is invalid\n+    \"C\"suffix //~ ERROR suffixes on an ABI spec are invalid\n {}\n \n fn main() {\n-    \"\"suffix; //~ ERROR string literal with a suffix is invalid\n-    b\"\"suffix; //~ ERROR byte string literal with a suffix is invalid\n-    r#\"\"#suffix; //~ ERROR string literal with a suffix is invalid\n-    br#\"\"#suffix; //~ ERROR byte string literal with a suffix is invalid\n-    'a'suffix; //~ ERROR char literal with a suffix is invalid\n-    b'a'suffix; //~ ERROR byte literal with a suffix is invalid\n+    \"\"suffix; //~ ERROR suffixes on a string literal are invalid\n+    b\"\"suffix; //~ ERROR suffixes on a byte string literal are invalid\n+    r#\"\"#suffix; //~ ERROR suffixes on a string literal are invalid\n+    br#\"\"#suffix; //~ ERROR suffixes on a byte string literal are invalid\n+    'a'suffix; //~ ERROR suffixes on a char literal are invalid\n+    b'a'suffix; //~ ERROR suffixes on a byte literal are invalid\n \n     1234u1024; //~ ERROR invalid width `1024` for integer literal\n     1234i1024; //~ ERROR invalid width `1024` for integer literal"}, {"sha": "de194f4820de0e0ec47459d30a1cdda4aa72651e", "filename": "src/test/ui/parser/bad-lit-suffixes.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.stderr?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -1,50 +1,50 @@\n-error: ABI spec with a suffix is invalid\n+error: suffixes on an ABI spec are invalid\n   --> $DIR/bad-lit-suffixes.rs:5:5\n    |\n LL |     \"C\"suffix\n-   |     ^^^^^^^^^ ABI spec with a suffix is invalid\n+   |     ^^^^^^^^^ invalid suffix `suffix`\n \n-error: ABI spec with a suffix is invalid\n+error: suffixes on an ABI spec are invalid\n   --> $DIR/bad-lit-suffixes.rs:9:5\n    |\n LL |     \"C\"suffix\n-   |     ^^^^^^^^^ ABI spec with a suffix is invalid\n+   |     ^^^^^^^^^ invalid suffix `suffix`\n \n-error: string literal with a suffix is invalid\n+error: suffixes on a string literal are invalid\n   --> $DIR/bad-lit-suffixes.rs:13:5\n    |\n LL |     \"\"suffix;\n-   |     ^^^^^^^^ string literal with a suffix is invalid\n+   |     ^^^^^^^^ invalid suffix `suffix`\n \n-error: byte string literal with a suffix is invalid\n+error: suffixes on a byte string literal are invalid\n   --> $DIR/bad-lit-suffixes.rs:14:5\n    |\n LL |     b\"\"suffix;\n-   |     ^^^^^^^^^ byte string literal with a suffix is invalid\n+   |     ^^^^^^^^^ invalid suffix `suffix`\n \n-error: string literal with a suffix is invalid\n+error: suffixes on a string literal are invalid\n   --> $DIR/bad-lit-suffixes.rs:15:5\n    |\n LL |     r#\"\"#suffix;\n-   |     ^^^^^^^^^^^ string literal with a suffix is invalid\n+   |     ^^^^^^^^^^^ invalid suffix `suffix`\n \n-error: byte string literal with a suffix is invalid\n+error: suffixes on a byte string literal are invalid\n   --> $DIR/bad-lit-suffixes.rs:16:5\n    |\n LL |     br#\"\"#suffix;\n-   |     ^^^^^^^^^^^^ byte string literal with a suffix is invalid\n+   |     ^^^^^^^^^^^^ invalid suffix `suffix`\n \n-error: char literal with a suffix is invalid\n+error: suffixes on a char literal are invalid\n   --> $DIR/bad-lit-suffixes.rs:17:5\n    |\n LL |     'a'suffix;\n-   |     ^^^^^^^^^ char literal with a suffix is invalid\n+   |     ^^^^^^^^^ invalid suffix `suffix`\n \n-error: byte literal with a suffix is invalid\n+error: suffixes on a byte literal are invalid\n   --> $DIR/bad-lit-suffixes.rs:18:5\n    |\n LL |     b'a'suffix;\n-   |     ^^^^^^^^^^ byte literal with a suffix is invalid\n+   |     ^^^^^^^^^^ invalid suffix `suffix`\n \n error: invalid width `1024` for integer literal\n   --> $DIR/bad-lit-suffixes.rs:20:5"}, {"sha": "0fa191d4a7ef430385ac7eb1b36383671a257255", "filename": "src/test/ui/parser/issue-59418.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fparser%2Fissue-59418.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fparser%2Fissue-59418.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-59418.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -0,0 +1,18 @@\n+struct X(i32,i32,i32);\n+\n+fn main() {\n+    let a = X(1, 2, 3);\n+    let b = a.1suffix;\n+    //~^ ERROR suffixes on a tuple index are invalid\n+    println!(\"{}\", b);\n+    let c = (1, 2, 3);\n+    let d = c.1suffix;\n+    //~^ ERROR suffixes on a tuple index are invalid\n+    println!(\"{}\", d);\n+    let s = X { 0suffix: 0, 1: 1, 2: 2 };\n+    //~^ ERROR suffixes on a tuple index are invalid\n+    match s {\n+        X { 0suffix: _, .. } => {}\n+        //~^ ERROR suffixes on a tuple index are invalid\n+    }\n+}"}, {"sha": "347051e9f921c5b24700367b194fccc403db47c5", "filename": "src/test/ui/parser/issue-59418.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fparser%2Fissue-59418.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fparser%2Fissue-59418.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-59418.stderr?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -0,0 +1,26 @@\n+error: suffixes on a tuple index are invalid\n+  --> $DIR/issue-59418.rs:5:15\n+   |\n+LL |     let b = a.1suffix;\n+   |               ^^^^^^^ invalid suffix `suffix`\n+\n+error: suffixes on a tuple index are invalid\n+  --> $DIR/issue-59418.rs:9:15\n+   |\n+LL |     let d = c.1suffix;\n+   |               ^^^^^^^ invalid suffix `suffix`\n+\n+error: suffixes on a tuple index are invalid\n+  --> $DIR/issue-59418.rs:12:17\n+   |\n+LL |     let s = X { 0suffix: 0, 1: 1, 2: 2 };\n+   |                 ^^^^^^^ invalid suffix `suffix`\n+\n+error: suffixes on a tuple index are invalid\n+  --> $DIR/issue-59418.rs:15:13\n+   |\n+LL |         X { 0suffix: _, .. } => {}\n+   |             ^^^^^^^ invalid suffix `suffix`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "9793ee801d185cfb5be7e09a50c6b3dd70d4a0a0", "filename": "src/test/ui/suggestions/into-str.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -0,0 +1,6 @@\n+fn foo<'a, T>(_t: T) where T: Into<&'a str> {}\n+\n+fn main() {\n+    foo(String::new());\n+    //~^ ERROR the trait bound `&str: std::convert::From<std::string::String>` is not satisfied\n+}"}, {"sha": "3e28700ce9552e36590a7db415b53ad4d039237a", "filename": "src/test/ui/suggestions/into-str.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -0,0 +1,17 @@\n+error[E0277]: the trait bound `&str: std::convert::From<std::string::String>` is not satisfied\n+  --> $DIR/into-str.rs:4:5\n+   |\n+LL |     foo(String::new());\n+   |     ^^^ the trait `std::convert::From<std::string::String>` is not implemented for `&str`\n+   |\n+   = note: to coerce a `std::string::String` into a `&str`, use `&*` as a prefix\n+   = note: required because of the requirements on the impl of `std::convert::Into<&str>` for `std::string::String`\n+note: required by `foo`\n+  --> $DIR/into-str.rs:1:1\n+   |\n+LL | fn foo<'a, T>(_t: T) where T: Into<&'a str> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "03830fea062cf7d660f63c0da91af450a45d703b", "filename": "src/test/ui/type/type-check/assignment-expected-bool.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -0,0 +1,34 @@\n+// The purpose of this text is to ensure that we get good\n+// diagnostics when a `bool` is expected but that due to\n+// an assignment expression `x = y` the type is `()`.\n+\n+fn main() {\n+    let _: bool = 0 = 0; //~ ERROR mismatched types [E0308]\n+\n+    let _: bool = match 0 {\n+        0 => 0 = 0, //~ ERROR mismatched types [E0308]\n+        _ => 0 = 0, //~ ERROR mismatched types [E0308]\n+    };\n+\n+    let _: bool = match true {\n+        true => 0 = 0, //~ ERROR mismatched types [E0308]\n+        _ => (),\n+    };\n+\n+    if 0 = 0 {} //~ ERROR mismatched types [E0308]\n+\n+    let _: bool = if { 0 = 0 } { //~ ERROR mismatched types [E0308]\n+        0 = 0 //~ ERROR mismatched types [E0308]\n+    } else {\n+        0 = 0 //~ ERROR mismatched types [E0308]\n+    };\n+\n+    let _ = (0 = 0) //~ ERROR mismatched types [E0308]\n+        && { 0 = 0 } //~ ERROR mismatched types [E0308]\n+        || (0 = 0); //~ ERROR mismatched types [E0308]\n+\n+    // A test to check that not expecting `bool` behaves well:\n+    let _: usize = 0 = 0;\n+    //~^ ERROR mismatched types [E0308]\n+    //~| ERROR invalid left-hand side expression [E0070]\n+}"}, {"sha": "fed8b913465827c3547b116a6603700163b45988", "filename": "src/test/ui/type/type-check/assignment-expected-bool.stderr", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-expected-bool.stderr?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -0,0 +1,151 @@\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:6:19\n+   |\n+LL |     let _: bool = 0 = 0;\n+   |                   ^^^^^\n+   |                   |\n+   |                   expected bool, found ()\n+   |                   help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:9:14\n+   |\n+LL |         0 => 0 = 0,\n+   |              ^^^^^\n+   |              |\n+   |              expected bool, found ()\n+   |              help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:10:14\n+   |\n+LL |         _ => 0 = 0,\n+   |              ^^^^^\n+   |              |\n+   |              expected bool, found ()\n+   |              help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:14:17\n+   |\n+LL |         true => 0 = 0,\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected bool, found ()\n+   |                 help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:18:8\n+   |\n+LL |     if 0 = 0 {}\n+   |        ^^^^^\n+   |        |\n+   |        expected bool, found ()\n+   |        help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:20:24\n+   |\n+LL |     let _: bool = if { 0 = 0 } {\n+   |                        ^^^^^\n+   |                        |\n+   |                        expected bool, found ()\n+   |                        help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:21:9\n+   |\n+LL |         0 = 0\n+   |         ^^^^^\n+   |         |\n+   |         expected bool, found ()\n+   |         help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:23:9\n+   |\n+LL |         0 = 0\n+   |         ^^^^^\n+   |         |\n+   |         expected bool, found ()\n+   |         help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:26:13\n+   |\n+LL |     let _ = (0 = 0)\n+   |             ^^^^^^^\n+   |             |\n+   |             expected bool, found ()\n+   |             help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:27:14\n+   |\n+LL |         && { 0 = 0 }\n+   |              ^^^^^\n+   |              |\n+   |              expected bool, found ()\n+   |              help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:28:12\n+   |\n+LL |         || (0 = 0);\n+   |            ^^^^^^^\n+   |            |\n+   |            expected bool, found ()\n+   |            help: try comparing for equality: `0 == 0`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error[E0070]: invalid left-hand side expression\n+  --> $DIR/assignment-expected-bool.rs:31:20\n+   |\n+LL |     let _: usize = 0 = 0;\n+   |                    ^^^^^ left-hand of expression not valid\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-expected-bool.rs:31:20\n+   |\n+LL |     let _: usize = 0 = 0;\n+   |                    ^^^^^ expected usize, found ()\n+   |\n+   = note: expected type `usize`\n+              found type `()`\n+\n+error: aborting due to 13 previous errors\n+\n+Some errors occurred: E0070, E0308.\n+For more information about an error, try `rustc --explain E0070`."}, {"sha": "77b122b0a794a779c22dad1ebd69379973c86833", "filename": "src/test/ui/type/type-check/assignment-in-if.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.rs?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -31,8 +31,13 @@ fn main() {\n         //~^ ERROR mismatched types\n         println!(\"{}\", x);\n     }\n-    if (if true { x = 4 } else { x = 5 }) {\n-        //~^ ERROR mismatched types\n+    if (\n+        if true {\n+            x = 4 //~ ERROR mismatched types\n+        } else {\n+            x = 5 //~ ERROR mismatched types\n+        }\n+    ) {\n         println!(\"{}\", x);\n     }\n }"}, {"sha": "87b8d17c21bcca0a8a3fc9fb631d630f9e6fa42d", "filename": "src/test/ui/type/type-check/assignment-in-if.stderr", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d20e0002725d2b3efff23c97450806b3517ba804/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr?ref=d20e0002725d2b3efff23c97450806b3517ba804", "patch": "@@ -47,14 +47,29 @@ LL |     if 3 = x {\n               found type `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/assignment-in-if.rs:34:8\n+  --> $DIR/assignment-in-if.rs:36:13\n    |\n-LL |     if (if true { x = 4 } else { x = 5 }) {\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bool, found ()\n+LL |             x = 4\n+   |             ^^^^^\n+   |             |\n+   |             expected bool, found ()\n+   |             help: try comparing for equality: `x == 4`\n    |\n    = note: expected type `bool`\n               found type `()`\n \n-error: aborting due to 5 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/assignment-in-if.rs:38:13\n+   |\n+LL |             x = 5\n+   |             ^^^^^\n+   |             |\n+   |             expected bool, found ()\n+   |             help: try comparing for equality: `x == 5`\n+   |\n+   = note: expected type `bool`\n+              found type `()`\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}