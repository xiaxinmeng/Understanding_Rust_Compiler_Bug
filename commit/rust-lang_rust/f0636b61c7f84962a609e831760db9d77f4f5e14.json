{"sha": "f0636b61c7f84962a609e831760db9d77f4f5e14", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNjM2YjYxYzdmODQ5NjJhNjA5ZTgzMTc2MGRiOWQ3N2Y0ZjVlMTQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-03-10T04:25:57Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-09T13:06:56Z"}, "message": "rustc_trans: use ty::layout for ABI computation instead of LLVM types.", "tree": {"sha": "ee4927e74f9203abebcd8ab2a327dc6b41cdd73e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee4927e74f9203abebcd8ab2a327dc6b41cdd73e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0636b61c7f84962a609e831760db9d77f4f5e14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0636b61c7f84962a609e831760db9d77f4f5e14", "html_url": "https://github.com/rust-lang/rust/commit/f0636b61c7f84962a609e831760db9d77f4f5e14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0636b61c7f84962a609e831760db9d77f4f5e14/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43b227f3bdea473c69cb5568adfedfbbb18ff929", "url": "https://api.github.com/repos/rust-lang/rust/commits/43b227f3bdea473c69cb5568adfedfbbb18ff929", "html_url": "https://github.com/rust-lang/rust/commit/43b227f3bdea473c69cb5568adfedfbbb18ff929"}], "stats": {"total": 2664, "additions": 992, "deletions": 1672}, "files": [{"sha": "7be80a757ca0166a300c275e96a6ca8f1320cd3b", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 400, "deletions": 185, "changes": 585, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef, Integer, Pointer, Float, Double, Struct, Array, Vector, AttributePlace};\n+use llvm::{self, ValueRef, AttributePlace};\n use base;\n use builder::Builder;\n use common::{type_is_fat_ptr, C_uint};\n@@ -29,16 +29,17 @@ use cabi_sparc;\n use cabi_sparc64;\n use cabi_nvptx;\n use cabi_nvptx64;\n-use machine::{llalign_of_min, llsize_of, llsize_of_alloc};\n+use machine::llalign_of_min;\n use type_::Type;\n use type_of;\n \n use rustc::hir;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{Layout, LayoutTyper};\n+use rustc::ty::layout::{self, Layout, LayoutTyper, TyLayout, Size};\n \n use libc::c_uint;\n use std::cmp;\n+use std::iter;\n \n pub use syntax::abi::Abi;\n pub use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n@@ -132,33 +133,293 @@ impl ArgAttributes {\n         }\n     }\n }\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum RegKind {\n+    Integer,\n+    Float,\n+    Vector\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct Reg {\n+    pub kind: RegKind,\n+    pub size: Size,\n+}\n+\n+macro_rules! reg_ctor {\n+    ($name:ident, $kind:ident, $bits:expr) => {\n+        pub fn $name() -> Reg {\n+            Reg {\n+                kind: RegKind::$kind,\n+                size: Size::from_bits($bits)\n+            }\n+        }\n+    }\n+}\n+\n+impl Reg {\n+    reg_ctor!(i8, Integer, 8);\n+    reg_ctor!(i16, Integer, 16);\n+    reg_ctor!(i32, Integer, 32);\n+    reg_ctor!(i64, Integer, 64);\n+\n+    reg_ctor!(f32, Float, 32);\n+    reg_ctor!(f64, Float, 64);\n+}\n+\n+impl Reg {\n+    fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+        match self.kind {\n+            RegKind::Integer => Type::ix(ccx, self.size.bits()),\n+            RegKind::Float => {\n+                match self.size.bits() {\n+                    32 => Type::f32(ccx),\n+                    64 => Type::f64(ccx),\n+                    _ => bug!(\"unsupported float: {:?}\", self)\n+                }\n+            }\n+            RegKind::Vector => {\n+                Type::vector(&Type::i8(ccx), self.size.bytes())\n+            }\n+        }\n+    }\n+}\n+\n+/// An argument passed entirely registers with the\n+/// same kind (e.g. HFA / HVA on PPC64 and AArch64).\n+#[derive(Copy, Clone)]\n+pub struct Uniform {\n+    pub unit: Reg,\n+\n+    /// The total size of the argument, which can be:\n+    /// * equal to `unit.size` (one scalar/vector)\n+    /// * a multiple of `unit.size` (an array of scalar/vectors)\n+    /// * if `unit.kind` is `Integer`, the last element\n+    ///   can be shorter, i.e. `{ i64, i64, i32 }` for\n+    ///   64-bit integers with a total size of 20 bytes\n+    pub total: Size,\n+}\n+\n+impl From<Reg> for Uniform {\n+    fn from(unit: Reg) -> Uniform {\n+        Uniform {\n+            unit,\n+            total: unit.size\n+        }\n+    }\n+}\n+\n+impl Uniform {\n+    fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+        let llunit = self.unit.llvm_type(ccx);\n+\n+        if self.total <= self.unit.size {\n+            return llunit;\n+        }\n+\n+        let count = self.total.bytes() / self.unit.size.bytes();\n+        let rem_bytes = self.total.bytes() % self.unit.size.bytes();\n+\n+        if rem_bytes == 0 {\n+            return Type::array(&llunit, count);\n+        }\n+\n+        // Only integers can be really split further.\n+        assert_eq!(self.unit.kind, RegKind::Integer);\n+\n+        let args: Vec<_> = (0..count).map(|_| llunit)\n+            .chain(iter::once(Type::ix(ccx, rem_bytes * 8)))\n+            .collect();\n+\n+        Type::struct_(ccx, &args, false)\n+    }\n+}\n+\n+pub trait LayoutExt<'tcx> {\n+    fn is_aggregate(&self) -> bool;\n+    fn homogenous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg>;\n+}\n+\n+impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n+    fn is_aggregate(&self) -> bool {\n+        match *self.layout {\n+            Layout::Scalar { .. } |\n+            Layout::RawNullablePointer { .. } |\n+            Layout::CEnum { .. } |\n+            Layout::Vector { .. } => false,\n+\n+            Layout::Array { .. } |\n+            Layout::FatPointer { .. } |\n+            Layout::Univariant { .. } |\n+            Layout::UntaggedUnion { .. } |\n+            Layout::General { .. } |\n+            Layout::StructWrappedNullablePointer { .. } => true\n+        }\n+    }\n+\n+    fn homogenous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg> {\n+        match *self.layout {\n+            // The primitives for this algorithm.\n+            Layout::Scalar { value, .. } |\n+            Layout::RawNullablePointer { value, .. } => {\n+                let kind = match value {\n+                    layout::Int(_) |\n+                    layout::Pointer => RegKind::Integer,\n+                    layout::F32 |\n+                    layout::F64 => RegKind::Float\n+                };\n+                Some(Reg {\n+                    kind,\n+                    size: self.size(ccx)\n+                })\n+            }\n+\n+            Layout::CEnum { .. } => {\n+                Some(Reg {\n+                    kind: RegKind::Integer,\n+                    size: self.size(ccx)\n+                })\n+            }\n+\n+            Layout::Vector { .. } => {\n+                Some(Reg {\n+                    kind: RegKind::Integer,\n+                    size: self.size(ccx)\n+                })\n+            }\n+\n+            Layout::Array { count, .. } => {\n+                if count > 0 {\n+                    self.field(ccx, 0).homogenous_aggregate(ccx)\n+                } else {\n+                    None\n+                }\n+            }\n+\n+            Layout::Univariant { ref variant, .. } => {\n+                let mut unaligned_offset = Size::from_bytes(0);\n+                let mut result = None;\n+\n+                for i in 0..self.field_count() {\n+                    if unaligned_offset != variant.offsets[i] {\n+                        return None;\n+                    }\n+\n+                    let field = self.field(ccx, i);\n+                    match (result, field.homogenous_aggregate(ccx)) {\n+                        // The field itself must be a homogenous aggregate.\n+                        (_, None) => return None,\n+                        // If this is the first field, record the unit.\n+                        (None, Some(unit)) => {\n+                            result = Some(unit);\n+                        }\n+                        // For all following fields, the unit must be the same.\n+                        (Some(prev_unit), Some(unit)) => {\n+                            if prev_unit != unit {\n+                                return None;\n+                            }\n+                        }\n+                    }\n+\n+                    // Keep track of the offset (without padding).\n+                    let size = field.size(ccx);\n+                    match unaligned_offset.checked_add(size, ccx) {\n+                        Some(offset) => unaligned_offset = offset,\n+                        None => return None\n+                    }\n+                }\n+\n+                // There needs to be no padding.\n+                if unaligned_offset != self.size(ccx) {\n+                    None\n+                } else {\n+                    result\n+                }\n+            }\n+\n+            Layout::UntaggedUnion { .. } => {\n+                let mut max = Size::from_bytes(0);\n+                let mut result = None;\n+\n+                for i in 0..self.field_count() {\n+                    let field = self.field(ccx, i);\n+                    match (result, field.homogenous_aggregate(ccx)) {\n+                        // The field itself must be a homogenous aggregate.\n+                        (_, None) => return None,\n+                        // If this is the first field, record the unit.\n+                        (None, Some(unit)) => {\n+                            result = Some(unit);\n+                        }\n+                        // For all following fields, the unit must be the same.\n+                        (Some(prev_unit), Some(unit)) => {\n+                            if prev_unit != unit {\n+                                return None;\n+                            }\n+                        }\n+                    }\n+\n+                    // Keep track of the offset (without padding).\n+                    let size = field.size(ccx);\n+                    if size > max {\n+                        max = size;\n+                    }\n+                }\n+\n+                // There needs to be no padding.\n+                if max != self.size(ccx) {\n+                    None\n+                } else {\n+                    result\n+                }\n+            }\n+\n+            // Rust-specific types, which we can ignore for C ABIs.\n+            Layout::FatPointer { .. } |\n+            Layout::General { .. } |\n+            Layout::StructWrappedNullablePointer { .. } => None\n+        }\n+    }\n+}\n+\n+pub enum CastTarget {\n+    Uniform(Uniform),\n+    Pair(Reg, Reg)\n+}\n+\n+impl From<Reg> for CastTarget {\n+    fn from(unit: Reg) -> CastTarget {\n+        CastTarget::Uniform(Uniform::from(unit))\n+    }\n+}\n+\n+impl From<Uniform> for CastTarget {\n+    fn from(uniform: Uniform) -> CastTarget {\n+        CastTarget::Uniform(uniform)\n+    }\n+}\n+\n+impl CastTarget {\n+    fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+        match *self {\n+            CastTarget::Uniform(u) => u.llvm_type(ccx),\n+            CastTarget::Pair(a, b) => {\n+                Type::struct_(ccx, &[\n+                    a.llvm_type(ccx),\n+                    b.llvm_type(ccx)\n+                ], false)\n+            }\n+        }\n+    }\n+}\n \n /// Information about how a specific C type\n /// should be passed to or returned from a function\n ///\n /// This is borrowed from clang's ABIInfo.h\n #[derive(Clone, Copy, Debug)]\n-pub struct ArgType {\n+pub struct ArgType<'tcx> {\n     kind: ArgKind,\n-    /// Original LLVM type\n-    pub original_ty: Type,\n-    /// Sizing LLVM type (pointers are opaque).\n-    /// Unlike original_ty, this is guaranteed to be complete.\n-    ///\n-    /// For example, while we're computing the function pointer type in\n-    /// `struct Foo(fn(Foo));`, `original_ty` is still LLVM's `%Foo = {}`.\n-    /// The field type will likely end up being `void(%Foo)*`, but we cannot\n-    /// use `%Foo` to compute properties (e.g. size and alignment) of `Foo`,\n-    /// until `%Foo` is completed by having all of its field types inserted,\n-    /// so `ty` holds the \"sizing type\" of `Foo`, which replaces all pointers\n-    /// with opaque ones, resulting in `{i8*}` for `Foo`.\n-    /// ABI-specific logic can then look at the size, alignment and fields of\n-    /// `{i8*}` in order to determine how the argument will be passed.\n-    /// Only later will `original_ty` aka `%Foo` be used in the LLVM function\n-    /// pointer type, without ever having introspected it.\n-    pub ty: Type,\n-    /// Signedness for integer types, None for other types\n-    pub signedness: Option<bool>,\n+    pub layout: TyLayout<'tcx>,\n     /// Coerced LLVM Type\n     pub cast: Option<Type>,\n     /// Dummy argument, which is emitted before the real argument\n@@ -167,26 +428,24 @@ pub struct ArgType {\n     pub attrs: ArgAttributes\n }\n \n-impl ArgType {\n-    fn new(original_ty: Type, ty: Type) -> ArgType {\n+impl<'a, 'tcx> ArgType<'tcx> {\n+    fn new(layout: TyLayout<'tcx>) -> ArgType<'tcx> {\n         ArgType {\n             kind: ArgKind::Direct,\n-            original_ty: original_ty,\n-            ty: ty,\n-            signedness: None,\n+            layout: layout,\n             cast: None,\n             pad: None,\n             attrs: ArgAttributes::default()\n         }\n     }\n \n-    pub fn make_indirect(&mut self, ccx: &CrateContext) {\n+    pub fn make_indirect(&mut self, ccx: &CrateContext<'a, 'tcx>) {\n         assert_eq!(self.kind, ArgKind::Direct);\n \n         // Wipe old attributes, likely not valid through indirection.\n         self.attrs = ArgAttributes::default();\n \n-        let llarg_sz = llsize_of_alloc(ccx, self.ty);\n+        let llarg_sz = self.layout.size(ccx).bytes();\n \n         // For non-immediate arguments the callee gets its own copy of\n         // the value on the stack, so there are no aliases. It's also\n@@ -205,17 +464,44 @@ impl ArgType {\n \n     pub fn extend_integer_width_to(&mut self, bits: u64) {\n         // Only integers have signedness\n-        if let Some(signed) = self.signedness {\n-            if self.ty.int_width() < bits {\n-                self.attrs.set(if signed {\n-                    ArgAttribute::SExt\n-                } else {\n-                    ArgAttribute::ZExt\n-                });\n+        let (i, signed) = match *self.layout {\n+            Layout::Scalar { value, .. } => {\n+                match value {\n+                    layout::Int(i) => {\n+                        if self.layout.ty.is_integral() {\n+                            (i, self.layout.ty.is_signed())\n+                        } else {\n+                            return;\n+                        }\n+                    }\n+                    _ => return\n+                }\n             }\n+\n+            // Rust enum types that map onto C enums also need to follow\n+            // the target ABI zero-/sign-extension rules.\n+            Layout::CEnum { discr, signed, .. } => (discr, signed),\n+\n+            _ => return\n+        };\n+\n+        if i.size().bits() < bits {\n+            self.attrs.set(if signed {\n+                ArgAttribute::SExt\n+            } else {\n+                ArgAttribute::ZExt\n+            });\n         }\n     }\n \n+    pub fn cast_to<T: Into<CastTarget>>(&mut self, ccx: &CrateContext, target: T) {\n+        self.cast = Some(target.into().llvm_type(ccx));\n+    }\n+\n+    pub fn pad_with(&mut self, ccx: &CrateContext, reg: Reg) {\n+        self.pad = Some(reg.llvm_type(ccx));\n+    }\n+\n     pub fn is_indirect(&self) -> bool {\n         self.kind == ArgKind::Indirect\n     }\n@@ -224,27 +510,33 @@ impl ArgType {\n         self.kind == ArgKind::Ignore\n     }\n \n+    /// Get the LLVM type for an lvalue of the original Rust type of\n+    /// this argument/return, i.e. the result of `type_of::type_of`.\n+    pub fn memory_ty(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n+        type_of::type_of(ccx, self.layout.ty)\n+    }\n+\n     /// Store a direct/indirect value described by this ArgType into a\n     /// lvalue for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    pub fn store(&self, bcx: &Builder, mut val: ValueRef, dst: ValueRef) {\n+    pub fn store(&self, bcx: &Builder<'a, 'tcx>, mut val: ValueRef, dst: ValueRef) {\n         if self.is_ignore() {\n             return;\n         }\n         let ccx = bcx.ccx;\n         if self.is_indirect() {\n-            let llsz = llsize_of(ccx, self.ty);\n-            let llalign = llalign_of_min(ccx, self.ty);\n+            let llsz = C_uint(ccx, self.layout.size(ccx).bytes());\n+            let llalign = self.layout.align(ccx).abi();\n             base::call_memcpy(bcx, dst, val, llsz, llalign as u32);\n         } else if let Some(ty) = self.cast {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n             if can_store_through_cast_ptr {\n                 let cast_dst = bcx.pointercast(dst, ty.ptr_to());\n-                let llalign = llalign_of_min(ccx, self.ty);\n-                bcx.store(val, cast_dst, Some(llalign));\n+                let llalign = self.layout.align(ccx).abi();\n+                bcx.store(val, cast_dst, Some(llalign as u32));\n             } else {\n                 // The actual return type is a struct, but the ABI\n                 // adaptation code has cast it into some scalar type.  The\n@@ -271,21 +563,21 @@ impl ArgType {\n                 base::call_memcpy(bcx,\n                                   bcx.pointercast(dst, Type::i8p(ccx)),\n                                   bcx.pointercast(llscratch, Type::i8p(ccx)),\n-                                  C_uint(ccx, llsize_of_alloc(ccx, self.ty)),\n-                                  cmp::min(llalign_of_min(ccx, self.ty),\n-                                           llalign_of_min(ccx, ty)) as u32);\n+                                  C_uint(ccx, self.layout.size(ccx).bytes()),\n+                                  cmp::min(self.layout.align(ccx).abi() as u32,\n+                                           llalign_of_min(ccx, ty)));\n \n                 base::Lifetime::End.call(bcx, llscratch);\n             }\n         } else {\n-            if self.original_ty == Type::i1(ccx) {\n+            if self.layout.ty == ccx.tcx().types.bool {\n                 val = bcx.zext(val, Type::i8(ccx));\n             }\n             bcx.store(val, dst, None);\n         }\n     }\n \n-    pub fn store_fn_arg(&self, bcx: &Builder, idx: &mut usize, dst: ValueRef) {\n+    pub fn store_fn_arg(&self, bcx: &Builder<'a, 'tcx>, idx: &mut usize, dst: ValueRef) {\n         if self.pad.is_some() {\n             *idx += 1;\n         }\n@@ -304,40 +596,40 @@ impl ArgType {\n /// I will do my best to describe this structure, but these\n /// comments are reverse-engineered and may be inaccurate. -NDM\n #[derive(Clone, Debug)]\n-pub struct FnType {\n+pub struct FnType<'tcx> {\n     /// The LLVM types of each argument.\n-    pub args: Vec<ArgType>,\n+    pub args: Vec<ArgType<'tcx>>,\n \n     /// LLVM return type.\n-    pub ret: ArgType,\n+    pub ret: ArgType<'tcx>,\n \n     pub variadic: bool,\n \n     pub cconv: llvm::CallConv\n }\n \n-impl FnType {\n-    pub fn new<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                         sig: ty::FnSig<'tcx>,\n-                         extra_args: &[Ty<'tcx>]) -> FnType {\n+impl<'a, 'tcx> FnType<'tcx> {\n+    pub fn new(ccx: &CrateContext<'a, 'tcx>,\n+               sig: ty::FnSig<'tcx>,\n+               extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n         let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n         fn_ty.adjust_for_abi(ccx, sig);\n         fn_ty\n     }\n \n-    pub fn new_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                sig: ty::FnSig<'tcx>,\n-                                extra_args: &[Ty<'tcx>]) -> FnType {\n+    pub fn new_vtable(ccx: &CrateContext<'a, 'tcx>,\n+                      sig: ty::FnSig<'tcx>,\n+                      extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n         let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n         // Don't pass the vtable, it's not an argument of the virtual fn.\n         fn_ty.args[1].ignore();\n         fn_ty.adjust_for_abi(ccx, sig);\n         fn_ty\n     }\n \n-    fn unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                            sig: ty::FnSig<'tcx>,\n-                            extra_args: &[Ty<'tcx>]) -> FnType {\n+    pub fn unadjusted(ccx: &CrateContext<'a, 'tcx>,\n+                      sig: ty::FnSig<'tcx>,\n+                      extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n         use self::Abi::*;\n         let cconv = match ccx.sess().target.target.adjust_abi(sig.abi) {\n             RustIntrinsic | PlatformIntrinsic |\n@@ -394,23 +686,11 @@ impl FnType {\n         };\n \n         let arg_of = |ty: Ty<'tcx>, is_return: bool| {\n+            let mut arg = ArgType::new(ccx.layout_of(ty));\n             if ty.is_bool() {\n-                let llty = Type::i1(ccx);\n-                let mut arg = ArgType::new(llty, llty);\n                 arg.attrs.set(ArgAttribute::ZExt);\n-                arg\n             } else {\n-                let mut arg = ArgType::new(type_of::type_of(ccx, ty),\n-                                           type_of::sizing_type_of(ccx, ty));\n-                if ty.is_integral() {\n-                    arg.signedness = Some(ty.is_signed());\n-                }\n-                // Rust enum types that map onto C enums also need to follow\n-                // the target ABI zero-/sign-extension rules.\n-                if let Layout::CEnum { signed, .. } = *ccx.layout_of(ty) {\n-                    arg.signedness = Some(signed);\n-                }\n-                if llsize_of_alloc(ccx, arg.ty) == 0 {\n+                if arg.layout.size(ccx).bytes() == 0 {\n                     // For some forsaken reason, x86_64-pc-windows-gnu\n                     // doesn't ignore zero-sized struct arguments.\n                     // The same is true for s390x-unknown-linux-gnu.\n@@ -419,8 +699,8 @@ impl FnType {\n                         arg.ignore();\n                     }\n                 }\n-                arg\n             }\n+            arg\n         };\n \n         let ret_ty = sig.output();\n@@ -491,13 +771,9 @@ impl FnType {\n         for ty in inputs.iter().chain(extra_args.iter()) {\n             let mut arg = arg_of(ty, false);\n \n-            if type_is_fat_ptr(ccx, ty) {\n-                let original_tys = arg.original_ty.field_types();\n-                let sizing_tys = arg.ty.field_types();\n-                assert_eq!((original_tys.len(), sizing_tys.len()), (2, 2));\n-\n-                let mut data = ArgType::new(original_tys[0], sizing_tys[0]);\n-                let mut info = ArgType::new(original_tys[1], sizing_tys[1]);\n+            if let ty::layout::FatPointer { .. } = *arg.layout {\n+                let mut data = ArgType::new(arg.layout.field(ccx, 0));\n+                let mut info = ArgType::new(arg.layout.field(ccx, 1));\n \n                 if let Some(inner) = rust_ptr_attrs(ty, &mut data) {\n                     data.attrs.set(ArgAttribute::NonNull);\n@@ -527,43 +803,51 @@ impl FnType {\n         }\n     }\n \n-    fn adjust_for_abi<'a, 'tcx>(&mut self,\n-                                ccx: &CrateContext<'a, 'tcx>,\n-                                sig: ty::FnSig<'tcx>) {\n+    fn adjust_for_abi(&mut self,\n+                      ccx: &CrateContext<'a, 'tcx>,\n+                      sig: ty::FnSig<'tcx>) {\n         let abi = sig.abi;\n         if abi == Abi::Unadjusted { return }\n \n         if abi == Abi::Rust || abi == Abi::RustCall ||\n            abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-            let fixup = |arg: &mut ArgType| {\n-                let mut llty = arg.ty;\n-\n-                // Replace newtypes with their inner-most type.\n-                while llty.kind() == llvm::TypeKind::Struct {\n-                    let inner = llty.field_types();\n-                    if inner.len() != 1 {\n-                        break;\n-                    }\n-                    llty = inner[0];\n+            let fixup = |arg: &mut ArgType<'tcx>| {\n+                if !arg.layout.is_aggregate() {\n+                    return;\n                 }\n \n-                if !llty.is_aggregate() {\n-                    // Scalars and vectors, always immediate.\n-                    if llty != arg.ty {\n+                let size = arg.layout.size(ccx);\n+\n+                if let Some(unit) = arg.layout.homogenous_aggregate(ccx) {\n+                    // Replace newtypes with their inner-most type.\n+                    if unit.size == size {\n                         // Needs a cast as we've unpacked a newtype.\n-                        arg.cast = Some(llty);\n+                        arg.cast_to(ccx, unit);\n+                        return;\n+                    }\n+\n+                    // Pairs of floats.\n+                    if unit.kind == RegKind::Float {\n+                        if unit.size.checked_mul(2, ccx) == Some(size) {\n+                            // FIXME(eddyb) This should be using Uniform instead of a pair,\n+                            // but the resulting [2 x float/double] breaks emscripten.\n+                            // See https://github.com/kripken/emscripten-fastcomp/issues/178.\n+                            arg.cast_to(ccx, CastTarget::Pair(unit, unit));\n+                            return;\n+                        }\n                     }\n-                    return;\n                 }\n \n-                let size = llsize_of_alloc(ccx, llty);\n-                if size > llsize_of_alloc(ccx, ccx.int_type()) {\n+                if size > layout::Pointer.size(ccx) {\n                     arg.make_indirect(ccx);\n-                } else if size > 0 {\n+                } else {\n                     // We want to pass small aggregates as immediates, but using\n                     // a LLVM aggregate type for this leads to bad optimizations,\n                     // so we pick an appropriately sized integer type instead.\n-                    arg.cast = Some(Type::ix(ccx, size * 8));\n+                    arg.cast_to(ccx, Reg {\n+                        kind: RegKind::Integer,\n+                        size\n+                    });\n                 }\n             };\n             // Fat pointers are returned by-value.\n@@ -599,14 +883,7 @@ impl FnType {\n                 cabi_x86_64::compute_abi_info(ccx, self);\n             },\n             \"aarch64\" => cabi_aarch64::compute_abi_info(ccx, self),\n-            \"arm\" => {\n-                let flavor = if ccx.sess().target.target.target_os == \"ios\" {\n-                    cabi_arm::Flavor::Ios\n-                } else {\n-                    cabi_arm::Flavor::General\n-                };\n-                cabi_arm::compute_abi_info(ccx, self, flavor);\n-            },\n+            \"arm\" => cabi_arm::compute_abi_info(ccx, self),\n             \"mips\" => cabi_mips::compute_abi_info(ccx, self),\n             \"mips64\" => cabi_mips64::compute_abi_info(ccx, self),\n             \"powerpc\" => cabi_powerpc::compute_abi_info(ccx, self),\n@@ -627,16 +904,18 @@ impl FnType {\n         }\n     }\n \n-    pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+    pub fn llvm_type(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n         let mut llargument_tys = Vec::new();\n \n         let llreturn_ty = if self.ret.is_ignore() {\n             Type::void(ccx)\n         } else if self.ret.is_indirect() {\n-            llargument_tys.push(self.ret.original_ty.ptr_to());\n+            llargument_tys.push(self.ret.memory_ty(ccx).ptr_to());\n             Type::void(ccx)\n         } else {\n-            self.ret.cast.unwrap_or(self.ret.original_ty)\n+            self.ret.cast.unwrap_or_else(|| {\n+                type_of::immediate_type_of(ccx, self.ret.layout.ty)\n+            })\n         };\n \n         for arg in &self.args {\n@@ -649,9 +928,11 @@ impl FnType {\n             }\n \n             let llarg_ty = if arg.is_indirect() {\n-                arg.original_ty.ptr_to()\n+                arg.memory_ty(ccx).ptr_to()\n             } else {\n-                arg.cast.unwrap_or(arg.original_ty)\n+                arg.cast.unwrap_or_else(|| {\n+                    type_of::immediate_type_of(ccx, arg.layout.ty)\n+                })\n             };\n \n             llargument_tys.push(llarg_ty);\n@@ -699,72 +980,6 @@ impl FnType {\n     }\n }\n \n-pub fn align_up_to(off: usize, a: usize) -> usize {\n-    return (off + a - 1) / a * a;\n-}\n-\n-fn align(off: usize, ty: Type, pointer: usize) -> usize {\n-    let a = ty_align(ty, pointer);\n-    return align_up_to(off, a);\n-}\n-\n-pub fn ty_align(ty: Type, pointer: usize) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => pointer,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                1\n-            } else {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(1, |a, t| cmp::max(a, ty_align(*t, pointer)))\n-            }\n-        }\n-        Array => {\n-            let elt = ty.element_type();\n-            ty_align(elt, pointer)\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            ty_align(elt, pointer) * len\n-        }\n-        _ => bug!(\"ty_align: unhandled type\")\n-    }\n-}\n-\n-pub fn ty_size(ty: Type, pointer: usize) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => pointer,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(0, |s, t| s + ty_size(*t, pointer))\n-            } else {\n-                let str_tys = ty.field_types();\n-                let size = str_tys.iter().fold(0, |s, t| {\n-                    align(s, *t, pointer) + ty_size(*t, pointer)\n-                });\n-                align(size, ty, pointer)\n-            }\n-        }\n-        Array => {\n-            let len = ty.array_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt, pointer);\n-            len * eltsz\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt, pointer);\n-            len * eltsz\n-        },\n-        _ => bug!(\"ty_size: unhandled type\")\n-    }\n+pub fn align_up_to(off: u64, a: u64) -> u64 {\n+    (off + a - 1) / a * a\n }"}, {"sha": "0fe180253b5b89c14fad0a77d6d752dd10882567", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -95,15 +95,6 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     generic_type_of(cx, t, None, false, false)\n }\n \n-\n-// Pass dst=true if the type you are passing is a DST. Yes, we could figure\n-// this out, but if you call this on an unsized type without realising it, you\n-// are going to get the wrong type (it will not include the unsized parts of it).\n-pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                t: Ty<'tcx>, dst: bool) -> Type {\n-    generic_type_of(cx, t, None, true, dst)\n-}\n-\n pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     t: Ty<'tcx>, name: &str) -> Type {\n     generic_type_of(cx, t, Some(name), false, false)\n@@ -149,7 +140,11 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             };\n             let nnty = monomorphize::field_ty(cx.tcx(), substs,\n                 &def.variants[nndiscr as usize].fields[0]);\n-            type_of::sizing_type_of(cx, nnty)\n+            if let layout::Scalar { value: layout::Pointer, .. } = *cx.layout_of(nnty) {\n+                Type::i8p(cx)\n+            } else {\n+                type_of::type_of(cx, nnty)\n+            }\n         }\n         layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n             let fields = compute_fields(cx, t, nndiscr as usize, false);\n@@ -181,10 +176,6 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        layout::Vector { element, count } => {\n-            let elem_ty = Type::from_primitive(cx, element);\n-            Type::vector(&elem_ty, count)\n-        }\n         layout::UntaggedUnion { ref variants, .. }=> {\n             // Use alignment-sized ints to fill all the union storage.\n             let size = variants.stride().bytes();\n@@ -258,11 +249,10 @@ fn union_fill(cx: &CrateContext, size: u64, align: u64) -> Type {\n \n fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fields: &Vec<Ty<'tcx>>,\n                              variant: &layout::Struct,\n-                             sizing: bool, dst: bool) -> Vec<Type> {\n+                             sizing: bool, _dst: bool) -> Vec<Type> {\n     let fields = variant.field_index_by_increasing_offset().map(|i| fields[i as usize]);\n     if sizing {\n-        fields.filter(|ty| !dst || cx.shared().type_is_sized(*ty))\n-            .map(|ty| type_of::sizing_type_of(cx, ty)).collect()\n+        bug!()\n     } else {\n         fields.map(|ty| type_of::in_memory_type_of(cx, ty)).collect()\n     }"}, {"sha": "c8c5af714d92a92c2e945ef9d73c181393a8fc28", "filename": "src/librustc_trans/cabi_aarch64.rs", "status": "modified", "additions": 57, "deletions": 121, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_aarch64.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -8,163 +8,99 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_upper_case_globals)]\n-\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use abi::{self, FnType, ArgType};\n+use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n use context::CrateContext;\n-use type_::Type;\n-\n-fn ty_size(ty: Type) -> usize {\n-    abi::ty_size(ty, 8)\n-}\n-\n-fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n-    fn check_array(ty: Type) -> Option<(Type, u64)> {\n-        let len = ty.array_length() as u64;\n-        if len == 0 {\n-            return None\n-        }\n-        let elt = ty.element_type();\n-\n-        // if our element is an HFA/HVA, so are we; multiply members by our len\n-        is_homogenous_aggregate_ty(elt).map(|(base_ty, members)| (base_ty, len * members))\n-    }\n-\n-    fn check_struct(ty: Type) -> Option<(Type, u64)> {\n-        let str_tys = ty.field_types();\n-        if str_tys.len() == 0 {\n-            return None\n-        }\n-\n-        let mut prev_base_ty = None;\n-        let mut members = 0;\n-        for opt_homog_agg in str_tys.iter().map(|t| is_homogenous_aggregate_ty(*t)) {\n-            match (prev_base_ty, opt_homog_agg) {\n-                // field isn't itself an HFA, so we aren't either\n-                (_, None) => return None,\n-\n-                // first field - store its type and number of members\n-                (None, Some((field_ty, field_members))) => {\n-                    prev_base_ty = Some(field_ty);\n-                    members = field_members;\n-                },\n \n-                // 2nd or later field - give up if it's a different type; otherwise incr. members\n-                (Some(prev_ty), Some((field_ty, field_members))) => {\n-                    if prev_ty != field_ty {\n-                        return None;\n-                    }\n-                    members += field_members;\n-                }\n-            }\n-        }\n-\n-        // Because of previous checks, we know prev_base_ty is Some(...) because\n-        //   1. str_tys has at least one element; and\n-        //   2. prev_base_ty was filled in (or we would've returned early)\n-        let (base_ty, members) = (prev_base_ty.unwrap(), members);\n+fn is_homogenous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+                                     -> Option<Uniform> {\n+    arg.layout.homogenous_aggregate(ccx).and_then(|unit| {\n+        let size = arg.layout.size(ccx);\n \n-        // Ensure there is no padding.\n-        if ty_size(ty) == ty_size(base_ty) * (members as usize) {\n-            Some((base_ty, members))\n-        } else {\n-            None\n+        // Ensure we have at most four uniquely addressable members.\n+        if size > unit.size.checked_mul(4, ccx).unwrap() {\n+            return None;\n         }\n-    }\n \n-    let homog_agg = match ty.kind() {\n-        Float  => Some((ty, 1)),\n-        Double => Some((ty, 1)),\n-        Array  => check_array(ty),\n-        Struct => check_struct(ty),\n-        Vector => match ty_size(ty) {\n-            4|8 => Some((ty, 1)),\n-            _   => None\n-        },\n-        _ => None\n-    };\n+        let valid_unit = match unit.kind {\n+            RegKind::Integer => false,\n+            RegKind::Float => true,\n+            RegKind::Vector => size.bits() == 64 || size.bits() == 128\n+        };\n \n-    // Ensure we have at most four uniquely addressable members\n-    homog_agg.and_then(|(base_ty, members)| {\n-        if members > 0 && members <= 4 {\n-            Some((base_ty, members))\n+        if valid_unit {\n+            Some(Uniform {\n+                unit,\n+                total: size\n+            })\n         } else {\n             None\n         }\n     })\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n         return;\n     }\n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ret.ty) {\n-        ret.cast = Some(Type::array(&base_ty, members));\n+    if let Some(uniform) = is_homogenous_aggregate(ccx, ret) {\n+        ret.cast_to(ccx, uniform);\n         return;\n     }\n-    let size = ty_size(ret.ty);\n-    if size <= 16 {\n-        let llty = if size <= 1 {\n-            Type::i8(ccx)\n-        } else if size <= 2 {\n-            Type::i16(ccx)\n-        } else if size <= 4 {\n-            Type::i32(ccx)\n-        } else if size <= 8 {\n-            Type::i64(ccx)\n+    let size = ret.layout.size(ccx);\n+    let bits = size.bits();\n+    if bits <= 128 {\n+        let unit = if bits <= 8 {\n+            Reg::i8()\n+        } else if bits <= 16 {\n+            Reg::i16()\n+        } else if bits <= 32 {\n+            Reg::i32()\n         } else {\n-            Type::array(&Type::i64(ccx), ((size + 7 ) / 8 ) as u64)\n+            Reg::i64()\n         };\n-        ret.cast = Some(llty);\n+\n+        ret.cast_to(ccx, Uniform {\n+            unit,\n+            total: size\n+        });\n         return;\n     }\n     ret.make_indirect(ccx);\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n-    if is_reg_ty(arg.ty) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n         return;\n     }\n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(arg.ty) {\n-        arg.cast = Some(Type::array(&base_ty, members));\n+    if let Some(uniform) = is_homogenous_aggregate(ccx, arg) {\n+        arg.cast_to(ccx, uniform);\n         return;\n     }\n-    let size = ty_size(arg.ty);\n-    if size <= 16 {\n-        let llty = if size == 0 {\n-            Type::array(&Type::i64(ccx), 0)\n-        } else if size == 1 {\n-            Type::i8(ccx)\n-        } else if size == 2 {\n-            Type::i16(ccx)\n-        } else if size <= 4 {\n-            Type::i32(ccx)\n-        } else if size <= 8 {\n-            Type::i64(ccx)\n+    let size = arg.layout.size(ccx);\n+    let bits = size.bits();\n+    if bits <= 128 {\n+        let unit = if bits <= 8 {\n+            Reg::i8()\n+        } else if bits <= 16 {\n+            Reg::i16()\n+        } else if bits <= 32 {\n+            Reg::i32()\n         } else {\n-            Type::array(&Type::i64(ccx), ((size + 7 ) / 8 ) as u64)\n+            Reg::i64()\n         };\n-        arg.cast = Some(llty);\n+\n+        arg.cast_to(ccx, Uniform {\n+            unit,\n+            total: size\n+        });\n         return;\n     }\n     arg.make_indirect(ccx);\n }\n \n-fn is_reg_ty(ty: Type) -> bool {\n-    match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double\n-        | Vector => true,\n-        _ => false\n-    }\n-}\n-\n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "7a91cad511d6d17bc7688a17c30f25787da2a7a3", "filename": "src/librustc_trans/cabi_arm.rs", "status": "modified", "additions": 26, "deletions": 129, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_arm.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -8,156 +8,53 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use abi::{self, align_up_to, FnType, ArgType};\n+use abi::{FnType, ArgType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n-use type_::Type;\n \n-use std::cmp;\n-\n-pub enum Flavor {\n-    General,\n-    Ios\n-}\n-\n-type TyAlignFn = fn(ty: Type) -> usize;\n-\n-fn align(off: usize, ty: Type, align_fn: TyAlignFn) -> usize {\n-    let a = align_fn(ty);\n-    return align_up_to(off, a);\n-}\n-\n-fn general_ty_align(ty: Type) -> usize {\n-    abi::ty_align(ty, 4)\n-}\n-\n-// For more information see:\n-// ARMv7\n-// https://developer.apple.com/library/ios/documentation/Xcode/Conceptual\n-//    /iPhoneOSABIReference/Articles/ARMv7FunctionCallingConventions.html\n-// ARMv6\n-// https://developer.apple.com/library/ios/documentation/Xcode/Conceptual\n-//    /iPhoneOSABIReference/Articles/ARMv6FunctionCallingConventions.html\n-fn ios_ty_align(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => cmp::min(4, ((ty.int_width() as usize) + 7) / 8),\n-        Pointer => 4,\n-        Float => 4,\n-        Double => 4,\n-        Struct => {\n-            if ty.is_packed() {\n-                1\n-            } else {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(1, |a, t| cmp::max(a, ios_ty_align(*t)))\n-            }\n-        }\n-        Array => {\n-            let elt = ty.element_type();\n-            ios_ty_align(elt)\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            ios_ty_align(elt) * len\n-        }\n-        _ => bug!(\"ty_align: unhandled type\")\n-    }\n-}\n-\n-fn ty_size(ty: Type, align_fn: TyAlignFn) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 4,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(0, |s, t| s + ty_size(*t, align_fn))\n-            } else {\n-                let str_tys = ty.field_types();\n-                let size = str_tys.iter()\n-                                  .fold(0, |s, t| {\n-                                      align(s, *t, align_fn) + ty_size(*t, align_fn)\n-                                  });\n-                align(size, ty, align_fn)\n-            }\n-        }\n-        Array => {\n-            let len = ty.array_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt, align_fn);\n-            len * eltsz\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt, align_fn);\n-            len * eltsz\n-        }\n-        _ => bug!(\"ty_size: unhandled type\")\n-    }\n-}\n-\n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType, align_fn: TyAlignFn) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n         return;\n     }\n-    let size = ty_size(ret.ty, align_fn);\n-    if size <= 4 {\n-        let llty = if size <= 1 {\n-            Type::i8(ccx)\n-        } else if size <= 2 {\n-            Type::i16(ccx)\n+    let size = ret.layout.size(ccx);\n+    let bits = size.bits();\n+    if bits <= 32 {\n+        let unit = if bits <= 8 {\n+            Reg::i8()\n+        } else if bits <= 16 {\n+            Reg::i16()\n         } else {\n-            Type::i32(ccx)\n+            Reg::i32()\n         };\n-        ret.cast = Some(llty);\n+        ret.cast_to(ccx, Uniform {\n+            unit,\n+            total: size\n+        });\n         return;\n     }\n     ret.make_indirect(ccx);\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, align_fn: TyAlignFn) {\n-    if is_reg_ty(arg.ty) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n         return;\n     }\n-    let align = align_fn(arg.ty);\n-    let size = ty_size(arg.ty, align_fn);\n-    let llty = if align <= 4 {\n-        Type::array(&Type::i32(ccx), ((size + 3) / 4) as u64)\n-    } else {\n-        Type::array(&Type::i64(ccx), ((size + 7) / 8) as u64)\n-    };\n-    arg.cast = Some(llty);\n+    let align = arg.layout.align(ccx).abi();\n+    let total = arg.layout.size(ccx);\n+    arg.cast_to(ccx, Uniform {\n+        unit: if align <= 4 { Reg::i32() } else { Reg::i64() },\n+        total\n+    });\n }\n \n-fn is_reg_ty(ty: Type) -> bool {\n-    match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double\n-        | Vector => true,\n-        _ => false\n-    }\n-}\n-\n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n-    let align_fn = match flavor {\n-        Flavor::General => general_ty_align as TyAlignFn,\n-        Flavor::Ios => ios_ty_align as TyAlignFn,\n-    };\n-\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret, align_fn);\n+        classify_ret_ty(ccx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg, align_fn);\n+        classify_arg_ty(ccx, arg);\n     }\n }"}, {"sha": "f05dda8bce21acf819212c5cb224df06bbad50e8", "filename": "src/librustc_trans/cabi_asmjs.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_asmjs.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -8,42 +8,39 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_upper_case_globals)]\n-\n-use llvm::{Struct, Array};\n-use abi::{FnType, ArgType, ArgAttribute};\n+use abi::{FnType, ArgType, ArgAttribute, LayoutExt, Uniform};\n use context::CrateContext;\n \n // Data layout: e-p:32:32-i64:64-v128:32:128-n32-S128\n \n // See the https://github.com/kripken/emscripten-fastcomp-clang repository.\n // The class `EmscriptenABIInfo` in `/lib/CodeGen/TargetInfo.cpp` contains the ABI definitions.\n \n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    match ret.ty.kind() {\n-        Struct => {\n-            let field_types = ret.ty.field_types();\n-            if field_types.len() == 1 {\n-                ret.cast = Some(field_types[0]);\n-            } else {\n-                ret.make_indirect(ccx);\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if ret.layout.is_aggregate() {\n+        if let Some(unit) = ret.layout.homogenous_aggregate(ccx) {\n+            let size = ret.layout.size(ccx);\n+            if unit.size == size {\n+                ret.cast_to(ccx, Uniform {\n+                    unit,\n+                    total: size\n+                });\n+                return;\n             }\n         }\n-        Array => {\n-            ret.make_indirect(ccx);\n-        }\n-        _ => {}\n+\n+        ret.make_indirect(ccx);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n-    if arg.ty.is_aggregate() {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if arg.layout.is_aggregate() {\n         arg.make_indirect(ccx);\n         arg.attrs.set(ArgAttribute::ByVal);\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "b7b60859d4a048b9f53e0952659bcc7c133948ee", "filename": "src/librustc_trans/cabi_mips.rs", "status": "modified", "additions": 17, "deletions": 71, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -8,94 +8,40 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_upper_case_globals)]\n-\n-use libc::c_uint;\n use std::cmp;\n-use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Vector};\n-use abi::{self, align_up_to, ArgType, FnType};\n+use abi::{align_up_to, ArgType, FnType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n-use type_::Type;\n-\n-fn ty_align(ty: Type) -> usize {\n-    abi::ty_align(ty, 4)\n-}\n \n-fn ty_size(ty: Type) -> usize {\n-    abi::ty_size(ty, 4)\n-}\n-\n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect(ccx);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n-    let orig_offset = *offset;\n-    let size = ty_size(arg.ty) * 8;\n-    let mut align = ty_align(arg.ty);\n-\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut u64) {\n+    let size = arg.layout.size(ccx);\n+    let mut align = arg.layout.align(ccx).abi();\n     align = cmp::min(cmp::max(align, 4), 8);\n-    *offset = align_up_to(*offset, align);\n-    *offset += align_up_to(size, align * 8) / 8;\n \n-    if !is_reg_ty(arg.ty) {\n-        arg.cast = Some(struct_ty(ccx, arg.ty));\n-        arg.pad = padding_ty(ccx, align, orig_offset);\n+    if arg.layout.is_aggregate() {\n+        arg.cast_to(ccx, Uniform {\n+            unit: Reg::i32(),\n+            total: size\n+        });\n+        if ((align - 1) & *offset) > 0 {\n+            arg.pad_with(ccx, Reg::i32());\n+        }\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n-}\n-\n-fn is_reg_ty(ty: Type) -> bool {\n-    return match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double\n-        | Vector => true,\n-        _ => false\n-    };\n-}\n-\n-fn padding_ty(ccx: &CrateContext, align: usize, offset: usize) -> Option<Type> {\n-    if ((align - 1 ) & offset) > 0 {\n-        Some(Type::i32(ccx))\n-    } else {\n-        None\n-    }\n-}\n-\n-fn coerce_to_int(ccx: &CrateContext, size: usize) -> Vec<Type> {\n-    let int_ty = Type::i32(ccx);\n-    let mut args = Vec::new();\n-\n-    let mut n = size / 32;\n-    while n > 0 {\n-        args.push(int_ty);\n-        n -= 1;\n-    }\n \n-    let r = size % 32;\n-    if r > 0 {\n-        unsafe {\n-            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(ccx.llcx(), r as c_uint)));\n-        }\n-    }\n-\n-    args\n-}\n-\n-fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n-    let size = ty_size(ty) * 8;\n-    Type::struct_(ccx, &coerce_to_int(ccx, size), false)\n+    *offset = align_up_to(*offset, align);\n+    *offset += align_up_to(size.bytes(), align);\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "dff75e628de10270fa83b09c4c6da22281ea21d5", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "modified", "additions": 17, "deletions": 71, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -8,94 +8,40 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_upper_case_globals)]\n-\n-use libc::c_uint;\n use std::cmp;\n-use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Vector};\n-use abi::{self, align_up_to, ArgType, FnType};\n+use abi::{align_up_to, ArgType, FnType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n-use type_::Type;\n-\n-fn ty_align(ty: Type) -> usize {\n-    abi::ty_align(ty, 8)\n-}\n \n-fn ty_size(ty: Type) -> usize {\n-    abi::ty_size(ty, 8)\n-}\n-\n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n     } else {\n         ret.make_indirect(ccx);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n-    let orig_offset = *offset;\n-    let size = ty_size(arg.ty) * 8;\n-    let mut align = ty_align(arg.ty);\n-\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut u64) {\n+    let size = arg.layout.size(ccx);\n+    let mut align = arg.layout.align(ccx).abi();\n     align = cmp::min(cmp::max(align, 4), 8);\n-    *offset = align_up_to(*offset, align);\n-    *offset += align_up_to(size, align * 8) / 8;\n \n-    if !is_reg_ty(arg.ty) {\n-        arg.cast = Some(struct_ty(ccx, arg.ty));\n-        arg.pad = padding_ty(ccx, align, orig_offset);\n+    if arg.layout.is_aggregate() {\n+        arg.cast_to(ccx, Uniform {\n+            unit: Reg::i64(),\n+            total: size\n+        });\n+        if ((align - 1) & *offset) > 0 {\n+            arg.pad_with(ccx, Reg::i64());\n+        }\n     } else {\n         arg.extend_integer_width_to(64);\n     }\n-}\n-\n-fn is_reg_ty(ty: Type) -> bool {\n-    return match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double\n-        | Vector => true,\n-        _ => false\n-    };\n-}\n-\n-fn padding_ty(ccx: &CrateContext, align: usize, offset: usize) -> Option<Type> {\n-    if ((align - 1 ) & offset) > 0 {\n-        Some(Type::i64(ccx))\n-    } else {\n-        None\n-    }\n-}\n-\n-fn coerce_to_int(ccx: &CrateContext, size: usize) -> Vec<Type> {\n-    let int_ty = Type::i64(ccx);\n-    let mut args = Vec::new();\n-\n-    let mut n = size / 64;\n-    while n > 0 {\n-        args.push(int_ty);\n-        n -= 1;\n-    }\n \n-    let r = size % 64;\n-    if r > 0 {\n-        unsafe {\n-            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(ccx.llcx(), r as c_uint)));\n-        }\n-    }\n-\n-    args\n-}\n-\n-fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n-    let size = ty_size(ty) * 8;\n-    Type::struct_(ccx, &coerce_to_int(ccx, size), false)\n+    *offset = align_up_to(*offset, align);\n+    *offset += align_up_to(size.bytes(), align);\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "546bb5ad9b44ef39b140c81dea2d817d8b186aeb", "filename": "src/librustc_trans/cabi_msp430.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_msp430.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_msp430.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_msp430.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -11,41 +11,32 @@\n // Reference: MSP430 Embedded Application Binary Interface\n // http://www.ti.com/lit/an/slaa534/slaa534.pdf\n \n-#![allow(non_upper_case_globals)]\n-\n-use llvm::Struct;\n-\n-use abi::{self, ArgType, FnType};\n+use abi::{ArgType, FnType, LayoutExt};\n use context::CrateContext;\n-use type_::Type;\n-\n-fn ty_size(ty: Type) -> usize {\n-    abi::ty_size(ty, 2)\n-}\n \n // 3.5 Structures or Unions Passed and Returned by Reference\n //\n // \"Structures (including classes) and unions larger than 32 bits are passed and\n // returned by reference. To pass a structure or union by reference, the caller\n // places its address in the appropriate location: either in a register or on\n // the stack, according to its position in the argument list. (..)\"\n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if ret.ty.kind() == Struct && ty_size(ret.ty) > 32 {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if ret.layout.is_aggregate() && ret.layout.size(ccx).bits() > 32 {\n         ret.make_indirect(ccx);\n     } else {\n         ret.extend_integer_width_to(16);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n-    if arg.ty.kind() == Struct && ty_size(arg.ty) > 32 {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if arg.layout.is_aggregate() && arg.layout.size(ccx).bits() > 32 {\n         arg.make_indirect(ccx);\n     } else {\n         arg.extend_integer_width_to(16);\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "3873752b25470638b2456a276a4b784499a6713e", "filename": "src/librustc_trans/cabi_nvptx.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_nvptx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_nvptx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_nvptx.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -11,35 +11,26 @@\n // Reference: PTX Writer's Guide to Interoperability\n // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n \n-#![allow(non_upper_case_globals)]\n-\n-use llvm::Struct;\n-\n-use abi::{self, ArgType, FnType};\n+use abi::{ArgType, FnType, LayoutExt};\n use context::CrateContext;\n-use type_::Type;\n-\n-fn ty_size(ty: Type) -> usize {\n-    abi::ty_size(ty, 4)\n-}\n \n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if ret.ty.kind() == Struct && ty_size(ret.ty) > 32 {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if ret.layout.is_aggregate() && ret.layout.size(ccx).bits() > 32 {\n         ret.make_indirect(ccx);\n     } else {\n         ret.extend_integer_width_to(32);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n-    if arg.ty.kind() == Struct && ty_size(arg.ty) > 32 {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if arg.layout.is_aggregate() && arg.layout.size(ccx).bits() > 32 {\n         arg.make_indirect(ccx);\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "24bf4920c16c1277dd50435442a0ffbd9cef9e3a", "filename": "src/librustc_trans/cabi_nvptx64.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_nvptx64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_nvptx64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_nvptx64.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -11,35 +11,26 @@\n // Reference: PTX Writer's Guide to Interoperability\n // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n \n-#![allow(non_upper_case_globals)]\n-\n-use llvm::Struct;\n-\n-use abi::{self, ArgType, FnType};\n+use abi::{ArgType, FnType, LayoutExt};\n use context::CrateContext;\n-use type_::Type;\n-\n-fn ty_size(ty: Type) -> usize {\n-    abi::ty_size(ty, 8)\n-}\n \n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if ret.ty.kind() == Struct && ty_size(ret.ty) > 64 {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if ret.layout.is_aggregate() && ret.layout.size(ccx).bits() > 64 {\n         ret.make_indirect(ccx);\n     } else {\n         ret.extend_integer_width_to(64);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n-    if arg.ty.kind() == Struct && ty_size(arg.ty) > 64 {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if arg.layout.is_aggregate() && arg.layout.size(ccx).bits() > 64 {\n         arg.make_indirect(ccx);\n     } else {\n         arg.extend_integer_width_to(64);\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "f951ac76391f6614b0936f013bbf12a3bd9d87e8", "filename": "src/librustc_trans/cabi_powerpc.rs", "status": "modified", "additions": 17, "deletions": 76, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -8,100 +8,41 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use libc::c_uint;\n-use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Vector};\n-use abi::{self, align_up_to, FnType, ArgType};\n+use abi::{align_up_to, FnType, ArgType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n-use type_::Type;\n \n use std::cmp;\n \n-fn ty_align(ty: Type) -> usize {\n-    if ty.kind() == Vector {\n-        bug!(\"ty_size: unhandled type\")\n-    } else {\n-        abi::ty_align(ty, 4)\n-    }\n-}\n-\n-fn ty_size(ty: Type) -> usize {\n-    if ty.kind() == Vector {\n-        bug!(\"ty_size: unhandled type\")\n-    } else {\n-        abi::ty_size(ty, 4)\n-    }\n-}\n-\n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect(ccx);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n-    let orig_offset = *offset;\n-    let size = ty_size(arg.ty) * 8;\n-    let mut align = ty_align(arg.ty);\n-\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut u64) {\n+    let size = arg.layout.size(ccx);\n+    let mut align = arg.layout.align(ccx).abi();\n     align = cmp::min(cmp::max(align, 4), 8);\n-    *offset = align_up_to(*offset, align);\n-    *offset += align_up_to(size, align * 8) / 8;\n \n-    if !is_reg_ty(arg.ty) {\n-        arg.cast = Some(struct_ty(ccx, arg.ty));\n-        arg.pad = padding_ty(ccx, align, orig_offset);\n+    if arg.layout.is_aggregate() {\n+        arg.cast_to(ccx, Uniform {\n+            unit: Reg::i32(),\n+            total: size\n+        });\n+        if ((align - 1) & *offset) > 0 {\n+            arg.pad_with(ccx, Reg::i32());\n+        }\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n-}\n-\n-fn is_reg_ty(ty: Type) -> bool {\n-    return match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double => true,\n-        _ => false\n-    };\n-}\n \n-fn padding_ty(ccx: &CrateContext, align: usize, offset: usize) -> Option<Type> {\n-    if ((align - 1 ) & offset) > 0 {\n-        Some(Type::i32(ccx))\n-    } else {\n-        None\n-    }\n-}\n-\n-fn coerce_to_int(ccx: &CrateContext, size: usize) -> Vec<Type> {\n-    let int_ty = Type::i32(ccx);\n-    let mut args = Vec::new();\n-\n-    let mut n = size / 32;\n-    while n > 0 {\n-        args.push(int_ty);\n-        n -= 1;\n-    }\n-\n-    let r = size % 32;\n-    if r > 0 {\n-        unsafe {\n-            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(ccx.llcx(), r as c_uint)));\n-        }\n-    }\n-\n-    args\n-}\n-\n-fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n-    let size = ty_size(ty) * 8;\n-    Type::struct_(ccx, &coerce_to_int(ccx, size), false)\n+    *offset = align_up_to(*offset, align);\n+    *offset += align_up_to(size.bytes(), align);\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "c4f8d0b4b963780f6192834ac9329608f4ab14bd", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 48, "deletions": 132, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -8,100 +8,42 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME: The PowerPC64 ABI needs to zero or sign extend function\n-// call parameters, but compute_abi_info() is passed LLVM types\n-// which have no sign information.\n-//\n+// FIXME:\n // Alignment of 128 bit types is not currently handled, this will\n // need to be fixed when PowerPC vector support is added.\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Vector, Array};\n-use abi::{self, FnType, ArgType};\n+use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n use context::CrateContext;\n-use type_::Type;\n-\n-fn ty_size(ty: Type) -> usize {\n-    if ty.kind() == Vector {\n-        bug!(\"ty_size: unhandled type\")\n-    } else {\n-        abi::ty_size(ty, 8)\n-    }\n-}\n-\n-fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n-    fn check_array(ty: Type) -> Option<(Type, u64)> {\n-        let len = ty.array_length() as u64;\n-        if len == 0 {\n-            return None\n-        }\n-        let elt = ty.element_type();\n-\n-        // if our element is an HFA/HVA, so are we; multiply members by our len\n-        is_homogenous_aggregate_ty(elt).map(|(base_ty, members)| (base_ty, len * members))\n-    }\n \n-    fn check_struct(ty: Type) -> Option<(Type, u64)> {\n-        let str_tys = ty.field_types();\n-        if str_tys.len() == 0 {\n-            return None\n-        }\n+fn is_homogenous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+                                     -> Option<Uniform> {\n+    arg.layout.homogenous_aggregate(ccx).and_then(|unit| {\n+        let size = arg.layout.size(ccx);\n \n-        let mut prev_base_ty = None;\n-        let mut members = 0;\n-        for opt_homog_agg in str_tys.iter().map(|t| is_homogenous_aggregate_ty(*t)) {\n-            match (prev_base_ty, opt_homog_agg) {\n-                // field isn't itself an HFA, so we aren't either\n-                (_, None) => return None,\n-\n-                // first field - store its type and number of members\n-                (None, Some((field_ty, field_members))) => {\n-                    prev_base_ty = Some(field_ty);\n-                    members = field_members;\n-                },\n-\n-                // 2nd or later field - give up if it's a different type; otherwise incr. members\n-                (Some(prev_ty), Some((field_ty, field_members))) => {\n-                    if prev_ty != field_ty {\n-                        return None;\n-                    }\n-                    members += field_members;\n-                }\n-            }\n+        // Ensure we have at most eight uniquely addressable members.\n+        if size > unit.size.checked_mul(8, ccx).unwrap() {\n+            return None;\n         }\n \n-        // Because of previous checks, we know prev_base_ty is Some(...) because\n-        //   1. str_tys has at least one element; and\n-        //   2. prev_base_ty was filled in (or we would've returned early)\n-        let (base_ty, members) = (prev_base_ty.unwrap(), members);\n-\n-        // Ensure there is no padding.\n-        if ty_size(ty) == ty_size(base_ty) * (members as usize) {\n-            Some((base_ty, members))\n-        } else {\n-            None\n-        }\n-    }\n+        let valid_unit = match unit.kind {\n+            RegKind::Integer => false,\n+            RegKind::Float => true,\n+            RegKind::Vector => size.bits() == 128\n+        };\n \n-    let homog_agg = match ty.kind() {\n-        Float  => Some((ty, 1)),\n-        Double => Some((ty, 1)),\n-        Array  => check_array(ty),\n-        Struct => check_struct(ty),\n-        _ => None\n-    };\n-\n-    // Ensure we have at most eight uniquely addressable members\n-    homog_agg.and_then(|(base_ty, members)| {\n-        if members > 0 && members <= 8 {\n-            Some((base_ty, members))\n+        if valid_unit {\n+            Some(Uniform {\n+                unit,\n+                total: size\n+            })\n         } else {\n             None\n         }\n     })\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n         return;\n     }\n@@ -111,78 +53,52 @@ fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n         ret.make_indirect(ccx);\n     }\n \n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ret.ty) {\n-        ret.cast = Some(Type::array(&base_ty, members));\n+    if let Some(uniform) = is_homogenous_aggregate(ccx, ret) {\n+        ret.cast_to(ccx, uniform);\n         return;\n     }\n-    let size = ty_size(ret.ty);\n-    if size <= 16 {\n-        let llty = if size <= 1 {\n-            Type::i8(ccx)\n-        } else if size <= 2 {\n-            Type::i16(ccx)\n-        } else if size <= 4 {\n-            Type::i32(ccx)\n-        } else if size <= 8 {\n-            Type::i64(ccx)\n+    let size = ret.layout.size(ccx);\n+    let bits = size.bits();\n+    if bits <= 128 {\n+        let unit = if bits <= 8 {\n+            Reg::i8()\n+        } else if bits <= 16 {\n+            Reg::i16()\n+        } else if bits <= 32 {\n+            Reg::i32()\n         } else {\n-            Type::array(&Type::i64(ccx), ((size + 7 ) / 8 ) as u64)\n+            Reg::i64()\n         };\n-        ret.cast = Some(llty);\n+\n+        ret.cast_to(ccx, Uniform {\n+            unit,\n+            total: size\n+        });\n         return;\n     }\n \n     ret.make_indirect(ccx);\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n-    if is_reg_ty(arg.ty) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n         return;\n     }\n \n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(arg.ty) {\n-        arg.cast = Some(Type::array(&base_ty, members));\n+    if let Some(uniform) = is_homogenous_aggregate(ccx, arg) {\n+        arg.cast_to(ccx, uniform);\n         return;\n     }\n \n-    arg.cast = Some(struct_ty(ccx, arg.ty));\n-}\n-\n-fn is_reg_ty(ty: Type) -> bool {\n-    match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double => true,\n-        _ => false\n-    }\n-}\n-\n-fn coerce_to_long(ccx: &CrateContext, size: usize) -> Vec<Type> {\n-    let long_ty = Type::i64(ccx);\n-    let mut args = Vec::new();\n-\n-    let mut n = size / 64;\n-    while n > 0 {\n-        args.push(long_ty);\n-        n -= 1;\n-    }\n-\n-    let r = size % 64;\n-    if r > 0 {\n-        args.push(Type::ix(ccx, r as u64));\n-    }\n-\n-    args\n-}\n-\n-fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n-    let size = ty_size(ty) * 8;\n-    Type::struct_(ccx, &coerce_to_long(ccx, size), false)\n+    let total = arg.layout.size(ccx);\n+    arg.cast_to(ccx, Uniform {\n+        unit: Reg::i64(),\n+        total\n+    });\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "fedebea3f4c998ea177607167a3a83b2748ff0cb", "filename": "src/librustc_trans/cabi_s390x.rs", "status": "modified", "additions": 35, "deletions": 105, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_s390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_s390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_s390x.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -11,130 +11,60 @@\n // FIXME: The assumes we're using the non-vector ABI, i.e. compiling\n // for a pre-z13 machine or using -mno-vx.\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use abi::{align_up_to, FnType, ArgType};\n+use abi::{FnType, ArgType, LayoutExt, Reg};\n use context::CrateContext;\n-use type_::Type;\n \n-use std::cmp;\n+use rustc::ty::layout::{self, Layout, TyLayout};\n \n-fn align(off: usize, ty: Type) -> usize {\n-    let a = ty_align(ty);\n-    return align_up_to(off, a);\n-}\n-\n-fn ty_align(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 8,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                1\n-            } else {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(1, |a, t| cmp::max(a, ty_align(*t)))\n-            }\n-        }\n-        Array => {\n-            let elt = ty.element_type();\n-            ty_align(elt)\n-        }\n-        Vector => ty_size(ty),\n-        _ => bug!(\"ty_align: unhandled type\")\n-    }\n-}\n-\n-fn ty_size(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 8,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n-            } else {\n-                let str_tys = ty.field_types();\n-                let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n-                align(size, ty)\n-            }\n-        }\n-        Array => {\n-            let len = ty.array_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt);\n-            len * eltsz\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt);\n-            len * eltsz\n-        }\n-        _ => bug!(\"ty_size: unhandled type\")\n-    }\n-}\n-\n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() && ret.layout.size(ccx).bits() <= 64 {\n         ret.extend_integer_width_to(64);\n     } else {\n         ret.make_indirect(ccx);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n-    if arg.ty.kind() == Struct {\n-        fn is_single_fp_element(tys: &[Type]) -> bool {\n-            if tys.len() != 1 {\n-                return false;\n-            }\n-            match tys[0].kind() {\n-                Float | Double => true,\n-                Struct => is_single_fp_element(&tys[0].field_types()),\n-                _ => false\n-            }\n-        }\n-\n-        if is_single_fp_element(&arg.ty.field_types()) {\n-            match ty_size(arg.ty) {\n-                4 => arg.cast = Some(Type::f32(ccx)),\n-                8 => arg.cast = Some(Type::f64(ccx)),\n-                _ => arg.make_indirect(ccx)\n-            }\n-        } else {\n-            match ty_size(arg.ty) {\n-                1 => arg.cast = Some(Type::i8(ccx)),\n-                2 => arg.cast = Some(Type::i16(ccx)),\n-                4 => arg.cast = Some(Type::i32(ccx)),\n-                8 => arg.cast = Some(Type::i64(ccx)),\n-                _ => arg.make_indirect(ccx)\n+fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                  layout: TyLayout<'tcx>) -> bool {\n+    match *layout {\n+        Layout::Scalar { value: layout::F32, .. } |\n+        Layout::Scalar { value: layout::F64, .. } => true,\n+        Layout::Univariant { .. } => {\n+            if layout.field_count() == 1 {\n+                is_single_fp_element(ccx, layout.field(ccx, 0))\n+            } else {\n+                false\n             }\n         }\n-        return;\n+        _ => false\n     }\n+}\n \n-    if is_reg_ty(arg.ty) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    let size = arg.layout.size(ccx);\n+    if !arg.layout.is_aggregate() && size.bits() <= 64 {\n         arg.extend_integer_width_to(64);\n-    } else {\n-        arg.make_indirect(ccx);\n+        return;\n     }\n-}\n \n-fn is_reg_ty(ty: Type) -> bool {\n-    match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double => ty_size(ty) <= 8,\n-        _ => false\n+    if is_single_fp_element(ccx, arg.layout) {\n+        match size.bytes() {\n+            4 => arg.cast_to(ccx, Reg::f32()),\n+            8 => arg.cast_to(ccx, Reg::f64()),\n+            _ => arg.make_indirect(ccx)\n+        }\n+    } else {\n+        match size.bytes() {\n+            1 => arg.cast_to(ccx, Reg::i8()),\n+            2 => arg.cast_to(ccx, Reg::i16()),\n+            4 => arg.cast_to(ccx, Reg::i32()),\n+            8 => arg.cast_to(ccx, Reg::i64()),\n+            _ => arg.make_indirect(ccx)\n+        }\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "c17901e1adebc113aace587a507e7cf3044cc122", "filename": "src/librustc_trans/cabi_sparc.rs", "status": "modified", "additions": 18, "deletions": 72, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_sparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_sparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -8,94 +8,40 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_upper_case_globals)]\n-\n-use libc::c_uint;\n use std::cmp;\n-use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Vector};\n-use abi::{self, align_up_to, ArgType, FnType};\n+use abi::{align_up_to, ArgType, FnType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n-use type_::Type;\n-\n-fn ty_align(ty: Type) -> usize {\n-    abi::ty_align(ty, 4)\n-}\n \n-fn ty_size(ty: Type) -> usize {\n-    abi::ty_size(ty, 4)\n-}\n-\n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect(ccx);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n-    let orig_offset = *offset;\n-    let size = ty_size(arg.ty) * 8;\n-    let mut align = ty_align(arg.ty);\n-\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut u64) {\n+    let size = arg.layout.size(ccx);\n+    let mut align = arg.layout.align(ccx).abi();\n     align = cmp::min(cmp::max(align, 4), 8);\n-    *offset = align_up_to(*offset, align);\n-    *offset += align_up_to(size, align * 8) / 8;\n-\n-    if !is_reg_ty(arg.ty) {\n-        arg.cast = Some(struct_ty(ccx, arg.ty));\n-        arg.pad = padding_ty(ccx, align, orig_offset);\n-    } else {\n-        arg.extend_integer_width_to(32);\n-    }\n-}\n-\n-fn is_reg_ty(ty: Type) -> bool {\n-    return match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double\n-        | Vector => true,\n-        _ => false\n-    };\n-}\n-\n-fn padding_ty(ccx: &CrateContext, align: usize, offset: usize) -> Option<Type> {\n-    if ((align - 1 ) & offset) > 0 {\n-        Some(Type::i32(ccx))\n-    } else {\n-        None\n-    }\n-}\n-\n-fn coerce_to_int(ccx: &CrateContext, size: usize) -> Vec<Type> {\n-    let int_ty = Type::i32(ccx);\n-    let mut args = Vec::new();\n \n-    let mut n = size / 32;\n-    while n > 0 {\n-        args.push(int_ty);\n-        n -= 1;\n-    }\n-\n-    let r = size % 32;\n-    if r > 0 {\n-        unsafe {\n-            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(ccx.llcx(), r as c_uint)));\n+    if arg.layout.is_aggregate() {\n+        arg.cast_to(ccx, Uniform {\n+            unit: Reg::i32(),\n+            total: size\n+        });\n+        if ((align - 1) & *offset) > 0 {\n+            arg.pad_with(ccx, Reg::i32());\n         }\n+    } else {\n+        arg.extend_integer_width_to(32)\n     }\n \n-    args\n-}\n-\n-fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n-    let size = ty_size(ty) * 8;\n-    Type::struct_(ccx, &coerce_to_int(ccx, size), false)\n+    *offset = align_up_to(*offset, align);\n+    *offset += align_up_to(size.bytes(), align);\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "b75fa97f948ecadfea7e2ee2c1af8f3faf825881", "filename": "src/librustc_trans/cabi_sparc64.rs", "status": "modified", "additions": 50, "deletions": 131, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc64.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -10,170 +10,89 @@\n \n // FIXME: This needs an audit for correctness and completeness.\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Vector, Array};\n-use abi::{self, FnType, ArgType};\n+use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n use context::CrateContext;\n-use type_::Type;\n \n-fn ty_size(ty: Type) -> usize {\n-    if ty.kind() == Vector {\n-        bug!(\"ty_size: unhandled type\")\n-    } else {\n-        abi::ty_size(ty, 8)\n-    }\n-}\n-\n-fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n-    fn check_array(ty: Type) -> Option<(Type, u64)> {\n-        let len = ty.array_length() as u64;\n-        if len == 0 {\n-            return None\n-        }\n-        let elt = ty.element_type();\n-\n-        // if our element is an HFA/HVA, so are we; multiply members by our len\n-        is_homogenous_aggregate_ty(elt).map(|(base_ty, members)| (base_ty, len * members))\n-    }\n-\n-    fn check_struct(ty: Type) -> Option<(Type, u64)> {\n-        let str_tys = ty.field_types();\n-        if str_tys.len() == 0 {\n-            return None\n-        }\n-\n-        let mut prev_base_ty = None;\n-        let mut members = 0;\n-        for opt_homog_agg in str_tys.iter().map(|t| is_homogenous_aggregate_ty(*t)) {\n-            match (prev_base_ty, opt_homog_agg) {\n-                // field isn't itself an HFA, so we aren't either\n-                (_, None) => return None,\n+fn is_homogenous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+                                     -> Option<Uniform> {\n+    arg.layout.homogenous_aggregate(ccx).and_then(|unit| {\n+        let size = arg.layout.size(ccx);\n \n-                // first field - store its type and number of members\n-                (None, Some((field_ty, field_members))) => {\n-                    prev_base_ty = Some(field_ty);\n-                    members = field_members;\n-                },\n-\n-                // 2nd or later field - give up if it's a different type; otherwise incr. members\n-                (Some(prev_ty), Some((field_ty, field_members))) => {\n-                    if prev_ty != field_ty {\n-                        return None;\n-                    }\n-                    members += field_members;\n-                }\n-            }\n+        // Ensure we have at most eight uniquely addressable members.\n+        if size > unit.size.checked_mul(8, ccx).unwrap() {\n+            return None;\n         }\n \n-        // Because of previous checks, we know prev_base_ty is Some(...) because\n-        //   1. str_tys has at least one element; and\n-        //   2. prev_base_ty was filled in (or we would've returned early)\n-        let (base_ty, members) = (prev_base_ty.unwrap(), members);\n-\n-        // Ensure there is no padding.\n-        if ty_size(ty) == ty_size(base_ty) * (members as usize) {\n-            Some((base_ty, members))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    let homog_agg = match ty.kind() {\n-        Float  => Some((ty, 1)),\n-        Double => Some((ty, 1)),\n-        Array  => check_array(ty),\n-        Struct => check_struct(ty),\n-        _ => None\n-    };\n+        let valid_unit = match unit.kind {\n+            RegKind::Integer => false,\n+            RegKind::Float => true,\n+            RegKind::Vector => size.bits() == 128\n+        };\n \n-    // Ensure we have at most eight uniquely addressable members\n-    homog_agg.and_then(|(base_ty, members)| {\n-        if members > 0 && members <= 8 {\n-            Some((base_ty, members))\n+        if valid_unit {\n+            Some(Uniform {\n+                unit,\n+                total: size\n+            })\n         } else {\n             None\n         }\n     })\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n         return;\n     }\n \n-    // don't return aggregates in registers\n-    ret.make_indirect(ccx);\n-\n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ret.ty) {\n-        ret.cast = Some(Type::array(&base_ty, members));\n+    if let Some(uniform) = is_homogenous_aggregate(ccx, ret) {\n+        ret.cast_to(ccx, uniform);\n         return;\n     }\n-    let size = ty_size(ret.ty);\n-    if size <= 16 {\n-        let llty = if size <= 1 {\n-            Type::i8(ccx)\n-        } else if size <= 2 {\n-            Type::i16(ccx)\n-        } else if size <= 4 {\n-            Type::i32(ccx)\n-        } else if size <= 8 {\n-            Type::i64(ccx)\n+    let size = ret.layout.size(ccx);\n+    let bits = size.bits();\n+    if bits <= 128 {\n+        let unit = if bits <= 8 {\n+            Reg::i8()\n+        } else if bits <= 16 {\n+            Reg::i16()\n+        } else if bits <= 32 {\n+            Reg::i32()\n         } else {\n-            Type::array(&Type::i64(ccx), ((size + 7 ) / 8 ) as u64)\n+            Reg::i64()\n         };\n-        ret.cast = Some(llty);\n+\n+        ret.cast_to(ccx, Uniform {\n+            unit,\n+            total: size\n+        });\n         return;\n     }\n+\n+    // don't return aggregates in registers\n+    ret.make_indirect(ccx);\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n-    if is_reg_ty(arg.ty) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n         return;\n     }\n \n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(arg.ty) {\n-        arg.cast = Some(Type::array(&base_ty, members));\n+    if let Some(uniform) = is_homogenous_aggregate(ccx, arg) {\n+        arg.cast_to(ccx, uniform);\n         return;\n     }\n \n-    arg.cast = Some(struct_ty(ccx, arg.ty));\n-}\n-\n-fn is_reg_ty(ty: Type) -> bool {\n-    match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double => true,\n-        _ => false\n-    }\n-}\n-\n-fn coerce_to_long(ccx: &CrateContext, size: usize) -> Vec<Type> {\n-    let long_ty = Type::i64(ccx);\n-    let mut args = Vec::new();\n-\n-    let mut n = size / 64;\n-    while n > 0 {\n-        args.push(long_ty);\n-        n -= 1;\n-    }\n-\n-    let r = size % 64;\n-    if r > 0 {\n-        args.push(Type::ix(ccx, r as u64));\n-    }\n-\n-    args\n-}\n-\n-fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n-    let size = ty_size(ty) * 8;\n-    Type::struct_(ccx, &coerce_to_long(ccx, size), false)\n+    let total = arg.layout.size(ccx);\n+    arg.cast_to(ccx, Uniform {\n+        unit: Reg::i64(),\n+        total\n+    });\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "9f5520dabe3349e14dbdffbfda4fdeac7998d187", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -8,21 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::*;\n-use abi::{ArgAttribute, FnType};\n-use type_::Type;\n-use super::common::*;\n-use super::machine::*;\n+use abi::{ArgAttribute, FnType, LayoutExt, Reg, RegKind};\n+use common::CrateContext;\n \n #[derive(PartialEq)]\n pub enum Flavor {\n     General,\n     Fastcall\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                  fty: &mut FnType<'tcx>,\n+                                  flavor: Flavor) {\n     if !fty.ret.is_ignore() {\n-        if fty.ret.ty.kind() == Struct {\n+        if fty.ret.layout.is_aggregate() {\n             // Returning a structure. Most often, this will use\n             // a hidden first argument. On some platforms, though,\n             // small structs are returned as integers.\n@@ -33,11 +32,12 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n             let t = &ccx.sess().target.target;\n             if t.options.is_like_osx || t.options.is_like_windows\n                 || t.options.is_like_openbsd {\n-                match llsize_of_alloc(ccx, fty.ret.ty) {\n-                    1 => fty.ret.cast = Some(Type::i8(ccx)),\n-                    2 => fty.ret.cast = Some(Type::i16(ccx)),\n-                    4 => fty.ret.cast = Some(Type::i32(ccx)),\n-                    8 => fty.ret.cast = Some(Type::i64(ccx)),\n+                let size = fty.ret.layout.size(ccx);\n+                match size.bytes() {\n+                    1 => fty.ret.cast_to(ccx, Reg::i8()),\n+                    2 => fty.ret.cast_to(ccx, Reg::i16()),\n+                    4 => fty.ret.cast_to(ccx, Reg::i32()),\n+                    8 => fty.ret.cast_to(ccx, Reg::i64()),\n                     _ => fty.ret.make_indirect(ccx)\n                 }\n             } else {\n@@ -50,7 +50,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        if arg.ty.kind() == Struct {\n+        if arg.layout.is_aggregate() {\n             arg.make_indirect(ccx);\n             arg.attrs.set(ArgAttribute::ByVal);\n         } else {\n@@ -73,12 +73,15 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n         for arg in &mut fty.args {\n             if arg.is_ignore() || arg.is_indirect() { continue; }\n \n-            if arg.ty.kind() == Float {\n+            // At this point we know this must be a primitive of sorts.\n+            let unit = arg.layout.homogenous_aggregate(ccx).unwrap();\n+            let size = arg.layout.size(ccx);\n+            assert_eq!(unit.size, size);\n+            if unit.kind == RegKind::Float {\n                 continue;\n             }\n \n-            let size = llbitsize_of_real(ccx, arg.ty);\n-            let size_in_regs = (size + 31) / 32;\n+            let size_in_regs = (size.bits() + 31) / 32;\n \n             if size_in_regs == 0 {\n                 continue;\n@@ -90,7 +93,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n \n             free_regs -= size_in_regs;\n \n-            if size <= 32 && (arg.ty.kind() == Pointer || arg.ty.kind() == Integer) {\n+            if size.bits() <= 32 && unit.kind == RegKind::Integer {\n                 arg.attrs.set(ArgAttribute::InReg);\n             }\n "}, {"sha": "cbe170d85834cfa527dc845f877153c5dd157c89", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 187, "deletions": 325, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -11,388 +11,250 @@\n // The classification code for the x86_64 ABI is taken from the clay language\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n-#![allow(non_upper_case_globals)]\n-use self::RegClass::*;\n-\n-use llvm::{Integer, Pointer, Float, Double};\n-use llvm::{Struct, Array, Vector};\n-use abi::{self, ArgType, ArgAttribute, FnType};\n+use abi::{ArgType, ArgAttribute, CastTarget, FnType, LayoutExt, Reg, RegKind};\n use context::CrateContext;\n-use type_::Type;\n-\n-#[derive(Clone, Copy, PartialEq)]\n-enum RegClass {\n-    NoClass,\n-    Int,\n-    SSEFs,\n-    SSEFv,\n-    SSEDs,\n-    SSEDv,\n-    SSEInt(/* bitwidth */ u64),\n-    /// Data that can appear in the upper half of an SSE register.\n-    SSEUp,\n-    X87,\n-    X87Up,\n-    ComplexX87,\n-    Memory\n-}\n-\n-trait TypeMethods {\n-    fn is_reg_ty(&self) -> bool;\n-}\n-\n-impl TypeMethods for Type {\n-    fn is_reg_ty(&self) -> bool {\n-        match self.kind() {\n-            Integer | Pointer | Float | Double => true,\n-            _ => false\n-        }\n-    }\n-}\n-\n-impl RegClass {\n-    fn is_sse(&self) -> bool {\n-        match *self {\n-            SSEFs | SSEFv | SSEDs | SSEDv | SSEInt(_) => true,\n-            _ => false\n-        }\n-    }\n-}\n-\n-trait ClassList {\n-    fn is_pass_byval(&self) -> bool;\n-    fn is_ret_bysret(&self) -> bool;\n-}\n-\n-impl ClassList for [RegClass] {\n-    fn is_pass_byval(&self) -> bool {\n-        if self.is_empty() { return false; }\n-\n-        let class = self[0];\n-           class == Memory\n-        || class == X87\n-        || class == ComplexX87\n-    }\n \n-    fn is_ret_bysret(&self) -> bool {\n-        if self.is_empty() { return false; }\n+use rustc::ty::layout::{self, Layout, TyLayout, Size};\n \n-        self[0] == Memory\n-    }\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+enum Class {\n+    None,\n+    Int,\n+    Sse,\n+    SseUp\n }\n \n-fn classify_ty(ty: Type) -> Vec<RegClass> {\n-    fn align(off: usize, ty: Type) -> usize {\n-        let a = ty_align(ty);\n-        return (off + a - 1) / a * a;\n-    }\n-\n-    fn ty_align(ty: Type) -> usize {\n-        abi::ty_align(ty, 8)\n-    }\n-\n-    fn ty_size(ty: Type) -> usize {\n-        abi::ty_size(ty, 8)\n-    }\n-\n-    fn all_mem(cls: &mut [RegClass]) {\n-        for elt in cls {\n-            *elt = Memory;\n-        }\n-    }\n-\n-    fn unify(cls: &mut [RegClass],\n-             i: usize,\n-             newv: RegClass) {\n-        if cls[i] == newv { return }\n+#[derive(Clone, Copy, Debug)]\n+struct Memory;\n \n-        let to_write = match (cls[i], newv) {\n-            (NoClass,     _) => newv,\n-            (_,           NoClass) => return,\n+// Currently supported vector size (AVX).\n+const LARGEST_VECTOR_SIZE: usize = 256;\n+const MAX_EIGHTBYTES: usize = LARGEST_VECTOR_SIZE / 64;\n \n-            (Memory,      _) |\n-            (_,           Memory) => Memory,\n+fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n+                          -> Result<[Class; MAX_EIGHTBYTES], Memory> {\n+    fn unify(cls: &mut [Class],\n+             off: u64,\n+             c: Class) {\n+        let i = (off / 8) as usize;\n+        let to_write = match (cls[i], c) {\n+            (Class::None, _) => c,\n+            (_, Class::None) => return,\n \n-            (Int,         _) |\n-            (_,           Int) => Int,\n+            (Class::Int, _) |\n+            (_, Class::Int) => Class::Int,\n \n-            (X87,         _) |\n-            (X87Up,       _) |\n-            (ComplexX87,  _) |\n-            (_,           X87) |\n-            (_,           X87Up) |\n-            (_,           ComplexX87) => Memory,\n+            (Class::Sse, _) |\n+            (_, Class::Sse) => Class::Sse,\n \n-            (SSEFv,       SSEUp) |\n-            (SSEFs,       SSEUp) |\n-            (SSEDv,       SSEUp) |\n-            (SSEDs,       SSEUp) |\n-            (SSEInt(_),   SSEUp) => return,\n-\n-            (..) => newv\n+            (Class::SseUp, Class::SseUp) => Class::SseUp\n         };\n         cls[i] = to_write;\n     }\n \n-    fn classify_struct(tys: &[Type],\n-                       cls: &mut [RegClass],\n-                       i: usize,\n-                       off: usize,\n-                       packed: bool) {\n-        let mut field_off = off;\n-        for ty in tys {\n-            if !packed {\n-                field_off = align(field_off, *ty);\n+    fn classify<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                          layout: TyLayout<'tcx>,\n+                          cls: &mut [Class],\n+                          off: u64)\n+                          -> Result<(), Memory> {\n+        if off % layout.align(ccx).abi() != 0 {\n+            if layout.size(ccx).bytes() > 0 {\n+                return Err(Memory);\n             }\n-            classify(*ty, cls, i, field_off);\n-            field_off += ty_size(*ty);\n+            return Ok(());\n         }\n-    }\n \n-    fn classify(ty: Type,\n-                cls: &mut [RegClass], ix: usize,\n-                off: usize) {\n-        let t_align = ty_align(ty);\n-        let t_size = ty_size(ty);\n-\n-        let misalign = off % t_align;\n-        if misalign != 0 {\n-            let mut i = off / 8;\n-            let e = (off + t_size + 7) / 8;\n-            while i < e {\n-                unify(cls, ix + i, Memory);\n-                i += 1;\n+        match *layout {\n+            Layout::Scalar { value, .. } |\n+            Layout::RawNullablePointer { value, .. } => {\n+                let reg = match value {\n+                    layout::Int(_) |\n+                    layout::Pointer => Class::Int,\n+                    layout::F32 |\n+                    layout::F64 => Class::Sse\n+                };\n+                unify(cls, off, reg);\n             }\n-            return;\n-        }\n \n-        match ty.kind() {\n-            Integer |\n-            Pointer => {\n-                unify(cls, ix + off / 8, Int);\n+            Layout::CEnum { .. } => {\n+                unify(cls, off, Class::Int);\n             }\n-            Float => {\n-                if off % 8 == 4 {\n-                    unify(cls, ix + off / 8, SSEFv);\n-                } else {\n-                    unify(cls, ix + off / 8, SSEFs);\n+\n+            Layout::Vector { element, count } => {\n+                unify(cls, off, Class::Sse);\n+\n+                // everything after the first one is the upper\n+                // half of a register.\n+                let eltsz = element.size(ccx).bytes();\n+                for i in 1..count {\n+                    unify(cls, off + i * eltsz, Class::SseUp);\n                 }\n             }\n-            Double => {\n-                unify(cls, ix + off / 8, SSEDs);\n-            }\n-            Struct => {\n-                classify_struct(&ty.field_types(), cls, ix, off, ty.is_packed());\n-            }\n-            Array => {\n-                let len = ty.array_length();\n-                let elt = ty.element_type();\n-                let eltsz = ty_size(elt);\n-                let mut i = 0;\n-                while i < len {\n-                    classify(elt, cls, ix, off + i * eltsz);\n-                    i += 1;\n+\n+            Layout::Array { count, .. } => {\n+                if count > 0 {\n+                    let elt = layout.field(ccx, 0);\n+                    let eltsz = elt.size(ccx).bytes();\n+                    for i in 0..count {\n+                        classify(ccx, elt, cls, off + i * eltsz)?;\n+                    }\n                 }\n             }\n-            Vector => {\n-                let len = ty.vector_length();\n-                let elt = ty.element_type();\n-                let eltsz = ty_size(elt);\n-                let mut reg = match elt.kind() {\n-                    Integer => SSEInt(elt.int_width()),\n-                    Float => SSEFv,\n-                    Double => SSEDv,\n-                    _ => bug!(\"classify: unhandled vector element type\")\n-                };\n \n-                let mut i = 0;\n-                while i < len {\n-                    unify(cls, ix + (off + i * eltsz) / 8, reg);\n+            Layout::Univariant { ref variant, .. } => {\n+                for i in 0..layout.field_count() {\n+                    let field_off = off + variant.offsets[i].bytes();\n+                    classify(ccx, layout.field(ccx, i), cls, field_off)?;\n+                }\n+            }\n \n-                    // everything after the first one is the upper\n-                    // half of a register.\n-                    reg = SSEUp;\n-                    i += 1;\n+            Layout::UntaggedUnion { .. } => {\n+                for i in 0..layout.field_count() {\n+                    classify(ccx, layout.field(ccx, i), cls, off)?;\n                 }\n             }\n-            _ => bug!(\"classify: unhandled type\")\n+\n+            Layout::FatPointer { .. } |\n+            Layout::General { .. } |\n+            Layout::StructWrappedNullablePointer { .. } => return Err(Memory)\n         }\n+\n+        Ok(())\n+    }\n+\n+    let n = ((arg.layout.size(ccx).bytes() + 7) / 8) as usize;\n+    if n > MAX_EIGHTBYTES {\n+        return Err(Memory);\n     }\n \n-    fn fixup(ty: Type, cls: &mut [RegClass]) {\n+    let mut cls = [Class::None; MAX_EIGHTBYTES];\n+    classify(ccx, arg.layout, &mut cls, 0)?;\n+    if n > 2 {\n+        if cls[0] != Class::Sse {\n+            return Err(Memory);\n+        }\n+        if cls[1..n].iter().any(|&c| c != Class::SseUp) {\n+            return Err(Memory);\n+        }\n+    } else {\n         let mut i = 0;\n-        let ty_kind = ty.kind();\n-        let e = cls.len();\n-        if cls.len() > 2 && (ty_kind == Struct || ty_kind == Array || ty_kind == Vector) {\n-            if cls[i].is_sse() {\n+        while i < n {\n+            if cls[i] == Class::SseUp {\n+                cls[i] = Class::Sse;\n+            } else if cls[i] == Class::Sse {\n                 i += 1;\n-                while i < e {\n-                    if cls[i] != SSEUp {\n-                        all_mem(cls);\n-                        return;\n-                    }\n-                    i += 1;\n-                }\n+                while i != n && cls[i] == Class::SseUp { i += 1; }\n             } else {\n-                all_mem(cls);\n-                return\n-            }\n-        } else {\n-            while i < e {\n-                if cls[i] == Memory {\n-                    all_mem(cls);\n-                    return;\n-                }\n-                if cls[i] == X87Up {\n-                    // for darwin\n-                    // cls[i] = SSEDs;\n-                    all_mem(cls);\n-                    return;\n-                }\n-                if cls[i] == SSEUp {\n-                    cls[i] = SSEDv;\n-                } else if cls[i].is_sse() {\n-                    i += 1;\n-                    while i != e && cls[i] == SSEUp { i += 1; }\n-                } else if cls[i] == X87 {\n-                    i += 1;\n-                    while i != e && cls[i] == X87Up { i += 1; }\n-                } else {\n-                    i += 1;\n-                }\n+                i += 1;\n             }\n         }\n     }\n \n-    let words = (ty_size(ty) + 7) / 8;\n-    let mut cls = vec![NoClass; words];\n-    if words > 4 {\n-        all_mem(&mut cls);\n-        return cls;\n-    }\n-    classify(ty, &mut cls, 0, 0);\n-    fixup(ty, &mut cls);\n-    return cls;\n+    Ok(cls)\n }\n \n-fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n-    fn llvec_len(cls: &[RegClass]) -> usize {\n-        let mut len = 1;\n-        for c in cls {\n-            if *c != SSEUp {\n-                break;\n-            }\n-            len += 1;\n-        }\n-        return len;\n+fn reg_component(cls: &[Class], i: &mut usize, size: u64) -> Option<Reg> {\n+    if *i >= cls.len() {\n+        return None;\n     }\n \n-    let mut tys = Vec::new();\n-    let mut i = 0;\n-    let e = cls.len();\n-    while i < e {\n-        match cls[i] {\n-            Int => {\n-                tys.push(Type::i64(ccx));\n-            }\n-            SSEFv | SSEDv | SSEInt(_) => {\n-                let (elts_per_word, elt_ty) = match cls[i] {\n-                    SSEFv => (2, Type::f32(ccx)),\n-                    SSEDv => (1, Type::f64(ccx)),\n-                    SSEInt(bits) => {\n-                        assert!(bits == 8 || bits == 16 || bits == 32 || bits == 64,\n-                                \"llreg_ty: unsupported SSEInt width {}\", bits);\n-                        (64 / bits, Type::ix(ccx, bits))\n+    match cls[*i] {\n+        Class::None => None,\n+        Class::Int => {\n+            *i += 1;\n+            Some(match size {\n+                1 => Reg::i8(),\n+                2 => Reg::i16(),\n+                3 |\n+                4 => Reg::i32(),\n+                _ => Reg::i64()\n+            })\n+        }\n+        Class::Sse => {\n+            let vec_len = 1 + cls[*i+1..].iter().take_while(|&&c| c == Class::SseUp).count();\n+            *i += vec_len;\n+            Some(match size {\n+                4 => Reg::f32(),\n+                8 => Reg::f64(),\n+                _ => {\n+                    Reg {\n+                        kind: RegKind::Vector,\n+                        size: Size::from_bytes(vec_len as u64 * 8)\n                     }\n-                    _ => bug!(),\n-                };\n-                let vec_len = llvec_len(&cls[i + 1..]);\n-                let vec_ty = Type::vector(&elt_ty, vec_len as u64 * elts_per_word);\n-                tys.push(vec_ty);\n-                i += vec_len;\n-                continue;\n-            }\n-            SSEFs => {\n-                tys.push(Type::f32(ccx));\n-            }\n-            SSEDs => {\n-                tys.push(Type::f64(ccx));\n-            }\n-            _ => bug!(\"llregtype: unhandled class\")\n+                }\n+            })\n         }\n-        i += 1;\n+        c => bug!(\"reg_component: unhandled class {:?}\", c)\n     }\n-    if tys.len() == 1 && tys[0].kind() == Vector {\n-        // if the type contains only a vector, pass it as that vector.\n-        tys[0]\n+}\n+\n+fn cast_target(cls: &[Class], size: u64) -> CastTarget {\n+    let mut i = 0;\n+    let lo = reg_component(cls, &mut i, size).unwrap();\n+    let offset = i as u64 * 8;\n+    let target = if size <= offset {\n+        CastTarget::from(lo)\n     } else {\n-        Type::struct_(ccx, &tys, false)\n-    }\n+        let hi = reg_component(cls, &mut i, size - offset).unwrap();\n+        CastTarget::Pair(lo, hi)\n+    };\n+    assert_eq!(reg_component(cls, &mut i, 0), None);\n+    target\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    fn x86_64_ty<F>(ccx: &CrateContext,\n-                    arg: &mut ArgType,\n-                    is_mem_cls: F,\n-                    ind_attr: Option<ArgAttribute>)\n-        where F: FnOnce(&[RegClass]) -> bool\n-    {\n-        if !arg.ty.is_reg_ty() {\n-            let cls = classify_ty(arg.ty);\n-            if is_mem_cls(&cls) {\n-                arg.make_indirect(ccx);\n-                if let Some(attr) = ind_attr {\n-                    arg.attrs.set(attr);\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    let mut int_regs = 6; // RDI, RSI, RDX, RCX, R8, R9\n+    let mut sse_regs = 8; // XMM0-7\n+\n+    let mut x86_64_ty = |arg: &mut ArgType<'tcx>, is_arg: bool| {\n+        let cls = classify_arg(ccx, arg);\n+\n+        let mut needed_int = 0;\n+        let mut needed_sse = 0;\n+        let in_mem = match cls {\n+            Err(Memory) => true,\n+            Ok(ref cls) if is_arg => {\n+                for &c in cls {\n+                    match c {\n+                        Class::Int => needed_int += 1,\n+                        Class::Sse => needed_sse += 1,\n+                        _ => {}\n+                    }\n                 }\n-            } else {\n-                arg.cast = Some(llreg_ty(ccx, &cls));\n+                arg.layout.is_aggregate() &&\n+                    (int_regs < needed_int || sse_regs < needed_sse)\n             }\n-        } else {\n-            arg.extend_integer_width_to(32);\n-        }\n-    }\n+            Ok(_) => false\n+        };\n \n-    let mut int_regs = 6; // RDI, RSI, RDX, RCX, R8, R9\n-    let mut sse_regs = 8; // XMM0-7\n+        if in_mem {\n+            // `sret` / `byval` parameter thus one less integer register available\n+            int_regs -= 1;\n \n-    if !fty.ret.is_ignore() {\n-        x86_64_ty(ccx, &mut fty.ret, |cls| {\n-            if cls.is_ret_bysret() {\n-                // `sret` parameter thus one less register available\n-                int_regs -= 1;\n-                true\n+            arg.make_indirect(ccx);\n+            if is_arg {\n+                arg.attrs.set(ArgAttribute::ByVal);\n+            }\n+        } else {\n+            // split into sized chunks passed individually\n+            int_regs -= needed_int;\n+            sse_regs -= needed_sse;\n+\n+            if arg.layout.is_aggregate() {\n+                let size = arg.layout.size(ccx).bytes();\n+                arg.cast_to(ccx, cast_target(cls.as_ref().unwrap(), size))\n             } else {\n-                false\n+                arg.extend_integer_width_to(32);\n             }\n-        }, None);\n+        }\n+    };\n+\n+    if !fty.ret.is_ignore() {\n+        x86_64_ty(&mut fty.ret, false);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        x86_64_ty(ccx, arg, |cls| {\n-            let needed_int = cls.iter().filter(|&&c| c == Int).count() as isize;\n-            let needed_sse = cls.iter().filter(|c| c.is_sse()).count() as isize;\n-            let in_mem = cls.is_pass_byval() ||\n-                         int_regs < needed_int ||\n-                         sse_regs < needed_sse;\n-            if in_mem {\n-                // `byval` parameter thus one less integer register available\n-                int_regs -= 1;\n-            } else {\n-                // split into sized chunks passed individually\n-                int_regs -= needed_int;\n-                sse_regs -= needed_sse;\n-            }\n-            in_mem\n-        }, Some(ArgAttribute::ByVal));\n-\n-        // An integer, pointer, double or float parameter\n-        // thus the above closure passed to `x86_64_ty` won't\n-        // get called.\n-        match arg.ty.kind() {\n-            Integer | Pointer => int_regs -= 1,\n-            Double | Float => sse_regs -= 1,\n-            _ => {}\n-        }\n+        x86_64_ty(arg, true);\n     }\n }"}, {"sha": "39e728d4e4f9b987bf4252031dbb2567b8665dbd", "filename": "src/librustc_trans/cabi_x86_win64.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_win64.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -8,30 +8,33 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::*;\n-use super::common::*;\n-use super::machine::*;\n-use abi::{ArgType, FnType};\n-use type_::Type;\n+use abi::{ArgType, FnType, LayoutExt, Reg};\n+use common::CrateContext;\n+\n+use rustc::ty::layout::Layout;\n \n // Win64 ABI: http://msdn.microsoft.com/en-us/library/zthk2dkh.aspx\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    let fixup = |a: &mut ArgType| {\n-        match a.ty.kind() {\n-            Struct => match llsize_of_alloc(ccx, a.ty) {\n-                          1 => a.cast = Some(Type::i8(ccx)),\n-                          2 => a.cast = Some(Type::i16(ccx)),\n-                          4 => a.cast = Some(Type::i32(ccx)),\n-                          8 => a.cast = Some(Type::i64(ccx)),\n-                          _ => a.make_indirect(ccx)\n-                      },\n-            Integer => match llsize_of_alloc(ccx, a.ty) {\n-                           1 ... 8 => a.extend_integer_width_to(32),\n-                           16 => a.make_indirect(ccx),\n-                           _ => bug!(),\n-            },\n-            _ => (),\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    let fixup = |a: &mut ArgType<'tcx>| {\n+        let size = a.layout.size(ccx);\n+        if a.layout.is_aggregate() {\n+            match size.bits() {\n+                8 => a.cast_to(ccx, Reg::i8()),\n+                16 => a.cast_to(ccx, Reg::i16()),\n+                32 => a.cast_to(ccx, Reg::i32()),\n+                64 => a.cast_to(ccx, Reg::i64()),\n+                _ => a.make_indirect(ccx)\n+            };\n+        } else {\n+            if let Layout::Vector { .. } = *a.layout {\n+                // FIXME(eddyb) there should be a size cap here\n+                // (probably what clang calls \"illegal vectors\").\n+            } else if size.bytes() > 8 {\n+                a.make_indirect(ccx);\n+            } else {\n+                a.extend_integer_width_to(32);\n+            }\n         }\n     };\n "}, {"sha": "caec4789eddce310a244e9c36ddf16eaa1138342", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -178,7 +178,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n                     let llslot = match op.val {\n                         Immediate(_) | Pair(..) => {\n-                            let llscratch = bcx.alloca(ret.original_ty, \"ret\");\n+                            let llscratch = bcx.alloca(ret.memory_ty(bcx.ccx), \"ret\");\n                             self.store_operand(&bcx, llscratch, None, op);\n                             llscratch\n                         }\n@@ -190,7 +190,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n                     let load = bcx.load(\n                         bcx.pointercast(llslot, cast_ty.ptr_to()),\n-                        Some(llalign_of_min(bcx.ccx, ret.ty)));\n+                        Some(ret.layout.align(bcx.ccx).abi() as u32));\n                     load\n                 } else {\n                     let op = self.trans_consume(&bcx, &mir::Lvalue::Local(mir::RETURN_POINTER));\n@@ -516,7 +516,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             (llargs[0], &llargs[1..])\n                         }\n                         ReturnDest::Nothing => {\n-                            (C_undef(fn_ty.ret.original_ty.ptr_to()), &llargs[..])\n+                            (C_undef(fn_ty.ret.memory_ty(bcx.ccx).ptr_to()), &llargs[..])\n                         }\n                         ReturnDest::IndirectOperand(dst, _) |\n                         ReturnDest::Store(dst) => (dst, &llargs[..]),\n@@ -535,7 +535,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             val: Ref(dst, Alignment::AbiAligned),\n                             ty: sig.output(),\n                         };\n-                        self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n+                        self.store_return(&bcx, ret_dest, &fn_ty.ret, op);\n                     }\n \n                     if let Some((_, target)) = *destination {\n@@ -574,7 +574,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             val: Immediate(invokeret),\n                             ty: sig.output(),\n                         };\n-                        self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n+                        self.store_return(&ret_bcx, ret_dest, &fn_ty.ret, op);\n                     }\n                 } else {\n                     let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle);\n@@ -584,7 +584,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             val: Immediate(llret),\n                             ty: sig.output(),\n                         };\n-                        self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n+                        self.store_return(&bcx, ret_dest, &fn_ty.ret, op);\n                         funclet_br(self, bcx, target);\n                     } else {\n                         bcx.unreachable();\n@@ -598,7 +598,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                       bcx: &Builder<'a, 'tcx>,\n                       op: OperandRef<'tcx>,\n                       llargs: &mut Vec<ValueRef>,\n-                      fn_ty: &FnType,\n+                      fn_ty: &FnType<'tcx>,\n                       next_idx: &mut usize,\n                       llfn: &mut Option<ValueRef>,\n                       def: &Option<ty::InstanceDef<'tcx>>) {\n@@ -641,7 +641,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => {\n                 if arg.is_indirect() || arg.cast.is_some() {\n-                    let llscratch = bcx.alloca(arg.original_ty, \"arg\");\n+                    let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\");\n                     self.store_operand(bcx, llscratch, None, op);\n                     (llscratch, Alignment::AbiAligned, true)\n                 } else {\n@@ -653,7 +653,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n                 // have scary latent bugs around.\n \n-                let llscratch = bcx.alloca(arg.original_ty, \"arg\");\n+                let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\");\n                 base::memcpy_ty(bcx, llscratch, llval, op.ty, Some(1));\n                 (llscratch, Alignment::AbiAligned, true)\n             }\n@@ -662,13 +662,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n-            if arg.original_ty == Type::i1(bcx.ccx) {\n+            if arg.layout.ty == bcx.tcx().types.bool {\n                 // We store bools as i8 so we need to truncate to i1.\n                 llval = bcx.load_range_assert(llval, 0, 2, llvm::False, None);\n-                llval = bcx.trunc(llval, arg.original_ty);\n+                llval = bcx.trunc(llval, Type::i1(bcx.ccx));\n             } else if let Some(ty) = arg.cast {\n                 llval = bcx.load(bcx.pointercast(llval, ty.ptr_to()),\n-                                 align.min_with(llalign_of_min(bcx.ccx, arg.ty)));\n+                                 align.min_with(arg.layout.align(bcx.ccx).abi() as u32));\n             } else {\n                 llval = bcx.load(llval, align.to_align());\n             }\n@@ -681,7 +681,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 bcx: &Builder<'a, 'tcx>,\n                                 operand: &mir::Operand<'tcx>,\n                                 llargs: &mut Vec<ValueRef>,\n-                                fn_ty: &FnType,\n+                                fn_ty: &FnType<'tcx>,\n                                 next_idx: &mut usize,\n                                 llfn: &mut Option<ValueRef>,\n                                 def: &Option<ty::InstanceDef<'tcx>>) {\n@@ -920,7 +920,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     fn store_return(&mut self,\n                     bcx: &Builder<'a, 'tcx>,\n                     dest: ReturnDest,\n-                    ret_ty: ArgType,\n+                    ret_ty: &ArgType<'tcx>,\n                     op: OperandRef<'tcx>) {\n         use self::ReturnDest::*;\n "}, {"sha": "c8d15d28708f4e3b9a8b926bc272afd174e9c778", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -53,7 +53,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n \n     ccx: &'a CrateContext<'a, 'tcx>,\n \n-    fn_ty: FnType,\n+    fn_ty: FnType<'tcx>,\n \n     /// When unwinding is initiated, we have to store this personality\n     /// value somewhere so that we can load it and re-use it in the\n@@ -455,6 +455,23 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 assert_eq!((meta.cast, meta.pad), (None, None));\n                 let llmeta = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n                 llarg_idx += 1;\n+\n+                // FIXME(eddyb) As we can't perfectly represent the data and/or\n+                // vtable pointer in a fat pointers in Rust's typesystem, and\n+                // because we split fat pointers into two ArgType's, they're\n+                // not the right type so we have to cast them for now.\n+                let pointee = match arg_ty.sty {\n+                    ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n+                    ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => ty,\n+                    ty::TyAdt(def, _) if def.is_box() => arg_ty.boxed_ty(),\n+                    _ => bug!()\n+                };\n+                let data_llty = type_of::in_memory_type_of(bcx.ccx, pointee);\n+                let meta_llty = type_of::unsized_info_ty(bcx.ccx, pointee);\n+\n+                let llarg = bcx.pointercast(llarg, data_llty.ptr_to());\n+                let llmeta = bcx.pointercast(llmeta, meta_llty);\n+\n                 OperandValue::Pair(llarg, llmeta)\n             } else {\n                 OperandValue::Immediate(llarg)"}, {"sha": "d4ab6b0782855b7702c3b1fcfe030e4cf5aed512", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 118, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -19,122 +19,6 @@ use type_::Type;\n \n use syntax::ast;\n \n-\n-// A \"sizing type\" is an LLVM type, the size and alignment of which are\n-// guaranteed to be equivalent to what you would get out of `type_of()`. It's\n-// useful because:\n-//\n-// (1) It may be cheaper to compute the sizing type than the full type if all\n-//     you're interested in is the size and/or alignment;\n-//\n-// (2) It won't make any recursive calls to determine the structure of the\n-//     type behind pointers. This can help prevent infinite loops for\n-//     recursive types. For example, enum types rely on this behavior.\n-\n-pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    if let Some(t) = cx.llsizingtypes().borrow().get(&t).cloned() {\n-        return t;\n-    }\n-\n-    debug!(\"sizing_type_of {:?}\", t);\n-    let _recursion_lock = cx.enter_type_of(t);\n-\n-    let ptr_sizing_ty = |ty: Ty<'tcx>| {\n-        if cx.shared().type_is_sized(ty) {\n-            Type::i8p(cx)\n-        } else {\n-            Type::struct_(cx, &[Type::i8p(cx), unsized_info_ty(cx, ty)], false)\n-        }\n-    };\n-    let llsizingty = match t.sty {\n-        _ if !cx.shared().type_is_sized(t) => {\n-            Type::struct_(cx, &[Type::i8p(cx), unsized_info_ty(cx, t)], false)\n-        }\n-\n-        ty::TyBool => Type::bool(cx),\n-        ty::TyChar => Type::char(cx),\n-        ty::TyInt(t) => Type::int_from_ty(cx, t),\n-        ty::TyUint(t) => Type::uint_from_ty(cx, t),\n-        ty::TyFloat(t) => Type::float_from_ty(cx, t),\n-        ty::TyNever => Type::nil(cx),\n-\n-        ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n-        ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => {\n-            ptr_sizing_ty(ty)\n-        }\n-        ty::TyAdt(def, _) if def.is_box() => {\n-            ptr_sizing_ty(t.boxed_ty())\n-        }\n-\n-        ty::TyFnDef(..) => Type::nil(cx),\n-        ty::TyFnPtr(_) => Type::i8p(cx),\n-\n-        ty::TyArray(ty, size) => {\n-            let llty = sizing_type_of(cx, ty);\n-            let size = size as u64;\n-            Type::array(&llty, size)\n-        }\n-\n-        ty::TyTuple(ref tys, _) if tys.is_empty() => {\n-            Type::nil(cx)\n-        }\n-\n-        ty::TyAdt(..) if t.is_simd() => {\n-            let e = t.simd_type(cx.tcx());\n-            if !e.is_machine() {\n-                cx.sess().fatal(&format!(\"monomorphising SIMD type `{}` with \\\n-                                          a non-machine element type `{}`\",\n-                                         t, e))\n-            }\n-            let llet = type_of(cx, e);\n-            let n = t.simd_size(cx.tcx()) as u64;\n-            Type::vector(&llet, n)\n-        }\n-\n-        ty::TyTuple(..) | ty::TyAdt(..) | ty::TyClosure(..) => {\n-            adt::sizing_type_of(cx, t, false)\n-        }\n-\n-        ty::TyProjection(..) | ty::TyInfer(..) | ty::TyParam(..) |\n-        ty::TyAnon(..) | ty::TyError => {\n-            bug!(\"fictitious type {:?} in sizing_type_of()\", t)\n-        }\n-        ty::TySlice(_) | ty::TyDynamic(..) | ty::TyStr => bug!()\n-    };\n-\n-    debug!(\"--> mapped t={:?} to llsizingty={:?}\", t, llsizingty);\n-\n-    cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n-\n-    // FIXME(eddyb) Temporary sanity check for ty::layout.\n-    let layout = cx.layout_of(t);\n-    if !cx.shared().type_is_sized(t) {\n-        if !layout.is_unsized() {\n-            bug!(\"layout should be unsized for type `{}` / {:#?}\",\n-                 t, layout);\n-        }\n-\n-        // Unsized types get turned into a fat pointer for LLVM.\n-        return llsizingty;\n-    }\n-\n-    let r = layout.size(cx).bytes();\n-    let l = machine::llsize_of_alloc(cx, llsizingty);\n-    if r != l {\n-        bug!(\"size differs (rustc: {}, llvm: {}) for type `{}` / {:#?}\",\n-             r, l, t, layout);\n-    }\n-\n-    let r = layout.align(cx).abi();\n-    let l = machine::llalign_of_min(cx, llsizingty) as u64;\n-    if r != l {\n-        bug!(\"align differs (rustc: {}, llvm: {}) for type `{}` / {:#?}\",\n-             r, l, t, layout);\n-    }\n-\n-    llsizingty\n-}\n-\n pub fn fat_ptr_base_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n     match ty.sty {\n         ty::TyRef(_, ty::TypeAndMut { ty: t, .. }) |\n@@ -148,7 +32,7 @@ pub fn fat_ptr_base_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) ->\n     }\n }\n \n-fn unsized_info_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n+pub fn unsized_info_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n     let unsized_part = ccx.tcx().struct_tail(ty);\n     match unsized_part.sty {\n         ty::TyStr | ty::TyArray(..) | ty::TySlice(_) => {\n@@ -197,7 +81,6 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n /// of that field's type - this is useful for taking the address of\n /// that field and ensuring the struct has the right alignment.\n /// For the LLVM type of a value as a whole, see `type_of`.\n-/// NB: If you update this, be sure to update `sizing_type_of()` as well.\n pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     // Check the cache.\n     if let Some(&llty) = cx.lltypes().borrow().get(&t) {"}, {"sha": "bc84ac49da985a11166ccc4e2c80793f45291e63", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0636b61c7f84962a609e831760db9d77f4f5e14/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=f0636b61c7f84962a609e831760db9d77f4f5e14", "patch": "@@ -121,13 +121,13 @@ pub fn unsafe_slice(_: &[UnsafeInner]) {\n fn str(_: &[u8]) {\n }\n \n-// CHECK: @trait_borrow(i8* nonnull, void (i8*)** noalias nonnull readonly)\n+// CHECK: @trait_borrow({}* nonnull, {}* noalias nonnull readonly)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n fn trait_borrow(_: &Drop) {\n }\n \n-// CHECK: @trait_box(i8* noalias nonnull, void (i8*)** noalias nonnull readonly)\n+// CHECK: @trait_box({}* noalias nonnull, {}* noalias nonnull readonly)\n #[no_mangle]\n fn trait_box(_: Box<Drop>) {\n }"}]}