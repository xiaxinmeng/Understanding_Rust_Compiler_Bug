{"sha": "b3164f3ab4720c6596c7e789c0281489c62347e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMTY0ZjNhYjQ3MjBjNjU5NmM3ZTc4OWMwMjgxNDg5YzYyMzQ3ZTc=", "commit": {"author": {"name": "Basile Desloges", "email": "basile.desloges@gmail.com", "date": "2018-02-22T14:27:41Z"}, "committer": {"name": "Basile Desloges", "email": "basile.desloges@gmail.com", "date": "2018-03-08T21:28:50Z"}, "message": "Add codemap functions to retrieve the source before a given span", "tree": {"sha": "d8a26e3dca781d7b8c4ad5e8809c72aa4308d276", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8a26e3dca781d7b8c4ad5e8809c72aa4308d276"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3164f3ab4720c6596c7e789c0281489c62347e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3164f3ab4720c6596c7e789c0281489c62347e7", "html_url": "https://github.com/rust-lang/rust/commit/b3164f3ab4720c6596c7e789c0281489c62347e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3164f3ab4720c6596c7e789c0281489c62347e7/comments", "author": {"login": "zilbuz", "id": 434964, "node_id": "MDQ6VXNlcjQzNDk2NA==", "avatar_url": "https://avatars.githubusercontent.com/u/434964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zilbuz", "html_url": "https://github.com/zilbuz", "followers_url": "https://api.github.com/users/zilbuz/followers", "following_url": "https://api.github.com/users/zilbuz/following{/other_user}", "gists_url": "https://api.github.com/users/zilbuz/gists{/gist_id}", "starred_url": "https://api.github.com/users/zilbuz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zilbuz/subscriptions", "organizations_url": "https://api.github.com/users/zilbuz/orgs", "repos_url": "https://api.github.com/users/zilbuz/repos", "events_url": "https://api.github.com/users/zilbuz/events{/privacy}", "received_events_url": "https://api.github.com/users/zilbuz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zilbuz", "id": 434964, "node_id": "MDQ6VXNlcjQzNDk2NA==", "avatar_url": "https://avatars.githubusercontent.com/u/434964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zilbuz", "html_url": "https://github.com/zilbuz", "followers_url": "https://api.github.com/users/zilbuz/followers", "following_url": "https://api.github.com/users/zilbuz/following{/other_user}", "gists_url": "https://api.github.com/users/zilbuz/gists{/gist_id}", "starred_url": "https://api.github.com/users/zilbuz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zilbuz/subscriptions", "organizations_url": "https://api.github.com/users/zilbuz/orgs", "repos_url": "https://api.github.com/users/zilbuz/repos", "events_url": "https://api.github.com/users/zilbuz/events{/privacy}", "received_events_url": "https://api.github.com/users/zilbuz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4af749f074a255bf923dc871a7e24f5b2fd58176", "url": "https://api.github.com/repos/rust-lang/rust/commits/4af749f074a255bf923dc871a7e24f5b2fd58176", "html_url": "https://github.com/rust-lang/rust/commit/4af749f074a255bf923dc871a7e24f5b2fd58176"}], "stats": {"total": 66, "additions": 63, "deletions": 3}, "files": [{"sha": "c340f1b8c8ab328315409ce002537c2a9788571d", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 63, "deletions": 3, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b3164f3ab4720c6596c7e789c0281489c62347e7/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3164f3ab4720c6596c7e789c0281489c62347e7/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=b3164f3ab4720c6596c7e789c0281489c62347e7", "patch": "@@ -533,7 +533,12 @@ impl CodeMap {\n         Ok(FileLines {file: lo.file, lines: lines})\n     }\n \n-    pub fn span_to_snippet(&self, sp: Span) -> Result<String, SpanSnippetError> {\n+    /// Extract the source surrounding the given `Span` using the `extract_source` function. The\n+    /// extract function takes three arguments: a string slice containing the source, an index in\n+    /// the slice for the beginning of the span and an index in the slice for the end of the span.\n+    fn span_to_source<F>(&self, sp: Span, extract_source: F) -> Result<String, SpanSnippetError>\n+        where F: Fn(&str, usize, usize) -> String\n+    {\n         if sp.lo() > sp.hi() {\n             return Err(SpanSnippetError::IllFormedSpan(sp));\n         }\n@@ -567,9 +572,9 @@ impl CodeMap {\n             }\n \n             if let Some(ref src) = local_begin.fm.src {\n-                return Ok((&src[start_index..end_index]).to_string());\n+                return Ok(extract_source(src, start_index, end_index));\n             } else if let Some(src) = local_begin.fm.external_src.borrow().get_source() {\n-                return Ok((&src[start_index..end_index]).to_string());\n+                return Ok(extract_source(src, start_index, end_index));\n             } else {\n                 return Err(SpanSnippetError::SourceNotAvailable {\n                     filename: local_begin.fm.name.clone()\n@@ -578,6 +583,17 @@ impl CodeMap {\n         }\n     }\n \n+    /// Return the source snippet as `String` corresponding to the given `Span`\n+    pub fn span_to_snippet(&self, sp: Span) -> Result<String, SpanSnippetError> {\n+        self.span_to_source(sp, |src, start_index, end_index| src[start_index..end_index]\n+                                                                .to_string())\n+    }\n+\n+    /// Return the source snippet as `String` before the given `Span`\n+    pub fn span_to_prev_source(&self, sp: Span) -> Result<String, SpanSnippetError> {\n+        self.span_to_source(sp, |src, start_index, _| src[..start_index].to_string())\n+    }\n+\n     /// Given a `Span`, try to get a shorter span ending before the first occurrence of `c` `char`\n     pub fn span_until_char(&self, sp: Span, c: char) -> Span {\n         match self.span_to_snippet(sp) {\n@@ -593,6 +609,32 @@ impl CodeMap {\n         }\n     }\n \n+    /// Extend the given `Span` to just after the previous occurrence of `c`. Return the same span\n+    /// if no character could be found or if an error occurred while retrieving the code snippet.\n+    pub fn span_extend_to_prev_char(&self, sp: Span, c: char) -> Span {\n+        if let Ok(prev_source) = self.span_to_prev_source(sp) {\n+            let prev_source = prev_source.rsplit(c).nth(0).unwrap_or(\"\").trim_left();\n+            if !prev_source.is_empty() && !prev_source.contains('\\n') {\n+                return sp.with_lo(BytePos(sp.lo().0 - prev_source.len() as u32));\n+            }\n+        }\n+\n+        sp\n+    }\n+\n+    /// Extend the given `Span` to just after the previous occurrence of `pat`. Return the same span\n+    /// if no character could be found or if an error occurred while retrieving the code snippet.\n+    pub fn span_extend_to_prev_str(&self, sp: Span, pat: &str) -> Span {\n+        if let Ok(prev_source) = self.span_to_prev_source(sp) {\n+            let prev_source = prev_source.rsplit(pat).nth(0).unwrap_or(\"\").trim_left();\n+            if !prev_source.is_empty() && !prev_source.contains('\\n') {\n+                return sp.with_lo(BytePos(sp.lo().0 - prev_source.len() as u32));\n+            }\n+        }\n+\n+        sp\n+    }\n+\n     /// Given a `Span`, get a new `Span` covering the first token and all its trailing whitespace or\n     /// the original `Span`.\n     ///\n@@ -615,6 +657,24 @@ impl CodeMap {\n         sp\n     }\n \n+    /// Given a `Span`, get a new `Span` covering the first token without its trailing whitespace or\n+    /// the original `Span` in case of error.\n+    ///\n+    /// If `sp` points to `\"let mut x\"`, then a span pointing at `\"let\"` will be returned.\n+    pub fn span_until_whitespace(&self, sp: Span) -> Span {\n+        if let Ok(snippet) = self.span_to_snippet(sp) {\n+            let mut offset = 0;\n+            // Get the bytes width of all the non-whitespace characters\n+            for c in snippet.chars().take_while(|c| !c.is_whitespace()) {\n+                offset += c.len_utf8();\n+            }\n+            if offset > 1 {\n+                return sp.with_hi(BytePos(sp.lo().0 + offset as u32));\n+            }\n+        }\n+        sp\n+    }\n+\n     /// Given a `Span`, try to get a shorter span ending just after the first occurrence of `char`\n     /// `c`.\n     pub fn span_through_char(&self, sp: Span, c: char) -> Span {"}]}