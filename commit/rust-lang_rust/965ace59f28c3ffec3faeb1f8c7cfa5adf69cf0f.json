{"sha": "965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NWFjZTU5ZjI4YzNmZmVjM2ZhZWIxZjhjN2NmYTVhZGY2OWNmMGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-11T13:30:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-11T13:30:16Z"}, "message": "Auto merge of #45932 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 4 pull requests\n\n- Successful merges: #45631, #45812, #45877, #45919\n- Failed merges:", "tree": {"sha": "5a7a5ffd74681217445b14751ba5f71bda8e8d5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a7a5ffd74681217445b14751ba5f71bda8e8d5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f", "html_url": "https://github.com/rust-lang/rust/commit/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69ee5a8a9787336f8635ec12ed0c6199a70505e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/69ee5a8a9787336f8635ec12ed0c6199a70505e0", "html_url": "https://github.com/rust-lang/rust/commit/69ee5a8a9787336f8635ec12ed0c6199a70505e0"}, {"sha": "04785f7e33d3ca67c2b3f2e1ed34e3dc20d8bdc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/04785f7e33d3ca67c2b3f2e1ed34e3dc20d8bdc2", "html_url": "https://github.com/rust-lang/rust/commit/04785f7e33d3ca67c2b3f2e1ed34e3dc20d8bdc2"}], "stats": {"total": 407, "additions": 373, "deletions": 34}, "files": [{"sha": "15545a04b64de04e7b37e8115ad8d6b491a92cd4", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f", "patch": "@@ -259,7 +259,7 @@ pub trait Hasher {\n     /// println!(\"Hash is {:x}!\", hasher.finish());\n     /// ```\n     ///\n-    /// ['write']: #tymethod.write\n+    /// [`write`]: #tymethod.write\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn finish(&self) -> u64;\n "}, {"sha": "d2524b306cfed6a22c8b2f1fb6aeacaedcc4b376", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 84, "deletions": 23, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f", "patch": "@@ -30,9 +30,10 @@ use dataflow::{do_dataflow};\n use dataflow::{MoveDataParamEnv};\n use dataflow::{BitDenotation, BlockSets, DataflowResults, DataflowResultsConsumer};\n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use dataflow::{MovingOutStatements};\n use dataflow::{Borrows, BorrowData, BorrowIndex};\n use dataflow::move_paths::{MoveError, IllegalMoveOriginKind};\n-use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n+use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult, MoveOutIndex};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n use self::MutateMode::{JustWrite, WriteAndRead};\n@@ -129,6 +130,9 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     let flow_uninits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n                                    MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n                                    |bd, i| &bd.move_data().move_paths[i]);\n+    let flow_move_outs = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                     MovingOutStatements::new(tcx, mir, &mdpe),\n+                                     |bd, i| &bd.move_data().moves[i]);\n \n     let mut mbcx = MirBorrowckCtxt {\n         tcx: tcx,\n@@ -141,7 +145,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n \n     let mut state = InProgress::new(flow_borrows,\n                                     flow_inits,\n-                                    flow_uninits);\n+                                    flow_uninits,\n+                                    flow_move_outs);\n \n     mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n }\n@@ -161,6 +166,7 @@ pub struct InProgress<'b, 'gcx: 'tcx, 'tcx: 'b> {\n     borrows: FlowInProgress<Borrows<'b, 'gcx, 'tcx>>,\n     inits: FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n     uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n+    move_outs: FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>,\n }\n \n struct FlowInProgress<BD> where BD: BitDenotation {\n@@ -185,31 +191,35 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'tcx>\n     fn reset_to_entry_of(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n         flow_state.each_flow(|b| b.reset_to_entry_of(bb),\n                              |i| i.reset_to_entry_of(bb),\n-                             |u| u.reset_to_entry_of(bb));\n+                             |u| u.reset_to_entry_of(bb),\n+                             |m| m.reset_to_entry_of(bb));\n     }\n \n     fn reconstruct_statement_effect(&mut self,\n                                     location: Location,\n                                     flow_state: &mut Self::FlowState) {\n         flow_state.each_flow(|b| b.reconstruct_statement_effect(location),\n                              |i| i.reconstruct_statement_effect(location),\n-                             |u| u.reconstruct_statement_effect(location));\n+                             |u| u.reconstruct_statement_effect(location),\n+                             |m| m.reconstruct_statement_effect(location));\n     }\n \n     fn apply_local_effect(&mut self,\n                           _location: Location,\n                           flow_state: &mut Self::FlowState) {\n         flow_state.each_flow(|b| b.apply_local_effect(),\n                              |i| i.apply_local_effect(),\n-                             |u| u.apply_local_effect());\n+                             |u| u.apply_local_effect(),\n+                             |m| m.apply_local_effect());\n     }\n \n     fn reconstruct_terminator_effect(&mut self,\n                                      location: Location,\n                                      flow_state: &mut Self::FlowState) {\n         flow_state.each_flow(|b| b.reconstruct_terminator_effect(location),\n                              |i| i.reconstruct_terminator_effect(location),\n-                             |u| u.reconstruct_terminator_effect(location));\n+                             |u| u.reconstruct_terminator_effect(location),\n+                             |m| m.reconstruct_terminator_effect(location));\n     }\n \n     fn visit_block_entry(&mut self,\n@@ -671,6 +681,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         let lvalue = self.base_path(lvalue_span.0);\n \n         let maybe_uninits = &flow_state.uninits;\n+        let curr_move_outs = &flow_state.move_outs.curr_state;\n \n         // Bad scenarios:\n         //\n@@ -712,7 +723,9 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         match self.move_path_closest_to(lvalue) {\n             Ok(mpi) => {\n                 if maybe_uninits.curr_state.contains(&mpi) {\n-                    self.report_use_of_moved(context, desired_action, lvalue_span);\n+                    self.report_use_of_moved_or_uninitialized(context, desired_action,\n+                                                              lvalue_span, mpi,\n+                                                              curr_move_outs);\n                     return; // don't bother finding other problems.\n                 }\n             }\n@@ -737,8 +750,10 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n         debug!(\"check_if_path_is_moved part2 lvalue: {:?}\", lvalue);\n         if let Some(mpi) = self.move_path_for_lvalue(lvalue) {\n-            if let Some(_) = maybe_uninits.has_any_child_of(mpi) {\n-                self.report_use_of_moved(context, desired_action, lvalue_span);\n+            if let Some(child_mpi) = maybe_uninits.has_any_child_of(mpi) {\n+                self.report_use_of_moved_or_uninitialized(context, desired_action,\n+                                                          lvalue_span, child_mpi,\n+                                                          curr_move_outs);\n                 return; // don't bother finding other problems.\n             }\n         }\n@@ -1083,17 +1098,47 @@ mod prefixes {\n }\n \n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n-    fn report_use_of_moved(&mut self,\n+    fn report_use_of_moved_or_uninitialized(&mut self,\n                            _context: Context,\n                            desired_action: &str,\n-                           (lvalue, span): (&Lvalue, Span)) {\n-        self.tcx.cannot_act_on_uninitialized_variable(span,\n-                                                      desired_action,\n-                                                      &self.describe_lvalue(lvalue),\n-                                                      Origin::Mir)\n-                .span_label(span, format!(\"use of possibly uninitialized `{}`\",\n-                                          self.describe_lvalue(lvalue)))\n-                .emit();\n+                           (lvalue, span): (&Lvalue, Span),\n+                           mpi: MovePathIndex,\n+                           curr_move_out: &IdxSetBuf<MoveOutIndex>) {\n+\n+        let mois = self.move_data.path_map[mpi].iter().filter(\n+            |moi| curr_move_out.contains(moi)).collect::<Vec<_>>();\n+\n+        if mois.is_empty() {\n+            self.tcx.cannot_act_on_uninitialized_variable(span,\n+                                                          desired_action,\n+                                                          &self.describe_lvalue(lvalue),\n+                                                          Origin::Mir)\n+                    .span_label(span, format!(\"use of possibly uninitialized `{}`\",\n+                                              self.describe_lvalue(lvalue)))\n+                    .emit();\n+        } else {\n+            let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n+\n+            let mut err = self.tcx.cannot_act_on_moved_value(span,\n+                                                             desired_action,\n+                                                             msg,\n+                                                             &self.describe_lvalue(lvalue),\n+                                                             Origin::Mir);\n+            err.span_label(span, format!(\"value {} here after move\", desired_action));\n+            for moi in mois {\n+                let move_msg = \"\"; //FIXME: add \" (into closure)\"\n+                let move_span = self.mir.source_info(self.move_data.moves[*moi].source).span;\n+                if span == move_span {\n+                    err.span_label(span,\n+                                   format!(\"value moved{} here in previous iteration of loop\",\n+                                           move_msg));\n+                } else {\n+                    err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n+                };\n+            }\n+            //FIXME: add note for closure\n+            err.emit();\n+        }\n     }\n \n     fn report_move_out_while_borrowed(&mut self,\n@@ -1396,26 +1441,31 @@ impl ContextKind {\n impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n     pub(super) fn new(borrows: DataflowResults<Borrows<'b, 'gcx, 'tcx>>,\n                       inits: DataflowResults<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n-                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>)\n+                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n+                      move_out: DataflowResults<MovingOutStatements<'b, 'gcx, 'tcx>>)\n                       -> Self {\n         InProgress {\n             borrows: FlowInProgress::new(borrows),\n             inits: FlowInProgress::new(inits),\n             uninits: FlowInProgress::new(uninits),\n+            move_outs: FlowInProgress::new(move_out)\n         }\n     }\n \n-    fn each_flow<XB, XI, XU>(&mut self,\n-                             mut xform_borrows: XB,\n-                             mut xform_inits: XI,\n-                             mut xform_uninits: XU) where\n+    fn each_flow<XB, XI, XU, XM>(&mut self,\n+                                 mut xform_borrows: XB,\n+                                 mut xform_inits: XI,\n+                                 mut xform_uninits: XU,\n+                                 mut xform_move_outs: XM) where\n         XB: FnMut(&mut FlowInProgress<Borrows<'b, 'gcx, 'tcx>>),\n         XI: FnMut(&mut FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>),\n         XU: FnMut(&mut FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>),\n+        XM: FnMut(&mut FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>),\n     {\n         xform_borrows(&mut self.borrows);\n         xform_inits(&mut self.inits);\n         xform_uninits(&mut self.uninits);\n+        xform_move_outs(&mut self.move_outs);\n     }\n \n     fn summary(&self) -> String {\n@@ -1461,6 +1511,17 @@ impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n                 &self.uninits.base_results.operator().move_data().move_paths[mpi_uninit];\n             s.push_str(&format!(\"{}\", move_path));\n         });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"move_out: [\");\n+        let mut saw_one = false;\n+        self.move_outs.each_state_bit(|mpi_move_out| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let move_out =\n+                &self.move_outs.base_results.operator().move_data().moves[mpi_move_out];\n+            s.push_str(&format!(\"{:?}\", move_out));\n+        });\n         s.push_str(\"]\");\n \n         return s;"}, {"sha": "dad96dc3a6ffeb2c47ae66f8d0d918f49a13cd2e", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 174, "deletions": 1, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f", "patch": "@@ -14,13 +14,16 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::{self, Mir, Location};\n+use rustc_data_structures::bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n use rustc_data_structures::bitslice::{BitwiseOperator};\n use rustc_data_structures::indexed_set::{IdxSet};\n+use rustc_data_structures::indexed_vec::Idx;\n \n use super::MoveDataParamEnv;\n use util::elaborate_drops::DropFlagState;\n \n-use super::move_paths::{HasMoveData, MoveData, MovePathIndex};\n+use super::move_paths::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex};\n+use super::move_paths::LookupResult;\n use super::{BitDenotation, BlockSets, DataflowOperator};\n \n use super::drop_flag_effects_for_function_entry;\n@@ -205,6 +208,40 @@ impl<'a, 'gcx, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedLvals<'a, 'g\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n+/// `MovingOutStatements` tracks the statements that perform moves out\n+/// of particular l-values. More precisely, it tracks whether the\n+/// *effect* of such moves (namely, the uninitialization of the\n+/// l-value in question) can reach some point in the control-flow of\n+/// the function, or if that effect is \"killed\" by some intervening\n+/// operation reinitializing that l-value.\n+///\n+/// The resulting dataflow is a more enriched version of\n+/// `MaybeUninitializedLvals`. Both structures on their own only tell\n+/// you if an l-value *might* be uninitialized at a given point in the\n+/// control flow. But `MovingOutStatements` also includes the added\n+/// data of *which* particular statement causing the deinitialization\n+/// that the borrow checker's error message may need to report.\n+#[allow(dead_code)]\n+pub struct MovingOutStatements<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a> MovingOutStatements<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+               mir: &'a Mir<'tcx>,\n+               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n+               -> Self\n+    {\n+        MovingOutStatements { tcx: tcx, mir: mir, mdpe: mdpe }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MovingOutStatements<'a, 'gcx, 'tcx> {\n+    fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n+}\n+\n impl<'a, 'gcx, 'tcx> MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n@@ -399,6 +436,128 @@ impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'gcx, 'tcx\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n+    type Idx = MoveOutIndex;\n+    fn name() -> &'static str { \"moving_out\" }\n+    fn bits_per_block(&self) -> usize {\n+        self.move_data().moves.len()\n+    }\n+\n+    fn start_block_effect(&self, _sets: &mut BlockSets<MoveOutIndex>) {\n+        // no move-statements have been executed prior to function\n+        // execution, so this method has no effect on `_sets`.\n+    }\n+    fn statement_effect(&self,\n+                        sets: &mut BlockSets<MoveOutIndex>,\n+                        location: Location) {\n+        let (tcx, mir, move_data) = (self.tcx, self.mir, self.move_data());\n+        let stmt = &mir[location.block].statements[location.statement_index];\n+        let loc_map = &move_data.loc_map;\n+        let path_map = &move_data.path_map;\n+        let rev_lookup = &move_data.rev_lookup;\n+\n+        debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n+               stmt, location, &loc_map[location]);\n+        for move_index in &loc_map[location] {\n+            // Every path deinitialized by a *particular move*\n+            // has corresponding bit, \"gen'ed\" (i.e. set)\n+            // here, in dataflow vector\n+            zero_to_one(sets.gen_set.words_mut(), *move_index);\n+        }\n+        let bits_per_block = self.bits_per_block();\n+        match stmt.kind {\n+            mir::StatementKind::SetDiscriminant { .. } => {\n+                span_bug!(stmt.source_info.span, \"SetDiscriminant should not exist in borrowck\");\n+            }\n+            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n+                // assigning into this `lvalue` kills all\n+                // MoveOuts from it, and *also* all MoveOuts\n+                // for children and associated fragment sets.\n+                match rvalue.initialization_state() {\n+                    mir::tcx::RvalueInitializationState::Shallow => {\n+                        if let LookupResult::Exact(mpi) = rev_lookup.find(lvalue) {\n+                             for moi in &path_map[mpi] {\n+                                 assert!(moi.index() < bits_per_block);\n+                                 sets.kill_set.add(&moi);\n+                             }\n+                        }\n+                    }\n+                    mir::tcx::RvalueInitializationState::Deep => {\n+                        on_lookup_result_bits(tcx,\n+                                              mir,\n+                                              move_data,\n+                                              rev_lookup.find(lvalue),\n+                                              |mpi| for moi in &path_map[mpi] {\n+                                                  assert!(moi.index() < bits_per_block);\n+                                                  sets.kill_set.add(&moi);\n+                                              });\n+                    }\n+                }\n+            }\n+            mir::StatementKind::StorageLive(_) |\n+            mir::StatementKind::StorageDead(_) |\n+            mir::StatementKind::InlineAsm { .. } |\n+            mir::StatementKind::EndRegion(_) |\n+            mir::StatementKind::Validate(..) |\n+            mir::StatementKind::Nop => {}\n+        }\n+    }\n+\n+    fn terminator_effect(&self,\n+                         sets: &mut BlockSets<MoveOutIndex>,\n+                         location: Location)\n+    {\n+        let (mir, move_data) = (self.mir, self.move_data());\n+        let term = mir[location.block].terminator();\n+        let loc_map = &move_data.loc_map;\n+        debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n+               term, location, &loc_map[location]);\n+        let bits_per_block = self.bits_per_block();\n+        for move_index in &loc_map[location] {\n+            assert!(move_index.index() < bits_per_block);\n+            zero_to_one(sets.gen_set.words_mut(), *move_index);\n+        }\n+        match term.kind {\n+            mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n+                on_lookup_result_bits(self.tcx,\n+                                      mir,\n+                                      move_data,\n+                                      move_data.rev_lookup.find(location),\n+                                      |mpi| for moi in &move_data.path_map[mpi] {\n+                                          assert!(moi.index() < bits_per_block);\n+                                          sets.kill_set.add(&moi);\n+                                      });\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             in_out: &mut IdxSet<MoveOutIndex>,\n+                             _call_bb: mir::BasicBlock,\n+                             _dest_bb: mir::BasicBlock,\n+                             dest_lval: &mir::Lvalue) {\n+        let move_data = self.move_data();\n+        let bits_per_block = self.bits_per_block();\n+\n+        let path_map = &move_data.path_map;\n+        on_lookup_result_bits(self.tcx,\n+                              self.mir,\n+                              move_data,\n+                              move_data.rev_lookup.find(dest_lval),\n+                              |mpi| for moi in &path_map[mpi] {\n+                                  assert!(moi.index() < bits_per_block);\n+                                  in_out.remove(&moi);\n+                              });\n+    }\n+}\n+\n+fn zero_to_one(bitvec: &mut [usize], move_index: MoveOutIndex) {\n+    let retval = bitvec.set_bit(move_index.index());\n+    assert!(retval);\n+}\n+\n+\n impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n@@ -420,6 +579,13 @@ impl<'a, 'gcx, 'tcx> BitwiseOperator for DefinitelyInitializedLvals<'a, 'gcx, 't\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> BitwiseOperator for MovingOutStatements<'a, 'gcx, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // moves from both preds are in scope\n+    }\n+}\n+\n // The way that dataflow fixed point iteration works, you want to\n // start at bottom and work your way to a fixed point. Control-flow\n // merges will apply the `join` operator to each block entry's current\n@@ -450,3 +616,10 @@ impl<'a, 'gcx, 'tcx> DataflowOperator for DefinitelyInitializedLvals<'a, 'gcx, '\n         true // bottom = initialized (start_block_effect counters this at outset)\n     }\n }\n+\n+impl<'a, 'gcx, 'tcx> DataflowOperator for MovingOutStatements<'a, 'gcx, 'tcx> {\n+    #[inline]\n+    fn bottom_value() -> bool {\n+        false // bottom = no loans in scope by default\n+    }\n+}"}, {"sha": "bca9324d5b0aaaf8df44dc5459f88f91e833b389", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f", "patch": "@@ -26,7 +26,7 @@ use std::usize;\n \n pub use self::impls::{MaybeStorageLive};\n pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-pub use self::impls::{DefinitelyInitializedLvals};\n+pub use self::impls::{DefinitelyInitializedLvals, MovingOutStatements};\n pub use self::impls::borrows::{Borrows, BorrowData, BorrowIndex};\n pub(crate) use self::drop_flag_effects::*;\n "}, {"sha": "ecafb88c2b0e24e4a9905440bdc04eeefc3e4733", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f", "patch": "@@ -52,14 +52,14 @@\n             var start = elemClass.indexOf(className);\n             if (start == -1) {\n                 return false;\n-            } else if (elemClass.length == className.length) {\n+            } else if (elemClass.length === className.length) {\n                 return true;\n             } else {\n-                if (start > 0 && elemClass[start - 1] != ' ') {\n+                if (start > 0 && elemClass[start - 1] !== ' ') {\n                     return false;\n                 }\n                 var end = start + className.length;\n-                if (end < elemClass.length && elemClass[end] != ' ') {\n+                if (end < elemClass.length && elemClass[end] !== ' ') {\n                     return false;\n                 }\n                 return true;\n@@ -122,6 +122,7 @@\n     }\n \n     function highlightSourceLines(ev) {\n+        var search = document.getElementById(\"search\");\n         var i, from, to, match = window.location.hash.match(/^#?(\\d+)(?:-(\\d+))?$/);\n         if (match) {\n             from = parseInt(match[1], 10);\n@@ -145,6 +146,17 @@\n             for (i = from; i <= to; ++i) {\n                 addClass(document.getElementById(i), 'line-highlighted');\n             }\n+        } else if (ev !== null && search && !hasClass(search, \"hidden\") && ev.newURL) {\n+            addClass(search, \"hidden\");\n+            removeClass(document.getElementById(\"main\"), \"hidden\");\n+            var hash = ev.newURL.slice(ev.newURL.indexOf('#') + 1);\n+            if (browserSupportsHistoryApi()) {\n+                history.replaceState(hash, \"\", \"?search=#\" + hash);\n+            }\n+            var elem = document.getElementById(hash);\n+            if (elem) {\n+                elem.scrollIntoView();\n+            }\n         }\n     }\n     highlightSourceLines(null);\n@@ -1552,6 +1564,22 @@\n             });\n         }\n     });\n+\n+    var search_input = document.getElementsByClassName(\"search-input\")[0];\n+\n+    if (search_input) {\n+        search_input.onfocus = function() {\n+            if (search_input.value !== \"\") {\n+                addClass(document.getElementById(\"main\"), \"hidden\");\n+                removeClass(document.getElementById(\"search\"), \"hidden\");\n+                if (browserSupportsHistoryApi()) {\n+                    history.replaceState(search_input.value,\n+                                         \"\",\n+                                         \"?search=\" + encodeURIComponent(search_input.value));\n+                }\n+            }\n+        };\n+    }\n }());\n \n // Sets the focus on the search bar at the top of the page"}, {"sha": "2e17fd58e0a1e27658cd19377d5f0dbd0b780c72", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f", "patch": "@@ -34,8 +34,28 @@ pub trait FileExt {\n     ///\n     /// The current file cursor is not affected by this function.\n     ///\n-    /// Note that similar to `File::read`, it is not an error to return with a\n+    /// Note that similar to [`File::read`], it is not an error to return with a\n     /// short read.\n+    ///\n+    /// [`File::read`]: ../../../../std/fs/struct.File.html#method.read\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::prelude::FileExt;\n+    /// use std::fs::File;\n+    ///\n+    /// # use std::io;\n+    /// # fn f() -> io::Result<()> {\n+    /// let mut buf = [0u8; 8];\n+    /// let file = File::open(\"foo.txt\")?;\n+    ///\n+    /// // We now read 8 bytes from the offset 10.\n+    /// let num_bytes_read = file.read_at(&mut buf, 10)?;\n+    /// println!(\"read {} bytes: {:?}\", num_bytes_read, buf);\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n     fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;\n \n@@ -51,8 +71,26 @@ pub trait FileExt {\n     /// When writing beyond the end of the file, the file is appropriately\n     /// extended and the intermediate bytes are initialized with the value 0.\n     ///\n-    /// Note that similar to `File::write`, it is not an error to return a\n+    /// Note that similar to [`File::write`], it is not an error to return a\n     /// short write.\n+    ///\n+    /// [`File::write`]: ../../../../std/fs/struct.File.html#write.v\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::prelude::FileExt;\n+    /// use std::fs::File;\n+    ///\n+    /// # use std::io;\n+    /// # fn f() -> io::Result<()> {\n+    /// let file = File::open(\"foo.txt\")?;\n+    ///\n+    /// // We now write at the offset 10.\n+    /// file.write_at(b\"sushi\", 10)?;\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n     fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize>;\n }"}, {"sha": "087ced01d8cda162100aea94c64a4b7793827f4c", "filename": "src/test/compile-fail/borrowck/borrowck-drop-from-guard.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-drop-from-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-drop-from-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-drop-from-guard.rs?ref=965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f", "patch": "@@ -19,6 +19,6 @@ fn main()\n     match Some(42) {\n         Some(_) if { drop(my_str); false } => {}\n         Some(_) => {}\n-        None => { foo(my_str); } //~ ERROR (Mir) [E0381]\n+        None => { foo(my_str); } //~ ERROR (Mir) [E0382]\n     }\n }"}, {"sha": "8f39ae6c04e43818f855f9d25b794c7eae24c482", "filename": "src/test/compile-fail/borrowck/borrowck-uninit-field-access.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs?ref=965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f", "patch": "@@ -39,11 +39,11 @@ fn main() {\n     let _moved = line1.origin;\n     let _ = line1.origin.x + 1; //[ast]~ ERROR use of collaterally moved value: `line1.origin.x`\n                                 //[mir]~^       [E0382]\n-                                //[mir]~| (Mir) [E0381]\n+                                //[mir]~| (Mir) [E0382]\n \n     let mut line2 = Line::default();\n     let _moved = (line2.origin, line2.middle);\n     line2.consume(); //[ast]~ ERROR use of partially moved value: `line2` [E0382]\n                      //[mir]~^       [E0382]\n-                     //[mir]~| (Mir) [E0381]\n+                     //[mir]~| (Mir) [E0382]\n }"}, {"sha": "5547cb3ae523f7bc085d0ec977d47c45f0e21db6", "filename": "src/test/ui/borrowck/borrowck-reinit.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.rs?ref=965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z borrowck-mir -Z emit-end-regions\n+\n+fn main() {\n+    let mut x = Box::new(0);\n+    let _u = x; // error shouldn't note this move\n+    x = Box::new(1);\n+    drop(x);\n+    let _ = (1,x);\n+}"}, {"sha": "767d65c1e60fb07a7d01f00c14bc1f188b3553fe", "filename": "src/test/ui/borrowck/borrowck-reinit.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr?ref=965ace59f28c3ffec3faeb1f8c7cfa5adf69cf0f", "patch": "@@ -0,0 +1,20 @@\n+error[E0382]: use of moved value: `x` (Ast)\n+  --> $DIR/borrowck-reinit.rs:18:16\n+   |\n+17 |     drop(x);\n+   |          - value moved here\n+18 |     let _ = (1,x);\n+   |                ^ value used here after move\n+   |\n+   = note: move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `x` (Mir)\n+  --> $DIR/borrowck-reinit.rs:18:16\n+   |\n+17 |     drop(x);\n+   |          - value moved here\n+18 |     let _ = (1,x);\n+   |                ^ value use here after move\n+\n+error: aborting due to 2 previous errors\n+"}]}