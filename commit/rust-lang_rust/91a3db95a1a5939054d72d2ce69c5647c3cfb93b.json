{"sha": "91a3db95a1a5939054d72d2ce69c5647c3cfb93b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYTNkYjk1YTFhNTkzOTA1NGQ3MmQyY2U2OWM1NjQ3YzNjZmI5M2I=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-08-29T23:06:44Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-16T18:57:02Z"}, "message": "Add check for overlapping ranges to unreachable patterns lint", "tree": {"sha": "fca2bc2afc60849bcce0989184d8498bd1af9a07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fca2bc2afc60849bcce0989184d8498bd1af9a07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91a3db95a1a5939054d72d2ce69c5647c3cfb93b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91a3db95a1a5939054d72d2ce69c5647c3cfb93b", "html_url": "https://github.com/rust-lang/rust/commit/91a3db95a1a5939054d72d2ce69c5647c3cfb93b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "237d54ff6c4fb3577e02d4c5af02813c11b63d01", "url": "https://api.github.com/repos/rust-lang/rust/commits/237d54ff6c4fb3577e02d4c5af02813c11b63d01", "html_url": "https://github.com/rust-lang/rust/commit/237d54ff6c4fb3577e02d4c5af02813c11b63d01"}], "stats": {"total": 443, "additions": 325, "deletions": 118}, "files": [{"sha": "0492fbd55faf23fe47e5573218d42559dc31f2de", "filename": "src/libcore/ascii.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=91a3db95a1a5939054d72d2ce69c5647c3cfb93b", "patch": "@@ -100,6 +100,8 @@ pub fn escape_default(c: u8) -> EscapeDefault {\n         b'\\\\' => ([b'\\\\', b'\\\\', 0, 0], 2),\n         b'\\'' => ([b'\\\\', b'\\'', 0, 0], 2),\n         b'\"' => ([b'\\\\', b'\"', 0, 0], 2),\n+        // The three arms above are in the following range\n+        #[allow(unreachable_patterns)]\n         b'\\x20' ..= b'\\x7e' => ([c, 0, 0, 0], 1),\n         _ => ([b'\\\\', b'x', hexify(c >> 4), hexify(c & 0xf)], 4),\n     };"}, {"sha": "542f0ba5c9ca16e780b4f8eb430de430598b47ed", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 170, "deletions": 60, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=91a3db95a1a5939054d72d2ce69c5647c3cfb93b", "patch": "@@ -167,13 +167,14 @@ use super::{FieldPat, Pat, PatKind, PatRange};\n use super::{PatternFoldable, PatternFolder, compare_const_vals};\n \n use rustc::hir::def_id::DefId;\n-use rustc::hir::RangeEnd;\n+use rustc::hir::{RangeEnd, HirId};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Const};\n use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n \n use rustc::mir::Field;\n use rustc::mir::interpret::{ConstValue, Scalar, truncate, AllocId, Pointer};\n use rustc::util::common::ErrorReported;\n+use rustc::lint;\n \n use syntax::attr::{SignedInt, UnsignedInt};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -418,21 +419,38 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq)]\n+#[derive(Clone, Debug)]\n enum Constructor<'tcx> {\n     /// The constructor of all patterns that don't vary by constructor,\n     /// e.g., struct patterns and fixed-length arrays.\n     Single,\n     /// Enum variants.\n     Variant(DefId),\n     /// Literal values.\n-    ConstantValue(&'tcx ty::Const<'tcx>),\n+    ConstantValue(&'tcx ty::Const<'tcx>, Span),\n     /// Ranges of literal values (`2..=5` and `2..5`).\n-    ConstantRange(u128, u128, Ty<'tcx>, RangeEnd),\n+    ConstantRange(u128, u128, Ty<'tcx>, RangeEnd, Span),\n     /// Array patterns of length n.\n     Slice(u64),\n }\n \n+// Ignore spans when comparing, they don't carry semantic information as they are only for lints.\n+impl<'tcx> std::cmp::PartialEq for Constructor<'tcx> {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (Constructor::Single, Constructor::Single) => true,\n+            (Constructor::Variant(a), Constructor::Variant(b)) => a == b,\n+            (Constructor::ConstantValue(a, _), Constructor::ConstantValue(b, _)) => a == b,\n+            (\n+                Constructor::ConstantRange(a_start, a_end, a_ty, a_range_end, _),\n+                Constructor::ConstantRange(b_start, b_end, b_ty, b_range_end, _),\n+            ) => a_start == b_start && a_end == b_end && a_ty == b_ty && a_range_end == b_range_end,\n+            (Constructor::Slice(a), Constructor::Slice(b)) => a == b,\n+            _ => false,\n+        }\n+    }\n+}\n+\n impl<'tcx> Constructor<'tcx> {\n     fn is_slice(&self) -> bool {\n         match self {\n@@ -447,15 +465,36 @@ impl<'tcx> Constructor<'tcx> {\n         adt: &'tcx ty::AdtDef,\n     ) -> VariantIdx {\n         match self {\n-            &Variant(id) => adt.variant_index_with_id(id),\n-            &Single => {\n+            Variant(id) => adt.variant_index_with_id(*id),\n+            Single => {\n                 assert!(!adt.is_enum());\n                 VariantIdx::new(0)\n             }\n-            &ConstantValue(c) => crate::const_eval::const_variant_index(cx.tcx, cx.param_env, c),\n+            ConstantValue(c, _) => crate::const_eval::const_variant_index(cx.tcx, cx.param_env, c),\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt)\n         }\n     }\n+\n+    fn display(&self, tcx: TyCtxt<'tcx>) -> String {\n+        match self {\n+            Constructor::ConstantValue(val, _) => format!(\"{}\", val),\n+            Constructor::ConstantRange(lo, hi, ty, range_end, _) => {\n+                // Get the right sign on the output:\n+                let ty = ty::ParamEnv::empty().and(*ty);\n+                format!(\n+                    \"{}..{}{}\",\n+                    ty::Const::from_bits(tcx, *lo, ty),\n+                    match range_end {\n+                        RangeEnd::Included => \"=\",\n+                        RangeEnd::Excluded => \"\",\n+                    },\n+                    ty::Const::from_bits(tcx, *hi, ty),\n+                )\n+            }\n+            Constructor::Slice(val) => format!(\"[{}]\", val),\n+            _ => bug!(\"bad constructor being displayed: `{:?}\", self),\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]\n@@ -484,6 +523,7 @@ pub enum WitnessPreference {\n struct PatCtxt<'tcx> {\n     ty: Ty<'tcx>,\n     max_slice_length: u64,\n+    span: Span,\n }\n \n /// A witness of non-exhaustiveness for error reporting, represented\n@@ -610,8 +650,8 @@ impl<'tcx> Witness<'tcx> {\n \n                 _ => {\n                     match *ctor {\n-                        ConstantValue(value) => PatKind::Constant { value },\n-                        ConstantRange(lo, hi, ty, end) => PatKind::Range(PatRange {\n+                        ConstantValue(value, _) => PatKind::Constant { value },\n+                        ConstantRange(lo, hi, ty, end, _) => PatKind::Range(PatRange {\n                             lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n                             hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n                             end,\n@@ -647,7 +687,7 @@ fn all_constructors<'a, 'tcx>(\n     let ctors = match pcx.ty.kind {\n         ty::Bool => {\n             [true, false].iter().map(|&b| {\n-                ConstantValue(ty::Const::from_bool(cx.tcx, b))\n+                ConstantValue(ty::Const::from_bool(cx.tcx, b), pcx.span)\n             }).collect()\n         }\n         ty::Array(ref sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n@@ -679,28 +719,32 @@ fn all_constructors<'a, 'tcx>(\n         ty::Char => {\n             vec![\n                 // The valid Unicode Scalar Value ranges.\n-                ConstantRange('\\u{0000}' as u128,\n-                              '\\u{D7FF}' as u128,\n-                              cx.tcx.types.char,\n-                              RangeEnd::Included\n+                ConstantRange(\n+                    '\\u{0000}' as u128,\n+                    '\\u{D7FF}' as u128,\n+                    cx.tcx.types.char,\n+                    RangeEnd::Included,\n+                    pcx.span,\n                 ),\n-                ConstantRange('\\u{E000}' as u128,\n-                              '\\u{10FFFF}' as u128,\n-                              cx.tcx.types.char,\n-                              RangeEnd::Included\n+                ConstantRange(\n+                    '\\u{E000}' as u128,\n+                    '\\u{10FFFF}' as u128,\n+                    cx.tcx.types.char,\n+                    RangeEnd::Included,\n+                    pcx.span,\n                 ),\n             ]\n         }\n         ty::Int(ity) => {\n             let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n             let max = min - 1;\n-            vec![ConstantRange(min, max, pcx.ty, RangeEnd::Included)]\n+            vec![ConstantRange(min, max, pcx.ty, RangeEnd::Included, pcx.span)]\n         }\n         ty::Uint(uty) => {\n             let size = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size();\n             let max = truncate(u128::max_value(), size);\n-            vec![ConstantRange(0, max, pcx.ty, RangeEnd::Included)]\n+            vec![ConstantRange(0, max, pcx.ty, RangeEnd::Included, pcx.span)]\n         }\n         _ => {\n             if cx.is_uninhabited(pcx.ty) {\n@@ -827,10 +871,11 @@ where\n ///\n /// `IntRange` is never used to encode an empty range or a \"range\" that wraps\n /// around the (offset) space: i.e., `range.lo <= range.hi`.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n struct IntRange<'tcx> {\n     pub range: RangeInclusive<u128>,\n     pub ty: Ty<'tcx>,\n+    pub span: Span,\n }\n \n impl<'tcx> IntRange<'tcx> {\n@@ -860,6 +905,7 @@ impl<'tcx> IntRange<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &Const<'tcx>,\n+        span: Span,\n     ) -> Option<IntRange<'tcx>> {\n         if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, value.ty) {\n             let ty = value.ty;\n@@ -877,7 +923,7 @@ impl<'tcx> IntRange<'tcx> {\n                 return None\n             };\n             let val = val ^ bias;\n-            Some(IntRange { range: val..=val, ty })\n+            Some(IntRange { range: val..=val, ty, span })\n         } else {\n             None\n         }\n@@ -890,6 +936,7 @@ impl<'tcx> IntRange<'tcx> {\n         hi: u128,\n         ty: Ty<'tcx>,\n         end: &RangeEnd,\n+        span: Span,\n     ) -> Option<IntRange<'tcx>> {\n         if Self::is_integral(ty) {\n             // Perform a shift if the underlying types are signed,\n@@ -901,7 +948,7 @@ impl<'tcx> IntRange<'tcx> {\n                 None\n             } else {\n                 let offset = (*end == RangeEnd::Excluded) as u128;\n-                Some(IntRange { range: lo..=(hi - offset), ty })\n+                Some(IntRange { range: lo..=(hi - offset), ty, span })\n             }\n         } else {\n             None\n@@ -916,8 +963,8 @@ impl<'tcx> IntRange<'tcx> {\n         // Floating-point ranges are permitted and we don't want\n         // to consider them when constructing integer ranges.\n         match ctor {\n-            ConstantRange(lo, hi, ty, end) => Self::from_range(tcx, *lo, *hi, ty, end),\n-            ConstantValue(val) => Self::from_const(tcx, param_env, val),\n+            ConstantRange(lo, hi, ty, end, span) => Self::from_range(tcx, *lo, *hi, ty, end, *span),\n+            ConstantValue(val, span) => Self::from_const(tcx, param_env, val, *span),\n             _ => None,\n         }\n     }\n@@ -930,7 +977,7 @@ impl<'tcx> IntRange<'tcx> {\n         loop {\n             match pat.kind {\n                 box PatKind::Constant { value } => {\n-                    return Self::from_const(tcx, param_env, value);\n+                    return Self::from_const(tcx, param_env, value, pat.span);\n                 }\n                 box PatKind::Range(PatRange { lo, hi, end }) => {\n                     return Self::from_range(\n@@ -939,6 +986,7 @@ impl<'tcx> IntRange<'tcx> {\n                         hi.eval_bits(tcx, param_env, hi.ty),\n                         &lo.ty,\n                         &end,\n+                        pat.span,\n                     );\n                 }\n                 box PatKind::AscribeUserType { ref subpattern, .. } => {\n@@ -965,14 +1013,15 @@ impl<'tcx> IntRange<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         ty: Ty<'tcx>,\n         r: RangeInclusive<u128>,\n+        span: Span,\n     ) -> Constructor<'tcx> {\n         let bias = IntRange::signed_bias(tcx, ty);\n         let (lo, hi) = r.into_inner();\n         if lo == hi {\n             let ty = ty::ParamEnv::empty().and(ty);\n-            ConstantValue(ty::Const::from_bits(tcx, lo ^ bias, ty))\n+            ConstantValue(ty::Const::from_bits(tcx, lo ^ bias, ty), span)\n         } else {\n-            ConstantRange(lo ^ bias, hi ^ bias, ty, RangeEnd::Included)\n+            ConstantRange(lo ^ bias, hi ^ bias, ty, RangeEnd::Included, span)\n         }\n     }\n \n@@ -995,17 +1044,23 @@ impl<'tcx> IntRange<'tcx> {\n             if lo > subrange_hi || subrange_lo > hi  {\n                 // The pattern doesn't intersect with the subrange at all,\n                 // so the subrange remains untouched.\n-                remaining_ranges.push(Self::range_to_ctor(tcx, ty, subrange_lo..=subrange_hi));\n+                remaining_ranges.push(\n+                    Self::range_to_ctor(tcx, ty, subrange_lo..=subrange_hi, self.span),\n+                );\n             } else {\n                 if lo > subrange_lo {\n                     // The pattern intersects an upper section of the\n                     // subrange, so a lower section will remain.\n-                    remaining_ranges.push(Self::range_to_ctor(tcx, ty, subrange_lo..=(lo - 1)));\n+                    remaining_ranges.push(\n+                        Self::range_to_ctor(tcx, ty, subrange_lo..=(lo - 1), self.span),\n+                    );\n                 }\n                 if hi < subrange_hi {\n                     // The pattern intersects a lower section of the\n                     // subrange, so an upper section will remain.\n-                    remaining_ranges.push(Self::range_to_ctor(tcx, ty, (hi + 1)..=subrange_hi));\n+                    remaining_ranges.push(\n+                        Self::range_to_ctor(tcx, ty, (hi + 1)..=subrange_hi, self.span),\n+                    );\n                 }\n             }\n         }\n@@ -1017,7 +1072,8 @@ impl<'tcx> IntRange<'tcx> {\n         let (lo, hi) = (*self.range.start(), *self.range.end());\n         let (other_lo, other_hi) = (*other.range.start(), *other.range.end());\n         if lo <= other_hi && other_lo <= hi {\n-            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi), ty })\n+            let span = other.span;\n+            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi), ty, span })\n         } else {\n             None\n         }\n@@ -1127,6 +1183,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n     matrix: &Matrix<'p, 'tcx>,\n     v: &[&Pat<'tcx>],\n     witness: WitnessPreference,\n+    hir_id: HirId,\n ) -> Usefulness<'tcx> {\n     let &Matrix(ref rows) = matrix;\n     debug!(\"is_useful({:#?}, {:#?})\", matrix, v);\n@@ -1149,6 +1206,10 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n+    let (ty, span) = rows.iter()\n+        .map(|r| (r[0].ty, r[0].span))\n+        .find(|(ty, _)| !ty.references_error())\n+        .unwrap_or((v[0].ty, v[0].span));\n     let pcx = PatCtxt {\n         // TyErr is used to represent the type of wildcard patterns matching\n         // against inaccessible (private) fields of structs, so that we won't\n@@ -1169,8 +1230,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // FIXME: this might lead to \"unstable\" behavior with macro hygiene\n         // introducing uninhabited patterns for inaccessible fields. We\n         // need to figure out how to model that.\n-        ty: rows.iter().map(|r| r[0].ty).find(|ty| !ty.references_error()).unwrap_or(v[0].ty),\n-        max_slice_length: max_slice_length(cx, rows.iter().map(|r| r[0]).chain(Some(v[0])))\n+        ty,\n+        max_slice_length: max_slice_length(cx, rows.iter().map(|r| r[0]).chain(Some(v[0]))),\n+        span,\n     };\n \n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v[0]);\n@@ -1184,9 +1246,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n             Useful\n         } else {\n             split_grouped_constructors(\n-                cx.tcx, cx.param_env, constructors, matrix, pcx.ty,\n+                cx.tcx, cx.param_env, constructors, matrix, pcx.ty, pcx.span, Some(hir_id),\n             ).into_iter().map(|c|\n-                is_useful_specialized(cx, matrix, v, c, pcx.ty, witness)\n+                is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id)\n             ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n         }\n     } else {\n@@ -1239,8 +1301,11 @@ pub fn is_useful<'p, 'a, 'tcx>(\n             (pcx.ty.is_ptr_sized_integral() && !cx.tcx.features().precise_pointer_size_matching);\n \n         if cheap_missing_ctors == MissingCtors::Empty && !is_non_exhaustive {\n-            split_grouped_constructors(cx.tcx, cx.param_env, all_ctors, matrix, pcx.ty)\n-                .into_iter().map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness))\n+            split_grouped_constructors(\n+                cx.tcx, cx.param_env, all_ctors, matrix, pcx.ty, DUMMY_SP, None,\n+            )\n+                .into_iter()\n+                .map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id))\n                 .find(|result| result.is_useful())\n                 .unwrap_or(NotUseful)\n         } else {\n@@ -1251,7 +1316,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n                     None\n                 }\n             }).collect();\n-            match is_useful(cx, &matrix, &v[1..], witness) {\n+            match is_useful(cx, &matrix, &v[1..], witness, hir_id) {\n                 UsefulWithWitness(pats) => {\n                     let cx = &*cx;\n                     // In this case, there's at least one \"free\"\n@@ -1344,6 +1409,7 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n     ctor: Constructor<'tcx>,\n     lty: Ty<'tcx>,\n     witness: WitnessPreference,\n+    hir_id: HirId,\n ) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n     let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n@@ -1361,7 +1427,7 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n             .collect()\n     );\n     match specialize(cx, v, &ctor, &wild_patterns) {\n-        Some(v) => match is_useful(cx, &matrix, &v, witness) {\n+        Some(v) => match is_useful(cx, &matrix, &v, witness, hir_id) {\n             UsefulWithWitness(witnesses) => UsefulWithWitness(\n                 witnesses.into_iter()\n                     .map(|witness| witness.apply_constructor(cx, &ctor, lty))\n@@ -1381,11 +1447,11 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n /// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n ///\n /// Returns `None` in case of a catch-all, which can't be specialized.\n-fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n-                          pat: &Pat<'tcx>,\n-                          pcx: PatCtxt<'tcx>)\n-                          -> Option<Vec<Constructor<'tcx>>>\n-{\n+fn pat_constructors<'tcx>(\n+    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n+    pat: &Pat<'tcx>,\n+    pcx: PatCtxt<'tcx>,\n+) -> Option<Vec<Constructor<'tcx>>> {\n     match *pat.kind {\n         PatKind::AscribeUserType { ref subpattern, .. } =>\n             pat_constructors(cx, subpattern, pcx),\n@@ -1394,13 +1460,14 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n         PatKind::Variant { adt_def, variant_index, .. } => {\n             Some(vec![Variant(adt_def.variants[variant_index].def_id)])\n         }\n-        PatKind::Constant { value } => Some(vec![ConstantValue(value)]),\n+        PatKind::Constant { value } => Some(vec![ConstantValue(value, pat.span)]),\n         PatKind::Range(PatRange { lo, hi, end }) =>\n             Some(vec![ConstantRange(\n                 lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n                 hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n                 lo.ty,\n                 end,\n+                pat.span,\n             )]),\n         PatKind::Array { .. } => match pcx.ty.kind {\n             ty::Array(_, length) => Some(vec![\n@@ -1433,7 +1500,7 @@ fn constructor_arity(cx: &MatchCheckCtxt<'a, 'tcx>, ctor: &Constructor<'tcx>, ty\n         ty::Tuple(ref fs) => fs.len() as u64,\n         ty::Slice(..) | ty::Array(..) => match *ctor {\n             Slice(length) => length,\n-            ConstantValue(_) => 0,\n+            ConstantValue(..) => 0,\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         }\n         ty::Ref(..) => 1,\n@@ -1458,7 +1525,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx>(\n         ty::Tuple(ref fs) => fs.into_iter().map(|t| t.expect_ty()).collect(),\n         ty::Slice(ty) | ty::Array(ty, _) => match *ctor {\n             Slice(length) => (0..length).map(|_| ty).collect(),\n-            ConstantValue(_) => vec![],\n+            ConstantValue(..) => vec![],\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         }\n         ty::Ref(_, rty, _) => vec![rty],\n@@ -1556,8 +1623,8 @@ fn slice_pat_covered_by_const<'tcx>(\n // constructor is a range or constant with an integer type.\n fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>) -> bool {\n     let ty = match ctor {\n-        ConstantValue(value) => value.ty,\n-        ConstantRange(_, _, ty, _) => ty,\n+        ConstantValue(value, _) => value.ty,\n+        ConstantRange(_, _, ty, _, _) => ty,\n         _ => return false,\n     };\n     if let ty::Char | ty::Int(_) | ty::Uint(_) = ty.kind {\n@@ -1599,12 +1666,17 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>)\n /// boundaries for each interval range, sort them, then create constructors for each new interval\n /// between every pair of boundary points. (This essentially sums up to performing the intuitive\n /// merging operation depicted above.)\n+///\n+/// `hir_id` is `None` when we're evaluating the wildcard pattern, do not lint for overlapping in\n+/// ranges that case.\n fn split_grouped_constructors<'p, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ctors: Vec<Constructor<'tcx>>,\n     &Matrix(ref m): &Matrix<'p, 'tcx>,\n     ty: Ty<'tcx>,\n+    span: Span,\n+    hir_id: Option<HirId>,\n ) -> Vec<Constructor<'tcx>> {\n     let mut split_ctors = Vec::with_capacity(ctors.len());\n \n@@ -1621,7 +1693,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 /// Represents a border between 2 integers. Because the intervals spanning borders\n                 /// must be able to cover every integer, we need to be able to represent\n                 /// 2^128 + 1 such borders.\n-                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n                 enum Border {\n                     JustBefore(u128),\n                     AfterMax,\n@@ -1638,35 +1710,73 @@ fn split_grouped_constructors<'p, 'tcx>(\n                     vec![from, to].into_iter()\n                 }\n \n+                // Collect the span and range of all the intersecting ranges to lint on likely\n+                // incorrect range patterns. (#63987)\n+                let mut overlaps = vec![];\n                 // `borders` is the set of borders between equivalence classes: each equivalence\n                 // class lies between 2 borders.\n                 let row_borders = m.iter()\n-                    .flat_map(|row| IntRange::from_pat(tcx, param_env, row[0]))\n-                    .flat_map(|range| ctor_range.intersection(&range))\n+                    .flat_map(|row| {\n+                        IntRange::from_pat(tcx, param_env, row[0]).map(|r| (r, row.len()))\n+                    })\n+                    .flat_map(|(range, row_len)| {\n+                        let intersection = ctor_range.intersection(&range);\n+                        if let (Some(range), 1) = (&intersection, row_len) {\n+                            // FIXME: for now, only check for overlapping ranges on simple range\n+                            // patterns. Otherwise with the current logic the following is detected\n+                            // as overlapping:\n+                            //   match (10u8, true) {\n+                            //    (0 ..= 125, false) => {}\n+                            //    (126 ..= 255, false) => {}\n+                            //    (0 ..= 255, true) => {}\n+                            //  }\n+                            overlaps.push(range.clone());\n+                        }\n+                        intersection\n+                    })\n                     .flat_map(|range| range_borders(range));\n                 let ctor_borders = range_borders(ctor_range.clone());\n                 let mut borders: Vec<_> = row_borders.chain(ctor_borders).collect();\n                 borders.sort_unstable();\n \n+                if let (true, Some(hir_id)) = (!overlaps.is_empty(), hir_id) {\n+                    let mut err = tcx.struct_span_lint_hir(\n+                        lint::builtin::UNREACHABLE_PATTERNS,\n+                        hir_id,\n+                        ctor_range.span,\n+                        \"multiple patterns covering the same range\",\n+                    );\n+                    err.span_label(ctor_range.span, \"overlapping patterns\");\n+                    for int_range in overlaps {\n+                        // Use the real type for user display of the ranges:\n+                        err.span_label(int_range.span, &format!(\n+                            \"this range overlaps on `{}`\",\n+                            IntRange::range_to_ctor(tcx, ty, int_range.range, DUMMY_SP)\n+                                .display(tcx),\n+                        ));\n+                    }\n+                    err.emit();\n+                }\n+\n                 // We're going to iterate through every pair of borders, making sure that each\n                 // represents an interval of nonnegative length, and convert each such interval\n                 // into a constructor.\n                 for IntRange { range, .. } in borders.windows(2).filter_map(|window| {\n                     match (window[0], window[1]) {\n                         (Border::JustBefore(n), Border::JustBefore(m)) => {\n                             if n < m {\n-                                Some(IntRange { range: n..=(m - 1), ty })\n+                                Some(IntRange { range: n..=(m - 1), ty, span })\n                             } else {\n                                 None\n                             }\n                         }\n                         (Border::JustBefore(n), Border::AfterMax) => {\n-                            Some(IntRange { range: n..=u128::MAX, ty })\n+                            Some(IntRange { range: n..=u128::MAX, ty, span })\n                         }\n                         (Border::AfterMax, _) => None,\n                     }\n                 }) {\n-                    split_ctors.push(IntRange::range_to_ctor(tcx, ty, range));\n+                    split_ctors.push(IntRange::range_to_ctor(tcx, ty, range, span));\n                 }\n             }\n             // Any other constructor can be used unchanged.\n@@ -1701,13 +1811,13 @@ fn constructor_covered_by_range<'tcx>(\n         };\n     }\n     match *ctor {\n-        ConstantValue(value) => {\n+        ConstantValue(value, _) => {\n             let to = some_or_ok!(cmp_to(value));\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n             Ok(some_or_ok!(cmp_from(value)) && end)\n         },\n-        ConstantRange(from, to, ty, RangeEnd::Included) => {\n+        ConstantRange(from, to, ty, RangeEnd::Included, _) => {\n             let to = some_or_ok!(cmp_to(ty::Const::from_bits(\n                 tcx,\n                 to,\n@@ -1721,7 +1831,7 @@ fn constructor_covered_by_range<'tcx>(\n                 ty::ParamEnv::empty().and(ty),\n             ))) && end)\n         },\n-        ConstantRange(from, to, ty, RangeEnd::Excluded) => {\n+        ConstantRange(from, to, ty, RangeEnd::Excluded, _) => {\n             let to = some_or_ok!(cmp_to(ty::Const::from_bits(\n                 tcx,\n                 to,\n@@ -1915,7 +2025,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                         None\n                     }\n                 }\n-                ConstantValue(cv) => {\n+                ConstantValue(cv, _) => {\n                     match slice_pat_covered_by_const(\n                         cx.tcx, pat.span, cv, prefix, slice, suffix, cx.param_env,\n                     ) {"}, {"sha": "fe57e12bcfcc8b37543b59ea75ac785afd380b3b", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=91a3db95a1a5939054d72d2ce69c5647c3cfb93b", "patch": "@@ -10,6 +10,7 @@ use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::lint;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n \n+use rustc::hir::HirId;\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -239,7 +240,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 .map(|pat| smallvec![pat.0])\n                 .collect();\n             let scrut_ty = self.tables.node_type(scrut.hir_id);\n-            check_exhaustive(cx, scrut_ty, scrut.span, &matrix);\n+            check_exhaustive(cx, scrut_ty, scrut.span, &matrix, scrut.hir_id);\n         })\n     }\n \n@@ -256,7 +257,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 expand_pattern(cx, pattern)\n             ]].into_iter().collect();\n \n-            let witnesses = match check_not_useful(cx, pattern_ty, &pats) {\n+            let witnesses = match check_not_useful(cx, pattern_ty, &pats, pat.hir_id) {\n                 Ok(_) => return,\n                 Err(err) => err,\n             };\n@@ -389,7 +390,7 @@ fn check_arms<'tcx>(\n         for &(pat, hir_pat) in pats {\n             let v = smallvec![pat];\n \n-            match is_useful(cx, &seen, &v, LeaveOutWitness) {\n+            match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id) {\n                 NotUseful => {\n                     match source {\n                         hir::MatchSource::IfDesugar { .. } |\n@@ -428,6 +429,13 @@ fn check_arms<'tcx>(\n \n                         hir::MatchSource::ForLoopDesugar |\n                         hir::MatchSource::Normal => {\n+                            match pat.kind {\n+                                box PatternKind::Range(..) => {\n+                                    // Covered in `is_useful() with more context`\n+                                    break;\n+                                }\n+                                _ => {}\n+                            }\n                             let mut err = cx.tcx.struct_span_lint_hir(\n                                 lint::builtin::UNREACHABLE_PATTERNS,\n                                 hir_pat.hir_id,\n@@ -465,9 +473,10 @@ fn check_not_useful(\n     cx: &mut MatchCheckCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n     matrix: &Matrix<'_, 'tcx>,\n+    hir_id: HirId,\n ) -> Result<(), Vec<super::Pat<'tcx>>> {\n     let wild_pattern = super::Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild };\n-    match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness) {\n+    match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness, hir_id) {\n         NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n         UsefulWithWitness(pats) => Err(if pats.is_empty() {\n             vec![wild_pattern]\n@@ -483,8 +492,9 @@ fn check_exhaustive<'tcx>(\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n     matrix: &Matrix<'_, 'tcx>,\n+    hir_id: HirId,\n ) {\n-    let witnesses = match check_not_useful(cx, scrut_ty, matrix) {\n+    let witnesses = match check_not_useful(cx, scrut_ty, matrix, hir_id) {\n         Ok(_) => return,\n         Err(err) => err,\n     };"}, {"sha": "548300da034052ca04f89d20dc88b4b9a116a4fd", "filename": "src/test/ui/check_match/issue-43253.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.rs?ref=91a3db95a1a5939054d72d2ce69c5647c3cfb93b", "patch": "@@ -1,4 +1,4 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n \n #![feature(exclusive_range_pattern)]\n #![warn(unreachable_patterns)]\n@@ -13,7 +13,7 @@ fn main() {\n \n     match 10 {\n         1..10 => {},\n-        9..=10 => {},\n+        9..=10 => {}, //~ WARNING multiple patterns covering the same range\n         _ => {},\n     }\n \n@@ -23,22 +23,25 @@ fn main() {\n         _ => {},\n     }\n \n-    // These cases should generate an \"unreachable pattern\" warning.\n+    // These cases should generate \"unreachable pattern\" warnings.\n     match 10 {\n         1..10 => {},\n-        9 => {},\n+        9 => {}, //~ WARNING unreachable pattern\n         _ => {},\n     }\n \n     match 10 {\n         1..10 => {},\n-        8..=9 => {},\n+        8..=9 => {}, //~ WARNING multiple patterns covering the same range\n         _ => {},\n     }\n \n     match 10 {\n-        1..10 => {},\n-        9..=9 => {},\n+        5..7 => {},\n+        6 => {}, //~ WARNING unreachable pattern\n+        1..10 => {}, //~ WARNING multiple patterns covering the same range\n+        9..=9 => {}, //~ WARNING unreachable pattern\n+        6 => {}, //~ WARNING unreachable pattern\n         _ => {},\n     }\n }"}, {"sha": "24dfa52beb6873a80c6831b4b9b8f9dd213d0ece", "filename": "src/test/ui/check_match/issue-43253.stderr", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.stderr?ref=91a3db95a1a5939054d72d2ce69c5647c3cfb93b", "patch": "@@ -1,8 +1,10 @@\n-warning: unreachable pattern\n-  --> $DIR/issue-43253.rs:29:9\n+warning: multiple patterns covering the same range\n+  --> $DIR/issue-43253.rs:16:9\n    |\n-LL |         9 => {},\n-   |         ^\n+LL |         1..10 => {},\n+   |         ----- this range overlaps on `9i32`\n+LL |         9..=10 => {},\n+   |         ^^^^^^ overlapping patterns\n    |\n note: lint level defined here\n   --> $DIR/issue-43253.rs:4:9\n@@ -11,14 +13,44 @@ LL | #![warn(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n warning: unreachable pattern\n+  --> $DIR/issue-43253.rs:29:9\n+   |\n+LL |         9 => {},\n+   |         ^\n+\n+warning: multiple patterns covering the same range\n   --> $DIR/issue-43253.rs:35:9\n    |\n+LL |         1..10 => {},\n+   |         ----- this range overlaps on `8i32..=9i32`\n LL |         8..=9 => {},\n-   |         ^^^^^\n+   |         ^^^^^ overlapping patterns\n \n warning: unreachable pattern\n   --> $DIR/issue-43253.rs:41:9\n    |\n+LL |         6 => {},\n+   |         ^\n+\n+warning: multiple patterns covering the same range\n+  --> $DIR/issue-43253.rs:42:9\n+   |\n+LL |         5..7 => {},\n+   |         ---- this range overlaps on `5i32..=6i32`\n+LL |         6 => {},\n+   |         - this range overlaps on `6i32`\n+LL |         1..10 => {},\n+   |         ^^^^^ overlapping patterns\n+\n+warning: unreachable pattern\n+  --> $DIR/issue-43253.rs:43:9\n+   |\n LL |         9..=9 => {},\n    |         ^^^^^\n \n+warning: unreachable pattern\n+  --> $DIR/issue-43253.rs:44:9\n+   |\n+LL |         6 => {},\n+   |         ^\n+"}, {"sha": "ce2b44b8ef167a46598e5d61d77afe00e577fe2a", "filename": "src/test/ui/exhaustive_integer_patterns.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs?ref=91a3db95a1a5939054d72d2ce69c5647c3cfb93b", "patch": "@@ -19,7 +19,7 @@ fn main() {\n         0 ..= 32 => {}\n         33 => {}\n         34 .. 128 => {}\n-        100 ..= 200 => {}\n+        100 ..= 200 => {} //~ ERROR multiple patterns covering the same range\n         200 => {} //~ ERROR unreachable pattern\n         201 ..= 255 => {}\n     }\n@@ -41,7 +41,7 @@ fn main() {\n     match x { //~ ERROR non-exhaustive patterns\n         -7 => {}\n         -5..=120 => {}\n-        -2..=20 => {} //~ ERROR unreachable pattern\n+        -2..=20 => {} //~ ERROR multiple patterns covering the same range\n         125 => {}\n     }\n \n@@ -135,9 +135,9 @@ fn main() {\n         (125 .. 128, false) => {}\n     }\n \n-    match 0u8 { // ok\n+    match 0u8 {\n         0 .. 2 => {}\n-        1 ..= 2 => {}\n+        1 ..= 2 => {} //~ ERROR multiple patterns covering the same range\n         _ => {}\n     }\n "}, {"sha": "ef3faceaa7e10ad5752e4a839fb0ef7bfb50f3a4", "filename": "src/test/ui/exhaustive_integer_patterns.stderr", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr?ref=91a3db95a1a5939054d72d2ce69c5647c3cfb93b", "patch": "@@ -1,15 +1,23 @@\n-error: unreachable pattern\n-  --> $DIR/exhaustive_integer_patterns.rs:23:9\n+error: multiple patterns covering the same range\n+  --> $DIR/exhaustive_integer_patterns.rs:22:9\n    |\n-LL |         200 => {}\n-   |         ^^^\n+LL |         34 .. 128 => {}\n+   |         --------- this range overlaps on `100u8..=127u8`\n+LL |         100 ..= 200 => {}\n+   |         ^^^^^^^^^^^ overlapping patterns\n    |\n note: lint level defined here\n   --> $DIR/exhaustive_integer_patterns.rs:4:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n+error: unreachable pattern\n+  --> $DIR/exhaustive_integer_patterns.rs:23:9\n+   |\n+LL |         200 => {}\n+   |         ^^^\n+\n error[E0004]: non-exhaustive patterns: `128u8..=std::u8::MAX` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:28:11\n    |\n@@ -26,11 +34,13 @@ LL |     match x {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error: unreachable pattern\n+error: multiple patterns covering the same range\n   --> $DIR/exhaustive_integer_patterns.rs:44:9\n    |\n+LL |         -5..=120 => {}\n+   |         -------- this range overlaps on `-2i8..=20i8`\n LL |         -2..=20 => {}\n-   |         ^^^^^^^\n+   |         ^^^^^^^ overlapping patterns\n \n error[E0004]: non-exhaustive patterns: `std::i8::MIN..=-8i8`, `-6i8`, `121i8..=124i8` and 1 more not covered\n   --> $DIR/exhaustive_integer_patterns.rs:41:11\n@@ -80,6 +90,14 @@ LL |     match (0u8, true) {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n+error: multiple patterns covering the same range\n+  --> $DIR/exhaustive_integer_patterns.rs:140:9\n+   |\n+LL |         0 .. 2 => {}\n+   |         ------ this range overlaps on `1u8`\n+LL |         1 ..= 2 => {}\n+   |         ^^^^^^^ overlapping patterns\n+\n error[E0004]: non-exhaustive patterns: `std::u128::MAX` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:145:11\n    |\n@@ -104,6 +122,6 @@ LL |     match 0u128 {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 15 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}, {"sha": "4c0f57ffbeedd82b170b859593e62ab27fc009ed", "filename": "src/test/ui/match/match-range-fail-dominate.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.rs?ref=91a3db95a1a5939054d72d2ce69c5647c3cfb93b", "patch": "@@ -1,39 +1,41 @@\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-\n #![deny(unreachable_patterns)]\n \n fn main() {\n     match 5 {\n       1 ..= 10 => { }\n-      5 ..= 6 => { }\n+      5 ..= 6 => { } //~ ERROR multiple patterns covering the same range\n       _ => {}\n     };\n \n     match 5 {\n       3 ..= 6 => { }\n-      4 ..= 6 => { }\n+      4 ..= 6 => { } //~ ERROR multiple patterns covering the same range\n       _ => {}\n     };\n \n     match 5 {\n       4 ..= 6 => { }\n-      4 ..= 6 => { }\n+      4 ..= 6 => { } //~ ERROR multiple patterns covering the same range\n       _ => {}\n     };\n \n     match 'c' {\n       'A' ..= 'z' => {}\n-      'a' ..= 'z' => {}\n+      'a' ..= 'z' => {} //~ ERROR multiple patterns covering the same range\n       _ => {}\n     };\n \n     match 1.0f64 {\n       0.01f64 ..= 6.5f64 => {}\n-      0.02f64 => {}\n+      //~^ WARNING floating-point types cannot be used in patterns\n+      //~| WARNING floating-point types cannot be used in patterns\n+      //~| WARNING floating-point types cannot be used in patterns\n+      //~| WARNING this was previously accepted by the compiler\n+      //~| WARNING this was previously accepted by the compiler\n+      //~| WARNING this was previously accepted by the compiler\n+      0.02f64 => {} //~ ERROR unreachable pattern\n+      //~^ WARNING floating-point types cannot be used in patterns\n+      //~| WARNING this was previously accepted by the compiler\n       _ => {}\n     };\n }"}, {"sha": "af667be317de5a2024e452b7db044dce3ce0542d", "filename": "src/test/ui/match/match-range-fail-dominate.stderr", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.stderr?ref=91a3db95a1a5939054d72d2ce69c5647c3cfb93b", "patch": "@@ -1,35 +1,43 @@\n-error: unreachable pattern\n-  --> $DIR/match-range-fail-dominate.rs:12:7\n+error: multiple patterns covering the same range\n+  --> $DIR/match-range-fail-dominate.rs:6:7\n    |\n+LL |       1 ..= 10 => { }\n+   |       -------- this range overlaps on `5i32..=6i32`\n LL |       5 ..= 6 => { }\n-   |       ^^^^^^^\n+   |       ^^^^^^^ overlapping patterns\n    |\n note: lint level defined here\n-  --> $DIR/match-range-fail-dominate.rs:7:9\n+  --> $DIR/match-range-fail-dominate.rs:1:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: unreachable pattern\n-  --> $DIR/match-range-fail-dominate.rs:18:7\n+error: multiple patterns covering the same range\n+  --> $DIR/match-range-fail-dominate.rs:12:7\n    |\n+LL |       3 ..= 6 => { }\n+   |       ------- this range overlaps on `4i32..=6i32`\n LL |       4 ..= 6 => { }\n-   |       ^^^^^^^\n+   |       ^^^^^^^ overlapping patterns\n \n-error: unreachable pattern\n-  --> $DIR/match-range-fail-dominate.rs:24:7\n+error: multiple patterns covering the same range\n+  --> $DIR/match-range-fail-dominate.rs:18:7\n    |\n LL |       4 ..= 6 => { }\n-   |       ^^^^^^^\n+   |       ------- this range overlaps on `4i32..=6i32`\n+LL |       4 ..= 6 => { }\n+   |       ^^^^^^^ overlapping patterns\n \n-error: unreachable pattern\n-  --> $DIR/match-range-fail-dominate.rs:30:7\n+error: multiple patterns covering the same range\n+  --> $DIR/match-range-fail-dominate.rs:24:7\n    |\n+LL |       'A' ..= 'z' => {}\n+   |       ----------- this range overlaps on `'a'..='z'`\n LL |       'a' ..= 'z' => {}\n-   |       ^^^^^^^^^^^\n+   |       ^^^^^^^^^^^ overlapping patterns\n \n warning: floating-point types cannot be used in patterns\n-  --> $DIR/match-range-fail-dominate.rs:35:7\n+  --> $DIR/match-range-fail-dominate.rs:29:7\n    |\n LL |       0.01f64 ..= 6.5f64 => {}\n    |       ^^^^^^^\n@@ -39,7 +47,7 @@ LL |       0.01f64 ..= 6.5f64 => {}\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n warning: floating-point types cannot be used in patterns\n-  --> $DIR/match-range-fail-dominate.rs:35:19\n+  --> $DIR/match-range-fail-dominate.rs:29:19\n    |\n LL |       0.01f64 ..= 6.5f64 => {}\n    |                   ^^^^^^\n@@ -63,7 +71,7 @@ LL |       0.02f64 => {}\n    |       ^^^^^^^\n \n warning: floating-point types cannot be used in patterns\n-  --> $DIR/match-range-fail-dominate.rs:35:7\n+  --> $DIR/match-range-fail-dominate.rs:29:7\n    |\n LL |       0.01f64 ..= 6.5f64 => {}\n    |       ^^^^^^^"}, {"sha": "239197af2ca1dcf6a0dae4cd3eb39cf91e4fc6c1", "filename": "src/test/ui/precise_pointer_size_matching.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.rs?ref=91a3db95a1a5939054d72d2ce69c5647c3cfb93b", "patch": "@@ -23,11 +23,11 @@ fn main() {\n \n     match 0isize { //~ ERROR non-exhaustive patterns\n         1 ..= 8 => {}\n-        -5 ..= 20 => {}\n+        -5 ..= 20 => {} //~ ERROR multiple patterns covering the same range\n     }\n \n     match 0usize { //~ ERROR non-exhaustive patterns\n         1 ..= 8 => {}\n-        5 ..= 20 => {}\n+        5 ..= 20 => {} //~ ERROR multiple patterns covering the same range\n     }\n }"}, {"sha": "06b0e73c5a3b75a92eb106f69b9ee1e422c75508", "filename": "src/test/ui/precise_pointer_size_matching.stderr", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91a3db95a1a5939054d72d2ce69c5647c3cfb93b/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.stderr?ref=91a3db95a1a5939054d72d2ce69c5647c3cfb93b", "patch": "@@ -1,3 +1,17 @@\n+error: multiple patterns covering the same range\n+  --> $DIR/precise_pointer_size_matching.rs:26:9\n+   |\n+LL |         1 ..= 8 => {}\n+   |         ------- this range overlaps on `1isize..=8isize`\n+LL |         -5 ..= 20 => {}\n+   |         ^^^^^^^^^ overlapping patterns\n+   |\n+note: lint level defined here\n+  --> $DIR/precise_pointer_size_matching.rs:11:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n error[E0004]: non-exhaustive patterns: `std::isize::MIN..=-6isize` and `21isize..=std::isize::MAX` not covered\n   --> $DIR/precise_pointer_size_matching.rs:24:11\n    |\n@@ -6,6 +20,14 @@ LL |     match 0isize {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n+error: multiple patterns covering the same range\n+  --> $DIR/precise_pointer_size_matching.rs:31:9\n+   |\n+LL |         1 ..= 8 => {}\n+   |         ------- this range overlaps on `5usize..=8usize`\n+LL |         5 ..= 20 => {}\n+   |         ^^^^^^^^ overlapping patterns\n+\n error[E0004]: non-exhaustive patterns: `0usize` and `21usize..=std::usize::MAX` not covered\n   --> $DIR/precise_pointer_size_matching.rs:29:11\n    |\n@@ -14,6 +36,6 @@ LL |     match 0usize {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}]}