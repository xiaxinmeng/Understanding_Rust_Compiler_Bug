{"sha": "2c2fb3996f8b0db6537a2a9d193af89304cd62ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMmZiMzk5NmY4YjBkYjY1MzdhMmE5ZDE5M2FmODkzMDRjZDYyZWQ=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-02-12T05:00:17Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-08T15:47:30Z"}, "message": "Move vec_box to its own module", "tree": {"sha": "6d7027241be93f896b16a4bc06701946febbe258", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d7027241be93f896b16a4bc06701946febbe258"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c2fb3996f8b0db6537a2a9d193af89304cd62ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c2fb3996f8b0db6537a2a9d193af89304cd62ed", "html_url": "https://github.com/rust-lang/rust/commit/2c2fb3996f8b0db6537a2a9d193af89304cd62ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c2fb3996f8b0db6537a2a9d193af89304cd62ed/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f110c5e6f51eea87e37503819addbd1bd054416a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f110c5e6f51eea87e37503819addbd1bd054416a", "html_url": "https://github.com/rust-lang/rust/commit/f110c5e6f51eea87e37503819addbd1bd054416a"}], "stats": {"total": 106, "additions": 65, "deletions": 41}, "files": [{"sha": "8d866568df938fe12abea793bb2cccfc6cc2b075", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 6, "deletions": 41, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2c2fb3996f8b0db6537a2a9d193af89304cd62ed/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c2fb3996f8b0db6537a2a9d193af89304cd62ed/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=2c2fb3996f8b0db6537a2a9d193af89304cd62ed", "patch": "@@ -4,6 +4,7 @@ mod box_vec;\n mod rc_buffer;\n mod redundant_allocation;\n mod utils;\n+mod vec_box;\n \n use std::borrow::Cow;\n use std::cmp::Ordering;\n@@ -22,7 +23,6 @@ use rustc_hir::{\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, FloatTy, InferTy, IntTy, Ty, TyCtxt, TyS, TypeAndMut, TypeckResults, UintTy};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n@@ -38,8 +38,8 @@ use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n use crate::utils::{\n     clip, comparisons, differing_macro_contexts, higher, in_constant, indent_of, int_bits, is_hir_ty_cfg_dependant,\n-    is_ty_param_diagnostic_item, is_type_diagnostic_item, last_path_segment, match_def_path, match_path, meets_msrv,\n-    method_chain_args, multispan_sugg, numeric_literal::NumericLiteral, reindent_multiline, sext, snippet, snippet_opt,\n+    is_ty_param_diagnostic_item, is_type_diagnostic_item, match_def_path, match_path, meets_msrv, method_chain_args,\n+    multispan_sugg, numeric_literal::NumericLiteral, reindent_multiline, sext, snippet, snippet_opt,\n     snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg,\n     span_lint_and_then, unsext,\n };\n@@ -325,44 +325,9 @@ impl Types {\n                     box_vec::check(cx, hir_ty, qpath, def_id);\n                     redundant_allocation::check(cx, hir_ty, qpath, def_id);\n                     rc_buffer::check(cx, hir_ty, qpath, def_id);\n-                    if cx.tcx.is_diagnostic_item(sym::vec_type, def_id) {\n-                        if_chain! {\n-                            // Get the _ part of Vec<_>\n-                            if let Some(ref last) = last_path_segment(qpath).args;\n-                            if let Some(ty) = last.args.iter().find_map(|arg| match arg {\n-                                GenericArg::Type(ty) => Some(ty),\n-                                _ => None,\n-                            });\n-                            // ty is now _ at this point\n-                            if let TyKind::Path(ref ty_qpath) = ty.kind;\n-                            let res = cx.qpath_res(ty_qpath, ty.hir_id);\n-                            if let Some(def_id) = res.opt_def_id();\n-                            if Some(def_id) == cx.tcx.lang_items().owned_box();\n-                            // At this point, we know ty is Box<T>, now get T\n-                            if let Some(ref last) = last_path_segment(ty_qpath).args;\n-                            if let Some(boxed_ty) = last.args.iter().find_map(|arg| match arg {\n-                                GenericArg::Type(ty) => Some(ty),\n-                                _ => None,\n-                            });\n-                            let ty_ty = hir_ty_to_ty(cx.tcx, boxed_ty);\n-                            if !ty_ty.has_escaping_bound_vars();\n-                            if ty_ty.is_sized(cx.tcx.at(ty.span), cx.param_env);\n-                            if let Ok(ty_ty_size) = cx.layout_of(ty_ty).map(|l| l.size.bytes());\n-                            if ty_ty_size <= self.vec_box_size_threshold;\n-                            then {\n-                                span_lint_and_sugg(\n-                                    cx,\n-                                    VEC_BOX,\n-                                    hir_ty.span,\n-                                    \"`Vec<T>` is already on the heap, the boxing is unnecessary\",\n-                                    \"try\",\n-                                    format!(\"Vec<{}>\", snippet(cx, boxed_ty.span, \"..\")),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                                return; // don't recurse into the type\n-                            }\n-                        }\n-                    } else if cx.tcx.is_diagnostic_item(sym::option_type, def_id) {\n+                    vec_box::check(cx, hir_ty, qpath, def_id, self.vec_box_size_threshold);\n+\n+                    if cx.tcx.is_diagnostic_item(sym::option_type, def_id) {\n                         if is_ty_param_diagnostic_item(cx, qpath, sym::option_type).is_some() {\n                             span_lint(\n                                 cx,"}, {"sha": "2964abf3492eb548433a6cba9344ca05fd0c1117", "filename": "clippy_lints/src/types/vec_box.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2c2fb3996f8b0db6537a2a9d193af89304cd62ed/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c2fb3996f8b0db6537a2a9d193af89304cd62ed/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs?ref=2c2fb3996f8b0db6537a2a9d193af89304cd62ed", "patch": "@@ -0,0 +1,59 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{self as hir, def_id::DefId, GenericArg, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::TypeFoldable;\n+use rustc_span::symbol::sym;\n+use rustc_target::abi::LayoutOf;\n+use rustc_typeck::hir_ty_to_ty;\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{last_path_segment, snippet, span_lint_and_sugg};\n+\n+use super::VEC_BOX;\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    hir_ty: &hir::Ty<'_>,\n+    qpath: &QPath<'_>,\n+    def_id: DefId,\n+    box_size_threshold: u64,\n+) {\n+    if cx.tcx.is_diagnostic_item(sym::vec_type, def_id) {\n+        if_chain! {\n+            // Get the _ part of Vec<_>\n+            if let Some(ref last) = last_path_segment(qpath).args;\n+            if let Some(ty) = last.args.iter().find_map(|arg| match arg {\n+                GenericArg::Type(ty) => Some(ty),\n+                _ => None,\n+            });\n+            // ty is now _ at this point\n+            if let TyKind::Path(ref ty_qpath) = ty.kind;\n+            let res = cx.qpath_res(ty_qpath, ty.hir_id);\n+            if let Some(def_id) = res.opt_def_id();\n+            if Some(def_id) == cx.tcx.lang_items().owned_box();\n+            // At this point, we know ty is Box<T>, now get T\n+            if let Some(ref last) = last_path_segment(ty_qpath).args;\n+            if let Some(boxed_ty) = last.args.iter().find_map(|arg| match arg {\n+                GenericArg::Type(ty) => Some(ty),\n+                _ => None,\n+            });\n+            let ty_ty = hir_ty_to_ty(cx.tcx, boxed_ty);\n+            if !ty_ty.has_escaping_bound_vars();\n+            if ty_ty.is_sized(cx.tcx.at(ty.span), cx.param_env);\n+            if let Ok(ty_ty_size) = cx.layout_of(ty_ty).map(|l| l.size.bytes());\n+            if ty_ty_size <= box_size_threshold;\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    VEC_BOX,\n+                    hir_ty.span,\n+                    \"`Vec<T>` is already on the heap, the boxing is unnecessary\",\n+                    \"try\",\n+                    format!(\"Vec<{}>\", snippet(cx, boxed_ty.span, \"..\")),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}"}]}