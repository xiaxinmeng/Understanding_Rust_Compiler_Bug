{"sha": "09868a56c95f7bc7b6ee3ab7611e3ca551031dbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ODY4YTU2Yzk1ZjdiYzdiNmVlM2FiNzYxMWUzY2E1NTEwMzFkYmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-06T20:24:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-06T20:24:37Z"}, "message": "Auto merge of #65169 - tmandry:rollup-qxjj8xp, r=tmandry\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #65095 (Sort error codes in librustc_passes)\n - #65101 (Upgrade librustc_macros dependencies)\n - #65142 (Ensure that associated `async fn`s have unique fresh param names)\n - #65155 (Use shorthand initialization in rustdoc)\n - #65158 (Remove dead module)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "0feef472e9650b8449e8486256ff68d903d455fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0feef472e9650b8449e8486256ff68d903d455fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd", "html_url": "https://github.com/rust-lang/rust/commit/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "421bd77f42c2fe8a2596dbcc1580ec97fb89009f", "url": "https://api.github.com/repos/rust-lang/rust/commits/421bd77f42c2fe8a2596dbcc1580ec97fb89009f", "html_url": "https://github.com/rust-lang/rust/commit/421bd77f42c2fe8a2596dbcc1580ec97fb89009f"}, {"sha": "dd04a8391817fe3f03ca508f1d7e5567337b013d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd04a8391817fe3f03ca508f1d7e5567337b013d", "html_url": "https://github.com/rust-lang/rust/commit/dd04a8391817fe3f03ca508f1d7e5567337b013d"}], "stats": {"total": 610, "additions": 220, "deletions": 390}, "files": [{"sha": "0282dc9d668118c2dc8e543194c49d4bdd5c12c7", "filename": "Cargo.lock", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=09868a56c95f7bc7b6ee3ab7611e3ca551031dbd", "patch": "@@ -993,7 +993,7 @@ dependencies = [\n  \"proc-macro2 0.4.30\",\n  \"quote 0.6.12\",\n  \"syn 0.15.35\",\n- \"synstructure\",\n+ \"synstructure 0.10.2\",\n ]\n \n [[package]]\n@@ -3165,7 +3165,7 @@ dependencies = [\n  \"proc-macro2 0.4.30\",\n  \"quote 0.6.12\",\n  \"syn 0.15.35\",\n- \"synstructure\",\n+ \"synstructure 0.10.2\",\n ]\n \n [[package]]\n@@ -3546,10 +3546,10 @@ name = \"rustc_macros\"\n version = \"0.1.0\"\n dependencies = [\n  \"itertools 0.8.0\",\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n- \"synstructure\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.5\",\n+ \"synstructure 0.12.1\",\n ]\n \n [[package]]\n@@ -4244,6 +4244,18 @@ dependencies = [\n  \"unicode-xid 0.1.0\",\n ]\n \n+[[package]]\n+name = \"synstructure\"\n+version = \"0.12.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3f085a5855930c0441ca1288cf044ea4aecf4f43a91668abdb870b4ba546a203\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.5\",\n+ \"unicode-xid 0.2.0\",\n+]\n+\n [[package]]\n name = \"syntax\"\n version = \"0.0.0\""}, {"sha": "d773c454432d87eacba2af91eacb6fab82ec3786", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=09868a56c95f7bc7b6ee3ab7611e3ca551031dbd", "patch": "@@ -844,7 +844,7 @@ impl<'a> LoweringContext<'a> {\n     /// header, we convert it to an in-band lifetime.\n     fn collect_fresh_in_band_lifetime(&mut self, span: Span) -> ParamName {\n         assert!(self.is_collecting_in_band_lifetimes);\n-        let index = self.lifetimes_to_define.len();\n+        let index = self.lifetimes_to_define.len() + self.in_scope_lifetimes.len();\n         let hir_name = ParamName::Fresh(index);\n         self.lifetimes_to_define.push((span, hir_name));\n         hir_name"}, {"sha": "c28fcb1a395ff999d2637908c08b8667ea3a164d", "filename": "src/librustc_macros/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/src%2Flibrustc_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/src%2Flibrustc_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2FCargo.toml?ref=09868a56c95f7bc7b6ee3ab7611e3ca551031dbd", "patch": "@@ -8,8 +8,8 @@ edition = \"2018\"\n proc-macro = true\n \n [dependencies]\n-synstructure = \"0.10.2\"\n-syn = { version = \"0.15.22\", features = [\"full\"] }\n-proc-macro2 = \"0.4.24\"\n-quote = \"0.6.10\"\n+synstructure = \"0.12.1\"\n+syn = { version = \"1\", features = [\"full\"] }\n+proc-macro2 = \"1\"\n+quote = \"1\"\n itertools = \"0.8\""}, {"sha": "735cfb11b365c4876c7d8720a98183a32ea5c734", "filename": "src/librustc_macros/src/hash_stable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fhash_stable.rs?ref=09868a56c95f7bc7b6ee3ab7611e3ca551031dbd", "patch": "@@ -15,22 +15,22 @@ fn parse_attributes(field: &syn::Field) -> Attributes {\n     };\n     for attr in &field.attrs {\n         if let Ok(meta) = attr.parse_meta() {\n-            if &meta.name().to_string() != \"stable_hasher\" {\n+            if !meta.path().is_ident(\"stable_hasher\") {\n                 continue;\n             }\n             let mut any_attr = false;\n             if let Meta::List(list) = meta {\n                 for nested in list.nested.iter() {\n                     if let NestedMeta::Meta(meta) = nested {\n-                        if &meta.name().to_string() == \"ignore\" {\n+                        if meta.path().is_ident(\"ignore\") {\n                             attrs.ignore = true;\n                             any_attr = true;\n                         }\n-                        if &meta.name().to_string() == \"project\" {\n+                        if meta.path().is_ident(\"project\") {\n                             if let Meta::List(list) = meta {\n                                 if let Some(nested) = list.nested.iter().next() {\n                                     if let NestedMeta::Meta(meta) = nested {\n-                                        attrs.project = Some(meta.name());\n+                                        attrs.project = meta.path().get_ident().cloned();\n                                         any_attr = true;\n                                     }\n                                 }"}, {"sha": "e63426281bf21fea294ffd71ecac399254a366a5", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "removed", "additions": 0, "deletions": 204, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/421bd77f42c2fe8a2596dbcc1580ec97fb89009f/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421bd77f42c2fe8a2596dbcc1580ec97fb89009f/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=421bd77f42c2fe8a2596dbcc1580ec97fb89009f", "patch": "@@ -1,204 +0,0 @@\n-use rustc::hir::def_id::LOCAL_CRATE;\n-use rustc::mir::mono::MonoItem;\n-use rustc::session::config::OptLevel;\n-use rustc::ty::{self, TyCtxt, Instance};\n-use rustc::ty::subst::InternalSubsts;\n-use rustc::ty::print::obsolete::DefPathBasedNames;\n-use syntax::attr::InlineAttr;\n-use std::fmt;\n-use rustc::mir::mono::Linkage;\n-use syntax_pos::symbol::InternedString;\n-use syntax::source_map::Span;\n-\n-/// Describes how a monomorphization will be instantiated in object files.\n-#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n-pub enum InstantiationMode {\n-    /// There will be exactly one instance of the given MonoItem. It will have\n-    /// external linkage so that it can be linked to from other codegen units.\n-    GloballyShared {\n-        /// In some compilation scenarios we may decide to take functions that\n-        /// are typically `LocalCopy` and instead move them to `GloballyShared`\n-        /// to avoid codegenning them a bunch of times. In this situation,\n-        /// however, our local copy may conflict with other crates also\n-        /// inlining the same function.\n-        ///\n-        /// This flag indicates that this situation is occurring, and informs\n-        /// symbol name calculation that some extra mangling is needed to\n-        /// avoid conflicts. Note that this may eventually go away entirely if\n-        /// ThinLTO enables us to *always* have a globally shared instance of a\n-        /// function within one crate's compilation.\n-        may_conflict: bool,\n-    },\n-\n-    /// Each codegen unit containing a reference to the given MonoItem will\n-    /// have its own private copy of the function (with internal linkage).\n-    LocalCopy,\n-}\n-\n-pub trait MonoItemExt<'tcx>: fmt::Debug {\n-    fn as_mono_item(&self) -> &MonoItem<'tcx>;\n-\n-    fn is_generic_fn(&self) -> bool {\n-        match *self.as_mono_item() {\n-            MonoItem::Fn(ref instance) => {\n-                instance.substs.non_erasable_generics().next().is_some()\n-            }\n-            MonoItem::Static(..) |\n-            MonoItem::GlobalAsm(..) => false,\n-        }\n-    }\n-\n-    fn symbol_name(&self, tcx: TyCtxt<'tcx>) -> ty::SymbolName {\n-        match *self.as_mono_item() {\n-            MonoItem::Fn(instance) => tcx.symbol_name(instance),\n-            MonoItem::Static(def_id) => {\n-                tcx.symbol_name(Instance::mono(tcx, def_id))\n-            }\n-            MonoItem::GlobalAsm(hir_id) => {\n-                let def_id = tcx.hir().local_def_id(hir_id);\n-                ty::SymbolName {\n-                    name: InternedString::intern(&format!(\"global_asm_{:?}\", def_id))\n-                }\n-            }\n-        }\n-    }\n-    fn instantiation_mode(&self, tcx: TyCtxt<'tcx>) -> InstantiationMode {\n-        let inline_in_all_cgus =\n-            tcx.sess.opts.debugging_opts.inline_in_all_cgus.unwrap_or_else(|| {\n-                tcx.sess.opts.optimize != OptLevel::No\n-            }) && !tcx.sess.opts.cg.link_dead_code;\n-\n-        match *self.as_mono_item() {\n-            MonoItem::Fn(ref instance) => {\n-                let entry_def_id = tcx.entry_fn(LOCAL_CRATE).map(|(id, _)| id);\n-                // If this function isn't inlined or otherwise has explicit\n-                // linkage, then we'll be creating a globally shared version.\n-                if self.explicit_linkage(tcx).is_some() ||\n-                    !instance.def.requires_local(tcx) ||\n-                    Some(instance.def_id()) == entry_def_id\n-                {\n-                    return InstantiationMode::GloballyShared  { may_conflict: false }\n-                }\n-\n-                // At this point we don't have explicit linkage and we're an\n-                // inlined function. If we're inlining into all CGUs then we'll\n-                // be creating a local copy per CGU\n-                if inline_in_all_cgus {\n-                    return InstantiationMode::LocalCopy\n-                }\n-\n-                // Finally, if this is `#[inline(always)]` we're sure to respect\n-                // that with an inline copy per CGU, but otherwise we'll be\n-                // creating one copy of this `#[inline]` function which may\n-                // conflict with upstream crates as it could be an exported\n-                // symbol.\n-                match tcx.codegen_fn_attrs(instance.def_id()).inline {\n-                    InlineAttr::Always => InstantiationMode::LocalCopy,\n-                    _ => {\n-                        InstantiationMode::GloballyShared  { may_conflict: true }\n-                    }\n-                }\n-            }\n-            MonoItem::Static(..) |\n-            MonoItem::GlobalAsm(..) => {\n-                InstantiationMode::GloballyShared { may_conflict: false }\n-            }\n-        }\n-    }\n-\n-    fn explicit_linkage(&self, tcx: TyCtxt<'tcx>) -> Option<Linkage> {\n-        let def_id = match *self.as_mono_item() {\n-            MonoItem::Fn(ref instance) => instance.def_id(),\n-            MonoItem::Static(def_id) => def_id,\n-            MonoItem::GlobalAsm(..) => return None,\n-        };\n-\n-        let codegen_fn_attrs = tcx.codegen_fn_attrs(def_id);\n-        codegen_fn_attrs.linkage\n-    }\n-\n-    /// Returns `true` if this instance is instantiable - whether it has no unsatisfied\n-    /// predicates.\n-    ///\n-    /// In order to codegen an item, all of its predicates must hold, because\n-    /// otherwise the item does not make sense. Type-checking ensures that\n-    /// the predicates of every item that is *used by* a valid item *do*\n-    /// hold, so we can rely on that.\n-    ///\n-    /// However, we codegen collector roots (reachable items) and functions\n-    /// in vtables when they are seen, even if they are not used, and so they\n-    /// might not be instantiable. For example, a programmer can define this\n-    /// public function:\n-    ///\n-    ///     pub fn foo<'a>(s: &'a mut ()) where &'a mut (): Clone {\n-    ///         <&mut () as Clone>::clone(&s);\n-    ///     }\n-    ///\n-    /// That function can't be codegened, because the method `<&mut () as Clone>::clone`\n-    /// does not exist. Luckily for us, that function can't ever be used,\n-    /// because that would require for `&'a mut (): Clone` to hold, so we\n-    /// can just not emit any code, or even a linker reference for it.\n-    ///\n-    /// Similarly, if a vtable method has such a signature, and therefore can't\n-    /// be used, we can just not emit it and have a placeholder (a null pointer,\n-    /// which will never be accessed) in its place.\n-    fn is_instantiable(&self, tcx: TyCtxt<'tcx>) -> bool {\n-        debug!(\"is_instantiable({:?})\", self);\n-        let (def_id, substs) = match *self.as_mono_item() {\n-            MonoItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n-            MonoItem::Static(def_id) => (def_id, InternalSubsts::empty()),\n-            // global asm never has predicates\n-            MonoItem::GlobalAsm(..) => return true\n-        };\n-\n-        tcx.substitute_normalize_and_test_predicates((def_id, &substs))\n-    }\n-\n-    fn to_string(&self, tcx: TyCtxt<'tcx>, debug: bool) -> String {\n-        return match *self.as_mono_item() {\n-            MonoItem::Fn(instance) => {\n-                to_string_internal(tcx, \"fn \", instance, debug)\n-            },\n-            MonoItem::Static(def_id) => {\n-                let instance = Instance::new(def_id, tcx.intern_substs(&[]));\n-                to_string_internal(tcx, \"static \", instance, debug)\n-            },\n-            MonoItem::GlobalAsm(..) => {\n-                \"global_asm\".to_string()\n-            }\n-        };\n-\n-        fn to_string_internal<'a, 'tcx>(\n-            tcx: TyCtxt<'tcx>,\n-            prefix: &str,\n-            instance: Instance<'tcx>,\n-            debug: bool,\n-        ) -> String {\n-            let mut result = String::with_capacity(32);\n-            result.push_str(prefix);\n-            let printer = DefPathBasedNames::new(tcx, false, false);\n-            printer.push_instance_as_string(instance, &mut result, debug);\n-            result\n-        }\n-    }\n-\n-    fn local_span(&self, tcx: TyCtxt<'tcx>) -> Option<Span> {\n-        match *self.as_mono_item() {\n-            MonoItem::Fn(Instance { def, .. }) => {\n-                tcx.hir().as_local_hir_id(def.def_id())\n-            }\n-            MonoItem::Static(def_id) => {\n-                tcx.hir().as_local_hir_id(def_id)\n-            }\n-            MonoItem::GlobalAsm(hir_id) => {\n-                Some(hir_id)\n-            }\n-        }.map(|hir_id| tcx.hir().span(hir_id))\n-    }\n-}\n-\n-impl MonoItemExt<'tcx> for MonoItem<'tcx> {\n-    fn as_mono_item(&self) -> &MonoItem<'tcx> {\n-        self\n-    }\n-}"}, {"sha": "82cbcf458b074347b08370d2e3816e0ada447223", "filename": "src/librustc_passes/error_codes.rs", "status": "modified", "additions": 161, "deletions": 162, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/src%2Flibrustc_passes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/src%2Flibrustc_passes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Ferror_codes.rs?ref=09868a56c95f7bc7b6ee3ab7611e3ca551031dbd", "patch": "@@ -53,6 +53,67 @@ extern {\n ```\n \"##,\n \n+// This shouldn't really ever trigger since the repeated value error comes first\n+E0136: r##\"\n+A binary can only have one entry point, and by default that entry point is the\n+function `main()`. If there are multiple such functions, please rename one.\n+\"##,\n+\n+E0137: r##\"\n+More than one function was declared with the `#[main]` attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0137\n+#![feature(main)]\n+\n+#[main]\n+fn foo() {}\n+\n+#[main]\n+fn f() {} // error: multiple functions with a `#[main]` attribute\n+```\n+\n+This error indicates that the compiler found multiple functions with the\n+`#[main]` attribute. This is an error because there must be a unique entry\n+point into a Rust program. Example:\n+\n+```\n+#![feature(main)]\n+\n+#[main]\n+fn f() {} // ok!\n+```\n+\"##,\n+\n+E0138: r##\"\n+More than one function was declared with the `#[start]` attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0138\n+#![feature(start)]\n+\n+#[start]\n+fn foo(argc: isize, argv: *const *const u8) -> isize {}\n+\n+#[start]\n+fn f(argc: isize, argv: *const *const u8) -> isize {}\n+// error: multiple 'start' functions\n+```\n+\n+This error indicates that the compiler found multiple functions with the\n+`#[start]` attribute. This is an error because there must be a unique entry\n+point into a Rust program. Example:\n+\n+```\n+#![feature(start)]\n+\n+#[start]\n+fn foo(argc: isize, argv: *const *const u8) -> isize { 0 } // ok!\n+```\n+\"##,\n+\n E0197: r##\"\n Inherent implementations (one that do not implement a trait but provide\n methods associated with a type) are always safe because they are not\n@@ -198,20 +259,30 @@ impl Foo for Bar {\n ```\n \"##,\n \n+E0512: r##\"\n+Transmute with two differently sized types was attempted. Erroneous code\n+example:\n \n-E0590: r##\"\n-`break` or `continue` must include a label when used in the condition of a\n-`while` loop.\n-\n-Example of erroneous code:\n+```compile_fail,E0512\n+fn takes_u8(_: u8) {}\n \n-```compile_fail\n-while break {}\n+fn main() {\n+    unsafe { takes_u8(::std::mem::transmute(0u16)); }\n+    // error: cannot transmute between types of different sizes,\n+    //        or dependently-sized types\n+}\n ```\n \n-To fix this, add a label specifying which loop is being broken out of:\n+Please use types with same size or use the expected type directly. Example:\n+\n ```\n-'foo: while break 'foo {}\n+fn takes_u8(_: u8) {}\n+\n+fn main() {\n+    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\n+    // or:\n+    unsafe { takes_u8(0u8); } // ok!\n+}\n ```\n \"##,\n \n@@ -249,151 +320,20 @@ let result = loop { // ok!\n ```\n \"##,\n \n-E0642: r##\"\n-Trait methods currently cannot take patterns as arguments.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0642\n-trait Foo {\n-    fn foo((x, y): (i32, i32)); // error: patterns aren't allowed\n-                                //        in trait methods\n-}\n-```\n-\n-You can instead use a single name for the argument:\n-\n-```\n-trait Foo {\n-    fn foo(x_and_y: (i32, i32)); // ok!\n-}\n-```\n-\"##,\n-\n-E0695: r##\"\n-A `break` statement without a label appeared inside a labeled block.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0695\n-# #![feature(label_break_value)]\n-loop {\n-    'a: {\n-        break;\n-    }\n-}\n-```\n-\n-Make sure to always label the `break`:\n-\n-```\n-# #![feature(label_break_value)]\n-'l: loop {\n-    'a: {\n-        break 'l;\n-    }\n-}\n-```\n-\n-Or if you want to `break` the labeled block:\n-\n-```\n-# #![feature(label_break_value)]\n-loop {\n-    'a: {\n-        break 'a;\n-    }\n-    break;\n-}\n-```\n-\"##,\n-\n-E0670: r##\"\n-Rust 2015 does not permit the use of `async fn`.\n+E0590: r##\"\n+`break` or `continue` must include a label when used in the condition of a\n+`while` loop.\n \n Example of erroneous code:\n \n-```compile_fail,E0670\n-async fn foo() {}\n-```\n-\n-Switch to the Rust 2018 edition to use `async fn`.\n-\"##,\n-\n-// This shouldn't really ever trigger since the repeated value error comes first\n-E0136: r##\"\n-A binary can only have one entry point, and by default that entry point is the\n-function `main()`. If there are multiple such functions, please rename one.\n-\"##,\n-\n-E0137: r##\"\n-More than one function was declared with the `#[main]` attribute.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0137\n-#![feature(main)]\n-\n-#[main]\n-fn foo() {}\n-\n-#[main]\n-fn f() {} // error: multiple functions with a `#[main]` attribute\n-```\n-\n-This error indicates that the compiler found multiple functions with the\n-`#[main]` attribute. This is an error because there must be a unique entry\n-point into a Rust program. Example:\n-\n-```\n-#![feature(main)]\n-\n-#[main]\n-fn f() {} // ok!\n-```\n-\"##,\n-\n-E0138: r##\"\n-More than one function was declared with the `#[start]` attribute.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0138\n-#![feature(start)]\n-\n-#[start]\n-fn foo(argc: isize, argv: *const *const u8) -> isize {}\n-\n-#[start]\n-fn f(argc: isize, argv: *const *const u8) -> isize {}\n-// error: multiple 'start' functions\n-```\n-\n-This error indicates that the compiler found multiple functions with the\n-`#[start]` attribute. This is an error because there must be a unique entry\n-point into a Rust program. Example:\n-\n-```\n-#![feature(start)]\n-\n-#[start]\n-fn foo(argc: isize, argv: *const *const u8) -> isize { 0 } // ok!\n+```compile_fail\n+while break {}\n ```\n-\"##,\n-\n-E0601: r##\"\n-No `main` function was found in a binary crate. To fix this error, add a\n-`main` function. For example:\n \n+To fix this, add a label specifying which loop is being broken out of:\n ```\n-fn main() {\n-    // Your program will start here.\n-    println!(\"Hello world!\");\n-}\n+'foo: while break 'foo {}\n ```\n-\n-If you don't know the basics of Rust, you can go look to the Rust Book to get\n-started: https://doc.rust-lang.org/book/\n \"##,\n \n E0591: r##\"\n@@ -474,33 +414,92 @@ makes a difference in practice.)\n [rfc401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n \"##,\n \n-E0512: r##\"\n-Transmute with two differently sized types was attempted. Erroneous code\n-example:\n-\n-```compile_fail,E0512\n-fn takes_u8(_: u8) {}\n+E0601: r##\"\n+No `main` function was found in a binary crate. To fix this error, add a\n+`main` function. For example:\n \n+```\n fn main() {\n-    unsafe { takes_u8(::std::mem::transmute(0u16)); }\n-    // error: cannot transmute between types of different sizes,\n-    //        or dependently-sized types\n+    // Your program will start here.\n+    println!(\"Hello world!\");\n }\n ```\n \n-Please use types with same size or use the expected type directly. Example:\n+If you don't know the basics of Rust, you can go look to the Rust Book to get\n+started: https://doc.rust-lang.org/book/\n+\"##,\n+\n+E0642: r##\"\n+Trait methods currently cannot take patterns as arguments.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0642\n+trait Foo {\n+    fn foo((x, y): (i32, i32)); // error: patterns aren't allowed\n+                                //        in trait methods\n+}\n+```\n+\n+You can instead use a single name for the argument:\n \n ```\n-fn takes_u8(_: u8) {}\n+trait Foo {\n+    fn foo(x_and_y: (i32, i32)); // ok!\n+}\n+```\n+\"##,\n \n-fn main() {\n-    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\n-    // or:\n-    unsafe { takes_u8(0u8); } // ok!\n+E0695: r##\"\n+A `break` statement without a label appeared inside a labeled block.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0695\n+# #![feature(label_break_value)]\n+loop {\n+    'a: {\n+        break;\n+    }\n+}\n+```\n+\n+Make sure to always label the `break`:\n+\n+```\n+# #![feature(label_break_value)]\n+'l: loop {\n+    'a: {\n+        break 'l;\n+    }\n+}\n+```\n+\n+Or if you want to `break` the labeled block:\n+\n+```\n+# #![feature(label_break_value)]\n+loop {\n+    'a: {\n+        break 'a;\n+    }\n+    break;\n }\n ```\n \"##,\n \n+E0670: r##\"\n+Rust 2015 does not permit the use of `async fn`.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0670\n+async fn foo() {}\n+```\n+\n+Switch to the Rust 2018 edition to use `async fn`.\n+\"##,\n+\n ;\n     E0226, // only a single explicit lifetime bound is permitted\n     E0472, // asm! is unsupported on this target"}, {"sha": "212a09ee6e6341e643b33bcdac095f69eb165686", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=09868a56c95f7bc7b6ee3ab7611e3ca551031dbd", "patch": "@@ -198,7 +198,7 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n             Item {\n                 source: Span::empty(),\n                 name: Some(kw.clone()),\n-                attrs: attrs,\n+                attrs,\n                 visibility: Public,\n                 stability: get_stability(cx, def_id),\n                 deprecation: get_deprecation(cx, def_id),\n@@ -1570,7 +1570,7 @@ impl Clean<GenericParamDef> for hir::GenericParam {\n                     did: cx.tcx.hir().local_def_id(self.hir_id),\n                     bounds: self.bounds.clean(cx),\n                     default: default.clean(cx),\n-                    synthetic: synthetic,\n+                    synthetic,\n                 })\n             }\n             hir::GenericParamKind::Const { ref ty } => {\n@@ -2213,7 +2213,7 @@ impl Clean<Item> for doctree::Trait<'_> {\n         let is_spotlight = attrs.has_doc_flag(sym::spotlight);\n         Item {\n             name: Some(self.name.clean(cx)),\n-            attrs: attrs,\n+            attrs,\n             source: self.whence.clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n@@ -2844,7 +2844,7 @@ impl Clean<Type> for hir::Ty {\n                 } else {\n                     Some(l.clean(cx))\n                 };\n-                BorrowedRef {lifetime: lifetime, mutability: m.mutbl.clean(cx),\n+                BorrowedRef {lifetime, mutability: m.mutbl.clean(cx),\n                              type_: box m.ty.clean(cx)}\n             }\n             TyKind::Slice(ref ty) => Slice(box ty.clean(cx)),\n@@ -3102,9 +3102,9 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 let path = external_path(cx, cx.tcx.item_name(did),\n                                          None, false, vec![], InternalSubsts::empty());\n                 ResolvedPath {\n-                    path: path,\n+                    path,\n                     param_names: None,\n-                    did: did,\n+                    did,\n                     is_generic: false,\n                 }\n             }\n@@ -4274,7 +4274,7 @@ fn resolve_type(cx: &DocContext<'_>,\n         _ => false,\n     };\n     let did = register_res(&*cx, path.res);\n-    ResolvedPath { path: path, param_names: None, did: did, is_generic: is_generic }\n+    ResolvedPath { path, param_names: None, did, is_generic }\n }\n \n pub fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {"}, {"sha": "c23890e2a05ee590074da9b937af2baaee8f939b", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=09868a56c95f7bc7b6ee3ab7611e3ca551031dbd", "patch": "@@ -486,8 +486,8 @@ where R: 'static + Send,\n         krate.version = crate_version;\n \n         f(Output {\n-            krate: krate,\n-            renderinfo: renderinfo,\n+            krate,\n+            renderinfo,\n             renderopts,\n         })\n     });"}, {"sha": "8e08b82b9d3e3dbc4c17db5f50358205dd37b49b", "filename": "src/test/ui/async-await/async-assoc-fn-anon-lifetimes.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/src%2Ftest%2Fui%2Fasync-await%2Fasync-assoc-fn-anon-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09868a56c95f7bc7b6ee3ab7611e3ca551031dbd/src%2Ftest%2Fui%2Fasync-await%2Fasync-assoc-fn-anon-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-assoc-fn-anon-lifetimes.rs?ref=09868a56c95f7bc7b6ee3ab7611e3ca551031dbd", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+// Check that the anonymous lifetimes used here aren't considered to shadow one\n+// another. Note that `async fn` is different to `fn` here because the lifetimes\n+// are numbered by HIR lowering, rather than lifetime resolution.\n+\n+// edition:2018\n+\n+struct A<'a, 'b>(&'a &'b i32);\n+struct B<'a>(&'a i32);\n+\n+impl A<'_, '_> {\n+    async fn assoc(x: &u32, y: B<'_>) {\n+        async fn nested(x: &u32, y: A<'_, '_>) {}\n+    }\n+\n+    async fn assoc2(x: &u32, y: A<'_, '_>) {\n+        impl A<'_, '_> {\n+            async fn nested_assoc(x: &u32, y: B<'_>) {}\n+        }\n+    }\n+}\n+\n+fn main() {}"}]}