{"sha": "5fbf036670592d79eae81c4617141502b53a09a8", "node_id": "C_kwDOAAsO6NoAKDVmYmYwMzY2NzA1OTJkNzllYWU4MWM0NjE3MTQxNTAyYjUzYTA5YTg", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-20T01:44:45Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-20T01:44:45Z"}, "message": "only do env var cleanup if all threads have stopped", "tree": {"sha": "f9940d2f7c00ec55bbe572053d336ea64b92fda3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9940d2f7c00ec55bbe572053d336ea64b92fda3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fbf036670592d79eae81c4617141502b53a09a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fbf036670592d79eae81c4617141502b53a09a8", "html_url": "https://github.com/rust-lang/rust/commit/5fbf036670592d79eae81c4617141502b53a09a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fbf036670592d79eae81c4617141502b53a09a8/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e37c488f33ccf2acae6093647a5e739ccae402f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e37c488f33ccf2acae6093647a5e739ccae402f", "html_url": "https://github.com/rust-lang/rust/commit/9e37c488f33ccf2acae6093647a5e739ccae402f"}], "stats": {"total": 91, "additions": 45, "deletions": 46}, "files": [{"sha": "8ee8df7445b3bac36f4b18bf7598af4601cda23d", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/5fbf036670592d79eae81c4617141502b53a09a8/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fbf036670592d79eae81c4617141502b53a09a8/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=5fbf036670592d79eae81c4617141502b53a09a8", "patch": "@@ -436,45 +436,6 @@ impl MemoryCellClocks {\n /// Evaluation context extensions.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n-    /// Temporarily allow data-races to occur. This should only be used in\n-    /// one of these cases:\n-    /// - One of the appropriate `validate_atomic` functions will be called to\n-    /// to treat a memory access as atomic.\n-    /// - The memory being accessed should be treated as internal state, that\n-    /// cannot be accessed by the interpreted program.\n-    /// - Execution of the interpreted program execution has halted.\n-    #[inline]\n-    fn allow_data_races_ref<R>(&self, op: impl FnOnce(&MiriEvalContext<'mir, 'tcx>) -> R) -> R {\n-        let this = self.eval_context_ref();\n-        if let Some(data_race) = &this.machine.data_race {\n-            data_race.ongoing_action_data_race_free.set(true);\n-        }\n-        let result = op(this);\n-        if let Some(data_race) = &this.machine.data_race {\n-            data_race.ongoing_action_data_race_free.set(false);\n-        }\n-        result\n-    }\n-\n-    /// Same as `allow_data_races_ref`, this temporarily disables any data-race detection and\n-    /// so should only be used for atomic operations or internal state that the program cannot\n-    /// access.\n-    #[inline]\n-    fn allow_data_races_mut<R>(\n-        &mut self,\n-        op: impl FnOnce(&mut MiriEvalContext<'mir, 'tcx>) -> R,\n-    ) -> R {\n-        let this = self.eval_context_mut();\n-        if let Some(data_race) = &this.machine.data_race {\n-            data_race.ongoing_action_data_race_free.set(true);\n-        }\n-        let result = op(this);\n-        if let Some(data_race) = &this.machine.data_race {\n-            data_race.ongoing_action_data_race_free.set(false);\n-        }\n-        result\n-    }\n-\n     /// Atomic variant of read_scalar_at_offset.\n     fn read_scalar_at_offset_atomic(\n         &self,\n@@ -1044,6 +1005,45 @@ impl VClockAlloc {\n \n impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {}\n trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n+    /// Temporarily allow data-races to occur. This should only be used in\n+    /// one of these cases:\n+    /// - One of the appropriate `validate_atomic` functions will be called to\n+    /// to treat a memory access as atomic.\n+    /// - The memory being accessed should be treated as internal state, that\n+    /// cannot be accessed by the interpreted program.\n+    /// - Execution of the interpreted program execution has halted.\n+    #[inline]\n+    fn allow_data_races_ref<R>(&self, op: impl FnOnce(&MiriEvalContext<'mir, 'tcx>) -> R) -> R {\n+        let this = self.eval_context_ref();\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.ongoing_action_data_race_free.set(true);\n+        }\n+        let result = op(this);\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.ongoing_action_data_race_free.set(false);\n+        }\n+        result\n+    }\n+\n+    /// Same as `allow_data_races_ref`, this temporarily disables any data-race detection and\n+    /// so should only be used for atomic operations or internal state that the program cannot\n+    /// access.\n+    #[inline]\n+    fn allow_data_races_mut<R>(\n+        &mut self,\n+        op: impl FnOnce(&mut MiriEvalContext<'mir, 'tcx>) -> R,\n+    ) -> R {\n+        let this = self.eval_context_mut();\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.ongoing_action_data_race_free.set(true);\n+        }\n+        let result = op(this);\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.ongoing_action_data_race_free.set(false);\n+        }\n+        result\n+    }\n+\n     /// Generic atomic operation implementation\n     fn validate_atomic_op<A: Debug + Copy>(\n         &self,"}, {"sha": "996d04a2c57ccd1c1e0c661c9938a79abafcdda0", "filename": "src/eval.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5fbf036670592d79eae81c4617141502b53a09a8/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fbf036670592d79eae81c4617141502b53a09a8/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=5fbf036670592d79eae81c4617141502b53a09a8", "patch": "@@ -363,13 +363,12 @@ pub fn eval_entry<'tcx>(\n         panic::resume_unwind(panic_payload)\n     });\n \n-    // Machine cleanup.\n-    // Execution of the program has halted so any memory access we do here\n-    // cannot produce a real data race. If we do not do something to disable\n-    // data race detection here, some uncommon combination of errors will\n-    // cause a data race to be detected:\n-    // https://github.com/rust-lang/miri/issues/2020\n-    ecx.allow_data_races_mut(|ecx| EnvVars::cleanup(ecx).unwrap());\n+    // Machine cleanup. Only do this if all threads have terminated; threads that are still running\n+    // might cause data races (https://github.com/rust-lang/miri/issues/2020) or Stacked Borrows\n+    // errors (https://github.com/rust-lang/miri/issues/2396) if we deallocate here.\n+    if ecx.have_all_terminated() {\n+        EnvVars::cleanup(&mut ecx).unwrap();\n+    }\n \n     // Process the result.\n     match res {"}]}