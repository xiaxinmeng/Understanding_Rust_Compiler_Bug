{"sha": "1483e67addd37d9bd20ba3b4613b678ee9ad4d68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ODNlNjdhZGRkMzdkOWJkMjBiYTNiNDYxM2I2NzhlZTlhZDRkNjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-26T11:15:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-26T11:15:44Z"}, "message": "Auto merge of #81367 - andersk:join-test-threads, r=dtolnay\n\nlibtest: Wait for test threads to exit after they report completion\n\nOtherwise we can miss bugs where a test reports that it succeeded but then panics within a TLS destructor.\n\nExample:\n\n```rust\nuse std::thread::sleep;\nuse std::time::Duration;\n\nstruct Foo;\n\nimpl Drop for Foo {\n    fn drop(&mut self) {\n        sleep(Duration::from_secs(1));\n        panic!()\n    }\n}\n\nthread_local!(static FOO: Foo = Foo);\n\n#[test]\npub fn test() {\n    FOO.with(|_| {});\n}\n```\n\nBefore this fix, `cargo test` incorrectly reports success.\n\n```console\n$ cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.01s\n     Running target/debug/deps/panicking_test-85130fa46b54f758\n\nrunning 1 test\ntest test ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n$ echo $?\n0\n```\n\nAfter this fix, the failure is visible. (The entire process is aborted due to #24479.)\n\n```console\n$ cargo test\n    Finished test [unoptimized + debuginfo] target(s) in 0.01s\n     Running target/debug/deps/panicking_test-76180625bc2ee3c9\n\nrunning 1 test\nthread 'test' panicked at 'explicit panic', src/main.rs:9:9\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nfatal runtime error: failed to initiate panic, error 5\nerror: test failed, to rerun pass '--bin panicking-test'\n\nCaused by:\n  process didn't exit successfully: `/tmp/panicking-test/target/debug/deps/panicking_test-76180625bc2ee3c9 --nocapture` (signal: 6, SIGABRT: process abort signal)\n\n$ echo $?\n101\n```", "tree": {"sha": "d44b005ba8225aee4d93b8baab63f8375c16b7f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d44b005ba8225aee4d93b8baab63f8375c16b7f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1483e67addd37d9bd20ba3b4613b678ee9ad4d68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1483e67addd37d9bd20ba3b4613b678ee9ad4d68", "html_url": "https://github.com/rust-lang/rust/commit/1483e67addd37d9bd20ba3b4613b678ee9ad4d68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1483e67addd37d9bd20ba3b4613b678ee9ad4d68/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8f707553276a15565860af3d415aae18428aa96", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8f707553276a15565860af3d415aae18428aa96", "html_url": "https://github.com/rust-lang/rust/commit/a8f707553276a15565860af3d415aae18428aa96"}, {"sha": "b05788e859d3d553825eb114f07573f4839286b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b05788e859d3d553825eb114f07573f4839286b1", "html_url": "https://github.com/rust-lang/rust/commit/b05788e859d3d553825eb114f07573f4839286b1"}], "stats": {"total": 88, "additions": 64, "deletions": 24}, "files": [{"sha": "3ff79eaea49aba18fa749b91c12e600de52d8cbe", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 64, "deletions": 24, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1483e67addd37d9bd20ba3b4613b678ee9ad4d68/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1483e67addd37d9bd20ba3b4613b678ee9ad4d68/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=1483e67addd37d9bd20ba3b4613b678ee9ad4d68", "patch": "@@ -25,6 +25,7 @@\n #![feature(nll)]\n #![feature(available_concurrency)]\n #![feature(internal_output_capture)]\n+#![feature(option_unwrap_none)]\n #![feature(panic_unwind)]\n #![feature(staged_api)]\n #![feature(termination_trait_lib)]\n@@ -61,6 +62,7 @@ pub mod test {\n }\n \n use std::{\n+    collections::VecDeque,\n     env, io,\n     io::prelude::Write,\n     panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo},\n@@ -208,9 +210,19 @@ where\n     use std::collections::{self, HashMap};\n     use std::hash::BuildHasherDefault;\n     use std::sync::mpsc::RecvTimeoutError;\n+\n+    struct RunningTest {\n+        join_handle: Option<thread::JoinHandle<()>>,\n+    }\n+\n     // Use a deterministic hasher\n     type TestMap =\n-        HashMap<TestDesc, Instant, BuildHasherDefault<collections::hash_map::DefaultHasher>>;\n+        HashMap<TestDesc, RunningTest, BuildHasherDefault<collections::hash_map::DefaultHasher>>;\n+\n+    struct TimeoutEntry {\n+        desc: TestDesc,\n+        timeout: Instant,\n+    }\n \n     let tests_len = tests.len();\n \n@@ -255,23 +267,30 @@ where\n     };\n \n     let mut running_tests: TestMap = HashMap::default();\n+    let mut timeout_queue: VecDeque<TimeoutEntry> = VecDeque::new();\n \n-    fn get_timed_out_tests(running_tests: &mut TestMap) -> Vec<TestDesc> {\n+    fn get_timed_out_tests(\n+        running_tests: &TestMap,\n+        timeout_queue: &mut VecDeque<TimeoutEntry>,\n+    ) -> Vec<TestDesc> {\n         let now = Instant::now();\n-        let timed_out = running_tests\n-            .iter()\n-            .filter_map(|(desc, timeout)| if &now >= timeout { Some(desc.clone()) } else { None })\n-            .collect();\n-        for test in &timed_out {\n-            running_tests.remove(test);\n+        let mut timed_out = Vec::new();\n+        while let Some(timeout_entry) = timeout_queue.front() {\n+            if now < timeout_entry.timeout {\n+                break;\n+            }\n+            let timeout_entry = timeout_queue.pop_front().unwrap();\n+            if running_tests.contains_key(&timeout_entry.desc) {\n+                timed_out.push(timeout_entry.desc);\n+            }\n         }\n         timed_out\n     }\n \n-    fn calc_timeout(running_tests: &TestMap) -> Option<Duration> {\n-        running_tests.values().min().map(|next_timeout| {\n+    fn calc_timeout(timeout_queue: &VecDeque<TimeoutEntry>) -> Option<Duration> {\n+        timeout_queue.front().map(|&TimeoutEntry { timeout: next_timeout, .. }| {\n             let now = Instant::now();\n-            if *next_timeout >= now { *next_timeout - now } else { Duration::new(0, 0) }\n+            if next_timeout >= now { next_timeout - now } else { Duration::new(0, 0) }\n         })\n     }\n \n@@ -280,7 +299,8 @@ where\n             let test = remaining.pop().unwrap();\n             let event = TestEvent::TeWait(test.desc.clone());\n             notify_about_test_event(event)?;\n-            run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::No);\n+            run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::No)\n+                .unwrap_none();\n             let completed_test = rx.recv().unwrap();\n \n             let event = TestEvent::TeResult(completed_test);\n@@ -291,19 +311,28 @@ where\n             while pending < concurrency && !remaining.is_empty() {\n                 let test = remaining.pop().unwrap();\n                 let timeout = time::get_default_test_timeout();\n-                running_tests.insert(test.desc.clone(), timeout);\n+                let desc = test.desc.clone();\n \n-                let event = TestEvent::TeWait(test.desc.clone());\n+                let event = TestEvent::TeWait(desc.clone());\n                 notify_about_test_event(event)?; //here no pad\n-                run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::Yes);\n+                let join_handle = run_test(\n+                    opts,\n+                    !opts.run_tests,\n+                    test,\n+                    run_strategy,\n+                    tx.clone(),\n+                    Concurrent::Yes,\n+                );\n+                running_tests.insert(desc.clone(), RunningTest { join_handle });\n+                timeout_queue.push_back(TimeoutEntry { desc, timeout });\n                 pending += 1;\n             }\n \n             let mut res;\n             loop {\n-                if let Some(timeout) = calc_timeout(&running_tests) {\n+                if let Some(timeout) = calc_timeout(&timeout_queue) {\n                     res = rx.recv_timeout(timeout);\n-                    for test in get_timed_out_tests(&mut running_tests) {\n+                    for test in get_timed_out_tests(&running_tests, &mut timeout_queue) {\n                         let event = TestEvent::TeTimeout(test);\n                         notify_about_test_event(event)?;\n                     }\n@@ -323,8 +352,16 @@ where\n                 }\n             }\n \n-            let completed_test = res.unwrap();\n-            running_tests.remove(&completed_test.desc);\n+            let mut completed_test = res.unwrap();\n+            let running_test = running_tests.remove(&completed_test.desc).unwrap();\n+            if let Some(join_handle) = running_test.join_handle {\n+                if let Err(_) = join_handle.join() {\n+                    if let TrOk = completed_test.result {\n+                        completed_test.result =\n+                            TrFailedMsg(\"panicked after reporting success\".to_string());\n+                    }\n+                }\n+            }\n \n             let event = TestEvent::TeResult(completed_test);\n             notify_about_test_event(event)?;\n@@ -415,7 +452,7 @@ pub fn run_test(\n     strategy: RunStrategy,\n     monitor_ch: Sender<CompletedTest>,\n     concurrency: Concurrent,\n-) {\n+) -> Option<thread::JoinHandle<()>> {\n     let TestDescAndFn { desc, testfn } = test;\n \n     // Emscripten can catch panics but other wasm targets cannot\n@@ -426,7 +463,7 @@ pub fn run_test(\n     if force_ignore || desc.ignore || ignore_because_no_process_support {\n         let message = CompletedTest::new(desc, TrIgnored, None, Vec::new());\n         monitor_ch.send(message).unwrap();\n-        return;\n+        return None;\n     }\n \n     struct TestRunOpts {\n@@ -441,7 +478,7 @@ pub fn run_test(\n         monitor_ch: Sender<CompletedTest>,\n         testfn: Box<dyn FnOnce() + Send>,\n         opts: TestRunOpts,\n-    ) {\n+    ) -> Option<thread::JoinHandle<()>> {\n         let concurrency = opts.concurrency;\n         let name = desc.name.clone();\n \n@@ -469,9 +506,10 @@ pub fn run_test(\n         let supports_threads = !cfg!(target_os = \"emscripten\") && !cfg!(target_arch = \"wasm32\");\n         if concurrency == Concurrent::Yes && supports_threads {\n             let cfg = thread::Builder::new().name(name.as_slice().to_owned());\n-            cfg.spawn(runtest).unwrap();\n+            Some(cfg.spawn(runtest).unwrap())\n         } else {\n             runtest();\n+            None\n         }\n     }\n \n@@ -484,10 +522,12 @@ pub fn run_test(\n             crate::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n                 bencher.run(harness)\n             });\n+            None\n         }\n         StaticBenchFn(benchfn) => {\n             // Benchmarks aren't expected to panic, so we run them all in-process.\n             crate::bench::benchmark(desc, monitor_ch, opts.nocapture, benchfn);\n+            None\n         }\n         DynTestFn(f) => {\n             match strategy {\n@@ -499,7 +539,7 @@ pub fn run_test(\n                 monitor_ch,\n                 Box::new(move || __rust_begin_short_backtrace(f)),\n                 test_run_opts,\n-            );\n+            )\n         }\n         StaticTestFn(f) => run_test_inner(\n             desc,"}]}