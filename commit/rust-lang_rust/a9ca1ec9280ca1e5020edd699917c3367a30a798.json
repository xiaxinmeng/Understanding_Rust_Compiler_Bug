{"sha": "a9ca1ec9280ca1e5020edd699917c3367a30a798", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5Y2ExZWM5MjgwY2ExZTUwMjBlZGQ2OTk5MTdjMzM2N2EzMGE3OTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-22T11:24:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-22T11:24:24Z"}, "message": "Auto merge of #72460 - RalfJung:rollup-28fs06y, r=RalfJung\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #71610 (InvalidUndefBytes: Track size of undef region used)\n - #72161 (Replace fcntl-based file lock with flock)\n - #72306 (Break tokens before checking if they are 'probably equal')\n - #72325 (Always generated object code for `#![no_builtins]`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "59443855cf71d124f74f9296a18e2ab879db1638", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59443855cf71d124f74f9296a18e2ab879db1638"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9ca1ec9280ca1e5020edd699917c3367a30a798", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9ca1ec9280ca1e5020edd699917c3367a30a798", "html_url": "https://github.com/rust-lang/rust/commit/a9ca1ec9280ca1e5020edd699917c3367a30a798", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9ca1ec9280ca1e5020edd699917c3367a30a798/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de6060b09d23d8c50afe88354358aa056c27ad9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/de6060b09d23d8c50afe88354358aa056c27ad9f", "html_url": "https://github.com/rust-lang/rust/commit/de6060b09d23d8c50afe88354358aa056c27ad9f"}, {"sha": "1119421e26da4e8cb530e14557b49c96c025f7ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/1119421e26da4e8cb530e14557b49c96c025f7ff", "html_url": "https://github.com/rust-lang/rust/commit/1119421e26da4e8cb530e14557b49c96c025f7ff"}], "stats": {"total": 306, "additions": 252, "deletions": 54}, "files": [{"sha": "075aaa7e5bc013dd5b0d9744d6ec73efda73de18", "filename": "src/librustc_ast/tokenstream.rs", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Flibrustc_ast%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Flibrustc_ast%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftokenstream.rs?ref=a9ca1ec9280ca1e5020edd699917c3367a30a798", "patch": "@@ -21,6 +21,8 @@ use rustc_macros::HashStable_Generic;\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n \n+use log::debug;\n+\n use std::{iter, mem};\n \n /// When the main rust parser encounters a syntax-extension invocation, it\n@@ -338,8 +340,71 @@ impl TokenStream {\n             true\n         }\n \n-        let mut t1 = self.trees().filter(semantic_tree);\n-        let mut t2 = other.trees().filter(semantic_tree);\n+        // When comparing two `TokenStream`s, we ignore the `IsJoint` information.\n+        //\n+        // However, `rustc_parse::lexer::tokentrees::TokenStreamBuilder` will\n+        // use `Token.glue` on adjacent tokens with the proper `IsJoint`.\n+        // Since we are ignoreing `IsJoint`, a 'glued' token (e.g. `BinOp(Shr)`)\n+        // and its 'split'/'unglued' compoenents (e.g. `Gt, Gt`) are equivalent\n+        // when determining if two `TokenStream`s are 'probably equal'.\n+        //\n+        // Therefore, we use `break_two_token_op` to convert all tokens\n+        // to the 'unglued' form (if it exists). This ensures that two\n+        // `TokenStream`s which differ only in how their tokens are glued\n+        // will be considered 'probably equal', which allows us to keep spans.\n+        //\n+        // This is important when the original `TokenStream` contained\n+        // extra spaces (e.g. `f :: < Vec < _ > > ( ) ;'). These extra spaces\n+        // will be omitted when we pretty-print, which can cause the original\n+        // and reparsed `TokenStream`s to differ in the assignment of `IsJoint`,\n+        // leading to some tokens being 'glued' together in one stream but not\n+        // the other. See #68489 for more details.\n+        fn break_tokens(tree: TokenTree) -> impl Iterator<Item = TokenTree> {\n+            // In almost all cases, we should have either zero or one levels\n+            // of 'unglueing'. However, in some unusual cases, we may need\n+            // to iterate breaking tokens mutliple times. For example:\n+            // '[BinOpEq(Shr)] => [Gt, Ge] -> [Gt, Gt, Eq]'\n+            let mut token_trees: SmallVec<[_; 2]>;\n+            if let TokenTree::Token(token) = &tree {\n+                let mut out = SmallVec::<[_; 2]>::new();\n+                out.push(token.clone());\n+                // Iterate to fixpoint:\n+                // * We start off with 'out' containing our initial token, and `temp` empty\n+                // * If we are able to break any tokens in `out`, then `out` will have\n+                //   at least one more element than 'temp', so we will try to break tokens\n+                //   again.\n+                // * If we cannot break any tokens in 'out', we are done\n+                loop {\n+                    let mut temp = SmallVec::<[_; 2]>::new();\n+                    let mut changed = false;\n+\n+                    for token in out.into_iter() {\n+                        if let Some((first, second)) = token.kind.break_two_token_op() {\n+                            temp.push(Token::new(first, DUMMY_SP));\n+                            temp.push(Token::new(second, DUMMY_SP));\n+                            changed = true;\n+                        } else {\n+                            temp.push(token);\n+                        }\n+                    }\n+                    out = temp;\n+                    if !changed {\n+                        break;\n+                    }\n+                }\n+                token_trees = out.into_iter().map(|t| TokenTree::Token(t)).collect();\n+                if token_trees.len() != 1 {\n+                    debug!(\"break_tokens: broke {:?} to {:?}\", tree, token_trees);\n+                }\n+            } else {\n+                token_trees = SmallVec::new();\n+                token_trees.push(tree);\n+            }\n+            token_trees.into_iter()\n+        }\n+\n+        let mut t1 = self.trees().filter(semantic_tree).flat_map(break_tokens);\n+        let mut t2 = other.trees().filter(semantic_tree).flat_map(break_tokens);\n         for (t1, t2) in t1.by_ref().zip(t2.by_ref()) {\n             if !t1.probably_equal_for_proc_macro(&t2) {\n                 return false;"}, {"sha": "f9ee7d8c5de71907359928d492d8ceda2e09ea50", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=a9ca1ec9280ca1e5020edd699917c3367a30a798", "patch": "@@ -142,8 +142,22 @@ impl ModuleConfig {\n         let emit_obj = if !should_emit_obj {\n             EmitObj::None\n         } else if sess.target.target.options.obj_is_bitcode\n-            || sess.opts.cg.linker_plugin_lto.enabled()\n+            || (sess.opts.cg.linker_plugin_lto.enabled() && !no_builtins)\n         {\n+            // This case is selected if the target uses objects as bitcode, or\n+            // if linker plugin LTO is enabled. In the linker plugin LTO case\n+            // the assumption is that the final link-step will read the bitcode\n+            // and convert it to object code. This may be done by either the\n+            // native linker or rustc itself.\n+            //\n+            // Note, however, that the linker-plugin-lto requested here is\n+            // explicitly ignored for `#![no_builtins]` crates. These crates are\n+            // specifically ignored by rustc's LTO passes and wouldn't work if\n+            // loaded into the linker. These crates define symbols that LLVM\n+            // lowers intrinsics to, and these symbol dependencies aren't known\n+            // until after codegen. As a result any crate marked\n+            // `#![no_builtins]` is assumed to not participate in LTO and\n+            // instead goes on to generate object code.\n             EmitObj::Bitcode\n         } else if need_bitcode_in_object(sess) {\n             EmitObj::ObjectCode(BitcodeSection::Full)"}, {"sha": "9383be474fd5a6224094a66f676875ec367681d5", "filename": "src/librustc_data_structures/flock.rs", "status": "modified", "additions": 57, "deletions": 24, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Flibrustc_data_structures%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Flibrustc_data_structures%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fflock.rs?ref=a9ca1ec9280ca1e5020edd699917c3367a30a798", "patch": "@@ -7,18 +7,22 @@\n #![allow(non_camel_case_types)]\n #![allow(nonstandard_style)]\n \n+use std::fs::{File, OpenOptions};\n use std::io;\n use std::path::Path;\n \n cfg_if! {\n-    if #[cfg(unix)] {\n-        use std::ffi::{CString, OsStr};\n-        use std::mem;\n+    // We use `flock` rather than `fcntl` on Linux, because WSL1 does not support\n+    // `fcntl`-style advisory locks properly (rust-lang/rust#72157).\n+    //\n+    // For other Unix targets we still use `fcntl` because it's more portable than\n+    // `flock`.\n+    if #[cfg(target_os = \"linux\")] {\n         use std::os::unix::prelude::*;\n \n         #[derive(Debug)]\n         pub struct Lock {\n-            fd: libc::c_int,\n+            _file: File,\n         }\n \n         impl Lock {\n@@ -27,22 +31,55 @@ cfg_if! {\n                        create: bool,\n                        exclusive: bool)\n                        -> io::Result<Lock> {\n-                let os: &OsStr = p.as_ref();\n-                let buf = CString::new(os.as_bytes()).unwrap();\n-                let open_flags = if create {\n-                    libc::O_RDWR | libc::O_CREAT\n+                let file = OpenOptions::new()\n+                    .read(true)\n+                    .write(true)\n+                    .create(create)\n+                    .mode(libc::S_IRWXU as u32)\n+                    .open(p)?;\n+\n+                let mut operation = if exclusive {\n+                    libc::LOCK_EX\n                 } else {\n-                    libc::O_RDWR\n-                };\n-\n-                let fd = unsafe {\n-                    libc::open(buf.as_ptr(), open_flags,\n-                               libc::S_IRWXU as libc::c_int)\n+                    libc::LOCK_SH\n                 };\n+                if !wait {\n+                    operation |= libc::LOCK_NB\n+                }\n \n-                if fd < 0 {\n-                    return Err(io::Error::last_os_error());\n+                let ret = unsafe { libc::flock(file.as_raw_fd(), operation) };\n+                if ret == -1 {\n+                    Err(io::Error::last_os_error())\n+                } else {\n+                    Ok(Lock { _file: file })\n                 }\n+            }\n+        }\n+\n+        // Note that we don't need a Drop impl to execute `flock(fd, LOCK_UN)`. Lock acquired by\n+        // `flock` is associated with the file descriptor and closing the file release it\n+        // automatically.\n+    } else if #[cfg(unix)] {\n+        use std::mem;\n+        use std::os::unix::prelude::*;\n+\n+        #[derive(Debug)]\n+        pub struct Lock {\n+            file: File,\n+        }\n+\n+        impl Lock {\n+            pub fn new(p: &Path,\n+                       wait: bool,\n+                       create: bool,\n+                       exclusive: bool)\n+                       -> io::Result<Lock> {\n+                let file = OpenOptions::new()\n+                    .read(true)\n+                    .write(true)\n+                    .create(create)\n+                    .mode(libc::S_IRWXU as u32)\n+                    .open(p)?;\n \n                 let lock_type = if exclusive {\n                     libc::F_WRLCK\n@@ -58,14 +95,12 @@ cfg_if! {\n \n                 let cmd = if wait { libc::F_SETLKW } else { libc::F_SETLK };\n                 let ret = unsafe {\n-                    libc::fcntl(fd, cmd, &flock)\n+                    libc::fcntl(file.as_raw_fd(), cmd, &flock)\n                 };\n                 if ret == -1 {\n-                    let err = io::Error::last_os_error();\n-                    unsafe { libc::close(fd); }\n-                    Err(err)\n+                    Err(io::Error::last_os_error())\n                 } else {\n-                    Ok(Lock { fd })\n+                    Ok(Lock { file })\n                 }\n             }\n         }\n@@ -79,15 +114,13 @@ cfg_if! {\n                 flock.l_len = 0;\n \n                 unsafe {\n-                    libc::fcntl(self.fd, libc::F_SETLK, &flock);\n-                    libc::close(self.fd);\n+                    libc::fcntl(self.file.as_raw_fd(), libc::F_SETLK, &flock);\n                 }\n             }\n         }\n     } else if #[cfg(windows)] {\n         use std::mem;\n         use std::os::windows::prelude::*;\n-        use std::fs::{File, OpenOptions};\n \n         use winapi::um::minwinbase::{OVERLAPPED, LOCKFILE_FAIL_IMMEDIATELY, LOCKFILE_EXCLUSIVE_LOCK};\n         use winapi::um::fileapi::LockFileEx;"}, {"sha": "96195db0bacd227aecb090741694413dadf3d798", "filename": "src/librustc_middle/mir/interpret/allocation.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs?ref=a9ca1ec9280ca1e5020edd699917c3367a30a798", "patch": "@@ -11,6 +11,7 @@ use rustc_target::abi::{Align, HasDataLayout, Size};\n \n use super::{\n     read_target_uint, write_target_uint, AllocId, InterpResult, Pointer, Scalar, ScalarMaybeUninit,\n+    UninitBytesAccess,\n };\n \n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n@@ -545,17 +546,23 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Checks whether the given range  is entirely defined.\n     ///\n-    /// Returns `Ok(())` if it's defined. Otherwise returns the index of the byte\n-    /// at which the first undefined access begins.\n-    fn is_defined(&self, ptr: Pointer<Tag>, size: Size) -> Result<(), Size> {\n+    /// Returns `Ok(())` if it's defined. Otherwise returns the range of byte\n+    /// indexes of the first contiguous undefined access.\n+    fn is_defined(&self, ptr: Pointer<Tag>, size: Size) -> Result<(), Range<Size>> {\n         self.init_mask.is_range_initialized(ptr.offset, ptr.offset + size) // `Size` addition\n     }\n \n-    /// Checks that a range of bytes is defined. If not, returns the `ReadUndefBytes`\n-    /// error which will report the first byte which is undefined.\n+    /// Checks that a range of bytes is defined. If not, returns the `InvalidUndefBytes`\n+    /// error which will report the first range of bytes which is undefined.\n     fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n-        self.is_defined(ptr, size)\n-            .or_else(|idx| throw_ub!(InvalidUninitBytes(Some(Pointer::new(ptr.alloc_id, idx)))))\n+        self.is_defined(ptr, size).or_else(|idx_range| {\n+            throw_ub!(InvalidUninitBytes(Some(Box::new(UninitBytesAccess {\n+                access_ptr: ptr.erase_tag(),\n+                access_size: size,\n+                uninit_ptr: Pointer::new(ptr.alloc_id, idx_range.start),\n+                uninit_size: idx_range.end - idx_range.start, // `Size` subtraction\n+            }))))\n+        })\n     }\n \n     pub fn mark_definedness(&mut self, ptr: Pointer<Tag>, size: Size, new_state: bool) {\n@@ -758,19 +765,25 @@ impl InitMask {\n \n     /// Checks whether the range `start..end` (end-exclusive) is entirely initialized.\n     ///\n-    /// Returns `Ok(())` if it's initialized. Otherwise returns the index of the byte\n-    /// at which the first uninitialized access begins.\n+    /// Returns `Ok(())` if it's initialized. Otherwise returns a range of byte\n+    /// indexes for the first contiguous span of the uninitialized access.\n     #[inline]\n-    pub fn is_range_initialized(&self, start: Size, end: Size) -> Result<(), Size> {\n+    pub fn is_range_initialized(&self, start: Size, end: Size) -> Result<(), Range<Size>> {\n         if end > self.len {\n-            return Err(self.len);\n+            return Err(self.len..end);\n         }\n \n         // FIXME(oli-obk): optimize this for allocations larger than a block.\n         let idx = (start.bytes()..end.bytes()).map(Size::from_bytes).find(|&i| !self.get(i));\n \n         match idx {\n-            Some(idx) => Err(idx),\n+            Some(idx) => {\n+                let undef_end = (idx.bytes()..end.bytes())\n+                    .map(Size::from_bytes)\n+                    .find(|&i| self.get(i))\n+                    .unwrap_or(end);\n+                Err(idx..undef_end)\n+            }\n             None => Ok(()),\n         }\n     }"}, {"sha": "d32a147344992115bacde0cb8ebed88539115d75", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=a9ca1ec9280ca1e5020edd699917c3367a30a798", "patch": "@@ -6,7 +6,7 @@ use crate::ty::query::TyCtxtAt;\n use crate::ty::{self, layout, tls, FnSig, Ty};\n \n use rustc_data_structures::sync::Lock;\n-use rustc_errors::{struct_span_err, DiagnosticBuilder, ErrorReported};\n+use rustc_errors::{pluralize, struct_span_err, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::definitions::DefPathData;\n use rustc_macros::HashStable;\n@@ -327,6 +327,19 @@ impl fmt::Display for CheckInAllocMsg {\n     }\n }\n \n+/// Details of an access to uninitialized bytes where it is not allowed.\n+#[derive(Debug)]\n+pub struct UninitBytesAccess {\n+    /// Location of the original memory access.\n+    pub access_ptr: Pointer,\n+    /// Size of the original memory access.\n+    pub access_size: Size,\n+    /// Location of the first uninitialized byte that was accessed.\n+    pub uninit_ptr: Pointer,\n+    /// Number of consecutive uninitialized bytes that were accessed.\n+    pub uninit_size: Size,\n+}\n+\n /// Error information for when the program caused Undefined Behavior.\n pub enum UndefinedBehaviorInfo<'tcx> {\n     /// Free-form case. Only for errors that are never caught!\n@@ -384,7 +397,7 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     /// Using a string that is not valid UTF-8,\n     InvalidStr(std::str::Utf8Error),\n     /// Using uninitialized data where it is not allowed.\n-    InvalidUninitBytes(Option<Pointer>),\n+    InvalidUninitBytes(Option<Box<UninitBytesAccess>>),\n     /// Working with a local that is not currently live.\n     DeadLocal,\n     /// Data size is not equal to target size.\n@@ -455,10 +468,18 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n                 write!(f, \"using {} as function pointer but it does not point to a function\", p)\n             }\n             InvalidStr(err) => write!(f, \"this string is not valid UTF-8: {}\", err),\n-            InvalidUninitBytes(Some(p)) => write!(\n+            InvalidUninitBytes(Some(access)) => write!(\n                 f,\n-                \"reading uninitialized memory at {}, but this operation requires initialized memory\",\n-                p\n+                \"reading {} byte{} of memory starting at {}, \\\n+                 but {} byte{} {} uninitialized starting at {}, \\\n+                 and this operation requires initialized memory\",\n+                access.access_size.bytes(),\n+                pluralize!(access.access_size.bytes()),\n+                access.access_ptr,\n+                access.uninit_size.bytes(),\n+                pluralize!(access.uninit_size.bytes()),\n+                if access.uninit_size.bytes() != 1 { \"are\" } else { \"is\" },\n+                access.uninit_ptr,\n             ),\n             InvalidUninitBytes(None) => write!(\n                 f,\n@@ -556,6 +577,9 @@ impl dyn MachineStopType {\n     }\n }\n \n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(InterpError<'_>, 40);\n+\n pub enum InterpError<'tcx> {\n     /// The program caused undefined behavior.\n     UndefinedBehavior(UndefinedBehaviorInfo<'tcx>),\n@@ -604,7 +628,10 @@ impl InterpError<'_> {\n             InterpError::MachineStop(b) => mem::size_of_val::<dyn MachineStopType>(&**b) > 0,\n             InterpError::Unsupported(UnsupportedOpInfo::Unsupported(_))\n             | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::ValidationFailure(_))\n-            | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::Ub(_)) => true,\n+            | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::Ub(_))\n+            | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::InvalidUninitBytes(Some(_))) => {\n+                true\n+            }\n             _ => false,\n         }\n     }"}, {"sha": "d9e52af89007ca4286d32314bb18c1e641acfd39", "filename": "src/librustc_middle/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs?ref=a9ca1ec9280ca1e5020edd699917c3367a30a798", "patch": "@@ -119,7 +119,7 @@ use crate::ty::{self, Instance, Ty, TyCtxt};\n pub use self::error::{\n     struct_error, CheckInAllocMsg, ConstEvalErr, ConstEvalRawResult, ConstEvalResult, ErrorHandled,\n     FrameInfo, InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType,\n-    ResourceExhaustionInfo, UndefinedBehaviorInfo, UnsupportedOpInfo,\n+    ResourceExhaustionInfo, UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n };\n \n pub use self::value::{get_slice_bytes, ConstValue, RawConst, Scalar, ScalarMaybeUninit};"}, {"sha": "c83555d65faf06a525e83b9219c789a18959021b", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=a9ca1ec9280ca1e5020edd699917c3367a30a798", "patch": "@@ -366,7 +366,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let place = try_validation!(\n             self.ecx.ref_to_mplace(value),\n             self.path,\n-            err_ub!(InvalidUninitBytes(..)) => { \"uninitialized {}\", kind },\n+            err_ub!(InvalidUninitBytes { .. }) => { \"uninitialized {}\", kind },\n         );\n         if place.layout.is_unsized() {\n             self.check_wide_ptr_meta(place.meta, place.layout)?;\n@@ -514,7 +514,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 let place = try_validation!(\n                     self.ecx.ref_to_mplace(self.ecx.read_immediate(value)?),\n                     self.path,\n-                    err_ub!(InvalidUninitBytes(..)) => { \"uninitialized raw pointer\" },\n+                    err_ub!(InvalidUninitBytes { .. } ) => { \"uninitialized raw pointer\" },\n                 );\n                 if place.layout.is_unsized() {\n                     self.check_wide_ptr_meta(place.meta, place.layout)?;\n@@ -592,7 +592,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let value = try_validation!(\n             value.not_undef(),\n             self.path,\n-            err_ub!(InvalidUninitBytes(..)) => { \"{}\", value }\n+            err_ub!(InvalidUninitBytes { .. }) => { \"{}\", value }\n                 expected { \"something {}\", wrapping_range_format(valid_range, max_hi) },\n         );\n         let bits = match value.to_bits_or_ptr(op.layout.size, self.ecx) {\n@@ -803,12 +803,14 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                         // For some errors we might be able to provide extra information.\n                         // (This custom logic does not fit the `try_validation!` macro.)\n                         match err.kind {\n-                            err_ub!(InvalidUninitBytes(Some(ptr))) => {\n+                            err_ub!(InvalidUninitBytes(Some(access))) => {\n                                 // Some byte was uninitialized, determine which\n                                 // element that byte belongs to so we can\n                                 // provide an index.\n-                                let i = usize::try_from(ptr.offset.bytes() / layout.size.bytes())\n-                                    .unwrap();\n+                                let i = usize::try_from(\n+                                    access.uninit_ptr.offset.bytes() / layout.size.bytes(),\n+                                )\n+                                .unwrap();\n                                 self.path.push(PathElem::ArrayElem(i));\n \n                                 throw_validation_failure!(self.path, { \"uninitialized bytes\" })"}, {"sha": "59dc3b5043cd78bdb4ce6834daa8934c15b8dae4", "filename": "src/test/ui/proc-macro/break-token-spans.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.rs?ref=a9ca1ec9280ca1e5020edd699917c3367a30a798", "patch": "@@ -0,0 +1,16 @@\n+// aux-build:test-macros.rs\n+// Regression test for issues #68489 and #70987\n+// Tests that we properly break tokens in `probably_equal_for_proc_macro`\n+// See #72306\n+//\n+// Note that the weird spacing in this example is critical\n+// for testing the issue.\n+\n+extern crate test_macros;\n+\n+#[test_macros::recollect_attr]\n+fn repro() {\n+    f :: < Vec < _ > > ( ) ; //~ ERROR cannot find\n+    let a: Option<Option<u8>>= true; //~ ERROR mismatched\n+}\n+fn main() {}"}, {"sha": "caca973f252f7fe442d8d904a4eb26cdbbf4c9d4", "filename": "src/test/ui/proc-macro/break-token-spans.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fbreak-token-spans.stderr?ref=a9ca1ec9280ca1e5020edd699917c3367a30a798", "patch": "@@ -0,0 +1,21 @@\n+error[E0425]: cannot find function `f` in this scope\n+  --> $DIR/break-token-spans.rs:13:5\n+   |\n+LL |     f :: < Vec < _ > > ( ) ;\n+   |     ^ not found in this scope\n+\n+error[E0308]: mismatched types\n+  --> $DIR/break-token-spans.rs:14:32\n+   |\n+LL |     let a: Option<Option<u8>>= true;\n+   |            ------------------  ^^^^ expected enum `std::option::Option`, found `bool`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected enum `std::option::Option<std::option::Option<u8>>`\n+              found type `bool`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0308, E0425.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "666fc965f02f5caf2013effa1ca6b4a729b38fb9", "filename": "src/test/ui/suggestions/issue-61963.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.rs?ref=a9ca1ec9280ca1e5020edd699917c3367a30a798", "patch": "@@ -16,6 +16,7 @@ pub struct Qux<T>(T);\n \n #[dom_struct]\n pub struct Foo {\n+    //~^ ERROR trait objects without an explicit `dyn` are deprecated [bare_trait_objects]\n     qux: Qux<Qux<Baz>>,\n     bar: Box<Bar>,\n     //~^ ERROR trait objects without an explicit `dyn` are deprecated [bare_trait_objects]"}, {"sha": "62ae5fa3fe54fd09fc194f5ae5e5b4586564607e", "filename": "src/test/ui/suggestions/issue-61963.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9ca1ec9280ca1e5020edd699917c3367a30a798/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-61963.stderr?ref=a9ca1ec9280ca1e5020edd699917c3367a30a798", "patch": "@@ -1,5 +1,5 @@\n error: trait objects without an explicit `dyn` are deprecated\n-  --> $DIR/issue-61963.rs:20:14\n+  --> $DIR/issue-61963.rs:21:14\n    |\n LL |     bar: Box<Bar>,\n    |              ^^^ help: use `dyn`: `dyn Bar`\n@@ -10,5 +10,11 @@ note: the lint level is defined here\n LL | #![deny(bare_trait_objects)]\n    |         ^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: trait objects without an explicit `dyn` are deprecated\n+  --> $DIR/issue-61963.rs:18:1\n+   |\n+LL | pub struct Foo {\n+   | ^^^ help: use `dyn`: `dyn pub`\n+\n+error: aborting due to 2 previous errors\n "}]}