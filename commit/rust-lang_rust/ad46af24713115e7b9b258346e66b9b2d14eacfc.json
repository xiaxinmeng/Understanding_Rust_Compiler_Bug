{"sha": "ad46af24713115e7b9b258346e66b9b2d14eacfc", "node_id": "C_kwDOAAsO6NoAKGFkNDZhZjI0NzEzMTE1ZTdiOWIyNTgzNDZlNjZiOWIyZDE0ZWFjZmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-14T17:31:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-14T17:31:28Z"}, "message": "Auto merge of #92883 - matthiaskrgr:rollup-uoudywx, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #92045 (Don't fall back to crate-level opaque type definitions.)\n - #92381 (Suggest `return`ing tail expressions in async functions)\n - #92768 (Partially stabilize `maybe_uninit_extra`)\n - #92810 (Deduplicate box deref and regular deref suggestions)\n - #92818 (Update documentation for doc_cfg feature)\n - #92840 (Fix some lints documentation)\n - #92849 (Clippyup)\n - #92854 (Use the updated Rust logo in rustdoc)\n - #92864 (Fix a missing dot in the main item heading)\n\nFailed merges:\n\n - #92838 (Clean up some links in RELEASES)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "09e536728a971380ade053c74dff3bc4a48629d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09e536728a971380ade053c74dff3bc4a48629d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad46af24713115e7b9b258346e66b9b2d14eacfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad46af24713115e7b9b258346e66b9b2d14eacfc", "html_url": "https://github.com/rust-lang/rust/commit/ad46af24713115e7b9b258346e66b9b2d14eacfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad46af24713115e7b9b258346e66b9b2d14eacfc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609", "url": "https://api.github.com/repos/rust-lang/rust/commits/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609", "html_url": "https://github.com/rust-lang/rust/commit/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609"}, {"sha": "2ae4afddd739144afba7348fb682d7b0cade6f67", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ae4afddd739144afba7348fb682d7b0cade6f67", "html_url": "https://github.com/rust-lang/rust/commit/2ae4afddd739144afba7348fb682d7b0cade6f67"}], "stats": {"total": 5318, "additions": 3535, "deletions": 1783}, "files": [{"sha": "5fda666e480ed315147e13bf6aaae8fd556b711a", "filename": "Cargo.lock", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -639,14 +639,15 @@ dependencies = [\n \n [[package]]\n name = \"clippy\"\n-version = \"0.1.59\"\n+version = \"0.1.60\"\n dependencies = [\n  \"cargo_metadata 0.14.0\",\n  \"clippy_lints\",\n  \"clippy_utils\",\n  \"compiletest_rs\",\n  \"derive-new\",\n  \"filetime\",\n+ \"futures 0.3.12\",\n  \"if_chain\",\n  \"itertools 0.10.1\",\n  \"parking_lot\",\n@@ -659,6 +660,7 @@ dependencies = [\n  \"syn\",\n  \"tempfile\",\n  \"tester\",\n+ \"tokio\",\n ]\n \n [[package]]\n@@ -678,7 +680,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy_lints\"\n-version = \"0.1.59\"\n+version = \"0.1.60\"\n dependencies = [\n  \"cargo_metadata 0.14.0\",\n  \"clippy_utils\",\n@@ -699,8 +701,9 @@ dependencies = [\n \n [[package]]\n name = \"clippy_utils\"\n-version = \"0.1.59\"\n+version = \"0.1.60\"\n dependencies = [\n+ \"arrayvec\",\n  \"if_chain\",\n  \"rustc-semver\",\n ]"}, {"sha": "d3664e53447d04520cbf33233ac907a1dc8e9731", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -10,7 +10,6 @@ pub(crate) use self::undo_log::{InferCtxtUndoLogs, Snapshot, UndoLog};\n \n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n \n-use hir::def_id::CRATE_DEF_ID;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::Rollback;\n@@ -291,7 +290,12 @@ pub struct InferCtxt<'a, 'tcx> {\n \n     /// The `DefId` of the item in whose context we are performing inference or typeck.\n     /// It is used to check whether an opaque type use is a defining use.\n-    pub defining_use_anchor: LocalDefId,\n+    ///\n+    /// If it is `None`, we can't resolve opaque types here and need to bubble up\n+    /// the obligation. This frequently happens for\n+    /// short lived InferCtxt within queries. The opaque type obligations are forwarded\n+    /// to the outside until the end up in an `InferCtxt` for typeck or borrowck.\n+    pub defining_use_anchor: Option<LocalDefId>,\n \n     /// During type-checking/inference of a body, `in_progress_typeck_results`\n     /// contains a reference to the typeck results being built up, which are\n@@ -547,7 +551,7 @@ impl<'tcx> fmt::Display for FixupError<'tcx> {\n pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n-    defining_use_anchor: LocalDefId,\n+    defining_use_anchor: Option<LocalDefId>,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -556,11 +560,7 @@ pub trait TyCtxtInferExt<'tcx> {\n \n impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n     fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {\n-        InferCtxtBuilder {\n-            tcx: self,\n-            defining_use_anchor: CRATE_DEF_ID,\n-            fresh_typeck_results: None,\n-        }\n+        InferCtxtBuilder { tcx: self, defining_use_anchor: None, fresh_typeck_results: None }\n     }\n }\n \n@@ -580,7 +580,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// (via `with_fresh_in_progress_typeck_results`) and for the inference context used\n     /// in mir borrowck.\n     pub fn with_opaque_type_inference(mut self, defining_use_anchor: LocalDefId) -> Self {\n-        self.defining_use_anchor = defining_use_anchor;\n+        self.defining_use_anchor = Some(defining_use_anchor);\n         self\n     }\n "}, {"sha": "04b1a42e5beef75345bdf41c5b703d9e6d2ea05e", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -328,6 +328,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             },\n         });\n     }\n+\n+    fn opaque_type_origin(&self, def_id: LocalDefId) -> Option<hir::OpaqueTyOrigin> {\n+        let tcx = self.tcx;\n+        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        let parent_def_id = self.defining_use_anchor?;\n+        let item_kind = &tcx.hir().expect_item(def_id).kind;\n+        let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, ..  }) = item_kind else {\n+            span_bug!(\n+                tcx.def_span(def_id),\n+                \"weird opaque type: {:#?}\",\n+                item_kind\n+            )\n+        };\n+        let in_definition_scope = match *origin {\n+            // Async `impl Trait`\n+            hir::OpaqueTyOrigin::AsyncFn(parent) => parent == parent_def_id,\n+            // Anonymous `impl Trait`\n+            hir::OpaqueTyOrigin::FnReturn(parent) => parent == parent_def_id,\n+            // Named `type Foo = impl Bar;`\n+            hir::OpaqueTyOrigin::TyAlias => {\n+                may_define_opaque_type(tcx, parent_def_id, opaque_hir_id)\n+            }\n+        };\n+        in_definition_scope.then_some(*origin)\n+    }\n }\n \n // Visitor that requires that (almost) all regions in the type visited outlive\n@@ -459,31 +484,10 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                     // }\n                     // ```\n                     if let Some(def_id) = def_id.as_local() {\n-                        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                        let parent_def_id = self.infcx.defining_use_anchor;\n-                        let item_kind = &tcx.hir().expect_item(def_id).kind;\n-                        let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, ..  }) = item_kind else {\n-                            span_bug!(\n-                                self.value_span,\n-                                \"weird opaque type: {:#?}, {:#?}\",\n-                                ty.kind(),\n-                                item_kind\n-                            )\n-                        };\n-                        let in_definition_scope = match *origin {\n-                            // Async `impl Trait`\n-                            hir::OpaqueTyOrigin::AsyncFn(parent) => parent == parent_def_id,\n-                            // Anonymous `impl Trait`\n-                            hir::OpaqueTyOrigin::FnReturn(parent) => parent == parent_def_id,\n-                            // Named `type Foo = impl Bar;`\n-                            hir::OpaqueTyOrigin::TyAlias => {\n-                                may_define_opaque_type(tcx, parent_def_id, opaque_hir_id)\n-                            }\n-                        };\n-                        if in_definition_scope {\n+                        if let Some(origin) = self.infcx.opaque_type_origin(def_id) {\n                             let opaque_type_key =\n                                 OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n-                            return self.fold_opaque_ty(ty, opaque_type_key, *origin);\n+                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n                         }\n \n                         debug!("}, {"sha": "c2f6118227a4aec07d316381e1607edd127dde95", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1805,7 +1805,7 @@ declare_lint! {\n     ///\n     /// ### Example\n     ///\n-    /// ```\n+    /// ```rust\n     /// if let _ = 123 {\n     ///     println!(\"always runs!\");\n     /// }\n@@ -2431,7 +2431,19 @@ declare_lint! {\n     /// }\n     /// ```\n     ///\n-    /// {{produces}}\n+    /// This will produce:\n+    ///\n+    /// ```text\n+    /// warning: formatting may not be suitable for sub-register argument\n+    ///  --> src/main.rs:7:19\n+    ///   |\n+    /// 7 |         asm!(\"mov {0}, {0}\", in(reg) 0i16);\n+    ///   |                   ^^^  ^^^           ---- for this argument\n+    ///   |\n+    ///   = note: `#[warn(asm_sub_register)]` on by default\n+    ///   = help: use the `x` modifier to have the register formatted as `ax`\n+    ///   = help: or use the `r` modifier to keep the default formatting of `rax`\n+    /// ```\n     ///\n     /// ### Explanation\n     ///\n@@ -2470,7 +2482,17 @@ declare_lint! {\n     /// }\n     /// ```\n     ///\n-    /// {{produces}}\n+    /// This will produce:\n+    ///\n+    /// ```text\n+    /// warning: avoid using `.att_syntax`, prefer using `options(att_syntax)` instead\n+    ///  --> src/main.rs:8:14\n+    ///   |\n+    /// 8 |             \".att_syntax\",\n+    ///   |              ^^^^^^^^^^^\n+    ///   |\n+    ///   = note: `#[warn(bad_asm_style)]` on by default\n+    /// ```\n     ///\n     /// ### Explanation\n     ///\n@@ -2788,7 +2810,7 @@ declare_lint! {\n     ///\n     /// ### Example\n     ///\n-    /// ```compile_fail\n+    /// ```rust,compile_fail\n     /// #![feature(staged_api)]\n     ///\n     /// #[derive(Clone)]\n@@ -3618,7 +3640,17 @@ declare_lint! {\n     /// fn foo() {}\n     /// ```\n     ///\n-    /// {{produces}}\n+    /// This will produce:\n+    ///\n+    /// ```text\n+    /// warning: duplicated attribute\n+    ///  --> src/lib.rs:2:1\n+    ///   |\n+    /// 2 | #[test]\n+    ///   | ^^^^^^^\n+    ///   |\n+    ///   = note: `#[warn(duplicate_macro_attributes)]` on by default\n+    /// ```\n     ///\n     /// ### Explanation\n     ///"}, {"sha": "c351a9f70404a8df1fbf8d595025c5a46bc94738", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -31,9 +31,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         error: TypeError<'tcx>,\n     ) {\n         self.annotate_expected_due_to_let_ty(err, expr, error);\n-        self.suggest_box_deref(err, expr, expected, expr_ty);\n-        self.suggest_compatible_variants(err, expr, expected, expr_ty);\n         self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr);\n+        self.suggest_compatible_variants(err, expr, expected, expr_ty);\n         if self.suggest_calling_boxed_future_when_appropriate(err, expr, expected, expr_ty) {\n             return;\n         }\n@@ -259,23 +258,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_box_deref(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        expr: &hir::Expr<'_>,\n-        expected: Ty<'tcx>,\n-        expr_ty: Ty<'tcx>,\n-    ) {\n-        if expr_ty.is_box() && expr_ty.boxed_ty() == expected {\n-            err.span_suggestion_verbose(\n-                expr.span.shrink_to_lo(),\n-                \"try dereferencing the `Box`\",\n-                \"*\".to_string(),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    }\n-\n     /// If the expected type is an enum (Issue #55250) with any variants whose\n     /// sole field is of the found type, suggest such variants. (Issue #42764)\n     fn suggest_compatible_variants(\n@@ -857,14 +839,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 Applicability::MachineApplicable,\n                                 false,\n                             ));\n-                        } else if self.infcx.type_is_copy_modulo_regions(\n-                            self.param_env,\n-                            expected,\n-                            sp,\n-                        ) {\n-                            // For this suggestion to make sense, the type would need to be `Copy`.\n+                        }\n+\n+                        // For this suggestion to make sense, the type would need to be `Copy`,\n+                        // or we have to be moving out of a `Box<T>`\n+                        if self.infcx.type_is_copy_modulo_regions(self.param_env, expected, sp)\n+                            || checked_ty.is_box()\n+                        {\n                             if let Ok(code) = sm.span_to_snippet(expr.span) {\n-                                let message = if checked_ty.is_region_ptr() {\n+                                let message = if checked_ty.is_box() {\n+                                    \"consider unboxing the value\"\n+                                } else if checked_ty.is_region_ptr() {\n                                     \"consider dereferencing the borrow\"\n                                 } else {\n                                     \"consider dereferencing the type\""}, {"sha": "e8a0cc946b5e118d1ceba3bb1cd20f3c44953a7f", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -9,7 +9,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Expr, ExprKind, ItemKind, Node, Path, QPath, Stmt, StmtKind, TyKind};\n-use rustc_infer::infer;\n+use rustc_infer::infer::{self, TyCtxtInferExt};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Binder, Ty};\n use rustc_span::symbol::{kw, sym};\n@@ -608,6 +608,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let bound_vars = self.tcx.late_bound_vars(fn_id);\n             let ty = self.tcx.erase_late_bound_regions(Binder::bind_with_vars(ty, bound_vars));\n             let ty = self.normalize_associated_types_in(expr.span, ty);\n+            let ty = match self.tcx.asyncness(fn_id.owner) {\n+                hir::IsAsync::Async => self.tcx.infer_ctxt().enter(|infcx| {\n+                    infcx.get_impl_future_output_ty(ty).unwrap_or_else(|| {\n+                        span_bug!(\n+                            fn_decl.output.span(),\n+                            \"failed to get output type of async function\"\n+                        )\n+                    })\n+                }),\n+                hir::IsAsync::NotAsync => ty,\n+            };\n             if self.can_coerce(found, ty) {\n                 err.multipart_suggestion(\n                     \"you might have meant to return this value\","}, {"sha": "1cbc2b65f4dbdad1910c8c5b74d178516f0c5a15", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -119,7 +119,6 @@\n #![feature(inplace_iteration)]\n #![feature(iter_advance_by)]\n #![feature(layout_for_ptr)]\n-#![feature(maybe_uninit_extra)]\n #![feature(maybe_uninit_slice)]\n #![cfg_attr(test, feature(new_uninit))]\n #![feature(nonnull_slice_from_raw_parts)]"}, {"sha": "dd2f73063566ecac13c38b560751772e447e3cde", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -330,7 +330,7 @@ impl<T> MaybeUninit<T> {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// #![feature(maybe_uninit_uninit_array, maybe_uninit_extra, maybe_uninit_slice)]\n+    /// #![feature(maybe_uninit_uninit_array, maybe_uninit_slice)]\n     ///\n     /// use std::mem::MaybeUninit;\n     ///\n@@ -662,7 +662,6 @@ impl<T> MaybeUninit<T> {\n     /// Correct usage of this method:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit_extra)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<u32>::uninit();\n@@ -683,7 +682,6 @@ impl<T> MaybeUninit<T> {\n     /// *Incorrect* usage of this method:\n     ///\n     /// ```rust,no_run\n-    /// #![feature(maybe_uninit_extra)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n@@ -693,8 +691,8 @@ impl<T> MaybeUninit<T> {\n     /// // We now created two copies of the same vector, leading to a double-free \u26a0\ufe0f when\n     /// // they both get dropped!\n     /// ```\n-    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n-    #[rustc_const_unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n+    #[stable(feature = \"maybe_uninit_extra\", since = \"1.60.0\")]\n+    #[rustc_const_unstable(feature = \"const_maybe_uninit_assume_init_read\", issue = \"63567\")]\n     #[inline(always)]\n     #[track_caller]\n     pub const unsafe fn assume_init_read(&self) -> T {\n@@ -728,7 +726,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// [`assume_init`]: MaybeUninit::assume_init\n     /// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n-    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n+    #[stable(feature = \"maybe_uninit_extra\", since = \"1.60.0\")]\n     pub unsafe fn assume_init_drop(&mut self) {\n         // SAFETY: the caller must guarantee that `self` is initialized and\n         // satisfies all invariants of `T`."}, {"sha": "841c114063dc1de7c783a6222dec1452fa512105", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -15,6 +15,7 @@\n #![feature(const_convert)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n #![feature(const_maybe_uninit_assume_init)]\n+#![feature(const_maybe_uninit_assume_init_read)]\n #![feature(const_num_from_num)]\n #![feature(const_ptr_read)]\n #![feature(const_ptr_write)]\n@@ -46,7 +47,6 @@\n #![feature(slice_take)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(maybe_uninit_array_assume_init)]\n-#![feature(maybe_uninit_extra)]\n #![feature(maybe_uninit_write_slice)]\n #![feature(min_specialization)]\n #![feature(numfmt)]"}, {"sha": "1721e16f3a686300c72e181d0a2ad3fedb5df993", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -297,7 +297,6 @@\n #![feature(llvm_asm)]\n #![feature(log_syntax)]\n #![feature(map_try_insert)]\n-#![feature(maybe_uninit_extra)]\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(maybe_uninit_write_slice)]"}, {"sha": "d60be193bda2b1108328ae68d8501656c0d0a63a", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -84,6 +84,39 @@ in documentation.\n `#![feature(doc_cfg)]` feature gate. For more information, see [its chapter in the Unstable\n Book][unstable-doc-cfg] and [its tracking issue][issue-doc-cfg].\n \n+### `doc_auto_cfg`: Automatically generate `#[doc(cfg)]`\n+\n+`doc_auto_cfg` is an extension to the `#[doc(cfg)]` feature. With it, you don't need to add\n+`#[doc(cfg(...)]` anymore unless you want to override the default behaviour. So if we take the\n+previous source code:\n+\n+```rust\n+#![feature(doc_auto_cfg)]\n+\n+/// Token struct that can only be used on Windows.\n+#[cfg(any(windows, doc))]\n+pub struct WindowsToken;\n+\n+/// Token struct that can only be used on Unix.\n+#[cfg(any(unix, doc))]\n+pub struct UnixToken;\n+\n+/// Token struct that is only available with the `serde` feature\n+#[cfg(feature = \"serde\")]\n+#[derive(serde::Deserialize)]\n+pub struct SerdeToken;\n+```\n+\n+It'll render almost the same, the difference being that `doc` will also be displayed. To fix this,\n+you can use `doc_cfg_hide`:\n+\n+```rust\n+#![feature(doc_cfg_hide)]\n+#![doc(cfg_hide(doc))]\n+```\n+\n+And `doc` won't show up anymore!\n+\n [cfg-doc]: ./advanced-features.md\n [unstable-doc-cfg]: ../unstable-book/language-features/doc-cfg.html\n [issue-doc-cfg]: https://github.com/rust-lang/rust/issues/43781"}, {"sha": "d5e5af7bbf8dd09332f95a396f09057f90e55705", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -240,7 +240,7 @@ pub(super) fn write_shared(\n     }\n \n     if (*cx.shared).layout.logo.is_empty() {\n-        write_toolchain(\"rust-logo.png\", static_files::RUST_LOGO)?;\n+        write_toolchain(\"rust-logo.svg\", static_files::RUST_LOGO_SVG)?;\n     }\n     if (*cx.shared).layout.favicon.is_empty() {\n         write_toolchain(\"favicon.svg\", static_files::RUST_FAVICON_SVG)?;"}, {"sha": "ea4b45cae1618e6e20e6d61897da953f34b66b30", "filename": "src/librustdoc/html/static/images/favicon-16x16.png", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Ffavicon-16x16.png", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Ffavicon-16x16.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Ffavicon-16x16.png?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc"}, {"sha": "69b8613ce1506e1c92b864f91cc46df06348c62b", "filename": "src/librustdoc/html/static/images/favicon-32x32.png", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Ffavicon-32x32.png", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Ffavicon-32x32.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Ffavicon-32x32.png?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc"}, {"sha": "74b4bd695045ebc52c21af95301adc9311ca881c", "filename": "src/librustdoc/html/static/images/rust-logo.png", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Frust-logo.png", "raw_url": "https://github.com/rust-lang/rust/raw/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Frust-logo.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Frust-logo.png?ref=02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609"}, {"sha": "62424d8ffd763e38983edac61971770e945ee5bb", "filename": "src/librustdoc/html/static/images/rust-logo.svg", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Frust-logo.svg", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Frust-logo.svg", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fimages%2Frust-logo.svg?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,61 @@\n+<svg version=\"1.1\" height=\"106\" width=\"106\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n+<g id=\"logo\" transform=\"translate(53, 53)\">\n+  <path id=\"r\" transform=\"translate(0.5, 0.5)\" stroke=\"black\" stroke-width=\"1\" stroke-linejoin=\"round\" d=\"\n+    M -9,-15 H 4 C 12,-15 12,-7 4,-7 H -9 Z\n+    M -40,22 H 0 V 11 H -9 V 3 H 1 C 12,3 6,22 15,22 H 40\n+    V 3 H 34 V 5 C 34,13 25,12 24,7 C 23,2 19,-2 18,-2 C 33,-10 24,-26 12,-26 H -35\n+    V -15 H -25 V 11 H -40 Z\" />\n+  <g id=\"gear\" mask=\"url(#holes)\">\n+    <circle r=\"43\" fill=\"none\" stroke=\"black\" stroke-width=\"9\" />\n+    <g id=\"cogs\">\n+      <polygon id=\"cog\" stroke=\"black\" stroke-width=\"3\" stroke-linejoin=\"round\" points=\"46,3 51,0 46,-3\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(11.25)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(22.50)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(33.75)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(45.00)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(56.25)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(67.50)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(78.75)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(90.00)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(101.25)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(112.50)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(123.75)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(135.00)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(146.25)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(157.50)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(168.75)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(180.00)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(191.25)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(202.50)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(213.75)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(225.00)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(236.25)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(247.50)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(258.75)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(270.00)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(281.25)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(292.50)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(303.75)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(315.00)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(326.25)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(337.50)\" />\n+      <use xlink:href=\"#cog\" transform=\"rotate(348.75)\" />\n+    </g>\n+    <g id=\"mounts\">\n+      <polygon id=\"mount\" stroke=\"black\" stroke-width=\"6\" stroke-linejoin=\"round\" points=\"-7,-42 0,-35 7,-42\" />\n+      <use xlink:href=\"#mount\" transform=\"rotate(72)\" />\n+      <use xlink:href=\"#mount\" transform=\"rotate(144)\" />\n+      <use xlink:href=\"#mount\" transform=\"rotate(216)\" />\n+      <use xlink:href=\"#mount\" transform=\"rotate(288)\" />\n+    </g>\n+  </g>\n+  <mask id=\"holes\">\n+    <rect x=\"-60\" y=\"-60\" width=\"120\" height=\"120\" fill=\"white\"/>\n+    <circle id=\"hole\" cy=\"-40\" r=\"3\" />\n+    <use xlink:href=\"#hole\" transform=\"rotate(72)\" />\n+    <use xlink:href=\"#hole\" transform=\"rotate(144)\" />\n+    <use xlink:href=\"#hole\" transform=\"rotate(216)\" />\n+    <use xlink:href=\"#hole\" transform=\"rotate(288)\" />\n+  </mask>\n+</g>\n+</svg>"}, {"sha": "cd369a93d8283cff07f7fafe1075d2ab2dd0aee0", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -67,8 +67,9 @@ crate static LICENSE_APACHE: &[u8] = include_bytes!(\"static/LICENSE-APACHE.txt\")\n /// The contents of `LICENSE-MIT.txt`, the text of the MIT License.\n crate static LICENSE_MIT: &[u8] = include_bytes!(\"static/LICENSE-MIT.txt\");\n \n-/// The contents of `rust-logo.png`, the default icon of the documentation.\n-crate static RUST_LOGO: &[u8] = include_bytes!(\"static/images/rust-logo.png\");\n+/// The contents of `rust-logo.svg`, the default icon of the documentation.\n+crate static RUST_LOGO_SVG: &[u8] = include_bytes!(\"static/images/rust-logo.svg\");\n+\n /// The default documentation favicons (SVG and PNG fallbacks)\n crate static RUST_FAVICON_SVG: &[u8] = include_bytes!(\"static/images/favicon.svg\");\n crate static RUST_FAVICON_PNG_16: &[u8] = include_bytes!(\"static/images/favicon-16x16.png\");"}, {"sha": "02808754b539b006c6428468744e5e53f4f3df8c", "filename": "src/librustdoc/templates/page.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Flibrustdoc%2Ftemplates%2Fpage.html", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Flibrustdoc%2Ftemplates%2Fpage.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftemplates%2Fpage.html?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -79,7 +79,7 @@\n                 {%- if !layout.logo.is_empty()  %}\n                     <img src=\"{{layout.logo}}\" alt=\"logo\"> {#- -#}\n                 {%- else -%}\n-                    <img class=\"rust-logo\" src=\"{{static_root_path|safe}}rust-logo{{page.resource_suffix}}.png\" alt=\"logo\"> {#- -#}\n+                    <img class=\"rust-logo\" src=\"{{static_root_path|safe}}rust-logo{{page.resource_suffix}}.svg\" alt=\"logo\"> {#- -#}\n                 {%- endif -%}\n             </div>\n         </a> {#- -#}\n@@ -92,7 +92,7 @@\n                     {%- if !layout.logo.is_empty()  %}\n                         <img src=\"{{layout.logo}}\" alt=\"logo\"> {#- -#}\n                     {%- else -%}\n-                        <img class=\"rust-logo\" src=\"{{static_root_path|safe}}rust-logo{{page.resource_suffix}}.png\" alt=\"logo\"> {#- -#}\n+                        <img class=\"rust-logo\" src=\"{{static_root_path|safe}}rust-logo{{page.resource_suffix}}.svg\" alt=\"logo\"> {#- -#}\n                     {%- endif -%}\n                 </a> {#- -#}\n                 <nav class=\"sub\"> {#- -#}"}, {"sha": "459b01a9960d20b18ff4e005cb16740b5bf3c3ec", "filename": "src/librustdoc/templates/print_item.html", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Flibrustdoc%2Ftemplates%2Fprint_item.html", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Flibrustdoc%2Ftemplates%2Fprint_item.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftemplates%2Fprint_item.html?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -16,12 +16,12 @@ <h1 class=\"fqn\"> {#- -#}\n     </h1> {#- -#}\n     <span class=\"out-of-band\"> {#- -#}\n         {% if !stability_since_raw.is_empty() %}\n-        {{- stability_since_raw|safe -}} \u00b7\n+        {{- stability_since_raw|safe -}} \u00b7 {# -#}\n         {% endif %}\n         {%- match src_href -%}\n             {%- when Some with (href) -%}\n-                <a class=\"srclink\" href=\"{{href|safe}}\" title=\"goto source code\">source</a>\n-            {%- else -%} \u00b7\n+                <a class=\"srclink\" href=\"{{href|safe}}\" title=\"goto source code\">source</a> \u00b7 {# -#}\n+            {%- else -%}\n         {%- endmatch -%}\n         <a id=\"toggle-all-docs\" href=\"javascript:void(0)\" title=\"collapse all docs\"> {#- -#}\n             [<span class=\"inner\">&#x2212;</span>] {#- -#}"}, {"sha": "2d29f0592e14bf6d41098f880d3591e37e3bff90", "filename": "src/test/ui/infinite/infinite-autoderef.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Finfinite%2Finfinite-autoderef.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Finfinite%2Finfinite-autoderef.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-autoderef.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -2,9 +2,12 @@ error[E0308]: mismatched types\n   --> $DIR/infinite-autoderef.rs:20:13\n    |\n LL |         x = Box::new(x);\n-   |             ^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n-   |             |\n-   |             cyclic type of infinite size\n+   |             ^^^^^^^^^^^ cyclic type of infinite size\n+   |\n+help: consider unboxing the value\n+   |\n+LL |         x = *Box::new(x);\n+   |             +\n \n error[E0055]: reached the recursion limit while auto-dereferencing `Foo`\n   --> $DIR/infinite-autoderef.rs:25:5"}, {"sha": "b68c3fa5bcc9c478240e2e8af4260a3867765f4e", "filename": "src/test/ui/occurs-check-2.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Foccurs-check-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Foccurs-check-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foccurs-check-2.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -2,9 +2,12 @@ error[E0308]: mismatched types\n   --> $DIR/occurs-check-2.rs:7:9\n    |\n LL |     f = Box::new(g);\n-   |         ^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n-   |         |\n-   |         cyclic type of infinite size\n+   |         ^^^^^^^^^^^ cyclic type of infinite size\n+   |\n+help: consider unboxing the value\n+   |\n+LL |     f = *Box::new(g);\n+   |         +\n \n error: aborting due to previous error\n "}, {"sha": "fdbbdc3abb377b68ffc65520a8a6324dc6d9a8cb", "filename": "src/test/ui/occurs-check.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Foccurs-check.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Foccurs-check.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foccurs-check.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -2,9 +2,12 @@ error[E0308]: mismatched types\n   --> $DIR/occurs-check.rs:5:9\n    |\n LL |     f = Box::new(f);\n-   |         ^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n-   |         |\n-   |         cyclic type of infinite size\n+   |         ^^^^^^^^^^^ cyclic type of infinite size\n+   |\n+help: consider unboxing the value\n+   |\n+LL |     f = *Box::new(f);\n+   |         +\n \n error: aborting due to previous error\n "}, {"sha": "2c3610fb24d4e952e72299ca597ea1e8b6760b4d", "filename": "src/test/ui/return/tail-expr-as-potential-return.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Freturn%2Ftail-expr-as-potential-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Freturn%2Ftail-expr-as-potential-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn%2Ftail-expr-as-potential-return.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,10 +1,32 @@\n+// > Suggest `return`ing tail expressions that match return type\n+// >\n+// > Some newcomers are confused by the behavior of tail expressions,\n+// > interpreting that \"leaving out the `;` makes it the return value\".\n+// > To help them go in the right direction, suggest using `return` instead\n+// > when applicable.\n+// (original commit description for this test)\n+//\n+// This test was amended to also serve as a regression test for #92308, where\n+// this suggestion would not trigger with async functions.\n+//\n+// edition:2018\n+\n fn main() {\n     let _ = foo(true);\n }\n \n fn foo(x: bool) -> Result<f64, i32> {\n     if x {\n         Err(42) //~ ERROR mismatched types\n+                //| HELP you might have meant to return this value\n+    }\n+    Ok(42.0)\n+}\n+\n+async fn bar(x: bool) -> Result<f64, i32> {\n+    if x {\n+        Err(42) //~ ERROR mismatched types\n+                //| HELP you might have meant to return this value\n     }\n     Ok(42.0)\n }"}, {"sha": "dec1cbc4624ef5bece1d9262d612b21663ccb1e7", "filename": "src/test/ui/return/tail-expr-as-potential-return.stderr", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Freturn%2Ftail-expr-as-potential-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Freturn%2Ftail-expr-as-potential-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn%2Ftail-expr-as-potential-return.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,9 +1,10 @@\n error[E0308]: mismatched types\n-  --> $DIR/tail-expr-as-potential-return.rs:7:9\n+  --> $DIR/tail-expr-as-potential-return.rs:28:9\n    |\n LL | /     if x {\n LL | |         Err(42)\n    | |         ^^^^^^^ expected `()`, found enum `Result`\n+LL | |                 //| HELP you might have meant to return this value\n LL | |     }\n    | |_____- expected this to be `()`\n    |\n@@ -14,6 +15,23 @@ help: you might have meant to return this value\n LL |         return Err(42);\n    |         ++++++        +\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/tail-expr-as-potential-return.rs:20:9\n+   |\n+LL | /     if x {\n+LL | |         Err(42)\n+   | |         ^^^^^^^ expected `()`, found enum `Result`\n+LL | |                 //| HELP you might have meant to return this value\n+LL | |     }\n+   | |_____- expected this to be `()`\n+   |\n+   = note: expected unit type `()`\n+                   found enum `Result<_, {integer}>`\n+help: you might have meant to return this value\n+   |\n+LL |         return Err(42);\n+   |         ++++++        +\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "5a964c5d5cc6693e1667e60a7e1f647b42da75be", "filename": "src/test/ui/span/coerce-suggestions.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fcoerce-suggestions.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -38,9 +38,12 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-suggestions.rs:17:9\n    |\n LL |     f = Box::new(f);\n-   |         ^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n-   |         |\n-   |         cyclic type of infinite size\n+   |         ^^^^^^^^^^^ cyclic type of infinite size\n+   |\n+help: consider unboxing the value\n+   |\n+LL |     f = *Box::new(f);\n+   |         +\n \n error[E0308]: mismatched types\n   --> $DIR/coerce-suggestions.rs:21:9"}, {"sha": "e79be2f6127c1fb840e2f134cff6c6a93ab6c0e8", "filename": "src/test/ui/suggestions/boxed-variant-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -8,7 +8,7 @@ fn foo(x: Ty) -> Ty {\n         Ty::Unit => Ty::Unit,\n         Ty::List(elem) => foo(elem),\n         //~^ ERROR mismatched types\n-        //~| HELP try dereferencing the `Box`\n+        //~| HELP consider unboxing the value\n         //~| HELP try wrapping\n     }\n }"}, {"sha": "9a31dc89197e36209a295f4c8e319761ee1448c9", "filename": "src/test/ui/suggestions/boxed-variant-field.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fboxed-variant-field.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -6,7 +6,7 @@ LL |         Ty::List(elem) => foo(elem),\n    |\n    = note: expected enum `Ty`\n             found struct `Box<Ty>`\n-help: try dereferencing the `Box`\n+help: consider unboxing the value\n    |\n LL |         Ty::List(elem) => foo(*elem),\n    |                               +"}, {"sha": "34d4d9eaded8ac167dc6bcbc7ec23c415dc37e68", "filename": "src/test/ui/terr-sorts.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Fterr-sorts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftest%2Fui%2Fterr-sorts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fterr-sorts.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -6,7 +6,7 @@ LL |     want_foo(b);\n    |\n    = note: expected struct `Foo`\n               found struct `Box<Foo>`\n-help: try dereferencing the `Box`\n+help: consider unboxing the value\n    |\n LL |     want_foo(*b);\n    |              +"}, {"sha": "f3dd9275a42be6cd00a326912009fa3cb8a4df66", "filename": "src/tools/clippy/.cargo/config.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2F.cargo%2Fconfig.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2F.cargo%2Fconfig.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.cargo%2Fconfig.toml?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -2,9 +2,12 @@\n uitest = \"test --test compile-test\"\n dev = \"run --package clippy_dev --bin clippy_dev --manifest-path clippy_dev/Cargo.toml --\"\n lintcheck = \"run --package lintcheck --bin lintcheck --manifest-path lintcheck/Cargo.toml  -- \"\n-collect-metadata = \"test --test dogfood --features metadata-collector-lint -- run_metadata_collection_lint --ignored\"\n+collect-metadata = \"test --test dogfood --features internal -- run_metadata_collection_lint --ignored\"\n \n [build]\n # -Zbinary-dep-depinfo allows us to track which rlib files to use for compiling UI tests\n rustflags = [\"-Zunstable-options\", \"-Zbinary-dep-depinfo\"]\n target-dir = \"target\"\n+\n+[unstable]\n+binary-dep-depinfo = true"}, {"sha": "116ae031bb719d7b8a6b62223308a01289c09e1a", "filename": "src/tools/clippy/.github/workflows/clippy.yml", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -49,17 +49,17 @@ jobs:\n         echo \"LD_LIBRARY_PATH=${SYSROOT}/lib${LD_LIBRARY_PATH+:${LD_LIBRARY_PATH}}\" >> $GITHUB_ENV\n \n     - name: Build\n-      run: cargo build --features deny-warnings,internal-lints,metadata-collector-lint\n+      run: cargo build --features deny-warnings,internal\n \n     - name: Test\n-      run: cargo test --features deny-warnings,internal-lints,metadata-collector-lint\n+      run: cargo test --features deny-warnings,internal\n \n     - name: Test clippy_lints\n-      run: cargo test --features deny-warnings,internal-lints,metadata-collector-lint\n+      run: cargo test --features deny-warnings,internal\n       working-directory: clippy_lints\n \n     - name: Test clippy_utils\n-      run: cargo test --features deny-warnings,internal-lints,metadata-collector-lint\n+      run: cargo test --features deny-warnings,internal\n       working-directory: clippy_utils\n \n     - name: Test rustc_tools_util\n@@ -70,14 +70,6 @@ jobs:\n       run: cargo test --features deny-warnings\n       working-directory: clippy_dev\n \n-    - name: Test cargo-clippy\n-      run: ../target/debug/cargo-clippy\n-      working-directory: clippy_workspace_tests\n-\n-    - name: Test cargo-clippy --fix\n-      run: ../target/debug/cargo-clippy clippy --fix\n-      working-directory: clippy_workspace_tests\n-\n     - name: Test clippy-driver\n       run: bash .github/driver.sh\n       env:"}, {"sha": "989667037c1cb4e23a0dcb0e2802023258510e4f", "filename": "src/tools/clippy/.github/workflows/clippy_bors.yml", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -112,17 +112,22 @@ jobs:\n         echo \"$SYSROOT/bin\" >> $GITHUB_PATH\n \n     - name: Build\n-      run: cargo build --features deny-warnings,internal-lints,metadata-collector-lint\n+      run: cargo build --features deny-warnings,internal\n \n     - name: Test\n-      run: cargo test --features deny-warnings,internal-lints,metadata-collector-lint\n+      if: runner.os == 'Linux'\n+      run: cargo test --features deny-warnings,internal\n+\n+    - name: Test\n+      if: runner.os != 'Linux'\n+      run: cargo test --features deny-warnings,internal -- --skip dogfood\n \n     - name: Test clippy_lints\n-      run: cargo test --features deny-warnings,internal-lints,metadata-collector-lint\n+      run: cargo test --features deny-warnings,internal\n       working-directory: clippy_lints\n \n     - name: Test clippy_utils\n-      run: cargo test --features deny-warnings,internal-lints,metadata-collector-lint\n+      run: cargo test --features deny-warnings,internal\n       working-directory: clippy_utils\n \n     - name: Test rustc_tools_util\n@@ -133,14 +138,6 @@ jobs:\n       run: cargo test --features deny-warnings\n       working-directory: clippy_dev\n \n-    - name: Test cargo-clippy\n-      run: ../target/debug/cargo-clippy\n-      working-directory: clippy_workspace_tests\n-\n-    - name: Test cargo-clippy --fix\n-      run: ../target/debug/cargo-clippy clippy --fix\n-      working-directory: clippy_workspace_tests\n-\n     - name: Test clippy-driver\n       run: bash .github/driver.sh\n       env:"}, {"sha": "3e50c45a9b63ec8922446ef907cb10e220a33772", "filename": "src/tools/clippy/.gitignore", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.gitignore?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -19,7 +19,6 @@ out\n /target\n /clippy_lints/target\n /clippy_utils/target\n-/clippy_workspace_tests/target\n /clippy_dev/target\n /lintcheck/target\n /rustc_tools_util/target"}, {"sha": "8f4da9a382792a31443c9a81c6db1794ff2a04d1", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -2887,6 +2887,7 @@ Released 2018-09-13\n [`blocks_in_if_conditions`]: https://rust-lang.github.io/rust-clippy/master/index.html#blocks_in_if_conditions\n [`bool_assert_comparison`]: https://rust-lang.github.io/rust-clippy/master/index.html#bool_assert_comparison\n [`bool_comparison`]: https://rust-lang.github.io/rust-clippy/master/index.html#bool_comparison\n+[`borrow_as_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrow_as_ptr\n [`borrow_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrow_interior_mutable_const\n [`borrowed_box`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrowed_box\n [`box_collection`]: https://rust-lang.github.io/rust-clippy/master/index.html#box_collection\n@@ -3070,6 +3071,7 @@ Released 2018-09-13\n [`main_recursion`]: https://rust-lang.github.io/rust-clippy/master/index.html#main_recursion\n [`manual_assert`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_assert\n [`manual_async_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_async_fn\n+[`manual_bits`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_bits\n [`manual_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_filter_map\n [`manual_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find_map\n [`manual_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_flatten\n@@ -3253,6 +3255,7 @@ Released 2018-09-13\n [`should_implement_trait`]: https://rust-lang.github.io/rust-clippy/master/index.html#should_implement_trait\n [`similar_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#similar_names\n [`single_char_add_str`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_add_str\n+[`single_char_lifetime_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_lifetime_names\n [`single_char_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_char_pattern\n [`single_component_path_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_component_path_imports\n [`single_element_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_element_loop"}, {"sha": "e445889a58f77d7b4db6354b2ad7aa3c4a5a9e3f", "filename": "src/tools/clippy/Cargo.toml", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCargo.toml?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.1.59\"\n+version = \"0.1.60\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\"\n@@ -47,16 +47,17 @@ itertools = \"0.10\"\n quote = \"1.0\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n syn = { version = \"1.0\", features = [\"full\"] }\n+futures = \"0.3\"\n parking_lot = \"0.11.2\"\n+tokio = { version = \"1\", features = [\"io-util\"] }\n \n [build-dependencies]\n rustc_tools_util = { version = \"0.2\", path = \"rustc_tools_util\" }\n \n [features]\n deny-warnings = [\"clippy_lints/deny-warnings\"]\n integration = [\"tempfile\"]\n-internal-lints = [\"clippy_lints/internal-lints\"]\n-metadata-collector-lint = [\"internal-lints\", \"clippy_lints/metadata-collector-lint\"]\n+internal = [\"clippy_lints/internal\"]\n \n [package.metadata.rust-analyzer]\n # This package uses #[feature(rustc_private)]"}, {"sha": "f001a42d917d3134db7457aeb95713434bd3084c", "filename": "src/tools/clippy/README.md", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FREADME.md?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -5,7 +5,7 @@\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are over 450 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are over 500 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n Lints are divided into categories, each with a default [lint level](https://doc.rust-lang.org/rustc/lints/levels.html).\n You can choose how much Clippy is supposed to ~~annoy~~ help you by changing the lint level by category.\n@@ -37,8 +37,8 @@ Table of contents:\n \n ## Usage\n \n-Below are instructions on how to use Clippy as a subcommand, compiled from source\n-or in Travis CI.\n+Below are instructions on how to use Clippy as a cargo subcommand,\n+in projects that do not use cargo, or in Travis CI.\n \n ### As a cargo subcommand (`cargo clippy`)\n \n@@ -98,22 +98,18 @@ If you want to run Clippy **only** on the given crate, use the `--no-deps` optio\n cargo clippy -p example -- --no-deps\n ```\n \n-### As a rustc replacement (`clippy-driver`)\n+### Using `clippy-driver`\n \n-Clippy can also be used in projects that do not use cargo. To do so, you will need to replace\n-your `rustc` compilation commands with `clippy-driver`. For example, if your project runs:\n-\n-```terminal\n-rustc --edition 2018 -Cpanic=abort foo.rs\n-```\n-\n-Then, to enable Clippy, you will need to call:\n+Clippy can also be used in projects that do not use cargo. To do so, run `clippy-driver`\n+with the same arguments you use for `rustc`. For example:\n \n ```terminal\n clippy-driver --edition 2018 -Cpanic=abort foo.rs\n ```\n \n-Note that `rustc` will still run, i.e. it will still emit the output files it normally does.\n+Note that `clippy-driver` is designed for running Clippy only and should not be used as a general\n+replacement for `rustc`. `clippy-driver` may produce artifacts that are not optimized as expected,\n+for example.\n \n ### Travis CI\n "}, {"sha": "d513a229b7e386d3178c7055a2140f8d263c8a8a", "filename": "src/tools/clippy/clippy_dev/src/fmt.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -3,7 +3,7 @@ use itertools::Itertools;\n use shell_escape::escape;\n use std::ffi::{OsStr, OsString};\n use std::path::Path;\n-use std::process::{self, Command};\n+use std::process::{self, Command, Stdio};\n use std::{fs, io};\n use walkdir::WalkDir;\n \n@@ -31,6 +31,7 @@ impl From<walkdir::Error> for CliError {\n struct FmtContext {\n     check: bool,\n     verbose: bool,\n+    rustfmt_path: String,\n }\n \n // the \"main\" function of cargo dev fmt\n@@ -102,7 +103,23 @@ Please revert the changes to Cargo.tomls first.\"\n         }\n     }\n \n-    let context = FmtContext { check, verbose };\n+    let output = Command::new(\"rustup\")\n+        .args([\"which\", \"rustfmt\"])\n+        .stderr(Stdio::inherit())\n+        .output()\n+        .expect(\"error running `rustup which rustfmt`\");\n+    if !output.status.success() {\n+        eprintln!(\"`rustup which rustfmt` did not execute successfully\");\n+        process::exit(1);\n+    }\n+    let mut rustfmt_path = String::from_utf8(output.stdout).expect(\"invalid rustfmt path\");\n+    rustfmt_path.truncate(rustfmt_path.trim_end().len());\n+\n+    let context = FmtContext {\n+        check,\n+        verbose,\n+        rustfmt_path,\n+    };\n     let result = try_run(&context);\n     let code = match result {\n         Ok(true) => 0,\n@@ -141,8 +158,12 @@ fn exec(\n         println!(\"{}\", format_command(&program, &dir, args));\n     }\n \n-    let child = Command::new(&program).current_dir(&dir).args(args.iter()).spawn()?;\n-    let output = child.wait_with_output()?;\n+    let output = Command::new(&program)\n+        .env(\"RUSTFMT\", &context.rustfmt_path)\n+        .current_dir(&dir)\n+        .args(args.iter())\n+        .output()\n+        .unwrap();\n     let success = output.status.success();\n \n     if !context.check && !success {\n@@ -159,7 +180,6 @@ fn exec(\n fn cargo_fmt(context: &FmtContext, path: &Path) -> Result<bool, CliError> {\n     let mut args = vec![\"fmt\", \"--all\"];\n     if context.check {\n-        args.push(\"--\");\n         args.push(\"--check\");\n     }\n     let success = exec(context, \"cargo\", path, &args)?;\n@@ -200,7 +220,7 @@ fn rustfmt(context: &FmtContext, paths: impl Iterator<Item = OsString>) -> Resul\n     }\n     args.extend(paths);\n \n-    let success = exec(context, \"rustfmt\", std::env::current_dir()?, &args)?;\n+    let success = exec(context, &context.rustfmt_path, std::env::current_dir()?, &args)?;\n \n     Ok(success)\n }"}, {"sha": "d368ef1f46a2a98866e6aedcf32581c9ce17c047", "filename": "src/tools/clippy/clippy_dev/src/update_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fupdate_lints.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -321,7 +321,7 @@ fn gen_register_lint_list<'a>(\n \n     for (is_public, module_name, lint_name) in details {\n         if !is_public {\n-            output.push_str(\"    #[cfg(feature = \\\"internal-lints\\\")]\\n\");\n+            output.push_str(\"    #[cfg(feature = \\\"internal\\\")]\\n\");\n         }\n         output.push_str(&format!(\"    {}::{},\\n\", module_name, lint_name));\n     }"}, {"sha": "2053ca64ba23d19626dfdbaaebd826f70d82a4db", "filename": "src/tools/clippy/clippy_lints/Cargo.toml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_lints\"\n-version = \"0.1.59\"\n+version = \"0.1.60\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\"\n@@ -30,8 +30,7 @@ url = { version = \"2.2\", features = [\"serde\"] }\n [features]\n deny-warnings = [\"clippy_utils/deny-warnings\"]\n # build clippy with internal lints enabled, off by default\n-internal-lints = [\"clippy_utils/internal-lints\"]\n-metadata-collector-lint = [\"serde_json\", \"clippy_utils/metadata-collector-lint\"]\n+internal = [\"clippy_utils/internal\", \"serde_json\"]\n \n [package.metadata.rust-analyzer]\n # This crate uses #[feature(rustc_private)]"}, {"sha": "c82837746bd5d1086ea8fbfb29a3f8b62b00abfd", "filename": "src/tools/clippy/clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 25, "deletions": 95, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,12 +1,10 @@\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::higher;\n-use clippy_utils::source::snippet_opt;\n-use clippy_utils::{is_direct_expn_of, is_expn_of, match_panic_call, peel_blocks};\n-use if_chain::if_chain;\n-use rustc_hir::{Expr, ExprKind, UnOp};\n+use clippy_utils::macros::{find_assert_args, root_macro_call_first_node, PanicExpn};\n+use rustc_hir::Expr;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -36,107 +34,39 @@ declare_lint_pass!(AssertionsOnConstants => [ASSERTIONS_ON_CONSTANTS]);\n \n impl<'tcx> LateLintPass<'tcx> for AssertionsOnConstants {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        let lint_true = |is_debug: bool| {\n-            span_lint_and_help(\n-                cx,\n-                ASSERTIONS_ON_CONSTANTS,\n-                e.span,\n-                if is_debug {\n-                    \"`debug_assert!(true)` will be optimized out by the compiler\"\n-                } else {\n-                    \"`assert!(true)` will be optimized out by the compiler\"\n-                },\n-                None,\n-                \"remove it\",\n-            );\n+        let Some(macro_call) = root_macro_call_first_node(cx, e) else { return };\n+        let is_debug = match cx.tcx.get_diagnostic_name(macro_call.def_id) {\n+            Some(sym::debug_assert_macro) => true,\n+            Some(sym::assert_macro) => false,\n+            _ => return,\n         };\n-        let lint_false_without_message = || {\n+        let Some((condition, panic_expn)) = find_assert_args(cx, e, macro_call.expn) else { return };\n+        let Some((Constant::Bool(val), _)) = constant(cx, cx.typeck_results(), condition) else { return };\n+        if val {\n             span_lint_and_help(\n                 cx,\n                 ASSERTIONS_ON_CONSTANTS,\n-                e.span,\n-                \"`assert!(false)` should probably be replaced\",\n+                macro_call.span,\n+                &format!(\n+                    \"`{}!(true)` will be optimized out by the compiler\",\n+                    cx.tcx.item_name(macro_call.def_id)\n+                ),\n                 None,\n-                \"use `panic!()` or `unreachable!()`\",\n+                \"remove it\",\n             );\n-        };\n-        let lint_false_with_message = |panic_message: String| {\n+        } else if !is_debug {\n+            let (assert_arg, panic_arg) = match panic_expn {\n+                PanicExpn::Empty => (\"\", \"\"),\n+                _ => (\", ..\", \"..\"),\n+            };\n             span_lint_and_help(\n                 cx,\n                 ASSERTIONS_ON_CONSTANTS,\n-                e.span,\n-                &format!(\"`assert!(false, {})` should probably be replaced\", panic_message),\n+                macro_call.span,\n+                &format!(\"`assert!(false{})` should probably be replaced\", assert_arg),\n                 None,\n-                &format!(\"use `panic!({})` or `unreachable!({})`\", panic_message, panic_message),\n+                &format!(\"use `panic!({})` or `unreachable!({0})`\", panic_arg),\n             );\n-        };\n-\n-        if let Some(debug_assert_span) = is_expn_of(e.span, \"debug_assert\") {\n-            if debug_assert_span.from_expansion() {\n-                return;\n-            }\n-            if_chain! {\n-                if let ExprKind::Unary(_, lit) = e.kind;\n-                if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), lit);\n-                if is_true;\n-                then {\n-                    lint_true(true);\n-                }\n-            };\n-        } else if let Some(assert_span) = is_direct_expn_of(e.span, \"assert\") {\n-            if assert_span.from_expansion() {\n-                return;\n-            }\n-            if let Some(assert_match) = match_assert_with_message(cx, e) {\n-                match assert_match {\n-                    // matched assert but not message\n-                    AssertKind::WithoutMessage(false) => lint_false_without_message(),\n-                    AssertKind::WithoutMessage(true) | AssertKind::WithMessage(_, true) => lint_true(false),\n-                    AssertKind::WithMessage(panic_message, false) => lint_false_with_message(panic_message),\n-                };\n-            }\n-        }\n-    }\n-}\n-\n-/// Result of calling `match_assert_with_message`.\n-enum AssertKind {\n-    WithMessage(String, bool),\n-    WithoutMessage(bool),\n-}\n-\n-/// Check if the expression matches\n-///\n-/// ```rust,ignore\n-/// if !c {\n-///   {\n-///     ::std::rt::begin_panic(message, _)\n-///   }\n-/// }\n-/// ```\n-///\n-/// where `message` is any expression and `c` is a constant bool.\n-fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<AssertKind> {\n-    if_chain! {\n-        if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n-        if let ExprKind::Unary(UnOp::Not, expr) = cond.kind;\n-        // bind the first argument of the `assert!` macro\n-        if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), expr);\n-        let begin_panic_call = peel_blocks(then);\n-        // function call\n-        if let Some(arg) = match_panic_call(cx, begin_panic_call);\n-        // bind the second argument of the `assert!` macro if it exists\n-        if let panic_message = snippet_opt(cx, arg.span);\n-        // second argument of begin_panic is irrelevant\n-        // as is the second match arm\n-        then {\n-            // an empty message occurs when it was generated by the macro\n-            // (and not passed by the user)\n-            return panic_message\n-                .filter(|msg| !msg.is_empty())\n-                .map(|msg| AssertKind::WithMessage(msg, is_true))\n-                .or(Some(AssertKind::WithoutMessage(is_true)));\n         }\n     }\n-    None\n }"}, {"sha": "a58d12ddd6b4372278e4569126f2233d81183e28", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,9 +1,10 @@\n //! checks for attributes\n \n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::macros::{is_panic, macro_backtrace};\n use clippy_utils::msrvs;\n use clippy_utils::source::{first_line_of_span, is_present_in_source, snippet_opt, without_block_comments};\n-use clippy_utils::{extract_msrv_attr, match_panic_def_id, meets_msrv};\n+use clippy_utils::{extract_msrv_attr, meets_msrv};\n use if_chain::if_chain;\n use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_errors::Applicability;\n@@ -443,20 +444,15 @@ fn is_relevant_block(cx: &LateContext<'_>, typeck_results: &ty::TypeckResults<'_\n }\n \n fn is_relevant_expr(cx: &LateContext<'_>, typeck_results: &ty::TypeckResults<'_>, expr: &Expr<'_>) -> bool {\n+    if macro_backtrace(expr.span).last().map_or(false, |macro_call| {\n+        is_panic(cx, macro_call.def_id) || cx.tcx.item_name(macro_call.def_id) == sym::unreachable\n+    }) {\n+        return false;\n+    }\n     match &expr.kind {\n         ExprKind::Block(block, _) => is_relevant_block(cx, typeck_results, block),\n         ExprKind::Ret(Some(e)) => is_relevant_expr(cx, typeck_results, e),\n         ExprKind::Ret(None) | ExprKind::Break(_, None) => false,\n-        ExprKind::Call(path_expr, _) => {\n-            if let ExprKind::Path(qpath) = &path_expr.kind {\n-                typeck_results\n-                    .qpath_res(qpath, path_expr.hir_id)\n-                    .opt_def_id()\n-                    .map_or(true, |fun_id| !match_panic_def_id(cx, fun_id))\n-            } else {\n-                true\n-            }\n-        },\n         _ => true,\n     }\n }"}, {"sha": "c50e214be288dd4a9389ad67d254bd9be3153a67", "filename": "src/tools/clippy/clippy_lints/src/bool_assert_comparison.rs", "status": "modified", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_assert_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbool_assert_comparison.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,4 +1,5 @@\n-use clippy_utils::{diagnostics::span_lint_and_sugg, higher, is_direct_expn_of, ty::implements_trait};\n+use clippy_utils::macros::{find_assert_eq_args, root_macro_call_first_node};\n+use clippy_utils::{diagnostics::span_lint_and_sugg, ty::implements_trait};\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, Lit};\n@@ -41,7 +42,7 @@ fn is_bool_lit(e: &Expr<'_>) -> bool {\n     ) && !e.span.from_expansion()\n }\n \n-fn is_impl_not_trait_with_bool_out(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n+fn is_impl_not_trait_with_bool_out(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(e);\n \n     cx.tcx\n@@ -66,44 +67,40 @@ fn is_impl_not_trait_with_bool_out(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) ->\n \n impl<'tcx> LateLintPass<'tcx> for BoolAssertComparison {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let macros = [\"assert_eq\", \"debug_assert_eq\"];\n-        let inverted_macros = [\"assert_ne\", \"debug_assert_ne\"];\n-\n-        for mac in macros.iter().chain(inverted_macros.iter()) {\n-            if let Some(span) = is_direct_expn_of(expr.span, mac) {\n-                if let Some(args) = higher::extract_assert_macro_args(expr) {\n-                    if let [a, b, ..] = args[..] {\n-                        let nb_bool_args = usize::from(is_bool_lit(a)) + usize::from(is_bool_lit(b));\n-\n-                        if nb_bool_args != 1 {\n-                            // If there are two boolean arguments, we definitely don't understand\n-                            // what's going on, so better leave things as is...\n-                            //\n-                            // Or there is simply no boolean and then we can leave things as is!\n-                            return;\n-                        }\n-\n-                        if !is_impl_not_trait_with_bool_out(cx, a) || !is_impl_not_trait_with_bool_out(cx, b) {\n-                            // At this point the expression which is not a boolean\n-                            // literal does not implement Not trait with a bool output,\n-                            // so we cannot suggest to rewrite our code\n-                            return;\n-                        }\n+        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return };\n+        let macro_name = cx.tcx.item_name(macro_call.def_id);\n+        if !matches!(\n+            macro_name.as_str(),\n+            \"assert_eq\" | \"debug_assert_eq\" | \"assert_ne\" | \"debug_assert_ne\"\n+        ) {\n+            return;\n+        }\n+        let Some ((a, b, _)) = find_assert_eq_args(cx, expr, macro_call.expn) else { return };\n+        if !(is_bool_lit(a) ^ is_bool_lit(b)) {\n+            // If there are two boolean arguments, we definitely don't understand\n+            // what's going on, so better leave things as is...\n+            //\n+            // Or there is simply no boolean and then we can leave things as is!\n+            return;\n+        }\n \n-                        let non_eq_mac = &mac[..mac.len() - 3];\n-                        span_lint_and_sugg(\n-                            cx,\n-                            BOOL_ASSERT_COMPARISON,\n-                            span,\n-                            &format!(\"used `{}!` with a literal bool\", mac),\n-                            \"replace it with\",\n-                            format!(\"{}!(..)\", non_eq_mac),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        return;\n-                    }\n-                }\n-            }\n+        if !is_impl_not_trait_with_bool_out(cx, a) || !is_impl_not_trait_with_bool_out(cx, b) {\n+            // At this point the expression which is not a boolean\n+            // literal does not implement Not trait with a bool output,\n+            // so we cannot suggest to rewrite our code\n+            return;\n         }\n+\n+        let macro_name = macro_name.as_str();\n+        let non_eq_mac = &macro_name[..macro_name.len() - 3];\n+        span_lint_and_sugg(\n+            cx,\n+            BOOL_ASSERT_COMPARISON,\n+            macro_call.span,\n+            &format!(\"used `{}!` with a literal bool\", macro_name),\n+            \"replace it with\",\n+            format!(\"{}!(..)\", non_eq_mac),\n+            Applicability::MaybeIncorrect,\n+        );\n     }\n }"}, {"sha": "b8f5217af2b7d68dcda02e14ea6bd66783b0b7c5", "filename": "src/tools/clippy/clippy_lints/src/borrow_as_ptr.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fborrow_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fborrow_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fborrow_as_ptr.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,97 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_no_std_crate;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::{meets_msrv, msrvs};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, TyKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for the usage of `&expr as *const T` or\n+    /// `&mut expr as *mut T`, and suggest using `ptr::addr_of` or\n+    /// `ptr::addr_of_mut` instead.\n+    ///\n+    /// ### Why is this bad?\n+    /// This would improve readability and avoid creating a reference\n+    /// that points to an uninitialized value or unaligned place.\n+    /// Read the `ptr::addr_of` docs for more information.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let val = 1;\n+    /// let p = &val as *const i32;\n+    ///\n+    /// let mut val_mut = 1;\n+    /// let p_mut = &mut val_mut as *mut i32;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let val = 1;\n+    /// let p = std::ptr::addr_of!(val);\n+    ///\n+    /// let mut val_mut = 1;\n+    /// let p_mut = std::ptr::addr_of_mut!(val_mut);\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub BORROW_AS_PTR,\n+    pedantic,\n+    \"borrowing just to cast to a raw pointer\"\n+}\n+\n+impl_lint_pass!(BorrowAsPtr => [BORROW_AS_PTR]);\n+\n+pub struct BorrowAsPtr {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl BorrowAsPtr {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for BorrowAsPtr {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if !meets_msrv(self.msrv.as_ref(), &msrvs::BORROW_AS_PTR) {\n+            return;\n+        }\n+\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let ExprKind::Cast(left_expr, ty) = &expr.kind;\n+            if let TyKind::Ptr(_) = ty.kind;\n+            if let ExprKind::AddrOf(BorrowKind::Ref, mutability, e) = &left_expr.kind;\n+\n+            then {\n+                let core_or_std = if is_no_std_crate(cx) { \"core\" } else { \"std\" };\n+                let macro_name = match mutability {\n+                    Mutability::Not => \"addr_of\",\n+                    Mutability::Mut => \"addr_of_mut\",\n+                };\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    BORROW_AS_PTR,\n+                    expr.span,\n+                    \"borrow as raw pointer\",\n+                    \"try\",\n+                    format!(\n+                        \"{}::ptr::{}!({})\",\n+                        core_or_std,\n+                        macro_name,\n+                        snippet_opt(cx, e.span).unwrap()\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "e8f39cd37090d2f14fd64fedb0ae629ae19eb942", "filename": "src/tools/clippy/clippy_lints/src/case_sensitive_file_extension_comparisons.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -67,7 +67,7 @@ fn check_case_sensitive_file_extension_comparison(ctx: &LateContext<'_>, expr: &\n     None\n }\n \n-impl LateLintPass<'tcx> for CaseSensitiveFileExtensionComparisons {\n+impl<'tcx> LateLintPass<'tcx> for CaseSensitiveFileExtensionComparisons {\n     fn check_expr(&mut self, ctx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if let Some(span) = check_case_sensitive_file_extension_comparison(ctx, expr) {\n             span_lint_and_help("}, {"sha": "b9de5510455b9e7bdb3351b8e61c7bf27514d990", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -9,7 +9,7 @@ use rustc_span::symbol::sym;\n \n use super::CAST_PTR_ALIGNMENT;\n \n-pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if let ExprKind::Cast(cast_expr, cast_to) = expr.kind {\n         if is_hir_ty_cfg_dependant(cx, cast_to) {\n             return;"}, {"sha": "15f2f81f4079e5b2e88b66809e797f845249c3d1", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_ref_to_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ref_to_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ref_to_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_ref_to_mut.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::ty;\n \n use super::CAST_REF_TO_MUT;\n \n-pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Unary(UnOp::Deref, e) = &expr.kind;\n         if let ExprKind::Cast(e, t) = &e.kind;"}, {"sha": "7cc406018dbe0ab7c3395959899a63567c1a8c33", "filename": "src/tools/clippy/clippy_lints/src/casts/char_lit_as_u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fchar_lit_as_u8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fchar_lit_as_u8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fchar_lit_as_u8.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::ty::{self, UintTy};\n \n use super::CHAR_LIT_AS_U8;\n \n-pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Cast(e, _) = &expr.kind;\n         if let ExprKind::Lit(l) = &e.kind;"}, {"sha": "fb04f93fbcf9774190153ab78751a369d15a3408", "filename": "src/tools/clippy/clippy_lints/src/casts/ptr_as_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -12,7 +12,7 @@ use rustc_semver::RustcVersion;\n \n use super::PTR_AS_PTR;\n \n-pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: &Option<RustcVersion>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: &Option<RustcVersion>) {\n     if !meets_msrv(msrv.as_ref(), &msrvs::POINTER_CAST) {\n         return;\n     }"}, {"sha": "73ce656ad151437d490bf435e525c9d8c1797258", "filename": "src/tools/clippy/clippy_lints/src/copies.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -316,7 +316,7 @@ struct BlockEqual {\n \n /// This function can also trigger the `IF_SAME_THEN_ELSE` in which case it'll return `None` to\n /// abort any further processing and avoid duplicate lint triggers.\n-fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> Option<BlockEqual> {\n+fn scan_block_for_eq(cx: &LateContext<'_>, blocks: &[&Block<'_>]) -> Option<BlockEqual> {\n     let mut start_eq = usize::MAX;\n     let mut end_eq = usize::MAX;\n     let mut expr_eq = true;\n@@ -385,11 +385,7 @@ fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> Option<\n     })\n }\n \n-fn check_for_warn_of_moved_symbol(\n-    cx: &LateContext<'tcx>,\n-    symbols: &FxHashSet<Symbol>,\n-    if_expr: &'tcx Expr<'_>,\n-) -> bool {\n+fn check_for_warn_of_moved_symbol(cx: &LateContext<'_>, symbols: &FxHashSet<Symbol>, if_expr: &Expr<'_>) -> bool {\n     get_enclosing_block(cx, if_expr.hir_id).map_or(false, |block| {\n         let ignore_span = block.span.shrink_to_lo().to(if_expr.span);\n \n@@ -419,13 +415,13 @@ fn check_for_warn_of_moved_symbol(\n }\n \n fn emit_branches_sharing_code_lint(\n-    cx: &LateContext<'tcx>,\n+    cx: &LateContext<'_>,\n     start_stmts: usize,\n     end_stmts: usize,\n     lint_end: bool,\n     warn_about_moved_symbol: bool,\n-    blocks: &[&Block<'tcx>],\n-    if_expr: &'tcx Expr<'_>,\n+    blocks: &[&Block<'_>],\n+    if_expr: &Expr<'_>,\n ) {\n     if start_stmts == 0 && !lint_end {\n         return;"}, {"sha": "3070588483c21b33d97fc3ab305cce090b096c0f", "filename": "src/tools/clippy/clippy_lints/src/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -77,7 +77,7 @@ pub struct Default {\n \n impl_lint_pass!(Default => [DEFAULT_TRAIT_ACCESS, FIELD_REASSIGN_WITH_DEFAULT]);\n \n-impl LateLintPass<'_> for Default {\n+impl<'tcx> LateLintPass<'tcx> for Default {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if !expr.span.from_expansion();\n@@ -110,7 +110,7 @@ impl LateLintPass<'_> for Default {\n     }\n \n     #[allow(clippy::too_many_lines)]\n-    fn check_block<'tcx>(&mut self, cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n         // start from the `let mut _ = _::default();` and look at all the following\n         // statements, see if they re-assign the fields of the binding\n         let stmts_head = match block.stmts {"}, {"sha": "66b5f49817d8daed5ddd1b235b366553581c85a9", "filename": "src/tools/clippy/clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -54,7 +54,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(DefaultNumericFallback => [DEFAULT_NUMERIC_FALLBACK]);\n \n-impl LateLintPass<'_> for DefaultNumericFallback {\n+impl<'tcx> LateLintPass<'tcx> for DefaultNumericFallback {\n     fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n         let mut visitor = NumericFallbackVisitor::new(cx);\n         visitor.visit_body(body);"}, {"sha": "bf077a212fd0fcfadc1a78b6f9dfbd86af1a1e59", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -355,7 +355,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n     }\n }\n \n-fn try_parse_ref_op(\n+fn try_parse_ref_op<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     typeck: &'tcx TypeckResults<'_>,\n     expr: &'tcx Expr<'_>,\n@@ -387,7 +387,7 @@ fn try_parse_ref_op(\n \n // Checks whether the type for a deref call actually changed the type, not just the mutability of\n // the reference.\n-fn deref_method_same_type(result_ty: Ty<'tcx>, arg_ty: Ty<'tcx>) -> bool {\n+fn deref_method_same_type(result_ty: Ty<'_>, arg_ty: Ty<'_>) -> bool {\n     match (result_ty.kind(), arg_ty.kind()) {\n         (ty::Ref(_, result_ty, _), ty::Ref(_, arg_ty, _)) => TyS::same_type(result_ty, arg_ty),\n \n@@ -457,7 +457,7 @@ fn is_linted_explicit_deref_position(parent: Option<Node<'_>>, child_id: HirId,\n }\n \n /// Adjustments are sometimes made in the parent block rather than the expression itself.\n-fn find_adjustments(\n+fn find_adjustments<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     typeck: &'tcx TypeckResults<'_>,\n     expr: &'tcx Expr<'_>,\n@@ -499,7 +499,7 @@ fn find_adjustments(\n }\n \n #[allow(clippy::needless_pass_by_value)]\n-fn report(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data: StateData) {\n+fn report(cx: &LateContext<'_>, expr: &Expr<'_>, state: State, data: StateData) {\n     match state {\n         State::DerefMethod {\n             ty_changed_count,\n@@ -568,7 +568,7 @@ fn report(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data: Stat\n }\n \n impl Dereferencing {\n-    fn check_local_usage(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, local: HirId) {\n+    fn check_local_usage(&mut self, cx: &LateContext<'_>, e: &Expr<'_>, local: HirId) {\n         if let Some(outer_pat) = self.ref_locals.get_mut(&local) {\n             if let Some(pat) = outer_pat {\n                 // Check for auto-deref"}, {"sha": "73c00d97020bedf2a6badb9b698b89a59ce9b4de", "filename": "src/tools/clippy/clippy_lints/src/disallowed_methods.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_methods.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -11,6 +11,9 @@ declare_clippy_lint! {\n     /// ### What it does\n     /// Denies the configured methods and functions in clippy.toml\n     ///\n+    /// Note: Even though this lint is warn-by-default, it will only trigger if\n+    /// methods are defined in the clippy.toml file.\n+    ///\n     /// ### Why is this bad?\n     /// Some methods are undesirable in certain contexts, and it's beneficial to\n     /// lint for them as needed.\n@@ -49,14 +52,14 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.49.0\"]\n     pub DISALLOWED_METHODS,\n-    nursery,\n+    style,\n     \"use of a disallowed method call\"\n }\n \n #[derive(Clone, Debug)]\n pub struct DisallowedMethods {\n     conf_disallowed: Vec<conf::DisallowedMethod>,\n-    disallowed: DefIdMap<Option<String>>,\n+    disallowed: DefIdMap<usize>,\n }\n \n impl DisallowedMethods {\n@@ -72,17 +75,10 @@ impl_lint_pass!(DisallowedMethods => [DISALLOWED_METHODS]);\n \n impl<'tcx> LateLintPass<'tcx> for DisallowedMethods {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n-        for conf in &self.conf_disallowed {\n-            let (path, reason) = match conf {\n-                conf::DisallowedMethod::Simple(path) => (path, None),\n-                conf::DisallowedMethod::WithReason { path, reason } => (\n-                    path,\n-                    reason.as_ref().map(|reason| format!(\"{} (from clippy.toml)\", reason)),\n-                ),\n-            };\n-            let segs: Vec<_> = path.split(\"::\").collect();\n+        for (index, conf) in self.conf_disallowed.iter().enumerate() {\n+            let segs: Vec<_> = conf.path().split(\"::\").collect();\n             if let Res::Def(_, id) = clippy_utils::path_to_res(cx, &segs) {\n-                self.disallowed.insert(id, reason);\n+                self.disallowed.insert(id, index);\n             }\n         }\n     }\n@@ -92,15 +88,17 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedMethods {\n             Some(def_id) => def_id,\n             None => return,\n         };\n-        let reason = match self.disallowed.get(&def_id) {\n-            Some(reason) => reason,\n+        let conf = match self.disallowed.get(&def_id) {\n+            Some(&index) => &self.conf_disallowed[index],\n             None => return,\n         };\n-        let func_path = cx.tcx.def_path_str(def_id);\n-        let msg = format!(\"use of a disallowed method `{}`\", func_path);\n+        let msg = format!(\"use of a disallowed method `{}`\", conf.path());\n         span_lint_and_then(cx, DISALLOWED_METHODS, expr.span, &msg, |diag| {\n-            if let Some(reason) = reason {\n-                diag.note(reason);\n+            if let conf::DisallowedMethod::WithReason {\n+                reason: Some(reason), ..\n+            } = conf\n+            {\n+                diag.note(&format!(\"{} (from clippy.toml)\", reason));\n             }\n         });\n     }"}, {"sha": "ea4b49b46fe9f6d6e5ca9e6f7e8ee6d3e8f4112b", "filename": "src/tools/clippy/clippy_lints/src/disallowed_types.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_types.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -14,6 +14,9 @@ declare_clippy_lint! {\n     /// ### What it does\n     /// Denies the configured types in clippy.toml.\n     ///\n+    /// Note: Even though this lint is warn-by-default, it will only trigger if\n+    /// types are defined in the clippy.toml file.\n+    ///\n     /// ### Why is this bad?\n     /// Some types are undesirable in certain contexts.\n     ///\n@@ -44,7 +47,7 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.55.0\"]\n     pub DISALLOWED_TYPES,\n-    nursery,\n+    style,\n     \"use of disallowed types\"\n }\n #[derive(Clone, Debug)]"}, {"sha": "cb7d5ac73941a1712af8b28984857780f8edf812", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,8 +1,9 @@\n use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_note, span_lint_and_then};\n+use clippy_utils::macros::{is_panic, root_macro_call_first_node};\n use clippy_utils::source::{first_line_of_span, snippet_with_applicability};\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{is_entrypoint_fn, is_expn_of, match_panic_def_id, method_chain_args, return_ty};\n+use clippy_utils::{is_entrypoint_fn, method_chain_args, return_ty};\n use if_chain::if_chain;\n use itertools::Itertools;\n use rustc_ast::ast::{Async, AttrKind, Attribute, Fn, FnRetTy, ItemKind};\n@@ -13,7 +14,7 @@ use rustc_errors::emitter::EmitterWriter;\n use rustc_errors::{Applicability, Handler, SuggestionStyle};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_hir::{AnonConst, Expr, ExprKind, QPath};\n+use rustc_hir::{AnonConst, Expr};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n@@ -805,24 +806,17 @@ impl<'a, 'tcx> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n             return;\n         }\n \n-        // check for `begin_panic`\n-        if_chain! {\n-            if let ExprKind::Call(func_expr, _) = expr.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, path)) = func_expr.kind;\n-            if let Some(path_def_id) = path.res.opt_def_id();\n-            if match_panic_def_id(self.cx, path_def_id);\n-            if is_expn_of(expr.span, \"unreachable\").is_none();\n-            if !is_expn_of_debug_assertions(expr.span);\n-            then {\n-                self.panic_span = Some(expr.span);\n+        if let Some(macro_call) = root_macro_call_first_node(self.cx, expr) {\n+            if is_panic(self.cx, macro_call.def_id)\n+                || matches!(\n+                    self.cx.tcx.item_name(macro_call.def_id).as_str(),\n+                    \"assert\" | \"assert_eq\" | \"assert_ne\" | \"todo\"\n+                )\n+            {\n+                self.panic_span = Some(macro_call.span);\n             }\n         }\n \n-        // check for `assert_eq` or `assert_ne`\n-        if is_expn_of(expr.span, \"assert_eq\").is_some() || is_expn_of(expr.span, \"assert_ne\").is_some() {\n-            self.panic_span = Some(expr.span);\n-        }\n-\n         // check for `unwrap`\n         if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n             let receiver_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n@@ -844,8 +838,3 @@ impl<'a, 'tcx> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n         NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n     }\n }\n-\n-fn is_expn_of_debug_assertions(span: Span) -> bool {\n-    const MACRO_NAMES: &[&str] = &[\"debug_assert\", \"debug_assert_eq\", \"debug_assert_ne\"];\n-    MACRO_NAMES.iter().any(|name| is_expn_of(span, name).is_some())\n-}"}, {"sha": "3ce239273e2529cd3f10d875493b54468e76771f", "filename": "src/tools/clippy/clippy_lints/src/entry.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -233,7 +233,7 @@ struct ContainsExpr<'tcx> {\n     key: &'tcx Expr<'tcx>,\n     call_ctxt: SyntaxContext,\n }\n-fn try_parse_contains(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<(MapType, ContainsExpr<'tcx>)> {\n+fn try_parse_contains<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<(MapType, ContainsExpr<'tcx>)> {\n     let mut negated = false;\n     let expr = peel_hir_expr_while(expr, |e| match e.kind {\n         ExprKind::Unary(UnOp::Not, e) => {\n@@ -280,7 +280,7 @@ struct InsertExpr<'tcx> {\n     key: &'tcx Expr<'tcx>,\n     value: &'tcx Expr<'tcx>,\n }\n-fn try_parse_insert(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<InsertExpr<'tcx>> {\n+fn try_parse_insert<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<InsertExpr<'tcx>> {\n     if let ExprKind::MethodCall(_, _, [map, key, value], _) = expr.kind {\n         let id = cx.typeck_results().type_dependent_def_id(expr.hir_id)?;\n         if match_def_path(cx, id, &paths::BTREEMAP_INSERT) || match_def_path(cx, id, &paths::HASHMAP_INSERT) {\n@@ -301,7 +301,7 @@ enum Edit<'tcx> {\n     /// An insertion into the map.\n     Insertion(Insertion<'tcx>),\n }\n-impl Edit<'tcx> {\n+impl<'tcx> Edit<'tcx> {\n     fn as_insertion(self) -> Option<Insertion<'tcx>> {\n         if let Self::Insertion(i) = self { Some(i) } else { None }\n     }\n@@ -532,7 +532,7 @@ struct InsertSearchResults<'tcx> {\n     allow_insert_closure: bool,\n     is_single_insert: bool,\n }\n-impl InsertSearchResults<'tcx> {\n+impl<'tcx> InsertSearchResults<'tcx> {\n     fn as_single_insertion(&self) -> Option<Insertion<'tcx>> {\n         self.is_single_insert.then(|| self.edits[0].as_insertion().unwrap())\n     }\n@@ -633,7 +633,7 @@ impl InsertSearchResults<'tcx> {\n     }\n }\n \n-fn find_insert_calls(\n+fn find_insert_calls<'tcx>(\n     cx: &LateContext<'tcx>,\n     contains_expr: &ContainsExpr<'tcx>,\n     expr: &'tcx Expr<'_>,"}, {"sha": "df75b815436b896bd20160303ebe983d8a79b5d0", "filename": "src/tools/clippy/clippy_lints/src/eq_op.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,10 +1,11 @@\n use clippy_utils::diagnostics::{multispan_sugg, span_lint, span_lint_and_then};\n+use clippy_utils::macros::{find_assert_eq_args, first_node_macro_backtrace};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::{implements_trait, is_copy};\n-use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, higher, is_expn_of, is_in_test_function};\n+use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, is_in_test_function};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, StmtKind};\n+use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -68,32 +69,26 @@ declare_clippy_lint! {\n \n declare_lint_pass!(EqOp => [EQ_OP, OP_REF]);\n \n-const ASSERT_MACRO_NAMES: [&str; 4] = [\"assert_eq\", \"assert_ne\", \"debug_assert_eq\", \"debug_assert_ne\"];\n-\n impl<'tcx> LateLintPass<'tcx> for EqOp {\n     #[allow(clippy::similar_names, clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::Block(block, _) = e.kind {\n-            for stmt in block.stmts {\n-                for amn in &ASSERT_MACRO_NAMES {\n-                    if_chain! {\n-                        if is_expn_of(stmt.span, amn).is_some();\n-                        if let StmtKind::Semi(matchexpr) = stmt.kind;\n-                        if let Some(macro_args) = higher::extract_assert_macro_args(matchexpr);\n-                        if macro_args.len() == 2;\n-                        let (lhs, rhs) = (macro_args[0], macro_args[1]);\n-                        if eq_expr_value(cx, lhs, rhs);\n-                        if !is_in_test_function(cx.tcx, e.hir_id);\n-                        then {\n-                            span_lint(\n-                                cx,\n-                                EQ_OP,\n-                                lhs.span.to(rhs.span),\n-                                &format!(\"identical args used in this `{}!` macro call\", amn),\n-                            );\n-                        }\n-                    }\n-                }\n+        if_chain! {\n+            if let Some((macro_call, macro_name)) = first_node_macro_backtrace(cx, e).find_map(|macro_call| {\n+                let name = cx.tcx.item_name(macro_call.def_id);\n+                matches!(name.as_str(), \"assert_eq\" | \"assert_ne\" | \"debug_assert_eq\" | \"debug_assert_ne\")\n+                    .then(|| (macro_call, name))\n+            });\n+            if let Some((lhs, rhs, _)) = find_assert_eq_args(cx, e, macro_call.expn);\n+            if eq_expr_value(cx, lhs, rhs);\n+            if macro_call.is_local();\n+            if !is_in_test_function(cx.tcx, e.hir_id);\n+            then {\n+                span_lint(\n+                    cx,\n+                    EQ_OP,\n+                    lhs.span.to(rhs.span),\n+                    &format!(\"identical args used in this `{}!` macro call\", macro_name),\n+                );\n             }\n         }\n         if let ExprKind::Binary(op, left, right) = e.kind {"}, {"sha": "cf47e581ccb48f26166502236527f0004983f6b2", "filename": "src/tools/clippy/clippy_lints/src/equatable_if_let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -56,7 +56,7 @@ fn unary_pattern(pat: &Pat<'_>) -> bool {\n     }\n }\n \n-fn is_structural_partial_eq(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: Ty<'tcx>) -> bool {\n+fn is_structural_partial_eq<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: Ty<'tcx>) -> bool {\n     if let Some(def_id) = cx.tcx.lang_items().eq_trait() {\n         implements_trait(cx, ty, def_id, &[other.into()])\n     } else {"}, {"sha": "c1a84973c42114945130d4c5e9fbeeba75042efd", "filename": "src/tools/clippy/clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ferasing_op.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,9 +1,11 @@\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::same_type_and_consts;\n+\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::TypeckResults;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -35,24 +37,40 @@ impl<'tcx> LateLintPass<'tcx> for ErasingOp {\n             return;\n         }\n         if let ExprKind::Binary(ref cmp, left, right) = e.kind {\n+            let tck = cx.typeck_results();\n             match cmp.node {\n                 BinOpKind::Mul | BinOpKind::BitAnd => {\n-                    check(cx, left, e.span);\n-                    check(cx, right, e.span);\n+                    check(cx, tck, left, right, e);\n+                    check(cx, tck, right, left, e);\n                 },\n-                BinOpKind::Div => check(cx, left, e.span),\n+                BinOpKind::Div => check(cx, tck, left, right, e),\n                 _ => (),\n             }\n         }\n     }\n }\n \n-fn check(cx: &LateContext<'_>, e: &Expr<'_>, span: Span) {\n-    if constant_simple(cx, cx.typeck_results(), e) == Some(Constant::Int(0)) {\n+fn different_types(tck: &TypeckResults<'_>, input: &Expr<'_>, output: &Expr<'_>) -> bool {\n+    let input_ty = tck.expr_ty(input).peel_refs();\n+    let output_ty = tck.expr_ty(output).peel_refs();\n+    !same_type_and_consts(input_ty, output_ty)\n+}\n+\n+fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    tck: &TypeckResults<'tcx>,\n+    op: &Expr<'tcx>,\n+    other: &Expr<'tcx>,\n+    parent: &Expr<'tcx>,\n+) {\n+    if constant_simple(cx, tck, op) == Some(Constant::Int(0)) {\n+        if different_types(tck, other, parent) {\n+            return;\n+        }\n         span_lint(\n             cx,\n             ERASING_OP,\n-            span,\n+            parent.span,\n             \"this operation will always return zero. This is likely not the intended outcome\",\n         );\n     }"}, {"sha": "b22515a39079a2518ece04f75e10d3601e235fc2", "filename": "src/tools/clippy/clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,6 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::higher::VecArgs;\n use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::usage::local_used_after_expr;\n use clippy_utils::{get_enclosing_loop_or_closure, higher, path_to_local, path_to_local_id};\n use if_chain::if_chain;\n@@ -12,6 +13,7 @@ use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, ClosureKind, Ty, TypeFoldable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -113,6 +115,9 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n             // A type param function ref like `T::f` is not 'static, however\n             // it is if cast like `T::f as fn()`. This seems like a rustc bug.\n             if !substs.types().any(|t| matches!(t.kind(), ty::Param(_)));\n+            let callee_ty_unadjusted = cx.typeck_results().expr_ty(callee).peel_refs();\n+            if !is_type_diagnostic_item(cx, callee_ty_unadjusted, sym::Arc);\n+            if !is_type_diagnostic_item(cx, callee_ty_unadjusted, sym::Rc);\n             then {\n                 span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure\", |diag| {\n                     if let Some(mut snippet) = snippet_opt(cx, callee.span) {"}, {"sha": "98e5234e0aa94640a928d5eff4814b8c9a465307", "filename": "src/tools/clippy/clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n-use clippy_utils::higher::FormatArgsExpn;\n+use clippy_utils::macros::FormatArgsExpn;\n use clippy_utils::{is_expn_of, match_function_call, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -48,7 +48,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n             } else {\n                 None\n             };\n-            if let Some(format_args) = FormatArgsExpn::parse(write_arg);\n+            if let Some(format_args) = FormatArgsExpn::parse(cx, write_arg);\n             then {\n                 let calling_macro =\n                     // ordering is important here, since `writeln!` uses `write!` internally\n@@ -80,7 +80,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n                     )\n                 };\n                 let msg = format!(\"use of `{}.unwrap()`\", used);\n-                if let [write_output] = *format_args.format_string_symbols {\n+                if let [write_output] = *format_args.format_string_parts {\n                     let mut write_output = write_output.to_string();\n                     if write_output.ends_with('\\n') {\n                         write_output.pop();"}, {"sha": "02f1baf27fae81cc184cf64a5fdfe723d70c84cc", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,6 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::macros::{is_panic, root_macro_call_first_node};\n+use clippy_utils::method_chain_args;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_expn_of, match_panic_def_id, method_chain_args};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -68,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for FallibleImplFrom {\n \n fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[hir::ImplItemRef]) {\n     use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-    use rustc_hir::{Expr, ExprKind, ImplItemKind, QPath};\n+    use rustc_hir::{Expr, ImplItemKind};\n \n     struct FindPanicUnwrap<'a, 'tcx> {\n         lcx: &'a LateContext<'tcx>,\n@@ -80,14 +81,8 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n         type Map = Map<'tcx>;\n \n         fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-            // check for `begin_panic`\n-            if_chain! {\n-                if let ExprKind::Call(func_expr, _) = expr.kind;\n-                if let ExprKind::Path(QPath::Resolved(_, path)) = func_expr.kind;\n-                if let Some(path_def_id) = path.res.opt_def_id();\n-                if match_panic_def_id(self.lcx, path_def_id);\n-                if is_expn_of(expr.span, \"unreachable\").is_none();\n-                then {\n+            if let Some(macro_call) = root_macro_call_first_node(self.lcx, expr) {\n+                if is_panic(self.lcx, macro_call.def_id) {\n                     self.result.push(expr.span);\n                 }\n             }"}, {"sha": "688d8f8630f3fa38b84e55dd4489309b62ba2f73", "filename": "src/tools/clippy/clippy_lints/src/format.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher::FormatExpn;\n+use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn};\n use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use if_chain::if_chain;\n@@ -43,38 +43,41 @@ declare_lint_pass!(UselessFormat => [USELESS_FORMAT]);\n \n impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let FormatExpn { call_site, format_args } = match FormatExpn::parse(expr) {\n-            Some(e) if !e.call_site.from_expansion() => e,\n-            _ => return,\n+        let (format_args, call_site) = if_chain! {\n+            if let Some(macro_call) = root_macro_call_first_node(cx, expr);\n+            if cx.tcx.is_diagnostic_item(sym::format_macro, macro_call.def_id);\n+            if let Some(format_args) = FormatArgsExpn::find_nested(cx, expr, macro_call.expn);\n+            then {\n+                (format_args, macro_call.span)\n+            } else {\n+                return\n+            }\n         };\n \n         let mut applicability = Applicability::MachineApplicable;\n         if format_args.value_args.is_empty() {\n-            if format_args.format_string_parts.is_empty() {\n-                span_useless_format_empty(cx, call_site, \"String::new()\".to_owned(), applicability);\n-            } else {\n-                if_chain! {\n-                    if let [e] = &*format_args.format_string_parts;\n-                    if let ExprKind::Lit(lit) = &e.kind;\n-                    if let Some(s_src) = snippet_opt(cx, lit.span);\n-                    then {\n+            match *format_args.format_string_parts {\n+                [] => span_useless_format_empty(cx, call_site, \"String::new()\".to_owned(), applicability),\n+                [_] => {\n+                    if let Some(s_src) = snippet_opt(cx, format_args.format_string_span) {\n                         // Simulate macro expansion, converting {{ and }} to { and }.\n                         let s_expand = s_src.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n                         let sugg = format!(\"{}.to_string()\", s_expand);\n                         span_useless_format(cx, call_site, sugg, applicability);\n                     }\n-                }\n+                },\n+                [..] => {},\n             }\n         } else if let [value] = *format_args.value_args {\n             if_chain! {\n-                if format_args.format_string_symbols == [kw::Empty];\n+                if format_args.format_string_parts == [kw::Empty];\n                 if match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n                     ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(sym::String, adt.did),\n                     ty::Str => true,\n                     _ => false,\n                 };\n                 if let Some(args) = format_args.args();\n-                if args.iter().all(|arg| arg.is_display() && !arg.has_string_formatting());\n+                if args.iter().all(|arg| arg.format_trait == sym::Display && !arg.has_string_formatting());\n                 then {\n                     let is_new_string = match value.kind {\n                         ExprKind::Binary(..) => true,"}, {"sha": "ae423d799d71a3defb511ef01a02e13c1ea84241", "filename": "src/tools/clippy/clippy_lints/src/format_args.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::higher::{FormatArgsArg, FormatArgsExpn, FormatExpn};\n+use clippy_utils::macros::{FormatArgsArg, FormatArgsExpn};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::implements_trait;\n use clippy_utils::{is_diag_trait_item, match_def_path, paths};\n@@ -83,7 +83,7 @@ const FORMAT_MACRO_DIAG_ITEMS: &[Symbol] = &[sym::format_macro, sym::std_panic_m\n impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if_chain! {\n-            if let Some(format_args) = FormatArgsExpn::parse(expr);\n+            if let Some(format_args) = FormatArgsExpn::parse(cx, expr);\n             let expr_expn_data = expr.span.ctxt().outer_expn_data();\n             let outermost_expn_data = outermost_expn_data(expr_expn_data);\n             if let Some(macro_def_id) = outermost_expn_data.macro_def_id;\n@@ -97,7 +97,7 @@ impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n             if let Some(args) = format_args.args();\n             then {\n                 for (i, arg) in args.iter().enumerate() {\n-                    if !arg.is_display() {\n+                    if arg.format_trait != sym::Display {\n                         continue;\n                     }\n                     if arg.has_string_formatting() {\n@@ -106,8 +106,8 @@ impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n                     if is_aliased(&args, i) {\n                         continue;\n                     }\n-                    check_format_in_format_args(cx, outermost_expn_data.call_site, name, arg);\n-                    check_to_string_in_format_args(cx, name, arg);\n+                    check_format_in_format_args(cx, outermost_expn_data.call_site, name, arg.value);\n+                    check_to_string_in_format_args(cx, name, arg.value);\n                 }\n             }\n         }\n@@ -122,30 +122,31 @@ fn outermost_expn_data(expn_data: ExpnData) -> ExpnData {\n     }\n }\n \n-fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symbol, arg: &FormatArgsArg<'_>) {\n-    if_chain! {\n-        if FormatExpn::parse(arg.value).is_some();\n-        if !arg.value.span.ctxt().outer_expn_data().call_site.from_expansion();\n-        then {\n-            span_lint_and_then(\n-                cx,\n-                FORMAT_IN_FORMAT_ARGS,\n-                call_site,\n-                &format!(\"`format!` in `{}!` args\", name),\n-                |diag| {\n-                    diag.help(&format!(\n-                        \"combine the `format!(..)` arguments with the outer `{}!(..)` call\",\n-                        name\n-                    ));\n-                    diag.help(\"or consider changing `format!` to `format_args!`\");\n-                },\n-            );\n-        }\n+fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symbol, arg: &Expr<'_>) {\n+    let expn_data = arg.span.ctxt().outer_expn_data();\n+    if expn_data.call_site.from_expansion() {\n+        return;\n+    }\n+    let Some(mac_id) = expn_data.macro_def_id else { return };\n+    if !cx.tcx.is_diagnostic_item(sym::format_macro, mac_id) {\n+        return;\n     }\n+    span_lint_and_then(\n+        cx,\n+        FORMAT_IN_FORMAT_ARGS,\n+        call_site,\n+        &format!(\"`format!` in `{}!` args\", name),\n+        |diag| {\n+            diag.help(&format!(\n+                \"combine the `format!(..)` arguments with the outer `{}!(..)` call\",\n+                name\n+            ));\n+            diag.help(\"or consider changing `format!` to `format_args!`\");\n+        },\n+    );\n }\n \n-fn check_to_string_in_format_args<'tcx>(cx: &LateContext<'tcx>, name: Symbol, arg: &FormatArgsArg<'tcx>) {\n-    let value = arg.value;\n+fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Expr<'_>) {\n     if_chain! {\n         if !value.span.from_expansion();\n         if let ExprKind::MethodCall(_, _, [receiver], _) = value.kind;"}, {"sha": "5ece2cc5ac4f7dd3b509a1dc262b5b1df53f5eae", "filename": "src/tools/clippy/clippy_lints/src/from_over_into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -53,7 +53,7 @@ impl FromOverInto {\n \n impl_lint_pass!(FromOverInto => [FROM_OVER_INTO]);\n \n-impl LateLintPass<'_> for FromOverInto {\n+impl<'tcx> LateLintPass<'tcx> for FromOverInto {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         if !meets_msrv(self.msrv.as_ref(), &msrvs::RE_REBALANCING_COHERENCE) {\n             return;"}, {"sha": "57b0751320521b5bab69b34e34a0196e6517213a", "filename": "src/tools/clippy/clippy_lints/src/from_str_radix_10.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_str_radix_10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_str_radix_10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_str_radix_10.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -43,7 +43,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(FromStrRadix10 => [FROM_STR_RADIX_10]);\n \n-impl LateLintPass<'tcx> for FromStrRadix10 {\n+impl<'tcx> LateLintPass<'tcx> for FromStrRadix10 {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, exp: &Expr<'tcx>) {\n         if_chain! {\n             if let ExprKind::Call(maybe_path, arguments) = &exp.kind;"}, {"sha": "f2b4aefaead5284124e845c8847e79eecff5fedd", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -18,7 +18,7 @@ use clippy_utils::{match_def_path, must_use_attr, return_ty, trait_ref_of_method\n \n use super::{DOUBLE_MUST_USE, MUST_USE_CANDIDATE, MUST_USE_UNIT};\n \n-pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n+pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n     let attrs = cx.tcx.hir().attrs(item.hir_id());\n     let attr = must_use_attr(attrs);\n     if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n@@ -40,7 +40,7 @@ pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n     }\n }\n \n-pub(super) fn check_impl_item(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n+pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n     if let hir::ImplItemKind::Fn(ref sig, ref body_id) = item.kind {\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n@@ -62,7 +62,7 @@ pub(super) fn check_impl_item(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<\n     }\n }\n \n-pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n     if let hir::TraitItemKind::Fn(ref sig, ref eid) = item.kind {\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());"}, {"sha": "6d829a18b2e0927a0ef6ae95bf186fa15797b952", "filename": "src/tools/clippy/clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -9,7 +9,7 @@ use clippy_utils::{iter_input_pats, path_to_local};\n \n use super::NOT_UNSAFE_PTR_ARG_DEREF;\n \n-pub(super) fn check_fn(\n+pub(super) fn check_fn<'tcx>(\n     cx: &LateContext<'tcx>,\n     kind: intravisit::FnKind<'tcx>,\n     decl: &'tcx hir::FnDecl<'tcx>,\n@@ -25,14 +25,14 @@ pub(super) fn check_fn(\n     check_raw_ptr(cx, unsafety, decl, body, cx.tcx.hir().local_def_id(hir_id));\n }\n \n-pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n     if let hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(eid)) = item.kind {\n         let body = cx.tcx.hir().body(eid);\n         check_raw_ptr(cx, sig.header.unsafety, sig.decl, body, item.def_id);\n     }\n }\n \n-fn check_raw_ptr(\n+fn check_raw_ptr<'tcx>(\n     cx: &LateContext<'tcx>,\n     unsafety: hir::Unsafety,\n     decl: &'tcx hir::FnDecl<'tcx>,"}, {"sha": "73f08a04989734eb2168c63bd3f34c39a34d5c6f", "filename": "src/tools/clippy/clippy_lints/src/functions/result_unit_err.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -13,7 +13,7 @@ use clippy_utils::ty::is_type_diagnostic_item;\n \n use super::RESULT_UNIT_ERR;\n \n-pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n+pub(super) fn check_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n     if let hir::ItemKind::Fn(ref sig, ref _generics, _) = item.kind {\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n@@ -23,7 +23,7 @@ pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n     }\n }\n \n-pub(super) fn check_impl_item(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n+pub(super) fn check_impl_item(cx: &LateContext<'_>, item: &hir::ImplItem<'_>) {\n     if let hir::ImplItemKind::Fn(ref sig, _) = item.kind {\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n@@ -33,7 +33,7 @@ pub(super) fn check_impl_item(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<\n     }\n }\n \n-pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+pub(super) fn check_trait_item(cx: &LateContext<'_>, item: &hir::TraitItem<'_>) {\n     if let hir::TraitItemKind::Fn(ref sig, _) = item.kind {\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());"}, {"sha": "3af960491ed01d5872a0df98cba836829cadd303", "filename": "src/tools/clippy/clippy_lints/src/functions/too_many_arguments.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -9,9 +9,9 @@ use clippy_utils::is_trait_impl_item;\n use super::TOO_MANY_ARGUMENTS;\n \n pub(super) fn check_fn(\n-    cx: &LateContext<'tcx>,\n-    kind: intravisit::FnKind<'tcx>,\n-    decl: &'tcx hir::FnDecl<'_>,\n+    cx: &LateContext<'_>,\n+    kind: intravisit::FnKind<'_>,\n+    decl: &hir::FnDecl<'_>,\n     span: Span,\n     hir_id: hir::HirId,\n     too_many_arguments_threshold: u64,\n@@ -39,11 +39,7 @@ pub(super) fn check_fn(\n     }\n }\n \n-pub(super) fn check_trait_item(\n-    cx: &LateContext<'tcx>,\n-    item: &'tcx hir::TraitItem<'_>,\n-    too_many_arguments_threshold: u64,\n-) {\n+pub(super) fn check_trait_item(cx: &LateContext<'_>, item: &hir::TraitItem<'_>, too_many_arguments_threshold: u64) {\n     if let hir::TraitItemKind::Fn(ref sig, _) = item.kind {\n         // don't lint extern functions decls, it's not their fault\n         if sig.header.abi == Abi::Rust {"}, {"sha": "54bdea7ea25d634bde692af85f925652f9ca4d64", "filename": "src/tools/clippy/clippy_lints/src/functions/too_many_lines.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -11,9 +11,9 @@ use super::TOO_MANY_LINES;\n \n pub(super) fn check_fn(\n     cx: &LateContext<'_>,\n-    kind: FnKind<'tcx>,\n+    kind: FnKind<'_>,\n     span: Span,\n-    body: &'tcx hir::Body<'_>,\n+    body: &hir::Body<'_>,\n     too_many_lines_threshold: u64,\n ) {\n     // Closures must be contained in a parent body, which will be checked for `too_many_lines`."}, {"sha": "9525c163ece17a7b04a1e4a8e5c2ce50c343612e", "filename": "src/tools/clippy/clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -55,7 +55,7 @@ impl IfThenSomeElseNone {\n \n impl_lint_pass!(IfThenSomeElseNone => [IF_THEN_SOME_ELSE_NONE]);\n \n-impl LateLintPass<'_> for IfThenSomeElseNone {\n+impl<'tcx> LateLintPass<'tcx> for IfThenSomeElseNone {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'tcx Expr<'_>) {\n         if !meets_msrv(self.msrv.as_ref(), &msrvs::BOOL_THEN) {\n             return;"}, {"sha": "d650d6e9a85871881a680e755c6fc7def02fb345", "filename": "src/tools/clippy/clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_return.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -94,8 +94,8 @@ fn get_call_site(span: Span, ctxt: SyntaxContext) -> Option<Span> {\n }\n \n fn lint_implicit_returns(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx Expr<'_>,\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n     // The context of the function body.\n     ctxt: SyntaxContext,\n     // Whether the expression is from a macro expansion."}, {"sha": "3d44a669d8f0507ed1870a6fe81a4bea12aa38d7", "filename": "src/tools/clippy/clippy_lints/src/inconsistent_struct_constructor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -63,7 +63,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(InconsistentStructConstructor => [INCONSISTENT_STRUCT_CONSTRUCTOR]);\n \n-impl LateLintPass<'_> for InconsistentStructConstructor {\n+impl<'tcx> LateLintPass<'tcx> for InconsistentStructConstructor {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             if !expr.span.from_expansion();"}, {"sha": "073313e2bad4e2e40648ea921fb8538e1f6a00ba", "filename": "src/tools/clippy/clippy_lints/src/index_refutable_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -69,7 +69,7 @@ impl IndexRefutableSlice {\n \n impl_lint_pass!(IndexRefutableSlice => [INDEX_REFUTABLE_SLICE]);\n \n-impl LateLintPass<'_> for IndexRefutableSlice {\n+impl<'tcx> LateLintPass<'tcx> for IndexRefutableSlice {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             if !expr.span.from_expansion() || is_expn_of(expr.span, \"if_chain\").is_some();"}, {"sha": "9284e002409920673763967bb375b5bbf1b1b90a", "filename": "src/tools/clippy/clippy_lints/src/init_numbered_fields.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finit_numbered_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finit_numbered_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finit_numbered_fields.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::in_macro;\n use clippy_utils::source::snippet_with_applicability;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n@@ -46,7 +45,7 @@ impl<'tcx> LateLintPass<'tcx> for NumberedFields {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::Struct(path, fields, None) = e.kind {\n             if !fields.is_empty()\n-                && !in_macro(e.span)\n+                && !e.span.from_expansion()\n                 && fields\n                     .iter()\n                     .all(|f| f.ident.as_str().as_bytes().iter().all(u8::is_ascii_digit))"}, {"sha": "d3bdc819a9f2b48e277d9dd5aaca17859e3d1782", "filename": "src/tools/clippy/clippy_lints/src/iter_not_returning_iterator.rs", "status": "modified", "additions": 46, "deletions": 21, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,8 +1,7 @@\n-use clippy_utils::{diagnostics::span_lint, return_ty, ty::implements_trait};\n-use rustc_hir::{ImplItem, ImplItemKind};\n+use clippy_utils::{diagnostics::span_lint, get_parent_node, ty::implements_trait};\n+use rustc_hir::{def_id::LocalDefId, FnSig, ImplItem, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::kw;\n use rustc_span::symbol::sym;\n \n declare_clippy_lint! {\n@@ -40,26 +39,52 @@ declare_clippy_lint! {\n \n declare_lint_pass!(IterNotReturningIterator => [ITER_NOT_RETURNING_ITERATOR]);\n \n-impl LateLintPass<'_> for IterNotReturningIterator {\n-    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'tcx>) {\n-        let name = impl_item.ident.name.as_str();\n-        if_chain! {\n-            if let ImplItemKind::Fn(fn_sig, _) = &impl_item.kind;\n-            let ret_ty = return_ty(cx, impl_item.hir_id());\n-            if matches!(name, \"iter\" | \"iter_mut\");\n-            if let [param] = cx.tcx.fn_arg_names(impl_item.def_id);\n-            if param.name == kw::SelfLower;\n-            if let Some(iter_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n-            if !implements_trait(cx, ret_ty, iter_trait_id, &[]);\n+impl<'tcx> LateLintPass<'tcx> for IterNotReturningIterator {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n+        let name = item.ident.name.as_str();\n+        if matches!(name, \"iter\" | \"iter_mut\") {\n+            if let TraitItemKind::Fn(fn_sig, _) = &item.kind {\n+                check_sig(cx, name, fn_sig, item.def_id);\n+            }\n+        }\n+    }\n \n-            then {\n-                span_lint(\n-                    cx,\n-                    ITER_NOT_RETURNING_ITERATOR,\n-                    fn_sig.span,\n-                    &format!(\"this method is named `{}` but its return type does not implement `Iterator`\", name),\n-                );\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'tcx>) {\n+        let name = item.ident.name.as_str();\n+        if matches!(name, \"iter\" | \"iter_mut\")\n+            && !matches!(\n+                get_parent_node(cx.tcx, item.hir_id()),\n+                Some(Node::Item(Item { kind: ItemKind::Impl(i), .. })) if i.of_trait.is_some()\n+            )\n+        {\n+            if let ImplItemKind::Fn(fn_sig, _) = &item.kind {\n+                check_sig(cx, name, fn_sig, item.def_id);\n             }\n         }\n     }\n }\n+\n+fn check_sig(cx: &LateContext<'_>, name: &str, sig: &FnSig<'_>, fn_id: LocalDefId) {\n+    if sig.decl.implicit_self.has_implicit_self() {\n+        let ret_ty = cx.tcx.fn_sig(fn_id).skip_binder().output();\n+        let ret_ty = cx\n+            .tcx\n+            .try_normalize_erasing_regions(cx.param_env, ret_ty)\n+            .unwrap_or(ret_ty);\n+        if cx\n+            .tcx\n+            .get_diagnostic_item(sym::Iterator)\n+            .map_or(false, |iter_id| !implements_trait(cx, ret_ty, iter_id, &[]))\n+        {\n+            span_lint(\n+                cx,\n+                ITER_NOT_RETURNING_ITERATOR,\n+                sig.span,\n+                &format!(\n+                    \"this method is named `{}` but its return type does not implement `Iterator`\",\n+                    name\n+                ),\n+            );\n+        }\n+    }\n+}"}, {"sha": "e1168c3f6022ef381fc2eb576b44fb47ea8c3e41", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -245,7 +245,7 @@ enum LenOutput<'tcx> {\n     Option(DefId),\n     Result(DefId, Ty<'tcx>),\n }\n-fn parse_len_output(cx: &LateContext<'_>, sig: FnSig<'tcx>) -> Option<LenOutput<'tcx>> {\n+fn parse_len_output<'tcx>(cx: &LateContext<'_>, sig: FnSig<'tcx>) -> Option<LenOutput<'tcx>> {\n     match *sig.output().kind() {\n         ty::Int(_) | ty::Uint(_) => Some(LenOutput::Integral),\n         ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Option, adt.did) => {"}, {"sha": "26fb4259952b6ac5b971179f41b36ad0b86d3c7b", "filename": "src/tools/clippy/clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -37,6 +37,8 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(derivable_impls::DERIVABLE_IMPLS),\n     LintId::of(derive::DERIVE_HASH_XOR_EQ),\n     LintId::of(derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n+    LintId::of(disallowed_methods::DISALLOWED_METHODS),\n+    LintId::of(disallowed_types::DISALLOWED_TYPES),\n     LintId::of(doc::MISSING_SAFETY_DOC),\n     LintId::of(doc::NEEDLESS_DOCTEST_MAIN),\n     LintId::of(double_comparison::DOUBLE_COMPARISONS),\n@@ -113,6 +115,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(loops::WHILE_LET_ON_ITERATOR),\n     LintId::of(main_recursion::MAIN_RECURSION),\n     LintId::of(manual_async_fn::MANUAL_ASYNC_FN),\n+    LintId::of(manual_bits::MANUAL_BITS),\n     LintId::of(manual_map::MANUAL_MAP),\n     LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n     LintId::of(manual_strip::MANUAL_STRIP),\n@@ -204,7 +207,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(mut_key::MUTABLE_KEY_TYPE),\n     LintId::of(mut_mutex_lock::MUT_MUTEX_LOCK),\n     LintId::of(mut_reference::UNNECESSARY_MUT_PASSED),\n-    LintId::of(mutex_atomic::MUTEX_ATOMIC),\n     LintId::of(needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE),\n     LintId::of(needless_bool::BOOL_COMPARISON),\n     LintId::of(needless_bool::NEEDLESS_BOOL),"}, {"sha": "746bdb19c3d927c71003c869be6f41ef6774a82c", "filename": "src/tools/clippy/clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -3,33 +3,33 @@\n // Manual edits will be overwritten.\n \n store.register_lints(&[\n-    #[cfg(feature = \"internal-lints\")]\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::CLIPPY_LINTS_INTERNAL,\n-    #[cfg(feature = \"internal-lints\")]\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS,\n-    #[cfg(feature = \"internal-lints\")]\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::COMPILER_LINT_FUNCTIONS,\n-    #[cfg(feature = \"internal-lints\")]\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::DEFAULT_LINT,\n-    #[cfg(feature = \"internal-lints\")]\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::IF_CHAIN_STYLE,\n-    #[cfg(feature = \"internal-lints\")]\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::INTERNING_DEFINED_SYMBOL,\n-    #[cfg(feature = \"internal-lints\")]\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::INVALID_CLIPPY_VERSION_ATTRIBUTE,\n-    #[cfg(feature = \"internal-lints\")]\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::INVALID_PATHS,\n-    #[cfg(feature = \"internal-lints\")]\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n-    #[cfg(feature = \"internal-lints\")]\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n-    #[cfg(feature = \"internal-lints\")]\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE,\n-    #[cfg(feature = \"internal-lints\")]\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n-    #[cfg(feature = \"internal-lints\")]\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::PRODUCE_ICE,\n-    #[cfg(feature = \"internal-lints\")]\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::UNNECESSARY_SYMBOL_STR,\n     absurd_extreme_comparisons::ABSURD_EXTREME_COMPARISONS,\n     approx_const::APPROX_CONSTANT,\n@@ -59,6 +59,7 @@ store.register_lints(&[\n     bool_assert_comparison::BOOL_ASSERT_COMPARISON,\n     booleans::LOGIC_BUG,\n     booleans::NONMINIMAL_BOOL,\n+    borrow_as_ptr::BORROW_AS_PTR,\n     bytecount::NAIVE_BYTECOUNT,\n     cargo_common_metadata::CARGO_COMMON_METADATA,\n     case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n@@ -225,6 +226,7 @@ store.register_lints(&[\n     main_recursion::MAIN_RECURSION,\n     manual_assert::MANUAL_ASSERT,\n     manual_async_fn::MANUAL_ASYNC_FN,\n+    manual_bits::MANUAL_BITS,\n     manual_map::MANUAL_MAP,\n     manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n     manual_ok_or::MANUAL_OK_OR,\n@@ -435,6 +437,7 @@ store.register_lints(&[\n     shadow::SHADOW_REUSE,\n     shadow::SHADOW_SAME,\n     shadow::SHADOW_UNRELATED,\n+    single_char_lifetime_names::SINGLE_CHAR_LIFETIME_NAMES,\n     single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS,\n     size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT,\n     slow_vector_initialization::SLOW_VECTOR_INITIALIZATION,"}, {"sha": "a7353790100267681b11ae92b234125b48571dfe", "filename": "src/tools/clippy/clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -6,8 +6,6 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(attrs::EMPTY_LINE_AFTER_OUTER_ATTR),\n     LintId::of(cognitive_complexity::COGNITIVE_COMPLEXITY),\n     LintId::of(copies::BRANCHES_SHARING_CODE),\n-    LintId::of(disallowed_methods::DISALLOWED_METHODS),\n-    LintId::of(disallowed_types::DISALLOWED_TYPES),\n     LintId::of(equatable_if_let::EQUATABLE_IF_LET),\n     LintId::of(fallible_impl_from::FALLIBLE_IMPL_FROM),\n     LintId::of(floating_point_arithmetic::IMPRECISE_FLOPS),\n@@ -17,6 +15,7 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(let_if_seq::USELESS_LET_IF_SEQ),\n     LintId::of(missing_const_for_fn::MISSING_CONST_FOR_FN),\n     LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n+    LintId::of(mutex_atomic::MUTEX_ATOMIC),\n     LintId::of(mutex_atomic::MUTEX_INTEGER),\n     LintId::of(non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY),\n     LintId::of(nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES),"}, {"sha": "1744b7c825078e40ed37210384bb3cda7a4d0409", "filename": "src/tools/clippy/clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -7,6 +7,7 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n     LintId::of(bit_mask::VERBOSE_BIT_MASK),\n+    LintId::of(borrow_as_ptr::BORROW_AS_PTR),\n     LintId::of(bytecount::NAIVE_BYTECOUNT),\n     LintId::of(case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS),\n     LintId::of(casts::CAST_LOSSLESS),"}, {"sha": "f9ffd4cf829fa220ac198750eedf317b4ba93916", "filename": "src/tools/clippy/clippy_lints/src/lib.register_perf.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -19,7 +19,6 @@ store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(methods::SINGLE_CHAR_PATTERN),\n     LintId::of(methods::UNNECESSARY_TO_OWNED),\n     LintId::of(misc::CMP_OWNED),\n-    LintId::of(mutex_atomic::MUTEX_ATOMIC),\n     LintId::of(redundant_clone::REDUNDANT_CLONE),\n     LintId::of(slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n     LintId::of(stable_sort_primitive::STABLE_SORT_PRIMITIVE),"}, {"sha": "e7e2798da7da99785f7b46c6410ee615f00c4bcd", "filename": "src/tools/clippy/clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -54,6 +54,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(shadow::SHADOW_REUSE),\n     LintId::of(shadow::SHADOW_SAME),\n     LintId::of(shadow::SHADOW_UNRELATED),\n+    LintId::of(single_char_lifetime_names::SINGLE_CHAR_LIFETIME_NAMES),\n     LintId::of(strings::STRING_ADD),\n     LintId::of(strings::STRING_SLICE),\n     LintId::of(strings::STRING_TO_STRING),"}, {"sha": "05211476ff2300df79103d25e801f600f2cb692b", "filename": "src/tools/clippy/clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -16,6 +16,8 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(comparison_chain::COMPARISON_CHAIN),\n     LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n     LintId::of(dereference::NEEDLESS_BORROW),\n+    LintId::of(disallowed_methods::DISALLOWED_METHODS),\n+    LintId::of(disallowed_types::DISALLOWED_TYPES),\n     LintId::of(doc::MISSING_SAFETY_DOC),\n     LintId::of(doc::NEEDLESS_DOCTEST_MAIN),\n     LintId::of(enum_variants::ENUM_VARIANT_NAMES),\n@@ -41,6 +43,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(loops::WHILE_LET_ON_ITERATOR),\n     LintId::of(main_recursion::MAIN_RECURSION),\n     LintId::of(manual_async_fn::MANUAL_ASYNC_FN),\n+    LintId::of(manual_bits::MANUAL_BITS),\n     LintId::of(manual_map::MANUAL_MAP),\n     LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n     LintId::of(map_clone::MAP_CLONE),"}, {"sha": "79e9882fef4c49c42c2d6fb4bca32878a42f23bf", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -4,7 +4,6 @@\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n #![feature(drain_filter)]\n-#![feature(in_band_lifetimes)]\n #![feature(iter_intersperse)]\n #![feature(let_else)]\n #![feature(once_cell)]\n@@ -153,12 +152,9 @@ macro_rules! declare_clippy_lint {\n     };\n }\n \n-#[cfg(feature = \"metadata-collector-lint\")]\n+#[cfg(feature = \"internal\")]\n mod deprecated_lints;\n-#[cfg_attr(\n-    any(feature = \"internal-lints\", feature = \"metadata-collector-lint\"),\n-    allow(clippy::missing_clippy_version_attribute)\n-)]\n+#[cfg_attr(feature = \"internal\", allow(clippy::missing_clippy_version_attribute))]\n mod utils;\n \n // begin lints modules, do not remove this comment, it\u2019s used in `update_lints`\n@@ -177,6 +173,7 @@ mod blacklisted_name;\n mod blocks_in_if_conditions;\n mod bool_assert_comparison;\n mod booleans;\n+mod borrow_as_ptr;\n mod bytecount;\n mod cargo_common_metadata;\n mod case_sensitive_file_extension_comparisons;\n@@ -264,6 +261,7 @@ mod macro_use;\n mod main_recursion;\n mod manual_assert;\n mod manual_async_fn;\n+mod manual_bits;\n mod manual_map;\n mod manual_non_exhaustive;\n mod manual_ok_or;\n@@ -351,6 +349,7 @@ mod self_named_constructors;\n mod semicolon_if_nothing_returned;\n mod serde_api;\n mod shadow;\n+mod single_char_lifetime_names;\n mod single_component_path_imports;\n mod size_of_in_element_count;\n mod slow_vector_initialization;\n@@ -471,7 +470,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     include!(\"lib.register_restriction.rs\");\n     include!(\"lib.register_pedantic.rs\");\n \n-    #[cfg(feature = \"internal-lints\")]\n+    #[cfg(feature = \"internal\")]\n     include!(\"lib.register_internal.rs\");\n \n     include!(\"lib.register_all.rs\");\n@@ -483,7 +482,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     include!(\"lib.register_cargo.rs\");\n     include!(\"lib.register_nursery.rs\");\n \n-    #[cfg(feature = \"metadata-collector-lint\")]\n+    #[cfg(feature = \"internal\")]\n     {\n         if std::env::var(\"ENABLE_METADATA_COLLECTION\").eq(&Ok(\"1\".to_string())) {\n             store.register_late_pass(|| Box::new(utils::internal_lints::metadata_collector::MetadataCollector::new()));\n@@ -492,7 +491,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     }\n \n     // all the internal lints\n-    #[cfg(feature = \"internal-lints\")]\n+    #[cfg(feature = \"internal\")]\n     {\n         store.register_early_pass(|| Box::new(utils::internal_lints::ClippyLintsInternal));\n         store.register_early_pass(|| Box::new(utils::internal_lints::ProduceIce));\n@@ -858,6 +857,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(needless_late_init::NeedlessLateInit));\n     store.register_late_pass(|| Box::new(return_self_not_must_use::ReturnSelfNotMustUse));\n     store.register_late_pass(|| Box::new(init_numbered_fields::NumberedFields));\n+    store.register_early_pass(|| Box::new(single_char_lifetime_names::SingleCharLifetimeNames));\n+    store.register_late_pass(move || Box::new(borrow_as_ptr::BorrowAsPtr::new(msrv)));\n+    store.register_late_pass(move || Box::new(manual_bits::ManualBits::new(msrv)));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "823cf0f43221ca644030184f2b1b35ff96aa58e4", "filename": "src/tools/clippy/clippy_lints/src/loops/empty_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fempty_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fempty_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fempty_loop.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::{is_in_panic_handler, is_no_std_crate};\n use rustc_hir::{Block, Expr};\n use rustc_lint::LateContext;\n \n-pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'tcx Block<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, loop_block: &Block<'_>) {\n     if loop_block.stmts.is_empty() && loop_block.expr.is_none() && !is_in_panic_handler(cx, expr) {\n         let msg = \"empty `loop {}` wastes CPU cycles\";\n         let help = if is_no_std_crate(cx) {"}, {"sha": "17246cc5426ae1ef638fc0ec546959ba9a8d0f7e", "filename": "src/tools/clippy/clippy_lints/src/loops/explicit_into_iter_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -8,7 +8,7 @@ use rustc_lint::LateContext;\n use rustc_middle::ty::TyS;\n use rustc_span::symbol::sym;\n \n-pub(super) fn check(cx: &LateContext<'_>, self_arg: &'hir Expr<'hir>, call_expr: &Expr<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, self_arg: &Expr<'_>, call_expr: &Expr<'_>) {\n     let self_ty = cx.typeck_results().expr_ty(self_arg);\n     let self_ty_adjusted = cx.typeck_results().expr_ty_adjusted(self_arg);\n     if !(TyS::same_type(self_ty, self_ty_adjusted) && is_trait_method(cx, call_expr, sym::IntoIterator)) {"}, {"sha": "48c4015e07b6d308abd6aeae6932d159344a206b", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -2,7 +2,7 @@ use super::{IncrementVisitor, InitializeVisitor, MANUAL_MEMCPY};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::is_copy;\n use clippy_utils::{get_enclosing_block, higher, path_to_local, sugg};\n use if_chain::if_chain;\n use rustc_ast::ast;\n@@ -62,23 +62,23 @@ pub(super) fn check<'tcx>(\n                         if_chain! {\n                             if let ExprKind::Index(base_left, idx_left) = lhs.kind;\n                             if let ExprKind::Index(base_right, idx_right) = rhs.kind;\n-                            if is_slice_like(cx, cx.typeck_results().expr_ty(base_left));\n-                            if is_slice_like(cx, cx.typeck_results().expr_ty(base_right));\n+                            if let Some(ty) = get_slice_like_element_ty(cx, cx.typeck_results().expr_ty(base_left));\n+                            if get_slice_like_element_ty(cx, cx.typeck_results().expr_ty(base_right)).is_some();\n                             if let Some((start_left, offset_left)) = get_details_from_idx(cx, idx_left, &starts);\n                             if let Some((start_right, offset_right)) = get_details_from_idx(cx, idx_right, &starts);\n \n                             // Source and destination must be different\n                             if path_to_local(base_left) != path_to_local(base_right);\n                             then {\n-                                Some((IndexExpr { base: base_left, idx: start_left, idx_offset: offset_left },\n+                                Some((ty, IndexExpr { base: base_left, idx: start_left, idx_offset: offset_left },\n                                     IndexExpr { base: base_right, idx: start_right, idx_offset: offset_right }))\n                             } else {\n                                 None\n                             }\n                         }\n                     })\n                 })\n-                .map(|o| o.map(|(dst, src)| build_manual_memcpy_suggestion(cx, start, end, limits, &dst, &src)))\n+                .map(|o| o.map(|(ty, dst, src)| build_manual_memcpy_suggestion(cx, start, end, limits, ty, &dst, &src)))\n                 .collect::<Option<Vec<_>>>()\n                 .filter(|v| !v.is_empty())\n                 .map(|v| v.join(\"\\n    \"));\n@@ -105,6 +105,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n     start: &Expr<'_>,\n     end: &Expr<'_>,\n     limits: ast::RangeLimits,\n+    elem_ty: Ty<'tcx>,\n     dst: &IndexExpr<'_>,\n     src: &IndexExpr<'_>,\n ) -> String {\n@@ -187,9 +188,16 @@ fn build_manual_memcpy_suggestion<'tcx>(\n         .into()\n     };\n \n+    let method_str = if is_copy(cx, elem_ty) {\n+        \"copy_from_slice\"\n+    } else {\n+        \"clone_from_slice\"\n+    };\n+\n     format!(\n-        \"{}.clone_from_slice(&{}[{}..{}]);\",\n+        \"{}.{}(&{}[{}..{}]);\",\n         dst,\n+        method_str,\n         src_base_str,\n         src_offset.maybe_par(),\n         src_limit.maybe_par()\n@@ -203,7 +211,7 @@ fn build_manual_memcpy_suggestion<'tcx>(\n #[derive(Clone)]\n struct MinifyingSugg<'a>(Sugg<'a>);\n \n-impl Display for MinifyingSugg<'a> {\n+impl<'a> Display for MinifyingSugg<'a> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         self.0.fmt(f)\n     }\n@@ -324,14 +332,13 @@ struct Start<'hir> {\n     kind: StartKind<'hir>,\n }\n \n-fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n-    let is_slice = match ty.kind() {\n-        ty::Ref(_, subty, _) => is_slice_like(cx, subty),\n-        ty::Slice(..) | ty::Array(..) => true,\n-        _ => false,\n-    };\n-\n-    is_slice || is_type_diagnostic_item(cx, ty, sym::Vec) || is_type_diagnostic_item(cx, ty, sym::VecDeque)\n+fn get_slice_like_element_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    match ty.kind() {\n+        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Vec, adt.did) => Some(subs.type_at(0)),\n+        ty::Ref(_, subty, _) => get_slice_like_element_ty(cx, subty),\n+        ty::Slice(ty) | ty::Array(ty, _) => Some(ty),\n+        _ => None,\n+    }\n }\n \n fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {"}, {"sha": "37a57d8feb1d33bc432c0a5f067da1f03baf818c", "filename": "src/tools/clippy/clippy_lints/src/loops/mut_range_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -147,7 +147,7 @@ impl BreakAfterExprVisitor {\n     }\n }\n \n-impl intravisit::Visitor<'tcx> for BreakAfterExprVisitor {\n+impl<'tcx> intravisit::Visitor<'tcx> for BreakAfterExprVisitor {\n     type Map = Map<'tcx>;\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {"}, {"sha": "6248680aa621663e4dc5528816578b3054c133a5", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -339,8 +339,8 @@ fn detect_iter_and_into_iters<'tcx: 'a, 'a>(\n     }\n }\n \n-fn get_captured_ids(cx: &LateContext<'tcx>, ty: &'_ TyS<'_>) -> HirIdSet {\n-    fn get_captured_ids_recursive(cx: &LateContext<'tcx>, ty: &'_ TyS<'_>, set: &mut HirIdSet) {\n+fn get_captured_ids(cx: &LateContext<'_>, ty: &'_ TyS<'_>) -> HirIdSet {\n+    fn get_captured_ids_recursive(cx: &LateContext<'_>, ty: &'_ TyS<'_>, set: &mut HirIdSet) {\n         match ty.kind() {\n             ty::Adt(_, generics) => {\n                 for generic in *generics {"}, {"sha": "bb1b3e2a1ec6ae9ab437f86bbd670e524a946579", "filename": "src/tools/clippy/clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -10,8 +10,8 @@ use rustc_span::Span;\n use std::iter::{once, Iterator};\n \n pub(super) fn check(\n-    cx: &LateContext<'tcx>,\n-    block: &'tcx Block<'_>,\n+    cx: &LateContext<'_>,\n+    block: &Block<'_>,\n     loop_id: HirId,\n     span: Span,\n     for_loop: Option<&ForLoop<'_>>,"}, {"sha": "8f57df0be6bd47563a82e932f9fe5bcda0946aea", "filename": "src/tools/clippy/clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::{Block, Expr, ExprKind, MatchSource, Pat, StmtKind};\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::lint::in_external_macro;\n \n-pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'tcx Block<'_>) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'tcx Block<'_>) {\n     // extract the expression from the first statement (if any) in a block\n     let inner_stmt_expr = extract_expr_from_first_stmt(loop_block);\n     // or extract the first expression (if any) from the block"}, {"sha": "750328d1d01a5b4385b2b08bfc2c30e4f0b16eb8", "filename": "src/tools/clippy/clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -8,12 +8,13 @@ use clippy_utils::{\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n-use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, PatKind, QPath, UnOp};\n+use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, Mutability, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n-use rustc_span::{symbol::sym, Span, Symbol};\n+use rustc_middle::ty::adjustment::Adjust;\n+use rustc_span::{symbol::sym, Symbol};\n \n-pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    let (scrutinee_expr, iter_expr, some_pat, loop_expr) = if_chain! {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    let (scrutinee_expr, iter_expr_struct, iter_expr, some_pat, loop_expr) = if_chain! {\n         if let Some(higher::WhileLet { if_then, let_pat, let_expr }) = higher::WhileLet::hir(expr);\n         // check for `Some(..)` pattern\n         if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = let_pat.kind;\n@@ -27,7 +28,7 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // get the loop containing the match expression\n         if !uses_iter(cx, &iter_expr_struct, if_then);\n         then {\n-            (let_expr, iter_expr_struct, some_pat, expr)\n+            (let_expr, iter_expr_struct, iter_expr, some_pat, expr)\n         } else {\n             return;\n         }\n@@ -47,7 +48,11 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     // If the iterator is a field or the iterator is accessed after the loop is complete it needs to be\n     // borrowed mutably. TODO: If the struct can be partially moved from and the struct isn't used\n     // afterwards a mutable borrow of a field isn't necessary.\n-    let by_ref = if !iter_expr.fields.is_empty() || needs_mutable_borrow(cx, &iter_expr, loop_expr) {\n+    let by_ref = if cx.typeck_results().expr_ty(iter_expr).ref_mutability() == Some(Mutability::Mut)\n+        || !iter_expr_struct.can_move\n+        || !iter_expr_struct.fields.is_empty()\n+        || needs_mutable_borrow(cx, &iter_expr_struct, loop_expr)\n+    {\n         \".by_ref()\"\n     } else {\n         \"\"\n@@ -67,26 +72,36 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n \n #[derive(Debug)]\n struct IterExpr {\n-    /// The span of the whole expression, not just the path and fields stored here.\n-    span: Span,\n     /// The fields used, in order of child to parent.\n     fields: Vec<Symbol>,\n     /// The path being used.\n     path: Res,\n+    /// Whether or not the iterator can be moved.\n+    can_move: bool,\n }\n \n /// Parses any expression to find out which field of which variable is used. Will return `None` if\n /// the expression might have side effects.\n fn try_parse_iter_expr(cx: &LateContext<'_>, mut e: &Expr<'_>) -> Option<IterExpr> {\n-    let span = e.span;\n     let mut fields = Vec::new();\n+    let mut can_move = true;\n     loop {\n+        if cx\n+            .typeck_results()\n+            .expr_adjustments(e)\n+            .iter()\n+            .any(|a| matches!(a.kind, Adjust::Deref(Some(..))))\n+        {\n+            // Custom deref impls need to borrow the whole value as it's captured by reference\n+            can_move = false;\n+            fields.clear();\n+        }\n         match e.kind {\n             ExprKind::Path(ref path) => {\n                 break Some(IterExpr {\n-                    span,\n                     fields,\n                     path: cx.qpath_res(path, e.hir_id),\n+                    can_move,\n                 });\n             },\n             ExprKind::Field(base, name) => {\n@@ -99,10 +114,12 @@ fn try_parse_iter_expr(cx: &LateContext<'_>, mut e: &Expr<'_>) -> Option<IterExp\n             // Shouldn't have side effects, but there's no way to trace which field is used. So forget which fields have\n             // already been seen.\n             ExprKind::Index(base, idx) if !idx.can_have_side_effects() => {\n+                can_move = false;\n                 fields.clear();\n                 e = base;\n             },\n             ExprKind::Unary(UnOp::Deref, base) => {\n+                can_move = false;\n                 fields.clear();\n                 e = base;\n             },\n@@ -174,7 +191,7 @@ fn is_expr_same_child_or_parent_field(cx: &LateContext<'_>, expr: &Expr<'_>, fie\n \n /// Strips off all field and path expressions. This will return true if a field or path has been\n /// skipped. Used to skip them after failing to check for equality.\n-fn skip_fields_and_path(expr: &'tcx Expr<'_>) -> (Option<&'tcx Expr<'tcx>>, bool) {\n+fn skip_fields_and_path<'tcx>(expr: &'tcx Expr<'_>) -> (Option<&'tcx Expr<'tcx>>, bool) {\n     let mut e = expr;\n     let e = loop {\n         match e.kind {\n@@ -187,13 +204,13 @@ fn skip_fields_and_path(expr: &'tcx Expr<'_>) -> (Option<&'tcx Expr<'tcx>>, bool\n }\n \n /// Checks if the given expression uses the iterator.\n-fn uses_iter(cx: &LateContext<'tcx>, iter_expr: &IterExpr, container: &'tcx Expr<'_>) -> bool {\n+fn uses_iter<'tcx>(cx: &LateContext<'tcx>, iter_expr: &IterExpr, container: &'tcx Expr<'_>) -> bool {\n     struct V<'a, 'b, 'tcx> {\n         cx: &'a LateContext<'tcx>,\n         iter_expr: &'b IterExpr,\n         uses_iter: bool,\n     }\n-    impl Visitor<'tcx> for V<'_, '_, 'tcx> {\n+    impl<'tcx> Visitor<'tcx> for V<'_, '_, 'tcx> {\n         type Map = ErasedMap<'tcx>;\n         fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n             NestedVisitorMap::None\n@@ -228,15 +245,15 @@ fn uses_iter(cx: &LateContext<'tcx>, iter_expr: &IterExpr, container: &'tcx Expr\n }\n \n #[allow(clippy::too_many_lines)]\n-fn needs_mutable_borrow(cx: &LateContext<'tcx>, iter_expr: &IterExpr, loop_expr: &'tcx Expr<'_>) -> bool {\n+fn needs_mutable_borrow(cx: &LateContext<'_>, iter_expr: &IterExpr, loop_expr: &Expr<'_>) -> bool {\n     struct AfterLoopVisitor<'a, 'b, 'tcx> {\n         cx: &'a LateContext<'tcx>,\n         iter_expr: &'b IterExpr,\n         loop_id: HirId,\n         after_loop: bool,\n         used_iter: bool,\n     }\n-    impl Visitor<'tcx> for AfterLoopVisitor<'_, '_, 'tcx> {\n+    impl<'tcx> Visitor<'tcx> for AfterLoopVisitor<'_, '_, 'tcx> {\n         type Map = ErasedMap<'tcx>;\n         fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n             NestedVisitorMap::None\n@@ -275,7 +292,7 @@ fn needs_mutable_borrow(cx: &LateContext<'tcx>, iter_expr: &IterExpr, loop_expr:\n         found_local: bool,\n         used_after: bool,\n     }\n-    impl Visitor<'tcx> for NestedLoopVisitor<'a, 'b, 'tcx> {\n+    impl<'a, 'b, 'tcx> Visitor<'tcx> for NestedLoopVisitor<'a, 'b, 'tcx> {\n         type Map = ErasedMap<'tcx>;\n \n         fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {"}, {"sha": "ca1ccb93bf3fbeea048a54fda55a0070aba819ab", "filename": "src/tools/clippy/clippy_lints/src/macro_use.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmacro_use.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::in_macro;\n use clippy_utils::source::snippet;\n use hir::def::{DefKind, Res};\n use if_chain::if_chain;\n@@ -104,34 +103,34 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n                     }\n                 }\n             } else {\n-                if in_macro(item.span) {\n+                if item.span.from_expansion() {\n                     self.push_unique_macro_pat_ty(cx, item.span);\n                 }\n             }\n         }\n     }\n     fn check_attribute(&mut self, cx: &LateContext<'_>, attr: &ast::Attribute) {\n-        if in_macro(attr.span) {\n+        if attr.span.from_expansion() {\n             self.push_unique_macro(cx, attr.span);\n         }\n     }\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n-        if in_macro(expr.span) {\n+        if expr.span.from_expansion() {\n             self.push_unique_macro(cx, expr.span);\n         }\n     }\n     fn check_stmt(&mut self, cx: &LateContext<'_>, stmt: &hir::Stmt<'_>) {\n-        if in_macro(stmt.span) {\n+        if stmt.span.from_expansion() {\n             self.push_unique_macro(cx, stmt.span);\n         }\n     }\n     fn check_pat(&mut self, cx: &LateContext<'_>, pat: &hir::Pat<'_>) {\n-        if in_macro(pat.span) {\n+        if pat.span.from_expansion() {\n             self.push_unique_macro_pat_ty(cx, pat.span);\n         }\n     }\n     fn check_ty(&mut self, cx: &LateContext<'_>, ty: &hir::Ty<'_>) {\n-        if in_macro(ty.span) {\n+        if ty.span.from_expansion() {\n             self.push_unique_macro_pat_ty(cx, ty.span);\n         }\n     }"}, {"sha": "26b53ab5d683739b5e5b7d7df594be12f808575c", "filename": "src/tools/clippy/clippy_lints/src/manual_assert.rs", "status": "modified", "additions": 20, "deletions": 50, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_assert.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher::PanicExpn;\n+use clippy_utils::macros::{root_macro_call, FormatArgsExpn};\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{is_expn_of, sugg};\n+use clippy_utils::{peel_blocks_with_stmt, sugg};\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, StmtKind, UnOp};\n+use rustc_hir::{Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -34,65 +35,34 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ManualAssert => [MANUAL_ASSERT]);\n \n-impl LateLintPass<'_> for ManualAssert {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for ManualAssert {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n         if_chain! {\n-            if let Expr {\n-                kind: ExprKind:: If(cond, Expr {\n-                    kind: ExprKind::Block(\n-                        Block {\n-                            stmts: [stmt],\n-                            ..\n-                        },\n-                        _),\n-                    ..\n-                }, None),\n-                ..\n-            } = &expr;\n-            if is_expn_of(stmt.span, \"panic\").is_some();\n+            if let ExprKind::If(cond, then, None) = expr.kind;\n             if !matches!(cond.kind, ExprKind::Let(_));\n-            if let StmtKind::Semi(semi) = stmt.kind;\n+            if !expr.span.from_expansion();\n+            let then = peel_blocks_with_stmt(then);\n+            if let Some(macro_call) = root_macro_call(then.span);\n+            if cx.tcx.item_name(macro_call.def_id) == sym::panic;\n             if !cx.tcx.sess.source_map().is_multiline(cond.span);\n-\n+            if let Some(format_args) = FormatArgsExpn::find_nested(cx, then, macro_call.expn);\n             then {\n-                let call = if_chain! {\n-                    if let ExprKind::Block(block, _) = semi.kind;\n-                    if let Some(init) = block.expr;\n-                    then {\n-                        init\n-                    } else {\n-                        semi\n-                    }\n-                };\n-                let span = if let Some(panic_expn) = PanicExpn::parse(call) {\n-                    match *panic_expn.format_args.value_args {\n-                        [] => panic_expn.format_args.format_string_span,\n-                        [.., last] => panic_expn.format_args.format_string_span.to(last.span),\n-                    }\n-                } else if let ExprKind::Call(_, [format_args]) = call.kind {\n-                    format_args.span\n-                } else {\n-                    return\n-                };\n                 let mut applicability = Applicability::MachineApplicable;\n-                let sugg = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n-                let cond_sugg = if let ExprKind::DropTemps(e, ..) = cond.kind {\n-                    if let Expr{kind: ExprKind::Unary(UnOp::Not, not_expr), ..} = e {\n-                         sugg::Sugg::hir_with_applicability(cx, not_expr, \"..\", &mut applicability).maybe_par().to_string()\n-                    } else {\n-                       format!(\"!{}\", sugg::Sugg::hir_with_applicability(cx, e, \"..\", &mut applicability).maybe_par())\n-                    }\n-                } else {\n-                   format!(\"!{}\", sugg::Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability).maybe_par())\n+                let format_args_snip = snippet_with_applicability(cx, format_args.inputs_span(), \"..\", &mut applicability);\n+                let cond = cond.peel_drop_temps();\n+                let (cond, not) = match cond.kind {\n+                    ExprKind::Unary(UnOp::Not, e) => (e, \"\"),\n+                    _ => (cond, \"!\"),\n                 };\n-\n+                let cond_sugg = sugg::Sugg::hir_with_applicability(cx, cond, \"..\", &mut applicability).maybe_par();\n+                let sugg = format!(\"assert!({not}{cond_sugg}, {format_args_snip});\");\n                 span_lint_and_sugg(\n                     cx,\n                     MANUAL_ASSERT,\n                     expr.span,\n                     \"only a `panic!` in `if`-then statement\",\n                     \"try\",\n-                    format!(\"assert!({}, {});\", cond_sugg, sugg),\n+                    sugg,\n                     Applicability::MachineApplicable,\n                 );\n             }"}, {"sha": "50bf2527e39a8f4c26cdaac9774949c0542975d7", "filename": "src/tools/clippy/clippy_lints/src/manual_bits.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_bits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_bits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_bits.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,107 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::{match_def_path, meets_msrv, msrvs, paths};\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind, GenericArg, QPath};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, Ty};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for uses of `std::mem::size_of::<T>() * 8` when\n+    /// `T::BITS` is available.\n+    ///\n+    /// ### Why is this bad?\n+    /// Can be written as the shorter `T::BITS`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// std::mem::size_of::<usize>() * 8;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// usize::BITS;\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub MANUAL_BITS,\n+    style,\n+    \"manual implementation of `size_of::<T>() * 8` can be simplified with `T::BITS`\"\n+}\n+\n+#[derive(Clone)]\n+pub struct ManualBits {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl ManualBits {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(ManualBits => [MANUAL_BITS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for ManualBits {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if !meets_msrv(self.msrv.as_ref(), &msrvs::MANUAL_BITS) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let ExprKind::Binary(bin_op, left_expr, right_expr) = expr.kind;\n+            if let BinOpKind::Mul = &bin_op.node;\n+            if let Some((real_ty, resolved_ty, other_expr)) = get_one_size_of_ty(cx, left_expr, right_expr);\n+            if matches!(resolved_ty.kind(), ty::Int(_) | ty::Uint(_));\n+            if let ExprKind::Lit(lit) = &other_expr.kind;\n+            if let LitKind::Int(8, _) = lit.node;\n+\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    MANUAL_BITS,\n+                    expr.span,\n+                    \"usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\",\n+                    \"consider using\",\n+                    format!(\"{}::BITS\", snippet_opt(cx, real_ty.span).unwrap()),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn get_one_size_of_ty<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr1: &'tcx Expr<'_>,\n+    expr2: &'tcx Expr<'_>,\n+) -> Option<(&'tcx rustc_hir::Ty<'tcx>, Ty<'tcx>, &'tcx Expr<'tcx>)> {\n+    match (get_size_of_ty(cx, expr1), get_size_of_ty(cx, expr2)) {\n+        (Some((real_ty, resolved_ty)), None) => Some((real_ty, resolved_ty, expr2)),\n+        (None, Some((real_ty, resolved_ty))) => Some((real_ty, resolved_ty, expr1)),\n+        _ => None,\n+    }\n+}\n+\n+fn get_size_of_ty<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<(&'tcx rustc_hir::Ty<'tcx>, Ty<'tcx>)> {\n+    if_chain! {\n+        if let ExprKind::Call(count_func, _func_args) = expr.kind;\n+        if let ExprKind::Path(ref count_func_qpath) = count_func.kind;\n+\n+        if let QPath::Resolved(_, count_func_path) = count_func_qpath;\n+        if let Some(segment_zero) = count_func_path.segments.get(0);\n+        if let Some(args) = segment_zero.args;\n+        if let Some(GenericArg::Type(real_ty)) = args.args.get(0);\n+\n+        if let Some(def_id) = cx.qpath_res(count_func_qpath, count_func.hir_id).opt_def_id();\n+        if match_def_path(cx, def_id, &paths::MEM_SIZE_OF);\n+        then {\n+            cx.typeck_results().node_substs(count_func.hir_id).types().next().map(|resolved_ty| (real_ty, resolved_ty))\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "8475e367b09fe3c4a14bad23f8f29357e64e3d32", "filename": "src/tools/clippy/clippy_lints/src/manual_map.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_map.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -45,7 +45,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ManualMap => [MANUAL_MAP]);\n \n-impl LateLintPass<'_> for ManualMap {\n+impl<'tcx> LateLintPass<'tcx> for ManualMap {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let (scrutinee, then_pat, then_body, else_pat, else_body) = match IfLetOrMatch::parse(cx, expr) {\n@@ -219,7 +219,7 @@ impl LateLintPass<'_> for ManualMap {\n \n // Checks whether the expression could be passed as a function, or whether a closure is needed.\n // Returns the function to be passed to `map` if it exists.\n-fn can_pass_as_func(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+fn can_pass_as_func<'tcx>(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     match expr.kind {\n         ExprKind::Call(func, [arg])\n             if path_to_local_id(arg, binding)\n@@ -251,8 +251,13 @@ struct SomeExpr<'tcx> {\n \n // Try to parse into a recognized `Option` pattern.\n // i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n-fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n-    fn f(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ref_count: usize, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n+fn try_parse_pattern<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n+    fn f<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        pat: &'tcx Pat<'_>,\n+        ref_count: usize,\n+        ctxt: SyntaxContext,\n+    ) -> Option<OptionPat<'tcx>> {\n         match pat.kind {\n             PatKind::Wild => Some(OptionPat::Wild),\n             PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n@@ -269,7 +274,7 @@ fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxCon\n }\n \n // Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n-fn get_some_expr(\n+fn get_some_expr<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n     needs_unsafe_block: bool,\n@@ -306,6 +311,6 @@ fn get_some_expr(\n }\n \n // Checks for the `None` value.\n-fn is_none_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+fn is_none_expr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     matches!(peel_blocks(expr).kind, ExprKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n }"}, {"sha": "bd083e3e9e2012d8a766aae6e46e67cf8dfaca65", "filename": "src/tools/clippy/clippy_lints/src/manual_ok_or.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -40,7 +40,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ManualOkOr => [MANUAL_OK_OR]);\n \n-impl LateLintPass<'_> for ManualOkOr {\n+impl<'tcx> LateLintPass<'tcx> for ManualOkOr {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, scrutinee: &'tcx Expr<'tcx>) {\n         if in_external_macro(cx.sess(), scrutinee.span) {\n             return;"}, {"sha": "b3a91d9f18f5d94ff4d782900996310d161ed6f9", "filename": "src/tools/clippy/clippy_lints/src/manual_unwrap_or.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -43,7 +43,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ManualUnwrapOr => [MANUAL_UNWRAP_OR]);\n \n-impl LateLintPass<'_> for ManualUnwrapOr {\n+impl<'tcx> LateLintPass<'tcx> for ManualUnwrapOr {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if in_external_macro(cx.sess(), expr.span) || in_constant(cx, expr.hir_id) {\n             return;"}, {"sha": "1fc7eb72142843fdfd9b6f2aac5170034d9f3ef1", "filename": "src/tools/clippy/clippy_lints/src/match_str_case_mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatch_str_case_mismatch.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -55,7 +55,7 @@ enum CaseMethod {\n     AsciiUppercase,\n }\n \n-impl LateLintPass<'_> for MatchStrCaseMismatch {\n+impl<'tcx> LateLintPass<'tcx> for MatchStrCaseMismatch {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if !in_external_macro(cx.tcx.sess, expr.span);"}, {"sha": "60dd957db01f8d69d6b67fef0eb020d6b687ecf9", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -2,16 +2,17 @@ use clippy_utils::consts::{constant, constant_full_int, miri_to_const, FullInt};\n use clippy_utils::diagnostics::{\n     multispan_sugg, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n };\n-use clippy_utils::higher;\n+use clippy_utils::macros::{is_panic, root_macro_call};\n use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n use clippy_utils::visitors::is_local_used;\n use clippy_utils::{\n-    get_parent_expr, is_expn_of, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild, meets_msrv, msrvs,\n+    get_parent_expr, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild, meets_msrv, msrvs,\n     path_to_local, path_to_local_id, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns,\n     strip_pat_refs,\n };\n+use clippy_utils::{higher, peel_blocks_with_stmt};\n use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use core::iter::{once, ExactSizeIterator};\n use if_chain::if_chain;\n@@ -974,7 +975,8 @@ fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm\n                     }\n                     if_chain! {\n                         if matching_wild;\n-                        if is_panic_call(arm.body);\n+                        if let Some(macro_call) = root_macro_call(peel_blocks_with_stmt(arm.body).span);\n+                        if is_panic(cx, macro_call.def_id);\n                         then {\n                             // `Err(_)` or `Err(_e)` arm with `panic!` found\n                             span_lint_and_note(cx,\n@@ -997,7 +999,7 @@ enum CommonPrefixSearcher<'a> {\n     Path(&'a [PathSegment<'a>]),\n     Mixed,\n }\n-impl CommonPrefixSearcher<'a> {\n+impl<'a> CommonPrefixSearcher<'a> {\n     fn with_path(&mut self, path: &'a [PathSegment<'a>]) {\n         match path {\n             [path @ .., _] => self.with_prefix(path),\n@@ -1179,22 +1181,6 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n     };\n }\n \n-// If the block contains only a `panic!` macro (as expression or statement)\n-fn is_panic_call(expr: &Expr<'_>) -> bool {\n-    // Unwrap any wrapping blocks\n-    let span = if let ExprKind::Block(block, _) = expr.kind {\n-        match (&block.expr, block.stmts.len(), block.stmts.first()) {\n-            (&Some(exp), 0, _) => exp.span,\n-            (&None, 1, Some(stmt)) => stmt.span,\n-            _ => return false,\n-        }\n-    } else {\n-        expr.span\n-    };\n-\n-    is_expn_of(span, \"panic\").is_some() && is_expn_of(span, \"unreachable\").is_none()\n-}\n-\n fn check_match_ref_pats<'a, 'b, I>(cx: &LateContext<'_>, ex: &Expr<'_>, pats: I, expr: &Expr<'_>)\n where\n     'b: 'a,\n@@ -1818,11 +1804,15 @@ mod redundant_pattern_match {\n     /// Checks if the drop order for a type matters. Some std types implement drop solely to\n     /// deallocate memory. For these types, and composites containing them, changing the drop order\n     /// won't result in any observable side effects.\n-    fn type_needs_ordered_drop(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    fn type_needs_ordered_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         type_needs_ordered_drop_inner(cx, ty, &mut FxHashSet::default())\n     }\n \n-    fn type_needs_ordered_drop_inner(cx: &LateContext<'tcx>, ty: Ty<'tcx>, seen: &mut FxHashSet<Ty<'tcx>>) -> bool {\n+    fn type_needs_ordered_drop_inner<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        ty: Ty<'tcx>,\n+        seen: &mut FxHashSet<Ty<'tcx>>,\n+    ) -> bool {\n         if !seen.insert(ty) {\n             return false;\n         }\n@@ -1884,7 +1874,7 @@ mod redundant_pattern_match {\n \n     // Checks if there are any temporaries created in the given expression for which drop order\n     // matters.\n-    fn temporaries_need_ordered_drop(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n         struct V<'a, 'tcx> {\n             cx: &'a LateContext<'tcx>,\n             res: bool,"}, {"sha": "0f39470f34262d2fc95718ea5f143b21e3ea7628", "filename": "src/tools/clippy/clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher::FormatExpn;\n+use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n use rustc_errors::Applicability;\n@@ -14,7 +14,13 @@ use super::EXPECT_FUN_CALL;\n \n /// Checks for the `EXPECT_FUN_CALL` lint.\n #[allow(clippy::too_many_lines)]\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Span, name: &str, args: &[hir::Expr<'_>]) {\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    method_span: Span,\n+    name: &str,\n+    args: &'tcx [hir::Expr<'tcx>],\n+) {\n     // Strip `&`, `as_ref()` and `as_str()` off `arg` until we're left with either a `String` or\n     // `&str`\n     fn get_arg_root<'a>(cx: &LateContext<'_>, arg: &'a hir::Expr<'a>) -> &'a hir::Expr<'a> {\n@@ -128,11 +134,12 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Spa\n     let mut applicability = Applicability::MachineApplicable;\n \n     //Special handling for `format!` as arg_root\n-    if let Some(format_expn) = FormatExpn::parse(arg_root) {\n-        let span = match *format_expn.format_args.value_args {\n-            [] => format_expn.format_args.format_string_span,\n-            [.., last] => format_expn.format_args.format_string_span.to(last.span),\n-        };\n+    if let Some(macro_call) = root_macro_call_first_node(cx, arg_root) {\n+        if !cx.tcx.is_diagnostic_item(sym::format_macro, macro_call.def_id) {\n+            return;\n+        }\n+        let Some(format_args) = FormatArgsExpn::find_nested(cx, arg_root, macro_call.expn) else { return };\n+        let span = format_args.inputs_span();\n         let sugg = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n         span_lint_and_sugg(\n             cx,"}, {"sha": "6436e28a63c521cb5d3af2f21a89c4fa45ba224e", "filename": "src/tools/clippy/clippy_lints/src/methods/from_iter_instead_of_collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -37,7 +37,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Exp\n     }\n }\n \n-fn extract_turbofish(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ty: Ty<'tcx>) -> String {\n+fn extract_turbofish(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ty: Ty<'_>) -> String {\n     fn strip_angle_brackets(s: &str) -> Option<&str> {\n         s.strip_prefix('<')?.strip_suffix('>')\n     }"}, {"sha": "1041f644e32eb62d496805018ed5c48d14138765", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -80,7 +80,6 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, TraitRef, Ty, TyS};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::Symbol;\n use rustc_span::{sym, Span};\n use rustc_typeck::hir_ty_to_ty;\n \n@@ -1895,6 +1894,11 @@ declare_clippy_lint! {\n     /// ### Why is this bad?\n     /// The unnecessary calls result in useless allocations.\n     ///\n+    /// ### Known problems\n+    /// `unnecessary_to_owned` can falsely trigger if `IntoIterator::into_iter` is applied to an\n+    /// owned copy of a resource and the resource is later used mutably. See\n+    /// [#8148](https://github.com/rust-lang/rust-clippy/issues/8148).\n+    ///\n     /// ### Example\n     /// ```rust\n     /// let path = std::path::Path::new(\"x\");\n@@ -1997,24 +2001,16 @@ impl_lint_pass!(Methods => [\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n-fn method_call<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> Option<(Symbol, &'tcx [hir::Expr<'tcx>], Span)> {\n+fn method_call<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> Option<(&'tcx str, &'tcx [hir::Expr<'tcx>], Span)> {\n     if let ExprKind::MethodCall(path, span, args, _) = recv.kind {\n         if !args.iter().any(|e| e.span.from_expansion()) {\n-            return Some((path.ident.name, args, span));\n+            let name = path.ident.name.as_str();\n+            return Some((name, args, span));\n         }\n     }\n     None\n }\n \n-/// Same as `method_call` but the `Symbol` is dereferenced into a temporary `&str`\n-macro_rules! method_call {\n-    ($expr:expr) => {\n-        method_call($expr)\n-            .as_ref()\n-            .map(|&(ref name, args, span)| (name.as_str(), args, span))\n-    };\n-}\n-\n impl<'tcx> LateLintPass<'tcx> for Methods {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if expr.span.from_expansion() {\n@@ -2217,7 +2213,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n #[allow(clippy::too_many_lines)]\n fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Option<&RustcVersion>) {\n-    if let Some((name, [recv, args @ ..], span)) = method_call!(expr) {\n+    if let Some((name, [recv, args @ ..], span)) = method_call(expr) {\n         match (name, args) {\n             (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [_arg]) => {\n                 zst_offset::check(cx, expr, recv);\n@@ -2233,7 +2229,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             (\"as_ref\", []) => useless_asref::check(cx, expr, \"as_ref\", recv),\n             (\"assume_init\", []) => uninit_assumed_init::check(cx, expr, recv),\n             (\"cloned\", []) => cloned_instead_of_copied::check(cx, expr, recv, span, msrv),\n-            (\"collect\", []) => match method_call!(recv) {\n+            (\"collect\", []) => match method_call(recv) {\n                 Some((name @ (\"cloned\" | \"copied\"), [recv2], _)) => {\n                     iter_cloned_collect::check(cx, name, expr, recv2);\n                 },\n@@ -2247,14 +2243,14 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                 },\n                 _ => {},\n             },\n-            (\"count\", []) => match method_call!(recv) {\n+            (\"count\", []) => match method_call(recv) {\n                 Some((name @ (\"into_iter\" | \"iter\" | \"iter_mut\"), [recv2], _)) => {\n                     iter_count::check(cx, expr, recv2, name);\n                 },\n                 Some((\"map\", [_, arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n                 _ => {},\n             },\n-            (\"expect\", [_]) => match method_call!(recv) {\n+            (\"expect\", [_]) => match method_call(recv) {\n                 Some((\"ok\", [recv], _)) => ok_expect::check(cx, expr, recv),\n                 _ => expect_used::check(cx, expr, recv),\n             },\n@@ -2271,13 +2267,13 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                 flat_map_option::check(cx, expr, arg, span);\n             },\n             (\"flatten\", []) => {\n-                if let Some((\"map\", [recv, map_arg], _)) = method_call!(recv) {\n+                if let Some((\"map\", [recv, map_arg], _)) = method_call(recv) {\n                     map_flatten::check(cx, expr, recv, map_arg);\n                 }\n             },\n             (\"fold\", [init, acc]) => unnecessary_fold::check(cx, expr, init, acc, span),\n             (\"for_each\", [_]) => {\n-                if let Some((\"inspect\", [_, _], span2)) = method_call!(recv) {\n+                if let Some((\"inspect\", [_, _], span2)) = method_call(recv) {\n                     inspect_for_each::check(cx, expr, span2);\n                 }\n             },\n@@ -2286,7 +2282,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             (\"is_none\", []) => check_is_some_is_none(cx, expr, recv, false),\n             (\"is_some\", []) => check_is_some_is_none(cx, expr, recv, true),\n             (\"map\", [m_arg]) => {\n-                if let Some((name, [recv2, args @ ..], span2)) = method_call!(recv) {\n+                if let Some((name, [recv2, args @ ..], span2)) = method_call(recv) {\n                     match (name, args) {\n                         (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, msrv),\n                         (\"as_ref\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, false, msrv),\n@@ -2301,7 +2297,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             },\n             (\"map_or\", [def, map]) => option_map_or_none::check(cx, expr, recv, def, map),\n             (\"next\", []) => {\n-                if let Some((name, [recv, args @ ..], _)) = method_call!(recv) {\n+                if let Some((name, [recv, args @ ..], _)) = method_call(recv) {\n                     match (name, args) {\n                         (\"filter\", [arg]) => filter_next::check(cx, expr, recv, arg),\n                         (\"filter_map\", [arg]) => filter_map_next::check(cx, expr, recv, arg, msrv),\n@@ -2312,7 +2308,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                     }\n                 }\n             },\n-            (\"nth\", [n_arg]) => match method_call!(recv) {\n+            (\"nth\", [n_arg]) => match method_call(recv) {\n                 Some((\"bytes\", [recv2], _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n                 Some((\"iter\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n                 Some((\"iter_mut\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n@@ -2344,12 +2340,12 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             (\"to_os_string\" | \"to_owned\" | \"to_path_buf\" | \"to_vec\", []) => {\n                 implicit_clone::check(cx, name, expr, recv, span);\n             },\n-            (\"unwrap\", []) => match method_call!(recv) {\n+            (\"unwrap\", []) => match method_call(recv) {\n                 Some((\"get\", [recv, get_arg], _)) => get_unwrap::check(cx, expr, recv, get_arg, false),\n                 Some((\"get_mut\", [recv, get_arg], _)) => get_unwrap::check(cx, expr, recv, get_arg, true),\n                 _ => unwrap_used::check(cx, expr, recv),\n             },\n-            (\"unwrap_or\", [u_arg]) => match method_call!(recv) {\n+            (\"unwrap_or\", [u_arg]) => match method_call(recv) {\n                 Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), [lhs, rhs], _)) => {\n                     manual_saturating_arithmetic::check(cx, expr, lhs, rhs, u_arg, &arith[\"checked_\".len()..]);\n                 },\n@@ -2358,7 +2354,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                 },\n                 _ => {},\n             },\n-            (\"unwrap_or_else\", [u_arg]) => match method_call!(recv) {\n+            (\"unwrap_or_else\", [u_arg]) => match method_call(recv) {\n                 Some((\"map\", [recv, map_arg], _)) if map_unwrap_or::check(cx, expr, recv, map_arg, u_arg, msrv) => {},\n                 _ => {\n                     unwrap_or_else_default::check(cx, expr, recv, u_arg);\n@@ -2371,7 +2367,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n }\n \n fn check_is_some_is_none(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, is_some: bool) {\n-    if let Some((name @ (\"find\" | \"position\" | \"rposition\"), [f_recv, arg], span)) = method_call!(recv) {\n+    if let Some((name @ (\"find\" | \"position\" | \"rposition\"), [f_recv, arg], span)) = method_call(recv) {\n         search_is_some::check(cx, expr, name, is_some, f_recv, arg, recv, span);\n     }\n }\n@@ -2535,11 +2531,17 @@ impl SelfKind {\n             implements_trait(cx, ty, trait_def_id, &[parent_ty.into()])\n         }\n \n+        fn matches_none<'a>(cx: &LateContext<'a>, parent_ty: Ty<'a>, ty: Ty<'a>) -> bool {\n+            !matches_value(cx, parent_ty, ty)\n+                && !matches_ref(cx, hir::Mutability::Not, parent_ty, ty)\n+                && !matches_ref(cx, hir::Mutability::Mut, parent_ty, ty)\n+        }\n+\n         match self {\n             Self::Value => matches_value(cx, parent_ty, ty),\n             Self::Ref => matches_ref(cx, hir::Mutability::Not, parent_ty, ty) || ty == parent_ty && is_copy(cx, ty),\n             Self::RefMut => matches_ref(cx, hir::Mutability::Mut, parent_ty, ty),\n-            Self::No => ty != parent_ty,\n+            Self::No => matches_none(cx, parent_ty, ty),\n         }\n     }\n "}, {"sha": "514bdadc442e3ac33263bf9bd202102216f4619e", "filename": "src/tools/clippy/clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -124,7 +124,7 @@ struct IterUsage {\n }\n \n #[allow(clippy::too_many_lines)]\n-fn parse_iter_usage(\n+fn parse_iter_usage<'tcx>(\n     cx: &LateContext<'tcx>,\n     ctxt: SyntaxContext,\n     mut iter: impl Iterator<Item = (HirId, Node<'tcx>)>,\n@@ -281,7 +281,7 @@ pub(super) fn check_needless_splitn(\n     }\n }\n \n-fn check_iter(\n+fn check_iter<'tcx>(\n     cx: &LateContext<'tcx>,\n     ctxt: SyntaxContext,\n     mut iter: impl Iterator<Item = (HirId, Node<'tcx>)>,"}, {"sha": "5999245ea7d0001e8262c0072ac262f7bd6c624f", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -12,13 +12,13 @@ use rustc_span::{sym, Symbol};\n \n use super::UNNECESSARY_TO_OWNED;\n \n-pub fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol, receiver: &'tcx Expr<'tcx>) -> bool {\n+pub fn check(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol, receiver: &Expr<'_>) -> bool {\n     if_chain! {\n         if let Some(parent) = get_parent_expr(cx, expr);\n         if let Some(callee_def_id) = fn_def_id(cx, parent);\n         if is_into_iter(cx, callee_def_id);\n         then {\n-            check_for_loop_iter(cx, parent, method_name, receiver)\n+            check_for_loop_iter(cx, parent, method_name, receiver, false)\n         } else {\n             false\n         }\n@@ -30,10 +30,11 @@ pub fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol\n /// include this code directly is so that it can be called from\n /// `unnecessary_into_owned::check_into_iter_call_arg`.\n pub fn check_for_loop_iter(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx Expr<'tcx>,\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n     method_name: Symbol,\n-    receiver: &'tcx Expr<'tcx>,\n+    receiver: &Expr<'_>,\n+    cloned_before_iter: bool,\n ) -> bool {\n     if_chain! {\n         if let Some(grandparent) = get_parent_expr(cx, expr).and_then(|parent| get_parent_expr(cx, parent));\n@@ -70,12 +71,22 @@ pub fn check_for_loop_iter(\n                 expr.span,\n                 &format!(\"unnecessary use of `{}`\", method_name),\n                 |diag| {\n-                    diag.span_suggestion(expr.span, \"use\", snippet, Applicability::MachineApplicable);\n+                    // If `check_into_iter_call_arg` called `check_for_loop_iter` because a call to\n+                    // a `to_owned`-like function was removed, then the next suggestion may be\n+                    // incorrect. This is because the iterator that results from the call's removal\n+                    // could hold a reference to a resource that is used mutably. See\n+                    // https://github.com/rust-lang/rust-clippy/issues/8148.\n+                    let applicability = if cloned_before_iter {\n+                        Applicability::MaybeIncorrect\n+                    } else {\n+                        Applicability::MachineApplicable\n+                    };\n+                    diag.span_suggestion(expr.span, \"use\", snippet, applicability);\n                     for addr_of_expr in addr_of_exprs {\n                         match addr_of_expr.kind {\n                             ExprKind::AddrOf(_, _, referent) => {\n                                 let span = addr_of_expr.span.with_hi(referent.span.lo());\n-                                diag.span_suggestion(span, \"remove this `&`\", String::new(), Applicability::MachineApplicable);\n+                                diag.span_suggestion(span, \"remove this `&`\", String::new(), applicability);\n                             }\n                             _ => unreachable!(),\n                         }\n@@ -90,7 +101,7 @@ pub fn check_for_loop_iter(\n \n /// The core logic of `check_for_loop_iter` above, this function wraps a use of\n /// `CloneOrCopyVisitor`.\n-fn clone_or_copy_needed(\n+fn clone_or_copy_needed<'tcx>(\n     cx: &LateContext<'tcx>,\n     pat: &Pat<'tcx>,\n     body: &'tcx Expr<'tcx>,"}, {"sha": "e5b6d296b2d2519a320636db919465f54a7bf21f", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -16,7 +16,7 @@ use std::cmp::max;\n \n use super::UNNECESSARY_TO_OWNED;\n \n-pub fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol, args: &'tcx [Expr<'tcx>]) {\n+pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol, args: &'tcx [Expr<'tcx>]) {\n     if_chain! {\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let [receiver] = args;\n@@ -44,11 +44,11 @@ pub fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol\n /// call of a `to_owned`-like function is unnecessary.\n #[allow(clippy::too_many_lines)]\n fn check_addr_of_expr(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx Expr<'tcx>,\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n     method_name: Symbol,\n     method_def_id: DefId,\n-    receiver: &'tcx Expr<'tcx>,\n+    receiver: &Expr<'_>,\n ) -> bool {\n     if_chain! {\n         if let Some(parent) = get_parent_expr(cx, expr);\n@@ -171,12 +171,7 @@ fn check_addr_of_expr(\n \n /// Checks whether `expr` is an argument in an `into_iter` call and, if so, determines whether its\n /// call of a `to_owned`-like function is unnecessary.\n-fn check_into_iter_call_arg(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx Expr<'tcx>,\n-    method_name: Symbol,\n-    receiver: &'tcx Expr<'tcx>,\n-) -> bool {\n+fn check_into_iter_call_arg(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol, receiver: &Expr<'_>) -> bool {\n     if_chain! {\n         if let Some(parent) = get_parent_expr(cx, expr);\n         if let Some(callee_def_id) = fn_def_id(cx, parent);\n@@ -187,22 +182,31 @@ fn check_into_iter_call_arg(\n         if let Some(item_ty) = get_iterator_item_ty(cx, parent_ty);\n         if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n         then {\n-            if unnecessary_iter_cloned::check_for_loop_iter(cx, parent, method_name, receiver) {\n+            if unnecessary_iter_cloned::check_for_loop_iter(\n+                cx,\n+                parent,\n+                method_name,\n+                receiver,\n+                true,\n+            ) {\n                 return true;\n             }\n             let cloned_or_copied = if is_copy(cx, item_ty) {\n                 \"copied\"\n             } else {\n                 \"cloned\"\n             };\n+            // The next suggestion may be incorrect because the removal of the `to_owned`-like\n+            // function could cause the iterator to hold a reference to a resource that is used\n+            // mutably. See https://github.com/rust-lang/rust-clippy/issues/8148.\n             span_lint_and_sugg(\n                 cx,\n                 UNNECESSARY_TO_OWNED,\n                 parent.span,\n                 &format!(\"unnecessary use of `{}`\", method_name),\n                 \"use\",\n                 format!(\"{}.iter().{}()\", receiver_snippet, cloned_or_copied),\n-                Applicability::MachineApplicable,\n+                Applicability::MaybeIncorrect,\n             );\n             return true;\n         }\n@@ -212,7 +216,7 @@ fn check_into_iter_call_arg(\n \n /// Checks whether `expr` is an argument in a function call and, if so, determines whether its call\n /// of a `to_owned`-like function is unnecessary.\n-fn check_other_call_arg(\n+fn check_other_call_arg<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'tcx>,\n     method_name: Symbol,\n@@ -278,7 +282,7 @@ fn check_other_call_arg(\n \n /// Walks an expression's ancestors until it finds a non-`AddrOf` expression. Returns the first such\n /// expression found (if any) along with the immediately prior expression.\n-fn skip_addr_of_ancestors(\n+fn skip_addr_of_ancestors<'tcx>(\n     cx: &LateContext<'tcx>,\n     mut expr: &'tcx Expr<'tcx>,\n ) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n@@ -294,7 +298,7 @@ fn skip_addr_of_ancestors(\n \n /// Checks whether an expression is a function or method call and, if so, returns its `DefId`,\n /// `Substs`, and arguments.\n-fn get_callee_substs_and_args(\n+fn get_callee_substs_and_args<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'tcx>,\n ) -> Option<(DefId, SubstsRef<'tcx>, &'tcx [Expr<'tcx>])> {\n@@ -319,7 +323,7 @@ fn get_callee_substs_and_args(\n }\n \n /// Returns the `TraitPredicate`s and `ProjectionPredicate`s for a function's input type.\n-fn get_input_traits_and_projections(\n+fn get_input_traits_and_projections<'tcx>(\n     cx: &LateContext<'tcx>,\n     callee_def_id: DefId,\n     input: Ty<'tcx>,\n@@ -359,7 +363,11 @@ fn get_input_traits_and_projections(\n }\n \n /// Composes two substitutions by applying the latter to the types of the former.\n-fn compose_substs(cx: &LateContext<'tcx>, left: &[GenericArg<'tcx>], right: SubstsRef<'tcx>) -> Vec<GenericArg<'tcx>> {\n+fn compose_substs<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    left: &[GenericArg<'tcx>],\n+    right: SubstsRef<'tcx>,\n+) -> Vec<GenericArg<'tcx>> {\n     left.iter()\n         .map(|arg| {\n             if let GenericArgKind::Type(arg_ty) = arg.unpack() {"}, {"sha": "21b3f81d5d981978df903b8e2251eeac41c681ed", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -717,7 +717,7 @@ fn check_cast(cx: &LateContext<'_>, span: Span, e: &Expr<'_>, ty: &hir::Ty<'_>)\n     }\n }\n \n-fn check_binary(\n+fn check_binary<'a>(\n     cx: &LateContext<'a>,\n     expr: &Expr<'_>,\n     cmp: &rustc_span::source_map::Spanned<rustc_hir::BinOpKind>,"}, {"sha": "842959ce36b07ad41f3a45df70dcf0a37a21309f", "filename": "src/tools/clippy/clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{higher, is_direct_expn_of};\n+use clippy_utils::macros::{find_assert_eq_args, root_macro_call_first_node};\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{BorrowKind, Expr, ExprKind, MatchSource, Mutability};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -34,26 +34,30 @@ declare_clippy_lint! {\n \n declare_lint_pass!(DebugAssertWithMutCall => [DEBUG_ASSERT_WITH_MUT_CALL]);\n \n-const DEBUG_MACRO_NAMES: [&str; 3] = [\"debug_assert\", \"debug_assert_eq\", \"debug_assert_ne\"];\n-\n impl<'tcx> LateLintPass<'tcx> for DebugAssertWithMutCall {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        for dmn in &DEBUG_MACRO_NAMES {\n-            if is_direct_expn_of(e.span, dmn).is_some() {\n-                if let Some(macro_args) = higher::extract_assert_macro_args(e) {\n-                    for arg in macro_args {\n-                        let mut visitor = MutArgVisitor::new(cx);\n-                        visitor.visit_expr(arg);\n-                        if let Some(span) = visitor.expr_span() {\n-                            span_lint(\n-                                cx,\n-                                DEBUG_ASSERT_WITH_MUT_CALL,\n-                                span,\n-                                &format!(\"do not call a function with mutable arguments inside of `{}!`\", dmn),\n-                            );\n-                        }\n-                    }\n-                }\n+        let Some(macro_call) = root_macro_call_first_node(cx, e) else { return };\n+        let macro_name = cx.tcx.item_name(macro_call.def_id);\n+        if !matches!(\n+            macro_name.as_str(),\n+            \"debug_assert\" | \"debug_assert_eq\" | \"debug_assert_ne\"\n+        ) {\n+            return;\n+        }\n+        let Some((lhs, rhs, _)) = find_assert_eq_args(cx, e, macro_call.expn) else { return };\n+        for arg in [lhs, rhs] {\n+            let mut visitor = MutArgVisitor::new(cx);\n+            visitor.visit_expr(arg);\n+            if let Some(span) = visitor.expr_span() {\n+                span_lint(\n+                    cx,\n+                    DEBUG_ASSERT_WITH_MUT_CALL,\n+                    span,\n+                    &format!(\n+                        \"do not call a function with mutable arguments inside of `{}!`\",\n+                        macro_name\n+                    ),\n+                );\n             }\n         }\n     }"}, {"sha": "73823779e493d98e52e6642777db0db1dee9df1a", "filename": "src/tools/clippy/clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -38,7 +38,7 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"pre 1.29.0\"]\n     pub MUTEX_ATOMIC,\n-    perf,\n+    nursery,\n     \"using a mutex where an atomic value could be used instead\"\n }\n "}, {"sha": "19d58f7474b0ad548cd50622fd03ecd109de91d8", "filename": "src/tools/clippy/clippy_lints/src/needless_for_each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_for_each.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -48,7 +48,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(NeedlessForEach => [NEEDLESS_FOR_EACH]);\n \n-impl LateLintPass<'_> for NeedlessForEach {\n+impl<'tcx> LateLintPass<'tcx> for NeedlessForEach {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         let expr = match stmt.kind {\n             StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr,"}, {"sha": "9957afcbf04aaee1d7daaa305f1a89e797d335e9", "filename": "src/tools/clippy/clippy_lints/src/needless_late_init.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_late_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_late_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_late_init.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -330,7 +330,7 @@ fn check<'tcx>(\n     Some(())\n }\n \n-impl LateLintPass<'tcx> for NeedlessLateInit {\n+impl<'tcx> LateLintPass<'tcx> for NeedlessLateInit {\n     fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'tcx>) {\n         let mut parents = cx.tcx.hir().parent_iter(local.hir_id);\n "}, {"sha": "5bf8a1ba1ca3010258ed4d12afe881b5cf88ea7d", "filename": "src/tools/clippy/clippy_lints/src/no_effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -82,7 +82,7 @@ impl<'tcx> LateLintPass<'tcx> for NoEffect {\n     }\n }\n \n-fn check_no_effect(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> bool {\n+fn check_no_effect(cx: &LateContext<'_>, stmt: &Stmt<'_>) -> bool {\n     if let StmtKind::Semi(expr) = stmt.kind {\n         if has_no_effect(cx, expr) {\n             span_lint_hir(cx, NO_EFFECT, expr.hir_id, stmt.span, \"statement with no effect\");\n@@ -155,7 +155,7 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     }\n }\n \n-fn check_unnecessary_operation(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n+fn check_unnecessary_operation(cx: &LateContext<'_>, stmt: &Stmt<'_>) {\n     if_chain! {\n         if let StmtKind::Semi(expr) = stmt.kind;\n         if let Some(reduced) = reduce_expression(cx, expr);"}, {"sha": "e46fee4cac5eefd90aeabbe06886950848938107", "filename": "src/tools/clippy/clippy_lints/src/non_octal_unix_permissions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -40,7 +40,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(NonOctalUnixPermissions => [NON_OCTAL_UNIX_PERMISSIONS]);\n \n-impl LateLintPass<'_> for NonOctalUnixPermissions {\n+impl<'tcx> LateLintPass<'tcx> for NonOctalUnixPermissions {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         match &expr.kind {\n             ExprKind::MethodCall(path, _, [func, param], _) => {"}, {"sha": "e0da12f77fcc79693641f7b08ffe05bbd9bae7c7", "filename": "src/tools/clippy/clippy_lints/src/octal_escapes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foctal_escapes.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -50,7 +50,7 @@ declare_clippy_lint! {\n declare_lint_pass!(OctalEscapes => [OCTAL_ESCAPES]);\n \n impl EarlyLintPass for OctalEscapes {\n-    fn check_expr(&mut self, cx: &EarlyContext<'tcx>, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         if in_external_macro(cx.sess, expr.span) {\n             return;\n         }\n@@ -65,7 +65,7 @@ impl EarlyLintPass for OctalEscapes {\n     }\n }\n \n-fn check_lit(cx: &EarlyContext<'tcx>, lit: &Lit, span: Span, is_string: bool) {\n+fn check_lit(cx: &EarlyContext<'_>, lit: &Lit, span: Span, is_string: bool) {\n     let contents = lit.symbol.as_str();\n     let mut iter = contents.char_indices().peekable();\n     let mut found = vec![];"}, {"sha": "b7a56970b335520aac10736b4ca9f9f660a2fe93", "filename": "src/tools/clippy/clippy_lints/src/panic_in_result_fn.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,8 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::macros::root_macro_call_first_node;\n+use clippy_utils::return_ty;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{find_macro_calls, is_expn_of, return_ty};\n+use clippy_utils::visitors::expr_visitor_no_bodies;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::FnKind;\n+use rustc_hir::intravisit::{FnKind, Visitor};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n@@ -55,19 +57,19 @@ impl<'tcx> LateLintPass<'tcx> for PanicInResultFn {\n }\n \n fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, body: &'tcx hir::Body<'tcx>) {\n-    let mut panics = find_macro_calls(\n-        &[\n-            \"unimplemented\",\n-            \"unreachable\",\n-            \"panic\",\n-            \"todo\",\n-            \"assert\",\n-            \"assert_eq\",\n-            \"assert_ne\",\n-        ],\n-        body,\n-    );\n-    panics.retain(|span| is_expn_of(*span, \"debug_assert\").is_none());\n+    let mut panics = Vec::new();\n+    expr_visitor_no_bodies(|expr| {\n+        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return true };\n+        if matches!(\n+            &*cx.tcx.item_name(macro_call.def_id).as_str(),\n+            \"unimplemented\" | \"unreachable\" | \"panic\" | \"todo\" | \"assert\" | \"assert_eq\" | \"assert_ne\"\n+        ) {\n+            panics.push(macro_call.span);\n+            return false;\n+        }\n+        true\n+    })\n+    .visit_expr(&body.value);\n     if !panics.is_empty() {\n         span_lint_and_then(\n             cx,"}, {"sha": "6ef6b9a20aa4b185211eaa6c96c48dae49d11af0", "filename": "src/tools/clippy/clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,10 +1,8 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{is_expn_of, match_panic_call};\n-use if_chain::if_chain;\n+use clippy_utils::macros::{is_panic, root_macro_call_first_node};\n use rustc_hir::Expr;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -78,37 +76,37 @@ declare_lint_pass!(PanicUnimplemented => [UNIMPLEMENTED, UNREACHABLE, TODO, PANI\n \n impl<'tcx> LateLintPass<'tcx> for PanicUnimplemented {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if match_panic_call(cx, expr).is_some()\n-            && (is_expn_of(expr.span, \"debug_assert\").is_none() && is_expn_of(expr.span, \"assert\").is_none())\n-        {\n-            let span = get_outer_span(expr);\n-            if is_expn_of(expr.span, \"unimplemented\").is_some() {\n+        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return };\n+        if is_panic(cx, macro_call.def_id) {\n+            span_lint(\n+                cx,\n+                PANIC,\n+                macro_call.span,\n+                \"`panic` should not be present in production code\",\n+            );\n+            return;\n+        }\n+        match cx.tcx.item_name(macro_call.def_id).as_str() {\n+            \"todo\" => {\n+                span_lint(\n+                    cx,\n+                    TODO,\n+                    macro_call.span,\n+                    \"`todo` should not be present in production code\",\n+                );\n+            },\n+            \"unimplemented\" => {\n                 span_lint(\n                     cx,\n                     UNIMPLEMENTED,\n-                    span,\n+                    macro_call.span,\n                     \"`unimplemented` should not be present in production code\",\n                 );\n-            } else if is_expn_of(expr.span, \"todo\").is_some() {\n-                span_lint(cx, TODO, span, \"`todo` should not be present in production code\");\n-            } else if is_expn_of(expr.span, \"unreachable\").is_some() {\n-                span_lint(cx, UNREACHABLE, span, \"usage of the `unreachable!` macro\");\n-            } else if is_expn_of(expr.span, \"panic\").is_some() {\n-                span_lint(cx, PANIC, span, \"`panic` should not be present in production code\");\n-            }\n-        }\n-    }\n-}\n-\n-fn get_outer_span(expr: &Expr<'_>) -> Span {\n-    if_chain! {\n-        if expr.span.from_expansion();\n-        let first = expr.span.ctxt().outer_expn_data().call_site;\n-        if first.from_expansion();\n-        then {\n-            first.ctxt().outer_expn_data().call_site\n-        } else {\n-            expr.span\n+            },\n+            \"unreachable\" => {\n+                span_lint(cx, UNREACHABLE, macro_call.span, \"usage of the `unreachable!` macro\");\n+            },\n+            _ => {},\n         }\n     }\n }"}, {"sha": "2bec93ac606057e22c483777f9a9a546d332a787", "filename": "src/tools/clippy/clippy_lints/src/ptr_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr_eq.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -39,7 +39,7 @@ declare_lint_pass!(PtrEq => [PTR_EQ]);\n \n static LINT_MSG: &str = \"use `std::ptr::eq` when comparing raw pointers\";\n \n-impl LateLintPass<'_> for PtrEq {\n+impl<'tcx> LateLintPass<'tcx> for PtrEq {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if expr.span.from_expansion() {\n             return;"}, {"sha": "1991a01fb60be44ec352ff402e381772e565c9dd", "filename": "src/tools/clippy/clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -220,7 +220,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                     continue;\n                 } else if let Some(loc) = clone_usage.cloned_consume_or_mutate_loc {\n                     // cloned value is mutated, and the clone is alive.\n-                    if possible_borrower.is_alive_at(ret_local, loc) {\n+                    if possible_borrower.local_is_alive_at(ret_local, loc) {\n                         continue;\n                     }\n                 }\n@@ -767,7 +767,7 @@ impl PossibleBorrowerMap<'_, '_> {\n         self.bitset.0 == self.bitset.1\n     }\n \n-    fn is_alive_at(&mut self, local: mir::Local, at: mir::Location) -> bool {\n+    fn local_is_alive_at(&mut self, local: mir::Local, at: mir::Location) -> bool {\n         self.maybe_live.seek_after_primary_effect(at);\n         self.maybe_live.contains(local)\n     }"}, {"sha": "7c88b42ea3199a771b40f5692f95923cf6928fa6", "filename": "src/tools/clippy/clippy_lints/src/redundant_slicing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_slicing.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -42,7 +42,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(RedundantSlicing => [REDUNDANT_SLICING]);\n \n-impl LateLintPass<'_> for RedundantSlicing {\n+impl<'tcx> LateLintPass<'tcx> for RedundantSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if expr.span.from_expansion() {\n             return;"}, {"sha": "b24483723700c2b031a404dddb0fd70db862ccc1", "filename": "src/tools/clippy/clippy_lints/src/reference.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freference.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -50,6 +50,7 @@ impl EarlyLintPass for DerefAddrOf {\n         if_chain! {\n             if let ExprKind::Unary(UnOp::Deref, ref deref_target) = e.kind;\n             if let ExprKind::AddrOf(_, ref mutability, ref addrof_target) = without_parens(deref_target).kind;\n+            if deref_target.span.ctxt() == e.span.ctxt();\n             if !addrof_target.span.from_expansion();\n             then {\n                 let mut applicability = Applicability::MachineApplicable;"}, {"sha": "5dafd08cf3be0e754b8d9e1d29b4076a2a5c5448", "filename": "src/tools/clippy/clippy_lints/src/return_self_not_must_use.rs", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturn_self_not_must_use.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,5 +1,6 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::ty::is_must_use_ty;\n-use clippy_utils::{diagnostics::span_lint, nth_arg, return_ty};\n+use clippy_utils::{nth_arg, return_ty};\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, FnDecl, HirId, TraitItem, TraitItemKind};\n@@ -13,25 +14,46 @@ declare_clippy_lint! {\n     /// This lint warns when a method returning `Self` doesn't have the `#[must_use]` attribute.\n     ///\n     /// ### Why is this bad?\n-    /// It prevents to \"forget\" to use the newly created value.\n+    /// Methods returning `Self` often create new values, having the `#[must_use]` attribute\n+    /// prevents users from \"forgetting\" to use the newly created value.\n+    ///\n+    /// The `#[must_use]` attribute can be added to the type itself to ensure that instances\n+    /// are never forgotten. Functions returning a type marked with `#[must_use]` will not be\n+    /// linted, as the usage is already enforced by the type attribute.\n     ///\n     /// ### Limitations\n     /// This lint is only applied on methods taking a `self` argument. It would be mostly noise\n     /// if it was added on constructors for example.\n     ///\n     /// ### Example\n+    /// Missing attribute\n     /// ```rust\n     /// pub struct Bar;\n-    ///\n     /// impl Bar {\n     ///     // Bad\n     ///     pub fn bar(&self) -> Self {\n     ///         Self\n     ///     }\n+    /// }\n+    /// ```\n     ///\n-    ///     // Good\n+    /// It's better to have the `#[must_use]` attribute on the method like this:\n+    /// ```rust\n+    /// pub struct Bar;\n+    /// impl Bar {\n     ///     #[must_use]\n-    ///     pub fn foo(&self) -> Self {\n+    ///     pub fn bar(&self) -> Self {\n+    ///         Self\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Or on the type definition like this:\n+    /// ```rust\n+    /// #[must_use]\n+    /// pub struct Bar;\n+    /// impl Bar {\n+    ///     pub fn bar(&self) -> Self {\n     ///         Self\n     ///     }\n     /// }\n@@ -44,7 +66,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ReturnSelfNotMustUse => [RETURN_SELF_NOT_MUST_USE]);\n \n-fn check_method(cx: &LateContext<'tcx>, decl: &'tcx FnDecl<'tcx>, fn_def: LocalDefId, span: Span, hir_id: HirId) {\n+fn check_method(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_def: LocalDefId, span: Span, hir_id: HirId) {\n     if_chain! {\n         // If it comes from an external macro, better ignore it.\n         if !in_external_macro(cx.sess(), span);\n@@ -65,11 +87,13 @@ fn check_method(cx: &LateContext<'tcx>, decl: &'tcx FnDecl<'tcx>, fn_def: LocalD\n         if !is_must_use_ty(cx, ret_ty);\n \n         then {\n-            span_lint(\n+            span_lint_and_help(\n                 cx,\n                 RETURN_SELF_NOT_MUST_USE,\n                 span,\n                 \"missing `#[must_use]` attribute on a method returning `Self`\",\n+                None,\n+                \"consider adding the `#[must_use]` attribute to the method or directly to the `Self` type\"\n             );\n         }\n     }"}, {"sha": "729694da46d5c2ee6a3098d2b9000495cf4a753d", "filename": "src/tools/clippy/clippy_lints/src/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -37,7 +37,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(SemicolonIfNothingReturned => [SEMICOLON_IF_NOTHING_RETURNED]);\n \n-impl LateLintPass<'_> for SemicolonIfNothingReturned {\n+impl<'tcx> LateLintPass<'tcx> for SemicolonIfNothingReturned {\n     fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'tcx>) {\n         if_chain! {\n             if !block.span.from_expansion();"}, {"sha": "ee82666b5affea88b54526cee4c203a405e25c9c", "filename": "src/tools/clippy/clippy_lints/src/single_char_lifetime_names.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_char_lifetime_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_char_lifetime_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_char_lifetime_names.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,63 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use rustc_ast::ast::{GenericParam, GenericParamKind};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for lifetimes with names which are one character\n+    /// long.\n+    ///\n+    /// ### Why is this bad?\n+    /// A single character is likely not enough to express the\n+    /// purpose of a lifetime. Using a longer name can make code\n+    /// easier to understand, especially for those who are new to\n+    /// Rust.\n+    ///\n+    /// ### Known problems\n+    /// Rust programmers and learning resources tend to use single\n+    /// character lifetimes, so this lint is at odds with the\n+    /// ecosystem at large. In addition, the lifetime's purpose may\n+    /// be obvious or, rarely, expressible in one character.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// struct DiagnosticCtx<'a> {\n+    ///     source: &'a str,\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// struct DiagnosticCtx<'src> {\n+    ///     source: &'src str,\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.59.0\"]\n+    pub SINGLE_CHAR_LIFETIME_NAMES,\n+    restriction,\n+    \"warns against single-character lifetime names\"\n+}\n+\n+declare_lint_pass!(SingleCharLifetimeNames => [SINGLE_CHAR_LIFETIME_NAMES]);\n+\n+impl EarlyLintPass for SingleCharLifetimeNames {\n+    fn check_generic_param(&mut self, ctx: &EarlyContext<'_>, param: &GenericParam) {\n+        if in_external_macro(ctx.sess, param.ident.span) {\n+            return;\n+        }\n+\n+        if let GenericParamKind::Lifetime = param.kind {\n+            if !param.is_placeholder && param.ident.as_str().len() <= 2 {\n+                span_lint_and_help(\n+                    ctx,\n+                    SINGLE_CHAR_LIFETIME_NAMES,\n+                    param.ident.span,\n+                    \"single-character lifetime names are likely uninformative\",\n+                    None,\n+                    \"use a more informative name\",\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "9b195f3c0a228d1edefd01abad488e6347f6b334", "filename": "src/tools/clippy/clippy_lints/src/size_of_in_element_count.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -37,7 +37,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(SizeOfInElementCount => [SIZE_OF_IN_ELEMENT_COUNT]);\n \n-fn get_size_of_ty(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, inverted: bool) -> Option<Ty<'tcx>> {\n+fn get_size_of_ty<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, inverted: bool) -> Option<Ty<'tcx>> {\n     match expr.kind {\n         ExprKind::Call(count_func, _func_args) => {\n             if_chain! {\n@@ -64,7 +64,10 @@ fn get_size_of_ty(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, inverted: bool)\n     }\n }\n \n-fn get_pointee_ty_and_count_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<(Ty<'tcx>, &'tcx Expr<'tcx>)> {\n+fn get_pointee_ty_and_count_expr<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+) -> Option<(Ty<'tcx>, &'tcx Expr<'tcx>)> {\n     const FUNCTIONS: [&[&str]; 8] = [\n         &paths::PTR_COPY_NONOVERLAPPING,\n         &paths::PTR_COPY,"}, {"sha": "b4a71aefd437ff7b6c1a186467242b7cf3c0fa08", "filename": "src/tools/clippy/clippy_lints/src/strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -381,7 +381,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(StrToString => [STR_TO_STRING]);\n \n-impl LateLintPass<'_> for StrToString {\n+impl<'tcx> LateLintPass<'tcx> for StrToString {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n         if_chain! {\n             if let ExprKind::MethodCall(path, _, [self_arg, ..], _) = &expr.kind;\n@@ -431,7 +431,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(StringToString => [STRING_TO_STRING]);\n \n-impl LateLintPass<'_> for StringToString {\n+impl<'tcx> LateLintPass<'tcx> for StringToString {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n         if_chain! {\n             if let ExprKind::MethodCall(path, _, [self_arg, ..], _) = &expr.kind;"}, {"sha": "d6e948a75607bff1bfcb4da6ab50708febce40db", "filename": "src/tools/clippy/clippy_lints/src/strlen_on_c_strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -39,7 +39,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(StrlenOnCStrings => [STRLEN_ON_C_STRINGS]);\n \n-impl LateLintPass<'tcx> for StrlenOnCStrings {\n+impl<'tcx> LateLintPass<'tcx> for StrlenOnCStrings {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if !expr.span.from_expansion();"}, {"sha": "ca725918e873e3d8269bbf2a978379fe0c259ca1", "filename": "src/tools/clippy/clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -355,7 +355,7 @@ struct BinaryOp<'exprs> {\n     right: &'exprs Expr,\n }\n \n-impl BinaryOp<'exprs> {\n+impl<'exprs> BinaryOp<'exprs> {\n     fn new(op: BinOpKind, span: Span, (left, right): (&'exprs Expr, &'exprs Expr)) -> Self {\n         Self { op, span, left, right }\n     }\n@@ -419,7 +419,7 @@ fn chained_binops(kind: &ExprKind) -> Option<Vec<BinaryOp<'_>>> {\n     }\n }\n \n-fn chained_binops_helper(left_outer: &'expr Expr, right_outer: &'expr Expr) -> Option<Vec<BinaryOp<'expr>>> {\n+fn chained_binops_helper<'expr>(left_outer: &'expr Expr, right_outer: &'expr Expr) -> Option<Vec<BinaryOp<'expr>>> {\n     match (&left_outer.kind, &right_outer.kind) {\n         (\n             ExprKind::Paren(ref left_e) | ExprKind::Unary(_, ref left_e),"}, {"sha": "c9b2ce476e89d0d5cb8408a7b4f0978a3593c5fb", "filename": "src/tools/clippy/clippy_lints/src/trailing_empty_array.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -53,13 +53,12 @@ impl<'tcx> LateLintPass<'tcx> for TrailingEmptyArray {\n     }\n }\n \n-fn is_struct_with_trailing_zero_sized_array(cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) -> bool {\n+fn is_struct_with_trailing_zero_sized_array(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n     if_chain! {\n         // First check if last field is an array\n         if let ItemKind::Struct(data, _) = &item.kind;\n         if let Some(last_field) = data.fields().last();\n-        if let rustc_hir::TyKind::Array(_, length) = last_field.ty.kind;\n-        if let rustc_hir::ArrayLen::Body(length) = length;\n+        if let rustc_hir::TyKind::Array(_, rustc_hir::ArrayLen::Body(length)) = last_field.ty.kind;\n \n         // Then check if that that array zero-sized\n         let length_ldid = cx.tcx.hir().local_def_id(length.hir_id);"}, {"sha": "6369aafe3f9734ec605be603f4eb30d700cace9d", "filename": "src/tools/clippy/clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 80, "deletions": 12, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,11 +1,16 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::{snippet, snippet_with_applicability};\n-use clippy_utils::SpanlessHash;\n+use clippy_utils::{SpanlessEq, SpanlessHash};\n+use core::hash::{Hash, Hasher};\n use if_chain::if_chain;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::Applicability;\n-use rustc_hir::{def::Res, GenericBound, Generics, ParamName, Path, QPath, TyKind, WherePredicate};\n+use rustc_hir::def::Res;\n+use rustc_hir::{\n+    GenericBound, Generics, Item, ItemKind, Node, ParamName, Path, PathSegment, QPath, TraitItem, Ty, TyKind,\n+    WherePredicate,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n@@ -83,6 +88,53 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n         self.check_type_repetition(cx, gen);\n         check_trait_bound_duplication(cx, gen);\n     }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'tcx>) {\n+        let Generics { where_clause, .. } = &item.generics;\n+        let mut self_bounds_set = FxHashSet::default();\n+\n+        for predicate in where_clause.predicates {\n+            if_chain! {\n+                if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n+                if !bound_predicate.span.from_expansion();\n+                if let TyKind::Path(QPath::Resolved(_, Path { segments, .. })) = bound_predicate.bounded_ty.kind;\n+                if let Some(PathSegment { res: Some(Res::SelfTy(Some(def_id), _)), .. }) = segments.first();\n+\n+                if let Some(\n+                    Node::Item(\n+                        Item {\n+                            kind: ItemKind::Trait(_, _, _, self_bounds, _),\n+                            .. }\n+                        )\n+                    ) = cx.tcx.hir().get_if_local(*def_id);\n+                then {\n+                    if self_bounds_set.is_empty() {\n+                        for bound in self_bounds.iter() {\n+                            let Some((self_res, _)) = get_trait_res_span_from_bound(bound) else { continue };\n+                            self_bounds_set.insert(self_res);\n+                        }\n+                    }\n+\n+                    bound_predicate\n+                        .bounds\n+                        .iter()\n+                        .filter_map(get_trait_res_span_from_bound)\n+                        .for_each(|(trait_item_res, span)| {\n+                            if self_bounds_set.get(&trait_item_res).is_some() {\n+                                span_lint_and_help(\n+                                    cx,\n+                                    TRAIT_DUPLICATION_IN_BOUNDS,\n+                                    span,\n+                                    \"this trait bound is already specified in trait declaration\",\n+                                    None,\n+                                    \"consider removing this trait bound\",\n+                                );\n+                            }\n+                        });\n+                }\n+            }\n+        }\n+    }\n }\n \n fn get_trait_res_span_from_bound(bound: &GenericBound<'_>) -> Option<(Res, Span)> {\n@@ -94,24 +146,40 @@ fn get_trait_res_span_from_bound(bound: &GenericBound<'_>) -> Option<(Res, Span)\n }\n \n impl TraitBounds {\n-    fn check_type_repetition(self, cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n+    fn check_type_repetition<'tcx>(self, cx: &LateContext<'tcx>, gen: &'tcx Generics<'_>) {\n+        struct SpanlessTy<'cx, 'tcx> {\n+            ty: &'tcx Ty<'tcx>,\n+            cx: &'cx LateContext<'tcx>,\n+        }\n+        impl PartialEq for SpanlessTy<'_, '_> {\n+            fn eq(&self, other: &Self) -> bool {\n+                let mut eq = SpanlessEq::new(self.cx);\n+                eq.inter_expr().eq_ty(self.ty, other.ty)\n+            }\n+        }\n+        impl Hash for SpanlessTy<'_, '_> {\n+            fn hash<H: Hasher>(&self, h: &mut H) {\n+                let mut t = SpanlessHash::new(self.cx);\n+                t.hash_ty(self.ty);\n+                h.write_u64(t.finish());\n+            }\n+        }\n+        impl Eq for SpanlessTy<'_, '_> {}\n+\n         if gen.span.from_expansion() {\n             return;\n         }\n-        let hash = |ty| -> u64 {\n-            let mut hasher = SpanlessHash::new(cx);\n-            hasher.hash_ty(ty);\n-            hasher.finish()\n-        };\n-        let mut map: UnhashMap<u64, Vec<&GenericBound<'_>>> = UnhashMap::default();\n+        let mut map: UnhashMap<SpanlessTy<'_, '_>, Vec<&GenericBound<'_>>> = UnhashMap::default();\n         let mut applicability = Applicability::MaybeIncorrect;\n         for bound in gen.where_clause.predicates {\n             if_chain! {\n                 if let WherePredicate::BoundPredicate(ref p) = bound;\n                 if p.bounds.len() as u64 <= self.max_trait_bounds;\n                 if !p.span.from_expansion();\n-                let h = hash(p.bounded_ty);\n-                if let Some(ref v) = map.insert(h, p.bounds.iter().collect::<Vec<_>>());\n+                if let Some(ref v) = map.insert(\n+                    SpanlessTy { ty: p.bounded_ty, cx },\n+                    p.bounds.iter().collect::<Vec<_>>()\n+                );\n \n                 then {\n                     let mut hint_string = format!("}, {"sha": "9d57505e55ed67164b7b6e80417b6e878dc1064e", "filename": "src/tools/clippy/clippy_lints/src/types/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -167,8 +167,9 @@ declare_clippy_lint! {\n     /// Check the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.\n     ///\n     /// ### Why is this bad?\n-    /// Any `&Box<T>` can also be a `&T`, which is more\n-    /// general.\n+    /// A `&Box<T>` parameter requires the function caller to box `T` first before passing it to a function.\n+    /// Using `&T` defines a concrete type for the parameter and generalizes the function, this would also\n+    /// auto-deref to `&T` at the function call site if passed a `&Box<T>`.\n     ///\n     /// ### Example\n     /// ```rust,ignore"}, {"sha": "697ed267e2f357309961ac1642e4509c00e505a7", "filename": "src/tools/clippy/clippy_lints/src/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -113,8 +113,8 @@ impl LateLintPass<'_> for UndocumentedUnsafeBlocks {\n     }\n }\n \n-impl<'hir> Visitor<'hir> for UndocumentedUnsafeBlocks {\n-    type Map = Map<'hir>;\n+impl<'v> Visitor<'v> for UndocumentedUnsafeBlocks {\n+    type Map = Map<'v>;\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n         NestedVisitorMap::None"}, {"sha": "7557e14d11f526917b8faa0da05a3e941c829896", "filename": "src/tools/clippy/clippy_lints/src/undropped_manually_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundropped_manually_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundropped_manually_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fundropped_manually_drops.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -36,7 +36,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(UndroppedManuallyDrops => [UNDROPPED_MANUALLY_DROPS]);\n \n-impl LateLintPass<'tcx> for UndroppedManuallyDrops {\n+impl<'tcx> LateLintPass<'tcx> for UndroppedManuallyDrops {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let Some([arg_0, ..]) = match_function_call(cx, expr, &paths::DROP) {\n             let ty = cx.typeck_results().expr_ty(arg_0);"}, {"sha": "2ffaf24f942ae705dbd72cf3098b15c73030c6ee", "filename": "src/tools/clippy/clippy_lints/src/uninit_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funinit_vec.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -78,7 +78,7 @@ impl<'tcx> LateLintPass<'tcx> for UninitVec {\n     }\n }\n \n-fn handle_uninit_vec_pair(\n+fn handle_uninit_vec_pair<'tcx>(\n     cx: &LateContext<'tcx>,\n     maybe_init_or_reserve: &'tcx Stmt<'tcx>,\n     maybe_set_len: &'tcx Expr<'tcx>,\n@@ -196,7 +196,7 @@ fn is_reserve(cx: &LateContext<'_>, path: &PathSegment<'_>, self_expr: &Expr<'_>\n }\n \n /// Returns self if the expression is `Vec::set_len()`\n-fn extract_set_len_self(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<(&'tcx Expr<'tcx>, Span)> {\n+fn extract_set_len_self<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<(&'tcx Expr<'tcx>, Span)> {\n     // peel unsafe blocks in `unsafe { vec.set_len() }`\n     let expr = peel_hir_expr_while(expr, |e| {\n         if let ExprKind::Block(block, _) = e.kind {"}, {"sha": "dcf8a9d7c84d39416926d2e4f7f30dd4aa1bb3b3", "filename": "src/tools/clippy/clippy_lints/src/unit_hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_hash.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -46,7 +46,7 @@ declare_clippy_lint! {\n }\n declare_lint_pass!(UnitHash => [UNIT_HASH]);\n \n-impl LateLintPass<'tcx> for UnitHash {\n+impl<'tcx> LateLintPass<'tcx> for UnitHash {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if_chain! {\n             if let ExprKind::MethodCall(name_ident, _, args, _) = &expr.kind;"}, {"sha": "1dd8895ebd0763be6dd77e2da8f7f34fd8566030", "filename": "src/tools/clippy/clippy_lints/src/unit_types/unit_cmp.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,35 +1,29 @@\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::macros::{find_assert_eq_args, root_macro_call_first_node};\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::LateContext;\n-use rustc_span::hygiene::{ExpnKind, MacroKind};\n \n use super::UNIT_CMP;\n \n pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if expr.span.from_expansion() {\n-        if let Some(callee) = expr.span.source_callee() {\n-            if let ExpnKind::Macro(MacroKind::Bang, symbol) = callee.kind {\n-                if let ExprKind::Binary(ref cmp, left, _) = expr.kind {\n-                    let op = cmp.node;\n-                    if op.is_comparison() && cx.typeck_results().expr_ty(left).is_unit() {\n-                        let result = match symbol.as_str() {\n-                            \"assert_eq\" | \"debug_assert_eq\" => \"succeed\",\n-                            \"assert_ne\" | \"debug_assert_ne\" => \"fail\",\n-                            _ => return,\n-                        };\n-                        span_lint(\n-                            cx,\n-                            UNIT_CMP,\n-                            expr.span,\n-                            &format!(\n-                                \"`{}` of unit values detected. This will always {}\",\n-                                symbol.as_str(),\n-                                result\n-                            ),\n-                        );\n-                    }\n-                }\n+        if let Some(macro_call) = root_macro_call_first_node(cx, expr) {\n+            let macro_name = cx.tcx.item_name(macro_call.def_id);\n+            let result = match macro_name.as_str() {\n+                \"assert_eq\" | \"debug_assert_eq\" => \"succeed\",\n+                \"assert_ne\" | \"debug_assert_ne\" => \"fail\",\n+                _ => return,\n+            };\n+            let Some ((left, _, _)) = find_assert_eq_args(cx, expr, macro_call.expn) else { return };\n+            if !cx.typeck_results().expr_ty(left).is_unit() {\n+                return;\n             }\n+            span_lint(\n+                cx,\n+                UNIT_CMP,\n+                macro_call.span,\n+                &format!(\"`{}` of unit values detected. This will always {}\", macro_name, result),\n+            );\n         }\n         return;\n     }"}, {"sha": "287ac5b4a90835d162e12b4c9407e29f563e5578", "filename": "src/tools/clippy/clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 76, "deletions": 13, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_io_amount.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::{is_try, match_trait_method, paths};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -17,10 +17,17 @@ declare_clippy_lint! {\n     /// partial-write/read, use\n     /// `write_all`/`read_exact` instead.\n     ///\n+    /// When working with asynchronous code (either with the `futures`\n+    /// crate or with `tokio`), a similar issue exists for\n+    /// `AsyncWriteExt::write()` and `AsyncReadExt::read()` : these\n+    /// functions are also not guaranteed to process the entire\n+    /// buffer.  Your code should either handle partial-writes/reads, or\n+    /// call the `write_all`/`read_exact` methods on those traits instead.\n+    ///\n     /// ### Known problems\n     /// Detects only common patterns.\n     ///\n-    /// ### Example\n+    /// ### Examples\n     /// ```rust,ignore\n     /// use std::io;\n     /// fn foo<W: io::Write>(w: &mut W) -> io::Result<()> {\n@@ -68,6 +75,23 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n     }\n }\n \n+/// If `expr` is an (e).await, return the inner expression \"e\" that's being\n+/// waited on.  Otherwise return None.\n+fn try_remove_await<'a>(expr: &'a hir::Expr<'a>) -> Option<&hir::Expr<'a>> {\n+    if let hir::ExprKind::Match(expr, _, hir::MatchSource::AwaitDesugar) = expr.kind {\n+        if let hir::ExprKind::Call(func, [ref arg_0, ..]) = expr.kind {\n+            if matches!(\n+                func.kind,\n+                hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::IntoFutureIntoFuture, ..))\n+            ) {\n+                return Some(arg_0);\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n fn check_map_error(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n     let mut call = call;\n     while let hir::ExprKind::MethodCall(path, _, args, _) = call.kind {\n@@ -77,30 +101,69 @@ fn check_map_error(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<\n             break;\n         }\n     }\n-    check_method_call(cx, call, expr);\n+\n+    if let Some(call) = try_remove_await(call) {\n+        check_method_call(cx, call, expr, true);\n+    } else {\n+        check_method_call(cx, call, expr, false);\n+    }\n }\n \n-fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n+fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>, is_await: bool) {\n     if let hir::ExprKind::MethodCall(path, _, _, _) = call.kind {\n         let symbol = path.ident.as_str();\n-        let read_trait = match_trait_method(cx, call, &paths::IO_READ);\n-        let write_trait = match_trait_method(cx, call, &paths::IO_WRITE);\n+        let read_trait = if is_await {\n+            match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCREADEXT)\n+                || match_trait_method(cx, call, &paths::TOKIO_IO_ASYNCREADEXT)\n+        } else {\n+            match_trait_method(cx, call, &paths::IO_READ)\n+        };\n+        let write_trait = if is_await {\n+            match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCWRITEEXT)\n+                || match_trait_method(cx, call, &paths::TOKIO_IO_ASYNCWRITEEXT)\n+        } else {\n+            match_trait_method(cx, call, &paths::IO_WRITE)\n+        };\n \n-        match (read_trait, write_trait, symbol) {\n-            (true, _, \"read\") => span_lint(\n+        match (read_trait, write_trait, symbol, is_await) {\n+            (true, _, \"read\", false) => span_lint_and_help(\n+                cx,\n+                UNUSED_IO_AMOUNT,\n+                expr.span,\n+                \"read amount is not handled\",\n+                None,\n+                \"use `Read::read_exact` instead, or handle partial reads\",\n+            ),\n+            (true, _, \"read\", true) => span_lint_and_help(\n                 cx,\n                 UNUSED_IO_AMOUNT,\n                 expr.span,\n-                \"read amount is not handled. Use `Read::read_exact` instead\",\n+                \"read amount is not handled\",\n+                None,\n+                \"use `AsyncReadExt::read_exact` instead, or handle partial reads\",\n             ),\n-            (true, _, \"read_vectored\") => span_lint(cx, UNUSED_IO_AMOUNT, expr.span, \"read amount is not handled\"),\n-            (_, true, \"write\") => span_lint(\n+            (true, _, \"read_vectored\", _) => {\n+                span_lint(cx, UNUSED_IO_AMOUNT, expr.span, \"read amount is not handled\");\n+            },\n+            (_, true, \"write\", false) => span_lint_and_help(\n                 cx,\n                 UNUSED_IO_AMOUNT,\n                 expr.span,\n-                \"written amount is not handled. Use `Write::write_all` instead\",\n+                \"written amount is not handled\",\n+                None,\n+                \"use `Write::write_all` instead, or handle partial writes\",\n             ),\n-            (_, true, \"write_vectored\") => span_lint(cx, UNUSED_IO_AMOUNT, expr.span, \"written amount is not handled\"),\n+            (_, true, \"write\", true) => span_lint_and_help(\n+                cx,\n+                UNUSED_IO_AMOUNT,\n+                expr.span,\n+                \"written amount is not handled\",\n+                None,\n+                \"use `AsyncWriteExt::write_all` instead, or handle partial writes\",\n+            ),\n+            (_, true, \"write_vectored\", _) => {\n+                span_lint(cx, UNUSED_IO_AMOUNT, expr.span, \"written amount is not handled\");\n+            },\n             _ => (),\n         }\n     }"}, {"sha": "7751c593e435a3410d52c139bf286b8c79dfb22e", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -573,7 +573,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                         bind!(self, anon_const);\n                         out!(\"if let ArrayLen::Body({anon_const}) = {length};\");\n                         self.body(field!(anon_const.body));\n-                    }\n+                    },\n                 }\n             },\n             ExprKind::Err => kind!(\"Err\"),"}, {"sha": "d6deb50cc907379f7b66b633c8eaf77b298976a4", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -23,6 +23,14 @@ pub enum DisallowedMethod {\n     WithReason { path: String, reason: Option<String> },\n }\n \n+impl DisallowedMethod {\n+    pub fn path(&self) -> &str {\n+        let (Self::Simple(path) | Self::WithReason { path, .. }) = self;\n+\n+        path\n+    }\n+}\n+\n /// A single disallowed type, used by the `DISALLOWED_TYPES` lint.\n #[derive(Clone, Debug, Deserialize)]\n #[serde(untagged)]\n@@ -113,7 +121,7 @@ macro_rules! define_Conf {\n             }\n         }\n \n-        #[cfg(feature = \"metadata-collector-lint\")]\n+        #[cfg(feature = \"internal\")]\n         pub mod metadata {\n             use crate::utils::internal_lints::metadata_collector::ClippyConfiguration;\n "}, {"sha": "e90b6b73b34208c2283e480d3a18cde80d117765", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -342,8 +342,8 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n             match length {\n                 hir::ArrayLen::Infer(_, _) => println!(\"{}repeat count: _\", ind),\n                 hir::ArrayLen::Body(anon_const) => {\n-                    print_expr(cx, &cx.tcx.hir().body(anon_const.body).value, indent + 1)\n-                }\n+                    print_expr(cx, &cx.tcx.hir().body(anon_const.body).value, indent + 1);\n+                },\n             }\n         },\n         hir::ExprKind::Err => {"}, {"sha": "9c3dcc8e96a0644698ce5a915fdb5e72c1d8a534", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::macros::root_macro_call_first_node;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n use clippy_utils::{\n@@ -34,7 +35,7 @@ use rustc_typeck::hir_ty_to_ty;\n \n use std::borrow::{Borrow, Cow};\n \n-#[cfg(feature = \"metadata-collector-lint\")]\n+#[cfg(feature = \"internal\")]\n pub mod metadata_collector;\n \n declare_clippy_lint! {\n@@ -410,9 +411,13 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n                 }\n                 self.declared_lints.insert(item.ident.name, item.span);\n             }\n-        } else if is_expn_of(item.span, \"impl_lint_pass\").is_some()\n-            || is_expn_of(item.span, \"declare_lint_pass\").is_some()\n-        {\n+        } else if let Some(macro_call) = root_macro_call_first_node(cx, item) {\n+            if !matches!(\n+                &*cx.tcx.item_name(macro_call.def_id).as_str(),\n+                \"impl_lint_pass\" | \"declare_lint_pass\"\n+            ) {\n+                return;\n+            }\n             if let hir::ItemKind::Impl(hir::Impl {\n                 of_trait: None,\n                 items: impl_item_refs,\n@@ -924,9 +929,20 @@ pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n         let lang_item_path = cx.get_def_path(*item_def_id);\n         if path_syms.starts_with(&lang_item_path) {\n             if let [item] = &path_syms[lang_item_path.len()..] {\n-                for child in cx.tcx.module_children(*item_def_id) {\n-                    if child.ident.name == *item {\n-                        return true;\n+                if matches!(\n+                    cx.tcx.def_kind(*item_def_id),\n+                    DefKind::Mod | DefKind::Enum | DefKind::Trait\n+                ) {\n+                    for child in cx.tcx.module_children(*item_def_id) {\n+                        if child.ident.name == *item {\n+                            return true;\n+                        }\n+                    }\n+                } else {\n+                    for child in cx.tcx.associated_item_def_ids(*item_def_id) {\n+                        if cx.tcx.item_name(*child) == *item {\n+                            return true;\n+                        }\n                     }\n                 }\n             }"}, {"sha": "4e46d79dc087047aca119d05c2d603a53b8b10bf", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,8 +1,7 @@\n //! This lint is used to collect metadata about clippy lints. This metadata is exported as a json\n //! file and then used to generate the [clippy lint list](https://rust-lang.github.io/rust-clippy/master/index.html)\n //!\n-//! This module and therefor the entire lint is guarded by a feature flag called\n-//! `metadata-collector-lint`\n+//! This module and therefore the entire lint is guarded by a feature flag called `internal`\n //!\n //! The module transforms all lint names to ascii lowercase to ensure that we don't have mismatches\n //! during any comparison or mapping. (Please take care of this, it's not fun to spend time on such\n@@ -578,7 +577,7 @@ fn get_lint_version(cx: &LateContext<'_>, item: &Item<'_>) -> String {\n fn get_lint_group_and_level_or_lint(\n     cx: &LateContext<'_>,\n     lint_name: &str,\n-    item: &'hir Item<'_>,\n+    item: &Item<'_>,\n ) -> Option<(String, &'static str)> {\n     let result = cx\n         .lint_store\n@@ -697,20 +696,20 @@ fn extract_emission_info<'hir>(\n }\n \n /// Resolves the possible lints that this expression could reference\n-fn resolve_lints(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Vec<String> {\n+fn resolve_lints<'hir>(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Vec<String> {\n     let mut resolver = LintResolver::new(cx);\n     resolver.visit_expr(expr);\n     resolver.lints\n }\n \n /// This function tries to resolve the linked applicability to the given expression.\n-fn resolve_applicability(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Option<usize> {\n+fn resolve_applicability<'hir>(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Option<usize> {\n     let mut resolver = ApplicabilityResolver::new(cx);\n     resolver.visit_expr(expr);\n     resolver.complete()\n }\n \n-fn check_is_multi_part(cx: &LateContext<'hir>, closure_expr: &'hir hir::Expr<'hir>) -> bool {\n+fn check_is_multi_part<'hir>(cx: &LateContext<'hir>, closure_expr: &'hir hir::Expr<'hir>) -> bool {\n     if let ExprKind::Closure(_, _, body_id, _, _) = closure_expr.kind {\n         let mut scanner = IsMultiSpanScanner::new(cx);\n         intravisit::walk_body(&mut scanner, cx.tcx.hir().body(body_id));\n@@ -825,7 +824,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for ApplicabilityResolver<'a, 'hir> {\n }\n \n /// This returns the parent local node if the expression is a reference one\n-fn get_parent_local(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Option<&'hir hir::Local<'hir>> {\n+fn get_parent_local<'hir>(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Option<&'hir hir::Local<'hir>> {\n     if let ExprKind::Path(QPath::Resolved(_, path)) = expr.kind {\n         if let hir::def::Res::Local(local_hir) = path.res {\n             return get_parent_local_hir_id(cx, local_hir);\n@@ -835,7 +834,7 @@ fn get_parent_local(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Opti\n     None\n }\n \n-fn get_parent_local_hir_id(cx: &LateContext<'hir>, hir_id: hir::HirId) -> Option<&'hir hir::Local<'hir>> {\n+fn get_parent_local_hir_id<'hir>(cx: &LateContext<'hir>, hir_id: hir::HirId) -> Option<&'hir hir::Local<'hir>> {\n     let map = cx.tcx.hir();\n \n     match map.find(map.get_parent_node(hir_id)) {"}, {"sha": "dc385ebacba664db68ea0ed564508f9ef7a312cb", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,5 +1,5 @@\n pub mod author;\n pub mod conf;\n pub mod inspector;\n-#[cfg(any(feature = \"internal-lints\", feature = \"metadata-collector-lint\"))]\n+#[cfg(feature = \"internal\")]\n pub mod internal_lints;"}, {"sha": "43474da3450e2bd1e7641ed96d743c73f28439db", "filename": "src/tools/clippy/clippy_lints/src/vec_init_then_push.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -77,7 +77,7 @@ impl VecPushSearcher {\n     }\n }\n \n-impl LateLintPass<'_> for VecInitThenPush {\n+impl<'tcx> LateLintPass<'tcx> for VecInitThenPush {\n     fn check_block(&mut self, _: &LateContext<'tcx>, _: &'tcx Block<'tcx>) {\n         self.searcher = None;\n     }"}, {"sha": "afff6491aba6420b39febc824702f9776656170f", "filename": "src/tools/clippy/clippy_utils/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2FCargo.toml?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,17 +1,17 @@\n [package]\n name = \"clippy_utils\"\n-version = \"0.1.59\"\n+version = \"0.1.60\"\n edition = \"2021\"\n publish = false\n \n [dependencies]\n+arrayvec = { version = \"0.7\", default-features = false }\n if_chain = \"1.0\"\n rustc-semver = \"1.1\"\n \n [features]\n deny-warnings = []\n-internal-lints = []\n-metadata-collector-lint = []\n+internal = []\n \n [package.metadata.rust-analyzer]\n # This crate uses #[feature(rustc_private)]"}, {"sha": "3d3180521ab7a2fcb533727a1ed8a43a84971cf7", "filename": "src/tools/clippy/clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -5,7 +5,6 @@\n #![allow(clippy::similar_names, clippy::wildcard_imports, clippy::enum_glob_use)]\n \n use crate::{both, over};\n-use if_chain::if_chain;\n use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, *};\n use rustc_span::symbol::Ident;\n@@ -679,34 +678,3 @@ pub fn eq_mac_args(l: &MacArgs, r: &MacArgs) -> bool {\n         _ => false,\n     }\n }\n-\n-/// Extract args from an assert-like macro.\n-///\n-/// Currently working with:\n-/// - `assert_eq!` and `assert_ne!`\n-/// - `debug_assert_eq!` and `debug_assert_ne!`\n-///\n-/// For example:\n-///\n-/// `debug_assert_eq!(a, b)` will return Some([a, b])\n-pub fn extract_assert_macro_args(mut expr: &Expr) -> Option<[&Expr; 2]> {\n-    if_chain! {\n-        if let ExprKind::If(_, ref block, _) = expr.kind;\n-        if let StmtKind::Semi(ref e) = block.stmts.get(0)?.kind;\n-        then {\n-            expr = e;\n-        }\n-    }\n-    if_chain! {\n-        if let ExprKind::Block(ref block, _) = expr.kind;\n-        if let StmtKind::Expr(ref expr) = block.stmts.get(0)?.kind;\n-        if let ExprKind::Match(ref match_expr, _) = expr.kind;\n-        if let ExprKind::Tup(ref tup) = match_expr.kind;\n-        if let [a, b, ..] = tup.as_slice();\n-        if let (&ExprKind::AddrOf(_, _, ref a), &ExprKind::AddrOf(_, _, ref b)) = (&a.kind, &b.kind);\n-        then {\n-            return Some([&*a, &*b]);\n-        }\n-    }\n-    None\n-}"}, {"sha": "34c5af848a6dbe1bfaa92ec1efbfae3e4b4624bf", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -223,7 +223,7 @@ pub fn constant_simple<'tcx>(\n     constant(lcx, typeck_results, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n }\n \n-pub fn constant_full_int(\n+pub fn constant_full_int<'tcx>(\n     lcx: &LateContext<'tcx>,\n     typeck_results: &ty::TypeckResults<'tcx>,\n     e: &Expr<'_>,"}, {"sha": "ca222c3d669956d4b97eb5e4bd9f46ead9aa0d1d", "filename": "src/tools/clippy/clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -198,7 +198,7 @@ pub fn span_lint_hir_and_then(\n ///     |\n ///     = note: `-D fold-any` implied by `-D warnings`\n /// ```\n-#[cfg_attr(feature = \"internal-lints\", allow(clippy::collapsible_span_lint_calls))]\n+#[cfg_attr(feature = \"internal\", allow(clippy::collapsible_span_lint_calls))]\n pub fn span_lint_and_sugg<'a, T: LintContext>(\n     cx: &'a T,\n     lint: &'static Lint,"}, {"sha": "c3936ec95d46dc077edb1a1e6d251005be252142", "filename": "src/tools/clippy/clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -45,7 +45,12 @@ impl ops::BitOrAssign for EagernessSuggestion {\n }\n \n /// Determine the eagerness of the given function call.\n-fn fn_eagerness(cx: &LateContext<'tcx>, fn_id: DefId, name: Symbol, args: &'tcx [Expr<'_>]) -> EagernessSuggestion {\n+fn fn_eagerness<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    fn_id: DefId,\n+    name: Symbol,\n+    args: &'tcx [Expr<'_>],\n+) -> EagernessSuggestion {\n     use EagernessSuggestion::{Eager, Lazy, NoChange};\n     let name = name.as_str();\n \n@@ -92,7 +97,7 @@ fn fn_eagerness(cx: &LateContext<'tcx>, fn_id: DefId, name: Symbol, args: &'tcx\n }\n \n #[allow(clippy::too_many_lines)]\n-fn expr_eagerness(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> EagernessSuggestion {\n+fn expr_eagerness<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> EagernessSuggestion {\n     struct V<'cx, 'tcx> {\n         cx: &'cx LateContext<'tcx>,\n         eagerness: EagernessSuggestion,\n@@ -225,11 +230,11 @@ fn expr_eagerness(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> EagernessSuggest\n }\n \n /// Whether the given expression should be changed to evaluate eagerly\n-pub fn switch_to_eager_eval(cx: &'_ LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+pub fn switch_to_eager_eval<'tcx>(cx: &'_ LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n     expr_eagerness(cx, expr) == EagernessSuggestion::Eager\n }\n \n /// Whether the given expression should be changed to evaluate lazily\n-pub fn switch_to_lazy_eval(cx: &'_ LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+pub fn switch_to_lazy_eval<'tcx>(cx: &'_ LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n     expr_eagerness(cx, expr) == EagernessSuggestion::Lazy\n }"}, {"sha": "160a51740cd7cde24cf8f31fa13a52fb02925ff8", "filename": "src/tools/clippy/clippy_utils/src/higher.rs", "status": "modified", "additions": 3, "deletions": 292, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -3,15 +3,13 @@\n #![deny(clippy::missing_docs_in_private_items)]\n \n use crate::ty::is_type_diagnostic_item;\n-use crate::{is_expn_of, last_path_segment, match_def_path, paths};\n+use crate::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::{self, LitKind};\n use rustc_hir as hir;\n-use rustc_hir::{\n-    Arm, Block, BorrowKind, Expr, ExprKind, HirId, LoopSource, MatchSource, Node, Pat, QPath, StmtKind, UnOp,\n-};\n+use rustc_hir::{Arm, Block, Expr, ExprKind, HirId, LoopSource, MatchSource, Node, Pat, QPath};\n use rustc_lint::LateContext;\n-use rustc_span::{sym, symbol, ExpnKind, Span, Symbol};\n+use rustc_span::{sym, symbol, Span};\n \n /// The essential nodes of a desugared for loop as well as the entire span:\n /// `for pat in arg { body }` becomes `(pat, arg, body)`. Return `(pat, arg, body, span)`.\n@@ -428,293 +426,6 @@ pub fn binop(op: hir::BinOpKind) -> ast::BinOpKind {\n     }\n }\n \n-/// Extract args from an assert-like macro.\n-/// Currently working with:\n-/// - `assert!`, `assert_eq!` and `assert_ne!`\n-/// - `debug_assert!`, `debug_assert_eq!` and `debug_assert_ne!`\n-/// For example:\n-/// `assert!(expr)` will return `Some([expr])`\n-/// `debug_assert_eq!(a, b)` will return `Some([a, b])`\n-pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx Expr<'tcx>>> {\n-    /// Try to match the AST for a pattern that contains a match, for example when two args are\n-    /// compared\n-    fn ast_matchblock(matchblock_expr: &'tcx Expr<'tcx>) -> Option<Vec<&Expr<'_>>> {\n-        if_chain! {\n-            if let ExprKind::Match(headerexpr, _, _) = &matchblock_expr.kind;\n-            if let ExprKind::Tup([lhs, rhs]) = &headerexpr.kind;\n-            if let ExprKind::AddrOf(BorrowKind::Ref, _, lhs) = lhs.kind;\n-            if let ExprKind::AddrOf(BorrowKind::Ref, _, rhs) = rhs.kind;\n-            then {\n-                return Some(vec![lhs, rhs]);\n-            }\n-        }\n-        None\n-    }\n-\n-    if let ExprKind::Block(block, _) = e.kind {\n-        if block.stmts.len() == 1 {\n-            if let StmtKind::Semi(matchexpr) = block.stmts.get(0)?.kind {\n-                // macros with unique arg: `{debug_}assert!` (e.g., `debug_assert!(some_condition)`)\n-                if_chain! {\n-                    if let Some(If { cond, .. }) = If::hir(matchexpr);\n-                    if let ExprKind::Unary(UnOp::Not, condition) = cond.kind;\n-                    then {\n-                        return Some(vec![condition]);\n-                    }\n-                }\n-\n-                // debug macros with two args: `debug_assert_{ne, eq}` (e.g., `assert_ne!(a, b)`)\n-                if_chain! {\n-                    if let ExprKind::Block(matchblock,_) = matchexpr.kind;\n-                    if let Some(matchblock_expr) = matchblock.expr;\n-                    then {\n-                        return ast_matchblock(matchblock_expr);\n-                    }\n-                }\n-            }\n-        } else if let Some(matchblock_expr) = block.expr {\n-            // macros with two args: `assert_{ne, eq}` (e.g., `assert_ne!(a, b)`)\n-            return ast_matchblock(matchblock_expr);\n-        }\n-    }\n-    None\n-}\n-\n-/// A parsed `format!` expansion\n-pub struct FormatExpn<'tcx> {\n-    /// Span of `format!(..)`\n-    pub call_site: Span,\n-    /// Inner `format_args!` expansion\n-    pub format_args: FormatArgsExpn<'tcx>,\n-}\n-\n-impl FormatExpn<'tcx> {\n-    /// Parses an expanded `format!` invocation\n-    pub fn parse(expr: &'tcx Expr<'tcx>) -> Option<Self> {\n-        if_chain! {\n-            if let ExprKind::Block(block, _) = expr.kind;\n-            if let [stmt] = block.stmts;\n-            if let StmtKind::Local(local) = stmt.kind;\n-            if let Some(init) = local.init;\n-            if let ExprKind::Call(_, [format_args]) = init.kind;\n-            let expn_data = expr.span.ctxt().outer_expn_data();\n-            if let ExpnKind::Macro(_, sym::format) = expn_data.kind;\n-            if let Some(format_args) = FormatArgsExpn::parse(format_args);\n-            then {\n-                Some(FormatExpn {\n-                    call_site: expn_data.call_site,\n-                    format_args,\n-                })\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-/// A parsed `format_args!` expansion\n-pub struct FormatArgsExpn<'tcx> {\n-    /// Span of the first argument, the format string\n-    pub format_string_span: Span,\n-    /// Values passed after the format string\n-    pub value_args: Vec<&'tcx Expr<'tcx>>,\n-\n-    /// String literal expressions which represent the format string split by \"{}\"\n-    pub format_string_parts: &'tcx [Expr<'tcx>],\n-    /// Symbols corresponding to [`Self::format_string_parts`]\n-    pub format_string_symbols: Vec<Symbol>,\n-    /// Expressions like `ArgumentV1::new(arg0, Debug::fmt)`\n-    pub args: &'tcx [Expr<'tcx>],\n-    /// The final argument passed to `Arguments::new_v1_formatted`, if applicable\n-    pub fmt_expr: Option<&'tcx Expr<'tcx>>,\n-}\n-\n-impl FormatArgsExpn<'tcx> {\n-    /// Parses an expanded `format_args!` or `format_args_nl!` invocation\n-    pub fn parse(expr: &'tcx Expr<'tcx>) -> Option<Self> {\n-        if_chain! {\n-            if let ExpnKind::Macro(_, name) = expr.span.ctxt().outer_expn_data().kind;\n-            let name = name.as_str();\n-            if name.ends_with(\"format_args\") || name.ends_with(\"format_args_nl\");\n-            if let ExprKind::Call(_, args) = expr.kind;\n-            if let Some((strs_ref, args, fmt_expr)) = match args {\n-                // Arguments::new_v1\n-                [strs_ref, args] => Some((strs_ref, args, None)),\n-                // Arguments::new_v1_formatted\n-                [strs_ref, args, fmt_expr, _unsafe_arg] => Some((strs_ref, args, Some(fmt_expr))),\n-                _ => None,\n-            };\n-            if let ExprKind::AddrOf(BorrowKind::Ref, _, strs_arr) = strs_ref.kind;\n-            if let ExprKind::Array(format_string_parts) = strs_arr.kind;\n-            if let Some(format_string_symbols) = format_string_parts\n-                .iter()\n-                .map(|e| {\n-                    if let ExprKind::Lit(lit) = &e.kind {\n-                        if let LitKind::Str(symbol, _style) = lit.node {\n-                            return Some(symbol);\n-                        }\n-                    }\n-                    None\n-                })\n-                .collect();\n-            if let ExprKind::AddrOf(BorrowKind::Ref, _, args) = args.kind;\n-            if let ExprKind::Match(args, [arm], _) = args.kind;\n-            if let ExprKind::Tup(value_args) = args.kind;\n-            if let Some(value_args) = value_args\n-                .iter()\n-                .map(|e| match e.kind {\n-                    ExprKind::AddrOf(_, _, e) => Some(e),\n-                    _ => None,\n-                })\n-                .collect();\n-            if let ExprKind::Array(args) = arm.body.kind;\n-            then {\n-                Some(FormatArgsExpn {\n-                    format_string_span: strs_ref.span,\n-                    value_args,\n-                    format_string_parts,\n-                    format_string_symbols,\n-                    args,\n-                    fmt_expr,\n-                })\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n-    /// Returns a vector of `FormatArgsArg`.\n-    pub fn args(&self) -> Option<Vec<FormatArgsArg<'tcx>>> {\n-        if let Some(expr) = self.fmt_expr {\n-            if_chain! {\n-                if let ExprKind::AddrOf(BorrowKind::Ref, _, expr) = expr.kind;\n-                if let ExprKind::Array(exprs) = expr.kind;\n-                then {\n-                    exprs.iter().map(|fmt| {\n-                        if_chain! {\n-                            // struct `core::fmt::rt::v1::Argument`\n-                            if let ExprKind::Struct(_, fields, _) = fmt.kind;\n-                            if let Some(position_field) = fields.iter().find(|f| f.ident.name == sym::position);\n-                            if let ExprKind::Lit(lit) = &position_field.expr.kind;\n-                            if let LitKind::Int(position, _) = lit.node;\n-                            if let Ok(i) = usize::try_from(position);\n-                            let arg = &self.args[i];\n-                            if let ExprKind::Call(_, [arg_name, _]) = arg.kind;\n-                            if let ExprKind::Field(_, j) = arg_name.kind;\n-                            if let Ok(j) = j.name.as_str().parse::<usize>();\n-                            then {\n-                                Some(FormatArgsArg { value: self.value_args[j], arg, fmt: Some(fmt) })\n-                            } else {\n-                                None\n-                            }\n-                        }\n-                    }).collect()\n-                } else {\n-                    None\n-                }\n-            }\n-        } else {\n-            Some(\n-                self.value_args\n-                    .iter()\n-                    .zip(self.args.iter())\n-                    .map(|(value, arg)| FormatArgsArg { value, arg, fmt: None })\n-                    .collect(),\n-            )\n-        }\n-    }\n-}\n-\n-/// Type representing a `FormatArgsExpn`'s format arguments\n-pub struct FormatArgsArg<'tcx> {\n-    /// An element of `value_args` according to `position`\n-    pub value: &'tcx Expr<'tcx>,\n-    /// An element of `args` according to `position`\n-    pub arg: &'tcx Expr<'tcx>,\n-    /// An element of `fmt_expn`\n-    pub fmt: Option<&'tcx Expr<'tcx>>,\n-}\n-\n-impl<'tcx> FormatArgsArg<'tcx> {\n-    /// Returns true if any formatting parameters are used that would have an effect on strings,\n-    /// like `{:+2}` instead of just `{}`.\n-    pub fn has_string_formatting(&self) -> bool {\n-        self.fmt.map_or(false, |fmt| {\n-            // `!` because these conditions check that `self` is unformatted.\n-            !if_chain! {\n-                // struct `core::fmt::rt::v1::Argument`\n-                if let ExprKind::Struct(_, fields, _) = fmt.kind;\n-                if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n-                // struct `core::fmt::rt::v1::FormatSpec`\n-                if let ExprKind::Struct(_, subfields, _) = format_field.expr.kind;\n-                let mut precision_found = false;\n-                let mut width_found = false;\n-                if subfields.iter().all(|field| {\n-                    match field.ident.name {\n-                        sym::precision => {\n-                            precision_found = true;\n-                            if let ExprKind::Path(ref precision_path) = field.expr.kind {\n-                                last_path_segment(precision_path).ident.name == sym::Implied\n-                            } else {\n-                                false\n-                            }\n-                        }\n-                        sym::width => {\n-                            width_found = true;\n-                            if let ExprKind::Path(ref width_qpath) = field.expr.kind {\n-                                last_path_segment(width_qpath).ident.name == sym::Implied\n-                            } else {\n-                                false\n-                            }\n-                        }\n-                        _ => true,\n-                    }\n-                });\n-                if precision_found && width_found;\n-                then { true } else { false }\n-            }\n-        })\n-    }\n-\n-    /// Returns true if the argument is formatted using `Display::fmt`.\n-    pub fn is_display(&self) -> bool {\n-        if_chain! {\n-            if let ExprKind::Call(_, [_, format_field]) = self.arg.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, path)) = format_field.kind;\n-            if let [.., t, _] = path.segments;\n-            if t.ident.name == sym::Display;\n-            then { true } else { false }\n-        }\n-    }\n-}\n-\n-/// A parsed `panic!` expansion\n-pub struct PanicExpn<'tcx> {\n-    /// Span of `panic!(..)`\n-    pub call_site: Span,\n-    /// Inner `format_args!` expansion\n-    pub format_args: FormatArgsExpn<'tcx>,\n-}\n-\n-impl PanicExpn<'tcx> {\n-    /// Parses an expanded `panic!` invocation\n-    pub fn parse(expr: &'tcx Expr<'tcx>) -> Option<Self> {\n-        if_chain! {\n-            if let ExprKind::Call(_, [format_args]) = expr.kind;\n-            let expn_data = expr.span.ctxt().outer_expn_data();\n-            if let Some(format_args) = FormatArgsExpn::parse(format_args);\n-            then {\n-                Some(PanicExpn {\n-                    call_site: expn_data.call_site,\n-                    format_args,\n-                })\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-}\n-\n /// A parsed `Vec` initialization expression\n #[derive(Clone, Copy)]\n pub enum VecInitKind {"}, {"sha": "5a08a411dd13f5bc338ae60e3f7d6c29c1675eb9", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -6,9 +6,9 @@ use rustc_data_structures::fx::FxHasher;\n use rustc_hir::def::Res;\n use rustc_hir::HirIdMap;\n use rustc_hir::{\n-    BinOpKind, Block, BodyId, Expr, ExprField, ExprKind, FnRetTy, GenericArg, GenericArgs, Guard, HirId,\n+    ArrayLen, BinOpKind, Block, BodyId, Expr, ExprField, ExprKind, FnRetTy, GenericArg, GenericArgs, Guard, HirId,\n     InlineAsmOperand, Let, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path, PathSegment, QPath, Stmt,\n-    StmtKind, Ty, TyKind, TypeBinding, ArrayLen\n+    StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::LateContext;\n@@ -171,11 +171,11 @@ impl HirEqInterExpr<'_, '_, '_> {\n     }\n \n     pub fn eq_array_length(&mut self, left: ArrayLen, right: ArrayLen) -> bool {\n-            match (left, right) {\n-                (ArrayLen::Infer(..), ArrayLen::Infer(..)) => true,\n-                (ArrayLen::Body(l_ct), ArrayLen::Body(r_ct)) => self.eq_body(l_ct.body, r_ct.body),\n-                (_, _) => false,\n-            }\n+        match (left, right) {\n+            (ArrayLen::Infer(..), ArrayLen::Infer(..)) => true,\n+            (ArrayLen::Body(l_ct), ArrayLen::Body(r_ct)) => self.eq_body(l_ct.body, r_ct.body),\n+            (_, _) => false,\n+        }\n     }\n \n     pub fn eq_body(&mut self, left: BodyId, right: BodyId) -> bool {\n@@ -396,12 +396,10 @@ impl HirEqInterExpr<'_, '_, '_> {\n     }\n \n     #[allow(clippy::similar_names)]\n-    fn eq_ty(&mut self, left: &Ty<'_>, right: &Ty<'_>) -> bool {\n+    pub fn eq_ty(&mut self, left: &Ty<'_>, right: &Ty<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n             (&TyKind::Slice(l_vec), &TyKind::Slice(r_vec)) => self.eq_ty(l_vec, r_vec),\n-            (&TyKind::Array(lt, ll), &TyKind::Array(rt, rl)) => {\n-                self.eq_ty(lt, rt) && self.eq_array_length(ll, rl)\n-            },\n+            (&TyKind::Array(lt, ll), &TyKind::Array(rt, rl)) => self.eq_ty(lt, rt) && self.eq_array_length(ll, rl),\n             (&TyKind::Ptr(ref l_mut), &TyKind::Ptr(ref r_mut)) => {\n                 l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty)\n             },\n@@ -853,6 +851,8 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     pub fn hash_path(&mut self, path: &Path<'_>) {\n         match path.res {\n             // constant hash since equality is dependant on inter-expression context\n+            // e.g. The expressions `if let Some(x) = foo() {}` and `if let Some(y) = foo() {}` are considered equal\n+            // even though the binding names are different and they have different `HirId`s.\n             Res::Local(_) => 1_usize.hash(&mut self.s),\n             _ => {\n                 for seg in path.segments {\n@@ -963,7 +963,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n     pub fn hash_array_length(&mut self, length: ArrayLen) {\n         match length {\n-            ArrayLen::Infer(..) => {}\n+            ArrayLen::Infer(..) => {},\n             ArrayLen::Body(anon_const) => self.hash_body(anon_const.body),\n         }\n     }"}, {"sha": "57183b58b2a11922bbf81848c735362d51be3bb8", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 71, "deletions": 77, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,6 +1,5 @@\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n-#![feature(in_band_lifetimes)]\n #![feature(let_else)]\n #![feature(once_cell)]\n #![feature(rustc_private)]\n@@ -44,6 +43,7 @@ pub mod diagnostics;\n pub mod eager_or_lazy;\n pub mod higher;\n mod hir_utils;\n+pub mod macros;\n pub mod msrvs;\n pub mod numeric_literal;\n pub mod paths;\n@@ -70,16 +70,16 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n use rustc_hir::intravisit::{walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n-    def, Arm, BindingAnnotation, Block, BlockCheckMode, Body, Constness, Destination, Expr, ExprKind, FnDecl,\n-    ForeignItem, GenericArgs, HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local,\n-    MatchSource, Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem,\n-    TraitItemKind, TraitRef, TyKind, UnOp, ArrayLen\n+    def, lang_items, Arm, ArrayLen, BindingAnnotation, Block, BlockCheckMode, Body, Constness, Destination, Expr,\n+    ExprKind, FnDecl, ForeignItem, GenericArgs, HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem,\n+    Local, MatchSource, Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind,\n+    Target, TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::map::Map;\n@@ -126,7 +126,7 @@ macro_rules! extract_msrv_attr {\n         extract_msrv_attr!(@EarlyContext);\n     };\n     (@$context:ident$(, $call:tt)?) => {\n-        fn enter_lint_attrs(&mut self, cx: &rustc_lint::$context<'tcx>, attrs: &'tcx [rustc_ast::ast::Attribute]) {\n+        fn enter_lint_attrs(&mut self, cx: &rustc_lint::$context<'_>, attrs: &[rustc_ast::ast::Attribute]) {\n             use $crate::get_unique_inner_attr;\n             match get_unique_inner_attr(cx.sess$($call)?, attrs, \"msrv\") {\n                 Some(msrv_attr) => {\n@@ -146,13 +146,6 @@ macro_rules! extract_msrv_attr {\n     };\n }\n \n-/// Returns `true` if the span comes from a macro expansion, no matter if from a\n-/// macro by example or from a procedural macro\n-#[must_use]\n-pub fn in_macro(span: Span) -> bool {\n-    span.from_expansion() && !matches!(span.ctxt().outer_expn_data().kind, ExpnKind::Desugaring(..))\n-}\n-\n /// Returns `true` if the two spans come from differing expansions (i.e., one is\n /// from a macro and one isn't).\n #[must_use]\n@@ -282,7 +275,11 @@ pub fn is_wild(pat: &Pat<'_>) -> bool {\n }\n \n /// Checks if the first type parameter is a lang item.\n-pub fn is_ty_param_lang_item(cx: &LateContext<'_>, qpath: &QPath<'tcx>, item: LangItem) -> Option<&'tcx hir::Ty<'tcx>> {\n+pub fn is_ty_param_lang_item<'tcx>(\n+    cx: &LateContext<'_>,\n+    qpath: &QPath<'tcx>,\n+    item: LangItem,\n+) -> Option<&'tcx hir::Ty<'tcx>> {\n     let ty = get_qpath_generic_tys(qpath).next()?;\n \n     if let TyKind::Path(qpath) = &ty.kind {\n@@ -298,7 +295,7 @@ pub fn is_ty_param_lang_item(cx: &LateContext<'_>, qpath: &QPath<'tcx>, item: La\n }\n \n /// Checks if the first type parameter is a diagnostic item.\n-pub fn is_ty_param_diagnostic_item(\n+pub fn is_ty_param_diagnostic_item<'tcx>(\n     cx: &LateContext<'_>,\n     qpath: &QPath<'tcx>,\n     item: Symbol,\n@@ -375,15 +372,15 @@ pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n     }\n }\n \n-pub fn get_qpath_generics(path: &QPath<'tcx>) -> Option<&'tcx GenericArgs<'tcx>> {\n+pub fn get_qpath_generics<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx GenericArgs<'tcx>> {\n     match path {\n         QPath::Resolved(_, p) => p.segments.last().and_then(|s| s.args),\n         QPath::TypeRelative(_, s) => s.args,\n         QPath::LangItem(..) => None,\n     }\n }\n \n-pub fn get_qpath_generic_tys(path: &QPath<'tcx>) -> impl Iterator<Item = &'tcx hir::Ty<'tcx>> {\n+pub fn get_qpath_generic_tys<'tcx>(path: &QPath<'tcx>) -> impl Iterator<Item = &'tcx hir::Ty<'tcx>> {\n     get_qpath_generics(path)\n         .map_or([].as_ref(), |a| a.args)\n         .iter()\n@@ -522,7 +519,7 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n             }\n         };\n     }\n-    fn item_child_by_name<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, name: &str) -> Option<Res> {\n+    fn item_child_by_name(tcx: TyCtxt<'_>, def_id: DefId, name: &str) -> Option<Res> {\n         match tcx.def_kind(def_id) {\n             DefKind::Mod | DefKind::Enum | DefKind::Trait => tcx\n                 .module_children(def_id)\n@@ -538,18 +535,34 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n             _ => None,\n         }\n     }\n+    fn find_primitive(tcx: TyCtxt<'_>, name: &str) -> Option<DefId> {\n+        if let Some(&(index, Target::Impl)) = lang_items::ITEM_REFS.get(&Symbol::intern(name)) {\n+            tcx.lang_items().items()[index]\n+        } else {\n+            None\n+        }\n+    }\n+    fn find_crate(tcx: TyCtxt<'_>, name: &str) -> Option<DefId> {\n+        tcx.crates(())\n+            .iter()\n+            .find(|&&num| tcx.crate_name(num).as_str() == name)\n+            .map(CrateNum::as_def_id)\n+    }\n \n-    let (krate, first, path) = match *path {\n-        [krate, first, ref path @ ..] => (krate, first, path),\n+    let (base, first, path) = match *path {\n+        [base, first, ref path @ ..] => (base, first, path),\n         [primitive] => {\n             return PrimTy::from_name(Symbol::intern(primitive)).map_or(Res::Err, Res::PrimTy);\n         },\n         _ => return Res::Err,\n     };\n     let tcx = cx.tcx;\n-    let crates = tcx.crates(());\n-    let krate = try_res!(crates.iter().find(|&&num| tcx.crate_name(num).as_str() == krate));\n-    let first = try_res!(item_child_by_name(tcx, krate.as_def_id(), first));\n+    let first = try_res!(\n+        find_primitive(tcx, base)\n+            .or_else(|| find_crate(tcx, base))\n+            .and_then(|id| item_child_by_name(tcx, id, first))\n+    );\n+\n     let last = path\n         .iter()\n         .copied()\n@@ -628,6 +641,19 @@ fn projection_stack<'a, 'hir>(mut e: &'a Expr<'hir>) -> (Vec<&'a Expr<'hir>>, &'\n     (result, root)\n }\n \n+/// Gets the mutability of the custom deref adjustment, if any.\n+pub fn expr_custom_deref_adjustment(cx: &LateContext<'_>, e: &Expr<'_>) -> Option<Mutability> {\n+    cx.typeck_results()\n+        .expr_adjustments(e)\n+        .iter()\n+        .find_map(|a| match a.kind {\n+            Adjust::Deref(Some(d)) => Some(Some(d.mutbl)),\n+            Adjust::Deref(None) => None,\n+            _ => Some(None),\n+        })\n+        .and_then(|x| x)\n+}\n+\n /// Checks if two expressions can be mutably borrowed simultaneously\n /// and they aren't dependent on borrowing same thing twice\n pub fn can_mut_borrow_both(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>) -> bool {\n@@ -636,7 +662,15 @@ pub fn can_mut_borrow_both(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>) -\n     if !eq_expr_value(cx, r1, r2) {\n         return true;\n     }\n+    if expr_custom_deref_adjustment(cx, r1).is_some() || expr_custom_deref_adjustment(cx, r2).is_some() {\n+        return false;\n+    }\n+\n     for (x1, x2) in s1.iter().zip(s2.iter()) {\n+        if expr_custom_deref_adjustment(cx, x1).is_some() || expr_custom_deref_adjustment(cx, x2).is_some() {\n+            return false;\n+        }\n+\n         match (&x1.kind, &x2.kind) {\n             (ExprKind::Field(_, i1), ExprKind::Field(_, i2)) => {\n                 if i1 != i2 {\n@@ -710,8 +744,7 @@ pub fn is_default_equivalent(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n             _ => false,\n         },\n         ExprKind::Tup(items) | ExprKind::Array(items) => items.iter().all(|x| is_default_equivalent(cx, x)),\n-        ExprKind::Repeat(x, len) => if_chain! {\n-            if let ArrayLen::Body(len) = len;\n+        ExprKind::Repeat(x, ArrayLen::Body(len)) => if_chain! {\n             if let ExprKind::Lit(ref const_lit) = cx.tcx.hir().body(len.body).value.kind;\n             if let LitKind::Int(v, _) = const_lit.node;\n             if v <= 32 && is_default_equivalent(cx, x);\n@@ -760,7 +793,7 @@ pub fn is_default_equivalent(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n ///\n /// Note that this check is not recursive, so passing the `if` expression will always return true\n /// even though sub-expressions might return false.\n-pub fn can_move_expr_to_closure_no_visit(\n+pub fn can_move_expr_to_closure_no_visit<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n     loop_ids: &[HirId],\n@@ -835,7 +868,7 @@ impl std::ops::BitOrAssign for CaptureKind {\n /// Note as this will walk up to parent expressions until the capture can be determined it should\n /// only be used while making a closure somewhere a value is consumed. e.g. a block, match arm, or\n /// function argument (other than a receiver).\n-pub fn capture_local_usage(cx: &LateContext<'tcx>, e: &Expr<'_>) -> CaptureKind {\n+pub fn capture_local_usage<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>) -> CaptureKind {\n     fn pat_capture_kind(cx: &LateContext<'_>, pat: &Pat<'_>) -> CaptureKind {\n         let mut capture = CaptureKind::Ref(Mutability::Not);\n         pat.each_binding_or_first(&mut |_, id, span, _| match cx\n@@ -935,7 +968,7 @@ pub fn capture_local_usage(cx: &LateContext<'tcx>, e: &Expr<'_>) -> CaptureKind\n \n /// Checks if the expression can be moved into a closure as is. This will return a list of captures\n /// if so, otherwise, `None`.\n-pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<HirIdMap<CaptureKind>> {\n+pub fn can_move_expr_to_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<HirIdMap<CaptureKind>> {\n     struct V<'cx, 'tcx> {\n         cx: &'cx LateContext<'tcx>,\n         // Stack of potential break targets contained in the expression.\n@@ -948,7 +981,7 @@ pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) ->\n         /// mutable reference.\n         captures: HirIdMap<CaptureKind>,\n     }\n-    impl Visitor<'tcx> for V<'_, 'tcx> {\n+    impl<'tcx> Visitor<'tcx> for V<'_, 'tcx> {\n         type Map = ErasedMap<'tcx>;\n         fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n             NestedVisitorMap::None\n@@ -1146,19 +1179,6 @@ pub fn contains_return(expr: &hir::Expr<'_>) -> bool {\n     found\n }\n \n-/// Finds calls of the specified macros in a function body.\n-pub fn find_macro_calls(names: &[&str], body: &Body<'_>) -> Vec<Span> {\n-    let mut result = Vec::new();\n-    expr_visitor_no_bodies(|expr| {\n-        if names.iter().any(|fun| is_expn_of(expr.span, fun).is_some()) {\n-            result.push(expr.span);\n-        }\n-        true\n-    })\n-    .visit_expr(&body.value);\n-    result\n-}\n-\n /// Extends the span to the beginning of the spans line, incl. whitespaces.\n ///\n /// ```rust\n@@ -1218,7 +1238,7 @@ pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n }\n \n /// Gets the loop or closure enclosing the given expression, if any.\n-pub fn get_enclosing_loop_or_closure(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+pub fn get_enclosing_loop_or_closure<'tcx>(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     for (_, node) in tcx.hir().parent_iter(expr.hir_id) {\n         match node {\n             Node::Expr(\n@@ -1687,32 +1707,6 @@ pub fn match_libc_symbol(cx: &LateContext<'_>, did: DefId, name: &str) -> bool {\n     path.first().map_or(false, |s| s.as_str() == \"libc\") && path.last().map_or(false, |s| s.as_str() == name)\n }\n \n-pub fn match_panic_call(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    if let ExprKind::Call(func, [arg]) = expr.kind {\n-        expr_path_res(cx, func)\n-            .opt_def_id()\n-            .map_or(false, |id| match_panic_def_id(cx, id))\n-            .then(|| arg)\n-    } else {\n-        None\n-    }\n-}\n-\n-pub fn match_panic_def_id(cx: &LateContext<'_>, did: DefId) -> bool {\n-    match_any_def_paths(\n-        cx,\n-        did,\n-        &[\n-            &paths::BEGIN_PANIC,\n-            &paths::PANIC_ANY,\n-            &paths::PANICKING_PANIC,\n-            &paths::PANICKING_PANIC_FMT,\n-            &paths::PANICKING_PANIC_STR,\n-        ],\n-    )\n-    .is_some()\n-}\n-\n /// Returns the list of condition expressions and the list of blocks in a\n /// sequence of `if/else`.\n /// E.g., this returns `([a, b], [c, d, e])` for the expression\n@@ -1752,7 +1746,7 @@ pub fn is_async_fn(kind: FnKind<'_>) -> bool {\n }\n \n /// Peels away all the compiler generated code surrounding the body of an async function,\n-pub fn get_async_fn_body(tcx: TyCtxt<'tcx>, body: &Body<'_>) -> Option<&'tcx Expr<'tcx>> {\n+pub fn get_async_fn_body<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if let ExprKind::Call(\n         _,\n         &[\n@@ -1856,7 +1850,7 @@ pub fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool\n }\n \n /// Gets the node where an expression is either used, or it's type is unified with another branch.\n-pub fn get_expr_use_or_unification_node(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<Node<'tcx>> {\n+pub fn get_expr_use_or_unification_node<'tcx>(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<Node<'tcx>> {\n     let mut child_id = expr.hir_id;\n     let mut iter = tcx.hir().parent_iter(child_id);\n     loop {\n@@ -2062,8 +2056,8 @@ where\n \n /// Peels off all references on the pattern. Returns the underlying pattern and the number of\n /// references removed.\n-pub fn peel_hir_pat_refs(pat: &'a Pat<'a>) -> (&'a Pat<'a>, usize) {\n-    fn peel(pat: &'a Pat<'a>, count: usize) -> (&'a Pat<'a>, usize) {\n+pub fn peel_hir_pat_refs<'a>(pat: &'a Pat<'a>) -> (&'a Pat<'a>, usize) {\n+    fn peel<'a>(pat: &'a Pat<'a>, count: usize) -> (&'a Pat<'a>, usize) {\n         if let PatKind::Ref(pat, _) = pat.kind {\n             peel(pat, count + 1)\n         } else {\n@@ -2086,7 +2080,7 @@ pub fn peel_hir_expr_while<'tcx>(\n \n /// Peels off up to the given number of references on the expression. Returns the underlying\n /// expression and the number of references removed.\n-pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n+pub fn peel_n_hir_expr_refs<'a>(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>, usize) {\n     let mut remaining = count;\n     let e = peel_hir_expr_while(expr, |e| match e.kind {\n         ExprKind::AddrOf(ast::BorrowKind::Ref, _, e) if remaining != 0 => {\n@@ -2100,7 +2094,7 @@ pub fn peel_n_hir_expr_refs(expr: &'a Expr<'a>, count: usize) -> (&'a Expr<'a>,\n \n /// Peels off all references on the expression. Returns the underlying expression and the number of\n /// references removed.\n-pub fn peel_hir_expr_refs(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n+pub fn peel_hir_expr_refs<'a>(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n     let mut count = 0;\n     let e = peel_hir_expr_while(expr, |e| match e.kind {\n         ExprKind::AddrOf(ast::BorrowKind::Ref, _, e) => {\n@@ -2183,7 +2177,7 @@ impl<'hir> ItemLikeVisitor<'hir> for TestItemNamesVisitor<'hir> {\n \n static TEST_ITEM_NAMES_CACHE: SyncOnceCell<Mutex<FxHashMap<LocalDefId, Vec<Symbol>>>> = SyncOnceCell::new();\n \n-fn with_test_item_names(tcx: TyCtxt<'tcx>, module: LocalDefId, f: impl Fn(&[Symbol]) -> bool) -> bool {\n+fn with_test_item_names<'tcx>(tcx: TyCtxt<'tcx>, module: LocalDefId, f: impl Fn(&[Symbol]) -> bool) -> bool {\n     let cache = TEST_ITEM_NAMES_CACHE.get_or_init(|| Mutex::new(FxHashMap::default()));\n     let mut map: MutexGuard<'_, FxHashMap<LocalDefId, Vec<Symbol>>> = cache.lock().unwrap();\n     match map.entry(module) {"}, {"sha": "b7a242cf90a43369e752aa36451fd8e65b52f597", "filename": "src/tools/clippy/clippy_utils/src/macros.rs", "status": "added", "additions": 539, "deletions": 0, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,539 @@\n+#![allow(clippy::similar_names)] // `expr` and `expn`\n+\n+use crate::visitors::expr_visitor_no_bodies;\n+\n+use arrayvec::ArrayVec;\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{self as hir, Expr, ExprKind, HirId, Node, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::def_id::DefId;\n+use rustc_span::hygiene::{MacroKind, SyntaxContext};\n+use rustc_span::{sym, ExpnData, ExpnId, ExpnKind, Span, Symbol};\n+use std::ops::ControlFlow;\n+\n+/// A macro call, like `vec![1, 2, 3]`.\n+///\n+/// Use `tcx.item_name(macro_call.def_id)` to get the macro name.\n+/// Even better is to check if it is a diagnostic item.\n+///\n+/// This structure is similar to `ExpnData` but it precludes desugaring expansions.\n+#[derive(Debug)]\n+pub struct MacroCall {\n+    /// Macro `DefId`\n+    pub def_id: DefId,\n+    /// Kind of macro\n+    pub kind: MacroKind,\n+    /// The expansion produced by the macro call\n+    pub expn: ExpnId,\n+    /// Span of the macro call site\n+    pub span: Span,\n+}\n+\n+impl MacroCall {\n+    pub fn is_local(&self) -> bool {\n+        span_is_local(self.span)\n+    }\n+}\n+\n+/// Returns an iterator of expansions that created the given span\n+pub fn expn_backtrace(mut span: Span) -> impl Iterator<Item = (ExpnId, ExpnData)> {\n+    std::iter::from_fn(move || {\n+        let ctxt = span.ctxt();\n+        if ctxt == SyntaxContext::root() {\n+            return None;\n+        }\n+        let expn = ctxt.outer_expn();\n+        let data = expn.expn_data();\n+        span = data.call_site;\n+        Some((expn, data))\n+    })\n+}\n+\n+/// Checks whether the span is from the root expansion or a locally defined macro\n+pub fn span_is_local(span: Span) -> bool {\n+    !span.from_expansion() || expn_is_local(span.ctxt().outer_expn())\n+}\n+\n+/// Checks whether the expansion is the root expansion or a locally defined macro\n+pub fn expn_is_local(expn: ExpnId) -> bool {\n+    if expn == ExpnId::root() {\n+        return true;\n+    }\n+    let data = expn.expn_data();\n+    let backtrace = expn_backtrace(data.call_site);\n+    std::iter::once((expn, data))\n+        .chain(backtrace)\n+        .find_map(|(_, data)| data.macro_def_id)\n+        .map_or(true, DefId::is_local)\n+}\n+\n+/// Returns an iterator of macro expansions that created the given span.\n+/// Note that desugaring expansions are skipped.\n+pub fn macro_backtrace(span: Span) -> impl Iterator<Item = MacroCall> {\n+    expn_backtrace(span).filter_map(|(expn, data)| match data {\n+        ExpnData {\n+            kind: ExpnKind::Macro(kind, _),\n+            macro_def_id: Some(def_id),\n+            call_site: span,\n+            ..\n+        } => Some(MacroCall {\n+            def_id,\n+            kind,\n+            expn,\n+            span,\n+        }),\n+        _ => None,\n+    })\n+}\n+\n+/// If the macro backtrace of `span` has a macro call at the root expansion\n+/// (i.e. not a nested macro call), returns `Some` with the `MacroCall`\n+pub fn root_macro_call(span: Span) -> Option<MacroCall> {\n+    macro_backtrace(span).last()\n+}\n+\n+/// Like [`root_macro_call`], but only returns `Some` if `node` is the \"first node\"\n+/// produced by the macro call, as in [`first_node_in_macro`].\n+pub fn root_macro_call_first_node(cx: &LateContext<'_>, node: &impl HirNode) -> Option<MacroCall> {\n+    if first_node_in_macro(cx, node) != Some(ExpnId::root()) {\n+        return None;\n+    }\n+    root_macro_call(node.span())\n+}\n+\n+/// Like [`macro_backtrace`], but only returns macro calls where `node` is the \"first node\" of the\n+/// macro call, as in [`first_node_in_macro`].\n+pub fn first_node_macro_backtrace(cx: &LateContext<'_>, node: &impl HirNode) -> impl Iterator<Item = MacroCall> {\n+    let span = node.span();\n+    first_node_in_macro(cx, node)\n+        .into_iter()\n+        .flat_map(move |expn| macro_backtrace(span).take_while(move |macro_call| macro_call.expn != expn))\n+}\n+\n+/// If `node` is the \"first node\" in a macro expansion, returns `Some` with the `ExpnId` of the\n+/// macro call site (i.e. the parent of the macro expansion). This generally means that `node`\n+/// is the outermost node of an entire macro expansion, but there are some caveats noted below.\n+/// This is useful for finding macro calls while visiting the HIR without processing the macro call\n+/// at every node within its expansion.\n+///\n+/// If you already have immediate access to the parent node, it is simpler to\n+/// just check the context of that span directly (e.g. `parent.span.from_expansion()`).\n+///\n+/// If a macro call is in statement position, it expands to one or more statements.\n+/// In that case, each statement *and* their immediate descendants will all yield `Some`\n+/// with the `ExpnId` of the containing block.\n+///\n+/// A node may be the \"first node\" of multiple macro calls in a macro backtrace.\n+/// The expansion of the outermost macro call site is returned in such cases.\n+pub fn first_node_in_macro(cx: &LateContext<'_>, node: &impl HirNode) -> Option<ExpnId> {\n+    // get the macro expansion or return `None` if not found\n+    // `macro_backtrace` importantly ignores desugaring expansions\n+    let expn = macro_backtrace(node.span()).next()?.expn;\n+\n+    // get the parent node, possibly skipping over a statement\n+    // if the parent is not found, it is sensible to return `Some(root)`\n+    let hir = cx.tcx.hir();\n+    let mut parent_iter = hir.parent_iter(node.hir_id());\n+    let (parent_id, _) = match parent_iter.next() {\n+        None => return Some(ExpnId::root()),\n+        Some((_, Node::Stmt(_))) => match parent_iter.next() {\n+            None => return Some(ExpnId::root()),\n+            Some(next) => next,\n+        },\n+        Some(next) => next,\n+    };\n+\n+    // get the macro expansion of the parent node\n+    let parent_span = hir.span(parent_id);\n+    let Some(parent_macro_call) = macro_backtrace(parent_span).next() else {\n+        // the parent node is not in a macro\n+        return Some(ExpnId::root());\n+    };\n+\n+    if parent_macro_call.expn.is_descendant_of(expn) {\n+        // `node` is input to a macro call\n+        return None;\n+    }\n+\n+    Some(parent_macro_call.expn)\n+}\n+\n+/* Specific Macro Utils */\n+\n+/// Is `def_id` of `std::panic`, `core::panic` or any inner implementation macros\n+pub fn is_panic(cx: &LateContext<'_>, def_id: DefId) -> bool {\n+    let Some(name) = cx.tcx.get_diagnostic_name(def_id) else { return false };\n+    matches!(\n+        name.as_str(),\n+        \"core_panic_macro\"\n+            | \"std_panic_macro\"\n+            | \"core_panic_2015_macro\"\n+            | \"std_panic_2015_macro\"\n+            | \"core_panic_2021_macro\"\n+    )\n+}\n+\n+pub enum PanicExpn<'a> {\n+    /// No arguments - `panic!()`\n+    Empty,\n+    /// A string literal or any `&str` - `panic!(\"message\")` or `panic!(message)`\n+    Str(&'a Expr<'a>),\n+    /// A single argument that implements `Display` - `panic!(\"{}\", object)`\n+    Display(&'a Expr<'a>),\n+    /// Anything else - `panic!(\"error {}: {}\", a, b)`\n+    Format(FormatArgsExpn<'a>),\n+}\n+\n+impl<'a> PanicExpn<'a> {\n+    pub fn parse(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Self> {\n+        if !macro_backtrace(expr.span).any(|macro_call| is_panic(cx, macro_call.def_id)) {\n+            return None;\n+        }\n+        let ExprKind::Call(callee, [arg]) = &expr.kind else { return None };\n+        let ExprKind::Path(QPath::Resolved(_, path)) = &callee.kind else { return None };\n+        let result = match path.segments.last().unwrap().ident.as_str() {\n+            \"panic\" if arg.span.ctxt() == expr.span.ctxt() => Self::Empty,\n+            \"panic\" | \"panic_str\" => Self::Str(arg),\n+            \"panic_display\" => {\n+                let ExprKind::AddrOf(_, _, e) = &arg.kind else { return None };\n+                Self::Display(e)\n+            },\n+            \"panic_fmt\" => Self::Format(FormatArgsExpn::parse(cx, arg)?),\n+            _ => return None,\n+        };\n+        Some(result)\n+    }\n+}\n+\n+/// Finds the arguments of an `assert!` or `debug_assert!` macro call within the macro expansion\n+pub fn find_assert_args<'a>(\n+    cx: &LateContext<'_>,\n+    expr: &'a Expr<'a>,\n+    expn: ExpnId,\n+) -> Option<(&'a Expr<'a>, PanicExpn<'a>)> {\n+    find_assert_args_inner(cx, expr, expn).map(|([e], p)| (e, p))\n+}\n+\n+/// Finds the arguments of an `assert_eq!` or `debug_assert_eq!` macro call within the macro\n+/// expansion\n+pub fn find_assert_eq_args<'a>(\n+    cx: &LateContext<'_>,\n+    expr: &'a Expr<'a>,\n+    expn: ExpnId,\n+) -> Option<(&'a Expr<'a>, &'a Expr<'a>, PanicExpn<'a>)> {\n+    find_assert_args_inner(cx, expr, expn).map(|([a, b], p)| (a, b, p))\n+}\n+\n+fn find_assert_args_inner<'a, const N: usize>(\n+    cx: &LateContext<'_>,\n+    expr: &'a Expr<'a>,\n+    expn: ExpnId,\n+) -> Option<([&'a Expr<'a>; N], PanicExpn<'a>)> {\n+    let macro_id = expn.expn_data().macro_def_id?;\n+    let (expr, expn) = match cx.tcx.item_name(macro_id).as_str().strip_prefix(\"debug_\") {\n+        None => (expr, expn),\n+        Some(inner_name) => find_assert_within_debug_assert(cx, expr, expn, Symbol::intern(inner_name))?,\n+    };\n+    let mut args = ArrayVec::new();\n+    let mut panic_expn = None;\n+    expr_visitor_no_bodies(|e| {\n+        if args.is_full() {\n+            if panic_expn.is_none() && e.span.ctxt() != expr.span.ctxt() {\n+                panic_expn = PanicExpn::parse(cx, e);\n+            }\n+            panic_expn.is_none()\n+        } else if is_assert_arg(cx, e, expn) {\n+            args.push(e);\n+            false\n+        } else {\n+            true\n+        }\n+    })\n+    .visit_expr(expr);\n+    let args = args.into_inner().ok()?;\n+    // if no `panic!(..)` is found, use `PanicExpn::Empty`\n+    // to indicate that the default assertion message is used\n+    let panic_expn = panic_expn.unwrap_or(PanicExpn::Empty);\n+    Some((args, panic_expn))\n+}\n+\n+fn find_assert_within_debug_assert<'a>(\n+    cx: &LateContext<'_>,\n+    expr: &'a Expr<'a>,\n+    expn: ExpnId,\n+    assert_name: Symbol,\n+) -> Option<(&'a Expr<'a>, ExpnId)> {\n+    let mut found = None;\n+    expr_visitor_no_bodies(|e| {\n+        if found.is_some() || !e.span.from_expansion() {\n+            return false;\n+        }\n+        let e_expn = e.span.ctxt().outer_expn();\n+        if e_expn == expn {\n+            return true;\n+        }\n+        if e_expn.expn_data().macro_def_id.map(|id| cx.tcx.item_name(id)) == Some(assert_name) {\n+            found = Some((e, e_expn));\n+        }\n+        false\n+    })\n+    .visit_expr(expr);\n+    found\n+}\n+\n+fn is_assert_arg(cx: &LateContext<'_>, expr: &Expr<'_>, assert_expn: ExpnId) -> bool {\n+    if !expr.span.from_expansion() {\n+        return true;\n+    }\n+    let result = macro_backtrace(expr.span).try_for_each(|macro_call| {\n+        if macro_call.expn == assert_expn {\n+            ControlFlow::Break(false)\n+        } else {\n+            match cx.tcx.item_name(macro_call.def_id) {\n+                // `cfg!(debug_assertions)` in `debug_assert!`\n+                sym::cfg => ControlFlow::CONTINUE,\n+                // assert!(other_macro!(..))\n+                _ => ControlFlow::Break(true),\n+            }\n+        }\n+    });\n+    match result {\n+        ControlFlow::Break(is_assert_arg) => is_assert_arg,\n+        ControlFlow::Continue(()) => true,\n+    }\n+}\n+\n+/// A parsed `format_args!` expansion\n+pub struct FormatArgsExpn<'tcx> {\n+    /// Span of the first argument, the format string\n+    pub format_string_span: Span,\n+    /// The format string split by formatted args like `{..}`\n+    pub format_string_parts: Vec<Symbol>,\n+    /// Values passed after the format string\n+    pub value_args: Vec<&'tcx Expr<'tcx>>,\n+    /// Each element is a `value_args` index and a formatting trait (e.g. `sym::Debug`)\n+    pub formatters: Vec<(usize, Symbol)>,\n+    /// List of `fmt::v1::Argument { .. }` expressions. If this is empty,\n+    /// then `formatters` represents the format args (`{..}`).\n+    /// If this is non-empty, it represents the format args, and the `position`\n+    /// parameters within the struct expressions are indexes of `formatters`.\n+    pub specs: Vec<&'tcx Expr<'tcx>>,\n+}\n+\n+impl<'tcx> FormatArgsExpn<'tcx> {\n+    /// Parses an expanded `format_args!` or `format_args_nl!` invocation\n+    pub fn parse(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<Self> {\n+        macro_backtrace(expr.span).find(|macro_call| {\n+            matches!(\n+                cx.tcx.item_name(macro_call.def_id),\n+                sym::const_format_args | sym::format_args | sym::format_args_nl\n+            )\n+        })?;\n+        let mut format_string_span: Option<Span> = None;\n+        let mut format_string_parts: Vec<Symbol> = Vec::new();\n+        let mut value_args: Vec<&Expr<'_>> = Vec::new();\n+        let mut formatters: Vec<(usize, Symbol)> = Vec::new();\n+        let mut specs: Vec<&Expr<'_>> = Vec::new();\n+        expr_visitor_no_bodies(|e| {\n+            // if we're still inside of the macro definition...\n+            if e.span.ctxt() == expr.span.ctxt() {\n+                // ArgumnetV1::new(<value>, <format_trait>::fmt)\n+                if_chain! {\n+                    if let ExprKind::Call(callee, [val, fmt_path]) = e.kind;\n+                    if let ExprKind::Path(QPath::TypeRelative(ty, seg)) = callee.kind;\n+                    if seg.ident.name == sym::new;\n+                    if let hir::TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n+                    if path.segments.last().unwrap().ident.name == sym::ArgumentV1;\n+                    if let ExprKind::Path(QPath::Resolved(_, path)) = fmt_path.kind;\n+                    if let [.., fmt_trait, _fmt] = path.segments;\n+                    then {\n+                        let val_idx = if_chain! {\n+                            if val.span.ctxt() == expr.span.ctxt();\n+                            if let ExprKind::Field(_, field) = val.kind;\n+                            if let Ok(idx) = field.name.as_str().parse();\n+                            then {\n+                                // tuple index\n+                                idx\n+                            } else {\n+                                // assume the value expression is passed directly\n+                                formatters.len()\n+                            }\n+                        };\n+                        formatters.push((val_idx, fmt_trait.ident.name));\n+                    }\n+                }\n+                if let ExprKind::Struct(QPath::Resolved(_, path), ..) = e.kind {\n+                    if path.segments.last().unwrap().ident.name == sym::Argument {\n+                        specs.push(e);\n+                    }\n+                }\n+                // walk through the macro expansion\n+                return true;\n+            }\n+            // assume that the first expr with a differing context represents\n+            // (and has the span of) the format string\n+            if format_string_span.is_none() {\n+                format_string_span = Some(e.span);\n+                let span = e.span;\n+                // walk the expr and collect string literals which are format string parts\n+                expr_visitor_no_bodies(|e| {\n+                    if e.span.ctxt() != span.ctxt() {\n+                        // defensive check, probably doesn't happen\n+                        return false;\n+                    }\n+                    if let ExprKind::Lit(lit) = &e.kind {\n+                        if let LitKind::Str(symbol, _s) = lit.node {\n+                            format_string_parts.push(symbol);\n+                        }\n+                    }\n+                    true\n+                })\n+                .visit_expr(e);\n+            } else {\n+                // assume that any further exprs with a differing context are value args\n+                value_args.push(e);\n+            }\n+            // don't walk anything not from the macro expansion (e.a. inputs)\n+            false\n+        })\n+        .visit_expr(expr);\n+        Some(FormatArgsExpn {\n+            format_string_span: format_string_span?,\n+            format_string_parts,\n+            value_args,\n+            formatters,\n+            specs,\n+        })\n+    }\n+\n+    /// Finds a nested call to `format_args!` within a `format!`-like macro call\n+    pub fn find_nested(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, expn_id: ExpnId) -> Option<Self> {\n+        let mut format_args = None;\n+        expr_visitor_no_bodies(|e| {\n+            if format_args.is_some() {\n+                return false;\n+            }\n+            let e_ctxt = e.span.ctxt();\n+            if e_ctxt == expr.span.ctxt() {\n+                return true;\n+            }\n+            if e_ctxt.outer_expn().is_descendant_of(expn_id) {\n+                format_args = FormatArgsExpn::parse(cx, e);\n+            }\n+            false\n+        })\n+        .visit_expr(expr);\n+        format_args\n+    }\n+\n+    /// Returns a vector of `FormatArgsArg`.\n+    pub fn args(&self) -> Option<Vec<FormatArgsArg<'tcx>>> {\n+        if self.specs.is_empty() {\n+            let args = std::iter::zip(&self.value_args, &self.formatters)\n+                .map(|(value, &(_, format_trait))| FormatArgsArg {\n+                    value,\n+                    format_trait,\n+                    spec: None,\n+                })\n+                .collect();\n+            return Some(args);\n+        }\n+        self.specs\n+            .iter()\n+            .map(|spec| {\n+                if_chain! {\n+                    // struct `core::fmt::rt::v1::Argument`\n+                    if let ExprKind::Struct(_, fields, _) = spec.kind;\n+                    if let Some(position_field) = fields.iter().find(|f| f.ident.name == sym::position);\n+                    if let ExprKind::Lit(lit) = &position_field.expr.kind;\n+                    if let LitKind::Int(position, _) = lit.node;\n+                    if let Ok(i) = usize::try_from(position);\n+                    if let Some(&(j, format_trait)) = self.formatters.get(i);\n+                    then {\n+                        Some(FormatArgsArg { value: self.value_args[j], format_trait, spec: Some(spec) })\n+                    } else {\n+                        None\n+                    }\n+                }\n+            })\n+            .collect()\n+    }\n+\n+    /// Span of all inputs\n+    pub fn inputs_span(&self) -> Span {\n+        match *self.value_args {\n+            [] => self.format_string_span,\n+            [.., last] => self.format_string_span.to(last.span),\n+        }\n+    }\n+}\n+\n+/// Type representing a `FormatArgsExpn`'s format arguments\n+pub struct FormatArgsArg<'tcx> {\n+    /// An element of `value_args` according to `position`\n+    pub value: &'tcx Expr<'tcx>,\n+    /// An element of `args` according to `position`\n+    pub format_trait: Symbol,\n+    /// An element of `specs`\n+    pub spec: Option<&'tcx Expr<'tcx>>,\n+}\n+\n+impl<'tcx> FormatArgsArg<'tcx> {\n+    /// Returns true if any formatting parameters are used that would have an effect on strings,\n+    /// like `{:+2}` instead of just `{}`.\n+    pub fn has_string_formatting(&self) -> bool {\n+        self.spec.map_or(false, |spec| {\n+            // `!` because these conditions check that `self` is unformatted.\n+            !if_chain! {\n+                // struct `core::fmt::rt::v1::Argument`\n+                if let ExprKind::Struct(_, fields, _) = spec.kind;\n+                if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n+                // struct `core::fmt::rt::v1::FormatSpec`\n+                if let ExprKind::Struct(_, subfields, _) = format_field.expr.kind;\n+                if subfields.iter().all(|field| match field.ident.name {\n+                    sym::precision | sym::width => match field.expr.kind {\n+                        ExprKind::Path(QPath::Resolved(_, path)) => {\n+                            path.segments.last().unwrap().ident.name == sym::Implied\n+                        }\n+                        _ => false,\n+                    }\n+                    _ => true,\n+                });\n+                then { true } else { false }\n+            }\n+        })\n+    }\n+}\n+\n+/// A node with a `HirId` and a `Span`\n+pub trait HirNode {\n+    fn hir_id(&self) -> HirId;\n+    fn span(&self) -> Span;\n+}\n+\n+macro_rules! impl_hir_node {\n+    ($($t:ident),*) => {\n+        $(impl HirNode for hir::$t<'_> {\n+            fn hir_id(&self) -> HirId {\n+                self.hir_id\n+            }\n+            fn span(&self) -> Span {\n+                self.span\n+            }\n+        })*\n+    };\n+}\n+\n+impl_hir_node!(Expr, Pat);\n+\n+impl HirNode for hir::Item<'_> {\n+    fn hir_id(&self) -> HirId {\n+        self.hir_id()\n+    }\n+\n+    fn span(&self) -> Span {\n+        self.span\n+    }\n+}"}, {"sha": "a5b409ad96bbbd3125a50005e77430b93339b7df", "filename": "src/tools/clippy/clippy_utils/src/msrvs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmsrvs.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -12,8 +12,9 @@ macro_rules! msrv_aliases {\n \n // names may refer to stabilized feature flags or library items\n msrv_aliases! {\n-    1,53,0 { OR_PATTERNS }\n+    1,53,0 { OR_PATTERNS, MANUAL_BITS }\n     1,52,0 { STR_SPLIT_ONCE }\n+    1,51,0 { BORROW_AS_PTR }\n     1,50,0 { BOOL_THEN }\n     1,47,0 { TAU }\n     1,46,0 { CONST_IF_MATCH }"}, {"sha": "288c56e9fd737bd386c6afe35fbaea7d1746018c", "filename": "src/tools/clippy/clippy_utils/src/paths.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -5,16 +5,16 @@\n //! See <https://github.com/rust-lang/rust-clippy/issues/5393> for more information.\n \n pub const ANY_TRAIT: [&str; 3] = [\"core\", \"any\", \"Any\"];\n-#[cfg(feature = \"metadata-collector-lint\")]\n+#[cfg(feature = \"internal\")]\n pub const APPLICABILITY: [&str; 2] = [\"rustc_lint_defs\", \"Applicability\"];\n-#[cfg(feature = \"metadata-collector-lint\")]\n+#[cfg(feature = \"internal\")]\n pub const APPLICABILITY_VALUES: [[&str; 3]; 4] = [\n     [\"rustc_lint_defs\", \"Applicability\", \"Unspecified\"],\n     [\"rustc_lint_defs\", \"Applicability\", \"HasPlaceholders\"],\n     [\"rustc_lint_defs\", \"Applicability\", \"MaybeIncorrect\"],\n     [\"rustc_lint_defs\", \"Applicability\", \"MachineApplicable\"],\n ];\n-#[cfg(feature = \"metadata-collector-lint\")]\n+#[cfg(feature = \"internal\")]\n pub const DIAGNOSTIC_BUILDER: [&str; 3] = [\"rustc_errors\", \"diagnostic_builder\", \"DiagnosticBuilder\"];\n pub const ARC_PTR_EQ: [&str; 4] = [\"alloc\", \"sync\", \"Arc\", \"ptr_eq\"];\n #[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n@@ -25,7 +25,6 @@ pub const ASSERT_MACRO: [&str; 4] = [\"core\", \"macros\", \"builtin\", \"assert\"];\n pub const ASSERT_NE_MACRO: [&str; 3] = [\"core\", \"macros\", \"assert_ne\"];\n pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n-pub(super) const BEGIN_PANIC: [&str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n /// Preferably use the diagnostic item `sym::Borrow` where possible\n pub const BORROW_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"Borrow\"];\n pub const BORROW_MUT_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"BorrowMut\"];\n@@ -46,7 +45,7 @@ pub const DISPLAY_TRAIT: [&str; 3] = [\"core\", \"fmt\", \"Display\"];\n pub const DOUBLE_ENDED_ITERATOR: [&str; 4] = [\"core\", \"iter\", \"traits\", \"DoubleEndedIterator\"];\n pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n pub const DURATION: [&str; 3] = [\"core\", \"time\", \"Duration\"];\n-#[cfg(feature = \"internal-lints\")]\n+#[cfg(feature = \"internal\")]\n pub const EARLY_CONTEXT: [&str; 2] = [\"rustc_lint\", \"EarlyContext\"];\n #[allow(clippy::invalid_paths)] // `check_path` does not seem to work for macros\n pub const EPRINT_MACRO: [&str; 3] = [\"std\", \"macros\", \"eprint\"];\n@@ -64,13 +63,17 @@ pub const FROM_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"From\n pub const FROM_ITERATOR_METHOD: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\", \"from_iter\"];\n pub const FROM_STR_METHOD: [&str; 5] = [\"core\", \"str\", \"traits\", \"FromStr\", \"from_str\"];\n pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n+#[allow(clippy::invalid_paths)] // internal lints do not know about all external crates\n+pub const FUTURES_IO_ASYNCREADEXT: [&str; 3] = [\"futures_util\", \"io\", \"AsyncReadExt\"];\n+#[allow(clippy::invalid_paths)] // internal lints do not know about all external crates\n+pub const FUTURES_IO_ASYNCWRITEEXT: [&str; 3] = [\"futures_util\", \"io\", \"AsyncWriteExt\"];\n pub const HASH: [&str; 3] = [\"core\", \"hash\", \"Hash\"];\n pub const HASHMAP_CONTAINS_KEY: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"contains_key\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n pub const HASHMAP_INSERT: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"insert\"];\n-#[cfg(feature = \"internal-lints\")]\n+#[cfg(feature = \"internal\")]\n pub const IDENT: [&str; 3] = [\"rustc_span\", \"symbol\", \"Ident\"];\n-#[cfg(feature = \"internal-lints\")]\n+#[cfg(feature = \"internal\")]\n pub const IDENT_AS_STR: [&str; 4] = [\"rustc_span\", \"symbol\", \"Ident\", \"as_str\"];\n pub const INDEX: [&str; 3] = [\"core\", \"ops\", \"Index\"];\n pub const INDEX_MUT: [&str; 3] = [\"core\", \"ops\", \"IndexMut\"];\n@@ -82,11 +85,11 @@ pub const IPADDR_V6: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V6\"];\n pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];\n #[allow(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const ITERTOOLS_NEXT_TUPLE: [&str; 3] = [\"itertools\", \"Itertools\", \"next_tuple\"];\n-#[cfg(feature = \"internal-lints\")]\n+#[cfg(feature = \"internal\")]\n pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n-#[cfg(feature = \"internal-lints\")]\n+#[cfg(feature = \"internal\")]\n pub const LATE_CONTEXT: [&str; 2] = [\"rustc_lint\", \"LateContext\"];\n-#[cfg(any(feature = \"internal-lints\", feature = \"metadata-collector-lint\"))]\n+#[cfg(feature = \"internal\")]\n pub const LINT: [&str; 2] = [\"rustc_lint_defs\", \"Lint\"];\n pub const MEM_DISCRIMINANT: [&str; 3] = [\"core\", \"mem\", \"discriminant\"];\n pub const MEM_FORGET: [&str; 3] = [\"core\", \"mem\", \"forget\"];\n@@ -106,10 +109,6 @@ pub const OPTION_SOME: [&str; 4] = [\"core\", \"option\", \"Option\", \"Some\"];\n pub const ORD: [&str; 3] = [\"core\", \"cmp\", \"Ord\"];\n pub const OS_STRING_AS_OS_STR: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsString\", \"as_os_str\"];\n pub const OS_STR_TO_OS_STRING: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsStr\", \"to_os_string\"];\n-pub(super) const PANICKING_PANIC: [&str; 3] = [\"core\", \"panicking\", \"panic\"];\n-pub(super) const PANICKING_PANIC_FMT: [&str; 3] = [\"core\", \"panicking\", \"panic_fmt\"];\n-pub(super) const PANICKING_PANIC_STR: [&str; 3] = [\"core\", \"panicking\", \"panic_str\"];\n-pub(super) const PANIC_ANY: [&str; 3] = [\"std\", \"panic\", \"panic_any\"];\n pub const PARKING_LOT_RAWMUTEX: [&str; 3] = [\"parking_lot\", \"raw_mutex\", \"RawMutex\"];\n pub const PARKING_LOT_RAWRWLOCK: [&str; 3] = [\"parking_lot\", \"raw_rwlock\", \"RawRwLock\"];\n pub const PARKING_LOT_MUTEX_GUARD: [&str; 2] = [\"parking_lot\", \"MutexGuard\"];\n@@ -118,6 +117,7 @@ pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockWri\n pub const PATH_BUF_AS_PATH: [&str; 4] = [\"std\", \"path\", \"PathBuf\", \"as_path\"];\n pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n pub const PERMISSIONS: [&str; 3] = [\"std\", \"fs\", \"Permissions\"];\n+#[cfg_attr(not(unix), allow(clippy::invalid_paths))]\n pub const PERMISSIONS_FROM_MODE: [&str; 6] = [\"std\", \"os\", \"unix\", \"fs\", \"PermissionsExt\", \"from_mode\"];\n pub const POLL: [&str; 4] = [\"core\", \"task\", \"poll\", \"Poll\"];\n pub const POLL_PENDING: [&str; 5] = [\"core\", \"task\", \"poll\", \"Poll\", \"Pending\"];\n@@ -180,20 +180,24 @@ pub const STR_ENDS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"ends_with\"];\n pub const STR_FROM_UTF8: [&str; 4] = [\"core\", \"str\", \"converts\", \"from_utf8\"];\n pub const STR_LEN: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"len\"];\n pub const STR_STARTS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"starts_with\"];\n-#[cfg(feature = \"internal-lints\")]\n+#[cfg(feature = \"internal\")]\n pub const SYMBOL: [&str; 3] = [\"rustc_span\", \"symbol\", \"Symbol\"];\n-#[cfg(feature = \"internal-lints\")]\n+#[cfg(feature = \"internal\")]\n pub const SYMBOL_AS_STR: [&str; 4] = [\"rustc_span\", \"symbol\", \"Symbol\", \"as_str\"];\n-#[cfg(feature = \"internal-lints\")]\n+#[cfg(feature = \"internal\")]\n pub const SYMBOL_INTERN: [&str; 4] = [\"rustc_span\", \"symbol\", \"Symbol\", \"intern\"];\n-#[cfg(feature = \"internal-lints\")]\n+#[cfg(feature = \"internal\")]\n pub const SYMBOL_TO_IDENT_STRING: [&str; 4] = [\"rustc_span\", \"symbol\", \"Symbol\", \"to_ident_string\"];\n-#[cfg(feature = \"internal-lints\")]\n+#[cfg(feature = \"internal\")]\n pub const SYM_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"sym\"];\n-#[cfg(feature = \"internal-lints\")]\n+#[cfg(feature = \"internal\")]\n pub const SYNTAX_CONTEXT: [&str; 3] = [\"rustc_span\", \"hygiene\", \"SyntaxContext\"];\n pub const TO_OWNED_METHOD: [&str; 4] = [\"alloc\", \"borrow\", \"ToOwned\", \"to_owned\"];\n pub const TO_STRING_METHOD: [&str; 4] = [\"alloc\", \"string\", \"ToString\", \"to_string\"];\n+#[allow(clippy::invalid_paths)] // internal lints do not know about all external crates\n+pub const TOKIO_IO_ASYNCREADEXT: [&str; 5] = [\"tokio\", \"io\", \"util\", \"async_read_ext\", \"AsyncReadExt\"];\n+#[allow(clippy::invalid_paths)] // internal lints do not know about all external crates\n+pub const TOKIO_IO_ASYNCWRITEEXT: [&str; 5] = [\"tokio\", \"io\", \"util\", \"async_write_ext\", \"AsyncWriteExt\"];\n pub const TRY_FROM: [&str; 4] = [\"core\", \"convert\", \"TryFrom\", \"try_from\"];\n pub const VEC_AS_MUT_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_mut_slice\"];\n pub const VEC_AS_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_slice\"];"}, {"sha": "8bdc9a9ea16293715084517007a447efcafdf8c0", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -19,7 +19,7 @@ use std::borrow::Cow;\n \n type McfResult = Result<(), (Span, Cow<'static, str>)>;\n \n-pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv: Option<&RustcVersion>) -> McfResult {\n+pub fn is_min_const_fn<'a, 'tcx>(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv: Option<&RustcVersion>) -> McfResult {\n     let def_id = body.source.def_id();\n     let mut current = def_id;\n     loop {\n@@ -85,7 +85,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv: Option<&Ru\n     Ok(())\n }\n \n-fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) -> McfResult {\n+fn check_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) -> McfResult {\n     for arg in ty.walk(tcx) {\n         let ty = match arg.unpack() {\n             GenericArgKind::Type(ty) => ty,\n@@ -133,7 +133,13 @@ fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) -> McfResult {\n     Ok(())\n }\n \n-fn check_rvalue(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId, rvalue: &Rvalue<'tcx>, span: Span) -> McfResult {\n+fn check_rvalue<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    def_id: DefId,\n+    rvalue: &Rvalue<'tcx>,\n+    span: Span,\n+) -> McfResult {\n     match rvalue {\n         Rvalue::ThreadLocalRef(_) => Err((span, \"cannot access thread local storage in const fn\".into())),\n         Rvalue::Repeat(operand, _) | Rvalue::Use(operand) => check_operand(tcx, operand, span, body),\n@@ -210,7 +216,12 @@ fn check_rvalue(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId, rvalue: &Rv\n     }\n }\n \n-fn check_statement(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId, statement: &Statement<'tcx>) -> McfResult {\n+fn check_statement<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    def_id: DefId,\n+    statement: &Statement<'tcx>,\n+) -> McfResult {\n     let span = statement.source_info.span;\n     match &statement.kind {\n         StatementKind::Assign(box (place, rval)) => {\n@@ -239,7 +250,7 @@ fn check_statement(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId, statemen\n     }\n }\n \n-fn check_operand(tcx: TyCtxt<'tcx>, operand: &Operand<'tcx>, span: Span, body: &Body<'tcx>) -> McfResult {\n+fn check_operand<'tcx>(tcx: TyCtxt<'tcx>, operand: &Operand<'tcx>, span: Span, body: &Body<'tcx>) -> McfResult {\n     match operand {\n         Operand::Move(place) | Operand::Copy(place) => check_place(tcx, *place, span, body),\n         Operand::Constant(c) => match c.check_static_ptr(tcx) {\n@@ -249,7 +260,7 @@ fn check_operand(tcx: TyCtxt<'tcx>, operand: &Operand<'tcx>, span: Span, body: &\n     }\n }\n \n-fn check_place(tcx: TyCtxt<'tcx>, place: Place<'tcx>, span: Span, body: &Body<'tcx>) -> McfResult {\n+fn check_place<'tcx>(tcx: TyCtxt<'tcx>, place: Place<'tcx>, span: Span, body: &Body<'tcx>) -> McfResult {\n     let mut cursor = place.projection.as_ref();\n     while let [ref proj_base @ .., elem] = *cursor {\n         cursor = proj_base;\n@@ -274,7 +285,7 @@ fn check_place(tcx: TyCtxt<'tcx>, place: Place<'tcx>, span: Span, body: &Body<'t\n     Ok(())\n }\n \n-fn check_terminator(\n+fn check_terminator<'a, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     terminator: &Terminator<'tcx>,"}, {"sha": "dbad607c58ea34dfee9b37780b166824cd0f2efc", "filename": "src/tools/clippy/clippy_utils/src/source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsource.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -281,7 +281,7 @@ pub fn snippet_block_with_applicability<'a, T: LintContext>(\n /// correctly get a snippet of `vec![]`.\n ///\n /// This will also return whether or not the snippet is a macro call.\n-pub fn snippet_with_context(\n+pub fn snippet_with_context<'a>(\n     cx: &LateContext<'_>,\n     span: Span,\n     outer: SyntaxContext,"}, {"sha": "87bc8232dde3a6e2501e1fdc0ae2f73584091e8d", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -461,7 +461,7 @@ impl Neg for Sugg<'_> {\n     }\n }\n \n-impl Not for Sugg<'a> {\n+impl<'a> Not for Sugg<'a> {\n     type Output = Sugg<'a>;\n     fn not(self) -> Sugg<'a> {\n         use AssocOp::{Equal, Greater, GreaterEqual, Less, LessEqual, NotEqual};\n@@ -846,7 +846,7 @@ struct DerefDelegate<'a, 'tcx> {\n     applicability: Applicability,\n }\n \n-impl DerefDelegate<'_, 'tcx> {\n+impl<'tcx> DerefDelegate<'_, 'tcx> {\n     /// build final suggestion:\n     /// - create the ending part of suggestion\n     /// - concatenate starting and ending parts"}, {"sha": "72317447159a96ee4f16041df51eb2f22ca716ee", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -25,7 +25,7 @@ pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n }\n \n /// Checks whether a type can be partially moved.\n-pub fn can_partially_move_ty(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn can_partially_move_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     if has_drop(cx, ty) || is_copy(cx, ty) {\n         return false;\n     }\n@@ -366,7 +366,7 @@ pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n \n /// Returns `true` if types `a` and `b` are same types having same `Const` generic args,\n /// otherwise returns `false`\n-pub fn same_type_and_consts(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+pub fn same_type_and_consts<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n     match (&a.kind(), &b.kind()) {\n         (&ty::Adt(did_a, substs_a), &ty::Adt(did_b, substs_b)) => {\n             if did_a != did_b {"}, {"sha": "b60cd4736f32ac1d9bdeb9c16337d113679a26a7", "filename": "src/tools/clippy/clippy_utils/src/visitors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fvisitors.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -173,7 +173,7 @@ pub trait Visitable<'tcx> {\n }\n macro_rules! visitable_ref {\n     ($t:ident, $f:ident) => {\n-        impl Visitable<'tcx> for &'tcx $t<'tcx> {\n+        impl<'tcx> Visitable<'tcx> for &'tcx $t<'tcx> {\n             fn visit<V: Visitor<'tcx>>(self, visitor: &mut V) {\n                 visitor.$f(self);\n             }\n@@ -217,7 +217,7 @@ pub fn is_res_used(cx: &LateContext<'_>, res: Res, body: BodyId) -> bool {\n }\n \n /// Checks if the given local is used.\n-pub fn is_local_used(cx: &LateContext<'tcx>, visitable: impl Visitable<'tcx>, id: HirId) -> bool {\n+pub fn is_local_used<'tcx>(cx: &LateContext<'tcx>, visitable: impl Visitable<'tcx>, id: HirId) -> bool {\n     let mut is_used = false;\n     let mut visitor = expr_visitor(cx, |expr| {\n         if !is_used {\n@@ -231,7 +231,7 @@ pub fn is_local_used(cx: &LateContext<'tcx>, visitable: impl Visitable<'tcx>, id\n }\n \n /// Checks if the given expression is a constant.\n-pub fn is_const_evaluatable(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n+pub fn is_const_evaluatable<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n     struct V<'a, 'tcx> {\n         cx: &'a LateContext<'tcx>,\n         is_const: bool,\n@@ -321,7 +321,7 @@ pub fn is_const_evaluatable(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n }\n \n /// Checks if the given expression performs an unsafe operation outside of an unsafe block.\n-pub fn is_expr_unsafe(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n+pub fn is_expr_unsafe<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n     struct V<'a, 'tcx> {\n         cx: &'a LateContext<'tcx>,\n         is_unsafe: bool,"}, {"sha": "207b0be15488561da7a76d9f1ad4933dc9fde58f", "filename": "src/tools/clippy/doc/common_tools_writing_lints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -60,7 +60,7 @@ Two noticeable items here:\n Starting with an `expr`, you can check whether it is calling a specific method `some_method`:\n \n ```rust\n-impl LateLintPass<'_> for MyStructLint {\n+impl<'tcx> LateLintPass<'tcx> for MyStructLint {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             // Check our expr is calling a method"}, {"sha": "9af8dcc7726f080906adcc1c8ed2b1bc2b711175", "filename": "src/tools/clippy/lintcheck/src/main.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Flintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Flintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Flintcheck%2Fsrc%2Fmain.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -665,16 +665,6 @@ fn lintcheck_needs_rerun(lintcheck_logs_path: &Path) -> bool {\n     logs_modified < clippy_modified\n }\n \n-fn is_in_clippy_root() -> bool {\n-    if let Ok(pb) = std::env::current_dir() {\n-        if let Some(file) = pb.file_name() {\n-            return file == PathBuf::from(\"rust-clippy\");\n-        }\n-    }\n-\n-    false\n-}\n-\n /// lintchecks `main()` function\n ///\n /// # Panics\n@@ -683,7 +673,7 @@ fn is_in_clippy_root() -> bool {\n /// or if lintcheck is executed from the wrong directory (aka none-repo-root)\n pub fn main() {\n     // assert that we launch lintcheck from the repo root (via cargo lintcheck)\n-    if !is_in_clippy_root() {\n+    if std::fs::metadata(\"lintcheck/Cargo.toml\").is_err() {\n         eprintln!(\"lintcheck needs to be run from clippys repo root!\\nUse `cargo lintcheck` alternatively.\");\n         std::process::exit(3);\n     }"}, {"sha": "e6a58e92072501a2f4bc8293392634d5bae93cac", "filename": "src/tools/clippy/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frust-toolchain?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-12-30\"\n+channel = \"nightly-2022-01-13\"\n components = [\"cargo\", \"llvm-tools-preview\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "240e233420f0ea124f063951cfa9973f5ac087d9", "filename": "src/tools/clippy/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fmain.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -96,7 +96,7 @@ impl ClippyCmd {\n             clippy_args.push(\"--no-deps\".into());\n         }\n \n-        ClippyCmd {\n+        Self {\n             cargo_subcommand,\n             args,\n             clippy_args,"}, {"sha": "4dbe71e4b6ad6ae032be2c43649c6deba8aecf37", "filename": "src/tools/clippy/tests/cargo/mod.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609/src%2Ftools%2Fclippy%2Ftests%2Fcargo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609/src%2Ftools%2Fclippy%2Ftests%2Fcargo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fcargo%2Fmod.rs?ref=02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609", "patch": "@@ -1,4 +0,0 @@\n-#[must_use]\n-pub fn is_rustc_test_suite() -> bool {\n-    option_env!(\"RUSTC_TEST_SUITE\").is_some()\n-}"}, {"sha": "531890c863f5efeda3642e73a67029ea1e879f63", "filename": "src/tools/clippy/tests/compile-test.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,4 +1,5 @@\n #![feature(test)] // compiletest_rs requires this attribute\n+#![feature(once_cell)]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n #![warn(rust_2018_idioms, unused_lifetimes)]\n \n@@ -11,23 +12,26 @@ use std::ffi::{OsStr, OsString};\n use std::fs;\n use std::io;\n use std::path::{Path, PathBuf};\n+use test_utils::IS_RUSTC_TEST_SUITE;\n \n-mod cargo;\n+mod test_utils;\n \n // whether to run internal tests or not\n-const RUN_INTERNAL_TESTS: bool = cfg!(feature = \"internal-lints\");\n+const RUN_INTERNAL_TESTS: bool = cfg!(feature = \"internal\");\n \n /// All crates used in UI tests are listed here\n static TEST_DEPENDENCIES: &[&str] = &[\n     \"clippy_utils\",\n     \"derive_new\",\n+    \"futures\",\n     \"if_chain\",\n     \"itertools\",\n     \"quote\",\n     \"regex\",\n     \"serde\",\n     \"serde_derive\",\n     \"syn\",\n+    \"tokio\",\n     \"parking_lot\",\n ];\n \n@@ -38,6 +42,8 @@ extern crate clippy_utils;\n #[allow(unused_extern_crates)]\n extern crate derive_new;\n #[allow(unused_extern_crates)]\n+extern crate futures;\n+#[allow(unused_extern_crates)]\n extern crate if_chain;\n #[allow(unused_extern_crates)]\n extern crate itertools;\n@@ -47,6 +53,8 @@ extern crate parking_lot;\n extern crate quote;\n #[allow(unused_extern_crates)]\n extern crate syn;\n+#[allow(unused_extern_crates)]\n+extern crate tokio;\n \n /// Produces a string with an `--extern` flag for all UI test crate\n /// dependencies.\n@@ -298,7 +306,7 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n         Ok(result)\n     }\n \n-    if cargo::is_rustc_test_suite() {\n+    if IS_RUSTC_TEST_SUITE {\n         return;\n     }\n "}, {"sha": "67af9d05bf402473a3cc6d34080872e15c30ec61", "filename": "src/tools/clippy/tests/dogfood.rs", "status": "modified", "additions": 13, "deletions": 166, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -3,184 +3,31 @@\n //!\n //! See [Eating your own dog food](https://en.wikipedia.org/wiki/Eating_your_own_dog_food) for context\n \n-// Dogfood cannot run on Windows\n-#![cfg(not(windows))]\n #![feature(once_cell)]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n #![warn(rust_2018_idioms, unused_lifetimes)]\n \n-use std::lazy::SyncLazy;\n use std::path::PathBuf;\n use std::process::Command;\n+use test_utils::IS_RUSTC_TEST_SUITE;\n \n-mod cargo;\n-\n-static CLIPPY_PATH: SyncLazy<PathBuf> = SyncLazy::new(|| {\n-    let mut path = std::env::current_exe().unwrap();\n-    assert!(path.pop()); // deps\n-    path.set_file_name(\"cargo-clippy\");\n-    path\n-});\n+mod test_utils;\n \n #[test]\n fn dogfood_clippy() {\n-    // run clippy on itself and fail the test if lint warnings are reported\n-    if cargo::is_rustc_test_suite() {\n-        return;\n-    }\n-    let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n-\n-    let mut command = Command::new(&*CLIPPY_PATH);\n-    command\n-        .current_dir(root_dir)\n-        .env(\"CARGO_INCREMENTAL\", \"0\")\n-        .arg(\"clippy\")\n-        .arg(\"--all-targets\")\n-        .arg(\"--all-features\")\n-        .arg(\"--\")\n-        .args(&[\"-D\", \"clippy::all\"])\n-        .args(&[\"-D\", \"clippy::pedantic\"])\n-        .arg(\"-Cdebuginfo=0\"); // disable debuginfo to generate less data in the target dir\n-\n-    // internal lints only exist if we build with the internal-lints feature\n-    if cfg!(feature = \"internal-lints\") {\n-        command.args(&[\"-D\", \"clippy::internal\"]);\n-    }\n-\n-    let output = command.output().unwrap();\n-\n-    println!(\"status: {}\", output.status);\n-    println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n-    println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n-\n-    assert!(output.status.success());\n-}\n-\n-fn test_no_deps_ignores_path_deps_in_workspaces() {\n-    if cargo::is_rustc_test_suite() {\n+    if IS_RUSTC_TEST_SUITE {\n         return;\n     }\n-    let root = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n-    let target_dir = root.join(\"target\").join(\"dogfood\");\n-    let cwd = root.join(\"clippy_workspace_tests\");\n-\n-    // Make sure we start with a clean state\n-    Command::new(\"cargo\")\n-        .current_dir(&cwd)\n-        .env(\"CARGO_TARGET_DIR\", &target_dir)\n-        .arg(\"clean\")\n-        .args(&[\"-p\", \"subcrate\"])\n-        .args(&[\"-p\", \"path_dep\"])\n-        .output()\n-        .unwrap();\n-\n-    // `path_dep` is a path dependency of `subcrate` that would trigger a denied lint.\n-    // Make sure that with the `--no-deps` argument Clippy does not run on `path_dep`.\n-    let output = Command::new(&*CLIPPY_PATH)\n-        .current_dir(&cwd)\n-        .env(\"CARGO_INCREMENTAL\", \"0\")\n-        .arg(\"clippy\")\n-        .args(&[\"-p\", \"subcrate\"])\n-        .arg(\"--no-deps\")\n-        .arg(\"--\")\n-        .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n-        .args(&[\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n-        .output()\n-        .unwrap();\n-    println!(\"status: {}\", output.status);\n-    println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n-    println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n-\n-    assert!(output.status.success());\n-\n-    let lint_path_dep = || {\n-        // Test that without the `--no-deps` argument, `path_dep` is linted.\n-        let output = Command::new(&*CLIPPY_PATH)\n-            .current_dir(&cwd)\n-            .env(\"CARGO_INCREMENTAL\", \"0\")\n-            .arg(\"clippy\")\n-            .args(&[\"-p\", \"subcrate\"])\n-            .arg(\"--\")\n-            .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n-            .args(&[\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n-            .output()\n-            .unwrap();\n-        println!(\"status: {}\", output.status);\n-        println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n-        println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n-\n-        assert!(!output.status.success());\n-        assert!(\n-            String::from_utf8(output.stderr)\n-                .unwrap()\n-                .contains(\"error: empty `loop {}` wastes CPU cycles\")\n-        );\n-    };\n-\n-    // Make sure Cargo is aware of the removal of `--no-deps`.\n-    lint_path_dep();\n-\n-    let successful_build = || {\n-        let output = Command::new(&*CLIPPY_PATH)\n-            .current_dir(&cwd)\n-            .env(\"CARGO_INCREMENTAL\", \"0\")\n-            .arg(\"clippy\")\n-            .args(&[\"-p\", \"subcrate\"])\n-            .arg(\"--\")\n-            .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n-            .output()\n-            .unwrap();\n-        println!(\"status: {}\", output.status);\n-        println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n-        println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n-\n-        assert!(output.status.success());\n-\n-        output\n-    };\n-\n-    // Trigger a sucessful build, so Cargo would like to cache the build result.\n-    successful_build();\n-\n-    // Make sure there's no spurious rebuild when nothing changes.\n-    let stderr = String::from_utf8(successful_build().stderr).unwrap();\n-    assert!(!stderr.contains(\"Compiling\"));\n-    assert!(!stderr.contains(\"Checking\"));\n-    assert!(stderr.contains(\"Finished\"));\n-\n-    // Make sure Cargo is aware of the new `--cfg` flag.\n-    lint_path_dep();\n-}\n \n-#[test]\n-fn dogfood_subprojects() {\n-    // run clippy on remaining subprojects and fail the test if lint warnings are reported\n-    if cargo::is_rustc_test_suite() {\n-        return;\n+    // \"\" is the root package\n+    for package in &[\"\", \"clippy_dev\", \"clippy_lints\", \"clippy_utils\", \"rustc_tools_util\"] {\n+        run_clippy_for_package(package);\n     }\n-\n-    // NOTE: `path_dep` crate is omitted on purpose here\n-    for project in &[\n-        \"clippy_workspace_tests\",\n-        \"clippy_workspace_tests/src\",\n-        \"clippy_workspace_tests/subcrate\",\n-        \"clippy_workspace_tests/subcrate/src\",\n-        \"clippy_dev\",\n-        \"clippy_lints\",\n-        \"clippy_utils\",\n-        \"rustc_tools_util\",\n-    ] {\n-        run_clippy_for_project(project);\n-    }\n-\n-    // NOTE: Since tests run in parallel we can't run cargo commands on the same workspace at the\n-    // same time, so we test this immediately after the dogfood for workspaces.\n-    test_no_deps_ignores_path_deps_in_workspaces();\n }\n \n #[test]\n #[ignore]\n-#[cfg(feature = \"metadata-collector-lint\")]\n+#[cfg(feature = \"internal\")]\n fn run_metadata_collection_lint() {\n     use std::fs::File;\n     use std::time::SystemTime;\n@@ -191,7 +38,7 @@ fn run_metadata_collection_lint() {\n \n     // Run collection as is\n     std::env::set_var(\"ENABLE_METADATA_COLLECTION\", \"1\");\n-    run_clippy_for_project(\"clippy_lints\");\n+    run_clippy_for_package(\"clippy_lints\");\n \n     // Check if cargo caching got in the way\n     if let Ok(file) = File::open(metadata_output_path) {\n@@ -214,13 +61,13 @@ fn run_metadata_collection_lint() {\n     .unwrap();\n \n     // Running the collection again\n-    run_clippy_for_project(\"clippy_lints\");\n+    run_clippy_for_package(\"clippy_lints\");\n }\n \n-fn run_clippy_for_project(project: &str) {\n+fn run_clippy_for_package(project: &str) {\n     let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n \n-    let mut command = Command::new(&*CLIPPY_PATH);\n+    let mut command = Command::new(&*test_utils::CARGO_CLIPPY_PATH);\n \n     command\n         .current_dir(root_dir.join(project))\n@@ -233,8 +80,8 @@ fn run_clippy_for_project(project: &str) {\n         .args(&[\"-D\", \"clippy::pedantic\"])\n         .arg(\"-Cdebuginfo=0\"); // disable debuginfo to generate less data in the target dir\n \n-    // internal lints only exist if we build with the internal-lints feature\n-    if cfg!(feature = \"internal-lints\") {\n+    // internal lints only exist if we build with the internal feature\n+    if cfg!(feature = \"internal\") {\n         command.args(&[\"-D\", \"clippy::internal\"]);\n     }\n "}, {"sha": "0defd45b68b064745537b02321f5bb2b56c688aa", "filename": "src/tools/clippy/tests/fmt.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Ffmt.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -10,14 +10,6 @@ fn fmt() {\n         return;\n     }\n \n-    // Skip this test if nightly rustfmt is unavailable\n-    let rustup_output = Command::new(\"rustup\").args(&[\"component\", \"list\"]).output().unwrap();\n-    assert!(rustup_output.status.success());\n-    let component_output = String::from_utf8_lossy(&rustup_output.stdout);\n-    if !component_output.contains(\"rustfmt\") {\n-        return;\n-    }\n-\n     let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n     let output = Command::new(\"cargo\")\n         .current_dir(root_dir)"}, {"sha": "8a4de3f6def9094b9af6ca4ba0931834686f1c73", "filename": "src/tools/clippy/tests/test_utils/mod.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Ftest_utils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Ftest_utils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Ftest_utils%2Fmod.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,13 @@\n+#![allow(dead_code)] // see https://github.com/rust-lang/rust/issues/46379\n+\n+use std::lazy::SyncLazy;\n+use std::path::PathBuf;\n+\n+pub static CARGO_CLIPPY_PATH: SyncLazy<PathBuf> = SyncLazy::new(|| {\n+    let mut path = std::env::current_exe().unwrap();\n+    assert!(path.pop()); // deps\n+    path.set_file_name(\"cargo-clippy\");\n+    path\n+});\n+\n+pub const IS_RUSTC_TEST_SUITE: bool = option_env!(\"RUSTC_TEST_SUITE\").is_some();"}, {"sha": "0e85088691765820a5bc313ee9cd0a18a6801410", "filename": "src/tools/clippy/tests/ui-internal/invalid_paths.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Finvalid_paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Finvalid_paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Finvalid_paths.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,16 +1,22 @@\n+error: invalid path\n+  --> $DIR/invalid_paths.rs:15:5\n+   |\n+LL |     pub const TRANSMUTE: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::invalid-paths` implied by `-D warnings`\n+\n error: invalid path\n   --> $DIR/invalid_paths.rs:18:5\n    |\n LL |     pub const BAD_CRATE_PATH: [&str; 2] = [\"bad\", \"path\"];\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::invalid-paths` implied by `-D warnings`\n \n error: invalid path\n   --> $DIR/invalid_paths.rs:21:5\n    |\n LL |     pub const BAD_MOD_PATH: [&str; 2] = [\"std\", \"xxx\"];\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "c902d21123dce0dc9d8200531fe6669275776aba", "filename": "src/tools/clippy/tests/ui-toml/toml_disallowed_methods/clippy.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_methods%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_methods%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_methods%2Fclippy.toml?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,6 +1,8 @@\n disallowed-methods = [\n     # just a string is shorthand for path only\n     \"std::iter::Iterator::sum\",\n+    \"f32::clamp\",\n+    \"slice::sort_unstable\",\n     # can give path and reason with an inline table\n     { path = \"regex::Regex::is_match\", reason = \"no matching allowed\" },\n     # can use an inline table but omit reason"}, {"sha": "338b3b5b28f429b9700d5849886109698f758242", "filename": "src/tools/clippy/tests/ui-toml/toml_disallowed_methods/conf_disallowed_methods.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -7,6 +7,11 @@ fn main() {\n     let re = Regex::new(r\"ab.*c\").unwrap();\n     re.is_match(\"abc\");\n \n-    let a = vec![1, 2, 3, 4];\n+    let mut a = vec![1, 2, 3, 4];\n     a.iter().sum::<i32>();\n+\n+    a.sort_unstable();\n+\n+    let _ = 2.0f32.clamp(3.0f32, 4.0f32);\n+    let _ = 2.0f64.clamp(3.0f64, 4.0f64);\n }"}, {"sha": "5533676aea287b80677e8ec9f9cd0423dd52e405", "filename": "src/tools/clippy/tests/ui-toml/toml_disallowed_methods/conf_disallowed_methods.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_disallowed_methods%2Fconf_disallowed_methods.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -20,5 +20,17 @@ error: use of a disallowed method `std::iter::Iterator::sum`\n LL |     a.iter().sum::<i32>();\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: use of a disallowed method `slice::sort_unstable`\n+  --> $DIR/conf_disallowed_methods.rs:13:5\n+   |\n+LL |     a.sort_unstable();\n+   |     ^^^^^^^^^^^^^^^^^\n+\n+error: use of a disallowed method `f32::clamp`\n+  --> $DIR/conf_disallowed_methods.rs:15:13\n+   |\n+LL |     let _ = 2.0f32.clamp(3.0f32, 4.0f32);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n "}, {"sha": "ba4394defbf20d75f6f3c33bc47c48123b9fcb4b", "filename": "src/tools/clippy/tests/ui/as_conversions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fas_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fas_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fas_conversions.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,6 +1,7 @@\n // aux-build:macro_rules.rs\n \n #![warn(clippy::as_conversions)]\n+#![allow(clippy::borrow_as_ptr)]\n \n #[macro_use]\n extern crate macro_rules;"}, {"sha": "d11b56171b07211b6bd6f6a4bda0d6947eb32ab7", "filename": "src/tools/clippy/tests/ui/as_conversions.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fas_conversions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fas_conversions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fas_conversions.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,5 +1,5 @@\n error: using a potentially dangerous silent `as` conversion\n-  --> $DIR/as_conversions.rs:14:13\n+  --> $DIR/as_conversions.rs:15:13\n    |\n LL |     let i = 0u32 as u64;\n    |             ^^^^^^^^^^^\n@@ -8,15 +8,15 @@ LL |     let i = 0u32 as u64;\n    = help: consider using a safe wrapper for this conversion\n \n error: using a potentially dangerous silent `as` conversion\n-  --> $DIR/as_conversions.rs:16:13\n+  --> $DIR/as_conversions.rs:17:13\n    |\n LL |     let j = &i as *const u64 as *mut u64;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider using a safe wrapper for this conversion\n \n error: using a potentially dangerous silent `as` conversion\n-  --> $DIR/as_conversions.rs:16:13\n+  --> $DIR/as_conversions.rs:17:13\n    |\n LL |     let j = &i as *const u64 as *mut u64;\n    |             ^^^^^^^^^^^^^^^^"}, {"sha": "7477c01ca78283e173392dd12c86c40a210ebe8d", "filename": "src/tools/clippy/tests/ui/assertions_on_constants.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassertions_on_constants.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,4 +1,3 @@\n-//FIXME: suggestions are wrongly expanded, this should be fixed along with #7843\n #![allow(non_fmt_panics)]\n \n macro_rules! assert_const {"}, {"sha": "e1f818814d500105c2b69e3a0d979f6ed467fe55", "filename": "src/tools/clippy/tests/ui/assertions_on_constants.stderr", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassertions_on_constants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassertions_on_constants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fassertions_on_constants.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,75 +1,75 @@\n error: `assert!(true)` will be optimized out by the compiler\n-  --> $DIR/assertions_on_constants.rs:11:5\n+  --> $DIR/assertions_on_constants.rs:10:5\n    |\n LL |     assert!(true);\n    |     ^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::assertions-on-constants` implied by `-D warnings`\n    = help: remove it\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `assert!(false)` should probably be replaced\n-  --> $DIR/assertions_on_constants.rs:12:5\n+  --> $DIR/assertions_on_constants.rs:11:5\n    |\n LL |     assert!(false);\n    |     ^^^^^^^^^^^^^^\n    |\n    = help: use `panic!()` or `unreachable!()`\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `assert!(true)` will be optimized out by the compiler\n-  --> $DIR/assertions_on_constants.rs:13:5\n+  --> $DIR/assertions_on_constants.rs:12:5\n    |\n LL |     assert!(true, \"true message\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: remove it\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: `assert!(false, $crate::const_format_args!($($t)+))` should probably be replaced\n-  --> $DIR/assertions_on_constants.rs:14:5\n+error: `assert!(false, ..)` should probably be replaced\n+  --> $DIR/assertions_on_constants.rs:13:5\n    |\n LL |     assert!(false, \"false message\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: use `panic!($crate::const_format_args!($($t)+))` or `unreachable!($crate::const_format_args!($($t)+))`\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = help: use `panic!(..)` or `unreachable!(..)`\n+\n+error: `assert!(false, ..)` should probably be replaced\n+  --> $DIR/assertions_on_constants.rs:16:5\n+   |\n+LL |     assert!(false, \"{}\", msg.to_uppercase());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `panic!(..)` or `unreachable!(..)`\n \n error: `assert!(true)` will be optimized out by the compiler\n-  --> $DIR/assertions_on_constants.rs:20:5\n+  --> $DIR/assertions_on_constants.rs:19:5\n    |\n LL |     assert!(B);\n    |     ^^^^^^^^^^\n    |\n    = help: remove it\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `assert!(false)` should probably be replaced\n-  --> $DIR/assertions_on_constants.rs:23:5\n+  --> $DIR/assertions_on_constants.rs:22:5\n    |\n LL |     assert!(C);\n    |     ^^^^^^^^^^\n    |\n    = help: use `panic!()` or `unreachable!()`\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: `assert!(false, $crate::const_format_args!($($t)+))` should probably be replaced\n-  --> $DIR/assertions_on_constants.rs:24:5\n+error: `assert!(false, ..)` should probably be replaced\n+  --> $DIR/assertions_on_constants.rs:23:5\n    |\n LL |     assert!(C, \"C message\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: use `panic!($crate::const_format_args!($($t)+))` or `unreachable!($crate::const_format_args!($($t)+))`\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = help: use `panic!(..)` or `unreachable!(..)`\n \n error: `debug_assert!(true)` will be optimized out by the compiler\n-  --> $DIR/assertions_on_constants.rs:26:5\n+  --> $DIR/assertions_on_constants.rs:25:5\n    |\n LL |     debug_assert!(true);\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: remove it\n-   = note: this error originates in the macro `$crate::assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "ff5c6a8c3774bfbc39ea9698d1d388a444d3ddcd", "filename": "src/tools/clippy/tests/ui/borrow_as_ptr.fixed", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr.fixed?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+#![warn(clippy::borrow_as_ptr)]\n+\n+fn main() {\n+    let val = 1;\n+    let _p = std::ptr::addr_of!(val);\n+\n+    let mut val_mut = 1;\n+    let _p_mut = std::ptr::addr_of_mut!(val_mut);\n+}"}, {"sha": "0f62ec6ee58b4f88fc1a1251129c96e61653277d", "filename": "src/tools/clippy/tests/ui/borrow_as_ptr.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+#![warn(clippy::borrow_as_ptr)]\n+\n+fn main() {\n+    let val = 1;\n+    let _p = &val as *const i32;\n+\n+    let mut val_mut = 1;\n+    let _p_mut = &mut val_mut as *mut i32;\n+}"}, {"sha": "be1ed733056740f2dc702da987c0f69380e7bfbb", "filename": "src/tools/clippy/tests/ui/borrow_as_ptr.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,16 @@\n+error: borrow as raw pointer\n+  --> $DIR/borrow_as_ptr.rs:6:14\n+   |\n+LL |     let _p = &val as *const i32;\n+   |              ^^^^^^^^^^^^^^^^^^ help: try: `std::ptr::addr_of!(val)`\n+   |\n+   = note: `-D clippy::borrow-as-ptr` implied by `-D warnings`\n+\n+error: borrow as raw pointer\n+  --> $DIR/borrow_as_ptr.rs:9:18\n+   |\n+LL |     let _p_mut = &mut val_mut as *mut i32;\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `std::ptr::addr_of_mut!(val_mut)`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "eaba3b1c20c8d22afe98ae17c6cbd8686d324054", "filename": "src/tools/clippy/tests/ui/borrow_as_ptr_no_std.fixed", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr_no_std.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr_no_std.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr_no_std.fixed?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+#![warn(clippy::borrow_as_ptr)]\n+#![feature(lang_items, start, libc)]\n+#![no_std]\n+\n+#[start]\n+fn main(_argc: isize, _argv: *const *const u8) -> isize {\n+    let val = 1;\n+    let _p = core::ptr::addr_of!(val);\n+\n+    let mut val_mut = 1;\n+    let _p_mut = core::ptr::addr_of_mut!(val_mut);\n+    0\n+}\n+\n+#[panic_handler]\n+fn panic(_info: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}\n+\n+#[lang = \"eh_personality\"]\n+extern \"C\" fn eh_personality() {}"}, {"sha": "d83f9d1f875bafed872fecaef1d85ebd1125368b", "filename": "src/tools/clippy/tests/ui/borrow_as_ptr_no_std.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr_no_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr_no_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr_no_std.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+#![warn(clippy::borrow_as_ptr)]\n+#![feature(lang_items, start, libc)]\n+#![no_std]\n+\n+#[start]\n+fn main(_argc: isize, _argv: *const *const u8) -> isize {\n+    let val = 1;\n+    let _p = &val as *const i32;\n+\n+    let mut val_mut = 1;\n+    let _p_mut = &mut val_mut as *mut i32;\n+    0\n+}\n+\n+#[panic_handler]\n+fn panic(_info: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}\n+\n+#[lang = \"eh_personality\"]\n+extern \"C\" fn eh_personality() {}"}, {"sha": "84c8ba7d07f1e19ee65860fd27591fb78ba60f3d", "filename": "src/tools/clippy/tests/ui/borrow_as_ptr_no_std.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr_no_std.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr_no_std.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fborrow_as_ptr_no_std.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,16 @@\n+error: borrow as raw pointer\n+  --> $DIR/borrow_as_ptr_no_std.rs:9:14\n+   |\n+LL |     let _p = &val as *const i32;\n+   |              ^^^^^^^^^^^^^^^^^^ help: try: `core::ptr::addr_of!(val)`\n+   |\n+   = note: `-D clippy::borrow-as-ptr` implied by `-D warnings`\n+\n+error: borrow as raw pointer\n+  --> $DIR/borrow_as_ptr_no_std.rs:12:18\n+   |\n+LL |     let _p_mut = &mut val_mut as *mut i32;\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `core::ptr::addr_of_mut!(val_mut)`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "659591fffbecdb56993cdf8cbd8676430ec52e8c", "filename": "src/tools/clippy/tests/ui/cast_alignment.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_alignment.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -4,7 +4,13 @@\n extern crate libc;\n \n #[warn(clippy::cast_ptr_alignment)]\n-#[allow(clippy::no_effect, clippy::unnecessary_operation, clippy::cast_lossless)]\n+#[allow(\n+    clippy::no_effect,\n+    clippy::unnecessary_operation,\n+    clippy::cast_lossless,\n+    clippy::borrow_as_ptr\n+)]\n+\n fn main() {\n     /* These should be warned against */\n "}, {"sha": "aedd368445554b05ad2d1744be82e682081534d4", "filename": "src/tools/clippy/tests/ui/cast_alignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_alignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_alignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_alignment.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,25 +1,25 @@\n error: casting from `*const u8` to a more-strictly-aligned pointer (`*const u16`) (1 < 2 bytes)\n-  --> $DIR/cast_alignment.rs:12:5\n+  --> $DIR/cast_alignment.rs:18:5\n    |\n LL |     (&1u8 as *const u8) as *const u16;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::cast-ptr-alignment` implied by `-D warnings`\n \n error: casting from `*mut u8` to a more-strictly-aligned pointer (`*mut u16`) (1 < 2 bytes)\n-  --> $DIR/cast_alignment.rs:13:5\n+  --> $DIR/cast_alignment.rs:19:5\n    |\n LL |     (&mut 1u8 as *mut u8) as *mut u16;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: casting from `*const u8` to a more-strictly-aligned pointer (`*const u16`) (1 < 2 bytes)\n-  --> $DIR/cast_alignment.rs:16:5\n+  --> $DIR/cast_alignment.rs:22:5\n    |\n LL |     (&1u8 as *const u8).cast::<u16>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: casting from `*mut u8` to a more-strictly-aligned pointer (`*mut u16`) (1 < 2 bytes)\n-  --> $DIR/cast_alignment.rs:17:5\n+  --> $DIR/cast_alignment.rs:23:5\n    |\n LL |     (&mut 1u8 as *mut u8).cast::<u16>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "c48a734ba32c26874a19c58d8c6d959fe9e7f066", "filename": "src/tools/clippy/tests/ui/cast_ref_to_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_ref_to_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_ref_to_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_ref_to_mut.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,5 +1,5 @@\n #![warn(clippy::cast_ref_to_mut)]\n-#![allow(clippy::no_effect)]\n+#![allow(clippy::no_effect, clippy::borrow_as_ptr)]\n \n extern \"C\" {\n     // N.B., mutability can be easily incorrect in FFI calls -- as"}, {"sha": "2f489deb1ee1f5910b3acd8038c5de8ac531c877", "filename": "src/tools/clippy/tests/ui/deref_addrof.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fderef_addrof.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fderef_addrof.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fderef_addrof.fixed?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -37,6 +37,8 @@ fn main() {\n     let b = &a;\n \n     let b = *aref;\n+\n+    let _ = unsafe { *core::ptr::addr_of!(a) };\n }\n \n #[rustfmt::skip]"}, {"sha": "49f360b9a7f9e2ca7f7d6275d69f546f764b41d9", "filename": "src/tools/clippy/tests/ui/deref_addrof.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fderef_addrof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fderef_addrof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fderef_addrof.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -37,6 +37,8 @@ fn main() {\n     let b = *&&a;\n \n     let b = **&aref;\n+\n+    let _ = unsafe { *core::ptr::addr_of!(a) };\n }\n \n #[rustfmt::skip]"}, {"sha": "75371fcdb9677f476dc1bfaebceaa78cc0685d38", "filename": "src/tools/clippy/tests/ui/deref_addrof.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fderef_addrof.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fderef_addrof.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fderef_addrof.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -49,7 +49,7 @@ LL |     let b = **&aref;\n    |              ^^^^^^ help: try this: `aref`\n \n error: immediately dereferencing a reference\n-  --> $DIR/deref_addrof.rs:45:9\n+  --> $DIR/deref_addrof.rs:47:9\n    |\n LL |         *& $visitor\n    |         ^^^^^^^^^^^ help: try this: `$visitor`\n@@ -60,7 +60,7 @@ LL |         m!(self)\n    = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: immediately dereferencing a reference\n-  --> $DIR/deref_addrof.rs:52:9\n+  --> $DIR/deref_addrof.rs:54:9\n    |\n LL |         *& mut $visitor\n    |         ^^^^^^^^^^^^^^^ help: try this: `$visitor`"}, {"sha": "cd9f1826e59bf292d5b00cbe4381d6c178d12a71", "filename": "src/tools/clippy/tests/ui/eq_op_macros.stderr", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feq_op_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feq_op_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feq_op_macros.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -21,6 +21,28 @@ LL |     assert_in_macro_def!();\n    |\n    = note: this error originates in the macro `assert_in_macro_def` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n+error: identical args used in this `debug_assert_eq!` macro call\n+  --> $DIR/eq_op_macros.rs:9:26\n+   |\n+LL |         debug_assert_eq!(a, a);\n+   |                          ^^^^\n+...\n+LL |     assert_in_macro_def!();\n+   |     ---------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `assert_in_macro_def` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: identical args used in this `debug_assert_ne!` macro call\n+  --> $DIR/eq_op_macros.rs:10:26\n+   |\n+LL |         debug_assert_ne!(a, a);\n+   |                          ^^^^\n+...\n+LL |     assert_in_macro_def!();\n+   |     ---------------------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `assert_in_macro_def` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n error: identical args used in this `assert_eq!` macro call\n   --> $DIR/eq_op_macros.rs:22:16\n    |\n@@ -45,28 +67,6 @@ error: identical args used in this `assert_ne!` macro call\n LL |     assert_ne!(a + 1, a + 1);\n    |                ^^^^^^^^^^^^\n \n-error: identical args used in this `debug_assert_eq!` macro call\n-  --> $DIR/eq_op_macros.rs:9:26\n-   |\n-LL |         debug_assert_eq!(a, a);\n-   |                          ^^^^\n-...\n-LL |     assert_in_macro_def!();\n-   |     ---------------------- in this macro invocation\n-   |\n-   = note: this error originates in the macro `assert_in_macro_def` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: identical args used in this `debug_assert_ne!` macro call\n-  --> $DIR/eq_op_macros.rs:10:26\n-   |\n-LL |         debug_assert_ne!(a, a);\n-   |                          ^^^^\n-...\n-LL |     assert_in_macro_def!();\n-   |     ---------------------- in this macro invocation\n-   |\n-   = note: this error originates in the macro `assert_in_macro_def` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n error: identical args used in this `debug_assert_eq!` macro call\n   --> $DIR/eq_op_macros.rs:38:22\n    |"}, {"sha": "ae2fad0086daa0af39d6838418b407dfcad2c1a9", "filename": "src/tools/clippy/tests/ui/erasing_op.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ferasing_op.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,3 +1,34 @@\n+struct Length(u8);\n+struct Meter;\n+\n+impl core::ops::Mul<Meter> for u8 {\n+    type Output = Length;\n+    fn mul(self, _: Meter) -> Length {\n+        Length(self)\n+    }\n+}\n+\n+#[derive(Clone, Default, PartialEq, Eq, Hash)]\n+struct Vec1 {\n+    x: i32,\n+}\n+\n+impl core::ops::Mul<Vec1> for i32 {\n+    type Output = Vec1;\n+    fn mul(self, mut right: Vec1) -> Vec1 {\n+        right.x *= self;\n+        right\n+    }\n+}\n+\n+impl core::ops::Mul<i32> for Vec1 {\n+    type Output = Vec1;\n+    fn mul(mut self, right: i32) -> Vec1 {\n+        self.x *= right;\n+        self\n+    }\n+}\n+\n #[allow(clippy::no_effect)]\n #[warn(clippy::erasing_op)]\n fn main() {\n@@ -6,4 +37,7 @@ fn main() {\n     x * 0;\n     0 & x;\n     0 / x;\n+    0 * Meter; // no error: Output type is different from the non-zero argument\n+    0 * Vec1 { x: 5 };\n+    Vec1 { x: 5 } * 0;\n }"}, {"sha": "165ed9bfe58b1b0bda9f79560e47a457d2964a43", "filename": "src/tools/clippy/tests/ui/erasing_op.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ferasing_op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ferasing_op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ferasing_op.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,22 +1,34 @@\n error: this operation will always return zero. This is likely not the intended outcome\n-  --> $DIR/erasing_op.rs:6:5\n+  --> $DIR/erasing_op.rs:37:5\n    |\n LL |     x * 0;\n    |     ^^^^^\n    |\n    = note: `-D clippy::erasing-op` implied by `-D warnings`\n \n error: this operation will always return zero. This is likely not the intended outcome\n-  --> $DIR/erasing_op.rs:7:5\n+  --> $DIR/erasing_op.rs:38:5\n    |\n LL |     0 & x;\n    |     ^^^^^\n \n error: this operation will always return zero. This is likely not the intended outcome\n-  --> $DIR/erasing_op.rs:8:5\n+  --> $DIR/erasing_op.rs:39:5\n    |\n LL |     0 / x;\n    |     ^^^^^\n \n-error: aborting due to 3 previous errors\n+error: this operation will always return zero. This is likely not the intended outcome\n+  --> $DIR/erasing_op.rs:41:5\n+   |\n+LL |     0 * Vec1 { x: 5 };\n+   |     ^^^^^^^^^^^^^^^^^\n+\n+error: this operation will always return zero. This is likely not the intended outcome\n+  --> $DIR/erasing_op.rs:42:5\n+   |\n+LL |     Vec1 { x: 5 } * 0;\n+   |     ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n "}, {"sha": "f938f7106884416bb1d748f94f90a85a85ac131d", "filename": "src/tools/clippy/tests/ui/eta.fixed", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.fixed?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -248,3 +248,14 @@ mod type_param_bound {\n         take(X::fun as fn());\n     }\n }\n+\n+// #8073 Don't replace closure with `Arc<F>` or `Rc<F>`\n+fn arc_fp() {\n+    let rc = std::rc::Rc::new(|| 7);\n+    let arc = std::sync::Arc::new(|n| n + 1);\n+    let ref_arc = &std::sync::Arc::new(|_| 5);\n+\n+    true.then(|| rc());\n+    (0..5).map(|n| arc(n));\n+    Some(4).map(|n| ref_arc(n));\n+}"}, {"sha": "075bbc74922f91fa18b1ace10ec3689212e00a72", "filename": "src/tools/clippy/tests/ui/eta.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -248,3 +248,14 @@ mod type_param_bound {\n         take(X::fun as fn());\n     }\n }\n+\n+// #8073 Don't replace closure with `Arc<F>` or `Rc<F>`\n+fn arc_fp() {\n+    let rc = std::rc::Rc::new(|| 7);\n+    let arc = std::sync::Arc::new(|n| n + 1);\n+    let ref_arc = &std::sync::Arc::new(|_| 5);\n+\n+    true.then(|| rc());\n+    (0..5).map(|n| arc(n));\n+    Some(4).map(|n| ref_arc(n));\n+}"}, {"sha": "12bbda71f434813ca78c1e499bb3d70e82106490", "filename": "src/tools/clippy/tests/ui/identity_op.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fidentity_op.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -11,6 +11,17 @@ impl std::ops::Shl<i32> for A {\n         self\n     }\n }\n+\n+struct Length(u8);\n+struct Meter;\n+\n+impl core::ops::Mul<Meter> for u8 {\n+    type Output = Length;\n+    fn mul(self, _: Meter) -> Length {\n+        Length(self)\n+    }\n+}\n+\n #[allow(\n     clippy::eq_op,\n     clippy::no_effect,\n@@ -53,4 +64,6 @@ fn main() {\n \n     let mut a = A(\"\".into());\n     let b = a << 0; // no error: non-integer\n+\n+    1 * Meter; // no error: non-integer\n }"}, {"sha": "0103cf5457e81a8a313dc1b78506497679903647", "filename": "src/tools/clippy/tests/ui/identity_op.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fidentity_op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fidentity_op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fidentity_op.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,79 +1,79 @@\n error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:26:5\n+  --> $DIR/identity_op.rs:37:5\n    |\n LL |     x + 0;\n    |     ^^^^^\n    |\n    = note: `-D clippy::identity-op` implied by `-D warnings`\n \n error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:27:5\n+  --> $DIR/identity_op.rs:38:5\n    |\n LL |     x + (1 - 1);\n    |     ^^^^^^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:29:5\n+  --> $DIR/identity_op.rs:40:5\n    |\n LL |     0 + x;\n    |     ^^^^^\n \n error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:32:5\n+  --> $DIR/identity_op.rs:43:5\n    |\n LL |     x | (0);\n    |     ^^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:35:5\n+  --> $DIR/identity_op.rs:46:5\n    |\n LL |     x * 1;\n    |     ^^^^^\n \n error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:36:5\n+  --> $DIR/identity_op.rs:47:5\n    |\n LL |     1 * x;\n    |     ^^^^^\n \n error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:42:5\n+  --> $DIR/identity_op.rs:53:5\n    |\n LL |     -1 & x;\n    |     ^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `u`\n-  --> $DIR/identity_op.rs:45:5\n+  --> $DIR/identity_op.rs:56:5\n    |\n LL |     u & 255;\n    |     ^^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `42`\n-  --> $DIR/identity_op.rs:48:5\n+  --> $DIR/identity_op.rs:59:5\n    |\n LL |     42 << 0;\n    |     ^^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `1`\n-  --> $DIR/identity_op.rs:49:5\n+  --> $DIR/identity_op.rs:60:5\n    |\n LL |     1 >> 0;\n    |     ^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `42`\n-  --> $DIR/identity_op.rs:50:5\n+  --> $DIR/identity_op.rs:61:5\n    |\n LL |     42 >> 0;\n    |     ^^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `&x`\n-  --> $DIR/identity_op.rs:51:5\n+  --> $DIR/identity_op.rs:62:5\n    |\n LL |     &x >> 0;\n    |     ^^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:52:5\n+  --> $DIR/identity_op.rs:63:5\n    |\n LL |     x >> &0;\n    |     ^^^^^^^"}, {"sha": "e5042aaa776b4dbceeaa9297cc91535d4a23cad2", "filename": "src/tools/clippy/tests/ui/issue_4266.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fissue_4266.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fissue_4266.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fissue_4266.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -12,5 +12,14 @@ error: explicit lifetimes given in parameter types where they could be elided (o\n LL | async fn one_to_one<'a>(s: &'a str) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: methods called `new` usually take no `self`\n+  --> $DIR/issue_4266.rs:27:22\n+   |\n+LL |     pub async fn new(&mut self) -> Self {\n+   |                      ^^^^^^^^^\n+   |\n+   = note: `-D clippy::wrong-self-convention` implied by `-D warnings`\n+   = help: consider choosing a less ambiguous name\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "2c91e02e84223cd3257a4b898ac739ac9b675415", "filename": "src/tools/clippy/tests/ui/iter_not_returning_iterator.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_not_returning_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_not_returning_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_not_returning_iterator.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -44,4 +44,24 @@ impl Iterator for Counter {\n     }\n }\n \n+// Issue #8225\n+trait Iter {\n+    type I;\n+    fn iter(&self) -> Self::I;\n+}\n+\n+impl Iter for () {\n+    type I = core::slice::Iter<'static, ()>;\n+    fn iter(&self) -> Self::I {\n+        [].iter()\n+    }\n+}\n+\n+struct S;\n+impl S {\n+    fn iter(&self) -> <() as Iter>::I {\n+        ().iter()\n+    }\n+}\n+\n fn main() {}"}, {"sha": "44f0295583695bfadd40376d53fd383c76ad0872", "filename": "src/tools/clippy/tests/ui/iter_not_returning_iterator.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_not_returning_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_not_returning_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_not_returning_iterator.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -12,5 +12,11 @@ error: this method is named `iter_mut` but its return type does not implement `I\n LL |     fn iter_mut(&self) -> Counter2 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: this method is named `iter` but its return type does not implement `Iterator`\n+  --> $DIR/iter_not_returning_iterator.rs:50:5\n+   |\n+LL |     fn iter(&self) -> Self::I;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "4f1b19b75b8a1014d388b2a7097b3e34d7dc8b8c", "filename": "src/tools/clippy/tests/ui/manual_bits.fixed", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_bits.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_bits.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_bits.fixed?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,48 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_bits)]\n+#![allow(clippy::no_effect, path_statements, unused_must_use, clippy::unnecessary_operation)]\n+\n+use std::mem::{size_of, size_of_val};\n+\n+fn main() {\n+    i8::BITS;\n+    i16::BITS;\n+    i32::BITS;\n+    i64::BITS;\n+    i128::BITS;\n+    isize::BITS;\n+\n+    u8::BITS;\n+    u16::BITS;\n+    u32::BITS;\n+    u64::BITS;\n+    u128::BITS;\n+    usize::BITS;\n+\n+    i8::BITS;\n+    i16::BITS;\n+    i32::BITS;\n+    i64::BITS;\n+    i128::BITS;\n+    isize::BITS;\n+\n+    u8::BITS;\n+    u16::BITS;\n+    u32::BITS;\n+    u64::BITS;\n+    u128::BITS;\n+    usize::BITS;\n+\n+    size_of::<usize>() * 4;\n+    4 * size_of::<usize>();\n+    size_of::<bool>() * 8;\n+    8 * size_of::<bool>();\n+\n+    size_of_val(&0u32) * 8;\n+\n+    type Word = u32;\n+    Word::BITS;\n+    type Bool = bool;\n+    size_of::<Bool>() * 8;\n+}"}, {"sha": "f8a01313e6ad02117bfb9c3a7bb69a7430878d73", "filename": "src/tools/clippy/tests/ui/manual_bits.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_bits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_bits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_bits.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,48 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_bits)]\n+#![allow(clippy::no_effect, path_statements, unused_must_use, clippy::unnecessary_operation)]\n+\n+use std::mem::{size_of, size_of_val};\n+\n+fn main() {\n+    size_of::<i8>() * 8;\n+    size_of::<i16>() * 8;\n+    size_of::<i32>() * 8;\n+    size_of::<i64>() * 8;\n+    size_of::<i128>() * 8;\n+    size_of::<isize>() * 8;\n+\n+    size_of::<u8>() * 8;\n+    size_of::<u16>() * 8;\n+    size_of::<u32>() * 8;\n+    size_of::<u64>() * 8;\n+    size_of::<u128>() * 8;\n+    size_of::<usize>() * 8;\n+\n+    8 * size_of::<i8>();\n+    8 * size_of::<i16>();\n+    8 * size_of::<i32>();\n+    8 * size_of::<i64>();\n+    8 * size_of::<i128>();\n+    8 * size_of::<isize>();\n+\n+    8 * size_of::<u8>();\n+    8 * size_of::<u16>();\n+    8 * size_of::<u32>();\n+    8 * size_of::<u64>();\n+    8 * size_of::<u128>();\n+    8 * size_of::<usize>();\n+\n+    size_of::<usize>() * 4;\n+    4 * size_of::<usize>();\n+    size_of::<bool>() * 8;\n+    8 * size_of::<bool>();\n+\n+    size_of_val(&0u32) * 8;\n+\n+    type Word = u32;\n+    size_of::<Word>() * 8;\n+    type Bool = bool;\n+    size_of::<Bool>() * 8;\n+}"}, {"sha": "c4f5af2dcb0ec464192b497776482ac0f36ecc2b", "filename": "src/tools/clippy/tests/ui/manual_bits.stderr", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_bits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_bits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_bits.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,154 @@\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:9:5\n+   |\n+LL |     size_of::<i8>() * 8;\n+   |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `i8::BITS`\n+   |\n+   = note: `-D clippy::manual-bits` implied by `-D warnings`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:10:5\n+   |\n+LL |     size_of::<i16>() * 8;\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i16::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:11:5\n+   |\n+LL |     size_of::<i32>() * 8;\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i32::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:12:5\n+   |\n+LL |     size_of::<i64>() * 8;\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i64::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:13:5\n+   |\n+LL |     size_of::<i128>() * 8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `i128::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:14:5\n+   |\n+LL |     size_of::<isize>() * 8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `isize::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:16:5\n+   |\n+LL |     size_of::<u8>() * 8;\n+   |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `u8::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:17:5\n+   |\n+LL |     size_of::<u16>() * 8;\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u16::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:18:5\n+   |\n+LL |     size_of::<u32>() * 8;\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u32::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:19:5\n+   |\n+LL |     size_of::<u64>() * 8;\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u64::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:20:5\n+   |\n+LL |     size_of::<u128>() * 8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `u128::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:21:5\n+   |\n+LL |     size_of::<usize>() * 8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `usize::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:23:5\n+   |\n+LL |     8 * size_of::<i8>();\n+   |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `i8::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:24:5\n+   |\n+LL |     8 * size_of::<i16>();\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i16::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:25:5\n+   |\n+LL |     8 * size_of::<i32>();\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i32::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:26:5\n+   |\n+LL |     8 * size_of::<i64>();\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i64::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:27:5\n+   |\n+LL |     8 * size_of::<i128>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `i128::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:28:5\n+   |\n+LL |     8 * size_of::<isize>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `isize::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:30:5\n+   |\n+LL |     8 * size_of::<u8>();\n+   |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `u8::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:31:5\n+   |\n+LL |     8 * size_of::<u16>();\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u16::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:32:5\n+   |\n+LL |     8 * size_of::<u32>();\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u32::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:33:5\n+   |\n+LL |     8 * size_of::<u64>();\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u64::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:34:5\n+   |\n+LL |     8 * size_of::<u128>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `u128::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:35:5\n+   |\n+LL |     8 * size_of::<usize>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `usize::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:45:5\n+   |\n+LL |     size_of::<Word>() * 8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `Word::BITS`\n+\n+error: aborting due to 25 previous errors\n+"}, {"sha": "79d40c0bcb1d984d12415e109ad711e2d2d02103", "filename": "src/tools/clippy/tests/ui/manual_memcpy/with_loop_counters.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -5,7 +5,7 @@ LL | /     for i in 3..src.len() {\n LL | |         dst[i] = src[count];\n LL | |         count += 1;\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[3..src.len()].clone_from_slice(&src[..(src.len() - 3)]);`\n+   | |_____^ help: try replacing the loop by: `dst[3..src.len()].copy_from_slice(&src[..(src.len() - 3)]);`\n    |\n    = note: `-D clippy::manual-memcpy` implied by `-D warnings`\n \n@@ -16,7 +16,7 @@ LL | /     for i in 3..src.len() {\n LL | |         dst[count] = src[i];\n LL | |         count += 1;\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[..(src.len() - 3)].clone_from_slice(&src[3..]);`\n+   | |_____^ help: try replacing the loop by: `dst[..(src.len() - 3)].copy_from_slice(&src[3..]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/with_loop_counters.rs:17:5\n@@ -25,7 +25,7 @@ LL | /     for i in 0..src.len() {\n LL | |         dst[count] = src[i];\n LL | |         count += 1;\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[3..(src.len() + 3)].clone_from_slice(&src[..]);`\n+   | |_____^ help: try replacing the loop by: `dst[3..(src.len() + 3)].copy_from_slice(&src[..]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/with_loop_counters.rs:23:5\n@@ -34,7 +34,7 @@ LL | /     for i in 0..src.len() {\n LL | |         dst[i] = src[count];\n LL | |         count += 1;\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[3..(src.len() + 3)]);`\n+   | |_____^ help: try replacing the loop by: `dst[..src.len()].copy_from_slice(&src[3..(src.len() + 3)]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/with_loop_counters.rs:29:5\n@@ -43,7 +43,7 @@ LL | /     for i in 3..(3 + src.len()) {\n LL | |         dst[i] = src[count];\n LL | |         count += 1;\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[3..(3 + src.len())].clone_from_slice(&src[..(3 + src.len() - 3)]);`\n+   | |_____^ help: try replacing the loop by: `dst[3..(3 + src.len())].copy_from_slice(&src[..(3 + src.len() - 3)]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/with_loop_counters.rs:35:5\n@@ -52,7 +52,7 @@ LL | /     for i in 5..src.len() {\n LL | |         dst[i] = src[count - 2];\n LL | |         count += 1;\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[5..src.len()].clone_from_slice(&src[(3 - 2)..((src.len() - 2) + 3 - 5)]);`\n+   | |_____^ help: try replacing the loop by: `dst[5..src.len()].copy_from_slice(&src[(3 - 2)..((src.len() - 2) + 3 - 5)]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/with_loop_counters.rs:41:5\n@@ -61,7 +61,7 @@ LL | /     for i in 0..dst.len() {\n LL | |         dst[i] = src[count];\n LL | |         count += 1;\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst.clone_from_slice(&src[2..(dst.len() + 2)]);`\n+   | |_____^ help: try replacing the loop by: `dst.copy_from_slice(&src[2..(dst.len() + 2)]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/with_loop_counters.rs:47:5\n@@ -70,7 +70,7 @@ LL | /     for i in 3..10 {\n LL | |         dst[i] = src[count];\n LL | |         count += 1;\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[3..10].clone_from_slice(&src[5..(10 + 5 - 3)]);`\n+   | |_____^ help: try replacing the loop by: `dst[3..10].copy_from_slice(&src[5..(10 + 5 - 3)]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/with_loop_counters.rs:54:5\n@@ -85,8 +85,8 @@ LL | |     }\n    |\n help: try replacing the loop by\n    |\n-LL ~     dst[3..(src.len() + 3)].clone_from_slice(&src[..]);\n-LL +     dst2[30..(src.len() + 30)].clone_from_slice(&src[..]);\n+LL ~     dst[3..(src.len() + 3)].copy_from_slice(&src[..]);\n+LL +     dst2[30..(src.len() + 30)].copy_from_slice(&src[..]);\n    |\n \n error: it looks like you're manually copying between slices\n@@ -96,7 +96,7 @@ LL | /     for i in 0..1 << 1 {\n LL | |         dst[count] = src[i + 2];\n LL | |         count += 1;\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[(0 << 1)..((1 << 1) + (0 << 1))].clone_from_slice(&src[2..((1 << 1) + 2)]);`\n+   | |_____^ help: try replacing the loop by: `dst[(0 << 1)..((1 << 1) + (0 << 1))].copy_from_slice(&src[2..((1 << 1) + 2)]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/with_loop_counters.rs:71:5\n@@ -105,7 +105,7 @@ LL | /     for i in 3..src.len() {\n LL | |         dst[i] = src[count];\n LL | |         count += 1\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[3..src.len()].clone_from_slice(&src[..(src.len() - 3)]);`\n+   | |_____^ help: try replacing the loop by: `dst[3..src.len()].copy_from_slice(&src[..(src.len() - 3)]);`\n \n error: aborting due to 11 previous errors\n "}, {"sha": "ea0535d076b81911d99676b6d785afe22141544a", "filename": "src/tools/clippy/tests/ui/manual_memcpy/without_loop_counters.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -113,6 +113,17 @@ pub fn manual_copy(src: &[i32], dst: &mut [i32], dst2: &mut [i32]) {\n     for i in 0.. {\n         dst[i] = src[i];\n     }\n+\n+    // VecDeque - ideally this would work, but would require something like `range_as_slices`\n+    let mut dst = std::collections::VecDeque::from_iter([0; 5]);\n+    let src = std::collections::VecDeque::from_iter([0, 1, 2, 3, 4]);\n+    for i in 0..dst.len() {\n+        dst[i] = src[i];\n+    }\n+    let src = vec![0, 1, 2, 3, 4];\n+    for i in 0..dst.len() {\n+        dst[i] = src[i];\n+    }\n }\n \n #[warn(clippy::needless_range_loop, clippy::manual_memcpy)]"}, {"sha": "c163ae061dfc934235b87a4b5ef0c8971ae370e5", "filename": "src/tools/clippy/tests/ui/manual_memcpy/without_loop_counters.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -4,7 +4,7 @@ error: it looks like you're manually copying between slices\n LL | /     for i in 0..src.len() {\n LL | |         dst[i] = src[i];\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[..]);`\n+   | |_____^ help: try replacing the loop by: `dst[..src.len()].copy_from_slice(&src[..]);`\n    |\n    = note: `-D clippy::manual-memcpy` implied by `-D warnings`\n \n@@ -14,31 +14,31 @@ error: it looks like you're manually copying between slices\n LL | /     for i in 0..src.len() {\n LL | |         dst[i + 10] = src[i];\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[10..(src.len() + 10)].clone_from_slice(&src[..]);`\n+   | |_____^ help: try replacing the loop by: `dst[10..(src.len() + 10)].copy_from_slice(&src[..]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/without_loop_counters.rs:17:5\n    |\n LL | /     for i in 0..src.len() {\n LL | |         dst[i] = src[i + 10];\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[10..(src.len() + 10)]);`\n+   | |_____^ help: try replacing the loop by: `dst[..src.len()].copy_from_slice(&src[10..(src.len() + 10)]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/without_loop_counters.rs:22:5\n    |\n LL | /     for i in 11..src.len() {\n LL | |         dst[i] = src[i - 10];\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[11..src.len()].clone_from_slice(&src[(11 - 10)..(src.len() - 10)]);`\n+   | |_____^ help: try replacing the loop by: `dst[11..src.len()].copy_from_slice(&src[(11 - 10)..(src.len() - 10)]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/without_loop_counters.rs:27:5\n    |\n LL | /     for i in 0..dst.len() {\n LL | |         dst[i] = src[i];\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst.clone_from_slice(&src[..dst.len()]);`\n+   | |_____^ help: try replacing the loop by: `dst.copy_from_slice(&src[..dst.len()]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/without_loop_counters.rs:40:5\n@@ -51,8 +51,8 @@ LL | |     }\n    |\n help: try replacing the loop by\n    |\n-LL ~     dst[10..256].clone_from_slice(&src[(10 - 5)..(256 - 5)]);\n-LL +     dst2[(10 + 500)..(256 + 500)].clone_from_slice(&src[10..256]);\n+LL ~     dst[10..256].copy_from_slice(&src[(10 - 5)..(256 - 5)]);\n+LL +     dst2[(10 + 500)..(256 + 500)].copy_from_slice(&src[10..256]);\n    |\n \n error: it looks like you're manually copying between slices\n@@ -61,50 +61,50 @@ error: it looks like you're manually copying between slices\n LL | /     for i in 10..LOOP_OFFSET {\n LL | |         dst[i + LOOP_OFFSET] = src[i - some_var];\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[(10 + LOOP_OFFSET)..(LOOP_OFFSET + LOOP_OFFSET)].clone_from_slice(&src[(10 - some_var)..(LOOP_OFFSET - some_var)]);`\n+   | |_____^ help: try replacing the loop by: `dst[(10 + LOOP_OFFSET)..(LOOP_OFFSET + LOOP_OFFSET)].copy_from_slice(&src[(10 - some_var)..(LOOP_OFFSET - some_var)]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/without_loop_counters.rs:65:5\n    |\n LL | /     for i in 0..src_vec.len() {\n LL | |         dst_vec[i] = src_vec[i];\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst_vec[..src_vec.len()].clone_from_slice(&src_vec[..]);`\n+   | |_____^ help: try replacing the loop by: `dst_vec[..src_vec.len()].copy_from_slice(&src_vec[..]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/without_loop_counters.rs:94:5\n    |\n LL | /     for i in from..from + src.len() {\n LL | |         dst[i] = src[i - from];\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[from..(from + src.len())].clone_from_slice(&src[..(from + src.len() - from)]);`\n+   | |_____^ help: try replacing the loop by: `dst[from..(from + src.len())].copy_from_slice(&src[..(from + src.len() - from)]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/without_loop_counters.rs:98:5\n    |\n LL | /     for i in from..from + 3 {\n LL | |         dst[i] = src[i - from];\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[from..(from + 3)].clone_from_slice(&src[..(from + 3 - from)]);`\n+   | |_____^ help: try replacing the loop by: `dst[from..(from + 3)].copy_from_slice(&src[..(from + 3 - from)]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/without_loop_counters.rs:103:5\n    |\n LL | /     for i in 0..5 {\n LL | |         dst[i - 0] = src[i];\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[..5].clone_from_slice(&src[..5]);`\n+   | |_____^ help: try replacing the loop by: `dst[..5].copy_from_slice(&src[..5]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/without_loop_counters.rs:108:5\n    |\n LL | /     for i in 0..0 {\n LL | |         dst[i] = src[i];\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[..0].clone_from_slice(&src[..0]);`\n+   | |_____^ help: try replacing the loop by: `dst[..0].copy_from_slice(&src[..0]);`\n \n error: it looks like you're manually copying between slices\n-  --> $DIR/without_loop_counters.rs:120:5\n+  --> $DIR/without_loop_counters.rs:131:5\n    |\n LL | /     for i in 0..src.len() {\n LL | |         dst[i] = src[i].clone();"}, {"sha": "91ebd695238bb8db80da5f73388c0659768b64a9", "filename": "src/tools/clippy/tests/ui/missing_panics_doc.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmissing_panics_doc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmissing_panics_doc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmissing_panics_doc.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -27,7 +27,6 @@ note: first possible panic found here\n    |\n LL |     panic!(\"This function panics\")\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: docs for function which may panic missing `# Panics` section\n   --> $DIR/missing_panics_doc.rs:17:1\n@@ -42,7 +41,6 @@ note: first possible panic found here\n    |\n LL |     todo!()\n    |     ^^^^^^^\n-   = note: this error originates in the macro `todo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: docs for function which may panic missing `# Panics` section\n   --> $DIR/missing_panics_doc.rs:22:1\n@@ -61,7 +59,6 @@ note: first possible panic found here\n    |\n LL |             panic!()\n    |             ^^^^^^^^\n-   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: docs for function which may panic missing `# Panics` section\n   --> $DIR/missing_panics_doc.rs:31:1\n@@ -76,7 +73,6 @@ note: first possible panic found here\n    |\n LL |     if true { unreachable!() } else { panic!() }\n    |                                       ^^^^^^^^\n-   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: docs for function which may panic missing `# Panics` section\n   --> $DIR/missing_panics_doc.rs:36:1\n@@ -92,7 +88,6 @@ note: first possible panic found here\n    |\n LL |     assert_eq!(x, 0);\n    |     ^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: docs for function which may panic missing `# Panics` section\n   --> $DIR/missing_panics_doc.rs:42:1\n@@ -108,7 +103,6 @@ note: first possible panic found here\n    |\n LL |     assert_ne!(x, 0);\n    |     ^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `assert_ne` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 7 previous errors\n "}, {"sha": "47b3dad3989779188290cf5ede5cf10a443e076b", "filename": "src/tools/clippy/tests/ui/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmutex_atomic.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,5 +1,7 @@\n #![warn(clippy::all)]\n #![warn(clippy::mutex_integer)]\n+#![warn(clippy::mutex_atomic)]\n+#![allow(clippy::borrow_as_ptr)]\n \n fn main() {\n     use std::sync::Mutex;"}, {"sha": "262028a8723a3f9a2931d13f3a3ef08c0a8ad70a", "filename": "src/tools/clippy/tests/ui/mutex_atomic.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmutex_atomic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmutex_atomic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmutex_atomic.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,45 +1,45 @@\n error: consider using an `AtomicBool` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n-  --> $DIR/mutex_atomic.rs:6:5\n+  --> $DIR/mutex_atomic.rs:8:5\n    |\n LL |     Mutex::new(true);\n    |     ^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::mutex-atomic` implied by `-D warnings`\n \n error: consider using an `AtomicUsize` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n-  --> $DIR/mutex_atomic.rs:7:5\n+  --> $DIR/mutex_atomic.rs:9:5\n    |\n LL |     Mutex::new(5usize);\n    |     ^^^^^^^^^^^^^^^^^^\n \n error: consider using an `AtomicIsize` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n-  --> $DIR/mutex_atomic.rs:8:5\n+  --> $DIR/mutex_atomic.rs:10:5\n    |\n LL |     Mutex::new(9isize);\n    |     ^^^^^^^^^^^^^^^^^^\n \n error: consider using an `AtomicPtr` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n-  --> $DIR/mutex_atomic.rs:10:5\n+  --> $DIR/mutex_atomic.rs:12:5\n    |\n LL |     Mutex::new(&x as *const u32);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: consider using an `AtomicPtr` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n-  --> $DIR/mutex_atomic.rs:11:5\n+  --> $DIR/mutex_atomic.rs:13:5\n    |\n LL |     Mutex::new(&mut x as *mut u32);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: consider using an `AtomicUsize` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n-  --> $DIR/mutex_atomic.rs:12:5\n+  --> $DIR/mutex_atomic.rs:14:5\n    |\n LL |     Mutex::new(0u32);\n    |     ^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::mutex-integer` implied by `-D warnings`\n \n error: consider using an `AtomicIsize` instead of a `Mutex` here; if you just want the locking behavior and not the internal type, consider using `Mutex<()>`\n-  --> $DIR/mutex_atomic.rs:13:5\n+  --> $DIR/mutex_atomic.rs:15:5\n    |\n LL |     Mutex::new(0i32);\n    |     ^^^^^^^^^^^^^^^^"}, {"sha": "87cdb3ace47cb68176d4f4f6921313f55017cc9e", "filename": "src/tools/clippy/tests/ui/or_fun_call.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.fixed?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -2,7 +2,7 @@\n \n #![warn(clippy::or_fun_call)]\n #![allow(dead_code)]\n-#![allow(clippy::unnecessary_wraps)]\n+#![allow(clippy::unnecessary_wraps, clippy::borrow_as_ptr)]\n \n use std::collections::BTreeMap;\n use std::collections::HashMap;"}, {"sha": "3f69cef301c8b1b96d262067a2e719b1b6056735", "filename": "src/tools/clippy/tests/ui/or_fun_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -2,7 +2,7 @@\n \n #![warn(clippy::or_fun_call)]\n #![allow(dead_code)]\n-#![allow(clippy::unnecessary_wraps)]\n+#![allow(clippy::unnecessary_wraps, clippy::borrow_as_ptr)]\n \n use std::collections::BTreeMap;\n use std::collections::HashMap;"}, {"sha": "561503ae54fa22d67995e7dc8f60f88036f94bb5", "filename": "src/tools/clippy/tests/ui/panic_in_result_fn.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -14,7 +14,6 @@ note: return Err() instead of panicking\n    |\n LL |         panic!(\"error\");\n    |         ^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:11:5\n@@ -31,7 +30,6 @@ note: return Err() instead of panicking\n    |\n LL |         unimplemented!();\n    |         ^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `unimplemented` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:16:5\n@@ -48,7 +46,6 @@ note: return Err() instead of panicking\n    |\n LL |         unreachable!();\n    |         ^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `unreachable` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:21:5\n@@ -65,7 +62,6 @@ note: return Err() instead of panicking\n    |\n LL |         todo!(\"Finish this\");\n    |         ^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `todo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:52:1\n@@ -82,7 +78,6 @@ note: return Err() instead of panicking\n    |\n LL |     panic!(\"error\");\n    |     ^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `$crate::panic::panic_2021` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:67:1\n@@ -99,7 +94,6 @@ note: return Err() instead of panicking\n    |\n LL |     todo!(\"finish main method\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `todo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 6 previous errors\n "}, {"sha": "b6aa005e7b521364cce80a4c6b4014eef9d83ad2", "filename": "src/tools/clippy/tests/ui/panic_in_result_fn_assertions.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn_assertions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn_assertions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn_assertions.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -15,7 +15,6 @@ note: return Err() instead of panicking\n    |\n LL |         assert!(x == 5, \"wrong argument\");\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn_assertions.rs:13:5\n@@ -33,7 +32,6 @@ note: return Err() instead of panicking\n    |\n LL |         assert_eq!(x, 5);\n    |         ^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn_assertions.rs:19:5\n@@ -51,7 +49,6 @@ note: return Err() instead of panicking\n    |\n LL |         assert_ne!(x, 1);\n    |         ^^^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `assert_ne` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 3 previous errors\n "}, {"sha": "bfd1c7a380149b2cb89f6480f96b6ed1d1669808", "filename": "src/tools/clippy/tests/ui/panicking_macros.stderr", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanicking_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanicking_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanicking_macros.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -25,23 +25,18 @@ LL |     todo!();\n    |     ^^^^^^^\n    |\n    = note: `-D clippy::todo` implied by `-D warnings`\n-   = note: this error originates in the macro `todo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `todo` should not be present in production code\n   --> $DIR/panicking_macros.rs:17:5\n    |\n LL |     todo!(\"message\");\n    |     ^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the macro `todo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `todo` should not be present in production code\n   --> $DIR/panicking_macros.rs:18:5\n    |\n LL |     todo!(\"{} {}\", \"panic with\", \"multiple arguments\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the macro `todo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `unimplemented` should not be present in production code\n   --> $DIR/panicking_macros.rs:24:5\n@@ -50,23 +45,18 @@ LL |     unimplemented!();\n    |     ^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::unimplemented` implied by `-D warnings`\n-   = note: this error originates in the macro `unimplemented` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `unimplemented` should not be present in production code\n   --> $DIR/panicking_macros.rs:25:5\n    |\n LL |     unimplemented!(\"message\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the macro `unimplemented` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `unimplemented` should not be present in production code\n   --> $DIR/panicking_macros.rs:26:5\n    |\n LL |     unimplemented!(\"{} {}\", \"panic with\", \"multiple arguments\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the macro `unimplemented` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: usage of the `unreachable!` macro\n   --> $DIR/panicking_macros.rs:32:5\n@@ -75,23 +65,18 @@ LL |     unreachable!();\n    |     ^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::unreachable` implied by `-D warnings`\n-   = note: this error originates in the macro `unreachable` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: usage of the `unreachable!` macro\n   --> $DIR/panicking_macros.rs:33:5\n    |\n LL |     unreachable!(\"message\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the macro `$crate::unreachable` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: usage of the `unreachable!` macro\n   --> $DIR/panicking_macros.rs:34:5\n    |\n LL |     unreachable!(\"{} {}\", \"panic with\", \"multiple arguments\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the macro `unreachable` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `panic` should not be present in production code\n   --> $DIR/panicking_macros.rs:40:5\n@@ -104,24 +89,18 @@ error: `todo` should not be present in production code\n    |\n LL |     todo!();\n    |     ^^^^^^^\n-   |\n-   = note: this error originates in the macro `todo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `unimplemented` should not be present in production code\n   --> $DIR/panicking_macros.rs:42:5\n    |\n LL |     unimplemented!();\n    |     ^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the macro `unimplemented` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: usage of the `unreachable!` macro\n   --> $DIR/panicking_macros.rs:43:5\n    |\n LL |     unreachable!();\n    |     ^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the macro `unreachable` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 16 previous errors\n "}, {"sha": "8af10cb65c40670202da1fd459fea989382ccafc", "filename": "src/tools/clippy/tests/ui/return_self_not_must_use.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freturn_self_not_must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freturn_self_not_must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freturn_self_not_must_use.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -5,6 +5,7 @@ LL |     fn what(&self) -> Self;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::return-self-not-must-use` implied by `-D warnings`\n+   = help: consider adding the `#[must_use]` attribute to the method or directly to the `Self` type\n \n error: missing `#[must_use]` attribute on a method returning `Self`\n   --> $DIR/return_self_not_must_use.rs:17:5\n@@ -13,6 +14,8 @@ LL | /     pub fn foo(&self) -> Self {\n LL | |         Self\n LL | |     }\n    | |_____^\n+   |\n+   = help: consider adding the `#[must_use]` attribute to the method or directly to the `Self` type\n \n error: missing `#[must_use]` attribute on a method returning `Self`\n   --> $DIR/return_self_not_must_use.rs:20:5\n@@ -21,6 +24,8 @@ LL | /     pub fn bar(self) -> Self {\n LL | |         self\n LL | |     }\n    | |_____^\n+   |\n+   = help: consider adding the `#[must_use]` attribute to the method or directly to the `Self` type\n \n error: aborting due to 3 previous errors\n "}, {"sha": "261d8bc7260ca5deab6ab1519d4d9387eebaac87", "filename": "src/tools/clippy/tests/ui/single_char_lifetime_names.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_lifetime_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_lifetime_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_lifetime_names.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,43 @@\n+#![warn(clippy::single_char_lifetime_names)]\n+\n+// Lifetimes should only be linted when they're introduced\n+struct DiagnosticCtx<'a, 'b>\n+where\n+    'a: 'b,\n+{\n+    _source: &'a str,\n+    _unit: &'b (),\n+}\n+\n+// Only the lifetimes on the `impl`'s generics should be linted\n+impl<'a, 'b> DiagnosticCtx<'a, 'b> {\n+    fn new(source: &'a str, unit: &'b ()) -> DiagnosticCtx<'a, 'b> {\n+        Self {\n+            _source: source,\n+            _unit: unit,\n+        }\n+    }\n+}\n+\n+// No lifetimes should be linted here\n+impl<'src, 'unit> DiagnosticCtx<'src, 'unit> {\n+    fn new_pass(source: &'src str, unit: &'unit ()) -> DiagnosticCtx<'src, 'unit> {\n+        Self {\n+            _source: source,\n+            _unit: unit,\n+        }\n+    }\n+}\n+\n+// Only 'a should be linted here\n+fn split_once<'a>(base: &'a str, other: &'_ str) -> (&'a str, Option<&'a str>) {\n+    base.split_once(other)\n+        .map(|(left, right)| (left, Some(right)))\n+        .unwrap_or((base, None))\n+}\n+\n+fn main() {\n+    let src = \"loop {}\";\n+    let unit = ();\n+    DiagnosticCtx::new(src, &unit);\n+}"}, {"sha": "013b64f46a8ce1d2795a288c6864a8603dec0c6b", "filename": "src/tools/clippy/tests/ui/single_char_lifetime_names.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_lifetime_names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_lifetime_names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_char_lifetime_names.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,43 @@\n+error: single-character lifetime names are likely uninformative\n+  --> $DIR/single_char_lifetime_names.rs:4:22\n+   |\n+LL | struct DiagnosticCtx<'a, 'b>\n+   |                      ^^\n+   |\n+   = note: `-D clippy::single-char-lifetime-names` implied by `-D warnings`\n+   = help: use a more informative name\n+\n+error: single-character lifetime names are likely uninformative\n+  --> $DIR/single_char_lifetime_names.rs:4:26\n+   |\n+LL | struct DiagnosticCtx<'a, 'b>\n+   |                          ^^\n+   |\n+   = help: use a more informative name\n+\n+error: single-character lifetime names are likely uninformative\n+  --> $DIR/single_char_lifetime_names.rs:13:6\n+   |\n+LL | impl<'a, 'b> DiagnosticCtx<'a, 'b> {\n+   |      ^^\n+   |\n+   = help: use a more informative name\n+\n+error: single-character lifetime names are likely uninformative\n+  --> $DIR/single_char_lifetime_names.rs:13:10\n+   |\n+LL | impl<'a, 'b> DiagnosticCtx<'a, 'b> {\n+   |          ^^\n+   |\n+   = help: use a more informative name\n+\n+error: single-character lifetime names are likely uninformative\n+  --> $DIR/single_char_lifetime_names.rs:33:15\n+   |\n+LL | fn split_once<'a>(base: &'a str, other: &'_ str) -> (&'a str, Option<&'a str>) {\n+   |               ^^\n+   |\n+   = help: use a more informative name\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "3329efbd4ff429f1daabef797cf9793513b010c0", "filename": "src/tools/clippy/tests/ui/swap.fixed", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fswap.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fswap.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fswap.fixed?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -122,3 +122,36 @@ fn main() {\n \n     ; std::mem::swap(&mut c.0, &mut a);\n }\n+\n+fn issue_8154() {\n+    struct S1 {\n+        x: i32,\n+        y: i32,\n+    }\n+    struct S2(S1);\n+    struct S3<'a, 'b>(&'a mut &'b mut S1);\n+\n+    impl std::ops::Deref for S2 {\n+        type Target = S1;\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    impl std::ops::DerefMut for S2 {\n+        fn deref_mut(&mut self) -> &mut Self::Target {\n+            &mut self.0\n+        }\n+    }\n+\n+    // Don't lint. `s.0` is mutably borrowed by `s.x` and `s.y` via the deref impl.\n+    let mut s = S2(S1 { x: 0, y: 0 });\n+    let t = s.x;\n+    s.x = s.y;\n+    s.y = t;\n+\n+    // Accessing through a mutable reference is fine\n+    let mut s = S1 { x: 0, y: 0 };\n+    let mut s = &mut s;\n+    let s = S3(&mut s);\n+    std::mem::swap(&mut s.0.x, &mut s.0.y);\n+}"}, {"sha": "8179ac1f2ab028a7a5d5eb26a0adcb6a24c811c7", "filename": "src/tools/clippy/tests/ui/swap.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fswap.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -144,3 +144,38 @@ fn main() {\n     c.0 = a;\n     a = t;\n }\n+\n+fn issue_8154() {\n+    struct S1 {\n+        x: i32,\n+        y: i32,\n+    }\n+    struct S2(S1);\n+    struct S3<'a, 'b>(&'a mut &'b mut S1);\n+\n+    impl std::ops::Deref for S2 {\n+        type Target = S1;\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    impl std::ops::DerefMut for S2 {\n+        fn deref_mut(&mut self) -> &mut Self::Target {\n+            &mut self.0\n+        }\n+    }\n+\n+    // Don't lint. `s.0` is mutably borrowed by `s.x` and `s.y` via the deref impl.\n+    let mut s = S2(S1 { x: 0, y: 0 });\n+    let t = s.x;\n+    s.x = s.y;\n+    s.y = t;\n+\n+    // Accessing through a mutable reference is fine\n+    let mut s = S1 { x: 0, y: 0 };\n+    let mut s = &mut s;\n+    let s = S3(&mut s);\n+    let t = s.0.x;\n+    s.0.x = s.0.y;\n+    s.0.y = t;\n+}"}, {"sha": "2b556b475cee9da92ba55ebc79139ff980231ed0", "filename": "src/tools/clippy/tests/ui/swap.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fswap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fswap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fswap.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -108,5 +108,15 @@ LL | |     a = c.0;\n    |\n    = note: or maybe you should use `std::mem::replace`?\n \n-error: aborting due to 12 previous errors\n+error: this looks like you are swapping `s.0.x` and `s.0.y` manually\n+  --> $DIR/swap.rs:178:5\n+   |\n+LL | /     let t = s.0.x;\n+LL | |     s.0.x = s.0.y;\n+LL | |     s.0.y = t;\n+   | |_____________^ help: try: `std::mem::swap(&mut s.0.x, &mut s.0.y)`\n+   |\n+   = note: or maybe you should use `std::mem::replace`?\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "2edb202892afcaf4c1b65a7b3e91337a8779f3b8", "filename": "src/tools/clippy/tests/ui/trait_duplication_in_bounds.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -28,4 +28,49 @@ where\n     unimplemented!();\n }\n \n+trait T: Default {\n+    fn f()\n+    where\n+        Self: Default;\n+}\n+\n+trait U: Default {\n+    fn f()\n+    where\n+        Self: Clone;\n+}\n+\n+trait ZZ: Default {\n+    fn g();\n+    fn h();\n+    fn f()\n+    where\n+        Self: Default + Clone;\n+}\n+\n+trait BadTrait: Default + Clone {\n+    fn f()\n+    where\n+        Self: Default + Clone;\n+    fn g()\n+    where\n+        Self: Default;\n+    fn h()\n+    where\n+        Self: Copy;\n+}\n+\n+#[derive(Default, Clone)]\n+struct Life {}\n+\n+impl T for Life {\n+    // this should not warn\n+    fn f() {}\n+}\n+\n+impl U for Life {\n+    // this should not warn\n+    fn f() {}\n+}\n+\n fn main() {}"}, {"sha": "e0c7a7ec618ed932223b8fb8a17f3e5ca61b0eab", "filename": "src/tools/clippy/tests/ui/trait_duplication_in_bounds.stderr", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftrait_duplication_in_bounds.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -19,5 +19,45 @@ LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n    |\n    = help: consider removing this trait bound\n \n-error: aborting due to 2 previous errors\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds.rs:34:15\n+   |\n+LL |         Self: Default;\n+   |               ^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds.rs:48:15\n+   |\n+LL |         Self: Default + Clone;\n+   |               ^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds.rs:54:15\n+   |\n+LL |         Self: Default + Clone;\n+   |               ^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds.rs:54:25\n+   |\n+LL |         Self: Default + Clone;\n+   |                         ^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in trait declaration\n+  --> $DIR/trait_duplication_in_bounds.rs:57:15\n+   |\n+LL |         Self: Default;\n+   |               ^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: aborting due to 7 previous errors\n "}, {"sha": "9b681a79aae7a385f922a6c04aaf2cd06b37bd94", "filename": "src/tools/clippy/tests/ui/transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,4 +1,4 @@\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::borrow_as_ptr)]\n \n extern crate core;\n "}, {"sha": "f06ffab5d9be966df12a1fd93267c5be60f96135", "filename": "src/tools/clippy/tests/ui/transmute_ptr_to_ptr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_ptr_to_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_ptr_to_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_ptr_to_ptr.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::transmute_ptr_to_ptr)]\n+#![allow(clippy::borrow_as_ptr)]\n \n // Make sure we can modify lifetimes, which is one of the recommended uses\n // of transmute"}, {"sha": "49a8a3347e40497fede9a81d9d9ab0979ae7d9be", "filename": "src/tools/clippy/tests/ui/transmute_ptr_to_ptr.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_ptr_to_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_ptr_to_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_ptr_to_ptr.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,37 +1,37 @@\n error: transmute from a pointer to a pointer\n-  --> $DIR/transmute_ptr_to_ptr.rs:29:29\n+  --> $DIR/transmute_ptr_to_ptr.rs:30:29\n    |\n LL |         let _: *const f32 = std::mem::transmute(ptr);\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr as *const f32`\n    |\n    = note: `-D clippy::transmute-ptr-to-ptr` implied by `-D warnings`\n \n error: transmute from a pointer to a pointer\n-  --> $DIR/transmute_ptr_to_ptr.rs:30:27\n+  --> $DIR/transmute_ptr_to_ptr.rs:31:27\n    |\n LL |         let _: *mut f32 = std::mem::transmute(mut_ptr);\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `mut_ptr as *mut f32`\n \n error: transmute from a reference to a reference\n-  --> $DIR/transmute_ptr_to_ptr.rs:32:23\n+  --> $DIR/transmute_ptr_to_ptr.rs:33:23\n    |\n LL |         let _: &f32 = std::mem::transmute(&1u32);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*(&1u32 as *const u32 as *const f32)`\n \n error: transmute from a reference to a reference\n-  --> $DIR/transmute_ptr_to_ptr.rs:33:23\n+  --> $DIR/transmute_ptr_to_ptr.rs:34:23\n    |\n LL |         let _: &f64 = std::mem::transmute(&1f32);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*(&1f32 as *const f32 as *const f64)`\n \n error: transmute from a reference to a reference\n-  --> $DIR/transmute_ptr_to_ptr.rs:36:27\n+  --> $DIR/transmute_ptr_to_ptr.rs:37:27\n    |\n LL |         let _: &mut f32 = std::mem::transmute(&mut 1u32);\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&mut *(&mut 1u32 as *mut u32 as *mut f32)`\n \n error: transmute from a reference to a reference\n-  --> $DIR/transmute_ptr_to_ptr.rs:37:37\n+  --> $DIR/transmute_ptr_to_ptr.rs:38:37\n    |\n LL |         let _: &GenericParam<f32> = std::mem::transmute(&GenericParam { t: 1u32 });\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*(&GenericParam { t: 1u32 } as *const GenericParam<u32> as *const GenericParam<f32>)`"}, {"sha": "9ae0ed0b13f1e779a8ee08e82d3a9b4d1505a065", "filename": "src/tools/clippy/tests/ui/transmutes_expressible_as_ptr_casts.fixed", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -4,8 +4,7 @@\n // would otherwise be responsible for\n #![warn(clippy::useless_transmute)]\n #![warn(clippy::transmute_ptr_to_ptr)]\n-#![allow(unused_unsafe)]\n-#![allow(dead_code)]\n+#![allow(dead_code, unused_unsafe, clippy::borrow_as_ptr)]\n \n use std::mem::{size_of, transmute};\n "}, {"sha": "985cf9a075d312899d88409f78cb93b40a81529e", "filename": "src/tools/clippy/tests/ui/transmutes_expressible_as_ptr_casts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -4,8 +4,7 @@\n // would otherwise be responsible for\n #![warn(clippy::useless_transmute)]\n #![warn(clippy::transmute_ptr_to_ptr)]\n-#![allow(unused_unsafe)]\n-#![allow(dead_code)]\n+#![allow(dead_code, unused_unsafe, clippy::borrow_as_ptr)]\n \n use std::mem::{size_of, transmute};\n "}, {"sha": "e8496a325d6dc670178d789d13e73e60bb302848", "filename": "src/tools/clippy/tests/ui/transmutes_expressible_as_ptr_casts.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,53 +1,53 @@\n error: transmute from an integer to a pointer\n-  --> $DIR/transmutes_expressible_as_ptr_casts.rs:19:39\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:18:39\n    |\n LL |     let _ptr_i32_transmute = unsafe { transmute::<usize, *const i32>(usize::MAX) };\n    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `usize::MAX as *const i32`\n    |\n    = note: `-D clippy::useless-transmute` implied by `-D warnings`\n \n error: transmute from a pointer to a pointer\n-  --> $DIR/transmutes_expressible_as_ptr_casts.rs:23:38\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:22:38\n    |\n LL |     let _ptr_i8_transmute = unsafe { transmute::<*const i32, *const i8>(ptr_i32) };\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr_i32 as *const i8`\n    |\n    = note: `-D clippy::transmute-ptr-to-ptr` implied by `-D warnings`\n \n error: transmute from a pointer to a pointer\n-  --> $DIR/transmutes_expressible_as_ptr_casts.rs:29:46\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:28:46\n    |\n LL |     let _ptr_to_unsized_transmute = unsafe { transmute::<*const [i32], *const [u16]>(slice_ptr) };\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `slice_ptr as *const [u16]`\n \n error: transmute from `*const i32` to `usize` which could be expressed as a pointer cast instead\n-  --> $DIR/transmutes_expressible_as_ptr_casts.rs:35:50\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:34:50\n    |\n LL |     let _usize_from_int_ptr_transmute = unsafe { transmute::<*const i32, usize>(ptr_i32) };\n    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr_i32 as usize`\n    |\n    = note: `-D clippy::transmutes-expressible-as-ptr-casts` implied by `-D warnings`\n \n error: transmute from a reference to a pointer\n-  --> $DIR/transmutes_expressible_as_ptr_casts.rs:41:41\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:40:41\n    |\n LL |     let _array_ptr_transmute = unsafe { transmute::<&[i32; 4], *const [i32; 4]>(array_ref) };\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `array_ref as *const [i32; 4]`\n \n error: transmute from `fn(usize) -> u8 {main::foo}` to `*const usize` which could be expressed as a pointer cast instead\n-  --> $DIR/transmutes_expressible_as_ptr_casts.rs:49:41\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:48:41\n    |\n LL |     let _usize_ptr_transmute = unsafe { transmute::<fn(usize) -> u8, *const usize>(foo) };\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `foo as *const usize`\n \n error: transmute from `fn(usize) -> u8 {main::foo}` to `usize` which could be expressed as a pointer cast instead\n-  --> $DIR/transmutes_expressible_as_ptr_casts.rs:53:49\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:52:49\n    |\n LL |     let _usize_from_fn_ptr_transmute = unsafe { transmute::<fn(usize) -> u8, usize>(foo) };\n    |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `foo as usize`\n \n error: transmute from a reference to a pointer\n-  --> $DIR/transmutes_expressible_as_ptr_casts.rs:65:14\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:64:14\n    |\n LL |     unsafe { transmute::<&[i32; 1], *const u8>(in_param) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `in_param as *const [i32; 1] as *const u8`"}, {"sha": "fc740ee11d6ab7b815ab274dd283c76b44055da6", "filename": "src/tools/clippy/tests/ui/type_repetition_in_bounds.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftype_repetition_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftype_repetition_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftype_repetition_in_bounds.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -69,4 +69,14 @@ mod issue4326 {\n     }\n }\n \n+// Issue #7360\n+struct Foo<T, U>\n+where\n+    T: Clone,\n+    U: Clone,\n+{\n+    t: T,\n+    u: U,\n+}\n+\n fn main() {}"}, {"sha": "824506a4257efdf11a64220a7b0f513c5eeebc41", "filename": "src/tools/clippy/tests/ui/unit_cmp.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_cmp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_cmp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_cmp.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -33,8 +33,6 @@ LL | |         },\n LL | |         }\n LL | |     );\n    | |_____^\n-   |\n-   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `debug_assert_eq` of unit values detected. This will always succeed\n   --> $DIR/unit_cmp.rs:32:5\n@@ -47,8 +45,6 @@ LL | |         },\n LL | |         }\n LL | |     );\n    | |_____^\n-   |\n-   = note: this error originates in the macro `$crate::assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `assert_ne` of unit values detected. This will always fail\n   --> $DIR/unit_cmp.rs:41:5\n@@ -61,8 +57,6 @@ LL | |         },\n LL | |         }\n LL | |     );\n    | |_____^\n-   |\n-   = note: this error originates in the macro `assert_ne` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `debug_assert_ne` of unit values detected. This will always fail\n   --> $DIR/unit_cmp.rs:49:5\n@@ -75,8 +69,6 @@ LL | |         },\n LL | |         }\n LL | |     );\n    | |_____^\n-   |\n-   = note: this error originates in the macro `$crate::assert_ne` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 6 previous errors\n "}, {"sha": "3332f49c80c9758c2f8cbd61fc19d48a7681dfee", "filename": "src/tools/clippy/tests/ui/unnecessary_cast_fixable.fixed", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.fixed?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,7 +1,12 @@\n // run-rustfix\n \n #![warn(clippy::unnecessary_cast)]\n-#![allow(clippy::no_effect, clippy::unnecessary_operation, clippy::nonstandard_macro_braces)]\n+#![allow(\n+    clippy::no_effect,\n+    clippy::unnecessary_operation,\n+    clippy::nonstandard_macro_braces,\n+    clippy::borrow_as_ptr\n+)]\n \n fn main() {\n     // casting integer literal to float is unnecessary"}, {"sha": "ec01e93877927af3f51217fe4f194bfb6d8d9645", "filename": "src/tools/clippy/tests/ui/unnecessary_cast_fixable.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,7 +1,12 @@\n // run-rustfix\n \n #![warn(clippy::unnecessary_cast)]\n-#![allow(clippy::no_effect, clippy::unnecessary_operation, clippy::nonstandard_macro_braces)]\n+#![allow(\n+    clippy::no_effect,\n+    clippy::unnecessary_operation,\n+    clippy::nonstandard_macro_braces,\n+    clippy::borrow_as_ptr\n+)]\n \n fn main() {\n     // casting integer literal to float is unnecessary"}, {"sha": "a281143281b54fa591f29d71559da82fd7fca74f", "filename": "src/tools/clippy/tests/ui/unnecessary_cast_fixable.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_cast_fixable.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,103 +1,103 @@\n error: casting integer literal to `f32` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:8:5\n+  --> $DIR/unnecessary_cast_fixable.rs:13:5\n    |\n LL |     100 as f32;\n    |     ^^^^^^^^^^ help: try: `100_f32`\n    |\n    = note: `-D clippy::unnecessary-cast` implied by `-D warnings`\n \n error: casting integer literal to `f64` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:9:5\n+  --> $DIR/unnecessary_cast_fixable.rs:14:5\n    |\n LL |     100 as f64;\n    |     ^^^^^^^^^^ help: try: `100_f64`\n \n error: casting integer literal to `f64` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:10:5\n+  --> $DIR/unnecessary_cast_fixable.rs:15:5\n    |\n LL |     100_i32 as f64;\n    |     ^^^^^^^^^^^^^^ help: try: `100_f64`\n \n error: casting integer literal to `f32` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:11:13\n+  --> $DIR/unnecessary_cast_fixable.rs:16:13\n    |\n LL |     let _ = -100 as f32;\n    |             ^^^^^^^^^^^ help: try: `-100_f32`\n \n error: casting integer literal to `f64` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:12:13\n+  --> $DIR/unnecessary_cast_fixable.rs:17:13\n    |\n LL |     let _ = -100 as f64;\n    |             ^^^^^^^^^^^ help: try: `-100_f64`\n \n error: casting integer literal to `f64` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:13:13\n+  --> $DIR/unnecessary_cast_fixable.rs:18:13\n    |\n LL |     let _ = -100_i32 as f64;\n    |             ^^^^^^^^^^^^^^^ help: try: `-100_f64`\n \n error: casting float literal to `f32` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:14:5\n+  --> $DIR/unnecessary_cast_fixable.rs:19:5\n    |\n LL |     100. as f32;\n    |     ^^^^^^^^^^^ help: try: `100_f32`\n \n error: casting float literal to `f64` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:15:5\n+  --> $DIR/unnecessary_cast_fixable.rs:20:5\n    |\n LL |     100. as f64;\n    |     ^^^^^^^^^^^ help: try: `100_f64`\n \n error: casting integer literal to `u32` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:27:5\n+  --> $DIR/unnecessary_cast_fixable.rs:32:5\n    |\n LL |     1 as u32;\n    |     ^^^^^^^^ help: try: `1_u32`\n \n error: casting integer literal to `i32` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:28:5\n+  --> $DIR/unnecessary_cast_fixable.rs:33:5\n    |\n LL |     0x10 as i32;\n    |     ^^^^^^^^^^^ help: try: `0x10_i32`\n \n error: casting integer literal to `usize` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:29:5\n+  --> $DIR/unnecessary_cast_fixable.rs:34:5\n    |\n LL |     0b10 as usize;\n    |     ^^^^^^^^^^^^^ help: try: `0b10_usize`\n \n error: casting integer literal to `u16` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:30:5\n+  --> $DIR/unnecessary_cast_fixable.rs:35:5\n    |\n LL |     0o73 as u16;\n    |     ^^^^^^^^^^^ help: try: `0o73_u16`\n \n error: casting integer literal to `u32` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:31:5\n+  --> $DIR/unnecessary_cast_fixable.rs:36:5\n    |\n LL |     1_000_000_000 as u32;\n    |     ^^^^^^^^^^^^^^^^^^^^ help: try: `1_000_000_000_u32`\n \n error: casting float literal to `f64` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:33:5\n+  --> $DIR/unnecessary_cast_fixable.rs:38:5\n    |\n LL |     1.0 as f64;\n    |     ^^^^^^^^^^ help: try: `1.0_f64`\n \n error: casting float literal to `f32` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:34:5\n+  --> $DIR/unnecessary_cast_fixable.rs:39:5\n    |\n LL |     0.5 as f32;\n    |     ^^^^^^^^^^ help: try: `0.5_f32`\n \n error: casting integer literal to `i32` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:38:13\n+  --> $DIR/unnecessary_cast_fixable.rs:43:13\n    |\n LL |     let _ = -1 as i32;\n    |             ^^^^^^^^^ help: try: `-1_i32`\n \n error: casting float literal to `f32` is unnecessary\n-  --> $DIR/unnecessary_cast_fixable.rs:39:13\n+  --> $DIR/unnecessary_cast_fixable.rs:44:13\n    |\n LL |     let _ = -1.0 as f32;\n    |             ^^^^^^^^^^^ help: try: `-1.0_f32`"}, {"sha": "4b059558173fb783044655ef7358f968cd633d88", "filename": "src/tools/clippy/tests/ui/unused_io_amount.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_io_amount.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,6 +1,8 @@\n #![allow(dead_code)]\n #![warn(clippy::unused_io_amount)]\n \n+extern crate futures;\n+use futures::io::{AsyncRead, AsyncReadExt, AsyncWrite, AsyncWriteExt};\n use std::io::{self, Read};\n \n fn question_mark<T: io::Read + io::Write>(s: &mut T) -> io::Result<()> {\n@@ -61,4 +63,55 @@ fn combine_or(file: &str) -> Result<(), Error> {\n     Ok(())\n }\n \n+async fn bad_async_write<W: AsyncWrite + Unpin>(w: &mut W) {\n+    w.write(b\"hello world\").await.unwrap();\n+}\n+\n+async fn bad_async_read<R: AsyncRead + Unpin>(r: &mut R) {\n+    let mut buf = [0u8; 0];\n+    r.read(&mut buf[..]).await.unwrap();\n+}\n+\n+async fn io_not_ignored_async_write<W: AsyncWrite + Unpin>(mut w: W) {\n+    // Here we're forgetting to await the future, so we should get a\n+    // warning about _that_ (or we would, if it were enabled), but we\n+    // won't get one about ignoring the return value.\n+    w.write(b\"hello world\");\n+}\n+\n+fn bad_async_write_closure<W: AsyncWrite + Unpin + 'static>(w: W) -> impl futures::Future<Output = io::Result<()>> {\n+    let mut w = w;\n+    async move {\n+        w.write(b\"hello world\").await?;\n+        Ok(())\n+    }\n+}\n+\n+async fn async_read_nested_or<R: AsyncRead + Unpin>(r: &mut R, do_it: bool) -> Result<[u8; 1], Error> {\n+    let mut buf = [0u8; 1];\n+    if do_it {\n+        r.read(&mut buf[..]).await.or(Err(Error::Kind))?;\n+    }\n+    Ok(buf)\n+}\n+\n+use tokio::io::{AsyncRead as TokioAsyncRead, AsyncReadExt as _, AsyncWrite as TokioAsyncWrite, AsyncWriteExt as _};\n+\n+async fn bad_async_write_tokio<W: TokioAsyncWrite + Unpin>(w: &mut W) {\n+    w.write(b\"hello world\").await.unwrap();\n+}\n+\n+async fn bad_async_read_tokio<R: TokioAsyncRead + Unpin>(r: &mut R) {\n+    let mut buf = [0u8; 0];\n+    r.read(&mut buf[..]).await.unwrap();\n+}\n+\n+async fn undetected_bad_async_write<W: AsyncWrite + Unpin>(w: &mut W) {\n+    // It would be good to detect this case some day, but the current lint\n+    // doesn't handle it. (The documentation says that this lint \"detects\n+    // only common patterns\".)\n+    let future = w.write(b\"Hello world\");\n+    future.await.unwrap();\n+}\n+\n fn main() {}"}, {"sha": "e5bdd993aa1ad260736e52313562233762107b36", "filename": "src/tools/clippy/tests/ui/unused_io_amount.stderr", "status": "modified", "additions": 82, "deletions": 19, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_io_amount.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_io_amount.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funused_io_amount.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,68 +1,131 @@\n-error: written amount is not handled. Use `Write::write_all` instead\n-  --> $DIR/unused_io_amount.rs:7:5\n+error: written amount is not handled\n+  --> $DIR/unused_io_amount.rs:9:5\n    |\n LL |     s.write(b\"test\")?;\n    |     ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::unused-io-amount` implied by `-D warnings`\n+   = help: use `Write::write_all` instead, or handle partial writes\n \n-error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:9:5\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:11:5\n    |\n LL |     s.read(&mut buf)?;\n    |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `Read::read_exact` instead, or handle partial reads\n \n-error: written amount is not handled. Use `Write::write_all` instead\n-  --> $DIR/unused_io_amount.rs:14:5\n+error: written amount is not handled\n+  --> $DIR/unused_io_amount.rs:16:5\n    |\n LL |     s.write(b\"test\").unwrap();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `Write::write_all` instead, or handle partial writes\n \n-error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:16:5\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:18:5\n    |\n LL |     s.read(&mut buf).unwrap();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `Read::read_exact` instead, or handle partial reads\n \n error: read amount is not handled\n-  --> $DIR/unused_io_amount.rs:20:5\n+  --> $DIR/unused_io_amount.rs:22:5\n    |\n LL |     s.read_vectored(&mut [io::IoSliceMut::new(&mut [])])?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: written amount is not handled\n-  --> $DIR/unused_io_amount.rs:21:5\n+  --> $DIR/unused_io_amount.rs:23:5\n    |\n LL |     s.write_vectored(&[io::IoSlice::new(&[])])?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:28:5\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:30:5\n    |\n LL |     reader.read(&mut result).ok()?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `Read::read_exact` instead, or handle partial reads\n \n-error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:37:5\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:39:5\n    |\n LL |     reader.read(&mut result).or_else(|err| Err(err))?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `Read::read_exact` instead, or handle partial reads\n \n-error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:49:5\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:51:5\n    |\n LL |     reader.read(&mut result).or(Err(Error::Kind))?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `Read::read_exact` instead, or handle partial reads\n \n-error: read amount is not handled. Use `Read::read_exact` instead\n-  --> $DIR/unused_io_amount.rs:56:5\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:58:5\n    |\n LL | /     reader\n LL | |         .read(&mut result)\n LL | |         .or(Err(Error::Kind))\n LL | |         .or(Err(Error::Kind))\n LL | |         .expect(\"error\");\n    | |________________________^\n+   |\n+   = help: use `Read::read_exact` instead, or handle partial reads\n+\n+error: written amount is not handled\n+  --> $DIR/unused_io_amount.rs:67:5\n+   |\n+LL |     w.write(b\"hello world\").await.unwrap();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `AsyncWriteExt::write_all` instead, or handle partial writes\n+\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:72:5\n+   |\n+LL |     r.read(&mut buf[..]).await.unwrap();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `AsyncReadExt::read_exact` instead, or handle partial reads\n+\n+error: written amount is not handled\n+  --> $DIR/unused_io_amount.rs:85:9\n+   |\n+LL |         w.write(b\"hello world\").await?;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `AsyncWriteExt::write_all` instead, or handle partial writes\n+\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:93:9\n+   |\n+LL |         r.read(&mut buf[..]).await.or(Err(Error::Kind))?;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `AsyncReadExt::read_exact` instead, or handle partial reads\n+\n+error: written amount is not handled\n+  --> $DIR/unused_io_amount.rs:101:5\n+   |\n+LL |     w.write(b\"hello world\").await.unwrap();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `AsyncWriteExt::write_all` instead, or handle partial writes\n+\n+error: read amount is not handled\n+  --> $DIR/unused_io_amount.rs:106:5\n+   |\n+LL |     r.read(&mut buf[..]).await.unwrap();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `AsyncReadExt::read_exact` instead, or handle partial reads\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 16 previous errors\n "}, {"sha": "a9a4a0f5a6b5c8da75d41c3d0fe318d1cac553d0", "filename": "src/tools/clippy/tests/ui/vtable_address_comparisons.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvtable_address_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvtable_address_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvtable_address_comparisons.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -4,6 +4,8 @@ use std::rc::Rc;\n use std::sync::Arc;\n \n #[warn(clippy::vtable_address_comparisons)]\n+#[allow(clippy::borrow_as_ptr)]\n+\n fn main() {\n     let a: *const dyn Debug = &1 as &dyn Debug;\n     let b: *const dyn Debug = &1 as &dyn Debug;"}, {"sha": "2f1be61e5df72acd660326acd0d4db83deecf58d", "filename": "src/tools/clippy/tests/ui/vtable_address_comparisons.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvtable_address_comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvtable_address_comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvtable_address_comparisons.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,5 +1,5 @@\n error: comparing trait object pointers compares a non-unique vtable address\n-  --> $DIR/vtable_address_comparisons.rs:12:13\n+  --> $DIR/vtable_address_comparisons.rs:14:13\n    |\n LL |     let _ = a == b;\n    |             ^^^^^^\n@@ -8,71 +8,71 @@ LL |     let _ = a == b;\n    = help: consider extracting and comparing data pointers only\n \n error: comparing trait object pointers compares a non-unique vtable address\n-  --> $DIR/vtable_address_comparisons.rs:13:13\n+  --> $DIR/vtable_address_comparisons.rs:15:13\n    |\n LL |     let _ = a != b;\n    |             ^^^^^^\n    |\n    = help: consider extracting and comparing data pointers only\n \n error: comparing trait object pointers compares a non-unique vtable address\n-  --> $DIR/vtable_address_comparisons.rs:14:13\n+  --> $DIR/vtable_address_comparisons.rs:16:13\n    |\n LL |     let _ = a < b;\n    |             ^^^^^\n    |\n    = help: consider extracting and comparing data pointers only\n \n error: comparing trait object pointers compares a non-unique vtable address\n-  --> $DIR/vtable_address_comparisons.rs:15:13\n+  --> $DIR/vtable_address_comparisons.rs:17:13\n    |\n LL |     let _ = a <= b;\n    |             ^^^^^^\n    |\n    = help: consider extracting and comparing data pointers only\n \n error: comparing trait object pointers compares a non-unique vtable address\n-  --> $DIR/vtable_address_comparisons.rs:16:13\n+  --> $DIR/vtable_address_comparisons.rs:18:13\n    |\n LL |     let _ = a > b;\n    |             ^^^^^\n    |\n    = help: consider extracting and comparing data pointers only\n \n error: comparing trait object pointers compares a non-unique vtable address\n-  --> $DIR/vtable_address_comparisons.rs:17:13\n+  --> $DIR/vtable_address_comparisons.rs:19:13\n    |\n LL |     let _ = a >= b;\n    |             ^^^^^^\n    |\n    = help: consider extracting and comparing data pointers only\n \n error: comparing trait object pointers compares a non-unique vtable address\n-  --> $DIR/vtable_address_comparisons.rs:18:5\n+  --> $DIR/vtable_address_comparisons.rs:20:5\n    |\n LL |     ptr::eq(a, b);\n    |     ^^^^^^^^^^^^^\n    |\n    = help: consider extracting and comparing data pointers only\n \n error: comparing trait object pointers compares a non-unique vtable address\n-  --> $DIR/vtable_address_comparisons.rs:22:5\n+  --> $DIR/vtable_address_comparisons.rs:24:5\n    |\n LL |     ptr::eq(a, b);\n    |     ^^^^^^^^^^^^^\n    |\n    = help: consider extracting and comparing data pointers only\n \n error: comparing trait object pointers compares a non-unique vtable address\n-  --> $DIR/vtable_address_comparisons.rs:25:5\n+  --> $DIR/vtable_address_comparisons.rs:27:5\n    |\n LL |     Rc::ptr_eq(&a, &a);\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider extracting and comparing data pointers only\n \n error: comparing trait object pointers compares a non-unique vtable address\n-  --> $DIR/vtable_address_comparisons.rs:28:5\n+  --> $DIR/vtable_address_comparisons.rs:30:5\n    |\n LL |     Arc::ptr_eq(&a, &a);\n    |     ^^^^^^^^^^^^^^^^^^^"}, {"sha": "cb8892a3f009bdb99bbbc5c2ba6d4b3e4e02558e", "filename": "src/tools/clippy/tests/ui/while_let_on_iterator.fixed", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.fixed?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -372,6 +372,36 @@ fn exact_match_with_single_field() {\n     }\n }\n \n+fn custom_deref() {\n+    struct S1<T> {\n+        x: T,\n+    }\n+    struct S2<T>(S1<T>);\n+    impl<T> core::ops::Deref for S2<T> {\n+        type Target = S1<T>;\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    impl<T> core::ops::DerefMut for S2<T> {\n+        fn deref_mut(&mut self) -> &mut Self::Target {\n+            &mut self.0\n+        }\n+    }\n+\n+    let mut s = S2(S1 { x: 0..10 });\n+    for x in s.x.by_ref() {\n+        println!(\"{}\", x);\n+    }\n+}\n+\n+fn issue_8113() {\n+    let mut x = [0..10];\n+    for x in x[0].by_ref() {\n+        println!(\"{}\", x);\n+    }\n+}\n+\n fn main() {\n     let mut it = 0..20;\n     for _ in it {"}, {"sha": "d91571844959e1439fbc743d300fd037812c68f9", "filename": "src/tools/clippy/tests/ui/while_let_on_iterator.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -372,6 +372,36 @@ fn exact_match_with_single_field() {\n     }\n }\n \n+fn custom_deref() {\n+    struct S1<T> {\n+        x: T,\n+    }\n+    struct S2<T>(S1<T>);\n+    impl<T> core::ops::Deref for S2<T> {\n+        type Target = S1<T>;\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    impl<T> core::ops::DerefMut for S2<T> {\n+        fn deref_mut(&mut self) -> &mut Self::Target {\n+            &mut self.0\n+        }\n+    }\n+\n+    let mut s = S2(S1 { x: 0..10 });\n+    while let Some(x) = s.x.next() {\n+        println!(\"{}\", x);\n+    }\n+}\n+\n+fn issue_8113() {\n+    let mut x = [0..10];\n+    while let Some(x) = x[0].next() {\n+        println!(\"{}\", x);\n+    }\n+}\n+\n fn main() {\n     let mut it = 0..20;\n     while let Some(..) = it.next() {"}, {"sha": "fb2b0f2467c0d115924aa232f40e8d6b6706d3ef", "filename": "src/tools/clippy/tests/ui/while_let_on_iterator.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwhile_let_on_iterator.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -123,10 +123,22 @@ LL |     while let Some(x) = it.0.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in it.0.by_ref()`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:377:5\n+  --> $DIR/while_let_on_iterator.rs:393:5\n+   |\n+LL |     while let Some(x) = s.x.next() {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in s.x.by_ref()`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:400:5\n+   |\n+LL |     while let Some(x) = x[0].next() {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in x[0].by_ref()`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:407:5\n    |\n LL |     while let Some(..) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in it`\n \n-error: aborting due to 21 previous errors\n+error: aborting due to 23 previous errors\n "}, {"sha": "f8fee4b3ab2d8fb420c66ada277a88a046a4bc2d", "filename": "src/tools/clippy/tests/ui/wrong_self_convention.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -188,3 +188,24 @@ mod issue6727 {\n         }\n     }\n }\n+\n+pub mod issue8142 {\n+    struct S;\n+\n+    impl S {\n+        // Should lint: is_ methods should only take &self, or no self at all.\n+        fn is_still_buggy(&mut self) -> bool {\n+            false\n+        }\n+\n+        // Should not lint: \"no self at all\" is allowed.\n+        fn is_forty_two(x: u32) -> bool {\n+            x == 42\n+        }\n+\n+        // Should not lint: &self is allowed.\n+        fn is_test_code(&self) -> bool {\n+            true\n+        }\n+    }\n+}"}, {"sha": "5493a99572e068746d2900921ca208595e99f9ad", "filename": "src/tools/clippy/tests/ui/wrong_self_convention.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -191,5 +191,13 @@ LL |         fn to_u64(self) -> u64 {\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: aborting due to 24 previous errors\n+error: methods called `is_*` usually take `self` by reference or no `self`\n+  --> $DIR/wrong_self_convention.rs:197:27\n+   |\n+LL |         fn is_still_buggy(&mut self) -> bool {\n+   |                           ^^^^^^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n+\n+error: aborting due to 25 previous errors\n "}, {"sha": "fd9ac1fa7663b897333d1453e604e44a3143d1e7", "filename": "src/tools/clippy/tests/ui/zero_offset.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_offset.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,3 +1,4 @@\n+#[allow(clippy::borrow_as_ptr)]\n fn main() {\n     unsafe {\n         let m = &mut () as *mut ();"}, {"sha": "481a446571ab0880bece640007231774cf253cf6", "filename": "src/tools/clippy/tests/ui/zero_offset.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_offset.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_offset.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_offset.stderr?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,49 +1,49 @@\n error: offset calculation on zero-sized value\n-  --> $DIR/zero_offset.rs:4:9\n+  --> $DIR/zero_offset.rs:5:9\n    |\n LL |         m.offset(0);\n    |         ^^^^^^^^^^^\n    |\n    = note: `#[deny(clippy::zst_offset)]` on by default\n \n error: offset calculation on zero-sized value\n-  --> $DIR/zero_offset.rs:5:9\n+  --> $DIR/zero_offset.rs:6:9\n    |\n LL |         m.wrapping_add(0);\n    |         ^^^^^^^^^^^^^^^^^\n \n error: offset calculation on zero-sized value\n-  --> $DIR/zero_offset.rs:6:9\n+  --> $DIR/zero_offset.rs:7:9\n    |\n LL |         m.sub(0);\n    |         ^^^^^^^^\n \n error: offset calculation on zero-sized value\n-  --> $DIR/zero_offset.rs:7:9\n+  --> $DIR/zero_offset.rs:8:9\n    |\n LL |         m.wrapping_sub(0);\n    |         ^^^^^^^^^^^^^^^^^\n \n error: offset calculation on zero-sized value\n-  --> $DIR/zero_offset.rs:10:9\n+  --> $DIR/zero_offset.rs:11:9\n    |\n LL |         c.offset(0);\n    |         ^^^^^^^^^^^\n \n error: offset calculation on zero-sized value\n-  --> $DIR/zero_offset.rs:11:9\n+  --> $DIR/zero_offset.rs:12:9\n    |\n LL |         c.wrapping_add(0);\n    |         ^^^^^^^^^^^^^^^^^\n \n error: offset calculation on zero-sized value\n-  --> $DIR/zero_offset.rs:12:9\n+  --> $DIR/zero_offset.rs:13:9\n    |\n LL |         c.sub(0);\n    |         ^^^^^^^^\n \n error: offset calculation on zero-sized value\n-  --> $DIR/zero_offset.rs:13:9\n+  --> $DIR/zero_offset.rs:14:9\n    |\n LL |         c.wrapping_sub(0);\n    |         ^^^^^^^^^^^^^^^^^"}, {"sha": "677b4a4d569994598398bb9dc0b1a13f54ab1b4b", "filename": "src/tools/clippy/tests/workspace.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fworkspace.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -0,0 +1,107 @@\n+#![feature(once_cell)]\n+\n+use std::path::PathBuf;\n+use std::process::Command;\n+use test_utils::{CARGO_CLIPPY_PATH, IS_RUSTC_TEST_SUITE};\n+\n+mod test_utils;\n+\n+#[test]\n+fn test_no_deps_ignores_path_deps_in_workspaces() {\n+    if IS_RUSTC_TEST_SUITE {\n+        return;\n+    }\n+    let root = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n+    let target_dir = root.join(\"target\").join(\"workspace_test\");\n+    let cwd = root.join(\"tests/workspace_test\");\n+\n+    // Make sure we start with a clean state\n+    Command::new(\"cargo\")\n+        .current_dir(&cwd)\n+        .env(\"CARGO_TARGET_DIR\", &target_dir)\n+        .arg(\"clean\")\n+        .args(&[\"-p\", \"subcrate\"])\n+        .args(&[\"-p\", \"path_dep\"])\n+        .output()\n+        .unwrap();\n+\n+    // `path_dep` is a path dependency of `subcrate` that would trigger a denied lint.\n+    // Make sure that with the `--no-deps` argument Clippy does not run on `path_dep`.\n+    let output = Command::new(&*CARGO_CLIPPY_PATH)\n+        .current_dir(&cwd)\n+        .env(\"CARGO_INCREMENTAL\", \"0\")\n+        .env(\"CARGO_TARGET_DIR\", &target_dir)\n+        .arg(\"clippy\")\n+        .args(&[\"-p\", \"subcrate\"])\n+        .arg(\"--no-deps\")\n+        .arg(\"--\")\n+        .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n+        .args(&[\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n+        .output()\n+        .unwrap();\n+    println!(\"status: {}\", output.status);\n+    println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n+    println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n+\n+    assert!(output.status.success());\n+\n+    let lint_path_dep = || {\n+        // Test that without the `--no-deps` argument, `path_dep` is linted.\n+        let output = Command::new(&*CARGO_CLIPPY_PATH)\n+            .current_dir(&cwd)\n+            .env(\"CARGO_INCREMENTAL\", \"0\")\n+            .env(\"CARGO_TARGET_DIR\", &target_dir)\n+            .arg(\"clippy\")\n+            .args(&[\"-p\", \"subcrate\"])\n+            .arg(\"--\")\n+            .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n+            .args(&[\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n+            .output()\n+            .unwrap();\n+        println!(\"status: {}\", output.status);\n+        println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n+        println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n+\n+        assert!(!output.status.success());\n+        assert!(\n+            String::from_utf8(output.stderr)\n+                .unwrap()\n+                .contains(\"error: empty `loop {}` wastes CPU cycles\")\n+        );\n+    };\n+\n+    // Make sure Cargo is aware of the removal of `--no-deps`.\n+    lint_path_dep();\n+\n+    let successful_build = || {\n+        let output = Command::new(&*CARGO_CLIPPY_PATH)\n+            .current_dir(&cwd)\n+            .env(\"CARGO_INCREMENTAL\", \"0\")\n+            .env(\"CARGO_TARGET_DIR\", &target_dir)\n+            .arg(\"clippy\")\n+            .args(&[\"-p\", \"subcrate\"])\n+            .arg(\"--\")\n+            .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n+            .output()\n+            .unwrap();\n+        println!(\"status: {}\", output.status);\n+        println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n+        println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n+\n+        assert!(output.status.success());\n+\n+        output\n+    };\n+\n+    // Trigger a sucessful build, so Cargo would like to cache the build result.\n+    successful_build();\n+\n+    // Make sure there's no spurious rebuild when nothing changes.\n+    let stderr = String::from_utf8(successful_build().stderr).unwrap();\n+    assert!(!stderr.contains(\"Compiling\"));\n+    assert!(!stderr.contains(\"Checking\"));\n+    assert!(stderr.contains(\"Finished\"));\n+\n+    // Make sure Cargo is aware of the new `--cfg` flag.\n+    lint_path_dep();\n+}"}, {"sha": "bf5b4ca5288a4193f3934a02207c5813dee2b4b4", "filename": "src/tools/clippy/tests/workspace_test/Cargo.toml", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2FCargo.toml?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "patch": "@@ -1,5 +1,5 @@\n [package]\n-name = \"clippy_workspace_tests\"\n+name = \"workspace_test\"\n version = \"0.1.0\"\n edition = \"2018\"\n ", "previous_filename": "src/tools/clippy/clippy_workspace_tests/Cargo.toml"}, {"sha": "3507168a3a96452abe013ab42094028e10d8db6a", "filename": "src/tools/clippy/tests/workspace_test/build.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fbuild.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "previous_filename": "src/tools/clippy/clippy_workspace_tests/build.rs"}, {"sha": "85a91cd2decd59ffdad366977375be13f2fe52a5", "filename": "src/tools/clippy/tests/workspace_test/path_dep/Cargo.toml", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fpath_dep%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fpath_dep%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fpath_dep%2FCargo.toml?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "previous_filename": "src/tools/clippy/clippy_workspace_tests/path_dep/Cargo.toml"}, {"sha": "35ce524f2b10c367c0b3d71e4449f05458542261", "filename": "src/tools/clippy/tests/workspace_test/path_dep/src/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fpath_dep%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fpath_dep%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fpath_dep%2Fsrc%2Flib.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "previous_filename": "src/tools/clippy/clippy_workspace_tests/path_dep/src/lib.rs"}, {"sha": "b322eca1db51d2cf71da534d254f47be4213c6d1", "filename": "src/tools/clippy/tests/workspace_test/src/main.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fsrc%2Fmain.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "previous_filename": "src/tools/clippy/clippy_workspace_tests/src/main.rs"}, {"sha": "45362c11b856e3615cfa77348c12b251d127526b", "filename": "src/tools/clippy/tests/workspace_test/subcrate/Cargo.toml", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fsubcrate%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fsubcrate%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fsubcrate%2FCargo.toml?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "previous_filename": "src/tools/clippy/clippy_workspace_tests/subcrate/Cargo.toml"}, {"sha": "8b137891791fe96927ad78e64b0aad7bded08bdc", "filename": "src/tools/clippy/tests/workspace_test/subcrate/src/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fsubcrate%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad46af24713115e7b9b258346e66b9b2d14eacfc/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fsubcrate%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fworkspace_test%2Fsubcrate%2Fsrc%2Flib.rs?ref=ad46af24713115e7b9b258346e66b9b2d14eacfc", "previous_filename": "src/tools/clippy/clippy_workspace_tests/subcrate/src/lib.rs"}]}