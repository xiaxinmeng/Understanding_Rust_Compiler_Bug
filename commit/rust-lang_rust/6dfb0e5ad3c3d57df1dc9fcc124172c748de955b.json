{"sha": "6dfb0e5ad3c3d57df1dc9fcc124172c748de955b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkZmIwZTVhZDNjM2Q1N2RmMWRjOWZjYzEyNDE3MmM3NDhkZTk1NWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-23T02:13:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-23T02:13:39Z"}, "message": "auto merge of #7703 : sfackler/rust/bitv, r=alexcrichton\n\nSwitched Bitv and BitvSet to external iterators. They still use some internal iterators internally (ha).\r\n\r\nDerived clone for all Bitv types.\r\n\r\nRemoved indirection in BitvVariant. It previously held a unique pointer to the appropriate Bitv struct, even though those structs are the size of a pointer themselves. BitvVariant is the same size (16 bytes) as it was previously.", "tree": {"sha": "ef011d6bdd88f1370f5284cf83951726853a60da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef011d6bdd88f1370f5284cf83951726853a60da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dfb0e5ad3c3d57df1dc9fcc124172c748de955b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dfb0e5ad3c3d57df1dc9fcc124172c748de955b", "html_url": "https://github.com/rust-lang/rust/commit/6dfb0e5ad3c3d57df1dc9fcc124172c748de955b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dfb0e5ad3c3d57df1dc9fcc124172c748de955b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff34064aa3b49eb649d411b733201c512e9c5eed", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff34064aa3b49eb649d411b733201c512e9c5eed", "html_url": "https://github.com/rust-lang/rust/commit/ff34064aa3b49eb649d411b733201c512e9c5eed"}, {"sha": "fd757a8ab0f6bc84227d1ac7a83c55e09ea9dbcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd757a8ab0f6bc84227d1ac7a83c55e09ea9dbcf", "html_url": "https://github.com/rust-lang/rust/commit/fd757a8ab0f6bc84227d1ac7a83c55e09ea9dbcf"}], "stats": {"total": 200, "additions": 149, "deletions": 51}, "files": [{"sha": "168d6a3991674e91a14849d75875ae6a61db0520", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 149, "deletions": 51, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/6dfb0e5ad3c3d57df1dc9fcc124172c748de955b/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfb0e5ad3c3d57df1dc9fcc124172c748de955b/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=6dfb0e5ad3c3d57df1dc9fcc124172c748de955b", "patch": "@@ -17,6 +17,7 @@ use std::ops;\n use std::uint;\n use std::vec;\n \n+#[deriving(Clone)]\n struct SmallBitv {\n     /// only the lowest nbits of this value are used. the rest is undefined.\n     bits: uint\n@@ -107,6 +108,7 @@ impl SmallBitv {\n     pub fn negate(&mut self) { self.bits = !self.bits; }\n }\n \n+#[deriving(Clone)]\n struct BigBitv {\n     storage: ~[uint]\n }\n@@ -212,11 +214,13 @@ impl BigBitv {\n     }\n }\n \n-enum BitvVariant { Big(~BigBitv), Small(~SmallBitv) }\n+#[deriving(Clone)]\n+enum BitvVariant { Big(BigBitv), Small(SmallBitv) }\n \n enum Op {Union, Intersect, Assign, Difference}\n \n /// The bitvector type\n+#[deriving(Clone)]\n pub struct Bitv {\n     /// Internal representation of the bit vector (small or large)\n     rep: BitvVariant,\n@@ -237,20 +241,20 @@ impl Bitv {\n         match self.rep {\n           Small(ref mut s) => match other.rep {\n             Small(ref s1) => match op {\n-              Union      => s.union(*s1,      self.nbits),\n-              Intersect  => s.intersect(*s1,  self.nbits),\n-              Assign     => s.become(*s1,     self.nbits),\n-              Difference => s.difference(*s1, self.nbits)\n+              Union      => s.union(s1,      self.nbits),\n+              Intersect  => s.intersect(s1,  self.nbits),\n+              Assign     => s.become(s1,     self.nbits),\n+              Difference => s.difference(s1, self.nbits)\n             },\n             Big(_) => die()\n           },\n           Big(ref mut s) => match other.rep {\n             Small(_) => die(),\n             Big(ref s1) => match op {\n-              Union      => s.union(*s1,      self.nbits),\n-              Intersect  => s.intersect(*s1,  self.nbits),\n-              Assign     => s.become(*s1,     self.nbits),\n-              Difference => s.difference(*s1, self.nbits)\n+              Union      => s.union(s1,      self.nbits),\n+              Intersect  => s.intersect(s1,  self.nbits),\n+              Assign     => s.become(s1,     self.nbits),\n+              Difference => s.difference(s1, self.nbits)\n             }\n           }\n         }\n@@ -261,14 +265,14 @@ impl Bitv {\n impl Bitv {\n     pub fn new(nbits: uint, init: bool) -> Bitv {\n         let rep = if nbits <= uint::bits {\n-            Small(~SmallBitv::new(if init {!0} else {0}))\n+            Small(SmallBitv::new(if init {!0} else {0}))\n         }\n         else {\n             let nelems = nbits/uint::bits +\n                          if nbits % uint::bits == 0 {0} else {1};\n             let elem = if init {!0u} else {0u};\n             let s = vec::from_elem(nelems, elem);\n-            Big(~BigBitv::new(s))\n+            Big(BigBitv::new(s))\n         };\n         Bitv {rep: rep, nbits: nbits}\n     }\n@@ -337,11 +341,11 @@ impl Bitv {\n       if self.nbits != v1.nbits { return false; }\n       match self.rep {\n         Small(ref b) => match v1.rep {\n-          Small(ref b1) => b.equals(*b1, self.nbits),\n+          Small(ref b1) => b.equals(b1, self.nbits),\n           _ => false\n         },\n         Big(ref s) => match v1.rep {\n-          Big(ref s1) => s.equals(*s1, self.nbits),\n+          Big(ref s1) => s.equals(s1, self.nbits),\n           Small(_) => return false\n         }\n       }\n@@ -392,28 +396,23 @@ impl Bitv {\n       match self.rep {\n         Small(ref b) => b.is_true(self.nbits),\n         _ => {\n-          for self.each() |i| { if !i { return false; } }\n+          for self.iter().advance |i| { if !i { return false; } }\n           true\n         }\n       }\n     }\n \n     #[inline]\n-    pub fn each(&self, f: &fn(bool) -> bool) -> bool {\n-        let mut i = 0;\n-        while i < self.nbits {\n-            if !f(self.get(i)) { return false; }\n-            i += 1;\n-        }\n-        return true;\n+    pub fn iter<'a>(&'a self) -> BitvIterator<'a> {\n+        BitvIterator {bitv: self, next_idx: 0}\n     }\n \n     /// Returns true if all bits are 0\n     pub fn is_false(&self) -> bool {\n       match self.rep {\n         Small(ref b) => b.is_false(self.nbits),\n         Big(_) => {\n-          for self.each() |i| { if i { return false; } }\n+          for self.iter().advance |i| { if i { return false; } }\n           true\n         }\n       }\n@@ -477,7 +476,7 @@ impl Bitv {\n      */\n      pub fn to_str(&self) -> ~str {\n         let mut rs = ~\"\";\n-        for self.each() |i| {\n+        for self.iter().advance |i| {\n             if i {\n                 rs.push_char('1');\n             } else {\n@@ -509,24 +508,6 @@ impl Bitv {\n \n }\n \n-impl Clone for Bitv {\n-    /// Makes a copy of a bitvector\n-    #[inline]\n-    fn clone(&self) -> Bitv {\n-        match self.rep {\n-          Small(ref b) => {\n-            Bitv{nbits: self.nbits, rep: Small(~SmallBitv{bits: b.bits})}\n-          }\n-          Big(ref b) => {\n-            let mut st = vec::from_elem(self.nbits / uint::bits + 1, 0u);\n-            let len = st.len();\n-            for uint::range(0, len) |i| { st[i] = b.storage[i]; };\n-            Bitv{nbits: self.nbits, rep: Big(~BigBitv{storage: st})}\n-          }\n-        }\n-    }\n-}\n-\n /**\n  * Transform a byte-vector into a bitv. Each byte becomes 8 bits,\n  * with the most significant bits of each byte coming first. Each\n@@ -580,12 +561,37 @@ fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n     return true;\n }\n \n+/// An iterator for Bitv\n+pub struct BitvIterator<'self> {\n+    priv bitv: &'self Bitv,\n+    priv next_idx: uint\n+}\n+\n+impl<'self> Iterator<bool> for BitvIterator<'self> {\n+    #[inline]\n+    fn next(&mut self) -> Option<bool> {\n+        if self.next_idx < self.bitv.nbits {\n+            let idx = self.next_idx;\n+            self.next_idx += 1;\n+            Some(self.bitv.get(idx))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let rem = self.bitv.nbits - self.next_idx;\n+        (rem, Some(rem))\n+    }\n+}\n+\n /// An implementation of a set using a bit vector as an underlying\n /// representation for holding numerical elements.\n ///\n /// It should also be noted that the amount of storage necessary for holding a\n /// set of objects is proportional to the maximum of the objects when viewed\n /// as a uint.\n+#[deriving(Clone)]\n pub struct BitvSet {\n     priv size: uint,\n \n@@ -609,8 +615,8 @@ impl BitvSet {\n         }\n         let Bitv{rep, _} = bitv;\n         match rep {\n-            Big(~b) => BitvSet{ size: size, bitv: b },\n-            Small(~SmallBitv{bits}) =>\n+            Big(b) => BitvSet{ size: size, bitv: b },\n+            Small(SmallBitv{bits}) =>\n                 BitvSet{ size: size, bitv: BigBitv{ storage: ~[bits] } },\n         }\n     }\n@@ -623,7 +629,7 @@ impl BitvSet {\n     pub fn unwrap(self) -> Bitv {\n         let cap = self.capacity();\n         let BitvSet{bitv, _} = self;\n-        return Bitv{ nbits:cap, rep: Big(~bitv) };\n+        return Bitv{ nbits:cap, rep: Big(bitv) };\n     }\n \n     #[inline]\n@@ -670,13 +676,8 @@ impl BitvSet {\n         self.other_op(other, |w1, w2| w1 ^ w2);\n     }\n \n-    pub fn each(&self, blk: &fn(v: &uint) -> bool) -> bool {\n-        for self.bitv.storage.iter().enumerate().advance |(i, &w)| {\n-            if !iterate_bits(i * uint::bits, w, |b| blk(&b)) {\n-                return false;\n-            }\n-        }\n-        return true;\n+    pub fn iter<'a>(&'a self) -> BitvSetIterator<'a> {\n+        BitvSetIterator {set: self, next_idx: 0}\n     }\n }\n \n@@ -860,6 +861,31 @@ impl BitvSet {\n     }\n }\n \n+pub struct BitvSetIterator<'self> {\n+    priv set: &'self BitvSet,\n+    priv next_idx: uint\n+}\n+\n+impl<'self> Iterator<uint> for BitvSetIterator<'self> {\n+    #[inline]\n+    fn next(&mut self) -> Option<uint> {\n+        while self.next_idx < self.set.capacity() {\n+            let idx = self.next_idx;\n+            self.next_idx += 1;\n+\n+            if self.set.contains(&idx) {\n+                return Some(idx);\n+            }\n+        }\n+\n+        return None;\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (0, Some(self.set.capacity() - self.next_idx))\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use extra::test::BenchHarness;\n@@ -1241,6 +1267,25 @@ mod tests {\n         assert_eq!(from_bytes([0b00100110]).to_bools(), bools);\n     }\n \n+    #[test]\n+    fn test_bitv_iterator() {\n+        let bools = [true, false, true, true];\n+        let bitv = from_bools(bools);\n+\n+        for bitv.iter().zip(bools.iter()).advance |(act, &ex)| {\n+            assert_eq!(ex, act);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_iterator() {\n+        let bools = [true, false, true, true];\n+        let bitv = BitvSet::from_bitv(from_bools(bools));\n+\n+        let idxs: ~[uint] = bitv.iter().collect();\n+        assert_eq!(idxs, ~[0, 2, 3]);\n+    }\n+\n     #[test]\n     fn test_small_difference() {\n         let mut b1 = Bitv::new(3, false);\n@@ -1417,6 +1462,25 @@ mod tests {\n         assert_eq!(a.capacity(), uint::bits);\n     }\n \n+    #[test]\n+    fn test_bitv_clone() {\n+        let mut a = BitvSet::new();\n+\n+        assert!(a.insert(1));\n+        assert!(a.insert(100));\n+        assert!(a.insert(1000));\n+\n+        let mut b = a.clone();\n+\n+        assert_eq!(&a, &b);\n+\n+        assert!(b.remove(&1));\n+        assert!(a.contains(&1));\n+\n+        assert!(a.remove(&1000));\n+        assert!(b.contains(&1000));\n+    }\n+\n     fn rng() -> rand::IsaacRng {\n         let seed = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n         rand::IsaacRng::new_seeded(seed)\n@@ -1504,4 +1568,38 @@ mod tests {\n             b1.union(&b2);\n         }\n     }\n+\n+    #[bench]\n+    fn bench_btv_small_iter(b: &mut BenchHarness) {\n+        let bitv = Bitv::new(uint::bits, false);\n+        do b.iter {\n+            let mut sum = 0;\n+            for bitv.iter().advance |pres| {\n+                sum += pres as uint;\n+            }\n+        }\n+    }\n+\n+    #[bench]\n+    fn bench_bitv_big_iter(b: &mut BenchHarness) {\n+        let bitv = Bitv::new(BENCH_BITS, false);\n+        do b.iter {\n+            let mut sum = 0;\n+            for bitv.iter().advance |pres| {\n+                sum += pres as uint;\n+            }\n+        }\n+    }\n+\n+    #[bench]\n+    fn bench_bitvset_iter(b: &mut BenchHarness) {\n+        let bitv = BitvSet::from_bitv(from_fn(BENCH_BITS,\n+                                              |idx| {idx % 3 == 0}));\n+        do b.iter {\n+            let mut sum = 0;\n+            for bitv.iter().advance |idx| {\n+                sum += idx;\n+            }\n+        }\n+    }\n }"}]}