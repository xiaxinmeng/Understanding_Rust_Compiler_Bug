{"sha": "1939b76903eb8a4aa02dadc52353541637e3b98c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MzliNzY5MDNlYjhhNGFhMDJkYWRjNTIzNTM1NDE2MzdlM2I5OGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-10T06:50:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-10T06:50:10Z"}, "message": "Auto merge of #33473 - michaelwoerister:split-cratecontext, r=nikomatsakis\n\nPreparatory refactorings for collector-driven trans.\n\nThis is a set of refactorings that allows to do translation item collection and partitioning before LocalCrateContext instances or LLVM modules are generated. As a consequence we can now create LocalCrateContexts already with knowledge of the codegen unit it will be used for. This is a preparation step for driving trans by the results of codegen unit partitioning.", "tree": {"sha": "6615e19eead271fd8ac35916327ba49dc62578ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6615e19eead271fd8ac35916327ba49dc62578ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1939b76903eb8a4aa02dadc52353541637e3b98c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1939b76903eb8a4aa02dadc52353541637e3b98c", "html_url": "https://github.com/rust-lang/rust/commit/1939b76903eb8a4aa02dadc52353541637e3b98c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1939b76903eb8a4aa02dadc52353541637e3b98c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4d2424cc304e97f553c6d8eef17a24dc2f12c01", "html_url": "https://github.com/rust-lang/rust/commit/a4d2424cc304e97f553c6d8eef17a24dc2f12c01"}, {"sha": "118cc9e8e1fd72ea59c44c99a3ef3cc8abf9bbaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/118cc9e8e1fd72ea59c44c99a3ef3cc8abf9bbaf", "html_url": "https://github.com/rust-lang/rust/commit/118cc9e8e1fd72ea59c44c99a3ef3cc8abf9bbaf"}], "stats": {"total": 1036, "additions": 541, "deletions": 495}, "files": [{"sha": "cf81777be261d4895af8c5c4841bb7d3c7f686d8", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=1939b76903eb8a4aa02dadc52353541637e3b98c", "patch": "@@ -639,7 +639,8 @@ pub fn run_passes(sess: &Session,\n     }\n \n     // Sanity check\n-    assert!(trans.modules.len() == sess.opts.cg.codegen_units);\n+    assert!(trans.modules.len() == sess.opts.cg.codegen_units ||\n+            sess.opts.debugging_opts.incremental.is_some());\n \n     let tm = create_target_machine(sess);\n "}, {"sha": "191b14f8a4139a21db5413f8fe03ff9af38b8781", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 49, "deletions": 42, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=1939b76903eb8a4aa02dadc52353541637e3b98c", "patch": "@@ -68,7 +68,7 @@ use common::{node_id_type, fulfill_obligation};\n use common::{type_is_immediate, type_is_zero_size, val_ty};\n use common;\n use consts;\n-use context::SharedCrateContext;\n+use context::{SharedCrateContext, CrateContextList};\n use controlflow;\n use datum;\n use debuginfo::{self, DebugLoc, ToDebugLoc};\n@@ -81,7 +81,7 @@ use machine::{llalign_of_min, llsize_of, llsize_of_real};\n use meth;\n use mir;\n use monomorphize::{self, Instance};\n-use partitioning::{self, PartitioningStrategy, InstantiationMode};\n+use partitioning::{self, PartitioningStrategy, InstantiationMode, CodegenUnit};\n use symbol_names_test;\n use tvec;\n use type_::Type;\n@@ -664,7 +664,7 @@ pub fn coerce_unsized_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn custom_coerce_unsize_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n+pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx>,\n                                              source_ty: Ty<'tcx>,\n                                              target_ty: Ty<'tcx>)\n                                              -> CustomCoerceUnsized {\n@@ -674,13 +674,13 @@ pub fn custom_coerce_unsize_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                                    subst::VecPerParamSpace::empty());\n \n     let trait_ref = ty::Binder(ty::TraitRef {\n-        def_id: ccx.tcx().lang_items.coerce_unsized_trait().unwrap(),\n-        substs: ccx.tcx().mk_substs(trait_substs)\n+        def_id: scx.tcx().lang_items.coerce_unsized_trait().unwrap(),\n+        substs: scx.tcx().mk_substs(trait_substs)\n     });\n \n-    match fulfill_obligation(ccx, DUMMY_SP, trait_ref) {\n+    match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n         traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n-            ccx.tcx().custom_coerce_unsized_kind(impl_def_id)\n+            scx.tcx().custom_coerce_unsized_kind(impl_def_id)\n         }\n         vtable => {\n             bug!(\"invalid CoerceUnsized vtable: {:?}\", vtable);\n@@ -1824,7 +1824,7 @@ pub fn trans_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                closure_env: closure::ClosureEnv) {\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n-    if collector::collecting_debug_information(ccx) {\n+    if collector::collecting_debug_information(ccx.shared()) {\n         ccx.record_translation_item_as_generated(TransItem::Fn(instance));\n     }\n \n@@ -2188,7 +2188,8 @@ pub fn update_linkage(ccx: &CrateContext,\n             // `llval` is a translation of an item defined in a separate\n             // compilation unit.  This only makes sense if there are at least\n             // two compilation units.\n-            assert!(ccx.sess().opts.cg.codegen_units > 1);\n+            assert!(ccx.sess().opts.cg.codegen_units > 1 ||\n+                    ccx.sess().opts.debugging_opts.incremental.is_some());\n             // `llval` is a copy of something defined elsewhere, so use\n             // `AvailableExternallyLinkage` to avoid duplicating code in the\n             // output.\n@@ -2524,7 +2525,7 @@ pub fn write_metadata<'a, 'tcx>(cx: &SharedCrateContext<'a, 'tcx>,\n \n /// Find any symbols that are defined in one compilation unit, but not declared\n /// in any other compilation unit.  Give these symbols internal linkage.\n-fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<&str>) {\n+fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n     unsafe {\n         let mut declared = HashSet::new();\n \n@@ -2579,12 +2580,12 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<&str>) {\n // when using MSVC linker.  We do this only for data, as linker can fix up\n // code references on its own.\n // See #26591, #27438\n-fn create_imps(cx: &SharedCrateContext) {\n+fn create_imps(cx: &CrateContextList) {\n     // The x86 ABI seems to require that leading underscores are added to symbol\n     // names, so we need an extra underscore on 32-bit. There's also a leading\n     // '\\x01' here which disables LLVM's symbol mangling (e.g. no extra\n     // underscores added in front).\n-    let prefix = if cx.sess().target.target.target_pointer_width == \"32\" {\n+    let prefix = if cx.shared().sess().target.target.target_pointer_width == \"32\" {\n         \"\\x01__imp__\"\n     } else {\n         \"\\x01__imp_\"\n@@ -2661,10 +2662,10 @@ fn iter_functions(llmod: llvm::ModuleRef) -> ValueIter {\n ///\n /// This list is later used by linkers to determine the set of symbols needed to\n /// be exposed from a dynamic library and it's also encoded into the metadata.\n-pub fn filter_reachable_ids(ccx: &SharedCrateContext) -> NodeSet {\n-    ccx.reachable().iter().map(|x| *x).filter(|id| {\n+pub fn filter_reachable_ids(scx: &SharedCrateContext) -> NodeSet {\n+    scx.reachable().iter().map(|x| *x).filter(|id| {\n         // First, only worry about nodes which have a symbol name\n-        ccx.item_symbols().borrow().contains_key(id)\n+        scx.item_symbols().borrow().contains_key(id)\n     }).filter(|&id| {\n         // Next, we want to ignore some FFI functions that are not exposed from\n         // this crate. Reachable FFI functions can be lumped into two\n@@ -2679,9 +2680,9 @@ pub fn filter_reachable_ids(ccx: &SharedCrateContext) -> NodeSet {\n         //\n         // As a result, if this id is an FFI item (foreign item) then we only\n         // let it through if it's included statically.\n-        match ccx.tcx().map.get(id) {\n+        match scx.tcx().map.get(id) {\n             hir_map::NodeForeignItem(..) => {\n-                ccx.sess().cstore.is_statically_included_foreign_item(id)\n+                scx.sess().cstore.is_statically_included_foreign_item(id)\n             }\n             _ => true,\n         }\n@@ -2716,10 +2717,7 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n \n     let link_meta = link::build_link_meta(&tcx, name);\n \n-    let codegen_units = tcx.sess.opts.cg.codegen_units;\n-    let shared_ccx = SharedCrateContext::new(&link_meta.crate_name,\n-                                             codegen_units,\n-                                             tcx,\n+    let shared_ccx = SharedCrateContext::new(tcx,\n                                              &mir_map,\n                                              export_map,\n                                              Sha256::new(),\n@@ -2728,9 +2726,15 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n                                              check_overflow,\n                                              check_dropflag);\n \n+    let codegen_units = collect_and_partition_translation_items(&shared_ccx);\n+    let codegen_unit_count = codegen_units.len();\n+    assert!(tcx.sess.opts.cg.codegen_units == codegen_unit_count ||\n+            tcx.sess.opts.debugging_opts.incremental.is_some());\n+\n+    let crate_context_list = CrateContextList::new(&shared_ccx, codegen_units);\n+\n     {\n-        let ccx = shared_ccx.get_ccx(0);\n-        collect_translation_items(&ccx);\n+        let ccx = crate_context_list.get_ccx(0);\n \n         // Translate all items. See `TransModVisitor` for\n         // details on why we walk in this particular way.\n@@ -2740,12 +2744,12 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n             krate.visit_all_items(&mut TransModVisitor { ccx: &ccx });\n         }\n \n-        collector::print_collection_results(&ccx);\n+        collector::print_collection_results(ccx.shared());\n \n         symbol_names_test::report_symbol_names(&ccx);\n     }\n \n-    for ccx in shared_ccx.iter() {\n+    for ccx in crate_context_list.iter() {\n         if ccx.sess().opts.debuginfo != NoDebugInfo {\n             debuginfo::finalize(&ccx);\n         }\n@@ -2794,7 +2798,7 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n     }\n \n-    let modules = shared_ccx.iter()\n+    let modules = crate_context_list.iter()\n         .map(|ccx| ModuleTranslation { llcx: ccx.llcx(), llmod: ccx.llmod() })\n         .collect();\n \n@@ -2820,14 +2824,14 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n     }\n \n-    if codegen_units > 1 {\n-        internalize_symbols(&shared_ccx,\n+    if codegen_unit_count > 1 {\n+        internalize_symbols(&crate_context_list,\n                             &reachable_symbols.iter().map(|x| &x[..]).collect());\n     }\n \n     if sess.target.target.options.is_like_msvc &&\n        sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n-        create_imps(&shared_ccx);\n+        create_imps(&crate_context_list);\n     }\n \n     let metadata_module = ModuleTranslation {\n@@ -2912,10 +2916,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TransItemsWithinModVisitor<'a, 'tcx> {\n     }\n }\n \n-fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n-    let time_passes = ccx.sess().time_passes();\n+fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n+                                                     -> Vec<CodegenUnit<'tcx>> {\n+    let time_passes = scx.sess().time_passes();\n \n-    let collection_mode = match ccx.sess().opts.debugging_opts.print_trans_items {\n+    let collection_mode = match scx.sess().opts.debugging_opts.print_trans_items {\n         Some(ref s) => {\n             let mode_string = s.to_lowercase();\n             let mode_string = mode_string.trim();\n@@ -2926,7 +2931,7 @@ fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n                     let message = format!(\"Unknown codegen-item collection mode '{}'. \\\n                                            Falling back to 'lazy' mode.\",\n                                            mode_string);\n-                    ccx.sess().warn(&message);\n+                    scx.sess().warn(&message);\n                 }\n \n                 TransItemCollectionMode::Lazy\n@@ -2936,27 +2941,27 @@ fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n     };\n \n     let (items, reference_map) = time(time_passes, \"translation item collection\", || {\n-        collector::collect_crate_translation_items(&ccx, collection_mode)\n+        collector::collect_crate_translation_items(scx, collection_mode)\n     });\n \n-    let strategy = if ccx.sess().opts.debugging_opts.incremental.is_some() {\n+    let strategy = if scx.sess().opts.debugging_opts.incremental.is_some() {\n         PartitioningStrategy::PerModule\n     } else {\n-        PartitioningStrategy::FixedUnitCount(ccx.sess().opts.cg.codegen_units)\n+        PartitioningStrategy::FixedUnitCount(scx.sess().opts.cg.codegen_units)\n     };\n \n     let codegen_units = time(time_passes, \"codegen unit partitioning\", || {\n-        partitioning::partition(ccx.tcx(),\n+        partitioning::partition(scx.tcx(),\n                                 items.iter().cloned(),\n                                 strategy,\n                                 &reference_map)\n     });\n \n-    if ccx.sess().opts.debugging_opts.print_trans_items.is_some() {\n+    if scx.sess().opts.debugging_opts.print_trans_items.is_some() {\n         let mut item_to_cgus = HashMap::new();\n \n-        for cgu in codegen_units {\n-            for (trans_item, linkage) in cgu.items {\n+        for cgu in &codegen_units {\n+            for (&trans_item, &linkage) in &cgu.items {\n                 item_to_cgus.entry(trans_item)\n                             .or_insert(Vec::new())\n                             .push((cgu.name.clone(), linkage));\n@@ -2966,7 +2971,7 @@ fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n         let mut item_keys: Vec<_> = items\n             .iter()\n             .map(|i| {\n-                let mut output = i.to_string(ccx);\n+                let mut output = i.to_string(scx.tcx());\n                 output.push_str(\" @@\");\n                 let mut empty = Vec::new();\n                 let mut cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n@@ -3005,10 +3010,12 @@ fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n             println!(\"TRANS_ITEM {}\", item);\n         }\n \n-        let mut ccx_map = ccx.translation_items().borrow_mut();\n+        let mut ccx_map = scx.translation_items().borrow_mut();\n \n         for cgi in items {\n             ccx_map.insert(cgi, TransItemState::PredictedButNotGenerated);\n         }\n     }\n+\n+    codegen_units\n }"}, {"sha": "db605e4dc5d68af8a948bf01e12bdf1d94889276", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=1939b76903eb8a4aa02dadc52353541637e3b98c", "patch": "@@ -156,7 +156,7 @@ impl<'tcx> Callee<'tcx> {\n         let trait_id = method_item.container().id();\n         let trait_ref = ty::Binder(substs.to_trait_ref(tcx, trait_id));\n         let trait_ref = infer::normalize_associated_type(tcx, &trait_ref);\n-        match common::fulfill_obligation(ccx, DUMMY_SP, trait_ref) {\n+        match common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref) {\n             traits::VtableImpl(vtable_impl) => {\n                 let impl_did = vtable_impl.impl_def_id;\n                 let mname = tcx.item_name(def_id);"}, {"sha": "ba924d6ae3ef621a09c0e1cab8c43f4e0a1b4fb0", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 198, "deletions": 202, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=1939b76903eb8a4aa02dadc52353541637e3b98c", "patch": "@@ -210,9 +210,8 @@ use syntax::{attr, errors};\n use syntax::parse::token;\n \n use base::{custom_coerce_unsize_info, llvm_linkage_by_name};\n-use context::CrateContext;\n-use common::{fulfill_obligation, normalize_and_test_predicates,\n-                    type_is_sized};\n+use context::SharedCrateContext;\n+use common::{fulfill_obligation, normalize_and_test_predicates, type_is_sized};\n use glue::{self, DropGlueKind};\n use llvm;\n use meth;\n@@ -320,22 +319,22 @@ impl<'tcx> ReferenceMap<'tcx> {\n     }\n }\n \n-pub fn collect_crate_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                  mode: TransItemCollectionMode)\n                                                  -> (FnvHashSet<TransItem<'tcx>>,\n                                                      ReferenceMap<'tcx>) {\n     // We are not tracking dependencies of this pass as it has to be re-executed\n     // every time no matter what.\n-    ccx.tcx().dep_graph.with_ignore(|| {\n-        let roots = collect_roots(ccx, mode);\n+    scx.tcx().dep_graph.with_ignore(|| {\n+        let roots = collect_roots(scx, mode);\n \n         debug!(\"Building translation item graph, beginning at roots\");\n         let mut visited = FnvHashSet();\n         let mut recursion_depths = DefIdMap();\n         let mut reference_map = ReferenceMap::new();\n \n         for root in roots {\n-            collect_items_rec(ccx,\n+            collect_items_rec(scx,\n                               root,\n                               &mut visited,\n                               &mut recursion_depths,\n@@ -348,28 +347,28 @@ pub fn collect_crate_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n // Find all non-generic items by walking the HIR. These items serve as roots to\n // start monomorphizing from.\n-fn collect_roots<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn collect_roots<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                            mode: TransItemCollectionMode)\n                            -> Vec<TransItem<'tcx>> {\n     debug!(\"Collecting roots\");\n     let mut roots = Vec::new();\n \n     {\n         let mut visitor = RootCollector {\n-            ccx: ccx,\n+            scx: scx,\n             mode: mode,\n             output: &mut roots,\n             enclosing_item: None,\n         };\n \n-        ccx.tcx().map.krate().visit_all_items(&mut visitor);\n+        scx.tcx().map.krate().visit_all_items(&mut visitor);\n     }\n \n     roots\n }\n \n // Collect all monomorphized translation items reachable from `starting_point`\n-fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n+fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n                                    starting_point: TransItem<'tcx>,\n                                    visited: &mut FnvHashSet<TransItem<'tcx>>,\n                                    recursion_depths: &mut DefIdMap<usize>,\n@@ -378,36 +377,36 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n         // We've been here already, no need to search again.\n         return;\n     }\n-    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(ccx));\n+    debug!(\"BEGIN collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n \n     let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n \n     match starting_point {\n         TransItem::DropGlue(t) => {\n-            find_drop_glue_neighbors(ccx, t, &mut neighbors);\n+            find_drop_glue_neighbors(scx, t, &mut neighbors);\n             recursion_depth_reset = None;\n         }\n         TransItem::Static(node_id) => {\n-            let def_id = ccx.tcx().map.local_def_id(node_id);\n-            let ty = ccx.tcx().lookup_item_type(def_id).ty;\n-            let ty = glue::get_drop_glue_type(ccx, ty);\n+            let def_id = scx.tcx().map.local_def_id(node_id);\n+            let ty = scx.tcx().lookup_item_type(def_id).ty;\n+            let ty = glue::get_drop_glue_type(scx.tcx(), ty);\n             neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n             recursion_depth_reset = None;\n         }\n         TransItem::Fn(instance) => {\n             // Keep track of the monomorphization recursion depth\n-            recursion_depth_reset = Some(check_recursion_limit(ccx,\n+            recursion_depth_reset = Some(check_recursion_limit(scx.tcx(),\n                                                                instance,\n                                                                recursion_depths));\n \n             // Scan the MIR in order to find function calls, closures, and\n             // drop-glue\n-            let mir = errors::expect(ccx.sess().diagnostic(), ccx.get_mir(instance.def),\n+            let mir = errors::expect(scx.sess().diagnostic(), scx.get_mir(instance.def),\n                 || format!(\"Could not find MIR for function: {}\", instance));\n \n             let mut visitor = MirNeighborCollector {\n-                ccx: ccx,\n+                scx: scx,\n                 mir: &mir,\n                 output: &mut neighbors,\n                 param_substs: instance.substs\n@@ -420,36 +419,36 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    record_references(ccx, starting_point, &neighbors[..], reference_map);\n+    record_references(scx.tcx(), starting_point, &neighbors[..], reference_map);\n \n     for neighbour in neighbors {\n-        collect_items_rec(ccx, neighbour, visited, recursion_depths, reference_map);\n+        collect_items_rec(scx, neighbour, visited, recursion_depths, reference_map);\n     }\n \n     if let Some((def_id, depth)) = recursion_depth_reset {\n         recursion_depths.insert(def_id, depth);\n     }\n \n-    debug!(\"END collect_items_rec({})\", starting_point.to_string(ccx));\n+    debug!(\"END collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n }\n \n-fn record_references<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               caller: TransItem<'tcx>,\n-                               callees: &[TransItem<'tcx>],\n-                               reference_map: &mut ReferenceMap<'tcx>) {\n+fn record_references<'tcx>(tcx: &TyCtxt<'tcx>,\n+                           caller: TransItem<'tcx>,\n+                           callees: &[TransItem<'tcx>],\n+                           reference_map: &mut ReferenceMap<'tcx>) {\n     let iter = callees.into_iter()\n                       .map(|callee| {\n                         let is_inlining_candidate = callee.is_from_extern_crate() ||\n-                                                    callee.requests_inline(ccx.tcx());\n+                                                    callee.requests_inline(tcx);\n                         (*callee, is_inlining_candidate)\n                       });\n     reference_map.record_references(caller, iter);\n }\n \n-fn check_recursion_limit<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n-                                       instance: Instance<'tcx>,\n-                                       recursion_depths: &mut DefIdMap<usize>)\n-                                       -> (DefId, usize) {\n+fn check_recursion_limit<'tcx>(tcx: &TyCtxt<'tcx>,\n+                               instance: Instance<'tcx>,\n+                               recursion_depths: &mut DefIdMap<usize>)\n+                               -> (DefId, usize) {\n     let recursion_depth = recursion_depths.get(&instance.def)\n                                           .map(|x| *x)\n                                           .unwrap_or(0);\n@@ -458,13 +457,13 @@ fn check_recursion_limit<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n     // Code that needs to instantiate the same function recursively\n     // more than the recursion limit is assumed to be causing an\n     // infinite expansion.\n-    if recursion_depth > ccx.sess().recursion_limit.get() {\n+    if recursion_depth > tcx.sess.recursion_limit.get() {\n         let error = format!(\"reached the recursion limit while instantiating `{}`\",\n                             instance);\n-        if let Some(node_id) = ccx.tcx().map.as_local_node_id(instance.def) {\n-            ccx.sess().span_fatal(ccx.tcx().map.span(node_id), &error);\n+        if let Some(node_id) = tcx.map.as_local_node_id(instance.def) {\n+            tcx.sess.span_fatal(tcx.map.span(node_id), &error);\n         } else {\n-            ccx.sess().fatal(&error);\n+            tcx.sess.fatal(&error);\n         }\n     }\n \n@@ -474,7 +473,7 @@ fn check_recursion_limit<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n struct MirNeighborCollector<'a, 'tcx: 'a> {\n-    ccx: &'a CrateContext<'a, 'tcx>,\n+    scx: &'a SharedCrateContext<'a, 'tcx>,\n     mir: &'a mir::Mir<'tcx>,\n     output: &'a mut Vec<TransItem<'tcx>>,\n     param_substs: &'tcx Substs<'tcx>\n@@ -488,8 +487,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         match *rvalue {\n             mir::Rvalue::Aggregate(mir::AggregateKind::Closure(def_id,\n                                                                ref substs), _) => {\n-                assert!(can_have_local_instance(self.ccx, def_id));\n-                let trans_item = create_fn_trans_item(self.ccx,\n+                assert!(can_have_local_instance(self.scx.tcx(), def_id));\n+                let trans_item = create_fn_trans_item(self.scx.tcx(),\n                                                       def_id,\n                                                       substs.func_substs,\n                                                       self.param_substs);\n@@ -499,37 +498,37 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             // have to instantiate all methods of the trait being cast to, so we\n             // can build the appropriate vtable.\n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, target_ty) => {\n-                let target_ty = monomorphize::apply_param_substs(self.ccx.tcx(),\n+                let target_ty = monomorphize::apply_param_substs(self.scx.tcx(),\n                                                                  self.param_substs,\n                                                                  &target_ty);\n-                let source_ty = self.mir.operand_ty(self.ccx.tcx(), operand);\n-                let source_ty = monomorphize::apply_param_substs(self.ccx.tcx(),\n+                let source_ty = self.mir.operand_ty(self.scx.tcx(), operand);\n+                let source_ty = monomorphize::apply_param_substs(self.scx.tcx(),\n                                                                  self.param_substs,\n                                                                  &source_ty);\n-                let (source_ty, target_ty) = find_vtable_types_for_unsizing(self.ccx,\n+                let (source_ty, target_ty) = find_vtable_types_for_unsizing(self.scx,\n                                                                             source_ty,\n                                                                             target_ty);\n                 // This could also be a different Unsize instruction, like\n                 // from a fixed sized array to a slice. But we are only\n                 // interested in things that produce a vtable.\n                 if target_ty.is_trait() && !source_ty.is_trait() {\n-                    create_trans_items_for_vtable_methods(self.ccx,\n+                    create_trans_items_for_vtable_methods(self.scx,\n                                                           target_ty,\n                                                           source_ty,\n                                                           self.output);\n                 }\n             }\n             mir::Rvalue::Box(_) => {\n                 let exchange_malloc_fn_def_id =\n-                    self.ccx\n+                    self.scx\n                         .tcx()\n                         .lang_items\n                         .require(ExchangeMallocFnLangItem)\n-                        .unwrap_or_else(|e| self.ccx.sess().fatal(&e));\n+                        .unwrap_or_else(|e| self.scx.sess().fatal(&e));\n \n-                assert!(can_have_local_instance(self.ccx, exchange_malloc_fn_def_id));\n+                assert!(can_have_local_instance(self.scx.tcx(), exchange_malloc_fn_def_id));\n                 let exchange_malloc_fn_trans_item =\n-                    create_fn_trans_item(self.ccx,\n+                    create_fn_trans_item(self.scx.tcx(),\n                                          exchange_malloc_fn_def_id,\n                                          &Substs::empty(),\n                                          self.param_substs);\n@@ -548,14 +547,14 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         debug!(\"visiting lvalue {:?}\", *lvalue);\n \n         if let mir_visit::LvalueContext::Drop = context {\n-            let ty = self.mir.lvalue_ty(self.ccx.tcx(), lvalue)\n-                             .to_ty(self.ccx.tcx());\n+            let ty = self.mir.lvalue_ty(self.scx.tcx(), lvalue)\n+                             .to_ty(self.scx.tcx());\n \n-            let ty = monomorphize::apply_param_substs(self.ccx.tcx(),\n+            let ty = monomorphize::apply_param_substs(self.scx.tcx(),\n                                                       self.param_substs,\n                                                       &ty);\n-            let ty = self.ccx.tcx().erase_regions(&ty);\n-            let ty = glue::get_drop_glue_type(self.ccx, ty);\n+            let ty = self.scx.tcx().erase_regions(&ty);\n+            let ty = glue::get_drop_glue_type(self.scx.tcx(), ty);\n             self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n         }\n \n@@ -583,7 +582,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             //\n             // Calling do_static_dispatch() here will map the def_id of\n             // `std::cmp::partial_cmp` to the def_id of `i32::partial_cmp<i32>`\n-            let dispatched = do_static_dispatch(self.ccx,\n+            let dispatched = do_static_dispatch(self.scx,\n                                                 callee_def_id,\n                                                 callee_substs,\n                                                 self.param_substs);\n@@ -594,9 +593,9 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 // object shim or a closure that is handled differently),\n                 // we check if the callee is something that will actually\n                 // result in a translation item ...\n-                if can_result_in_trans_item(self.ccx, callee_def_id) {\n+                if can_result_in_trans_item(self.scx.tcx(), callee_def_id) {\n                     // ... and create one if it does.\n-                    let trans_item = create_fn_trans_item(self.ccx,\n+                    let trans_item = create_fn_trans_item(self.scx.tcx(),\n                                                           callee_def_id,\n                                                           callee_substs,\n                                                           self.param_substs);\n@@ -607,21 +606,21 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n         self.super_operand(operand);\n \n-        fn can_result_in_trans_item<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                              def_id: DefId)\n-                                              -> bool {\n-            if !match ccx.tcx().lookup_item_type(def_id).ty.sty {\n+        fn can_result_in_trans_item<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                          def_id: DefId)\n+                                          -> bool {\n+            if !match tcx.lookup_item_type(def_id).ty.sty {\n                 ty::TyFnDef(def_id, _, _) => {\n                     // Some constructors also have type TyFnDef but they are\n                     // always instantiated inline and don't result in\n                     // translation item. Same for FFI functions.\n-                    match ccx.tcx().map.get_if_local(def_id) {\n+                    match tcx.map.get_if_local(def_id) {\n                         Some(hir_map::NodeVariant(_))    |\n                         Some(hir_map::NodeStructCtor(_)) |\n                         Some(hir_map::NodeForeignItem(_)) => false,\n                         Some(_) => true,\n                         None => {\n-                            ccx.sess().cstore.variant_kind(def_id).is_none()\n+                            tcx.sess.cstore.variant_kind(def_id).is_none()\n                         }\n                     }\n                 }\n@@ -631,21 +630,21 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 return false;\n             }\n \n-            can_have_local_instance(ccx, def_id)\n+            can_have_local_instance(tcx, def_id)\n         }\n     }\n }\n \n-fn can_have_local_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                     def_id: DefId)\n-                                     -> bool {\n+fn can_have_local_instance<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                 def_id: DefId)\n+                                 -> bool {\n     // Take a look if we have the definition available. If not, we\n     // will not emit code for this item in the local crate, and thus\n     // don't create a translation item for it.\n-    def_id.is_local() || ccx.sess().cstore.is_item_mir_available(def_id)\n+    def_id.is_local() || tcx.sess.cstore.is_item_mir_available(def_id)\n }\n \n-fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                       dg: DropGlueKind<'tcx>,\n                                       output: &mut Vec<TransItem<'tcx>>) {\n     let ty = match dg {\n@@ -657,19 +656,19 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     };\n \n-    debug!(\"find_drop_glue_neighbors: {}\", type_to_string(ccx, ty));\n+    debug!(\"find_drop_glue_neighbors: {}\", type_to_string(scx.tcx(), ty));\n \n     // Make sure the exchange_free_fn() lang-item gets translated if\n     // there is a boxed value.\n     if let ty::TyBox(_) = ty.sty {\n-        let exchange_free_fn_def_id = ccx.tcx()\n+        let exchange_free_fn_def_id = scx.tcx()\n                                          .lang_items\n                                          .require(ExchangeFreeFnLangItem)\n-                                         .unwrap_or_else(|e| ccx.sess().fatal(&e));\n+                                         .unwrap_or_else(|e| scx.sess().fatal(&e));\n \n-        assert!(can_have_local_instance(ccx, exchange_free_fn_def_id));\n+        assert!(can_have_local_instance(scx.tcx(), exchange_free_fn_def_id));\n         let exchange_free_fn_trans_item =\n-            create_fn_trans_item(ccx,\n+            create_fn_trans_item(scx.tcx(),\n                                  exchange_free_fn_def_id,\n                                  &Substs::empty(),\n                                  &Substs::empty());\n@@ -688,26 +687,26 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     if let Some(destructor_did) = destructor_did {\n         use rustc::ty::ToPolyTraitRef;\n \n-        let drop_trait_def_id = ccx.tcx()\n+        let drop_trait_def_id = scx.tcx()\n                                    .lang_items\n                                    .drop_trait()\n                                    .unwrap();\n \n-        let self_type_substs = ccx.tcx().mk_substs(\n+        let self_type_substs = scx.tcx().mk_substs(\n             Substs::empty().with_self_ty(ty));\n \n         let trait_ref = ty::TraitRef {\n             def_id: drop_trait_def_id,\n             substs: self_type_substs,\n         }.to_poly_trait_ref();\n \n-        let substs = match fulfill_obligation(ccx, DUMMY_SP, trait_ref) {\n+        let substs = match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n             traits::VtableImpl(data) => data.substs,\n             _ => bug!()\n         };\n \n-        if can_have_local_instance(ccx, destructor_did) {\n-            let trans_item = create_fn_trans_item(ccx,\n+        if can_have_local_instance(scx.tcx(), destructor_did) {\n+            let trans_item = create_fn_trans_item(scx.tcx(),\n                                                   destructor_did,\n                                                   substs,\n                                                   &Substs::empty());\n@@ -738,35 +737,35 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::TyStruct(ref adt_def, substs) |\n         ty::TyEnum(ref adt_def, substs) => {\n             for field in adt_def.all_fields() {\n-                let field_type = monomorphize::apply_param_substs(ccx.tcx(),\n+                let field_type = monomorphize::apply_param_substs(scx.tcx(),\n                                                                   substs,\n                                                                   &field.unsubst_ty());\n-                let field_type = glue::get_drop_glue_type(ccx, field_type);\n+                let field_type = glue::get_drop_glue_type(scx.tcx(), field_type);\n \n-                if glue::type_needs_drop(ccx.tcx(), field_type) {\n+                if glue::type_needs_drop(scx.tcx(), field_type) {\n                     output.push(TransItem::DropGlue(DropGlueKind::Ty(field_type)));\n                 }\n             }\n         }\n         ty::TyClosure(_, ref substs) => {\n             for upvar_ty in &substs.upvar_tys {\n-                let upvar_ty = glue::get_drop_glue_type(ccx, upvar_ty);\n-                if glue::type_needs_drop(ccx.tcx(), upvar_ty) {\n+                let upvar_ty = glue::get_drop_glue_type(scx.tcx(), upvar_ty);\n+                if glue::type_needs_drop(scx.tcx(), upvar_ty) {\n                     output.push(TransItem::DropGlue(DropGlueKind::Ty(upvar_ty)));\n                 }\n             }\n         }\n         ty::TyBox(inner_type)      |\n         ty::TyArray(inner_type, _) => {\n-            let inner_type = glue::get_drop_glue_type(ccx, inner_type);\n-            if glue::type_needs_drop(ccx.tcx(), inner_type) {\n+            let inner_type = glue::get_drop_glue_type(scx.tcx(), inner_type);\n+            if glue::type_needs_drop(scx.tcx(), inner_type) {\n                 output.push(TransItem::DropGlue(DropGlueKind::Ty(inner_type)));\n             }\n         }\n         ty::TyTuple(ref args) => {\n             for arg in args {\n-                let arg = glue::get_drop_glue_type(ccx, arg);\n-                if glue::type_needs_drop(ccx.tcx(), arg) {\n+                let arg = glue::get_drop_glue_type(scx.tcx(), arg);\n+                if glue::type_needs_drop(scx.tcx(), arg) {\n                     output.push(TransItem::DropGlue(DropGlueKind::Ty(arg)));\n                 }\n             }\n@@ -780,25 +779,25 @@ fn find_drop_glue_neighbors<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn do_static_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                 fn_def_id: DefId,\n                                 fn_substs: &'tcx Substs<'tcx>,\n                                 param_substs: &'tcx Substs<'tcx>)\n                                 -> Option<(DefId, &'tcx Substs<'tcx>)> {\n     debug!(\"do_static_dispatch(fn_def_id={}, fn_substs={:?}, param_substs={:?})\",\n-           def_id_to_string(ccx, fn_def_id),\n+           def_id_to_string(scx.tcx(), fn_def_id),\n            fn_substs,\n            param_substs);\n \n-    let is_trait_method = ccx.tcx().trait_of_item(fn_def_id).is_some();\n+    let is_trait_method = scx.tcx().trait_of_item(fn_def_id).is_some();\n \n     if is_trait_method {\n-        match ccx.tcx().impl_or_trait_item(fn_def_id) {\n+        match scx.tcx().impl_or_trait_item(fn_def_id) {\n             ty::MethodTraitItem(ref method) => {\n                 match method.container {\n                     ty::TraitContainer(trait_def_id) => {\n                         debug!(\" => trait method, attempting to find impl\");\n-                        do_static_trait_method_dispatch(ccx,\n+                        do_static_trait_method_dispatch(scx,\n                                                         method,\n                                                         trait_def_id,\n                                                         fn_substs,\n@@ -823,19 +822,19 @@ fn do_static_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n // Given a trait-method and substitution information, find out the actual\n // implementation of the trait method.\n-fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                              trait_method: &ty::Method,\n                                              trait_id: DefId,\n                                              callee_substs: &'tcx Substs<'tcx>,\n                                              param_substs: &'tcx Substs<'tcx>)\n                                              -> Option<(DefId, &'tcx Substs<'tcx>)> {\n-    let tcx = ccx.tcx();\n+    let tcx = scx.tcx();\n     debug!(\"do_static_trait_method_dispatch(trait_method={}, \\\n                                             trait_id={}, \\\n                                             callee_substs={:?}, \\\n                                             param_substs={:?}\",\n-           def_id_to_string(ccx, trait_method.def_id),\n-           def_id_to_string(ccx, trait_id),\n+           def_id_to_string(scx.tcx(), trait_method.def_id),\n+           def_id_to_string(scx.tcx(), trait_id),\n            callee_substs,\n            param_substs);\n \n@@ -844,7 +843,7 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                        callee_substs);\n \n     let trait_ref = ty::Binder(rcvr_substs.to_trait_ref(tcx, trait_id));\n-    let vtbl = fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n+    let vtbl = fulfill_obligation(scx, DUMMY_SP, trait_ref);\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n@@ -912,7 +911,7 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n ///\n /// Finally, there is also the case of custom unsizing coercions, e.g. for\n /// smart pointers such as `Rc` and `Arc`.\n-fn find_vtable_types_for_unsizing<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                             source_ty: ty::Ty<'tcx>,\n                                             target_ty: ty::Ty<'tcx>)\n                                             -> (ty::Ty<'tcx>, ty::Ty<'tcx>) {\n@@ -926,18 +925,18 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             let (inner_source, inner_target) = (a, b);\n \n-            if !type_is_sized(ccx.tcx(), inner_source) {\n+            if !type_is_sized(scx.tcx(), inner_source) {\n                 (inner_source, inner_target)\n             } else {\n-                ccx.tcx().struct_lockstep_tails(inner_source, inner_target)\n+                scx.tcx().struct_lockstep_tails(inner_source, inner_target)\n             }\n         }\n \n         (&ty::TyStruct(source_adt_def, source_substs),\n          &ty::TyStruct(target_adt_def, target_substs)) => {\n             assert_eq!(source_adt_def, target_adt_def);\n \n-            let kind = custom_coerce_unsize_info(ccx, source_ty, target_ty);\n+            let kind = custom_coerce_unsize_info(scx, source_ty, target_ty);\n \n             let coerce_index = match kind {\n                 CustomCoerceUnsized::Struct(i) => i\n@@ -949,10 +948,10 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             assert!(coerce_index < source_fields.len() &&\n                     source_fields.len() == target_fields.len());\n \n-            find_vtable_types_for_unsizing(ccx,\n-                                           source_fields[coerce_index].ty(ccx.tcx(),\n+            find_vtable_types_for_unsizing(scx,\n+                                           source_fields[coerce_index].ty(scx.tcx(),\n                                                                           source_substs),\n-                                           target_fields[coerce_index].ty(ccx.tcx(),\n+                                           target_fields[coerce_index].ty(scx.tcx(),\n                                                                           target_substs))\n         }\n         _ => bug!(\"find_vtable_types_for_unsizing: invalid coercion {:?} -> {:?}\",\n@@ -961,61 +960,59 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn create_fn_trans_item<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                  def_id: DefId,\n-                                  fn_substs: &Substs<'tcx>,\n-                                  param_substs: &Substs<'tcx>)\n-                                  -> TransItem<'tcx>\n-{\n+fn create_fn_trans_item<'tcx>(tcx: &TyCtxt<'tcx>,\n+                              def_id: DefId,\n+                              fn_substs: &Substs<'tcx>,\n+                              param_substs: &Substs<'tcx>)\n+                              -> TransItem<'tcx> {\n     debug!(\"create_fn_trans_item(def_id={}, fn_substs={:?}, param_substs={:?})\",\n-            def_id_to_string(ccx, def_id),\n+            def_id_to_string(tcx, def_id),\n             fn_substs,\n             param_substs);\n \n     // We only get here, if fn_def_id either designates a local item or\n     // an inlineable external item. Non-inlineable external items are\n     // ignored because we don't want to generate any code for them.\n-    let concrete_substs = monomorphize::apply_param_substs(ccx.tcx(),\n+    let concrete_substs = monomorphize::apply_param_substs(tcx,\n                                                            param_substs,\n                                                            fn_substs);\n-    let concrete_substs = ccx.tcx().erase_regions(&concrete_substs);\n+    let concrete_substs = tcx.erase_regions(&concrete_substs);\n \n     let trans_item =\n         TransItem::Fn(Instance::new(def_id,\n-                                    &ccx.tcx().mk_substs(concrete_substs)));\n-\n+                                    &tcx.mk_substs(concrete_substs)));\n     return trans_item;\n }\n \n /// Creates a `TransItem` for each method that is referenced by the vtable for\n /// the given trait/impl pair.\n-fn create_trans_items_for_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                    trait_ty: ty::Ty<'tcx>,\n                                                    impl_ty: ty::Ty<'tcx>,\n                                                    output: &mut Vec<TransItem<'tcx>>) {\n     assert!(!trait_ty.needs_subst() && !impl_ty.needs_subst());\n \n     if let ty::TyTrait(ref trait_ty) = trait_ty.sty {\n-        let poly_trait_ref = trait_ty.principal_trait_ref_with_self_ty(ccx.tcx(),\n+        let poly_trait_ref = trait_ty.principal_trait_ref_with_self_ty(scx.tcx(),\n                                                                        impl_ty);\n \n         // Walk all methods of the trait, including those of its supertraits\n-        for trait_ref in traits::supertraits(ccx.tcx(), poly_trait_ref) {\n-            let vtable = fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n+        for trait_ref in traits::supertraits(scx.tcx(), poly_trait_ref) {\n+            let vtable = fulfill_obligation(scx, DUMMY_SP, trait_ref);\n             match vtable {\n                 traits::VtableImpl(\n                     traits::VtableImplData {\n                         impl_def_id,\n                         substs,\n                         nested: _ }) => {\n-                    let items = meth::get_vtable_methods(ccx, impl_def_id, substs)\n+                    let items = meth::get_vtable_methods(scx.tcx(), impl_def_id, substs)\n                         .into_iter()\n                         // filter out None values\n                         .filter_map(|opt_impl_method| opt_impl_method)\n                         // create translation items\n                         .filter_map(|impl_method| {\n-                            if can_have_local_instance(ccx, impl_method.method.def_id) {\n-                                Some(create_fn_trans_item(ccx,\n+                            if can_have_local_instance(scx.tcx(), impl_method.method.def_id) {\n+                                Some(create_fn_trans_item(scx.tcx(),\n                                                           impl_method.method.def_id,\n                                                           &impl_method.substs,\n                                                           &Substs::empty()))\n@@ -1038,7 +1035,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n //=-----------------------------------------------------------------------------\n \n struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n-    ccx: &'b CrateContext<'a, 'tcx>,\n+    scx: &'b SharedCrateContext<'a, 'tcx>,\n     mode: TransItemCollectionMode,\n     output: &'b mut Vec<TransItem<'tcx>>,\n     enclosing_item: Option<&'tcx hir::Item>,\n@@ -1063,7 +1060,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n \n             hir::ItemImpl(..) => {\n                 if self.mode == TransItemCollectionMode::Eager {\n-                    create_trans_items_for_default_impls(self.ccx,\n+                    create_trans_items_for_default_impls(self.scx.tcx(),\n                                                          item,\n                                                          self.output);\n                 }\n@@ -1073,35 +1070,35 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemStruct(_, ref generics)      => {\n                 if !generics.is_parameterized() {\n                     let ty = {\n-                        let tables = self.ccx.tcx().tables.borrow();\n+                        let tables = self.scx.tcx().tables.borrow();\n                         tables.node_types[&item.id]\n                     };\n \n                     if self.mode == TransItemCollectionMode::Eager {\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n-                               def_id_to_string(self.ccx,\n-                                                self.ccx.tcx().map.local_def_id(item.id)));\n+                               def_id_to_string(self.scx.tcx(),\n+                                                self.scx.tcx().map.local_def_id(item.id)));\n \n-                        let ty = glue::get_drop_glue_type(self.ccx, ty);\n+                        let ty = glue::get_drop_glue_type(self.scx.tcx(), ty);\n                         self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n                     }\n                 }\n             }\n             hir::ItemStatic(..) => {\n                 debug!(\"RootCollector: ItemStatic({})\",\n-                       def_id_to_string(self.ccx,\n-                                        self.ccx.tcx().map.local_def_id(item.id)));\n+                       def_id_to_string(self.scx.tcx(),\n+                                        self.scx.tcx().map.local_def_id(item.id)));\n                 self.output.push(TransItem::Static(item.id));\n             }\n             hir::ItemFn(_, _, constness, _, ref generics, _) => {\n                 if !generics.is_type_parameterized() &&\n                    constness == hir::Constness::NotConst {\n-                    let def_id = self.ccx.tcx().map.local_def_id(item.id);\n+                    let def_id = self.scx.tcx().map.local_def_id(item.id);\n \n                     debug!(\"RootCollector: ItemFn({})\",\n-                           def_id_to_string(self.ccx, def_id));\n+                           def_id_to_string(self.scx.tcx(), def_id));\n \n-                    let instance = Instance::mono(self.ccx.tcx(), def_id);\n+                    let instance = Instance::mono(self.scx.tcx(), def_id);\n                     self.output.push(TransItem::Fn(instance));\n                 }\n             }\n@@ -1118,7 +1115,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                 constness,\n                 ..\n             }, _) if constness == hir::Constness::NotConst => {\n-                let hir_map = &self.ccx.tcx().map;\n+                let hir_map = &self.scx.tcx().map;\n                 let parent_node_id = hir_map.get_parent_node(ii.id);\n                 let is_impl_generic = match hir_map.expect_item(parent_node_id) {\n                     &hir::Item {\n@@ -1133,12 +1130,12 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                 };\n \n                 if !generics.is_type_parameterized() && !is_impl_generic {\n-                    let def_id = self.ccx.tcx().map.local_def_id(ii.id);\n+                    let def_id = self.scx.tcx().map.local_def_id(ii.id);\n \n                     debug!(\"RootCollector: MethodImplItem({})\",\n-                           def_id_to_string(self.ccx, def_id));\n+                           def_id_to_string(self.scx.tcx(), def_id));\n \n-                    let instance = Instance::mono(self.ccx.tcx(), def_id);\n+                    let instance = Instance::mono(self.scx.tcx(), def_id);\n                     self.output.push(TransItem::Fn(instance));\n                 }\n             }\n@@ -1149,9 +1146,9 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n     }\n }\n \n-fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                  item: &'tcx hir::Item,\n-                                                  output: &mut Vec<TransItem<'tcx>>) {\n+fn create_trans_items_for_default_impls<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                              item: &'tcx hir::Item,\n+                                              output: &mut Vec<TransItem<'tcx>>) {\n     match item.node {\n         hir::ItemImpl(_,\n                       _,\n@@ -1163,11 +1160,10 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 return\n             }\n \n-            let tcx = ccx.tcx();\n             let impl_def_id = tcx.map.local_def_id(item.id);\n \n             debug!(\"create_trans_items_for_default_impls(item={})\",\n-                   def_id_to_string(ccx, impl_def_id));\n+                   def_id_to_string(tcx, impl_def_id));\n \n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 let default_impls = tcx.provided_trait_methods(trait_ref.def_id);\n@@ -1194,13 +1190,13 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     assert!(mth.is_provided);\n \n                     let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n-                    if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n+                    if !normalize_and_test_predicates(tcx, predicates.into_vec()) {\n                         continue;\n                     }\n \n-                    if can_have_local_instance(ccx, default_impl.def_id) {\n-                        let empty_substs = ccx.tcx().mk_substs(ccx.tcx().erase_regions(mth.substs));\n-                        let item = create_fn_trans_item(ccx,\n+                    if can_have_local_instance(tcx, default_impl.def_id) {\n+                        let empty_substs = tcx.mk_substs(tcx.erase_regions(mth.substs));\n+                        let item = create_fn_trans_item(tcx,\n                                                         default_impl.def_id,\n                                                         callee_substs,\n                                                         empty_substs);\n@@ -1229,9 +1225,9 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n /// Same as `unique_type_name()` but with the result pushed onto the given\n /// `output` parameter.\n-pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                       t: ty::Ty<'tcx>,\n-                                       output: &mut String) {\n+pub fn push_unique_type_name<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                   t: ty::Ty<'tcx>,\n+                                   output: &mut String) {\n     match t.sty {\n         ty::TyBool              => output.push_str(\"bool\"),\n         ty::TyChar              => output.push_str(\"char\"),\n@@ -1250,13 +1246,13 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n         ty::TyStruct(adt_def, substs) |\n         ty::TyEnum(adt_def, substs) => {\n-            push_item_name(cx, adt_def.did, output);\n-            push_type_params(cx, &substs.types, &[], output);\n+            push_item_name(tcx, adt_def.did, output);\n+            push_type_params(tcx, &substs.types, &[], output);\n         },\n         ty::TyTuple(ref component_types) => {\n             output.push('(');\n             for &component_type in component_types {\n-                push_unique_type_name(cx, component_type, output);\n+                push_unique_type_name(tcx, component_type, output);\n                 output.push_str(\", \");\n             }\n             if !component_types.is_empty() {\n@@ -1267,7 +1263,7 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         },\n         ty::TyBox(inner_type) => {\n             output.push_str(\"Box<\");\n-            push_unique_type_name(cx, inner_type, output);\n+            push_unique_type_name(tcx, inner_type, output);\n             output.push('>');\n         },\n         ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n@@ -1277,30 +1273,30 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 hir::MutMutable => output.push_str(\"mut \"),\n             }\n \n-            push_unique_type_name(cx, inner_type, output);\n+            push_unique_type_name(tcx, inner_type, output);\n         },\n         ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n             output.push('&');\n             if mutbl == hir::MutMutable {\n                 output.push_str(\"mut \");\n             }\n \n-            push_unique_type_name(cx, inner_type, output);\n+            push_unique_type_name(tcx, inner_type, output);\n         },\n         ty::TyArray(inner_type, len) => {\n             output.push('[');\n-            push_unique_type_name(cx, inner_type, output);\n+            push_unique_type_name(tcx, inner_type, output);\n             output.push_str(&format!(\"; {}\", len));\n             output.push(']');\n         },\n         ty::TySlice(inner_type) => {\n             output.push('[');\n-            push_unique_type_name(cx, inner_type, output);\n+            push_unique_type_name(tcx, inner_type, output);\n             output.push(']');\n         },\n         ty::TyTrait(ref trait_data) => {\n-            push_item_name(cx, trait_data.principal.skip_binder().def_id, output);\n-            push_type_params(cx,\n+            push_item_name(tcx, trait_data.principal.skip_binder().def_id, output);\n+            push_type_params(tcx,\n                              &trait_data.principal.skip_binder().substs.types,\n                              &trait_data.bounds.projection_bounds,\n                              output);\n@@ -1319,10 +1315,10 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push_str(\"fn(\");\n \n-            let sig = cx.tcx().erase_late_bound_regions(sig);\n+            let sig = tcx.erase_late_bound_regions(sig);\n             if !sig.inputs.is_empty() {\n                 for &parameter_type in &sig.inputs {\n-                    push_unique_type_name(cx, parameter_type, output);\n+                    push_unique_type_name(tcx, parameter_type, output);\n                     output.push_str(\", \");\n                 }\n                 output.pop();\n@@ -1343,19 +1339,19 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 ty::FnConverging(result_type) if result_type.is_nil() => {}\n                 ty::FnConverging(result_type) => {\n                     output.push_str(\" -> \");\n-                    push_unique_type_name(cx, result_type, output);\n+                    push_unique_type_name(tcx, result_type, output);\n                 }\n                 ty::FnDiverging => {\n                     output.push_str(\" -> !\");\n                 }\n             }\n         },\n         ty::TyClosure(def_id, ref closure_substs) => {\n-            push_item_name(cx, def_id, output);\n+            push_item_name(tcx, def_id, output);\n             output.push_str(\"{\");\n             output.push_str(&format!(\"{}:{}\", def_id.krate, def_id.index.as_usize()));\n             output.push_str(\"}\");\n-            push_type_params(cx, &closure_substs.func_substs.types, &[], output);\n+            push_type_params(tcx, &closure_substs.func_substs.types, &[], output);\n         }\n         ty::TyError |\n         ty::TyInfer(_) |\n@@ -1367,17 +1363,17 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-fn push_item_name(ccx: &CrateContext,\n+fn push_item_name(tcx: &TyCtxt,\n                   def_id: DefId,\n                   output: &mut String) {\n-    let def_path = ccx.tcx().def_path(def_id);\n+    let def_path = tcx.def_path(def_id);\n \n     // some_crate::\n-    output.push_str(&ccx.tcx().crate_name(def_path.krate));\n+    output.push_str(&tcx.crate_name(def_path.krate));\n     output.push_str(\"::\");\n \n     // foo::bar::ItemName::\n-    for part in ccx.tcx().def_path(def_id).data {\n+    for part in tcx.def_path(def_id).data {\n         output.push_str(&format!(\"{}[{}]::\",\n                         part.data.as_interned_str(),\n                         part.disambiguator));\n@@ -1388,18 +1384,18 @@ fn push_item_name(ccx: &CrateContext,\n     output.pop();\n }\n \n-fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                              types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n-                              projections: &[ty::PolyProjectionPredicate<'tcx>],\n-                              output: &mut String) {\n+fn push_type_params<'tcx>(tcx: &TyCtxt<'tcx>,\n+                          types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n+                          projections: &[ty::PolyProjectionPredicate<'tcx>],\n+                          output: &mut String) {\n     if types.is_empty() && projections.is_empty() {\n         return;\n     }\n \n     output.push('<');\n \n     for &type_parameter in types {\n-        push_unique_type_name(cx, type_parameter, output);\n+        push_unique_type_name(tcx, type_parameter, output);\n         output.push_str(\", \");\n     }\n \n@@ -1408,7 +1404,7 @@ fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let name = token::get_ident_interner().get(projection.projection_ty.item_name);\n         output.push_str(&name[..]);\n         output.push_str(\"=\");\n-        push_unique_type_name(cx, projection.ty, output);\n+        push_unique_type_name(tcx, projection.ty, output);\n         output.push_str(\", \");\n     }\n \n@@ -1418,24 +1414,24 @@ fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     output.push('>');\n }\n \n-fn push_instance_as_string<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                     instance: Instance<'tcx>,\n-                                     output: &mut String) {\n-    push_item_name(ccx, instance.def, output);\n-    push_type_params(ccx, &instance.substs.types, &[], output);\n+fn push_instance_as_string<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                 instance: Instance<'tcx>,\n+                                 output: &mut String) {\n+    push_item_name(tcx, instance.def, output);\n+    push_type_params(tcx, &instance.substs.types, &[], output);\n }\n \n-pub fn def_id_to_string(ccx: &CrateContext, def_id: DefId) -> String {\n+pub fn def_id_to_string(tcx: &TyCtxt, def_id: DefId) -> String {\n     let mut output = String::new();\n-    push_item_name(ccx, def_id, &mut output);\n+    push_item_name(tcx, def_id, &mut output);\n     output\n }\n \n-fn type_to_string<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                            ty: ty::Ty<'tcx>)\n-                            -> String {\n+fn type_to_string<'tcx>(tcx: &TyCtxt<'tcx>,\n+                        ty: ty::Ty<'tcx>)\n+                        -> String {\n     let mut output = String::new();\n-    push_unique_type_name(ccx, ty, &mut output);\n+    push_unique_type_name(tcx, ty, &mut output);\n     output\n }\n \n@@ -1492,8 +1488,8 @@ impl<'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        let hir_map = &ccx.tcx().map;\n+    pub fn to_string(&self, tcx: &TyCtxt<'tcx>) -> String {\n+        let hir_map = &tcx.map;\n \n         return match *self {\n             TransItem::DropGlue(dg) => {\n@@ -1502,26 +1498,26 @@ impl<'tcx> TransItem<'tcx> {\n                     DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n                     DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n                 };\n-                push_unique_type_name(ccx, dg.ty(), &mut s);\n+                push_unique_type_name(tcx, dg.ty(), &mut s);\n                 s\n             }\n             TransItem::Fn(instance) => {\n-                to_string_internal(ccx, \"fn \", instance)\n+                to_string_internal(tcx, \"fn \", instance)\n             },\n             TransItem::Static(node_id) => {\n                 let def_id = hir_map.local_def_id(node_id);\n-                let instance = Instance::mono(ccx.tcx(), def_id);\n-                to_string_internal(ccx, \"static \", instance)\n+                let instance = Instance::mono(tcx, def_id);\n+                to_string_internal(tcx, \"static \", instance)\n             },\n         };\n \n-        fn to_string_internal<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                        prefix: &str,\n-                                        instance: Instance<'tcx>)\n-                                        -> String {\n+        fn to_string_internal<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                    prefix: &str,\n+                                    instance: Instance<'tcx>)\n+                                    -> String {\n             let mut result = String::with_capacity(32);\n             result.push_str(prefix);\n-            push_instance_as_string(ccx, instance, &mut result);\n+            push_instance_as_string(tcx, instance, &mut result);\n             result\n         }\n     }\n@@ -1550,15 +1546,15 @@ pub enum TransItemState {\n     NotPredictedButGenerated,\n }\n \n-pub fn collecting_debug_information(ccx: &CrateContext) -> bool {\n+pub fn collecting_debug_information(scx: &SharedCrateContext) -> bool {\n     return cfg!(debug_assertions) &&\n-           ccx.sess().opts.debugging_opts.print_trans_items.is_some();\n+           scx.sess().opts.debugging_opts.print_trans_items.is_some();\n }\n \n-pub fn print_collection_results<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n+pub fn print_collection_results<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>) {\n     use std::hash::{Hash, SipHasher, Hasher};\n \n-    if !collecting_debug_information(ccx) {\n+    if !collecting_debug_information(scx) {\n         return;\n     }\n \n@@ -1568,14 +1564,14 @@ pub fn print_collection_results<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n         s.finish()\n     }\n \n-    let trans_items = ccx.translation_items().borrow();\n+    let trans_items = scx.translation_items().borrow();\n \n     {\n         // Check for duplicate item keys\n         let mut item_keys = FnvHashMap();\n \n         for (item, item_state) in trans_items.iter() {\n-            let k = item.to_string(&ccx);\n+            let k = item.to_string(scx.tcx());\n \n             if item_keys.contains_key(&k) {\n                 let prev: (TransItem, TransItemState) = item_keys[&k];\n@@ -1603,7 +1599,7 @@ pub fn print_collection_results<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n     let mut generated = FnvHashSet();\n \n     for (item, item_state) in trans_items.iter() {\n-        let item_key = item.to_string(&ccx);\n+        let item_key = item.to_string(scx.tcx());\n \n         match *item_state {\n             TransItemState::PredictedAndGenerated => {"}, {"sha": "dc1928a5e07b9e7c12cb985a0012d86d61cf5793", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 61, "deletions": 66, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=1939b76903eb8a4aa02dadc52353541637e3b98c", "patch": "@@ -20,6 +20,7 @@ use rustc::cfg;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::infer;\n+use rustc::util::common::MemoizationMap;\n use middle::lang_items::LangItem;\n use rustc::ty::subst::Substs;\n use abi::{Abi, FnType};\n@@ -54,7 +55,7 @@ use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n \n-pub use context::CrateContext;\n+pub use context::{CrateContext, SharedCrateContext};\n \n /// Is the type's representation size known at compile time?\n pub fn type_is_sized<'tcx>(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -1049,92 +1050,86 @@ pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &hir::Expr) ->\n /// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n /// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n /// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n-pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                     span: Span,\n                                     trait_ref: ty::PolyTraitRef<'tcx>)\n                                     -> traits::Vtable<'tcx, ()>\n {\n-    let tcx = ccx.tcx();\n+    let tcx = scx.tcx();\n \n     // Remove any references to regions; this helps improve caching.\n     let trait_ref = tcx.erase_regions(&trait_ref);\n \n-    // First check the cache.\n-    match ccx.trait_cache().borrow().get(&trait_ref) {\n-        Some(vtable) => {\n-            info!(\"Cache hit: {:?}\", trait_ref);\n-            return (*vtable).clone();\n-        }\n-        None => { }\n-    }\n-\n-    debug!(\"trans fulfill_obligation: trait_ref={:?} def_id={:?}\",\n-           trait_ref, trait_ref.def_id());\n-\n-\n-    // Do the initial selection for the obligation. This yields the\n-    // shallow result we are looking for -- that is, what specific impl.\n-    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Any);\n-    let mut selcx = SelectionContext::new(&infcx);\n-\n-    let obligation =\n-        traits::Obligation::new(traits::ObligationCause::misc(span, ast::DUMMY_NODE_ID),\n-                                trait_ref.to_poly_trait_predicate());\n-    let selection = match selcx.select(&obligation) {\n-        Ok(Some(selection)) => selection,\n-        Ok(None) => {\n-            // Ambiguity can happen when monomorphizing during trans\n-            // expands to some humongo type that never occurred\n-            // statically -- this humongo type can then overflow,\n-            // leading to an ambiguous result. So report this as an\n-            // overflow bug, since I believe this is the only case\n-            // where ambiguity can result.\n-            debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n-                    presuming due to overflow\",\n-                   trait_ref);\n-            ccx.sess().span_fatal(\n-                span,\n-                \"reached the recursion limit during monomorphization (selection ambiguity)\");\n-        }\n-        Err(e) => {\n-            span_bug!(\n-                span,\n-                \"Encountered error `{:?}` selecting `{:?}` during trans\",\n-                e,\n-                trait_ref)\n-        }\n-    };\n-\n-    // Currently, we use a fulfillment context to completely resolve\n-    // all nested obligations. This is because they can inform the\n-    // inference of the impl's type parameters.\n-    let mut fulfill_cx = traits::FulfillmentContext::new();\n-    let vtable = selection.map(|predicate| {\n-        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-    });\n-    let vtable = infer::drain_fulfillment_cx_or_panic(\n-        span, &infcx, &mut fulfill_cx, &vtable\n-    );\n+    scx.trait_cache().memoize(trait_ref, || {\n+        debug!(\"trans fulfill_obligation: trait_ref={:?} def_id={:?}\",\n+               trait_ref, trait_ref.def_id());\n+\n+        // Do the initial selection for the obligation. This yields the\n+        // shallow result we are looking for -- that is, what specific impl.\n+        let infcx = infer::normalizing_infer_ctxt(tcx,\n+                                                  &tcx.tables,\n+                                                  ProjectionMode::Any);\n+        let mut selcx = SelectionContext::new(&infcx);\n+\n+        let obligation_cause = traits::ObligationCause::misc(span,\n+                                                             ast::DUMMY_NODE_ID);\n+        let obligation = traits::Obligation::new(obligation_cause,\n+                                                 trait_ref.to_poly_trait_predicate());\n+\n+        let selection = match selcx.select(&obligation) {\n+            Ok(Some(selection)) => selection,\n+            Ok(None) => {\n+                // Ambiguity can happen when monomorphizing during trans\n+                // expands to some humongo type that never occurred\n+                // statically -- this humongo type can then overflow,\n+                // leading to an ambiguous result. So report this as an\n+                // overflow bug, since I believe this is the only case\n+                // where ambiguity can result.\n+                debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n+                        presuming due to overflow\",\n+                       trait_ref);\n+                tcx.sess.span_fatal(\n+                    span,\n+                    \"reached the recursion limit during monomorphization \\\n+                     (selection ambiguity)\");\n+            }\n+            Err(e) => {\n+                span_bug!(\n+                    span,\n+                    \"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                    e,\n+                    trait_ref)\n+            }\n+        };\n \n-    info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n+        // Currently, we use a fulfillment context to completely resolve\n+        // all nested obligations. This is because they can inform the\n+        // inference of the impl's type parameters.\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n+        let vtable = selection.map(|predicate| {\n+            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+        });\n+        let vtable = infer::drain_fulfillment_cx_or_panic(\n+            span, &infcx, &mut fulfill_cx, &vtable\n+        );\n \n-    ccx.trait_cache().borrow_mut().insert(trait_ref, vtable.clone());\n+        info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n \n-    vtable\n+        vtable\n+    })\n }\n \n /// Normalizes the predicates and checks whether they hold.  If this\n /// returns false, then either normalize encountered an error or one\n /// of the predicates did not hold. Used when creating vtables to\n /// check for unsatisfiable methods.\n-pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                               predicates: Vec<ty::Predicate<'tcx>>)\n-                                               -> bool\n+pub fn normalize_and_test_predicates<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                           predicates: Vec<ty::Predicate<'tcx>>)\n+                                           -> bool\n {\n     debug!(\"normalize_and_test_predicates(predicates={:?})\",\n            predicates);\n \n-    let tcx = ccx.tcx();\n     let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Any);\n     let mut selcx = SelectionContext::new(&infcx);\n     let mut fulfill_cx = traits::FulfillmentContext::new();"}, {"sha": "2811148abd68e259a2f92c53d558d2b36edb1058", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=1939b76903eb8a4aa02dadc52353541637e3b98c", "patch": "@@ -1133,7 +1133,7 @@ pub fn trans_static(ccx: &CrateContext,\n                     attrs: &[ast::Attribute])\n                     -> Result<ValueRef, ConstEvalErr> {\n \n-    if collector::collecting_debug_information(ccx) {\n+    if collector::collecting_debug_information(ccx.shared()) {\n         ccx.record_translation_item_as_generated(TransItem::Static(id));\n     }\n "}, {"sha": "24095929f4f9886bd4abc93517b93b2ce919a4b3", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 185, "deletions": 151, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=1939b76903eb8a4aa02dadc52353541637e3b98c", "patch": "@@ -28,6 +28,7 @@ use mir::CachedMir;\n use monomorphize::Instance;\n \n use collector::{TransItem, TransItemState};\n+use partitioning::CodegenUnit;\n use type_::{Type, TypeNames};\n use rustc::ty::subst::{Substs, VecPerParamSpace};\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -64,8 +65,6 @@ pub struct Stats {\n /// crate, so it must not contain references to any LLVM data structures\n /// (aside from metadata-related ones).\n pub struct SharedCrateContext<'a, 'tcx: 'a> {\n-    local_ccxs: Vec<LocalCrateContext<'tcx>>,\n-\n     metadata_llmod: ModuleRef,\n     metadata_llcx: ContextRef,\n \n@@ -86,6 +85,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     use_dll_storage_attrs: bool,\n \n     translation_items: RefCell<FnvHashMap<TransItem<'tcx>, TransItemState>>,\n+    trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n@@ -95,7 +95,8 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n pub struct LocalCrateContext<'tcx> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n-    tn: TypeNames,\n+    tn: TypeNames, // FIXME: This seems to be largely unused.\n+    codegen_unit: CodegenUnit<'tcx>,\n     needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n     fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n     drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, ValueRef>>,\n@@ -171,8 +172,6 @@ pub struct LocalCrateContext<'tcx> {\n \n     /// Depth of the current type-of computation - used to bail out\n     type_of_depth: Cell<usize>,\n-\n-    trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n }\n \n // Implement DepTrackingMapConfig for `trait_cache`\n@@ -184,31 +183,74 @@ impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n     type Key = ty::PolyTraitRef<'tcx>;\n     type Value = traits::Vtable<'tcx, ()>;\n     fn to_dep_node(key: &ty::PolyTraitRef<'tcx>) -> DepNode<DefId> {\n-        ty::tls::with(|tcx| {\n-            let lifted_key = tcx.lift(key).unwrap();\n-            lifted_key.to_poly_trait_predicate().dep_node()\n-        })\n+        key.to_poly_trait_predicate().dep_node()\n+    }\n+}\n+\n+/// This list owns a number of LocalCrateContexts and binds them to their common\n+/// SharedCrateContext. This type just exists as a convenience, something to\n+/// pass around all LocalCrateContexts with and get an iterator over them.\n+pub struct CrateContextList<'a, 'tcx: 'a> {\n+    shared: &'a SharedCrateContext<'a, 'tcx>,\n+    local_ccxs: Vec<LocalCrateContext<'tcx>>,\n+}\n+\n+impl<'a, 'tcx: 'a> CrateContextList<'a, 'tcx> {\n+\n+    pub fn new(shared_ccx: &'a SharedCrateContext<'a, 'tcx>,\n+               codegen_units: Vec<CodegenUnit<'tcx>>)\n+               -> CrateContextList<'a, 'tcx> {\n+        CrateContextList {\n+            shared: shared_ccx,\n+            local_ccxs: codegen_units.into_iter().map(|codegen_unit| {\n+                LocalCrateContext::new(shared_ccx, codegen_unit)\n+            }).collect()\n+        }\n+    }\n+\n+    pub fn iter<'b>(&'b self) -> CrateContextIterator<'b, 'tcx> {\n+        CrateContextIterator {\n+            shared: self.shared,\n+            index: 0,\n+            local_ccxs: &self.local_ccxs[..]\n+        }\n+    }\n+\n+    pub fn get_ccx<'b>(&'b self, index: usize) -> CrateContext<'b, 'tcx> {\n+        CrateContext {\n+            shared: self.shared,\n+            index: index,\n+            local_ccxs: &self.local_ccxs[..],\n+        }\n+    }\n+\n+    pub fn shared(&self) -> &'a SharedCrateContext<'a, 'tcx> {\n+        self.shared\n     }\n }\n \n+/// A CrateContext value binds together one LocalCrateContext with the\n+/// SharedCrateContext. It exists as a convenience wrapper, so we don't have to\n+/// pass around (SharedCrateContext, LocalCrateContext) tuples all over trans.\n pub struct CrateContext<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'a, 'tcx>,\n-    local: &'a LocalCrateContext<'tcx>,\n-    /// The index of `local` in `shared.local_ccxs`.  This is used in\n+    local_ccxs: &'a [LocalCrateContext<'tcx>],\n+    /// The index of `local` in `local_ccxs`.  This is used in\n     /// `maybe_iter(true)` to identify the original `LocalCrateContext`.\n     index: usize,\n }\n \n pub struct CrateContextIterator<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'a, 'tcx>,\n+    local_ccxs: &'a [LocalCrateContext<'tcx>],\n     index: usize,\n }\n \n impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n     type Item = CrateContext<'a, 'tcx>;\n \n     fn next(&mut self) -> Option<CrateContext<'a, 'tcx>> {\n-        if self.index >= self.shared.local_ccxs.len() {\n+        if self.index >= self.local_ccxs.len() {\n             return None;\n         }\n \n@@ -217,15 +259,16 @@ impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n \n         Some(CrateContext {\n             shared: self.shared,\n-            local: &self.shared.local_ccxs[index],\n             index: index,\n+            local_ccxs: self.local_ccxs,\n         })\n     }\n }\n \n /// The iterator produced by `CrateContext::maybe_iter`.\n pub struct CrateContextMaybeIterator<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'a, 'tcx>,\n+    local_ccxs: &'a [LocalCrateContext<'tcx>],\n     index: usize,\n     single: bool,\n     origin: usize,\n@@ -235,20 +278,20 @@ impl<'a, 'tcx> Iterator for CrateContextMaybeIterator<'a, 'tcx> {\n     type Item = (CrateContext<'a, 'tcx>, bool);\n \n     fn next(&mut self) -> Option<(CrateContext<'a, 'tcx>, bool)> {\n-        if self.index >= self.shared.local_ccxs.len() {\n+        if self.index >= self.local_ccxs.len() {\n             return None;\n         }\n \n         let index = self.index;\n         self.index += 1;\n         if self.single {\n-            self.index = self.shared.local_ccxs.len();\n+            self.index = self.local_ccxs.len();\n         }\n \n         let ccx = CrateContext {\n             shared: self.shared,\n-            local: &self.shared.local_ccxs[index],\n             index: index,\n+            local_ccxs: self.local_ccxs\n         };\n         Some((ccx, index == self.origin))\n     }\n@@ -288,9 +331,7 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n }\n \n impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n-    pub fn new(crate_name: &str,\n-               local_count: usize,\n-               tcx: &'b TyCtxt<'tcx>,\n+    pub fn new(tcx: &'b TyCtxt<'tcx>,\n                mir_map: &'b MirMap<'tcx>,\n                export_map: ExportMap,\n                symbol_hasher: Sha256,\n@@ -348,8 +389,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         // start) and then strongly recommending static linkage on MSVC!\n         let use_dll_storage_attrs = tcx.sess.target.target.options.is_like_msvc;\n \n-        let mut shared_ccx = SharedCrateContext {\n-            local_ccxs: Vec::with_capacity(local_count),\n+        SharedCrateContext {\n             metadata_llmod: metadata_llmod,\n             metadata_llcx: metadata_llcx,\n             export_map: export_map,\n@@ -378,55 +418,10 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             available_drop_glues: RefCell::new(FnvHashMap()),\n             use_dll_storage_attrs: use_dll_storage_attrs,\n             translation_items: RefCell::new(FnvHashMap()),\n-        };\n-\n-        for i in 0..local_count {\n-            // Append \".rs\" to crate name as LLVM module identifier.\n-            //\n-            // LLVM code generator emits a \".file filename\" directive\n-            // for ELF backends. Value of the \"filename\" is set as the\n-            // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n-            // crashes if the module identifier is same as other symbols\n-            // such as a function name in the module.\n-            // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-            let llmod_id = format!(\"{}.{}.rs\", crate_name, i);\n-            let local_ccx = LocalCrateContext::new(&shared_ccx, &llmod_id[..]);\n-            shared_ccx.local_ccxs.push(local_ccx);\n-        }\n-\n-        shared_ccx\n-    }\n-\n-    pub fn iter<'a>(&'a self) -> CrateContextIterator<'a, 'tcx> {\n-        CrateContextIterator {\n-            shared: self,\n-            index: 0,\n+            trait_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n         }\n     }\n \n-    pub fn get_ccx<'a>(&'a self, index: usize) -> CrateContext<'a, 'tcx> {\n-        CrateContext {\n-            shared: self,\n-            local: &self.local_ccxs[index],\n-            index: index,\n-        }\n-    }\n-\n-    fn get_smallest_ccx<'a>(&'a self) -> CrateContext<'a, 'tcx> {\n-        let (local_ccx, index) =\n-            self.local_ccxs\n-                .iter()\n-                .zip(0..self.local_ccxs.len())\n-                .min_by_key(|&(local_ccx, _idx)| local_ccx.n_llvm_insns.get())\n-                .unwrap();\n-        CrateContext {\n-            shared: self,\n-            local: local_ccx,\n-            index: index,\n-        }\n-    }\n-\n-\n     pub fn metadata_llmod(&self) -> ModuleRef {\n         self.metadata_llmod\n     }\n@@ -447,6 +442,10 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.item_symbols\n     }\n \n+    pub fn trait_cache(&self) -> &RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>> {\n+        &self.trait_cache\n+    }\n+\n     pub fn link_meta<'a>(&'a self) -> &'a LinkMeta {\n         &self.link_meta\n     }\n@@ -466,24 +465,58 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn use_dll_storage_attrs(&self) -> bool {\n         self.use_dll_storage_attrs\n     }\n+\n+    pub fn get_mir(&self, def_id: DefId) -> Option<CachedMir<'b, 'tcx>> {\n+        if def_id.is_local() {\n+            let node_id = self.tcx.map.as_local_node_id(def_id).unwrap();\n+            self.mir_map.map.get(&node_id).map(CachedMir::Ref)\n+        } else {\n+            if let Some(mir) = self.mir_cache.borrow().get(&def_id).cloned() {\n+                return Some(CachedMir::Owned(mir));\n+            }\n+\n+            let mir = self.sess().cstore.maybe_get_item_mir(self.tcx, def_id);\n+            let cached = mir.map(Rc::new);\n+            if let Some(ref mir) = cached {\n+                self.mir_cache.borrow_mut().insert(def_id, mir.clone());\n+            }\n+            cached.map(CachedMir::Owned)\n+        }\n+    }\n+\n+    pub fn translation_items(&self) -> &RefCell<FnvHashMap<TransItem<'tcx>, TransItemState>> {\n+        &self.translation_items\n+    }\n }\n \n impl<'tcx> LocalCrateContext<'tcx> {\n     fn new<'a>(shared: &SharedCrateContext<'a, 'tcx>,\n-           name: &str)\n+               codegen_unit: CodegenUnit<'tcx>)\n            -> LocalCrateContext<'tcx> {\n         unsafe {\n-            let (llcx, llmod) = create_context_and_module(&shared.tcx.sess, name);\n+            // Append \".rs\" to LLVM module identifier.\n+            //\n+            // LLVM code generator emits a \".file filename\" directive\n+            // for ELF backends. Value of the \"filename\" is set as the\n+            // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n+            // crashes if the module identifier is same as other symbols\n+            // such as a function name in the module.\n+            // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n+            let llmod_id = format!(\"{}.rs\", codegen_unit.name);\n+\n+            let (llcx, llmod) = create_context_and_module(&shared.tcx.sess,\n+                                                          &llmod_id[..]);\n \n             let dbg_cx = if shared.tcx.sess.opts.debuginfo != NoDebugInfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod))\n             } else {\n                 None\n             };\n \n-            let mut local_ccx = LocalCrateContext {\n+            let local_ccx = LocalCrateContext {\n                 llmod: llmod,\n                 llcx: llcx,\n+                codegen_unit: codegen_unit,\n                 tn: TypeNames::new(),\n                 needs_unwind_cleanup_cache: RefCell::new(FnvHashMap()),\n                 fn_pointer_shims: RefCell::new(FnvHashMap()),\n@@ -517,26 +550,30 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 intrinsics: RefCell::new(FnvHashMap()),\n                 n_llvm_insns: Cell::new(0),\n                 type_of_depth: Cell::new(0),\n-                trait_cache: RefCell::new(DepTrackingMap::new(shared.tcx\n-                                                                    .dep_graph\n-                                                                    .clone())),\n             };\n \n-            local_ccx.int_type = Type::int(&local_ccx.dummy_ccx(shared));\n-            local_ccx.opaque_vec_type = Type::opaque_vec(&local_ccx.dummy_ccx(shared));\n-\n-            // Done mutating local_ccx directly.  (The rest of the\n-            // initialization goes through RefCell.)\n-            {\n-                let ccx = local_ccx.dummy_ccx(shared);\n+            let (int_type, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n+                // Do a little dance to create a dummy CrateContext, so we can\n+                // create some things in the LLVM module of this codegen unit\n+                let mut local_ccxs = vec![local_ccx];\n+                let (int_type, opaque_vec_type, str_slice_ty) = {\n+                    let dummy_ccx = LocalCrateContext::dummy_ccx(shared,\n+                                                                 local_ccxs.as_mut_slice());\n+                    let mut str_slice_ty = Type::named_struct(&dummy_ccx, \"str_slice\");\n+                    str_slice_ty.set_struct_body(&[Type::i8p(&dummy_ccx),\n+                                                   Type::int(&dummy_ccx)],\n+                                                 false);\n+                    (Type::int(&dummy_ccx), Type::opaque_vec(&dummy_ccx), str_slice_ty)\n+                };\n+                (int_type, opaque_vec_type, str_slice_ty, local_ccxs.pop().unwrap())\n+            };\n \n-                let mut str_slice_ty = Type::named_struct(&ccx, \"str_slice\");\n-                str_slice_ty.set_struct_body(&[Type::i8p(&ccx), ccx.int_type()], false);\n-                ccx.tn().associate_type(\"str_slice\", &str_slice_ty);\n+            local_ccx.int_type = int_type;\n+            local_ccx.opaque_vec_type = opaque_vec_type;\n+            local_ccx.tn.associate_type(\"str_slice\", &str_slice_ty);\n \n-                if ccx.sess().count_llvm_insns() {\n-                    base::init_insn_ctxt()\n-                }\n+            if shared.tcx.sess.count_llvm_insns() {\n+                base::init_insn_ctxt()\n             }\n \n             local_ccx\n@@ -545,18 +582,19 @@ impl<'tcx> LocalCrateContext<'tcx> {\n \n     /// Create a dummy `CrateContext` from `self` and  the provided\n     /// `SharedCrateContext`.  This is somewhat dangerous because `self` may\n-    /// not actually be an element of `shared.local_ccxs`, which can cause some\n-    /// operations to panic unexpectedly.\n+    /// not be fully initialized.\n     ///\n     /// This is used in the `LocalCrateContext` constructor to allow calling\n     /// functions that expect a complete `CrateContext`, even before the local\n     /// portion is fully initialized and attached to the `SharedCrateContext`.\n-    fn dummy_ccx<'a>(&'a self, shared: &'a SharedCrateContext<'a, 'tcx>)\n+    fn dummy_ccx<'a>(shared: &'a SharedCrateContext<'a, 'tcx>,\n+                     local_ccxs: &'a [LocalCrateContext<'tcx>])\n                      -> CrateContext<'a, 'tcx> {\n+        assert!(local_ccxs.len() == 1);\n         CrateContext {\n             shared: shared,\n-            local: self,\n-            index: !0 as usize,\n+            index: 0,\n+            local_ccxs: local_ccxs\n         }\n     }\n }\n@@ -567,13 +605,23 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn local(&self) -> &'b LocalCrateContext<'tcx> {\n-        self.local\n+        &self.local_ccxs[self.index]\n     }\n \n     /// Get a (possibly) different `CrateContext` from the same\n     /// `SharedCrateContext`.\n-    pub fn rotate(&self) -> CrateContext<'b, 'tcx> {\n-        self.shared.get_smallest_ccx()\n+    pub fn rotate(&'b self) -> CrateContext<'b, 'tcx> {\n+        let (_, index) =\n+            self.local_ccxs\n+                .iter()\n+                .zip(0..self.local_ccxs.len())\n+                .min_by_key(|&(local_ccx, _idx)| local_ccx.n_llvm_insns.get())\n+                .unwrap();\n+        CrateContext {\n+            shared: self.shared,\n+            index: index,\n+            local_ccxs: &self.local_ccxs[..],\n+        }\n     }\n \n     /// Either iterate over only `self`, or iterate over all `CrateContext`s in\n@@ -588,10 +636,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n             index: if iter_all { 0 } else { self.index },\n             single: !iter_all,\n             origin: self.index,\n+            local_ccxs: self.local_ccxs,\n         }\n     }\n \n-\n     pub fn tcx<'a>(&'a self) -> &'a TyCtxt<'tcx> {\n         self.shared.tcx\n     }\n@@ -605,7 +653,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn raw_builder<'a>(&'a self) -> BuilderRef {\n-        self.local.builder.b\n+        self.local().builder.b\n     }\n \n     pub fn get_intrinsic(&self, key: &str) -> ValueRef {\n@@ -619,19 +667,23 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn llmod(&self) -> ModuleRef {\n-        self.local.llmod\n+        self.local().llmod\n     }\n \n     pub fn llcx(&self) -> ContextRef {\n-        self.local.llcx\n+        self.local().llcx\n+    }\n+\n+    pub fn codegen_unit(&self) -> &CodegenUnit<'tcx> {\n+        &self.local().codegen_unit\n     }\n \n     pub fn td(&self) -> llvm::TargetDataRef {\n         unsafe { llvm::LLVMRustGetModuleDataLayout(self.llmod()) }\n     }\n \n     pub fn tn<'a>(&'a self) -> &'a TypeNames {\n-        &self.local.tn\n+        &self.local().tn\n     }\n \n     pub fn export_map<'a>(&'a self) -> &'a ExportMap {\n@@ -651,93 +703,93 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn needs_unwind_cleanup_cache(&self) -> &RefCell<FnvHashMap<Ty<'tcx>, bool>> {\n-        &self.local.needs_unwind_cleanup_cache\n+        &self.local().needs_unwind_cleanup_cache\n     }\n \n     pub fn fn_pointer_shims(&self) -> &RefCell<FnvHashMap<Ty<'tcx>, ValueRef>> {\n-        &self.local.fn_pointer_shims\n+        &self.local().fn_pointer_shims\n     }\n \n     pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<DropGlueKind<'tcx>, ValueRef>> {\n-        &self.local.drop_glues\n+        &self.local().drop_glues\n     }\n \n     pub fn external<'a>(&'a self) -> &'a RefCell<DefIdMap<Option<ast::NodeId>>> {\n-        &self.local.external\n+        &self.local().external\n     }\n \n     pub fn external_srcs<'a>(&'a self) -> &'a RefCell<NodeMap<DefId>> {\n-        &self.local.external_srcs\n+        &self.local().external_srcs\n     }\n \n     pub fn instances<'a>(&'a self) -> &'a RefCell<FnvHashMap<Instance<'tcx>, ValueRef>> {\n-        &self.local.instances\n+        &self.local().instances\n     }\n \n     pub fn monomorphizing<'a>(&'a self) -> &'a RefCell<DefIdMap<usize>> {\n-        &self.local.monomorphizing\n+        &self.local().monomorphizing\n     }\n \n     pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>> {\n-        &self.local.vtables\n+        &self.local().vtables\n     }\n \n     pub fn const_cstr_cache<'a>(&'a self) -> &'a RefCell<FnvHashMap<InternedString, ValueRef>> {\n-        &self.local.const_cstr_cache\n+        &self.local().const_cstr_cache\n     }\n \n     pub fn const_unsized<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n-        &self.local.const_unsized\n+        &self.local().const_unsized\n     }\n \n     pub fn const_globals<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n-        &self.local.const_globals\n+        &self.local().const_globals\n     }\n \n     pub fn const_values<'a>(&'a self) -> &'a RefCell<FnvHashMap<(ast::NodeId, &'tcx Substs<'tcx>),\n                                                                 ValueRef>> {\n-        &self.local.const_values\n+        &self.local().const_values\n     }\n \n     pub fn extern_const_values<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n-        &self.local.extern_const_values\n+        &self.local().extern_const_values\n     }\n \n     pub fn statics<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, DefId>> {\n-        &self.local.statics\n+        &self.local().statics\n     }\n \n     pub fn impl_method_cache<'a>(&'a self)\n             -> &'a RefCell<FnvHashMap<(DefId, ast::Name), DefId>> {\n-        &self.local.impl_method_cache\n+        &self.local().impl_method_cache\n     }\n \n     pub fn closure_bare_wrapper_cache<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n-        &self.local.closure_bare_wrapper_cache\n+        &self.local().closure_bare_wrapper_cache\n     }\n \n     pub fn statics_to_rauw<'a>(&'a self) -> &'a RefCell<Vec<(ValueRef, ValueRef)>> {\n-        &self.local.statics_to_rauw\n+        &self.local().statics_to_rauw\n     }\n \n     pub fn lltypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Type>> {\n-        &self.local.lltypes\n+        &self.local().lltypes\n     }\n \n     pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Type>> {\n-        &self.local.llsizingtypes\n+        &self.local().llsizingtypes\n     }\n \n     pub fn adt_reprs<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Rc<adt::Repr<'tcx>>>> {\n-        &self.local.adt_reprs\n+        &self.local().adt_reprs\n     }\n \n     pub fn symbol_hasher<'a>(&'a self) -> &'a RefCell<Sha256> {\n         &self.shared.symbol_hasher\n     }\n \n     pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, String>> {\n-        &self.local.type_hashcodes\n+        &self.local().type_hashcodes\n     }\n \n     pub fn stats<'a>(&'a self) -> &'a Stats {\n@@ -753,43 +805,39 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn int_type(&self) -> Type {\n-        self.local.int_type\n+        self.local().int_type\n     }\n \n     pub fn opaque_vec_type(&self) -> Type {\n-        self.local.opaque_vec_type\n+        self.local().opaque_vec_type\n     }\n \n     pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<Instance<'tcx>, ValueRef>> {\n-        &self.local.closure_vals\n+        &self.local().closure_vals\n     }\n \n     pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext<'tcx>> {\n-        &self.local.dbg_cx\n+        &self.local().dbg_cx\n     }\n \n     pub fn eh_personality<'a>(&'a self) -> &'a Cell<Option<ValueRef>> {\n-        &self.local.eh_personality\n+        &self.local().eh_personality\n     }\n \n     pub fn eh_unwind_resume<'a>(&'a self) -> &'a Cell<Option<ValueRef>> {\n-        &self.local.eh_unwind_resume\n+        &self.local().eh_unwind_resume\n     }\n \n     pub fn rust_try_fn<'a>(&'a self) -> &'a Cell<Option<ValueRef>> {\n-        &self.local.rust_try_fn\n+        &self.local().rust_try_fn\n     }\n \n     fn intrinsics<'a>(&'a self) -> &'a RefCell<FnvHashMap<&'static str, ValueRef>> {\n-        &self.local.intrinsics\n+        &self.local().intrinsics\n     }\n \n     pub fn count_llvm_insn(&self) {\n-        self.local.n_llvm_insns.set(self.local.n_llvm_insns.get() + 1);\n-    }\n-\n-    pub fn trait_cache(&self) -> &RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>> {\n-        &self.local.trait_cache\n+        self.local().n_llvm_insns.set(self.local().n_llvm_insns.get() + 1);\n     }\n \n     pub fn obj_size_bound(&self) -> u64 {\n@@ -803,14 +851,14 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn enter_type_of(&self, ty: Ty<'tcx>) -> TypeOfDepthLock<'b, 'tcx> {\n-        let current_depth = self.local.type_of_depth.get();\n+        let current_depth = self.local().type_of_depth.get();\n         debug!(\"enter_type_of({:?}) at depth {:?}\", ty, current_depth);\n         if current_depth > self.sess().recursion_limit.get() {\n             self.sess().fatal(\n                 &format!(\"overflow representing the type `{}`\", ty))\n         }\n-        self.local.type_of_depth.set(current_depth + 1);\n-        TypeOfDepthLock(self.local)\n+        self.local().type_of_depth.set(current_depth + 1);\n+        TypeOfDepthLock(self.local())\n     }\n \n     pub fn check_overflow(&self) -> bool {\n@@ -829,21 +877,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn get_mir(&self, def_id: DefId) -> Option<CachedMir<'b, 'tcx>> {\n-        if def_id.is_local() {\n-            let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n-            self.shared.mir_map.map.get(&node_id).map(CachedMir::Ref)\n-        } else {\n-            if let Some(mir) = self.shared.mir_cache.borrow().get(&def_id).cloned() {\n-                return Some(CachedMir::Owned(mir));\n-            }\n-\n-            let mir = self.sess().cstore.maybe_get_item_mir(self.tcx(), def_id);\n-            let cached = mir.map(Rc::new);\n-            if let Some(ref mir) = cached {\n-                self.shared.mir_cache.borrow_mut().insert(def_id, mir.clone());\n-            }\n-            cached.map(CachedMir::Owned)\n-        }\n+        self.shared.get_mir(def_id)\n     }\n \n     pub fn translation_items(&self) -> &RefCell<FnvHashMap<TransItem<'tcx>, TransItemState>> {"}, {"sha": "edb3d167ddeb0a3d62983ace638ec4a8e925a214", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=1939b76903eb8a4aa02dadc52353541637e3b98c", "patch": "@@ -510,7 +510,9 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let source = unpack_datum!(bcx, source.to_ref_datum(bcx));\n             assert!(target.kind.is_by_ref());\n \n-            let kind = custom_coerce_unsize_info(bcx.ccx(), source.ty, target.ty);\n+            let kind = custom_coerce_unsize_info(bcx.ccx().shared(),\n+                                                 source.ty,\n+                                                 target.ty);\n \n             let repr_source = adt::represent_type(bcx.ccx(), source.ty);\n             let src_fields = match &*repr_source {"}, {"sha": "898ac636c1d431246895eeede989b15fcc36c8c8", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=1939b76903eb8a4aa02dadc52353541637e3b98c", "patch": "@@ -19,7 +19,7 @@ use llvm;\n use llvm::{ValueRef, get_param};\n use middle::lang_items::ExchangeFreeFnLangItem;\n use rustc::ty::subst::{Substs};\n-use rustc::traits;\n+use rustc::{infer, traits};\n use rustc::ty::{self, Ty, TyCtxt};\n use abi::{Abi, FnType};\n use adt;\n@@ -92,13 +92,12 @@ pub fn type_needs_drop<'tcx>(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     tcx.type_needs_drop_given_env(ty, &tcx.empty_parameter_environment())\n }\n \n-pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                    t: Ty<'tcx>) -> Ty<'tcx> {\n-    let tcx = ccx.tcx();\n+pub fn get_drop_glue_type<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                t: Ty<'tcx>) -> Ty<'tcx> {\n     // Even if there is no dtor for t, there might be one deeper down and we\n     // might need to pass in the vtable ptr.\n     if !type_is_sized(tcx, t) {\n-        return ccx.tcx().erase_regions(&t);\n+        return tcx.erase_regions(&t);\n     }\n \n     // FIXME (#22815): note that type_needs_drop conservatively\n@@ -116,15 +115,18 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     match t.sty {\n         ty::TyBox(typ) if !type_needs_drop(&tcx, typ)\n                          && type_is_sized(tcx, typ) => {\n-            let llty = sizing_type_of(ccx, typ);\n-            // `Box<ZeroSizeType>` does not allocate.\n-            if llsize_of_alloc(ccx, llty) == 0 {\n+            let infcx = infer::normalizing_infer_ctxt(tcx,\n+                                                      &tcx.tables,\n+                                                      traits::ProjectionMode::Any);\n+            let layout = t.layout(&infcx).unwrap();\n+            if layout.size(&tcx.data_layout).bytes() == 0 {\n+                // `Box<ZeroSizeType>` does not allocate.\n                 tcx.types.i8\n             } else {\n-                ccx.tcx().erase_regions(&t)\n+                tcx.erase_regions(&t)\n             }\n         }\n-        _ => ccx.tcx().erase_regions(&t)\n+        _ => tcx.erase_regions(&t)\n     }\n }\n \n@@ -154,7 +156,7 @@ pub fn drop_ty_core<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             DropGlueKind::Ty(t)\n         };\n         let glue = get_drop_glue_core(ccx, g);\n-        let glue_type = get_drop_glue_type(ccx, t);\n+        let glue_type = get_drop_glue_type(ccx.tcx(), t);\n         let ptr = if glue_type != t {\n             PointerCast(bcx, v, type_of(ccx, glue_type).ptr_to())\n         } else {\n@@ -231,7 +233,7 @@ impl<'tcx> DropGlueKind<'tcx> {\n fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 g: DropGlueKind<'tcx>) -> ValueRef {\n     debug!(\"make drop glue for {:?}\", g);\n-    let g = g.map_ty(|t| get_drop_glue_type(ccx, t));\n+    let g = g.map_ty(|t| get_drop_glue_type(ccx.tcx(), t));\n     debug!(\"drop glue type {:?}\", g);\n     match ccx.drop_glues().borrow().get(&g) {\n         Some(&glue) => return glue,\n@@ -364,7 +366,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         def_id: tcx.lang_items.drop_trait().unwrap(),\n         substs: tcx.mk_substs(Substs::empty().with_self_ty(t))\n     });\n-    let vtbl = match fulfill_obligation(bcx.ccx(), DUMMY_SP, trait_ref) {\n+    let vtbl = match fulfill_obligation(bcx.ccx().shared(), DUMMY_SP, trait_ref) {\n         traits::VtableImpl(data) => data,\n         _ => bug!(\"dtor for {:?} is not an impl???\", t)\n     };\n@@ -487,7 +489,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n \n fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueKind<'tcx>)\n                               -> Block<'blk, 'tcx> {\n-    if collector::collecting_debug_information(bcx.ccx()) {\n+    if collector::collecting_debug_information(bcx.ccx().shared()) {\n         bcx.ccx()\n            .record_translation_item_as_generated(TransItem::DropGlue(g));\n     }"}, {"sha": "648a232ef6946728b0963c8656bec560b68754eb", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=1939b76903eb8a4aa02dadc52353541637e3b98c", "patch": "@@ -144,7 +144,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Not in the cache. Build it.\n     let methods = traits::supertraits(tcx, trait_ref.clone()).flat_map(|trait_ref| {\n-        let vtable = fulfill_obligation(ccx, DUMMY_SP, trait_ref.clone());\n+        let vtable = fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref.clone());\n         match vtable {\n             // Should default trait error here?\n             traits::VtableDefaultImpl(_) |\n@@ -157,7 +157,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     substs,\n                     nested: _ }) => {\n                 let nullptr = C_null(Type::nil(ccx).ptr_to());\n-                get_vtable_methods(ccx, id, substs)\n+                get_vtable_methods(tcx, id, substs)\n                     .into_iter()\n                     .map(|opt_mth| opt_mth.map_or(nullptr, |mth| {\n                         Callee::def(ccx, mth.method.def_id, &mth.substs).reify(ccx).val\n@@ -215,13 +215,11 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     vtable\n }\n \n-pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                    impl_id: DefId,\n-                                    substs: &'tcx subst::Substs<'tcx>)\n-                                    -> Vec<Option<ImplMethod<'tcx>>>\n+pub fn get_vtable_methods<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                impl_id: DefId,\n+                                substs: &'tcx subst::Substs<'tcx>)\n+                                -> Vec<Option<ImplMethod<'tcx>>>\n {\n-    let tcx = ccx.tcx();\n-\n     debug!(\"get_vtable_methods(impl_id={:?}, substs={:?}\", impl_id, substs);\n \n     let trt_id = match tcx.impl_trait_ref(impl_id) {\n@@ -287,7 +285,7 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // try and trans it, in that case. Issue #23435.\n             if mth.is_provided {\n                 let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n-                if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n+                if !normalize_and_test_predicates(tcx, predicates.into_vec()) {\n                     debug!(\"get_vtable_methods: predicates do not hold\");\n                     return None;\n                 }"}, {"sha": "39bf0da5cf957236075448c1757bb67c65ca514b", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=1939b76903eb8a4aa02dadc52353541637e3b98c", "patch": "@@ -136,7 +136,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     return;\n                 }\n                 let drop_fn = glue::get_drop_glue(bcx.ccx(), ty);\n-                let drop_ty = glue::get_drop_glue_type(bcx.ccx(), ty);\n+                let drop_ty = glue::get_drop_glue_type(bcx.tcx(), ty);\n                 let llvalue = if drop_ty != ty {\n                     bcx.pointercast(lvalue.llval, type_of::type_of(bcx.ccx(), drop_ty).ptr_to())\n                 } else {"}, {"sha": "267d9e9a23a664c18f6a8ba3816a43ecb85ab113", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=1939b76903eb8a4aa02dadc52353541637e3b98c", "patch": "@@ -233,7 +233,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             let trait_id = trait_item.container().id();\n             let substs = instance.substs;\n             let trait_ref = ty::Binder(substs.to_trait_ref(ccx.tcx(), trait_id));\n-            let vtable = common::fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n+            let vtable = common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref);\n             if let traits::VtableImpl(vtable_impl) = vtable {\n                 let name = ccx.tcx().item_name(instance.def);\n                 for ac in ccx.tcx().associated_consts(vtable_impl.impl_def_id) {"}, {"sha": "7b21b612097597eff5e12ce0bd8b2a2f71610313", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1939b76903eb8a4aa02dadc52353541637e3b98c/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=1939b76903eb8a4aa02dadc52353541637e3b98c", "patch": "@@ -256,10 +256,6 @@ fn place_root_translation_items<'tcx, I>(tcx: &TyCtxt<'tcx>,\n fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n                              target_cgu_count: usize,\n                              crate_name: &str) {\n-    if target_cgu_count >= initial_partitioning.codegen_units.len() {\n-        return;\n-    }\n-\n     assert!(target_cgu_count >= 1);\n     let codegen_units = &mut initial_partitioning.codegen_units;\n \n@@ -278,7 +274,22 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<\n     }\n \n     for (index, cgu) in codegen_units.iter_mut().enumerate() {\n-        cgu.name = token::intern_and_get_ident(&format!(\"{}.{}\", crate_name, index)[..]);\n+        cgu.name = numbered_codegen_unit_name(crate_name, index);\n+    }\n+\n+    // If the initial partitioning contained less than target_cgu_count to begin\n+    // with, we won't have enough codegen units here, so add a empty units until\n+    // we reach the target count\n+    while codegen_units.len() < target_cgu_count {\n+        let index = codegen_units.len();\n+        codegen_units.push(CodegenUnit {\n+            name: numbered_codegen_unit_name(crate_name, index),\n+            items: FnvHashMap()\n+        });\n+    }\n+\n+    fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString {\n+        token::intern_and_get_ident(&format!(\"{}.{}\", crate_name, index)[..])\n     }\n }\n "}]}