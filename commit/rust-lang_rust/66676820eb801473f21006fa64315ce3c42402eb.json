{"sha": "66676820eb801473f21006fa64315ce3c42402eb", "node_id": "C_kwDOAAsO6NoAKDY2Njc2ODIwZWI4MDE0NzNmMjEwMDZmYTY0MzE1Y2UzYzQyNDAyZWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-21T14:33:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-21T14:33:14Z"}, "message": "Auto merge of #108659 - ferrocene:pa-test-metrics, r=Mark-Simulacrum\n\nInclude executed tests in the build metrics (and use a custom test display impl)\n\nThe main goal of this PR is to include all tests executed in CI inside the build metrics JSON files. I need this for Ferrocene, and `@Mark-Simulacrum` expressed desire to have this as well to ensure all tests are executed at least once somewhere in CI.\n\nUnfortunately implementing this required rewriting inside of bootstrap all of the code to render the test output to console. libtest supports outputting JSON instead of raw text, which we can indeed use to populate the build metrics. Doing that suppresses the console output though, and compared to rustc and Cargo the console output is not included as a JSON field.\n\nBecause of that, this PR had to reimplement both the \"pretty\" format (one test per line, with `rust.verbose-tests = true`), and the \"terse\" format (the wall of dots, with `rust.verbose-tests = false`). The current implementation should have the exact same output as libtest, except for the benchmark output. libtest's benchmark output is broken in the \"terse\" format, so since that's our default I slightly improved how it's rendered.\n\nAlso, to bring parity with libtest I had to introduce support for coloring output from bootstrap, using the same dependencies `annotate-snippets` uses. It's now possible to use `builder.color_for_stdout(Color::Red, \"text\")` and `builder.color_for_stderr(Color::Green, \"text\")` across all of bootstrap, automatically respecting the `--color` flag and whether the stream is a terminal or not.\n\nI recommend reviewing the PR commit-by-commit.\nr? `@Mark-Simulacrum`", "tree": {"sha": "f930681036fde2a0c527ea70d12e66a3bd0b841a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f930681036fde2a0c527ea70d12e66a3bd0b841a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66676820eb801473f21006fa64315ce3c42402eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66676820eb801473f21006fa64315ce3c42402eb", "html_url": "https://github.com/rust-lang/rust/commit/66676820eb801473f21006fa64315ce3c42402eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66676820eb801473f21006fa64315ce3c42402eb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "url": "https://api.github.com/repos/rust-lang/rust/commits/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "html_url": "https://github.com/rust-lang/rust/commit/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34"}, {"sha": "aacbd8671b316a0fb79af71121d723ce25e703d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/aacbd8671b316a0fb79af71121d723ce25e703d2", "html_url": "https://github.com/rust-lang/rust/commit/aacbd8671b316a0fb79af71121d723ce25e703d2"}], "stats": {"total": 542, "additions": 504, "deletions": 38}, "files": [{"sha": "27236e191fdebb8589c97a62e10c4d30b320fe3d", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/66676820eb801473f21006fa64315ce3c42402eb/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/66676820eb801473f21006fa64315ce3c42402eb/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=66676820eb801473f21006fa64315ce3c42402eb", "patch": "@@ -11,6 +11,17 @@ dependencies = [\n  \"memchr\",\n ]\n \n+[[package]]\n+name = \"atty\"\n+version = \"0.2.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8\"\n+dependencies = [\n+ \"hermit-abi\",\n+ \"libc\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"autocfg\"\n version = \"1.1.0\"\n@@ -36,6 +47,7 @@ dependencies = [\n name = \"bootstrap\"\n version = \"0.0.0\"\n dependencies = [\n+ \"atty\",\n  \"build_helper\",\n  \"cc\",\n  \"cmake\",\n@@ -55,6 +67,7 @@ dependencies = [\n  \"sha2\",\n  \"sysinfo\",\n  \"tar\",\n+ \"termcolor\",\n  \"toml\",\n  \"walkdir\",\n  \"windows\",\n@@ -636,6 +649,15 @@ dependencies = [\n  \"xattr\",\n ]\n \n+[[package]]\n+name = \"termcolor\"\n+version = \"1.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"be55cf8942feac5c765c2c993422806843c9a9a45d4d5c407ad6dd2ea95eb9b6\"\n+dependencies = [\n+ \"winapi-util\",\n+]\n+\n [[package]]\n name = \"thread_local\"\n version = \"1.1.4\""}, {"sha": "5c659800bdb6c15413827384d991168cdfefd838", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66676820eb801473f21006fa64315ce3c42402eb/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66676820eb801473f21006fa64315ce3c42402eb/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=66676820eb801473f21006fa64315ce3c42402eb", "patch": "@@ -30,6 +30,7 @@ path = \"bin/sccache-plus-cl.rs\"\n test = false\n \n [dependencies]\n+atty = \"0.2.14\"\n build_helper = { path = \"../tools/build_helper\" }\n cmake = \"0.1.38\"\n filetime = \"0.2\"\n@@ -45,6 +46,7 @@ serde_derive = \"1.0.137\"\n serde_json = \"1.0.2\"\n sha2 = \"0.10\"\n tar = \"0.4\"\n+termcolor = \"1.2.0\"\n toml = \"0.5\"\n ignore = \"0.4.10\"\n opener = \"0.5\""}, {"sha": "95625170478f66a162cdf310f795e6b2e0085689", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66676820eb801473f21006fa64315ce3c42402eb/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66676820eb801473f21006fa64315ce3c42402eb/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=66676820eb801473f21006fa64315ce3c42402eb", "patch": "@@ -87,6 +87,9 @@ pub struct Config {\n     pub patch_binaries_for_nix: bool,\n     pub stage0_metadata: Stage0Metadata,\n \n+    pub stdout_is_tty: bool,\n+    pub stderr_is_tty: bool,\n+\n     pub on_fail: Option<String>,\n     pub stage: u32,\n     pub keep_stage: Vec<u32>,\n@@ -825,6 +828,9 @@ impl Config {\n         config.dist_include_mingw_linker = true;\n         config.dist_compression_profile = \"fast\".into();\n \n+        config.stdout_is_tty = atty::is(atty::Stream::Stdout);\n+        config.stderr_is_tty = atty::is(atty::Stream::Stderr);\n+\n         // set by build.rs\n         config.build = TargetSelection::from_user(&env!(\"BUILD_TRIPLE\"));\n "}, {"sha": "47a970c782e53aaa8a6dfea267f113eb990429da", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/66676820eb801473f21006fa64315ce3c42402eb/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66676820eb801473f21006fa64315ce3c42402eb/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=66676820eb801473f21006fa64315ce3c42402eb", "patch": "@@ -55,6 +55,7 @@ mod format;\n mod install;\n mod metadata;\n mod native;\n+mod render_tests;\n mod run;\n mod sanity;\n mod setup;\n@@ -88,6 +89,7 @@ pub use crate::builder::PathSet;\n use crate::cache::{Interned, INTERNER};\n pub use crate::config::Config;\n pub use crate::flags::Subcommand;\n+use termcolor::{ColorChoice, StandardStream, WriteColor};\n \n const LLVM_TOOLS: &[&str] = &[\n     \"llvm-cov\",      // used to generate coverage report\n@@ -1582,6 +1584,31 @@ to download LLVM rather than building it.\n \n         self.config.ninja_in_file\n     }\n+\n+    pub fn colored_stdout<R, F: FnOnce(&mut dyn WriteColor) -> R>(&self, f: F) -> R {\n+        self.colored_stream_inner(StandardStream::stdout, self.config.stdout_is_tty, f)\n+    }\n+\n+    pub fn colored_stderr<R, F: FnOnce(&mut dyn WriteColor) -> R>(&self, f: F) -> R {\n+        self.colored_stream_inner(StandardStream::stderr, self.config.stderr_is_tty, f)\n+    }\n+\n+    fn colored_stream_inner<R, F, C>(&self, constructor: C, is_tty: bool, f: F) -> R\n+    where\n+        C: Fn(ColorChoice) -> StandardStream,\n+        F: FnOnce(&mut dyn WriteColor) -> R,\n+    {\n+        let choice = match self.config.color {\n+            flags::Color::Always => ColorChoice::Always,\n+            flags::Color::Never => ColorChoice::Never,\n+            flags::Color::Auto if !is_tty => ColorChoice::Never,\n+            flags::Color::Auto => ColorChoice::Auto,\n+        };\n+        let mut stream = constructor(choice);\n+        let result = f(&mut stream);\n+        stream.reset().unwrap();\n+        result\n+    }\n }\n \n #[cfg(unix)]"}, {"sha": "5f254761aa19f21c18f6360e9e6008eec5422b70", "filename": "src/bootstrap/metrics.rs", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/66676820eb801473f21006fa64315ce3c42402eb/src%2Fbootstrap%2Fmetrics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66676820eb801473f21006fa64315ce3c42402eb/src%2Fbootstrap%2Fmetrics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetrics.rs?ref=66676820eb801473f21006fa64315ce3c42402eb", "patch": "@@ -51,6 +51,7 @@ impl BuildMetrics {\n             duration_excluding_children_sec: Duration::ZERO,\n \n             children: Vec::new(),\n+            tests: Vec::new(),\n         });\n     }\n \n@@ -72,6 +73,16 @@ impl BuildMetrics {\n         }\n     }\n \n+    pub(crate) fn record_test(&self, name: &str, outcome: TestOutcome) {\n+        let mut state = self.state.borrow_mut();\n+        state\n+            .running_steps\n+            .last_mut()\n+            .unwrap()\n+            .tests\n+            .push(Test { name: name.to_string(), outcome });\n+    }\n+\n     fn collect_stats(&self, state: &mut MetricsState) {\n         let step = state.running_steps.last_mut().unwrap();\n \n@@ -125,6 +136,14 @@ impl BuildMetrics {\n     }\n \n     fn prepare_json_step(&self, step: StepMetrics) -> JsonNode {\n+        let mut children = Vec::new();\n+        children.extend(step.children.into_iter().map(|child| self.prepare_json_step(child)));\n+        children.extend(\n+            step.tests\n+                .into_iter()\n+                .map(|test| JsonNode::Test { name: test.name, outcome: test.outcome }),\n+        );\n+\n         JsonNode::RustbuildStep {\n             type_: step.type_,\n             debug_repr: step.debug_repr,\n@@ -135,11 +154,7 @@ impl BuildMetrics {\n                     / step.duration_excluding_children_sec.as_secs_f64(),\n             },\n \n-            children: step\n-                .children\n-                .into_iter()\n-                .map(|child| self.prepare_json_step(child))\n-                .collect(),\n+            children,\n         }\n     }\n }\n@@ -161,6 +176,12 @@ struct StepMetrics {\n     duration_excluding_children_sec: Duration,\n \n     children: Vec<StepMetrics>,\n+    tests: Vec<Test>,\n+}\n+\n+struct Test {\n+    name: String,\n+    outcome: TestOutcome,\n }\n \n #[derive(Serialize, Deserialize)]\n@@ -190,6 +211,19 @@ enum JsonNode {\n \n         children: Vec<JsonNode>,\n     },\n+    Test {\n+        name: String,\n+        #[serde(flatten)]\n+        outcome: TestOutcome,\n+    },\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(tag = \"outcome\", rename_all = \"snake_case\")]\n+pub(crate) enum TestOutcome {\n+    Passed,\n+    Failed,\n+    Ignored { ignore_reason: Option<String> },\n }\n \n #[derive(Serialize, Deserialize)]"}, {"sha": "af2370d439e6b1d1df65acdd9fda2733ac942a42", "filename": "src/bootstrap/render_tests.rs", "status": "added", "additions": 376, "deletions": 0, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/66676820eb801473f21006fa64315ce3c42402eb/src%2Fbootstrap%2Frender_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66676820eb801473f21006fa64315ce3c42402eb/src%2Fbootstrap%2Frender_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frender_tests.rs?ref=66676820eb801473f21006fa64315ce3c42402eb", "patch": "@@ -0,0 +1,376 @@\n+//! This module renders the JSON output of libtest into a human-readable form, trying to be as\n+//! similar to libtest's native output as possible.\n+//!\n+//! This is needed because we need to use libtest in JSON mode to extract granluar information\n+//! about the executed tests. Doing so suppresses the human-readable output, and (compared to Cargo\n+//! and rustc) libtest doesn't include the rendered human-readable output as a JSON field. We had\n+//! to reimplement all the rendering logic in this module because of that.\n+\n+use crate::builder::Builder;\n+use std::io::{BufRead, BufReader, Write};\n+use std::process::{ChildStdout, Command, Stdio};\n+use std::time::Duration;\n+use termcolor::{Color, ColorSpec, WriteColor};\n+\n+const TERSE_TESTS_PER_LINE: usize = 88;\n+\n+pub(crate) fn add_flags_and_try_run_tests(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n+    if cmd.get_args().position(|arg| arg == \"--\").is_none() {\n+        cmd.arg(\"--\");\n+    }\n+    cmd.args(&[\"-Z\", \"unstable-options\", \"--format\", \"json\"]);\n+\n+    try_run_tests(builder, cmd)\n+}\n+\n+pub(crate) fn try_run_tests(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n+    if builder.config.dry_run() {\n+        return true;\n+    }\n+\n+    if !run_tests(builder, cmd) {\n+        if builder.fail_fast {\n+            crate::detail_exit(1);\n+        } else {\n+            let mut failures = builder.delayed_failures.borrow_mut();\n+            failures.push(format!(\"{cmd:?}\"));\n+            false\n+        }\n+    } else {\n+        true\n+    }\n+}\n+\n+fn run_tests(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n+    cmd.stdout(Stdio::piped());\n+\n+    builder.verbose(&format!(\"running: {cmd:?}\"));\n+\n+    let mut process = cmd.spawn().unwrap();\n+\n+    // This runs until the stdout of the child is closed, which means the child exited. We don't\n+    // run this on another thread since the builder is not Sync.\n+    Renderer::new(process.stdout.take().unwrap(), builder).render_all();\n+\n+    let result = process.wait_with_output().unwrap();\n+    if !result.status.success() && builder.is_verbose() {\n+        println!(\n+            \"\\n\\ncommand did not execute successfully: {cmd:?}\\n\\\n+             expected success, got: {}\",\n+            result.status\n+        );\n+    }\n+\n+    result.status.success()\n+}\n+\n+struct Renderer<'a> {\n+    stdout: BufReader<ChildStdout>,\n+    failures: Vec<TestOutcome>,\n+    benches: Vec<BenchOutcome>,\n+    builder: &'a Builder<'a>,\n+    tests_count: Option<usize>,\n+    executed_tests: usize,\n+    terse_tests_in_line: usize,\n+}\n+\n+impl<'a> Renderer<'a> {\n+    fn new(stdout: ChildStdout, builder: &'a Builder<'a>) -> Self {\n+        Self {\n+            stdout: BufReader::new(stdout),\n+            benches: Vec::new(),\n+            failures: Vec::new(),\n+            builder,\n+            tests_count: None,\n+            executed_tests: 0,\n+            terse_tests_in_line: 0,\n+        }\n+    }\n+\n+    fn render_all(mut self) {\n+        let mut line = String::new();\n+        loop {\n+            line.clear();\n+            match self.stdout.read_line(&mut line) {\n+                Ok(_) => {}\n+                Err(err) if err.kind() == std::io::ErrorKind::UnexpectedEof => break,\n+                Err(err) => panic!(\"failed to read output of test runner: {err}\"),\n+            }\n+            if line.is_empty() {\n+                break;\n+            }\n+\n+            let trimmed = line.trim();\n+            if trimmed.starts_with(\"{\") && trimmed.ends_with(\"}\") {\n+                self.render_message(match serde_json::from_str(&trimmed) {\n+                    Ok(parsed) => parsed,\n+                    Err(err) => {\n+                        panic!(\"failed to parse libtest json output; error: {err}, line: {line:?}\");\n+                    }\n+                });\n+            } else {\n+                // Handle non-JSON output, for example when --nocapture is passed.\n+                print!(\"{line}\");\n+                let _ = std::io::stdout().flush();\n+            }\n+        }\n+    }\n+\n+    fn render_test_outcome(&mut self, outcome: Outcome<'_>, test: &TestOutcome) {\n+        self.executed_tests += 1;\n+\n+        #[cfg(feature = \"build-metrics\")]\n+        self.builder.metrics.record_test(\n+            &test.name,\n+            match outcome {\n+                Outcome::Ok | Outcome::BenchOk => crate::metrics::TestOutcome::Passed,\n+                Outcome::Failed => crate::metrics::TestOutcome::Failed,\n+                Outcome::Ignored { reason } => crate::metrics::TestOutcome::Ignored {\n+                    ignore_reason: reason.map(|s| s.to_string()),\n+                },\n+            },\n+        );\n+\n+        if self.builder.config.verbose_tests {\n+            self.render_test_outcome_verbose(outcome, test);\n+        } else {\n+            self.render_test_outcome_terse(outcome, test);\n+        }\n+    }\n+\n+    fn render_test_outcome_verbose(&self, outcome: Outcome<'_>, test: &TestOutcome) {\n+        print!(\"test {} ... \", test.name);\n+        self.builder.colored_stdout(|stdout| outcome.write_long(stdout)).unwrap();\n+        if let Some(exec_time) = test.exec_time {\n+            print!(\" ({exec_time:.2?})\");\n+        }\n+        println!();\n+    }\n+\n+    fn render_test_outcome_terse(&mut self, outcome: Outcome<'_>, _: &TestOutcome) {\n+        if self.terse_tests_in_line != 0 && self.terse_tests_in_line % TERSE_TESTS_PER_LINE == 0 {\n+            if let Some(total) = self.tests_count {\n+                let total = total.to_string();\n+                let executed = format!(\"{:>width$}\", self.executed_tests - 1, width = total.len());\n+                print!(\" {executed}/{total}\");\n+            }\n+            println!();\n+            self.terse_tests_in_line = 0;\n+        }\n+\n+        self.terse_tests_in_line += 1;\n+        self.builder.colored_stdout(|stdout| outcome.write_short(stdout)).unwrap();\n+        let _ = std::io::stdout().flush();\n+    }\n+\n+    fn render_suite_outcome(&self, outcome: Outcome<'_>, suite: &SuiteOutcome) {\n+        // The terse output doesn't end with a newline, so we need to add it ourselves.\n+        if !self.builder.config.verbose_tests {\n+            println!();\n+        }\n+\n+        if !self.failures.is_empty() {\n+            println!(\"\\nfailures:\\n\");\n+            for failure in &self.failures {\n+                if let Some(stdout) = &failure.stdout {\n+                    println!(\"---- {} stdout ----\", failure.name);\n+                    println!(\"{stdout}\");\n+                }\n+            }\n+\n+            println!(\"\\nfailures:\");\n+            for failure in &self.failures {\n+                println!(\"    {}\", failure.name);\n+            }\n+        }\n+\n+        if !self.benches.is_empty() {\n+            println!(\"\\nbenchmarks:\");\n+\n+            let mut rows = Vec::new();\n+            for bench in &self.benches {\n+                rows.push((\n+                    &bench.name,\n+                    format!(\"{:.2?}/iter\", Duration::from_nanos(bench.median)),\n+                    format!(\"+/- {:.2?}\", Duration::from_nanos(bench.deviation)),\n+                ));\n+            }\n+\n+            let max_0 = rows.iter().map(|r| r.0.len()).max().unwrap_or(0);\n+            let max_1 = rows.iter().map(|r| r.1.len()).max().unwrap_or(0);\n+            let max_2 = rows.iter().map(|r| r.2.len()).max().unwrap_or(0);\n+            for row in &rows {\n+                println!(\"    {:<max_0$} {:>max_1$} {:>max_2$}\", row.0, row.1, row.2);\n+            }\n+        }\n+\n+        print!(\"\\ntest result: \");\n+        self.builder.colored_stdout(|stdout| outcome.write_long(stdout)).unwrap();\n+        println!(\n+            \". {} passed; {} failed; {} ignored; {} measured; {} filtered out; \\\n+             finished in {:.2?}\\n\",\n+            suite.passed,\n+            suite.failed,\n+            suite.ignored,\n+            suite.measured,\n+            suite.filtered_out,\n+            Duration::from_secs_f64(suite.exec_time)\n+        );\n+    }\n+\n+    fn render_message(&mut self, message: Message) {\n+        match message {\n+            Message::Suite(SuiteMessage::Started { test_count }) => {\n+                println!(\"\\nrunning {test_count} tests\");\n+                self.executed_tests = 0;\n+                self.terse_tests_in_line = 0;\n+                self.tests_count = Some(test_count);\n+            }\n+            Message::Suite(SuiteMessage::Ok(outcome)) => {\n+                self.render_suite_outcome(Outcome::Ok, &outcome);\n+            }\n+            Message::Suite(SuiteMessage::Failed(outcome)) => {\n+                self.render_suite_outcome(Outcome::Failed, &outcome);\n+            }\n+            Message::Bench(outcome) => {\n+                // The formatting for benchmarks doesn't replicate 1:1 the formatting libtest\n+                // outputs, mostly because libtest's formatting is broken in terse mode, which is\n+                // the default used by our monorepo. We use a different formatting instead:\n+                // successful benchmarks are just showed as \"benchmarked\"/\"b\", and the details are\n+                // outputted at the bottom like failures.\n+                let fake_test_outcome = TestOutcome {\n+                    name: outcome.name.clone(),\n+                    exec_time: None,\n+                    stdout: None,\n+                    message: None,\n+                };\n+                self.render_test_outcome(Outcome::BenchOk, &fake_test_outcome);\n+                self.benches.push(outcome);\n+            }\n+            Message::Test(TestMessage::Ok(outcome)) => {\n+                self.render_test_outcome(Outcome::Ok, &outcome);\n+            }\n+            Message::Test(TestMessage::Ignored(outcome)) => {\n+                self.render_test_outcome(\n+                    Outcome::Ignored { reason: outcome.message.as_deref() },\n+                    &outcome,\n+                );\n+            }\n+            Message::Test(TestMessage::Failed(outcome)) => {\n+                self.render_test_outcome(Outcome::Failed, &outcome);\n+                self.failures.push(outcome);\n+            }\n+            Message::Test(TestMessage::Timeout { name }) => {\n+                println!(\"test {name} has been running for a long time\");\n+            }\n+            Message::Test(TestMessage::Started) => {} // Not useful\n+        }\n+    }\n+}\n+\n+enum Outcome<'a> {\n+    Ok,\n+    BenchOk,\n+    Failed,\n+    Ignored { reason: Option<&'a str> },\n+}\n+\n+impl Outcome<'_> {\n+    fn write_short(&self, writer: &mut dyn WriteColor) -> Result<(), std::io::Error> {\n+        match self {\n+            Outcome::Ok => {\n+                writer.set_color(&ColorSpec::new().set_fg(Some(Color::Green)))?;\n+                write!(writer, \".\")?;\n+            }\n+            Outcome::BenchOk => {\n+                writer.set_color(&ColorSpec::new().set_fg(Some(Color::Cyan)))?;\n+                write!(writer, \"b\")?;\n+            }\n+            Outcome::Failed => {\n+                writer.set_color(&ColorSpec::new().set_fg(Some(Color::Red)))?;\n+                write!(writer, \"F\")?;\n+            }\n+            Outcome::Ignored { .. } => {\n+                writer.set_color(&ColorSpec::new().set_fg(Some(Color::Yellow)))?;\n+                write!(writer, \"i\")?;\n+            }\n+        }\n+        writer.reset()\n+    }\n+\n+    fn write_long(&self, writer: &mut dyn WriteColor) -> Result<(), std::io::Error> {\n+        match self {\n+            Outcome::Ok => {\n+                writer.set_color(&ColorSpec::new().set_fg(Some(Color::Green)))?;\n+                write!(writer, \"ok\")?;\n+            }\n+            Outcome::BenchOk => {\n+                writer.set_color(&ColorSpec::new().set_fg(Some(Color::Cyan)))?;\n+                write!(writer, \"benchmarked\")?;\n+            }\n+            Outcome::Failed => {\n+                writer.set_color(&ColorSpec::new().set_fg(Some(Color::Red)))?;\n+                write!(writer, \"FAILED\")?;\n+            }\n+            Outcome::Ignored { reason } => {\n+                writer.set_color(&ColorSpec::new().set_fg(Some(Color::Yellow)))?;\n+                write!(writer, \"ignored\")?;\n+                if let Some(reason) = reason {\n+                    write!(writer, \", {reason}\")?;\n+                }\n+            }\n+        }\n+        writer.reset()\n+    }\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+#[serde(tag = \"type\", rename_all = \"snake_case\")]\n+enum Message {\n+    Suite(SuiteMessage),\n+    Test(TestMessage),\n+    Bench(BenchOutcome),\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+#[serde(tag = \"event\", rename_all = \"snake_case\")]\n+enum SuiteMessage {\n+    Ok(SuiteOutcome),\n+    Failed(SuiteOutcome),\n+    Started { test_count: usize },\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+struct SuiteOutcome {\n+    passed: usize,\n+    failed: usize,\n+    ignored: usize,\n+    measured: usize,\n+    filtered_out: usize,\n+    exec_time: f64,\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+#[serde(tag = \"event\", rename_all = \"snake_case\")]\n+enum TestMessage {\n+    Ok(TestOutcome),\n+    Failed(TestOutcome),\n+    Ignored(TestOutcome),\n+    Timeout { name: String },\n+    Started,\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+struct BenchOutcome {\n+    name: String,\n+    median: u64,\n+    deviation: u64,\n+}\n+\n+#[derive(serde_derive::Deserialize)]\n+struct TestOutcome {\n+    name: String,\n+    exec_time: Option<f64>,\n+    stdout: Option<String>,\n+    message: Option<String>,\n+}"}, {"sha": "29d37c09d884c125ada52418977f64b1d07e0763", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/66676820eb801473f21006fa64315ce3c42402eb/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66676820eb801473f21006fa64315ce3c42402eb/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=66676820eb801473f21006fa64315ce3c42402eb", "patch": "@@ -20,6 +20,7 @@ use crate::dist;\n use crate::doc::DocumentationFormat;\n use crate::flags::Subcommand;\n use crate::native;\n+use crate::render_tests::add_flags_and_try_run_tests;\n use crate::tool::{self, SourceType, Tool};\n use crate::toolstate::ToolState;\n use crate::util::{self, add_link_lib_path, dylib_path, dylib_path_var, output, t};\n@@ -123,7 +124,7 @@ impl Step for CrateJsonDocLint {\n             SourceType::InTree,\n             &[],\n         );\n-        try_run(builder, &mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -172,7 +173,7 @@ You can skip linkcheck with --exclude src/tools/linkchecker\"\n             SourceType::InTree,\n             &[],\n         );\n-        try_run(builder, &mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n \n         // Build all the default documentation.\n         builder.default_doc(&[]);\n@@ -333,7 +334,7 @@ impl Step for Cargo {\n \n         cargo.env(\"PATH\", &path_for_cargo(builder, compiler));\n \n-        try_run(builder, &mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -392,7 +393,7 @@ impl Step for RustAnalyzer {\n         cargo.add_rustc_lib_path(builder, compiler);\n         cargo.arg(\"--\").args(builder.config.cmd.test_args());\n \n-        builder.run(&mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -445,7 +446,7 @@ impl Step for Rustfmt {\n \n         cargo.add_rustc_lib_path(builder, compiler);\n \n-        builder.run(&mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -496,7 +497,7 @@ impl Step for RustDemangler {\n \n         cargo.add_rustc_lib_path(builder, compiler);\n \n-        builder.run(&mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -637,8 +638,7 @@ impl Step for Miri {\n         // Forward test filters.\n         cargo.arg(\"--\").args(builder.config.cmd.test_args());\n \n-        let mut cargo = Command::from(cargo);\n-        builder.run(&mut cargo);\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n \n         // # Run `cargo miri test`.\n         // This is just a smoke test (Miri's own CI invokes this in a bunch of different ways and ensures\n@@ -711,7 +711,7 @@ impl Step for CompiletestTest {\n         );\n         cargo.allow_features(\"test\");\n \n-        try_run(builder, &mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -1193,7 +1193,7 @@ impl Step for TidySelfTest {\n             SourceType::InTree,\n             &[],\n         );\n-        try_run(builder, &mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -1620,9 +1620,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             cmd.arg(\"--verbose\");\n         }\n \n-        if !builder.config.verbose_tests {\n-            cmd.arg(\"--quiet\");\n-        }\n+        cmd.arg(\"--json\");\n \n         let mut llvm_components_passed = false;\n         let mut copts_passed = false;\n@@ -1773,7 +1771,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             suite, mode, &compiler.host, target\n         ));\n         let _time = util::timeit(&builder);\n-        try_run(builder, &mut cmd);\n+        crate::render_tests::try_run_tests(builder, &mut cmd);\n \n         if let Some(compare_mode) = compare_mode {\n             cmd.arg(\"--compare-mode\").arg(compare_mode);\n@@ -1782,7 +1780,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n                 suite, mode, compare_mode, &compiler.host, target\n             ));\n             let _time = util::timeit(&builder);\n-            try_run(builder, &mut cmd);\n+            crate::render_tests::try_run_tests(builder, &mut cmd);\n         }\n     }\n }\n@@ -2184,9 +2182,8 @@ impl Step for Crate {\n         cargo.arg(\"--\");\n         cargo.args(&builder.config.cmd.test_args());\n \n-        if !builder.config.verbose_tests {\n-            cargo.arg(\"--quiet\");\n-        }\n+        cargo.arg(\"-Z\").arg(\"unstable-options\");\n+        cargo.arg(\"--format\").arg(\"json\");\n \n         if target.contains(\"emscripten\") {\n             cargo.env(\n@@ -2214,7 +2211,7 @@ impl Step for Crate {\n             target\n         ));\n         let _time = util::timeit(&builder);\n-        try_run(builder, &mut cargo.into());\n+        crate::render_tests::try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -2334,7 +2331,7 @@ impl Step for CrateRustdoc {\n         ));\n         let _time = util::timeit(&builder);\n \n-        try_run(builder, &mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -2395,17 +2392,13 @@ impl Step for CrateRustdocJsonTypes {\n             cargo.arg(\"'-Ctarget-feature=-crt-static'\");\n         }\n \n-        if !builder.config.verbose_tests {\n-            cargo.arg(\"--quiet\");\n-        }\n-\n         builder.info(&format!(\n             \"{} rustdoc-json-types stage{} ({} -> {})\",\n             test_kind, compiler.stage, &compiler.host, target\n         ));\n         let _time = util::timeit(&builder);\n \n-        try_run(builder, &mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n }\n \n@@ -2574,7 +2567,7 @@ impl Step for Bootstrap {\n         // rustbuild tests are racy on directory creation so just run them one at a time.\n         // Since there's not many this shouldn't be a problem.\n         cmd.arg(\"--test-threads=1\");\n-        try_run(builder, &mut cmd);\n+        add_flags_and_try_run_tests(builder, &mut cmd);\n     }\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -2655,7 +2648,7 @@ impl Step for ReplacePlaceholderTest {\n             SourceType::InTree,\n             &[],\n         );\n-        try_run(builder, &mut cargo.into());\n+        add_flags_and_try_run_tests(builder, &mut cargo.into());\n     }\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {"}, {"sha": "7691f5c32b21e562286e6e382fe6ed459e807b29", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66676820eb801473f21006fa64315ce3c42402eb/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66676820eb801473f21006fa64315ce3c42402eb/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=66676820eb801473f21006fa64315ce3c42402eb", "patch": "@@ -9,7 +9,7 @@ use std::str::FromStr;\n \n use crate::util::{add_dylib_path, PathBufExt};\n use lazycell::LazyCell;\n-use test::ColorConfig;\n+use test::{ColorConfig, OutputFormat};\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n pub enum Mode {\n@@ -337,7 +337,7 @@ pub struct Config {\n     pub verbose: bool,\n \n     /// Print one character per test instead of one line\n-    pub quiet: bool,\n+    pub format: OutputFormat,\n \n     /// Whether to use colors in test.\n     pub color: ColorConfig,"}, {"sha": "cbaa599f79308d2c203c4de2654d4353d01ef832", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66676820eb801473f21006fa64315ce3c42402eb/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66676820eb801473f21006fa64315ce3c42402eb/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=66676820eb801473f21006fa64315ce3c42402eb", "patch": "@@ -114,6 +114,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         )\n         .optflag(\"\", \"quiet\", \"print one character per test instead of one line\")\n         .optopt(\"\", \"color\", \"coloring: auto, always, never\", \"WHEN\")\n+        .optflag(\"\", \"json\", \"emit json output instead of plaintext output\")\n         .optopt(\"\", \"logfile\", \"file to log test execution to\", \"FILE\")\n         .optopt(\"\", \"target\", \"the target to build for\", \"TARGET\")\n         .optopt(\"\", \"host\", \"the host to build for\", \"HOST\")\n@@ -281,7 +282,12 @@ pub fn parse_config(args: Vec<String>) -> Config {\n             && !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n         lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n         verbose: matches.opt_present(\"verbose\"),\n-        quiet: matches.opt_present(\"quiet\"),\n+        format: match (matches.opt_present(\"quiet\"), matches.opt_present(\"json\")) {\n+            (true, true) => panic!(\"--quiet and --json are incompatible\"),\n+            (true, false) => test::OutputFormat::Terse,\n+            (false, true) => test::OutputFormat::Json,\n+            (false, false) => test::OutputFormat::Pretty,\n+        },\n         only_modified: matches.opt_present(\"only-modified\"),\n         color,\n         remote_test_client: matches.opt_str(\"remote-test-client\").map(PathBuf::from),\n@@ -339,7 +345,7 @@ pub fn log_config(config: &Config) {\n     logv(c, format!(\"ar: {}\", config.ar));\n     logv(c, format!(\"linker: {:?}\", config.linker));\n     logv(c, format!(\"verbose: {}\", config.verbose));\n-    logv(c, format!(\"quiet: {}\", config.quiet));\n+    logv(c, format!(\"format: {:?}\", config.format));\n     logv(c, \"\\n\".to_string());\n }\n \n@@ -416,7 +422,7 @@ pub fn run_tests(config: Config) {\n             // easy to miss which tests failed, and as such fail to reproduce\n             // the failure locally.\n \n-            eprintln!(\n+            println!(\n                 \"Some tests failed in compiletest suite={}{} mode={} host={} target={}\",\n                 config.suite,\n                 config.compare_mode.map(|c| format!(\" compare_mode={:?}\", c)).unwrap_or_default(),\n@@ -501,7 +507,7 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         filters: config.filters.clone(),\n         filter_exact: config.filter_exact,\n         run_ignored: if config.run_ignored { test::RunIgnored::Yes } else { test::RunIgnored::No },\n-        format: if config.quiet { test::OutputFormat::Terse } else { test::OutputFormat::Pretty },\n+        format: config.format,\n         logfile: config.logfile.clone(),\n         run_tests: true,\n         bench_benchmarks: true,"}]}