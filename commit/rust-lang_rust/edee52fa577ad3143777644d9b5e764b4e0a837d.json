{"sha": "edee52fa577ad3143777644d9b5e764b4e0a837d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZWU1MmZhNTc3YWQzMTQzNzc3NjQ0ZDliNWU3NjRiNGUwYTgzN2Q=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-02T12:37:27Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-02T12:37:50Z"}, "message": "reorg docs", "tree": {"sha": "c35796b1504d01e792260145bb1a4ccd4b3d4858", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c35796b1504d01e792260145bb1a4ccd4b3d4858"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edee52fa577ad3143777644d9b5e764b4e0a837d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edee52fa577ad3143777644d9b5e764b4e0a837d", "html_url": "https://github.com/rust-lang/rust/commit/edee52fa577ad3143777644d9b5e764b4e0a837d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edee52fa577ad3143777644d9b5e764b4e0a837d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4d0f19b01e5ba5007073f126b7eb0276c79024f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4d0f19b01e5ba5007073f126b7eb0276c79024f", "html_url": "https://github.com/rust-lang/rust/commit/e4d0f19b01e5ba5007073f126b7eb0276c79024f"}], "stats": {"total": 531, "additions": 263, "deletions": 268}, "files": [{"sha": "18c53d5c0e9e5ab60322f5ce95690e0e3a82cb28", "filename": "docs/dev/README.md", "status": "modified", "additions": 52, "deletions": 268, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/edee52fa577ad3143777644d9b5e764b4e0a837d/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/edee52fa577ad3143777644d9b5e764b4e0a837d/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=edee52fa577ad3143777644d9b5e764b4e0a837d", "patch": "@@ -50,277 +50,85 @@ We use bors-ng to enforce the [not rocket science](https://graydon2.dreamwidth.o\n \n You can run `cargo xtask install-pre-commit-hook` to install git-hook to run rustfmt on commit.\n \n-# Code organization\n-\n-All Rust code lives in the `crates` top-level directory, and is organized as a\n-single Cargo workspace. The `editors` top-level directory contains code for\n-integrating with editors. Currently, it contains the plugin for VS Code (in\n-TypeScript). The `docs` top-level directory contains both developer and user\n-documentation.\n-\n-We have some automation infra in Rust in the `xtask` package. It contains\n-stuff like formatting checking, code generation and powers `cargo xtask install`.\n-The latter syntax is achieved with the help of cargo aliases (see `.cargo`\n-directory).\n-\n # Launching rust-analyzer\n \n-Debugging the language server can be tricky: LSP is rather chatty, so driving it\n-from the command line is not really feasible, driving it via VS Code requires\n-interacting with two processes.\n+Debugging the language server can be tricky.\n+LSP is rather chatty, so driving it from the command line is not really feasible, driving it via VS Code requires interacting with two processes.\n \n-For this reason, the best way to see how rust-analyzer works is to find a\n-relevant test and execute it (VS Code includes an action for running a single\n-test).\n+For this reason, the best way to see how rust-analyzer works is to find a relevant test and execute it.\n+VS Code & Emacs include an action for running a single test.\n \n-However, launching a VS Code instance with a locally built language server is\n-possible. There's **\"Run Extension (Debug Build)\"** launch configuration for this.\n+Launching a VS Code instance with a locally built language server is also possible.\n+There's **\"Run Extension (Debug Build)\"** launch configuration for this in VS Code.\n \n-In general, I use one of the following workflows for fixing bugs and\n-implementing features.\n+In general, I use one of the following workflows for fixing bugs and implementing features:\n \n-If the problem concerns only internal parts of rust-analyzer (i.e. I don't need\n-to touch the `rust-analyzer` crate or TypeScript code), there is a unit-test for it.\n-So, I use **Rust Analyzer: Run** action in VS Code to run this single test, and\n-then just do printf-driven development/debugging. As a sanity check after I'm\n-done, I use `cargo xtask install --server` and **Reload Window** action in VS\n-Code to sanity check that the thing works as I expect.\n+If the problem concerns only internal parts of rust-analyzer (i.e. I don't need to touch the `rust-analyzer` crate or TypeScript code), there is a unit-test for it.\n+So, I use **Rust Analyzer: Run** action in VS Code to run this single test, and then just do printf-driven development/debugging.\n+As a sanity check after I'm done, I use `cargo xtask install --server` and **Reload Window** action in VS Code to verify that the thing works as I expect.\n \n-If the problem concerns only the VS Code extension, I use **Run Installed Extension**\n-launch configuration from `launch.json`. Notably, this uses the usual\n-`rust-analyzer` binary from `PATH`. For this, it is important to have the following\n-in your `settings.json` file:\n+If the problem concerns only the VS Code extension, I use **Run Installed Extension** launch configuration from `launch.json`.\n+Notably, this uses the usual `rust-analyzer` binary from `PATH`.\n+For this, it is important to have the following in your `settings.json` file:\n ```json\n {\n     \"rust-analyzer.serverPath\": \"rust-analyzer\"\n }\n ```\n-After I am done with the fix, I use `cargo\n-xtask install --client-code` to try the new extension for real.\n-\n-If I need to fix something in the `rust-analyzer` crate, I feel sad because it's\n-on the boundary between the two processes, and working there is slow. I usually\n-just `cargo xtask install --server` and poke changes from my live environment.\n-Note that this uses `--release`, which is usually faster overall, because\n-loading stdlib into debug version of rust-analyzer takes a lot of time. To speed\n-things up, sometimes I open a temporary hello-world project which has\n-`\"rust-analyzer.withSysroot\": false` in `.code/settings.json`. This flag causes\n-rust-analyzer to skip loading the sysroot, which greatly reduces the amount of\n-things rust-analyzer needs to do, and makes printf's more useful. Note that you\n-should only use the `eprint!` family of macros for debugging: stdout is used for LSP\n-communication, and `print!` would break it.\n-\n-If I need to fix something simultaneously in the server and in the client, I\n-feel even more sad. I don't have a specific workflow for this case.\n-\n-Additionally, I use `cargo run --release -p rust-analyzer -- analysis-stats\n-path/to/some/rust/crate` to run a batch analysis. This is primarily useful for\n-performance optimizations, or for bug minimization.\n-\n-# Code Style & Review Process\n-\n-Our approach to \"clean code\" is two-fold:\n-\n-* We generally don't block PRs on style changes.\n-* At the same time, all code in rust-analyzer is constantly refactored.\n-\n-It is explicitly OK for a reviewer to flag only some nits in the PR, and then send a follow-up cleanup PR for things which are easier to explain by example, cc-ing the original author.\n-Sending small cleanup PRs (like renaming a single local variable) is encouraged.\n-\n-## Scale of Changes\n-\n-Everyone knows that it's better to send small & focused pull requests.\n-The problem is, sometimes you *have* to, eg, rewrite the whole compiler, and that just doesn't fit into a set of isolated PRs.\n-\n-The main things to keep an eye on are the boundaries between various components.\n-There are three kinds of changes:\n-\n-1. Internals of a single component are changed.\n-   Specifically, you don't change any `pub` items.\n-   A good example here would be an addition of a new assist.\n-\n-2. API of a component is expanded.\n-   Specifically, you add a new `pub` function which wasn't there before.\n-   A good example here would be expansion of assist API, for example, to implement lazy assists or assists groups.\n-\n-3. A new dependency between components is introduced.\n-   Specifically, you add a `pub use` reexport from another crate or you add a new line to the `[dependencies]` section of `Cargo.toml`.\n-   A good example here would be adding reference search capability to the assists crates.\n-\n-For the first group, the change is generally merged as long as:\n-\n-* it works for the happy case,\n-* it has tests,\n-* it doesn't panic for the unhappy case.\n-\n-For the second group, the change would be subjected to quite a bit of scrutiny and iteration.\n-The new API needs to be right (or at least easy to change later).\n-The actual implementation doesn't matter that much.\n-It's very important to minimize the amount of changed lines of code for changes of the second kind.\n-Often, you start doing a change of the first kind, only to realise that you need to elevate to a change of the second kind.\n-In this case, we'll probably ask you to split API changes into a separate PR.\n-\n-Changes of the third group should be pretty rare, so we don't specify any specific process for them.\n-That said, adding an innocent-looking `pub use` is a very simple way to break encapsulation, keep an eye on it!\n-\n-Note: if you enjoyed this abstract hand-waving about boundaries, you might appreciate\n-https://www.tedinski.com/2018/02/06/system-boundaries.html\n-\n-## Crates.io Dependencies\n-\n-We try to be very conservative with usage of crates.io dependencies.\n-Don't use small \"helper\" crates (exception: `itertools` is allowed).\n-If there's some general reusable bit of code you need, consider adding it to the `stdx` crate.\n-\n-## Minimal Tests\n-\n-Most tests in rust-analyzer start with a snippet of Rust code.\n-This snippets should be minimal -- if you copy-paste a snippet of real code into the tests, make sure to remove everything which could be removed.\n-There are many benefits to this:\n-\n-* less to read or to scroll past\n-* easier to understand what exactly is tested\n-* less stuff printed during printf-debugging\n-* less time to run test\n-\n-It also makes sense to format snippets more compactly (for example, by placing enum defitions like `enum E { Foo, Bar }` on a single line),\n-as long as they are still readable.\n-\n-## Order of Imports\n-\n-We separate import groups with blank lines\n+After I am done with the fix, I use `cargo xtask install --client-code` to try the new extension for real.\n \n-```rust\n-mod x;\n-mod y;\n+If I need to fix something in the `rust-analyzer` crate, I feel sad because it's on the boundary between the two processes, and working there is slow.\n+I usually just `cargo xtask install --server` and poke changes from my live environment.\n+Note that this uses `--release`, which is usually faster overall, because loading stdlib into debug version of rust-analyzer takes a lot of time.\n+To speed things up, sometimes I open a temporary hello-world project which has `\"rust-analyzer.withSysroot\": false` in `.code/settings.json`.\n+This flag causes rust-analyzer to skip loading the sysroot, which greatly reduces the amount of things rust-analyzer needs to do, and makes printf's more useful.\n+Note that you should only use the `eprint!` family of macros for debugging: stdout is used for LSP communication, and `print!` would break it.\n \n-use std::{ ... }\n-\n-use crate_foo::{ ... }\n-use crate_bar::{ ... }\n-\n-use crate::{}\n-\n-use super::{} // but prefer `use crate::`\n-```\n-\n-## Import Style\n-\n-Items from `hir` and `ast` should be used qualified:\n-\n-```rust\n-// Good\n-use ra_syntax::ast;\n-\n-fn frobnicate(func: hir::Function, strukt: ast::StructDef) {}\n-\n-// Not as good\n-use hir::Function;\n-use ra_syntax::ast::StructDef;\n-\n-fn frobnicate(func: Function, strukt: StructDef) {}\n-```\n-\n-Avoid local `use MyEnum::*` imports.\n-\n-Prefer `use crate::foo::bar` to `use super::bar`.\n-\n-## Order of Items\n-\n-Optimize for the reader who sees the file for the first time, and wants to get the general idea about what's going on.\n-People read things from top to bottom, so place most important things first.\n-\n-Specifically, if all items except one are private, always put the non-private item on top.\n-\n-Put `struct`s and `enum`s first, functions and impls last.\n-\n-Do\n-\n-```rust\n-// Good\n-struct Foo {\n-    bars: Vec<Bar>\n-}\n-\n-struct Bar;\n-```\n-\n-rather than\n-\n-```rust\n-// Not as good\n-struct Bar;\n-\n-struct Foo {\n-    bars: Vec<Bar>\n-}\n-```\n+If I need to fix something simultaneously in the server and in the client, I feel even more sad.\n+I don't have a specific workflow for this case.\n \n-## Variable Naming\n+Additionally, I use `cargo run --release -p rust-analyzer -- analysis-stats path/to/some/rust/crate` to run a batch analysis.\n+This is primarily useful for performance optimizations, or for bug minimization.\n \n-We generally use boring and long names for local variables ([yay code completion](https://github.com/rust-analyzer/rust-analyzer/pull/4162#discussion_r417130973)).\n-The default name is a lowercased name of the type: `global_state: GlobalState`.\n-Avoid ad-hoc acronyms and contractions, but use the ones that exist consistently (`db`, `ctx`, `acc`).\n-The default name for \"result of the function\" local variable is `res`.\n-\n-## Collection types\n+## Parser Tests\n \n-We prefer `rustc_hash::FxHashMap` and `rustc_hash::FxHashSet` instead of the ones in `std::collections`.\n-They use a hasher that's slightly faster and using them consistently will reduce code size by some small amount.\n+Tests for the parser (`ra_parser`) live in the `ra_syntax` crate (see `test_data` directory).\n+There are two kinds of tests:\n \n-## Preconditions\n+* Manually written test cases in `parser/ok` and `parser/err`\n+* \"Inline\" tests in `parser/inline` (these are generated) from comments in `ra_parser` crate.\n \n-Function preconditions should generally be expressed in types and provided by the caller (rather than checked by callee):\n+The purpose of inline tests is not to achieve full coverage by test cases, but to explain to the reader of the code what each particular `if` and `match` is responsible for.\n+If you are tempted to add a large inline test, it might be a good idea to leave only the simplest example in place, and move the test to a manual `parser/ok` test.\n \n-```rust\n-// Good\n-fn frbonicate(walrus: Walrus) {\n-    ...\n-}\n+To update test data, run with `UPDATE_EXPECT` variable:\n \n-// Not as good\n-fn frobnicate(walrus: Option<Walrus>) {\n-    let walrus = match walrus {\n-        Some(it) => it,\n-        None => return,\n-    };\n-    ...\n-}\n+```bash\n+env UPDATE_EXPECT=1 cargo qt\n ```\n \n-## Premature Pessimization\n-\n-While we don't specifically optimize code yet, avoid writing code which is slower than it needs to be.\n-Don't allocate a `Vec` where an iterator would do, don't allocate strings needlessly.\n+After adding a new inline test you need to run `cargo xtest codegen` and also update the test data as described above.\n \n-```rust\n-// Good\n-use itertools::Itertools;\n+## TypeScript Tests\n \n-let (first_word, second_word) = match text.split_ascii_whitespace().collect_tuple() {\n-    Some(it) => it,\n-    None => return,\n-}\n+If you change files under `editors/code` and would like to run the tests and linter, install npm and run:\n \n-// Not as good\n-let words = text.split_ascii_whitespace().collect::<Vec<_>>();\n-if words.len() != 2 {\n-    return\n-}\n+```bash\n+cd editors/code\n+npm ci\n+npm run lint\n ```\n \n-## Documentation\n-\n-For `.md` and `.adoc` files, prefer a sentence-per-line format, don't wrap lines.\n-If the line is too long, you want to split the sentence in two :-)\n-\n-## Commit Style\n+# Code organization\n \n-We don't have specific rules around git history hygiene.\n-Maintaining clean git history is encouraged, but not enforced.\n-We use rebase workflow, it's OK to rewrite history during PR review process.\n+All Rust code lives in the `crates` top-level directory, and is organized as a single Cargo workspace.\n+The `editors` top-level directory contains code for integrating with editors.\n+Currently, it contains the plugin for VS Code (in TypeScript).\n+The `docs` top-level directory contains both developer and user documentation.\n \n-Avoid @mentioning people in commit messages and pull request descriptions (they are added to commit message by bors), as such messages create a lot of duplicate notification traffic during rebases.\n+We have some automation infra in Rust in the `xtask` package.\n+It contains stuff like formatting checking, code generation and powers `cargo xtask install`.\n+The latter syntax is achieved with the help of cargo aliases (see `.cargo` directory).\n \n # Architecture Invariants\n \n@@ -355,35 +163,11 @@ The main IDE crate (`ra_ide`) uses \"Plain Old Data\" for the API.\n Rather than talking in definitions and references, it talks in Strings and textual offsets.\n In general, API is centered around UI concerns -- the result of the call is what the user sees in the editor, and not what the compiler sees underneath.\n The results are 100% Rust specific though.\n+Shout outs to LSP developers for popularizing the idea that \"UI\" is a good place to draw a boundary at.\n \n-## Parser Tests\n-\n-Tests for the parser (`ra_parser`) live in the `ra_syntax` crate (see `test_data` directory).\n-There are two kinds of tests:\n-\n-* Manually written test cases in `parser/ok` and `parser/err`\n-* \"Inline\" tests in `parser/inline` (these are generated) from comments in `ra_parser` crate.\n-\n-The purpose of inline tests is not to achieve full coverage by test cases, but to explain to the reader of the code what each particular `if` and `match` is responsible for.\n-If you are tempted to add a large inline test, it might be a good idea to leave only the simplest example in place, and move the test to a manual `parser/ok` test.\n-\n-To update test data, run with `UPDATE_EXPECT` variable:\n-\n-```bash\n-env UPDATE_EXPECT=1 cargo qt\n-```\n-\n-After adding a new inline test you need to run `cargo xtest codegen` and also update the test data as described above.\n-\n-## TypeScript Tests\n-\n-If you change files under `editors/code` and would like to run the tests and linter, install npm and run:\n+# Code Style & Review Process\n \n-```bash\n-cd editors/code\n-npm ci\n-npm run lint\n-```\n+Do see [./style.md](./style.md).\n \n # Logging\n "}, {"sha": "0a85b4a55db4ca8f93fb7e26b3e6f6ec90f275bb", "filename": "docs/dev/style.md", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/edee52fa577ad3143777644d9b5e764b4e0a837d/docs%2Fdev%2Fstyle.md", "raw_url": "https://github.com/rust-lang/rust/raw/edee52fa577ad3143777644d9b5e764b4e0a837d/docs%2Fdev%2Fstyle.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fstyle.md?ref=edee52fa577ad3143777644d9b5e764b4e0a837d", "patch": "@@ -0,0 +1,211 @@\n+Our approach to \"clean code\" is two-fold:\n+\n+* We generally don't block PRs on style changes.\n+* At the same time, all code in rust-analyzer is constantly refactored.\n+\n+It is explicitly OK for a reviewer to flag only some nits in the PR, and then send a follow-up cleanup PR for things which are easier to explain by example, cc-ing the original author.\n+Sending small cleanup PRs (like renaming a single local variable) is encouraged.\n+\n+# Scale of Changes\n+\n+Everyone knows that it's better to send small & focused pull requests.\n+The problem is, sometimes you *have* to, eg, rewrite the whole compiler, and that just doesn't fit into a set of isolated PRs.\n+\n+The main things to keep an eye on are the boundaries between various components.\n+There are three kinds of changes:\n+\n+1. Internals of a single component are changed.\n+   Specifically, you don't change any `pub` items.\n+   A good example here would be an addition of a new assist.\n+\n+2. API of a component is expanded.\n+   Specifically, you add a new `pub` function which wasn't there before.\n+   A good example here would be expansion of assist API, for example, to implement lazy assists or assists groups.\n+\n+3. A new dependency between components is introduced.\n+   Specifically, you add a `pub use` reexport from another crate or you add a new line to the `[dependencies]` section of `Cargo.toml`.\n+   A good example here would be adding reference search capability to the assists crates.\n+\n+For the first group, the change is generally merged as long as:\n+\n+* it works for the happy case,\n+* it has tests,\n+* it doesn't panic for the unhappy case.\n+\n+For the second group, the change would be subjected to quite a bit of scrutiny and iteration.\n+The new API needs to be right (or at least easy to change later).\n+The actual implementation doesn't matter that much.\n+It's very important to minimize the amount of changed lines of code for changes of the second kind.\n+Often, you start doing a change of the first kind, only to realise that you need to elevate to a change of the second kind.\n+In this case, we'll probably ask you to split API changes into a separate PR.\n+\n+Changes of the third group should be pretty rare, so we don't specify any specific process for them.\n+That said, adding an innocent-looking `pub use` is a very simple way to break encapsulation, keep an eye on it!\n+\n+Note: if you enjoyed this abstract hand-waving about boundaries, you might appreciate\n+https://www.tedinski.com/2018/02/06/system-boundaries.html\n+\n+# Crates.io Dependencies\n+\n+We try to be very conservative with usage of crates.io dependencies.\n+Don't use small \"helper\" crates (exception: `itertools` is allowed).\n+If there's some general reusable bit of code you need, consider adding it to the `stdx` crate.\n+\n+# Minimal Tests\n+\n+Most tests in rust-analyzer start with a snippet of Rust code.\n+This snippets should be minimal -- if you copy-paste a snippet of real code into the tests, make sure to remove everything which could be removed.\n+There are many benefits to this:\n+\n+* less to read or to scroll past\n+* easier to understand what exactly is tested\n+* less stuff printed during printf-debugging\n+* less time to run test\n+\n+It also makes sense to format snippets more compactly (for example, by placing enum definitions like `enum E { Foo, Bar }` on a single line),\n+as long as they are still readable.\n+\n+## Order of Imports\n+\n+We separate import groups with blank lines\n+\n+```rust\n+mod x;\n+mod y;\n+\n+// First std.\n+use std::{ ... }\n+\n+// Second, external crates (both crates.io crates and other rust-analyzer crates).\n+use crate_foo::{ ... }\n+use crate_bar::{ ... }\n+\n+// Then current crate.\n+use crate::{}\n+\n+// Finally, parent and child modules, but prefer `use crate::`.\n+use super::{}\n+```\n+\n+Module declarations come before the imports.\n+Order them in \"suggested reading order\" for a person new to the code base.\n+\n+## Import Style\n+\n+Items from `hir` and `ast` should be used qualified:\n+\n+```rust\n+// Good\n+use ra_syntax::ast;\n+\n+fn frobnicate(func: hir::Function, strukt: ast::StructDef) {}\n+\n+// Not as good\n+use hir::Function;\n+use ra_syntax::ast::StructDef;\n+\n+fn frobnicate(func: Function, strukt: StructDef) {}\n+```\n+\n+Avoid local `use MyEnum::*` imports.\n+\n+Prefer `use crate::foo::bar` to `use super::bar`.\n+\n+## Order of Items\n+\n+Optimize for the reader who sees the file for the first time, and wants to get a general idea about what's going on.\n+People read things from top to bottom, so place most important things first.\n+\n+Specifically, if all items except one are private, always put the non-private item on top.\n+\n+Put `struct`s and `enum`s first, functions and impls last.\n+\n+Do\n+\n+```rust\n+// Good\n+struct Foo {\n+    bars: Vec<Bar>\n+}\n+\n+struct Bar;\n+```\n+\n+rather than\n+\n+```rust\n+// Not as good\n+struct Bar;\n+\n+struct Foo {\n+    bars: Vec<Bar>\n+}\n+```\n+\n+## Variable Naming\n+\n+We generally use boring and long names for local variables ([yay code completion](https://github.com/rust-analyzer/rust-analyzer/pull/4162#discussion_r417130973)).\n+The default name is a lowercased name of the type: `global_state: GlobalState`.\n+Avoid ad-hoc acronyms and contractions, but use the ones that exist consistently (`db`, `ctx`, `acc`).\n+The default name for \"result of the function\" local variable is `res`.\n+The default name for \"I don't really care about the name\" variable is `it`.\n+\n+## Collection types\n+\n+We prefer `rustc_hash::FxHashMap` and `rustc_hash::FxHashSet` instead of the ones in `std::collections`.\n+They use a hasher that's slightly faster and using them consistently will reduce code size by some small amount.\n+\n+## Preconditions\n+\n+Function preconditions should generally be expressed in types and provided by the caller (rather than checked by callee):\n+\n+```rust\n+// Good\n+fn frbonicate(walrus: Walrus) {\n+    ...\n+}\n+\n+// Not as good\n+fn frobnicate(walrus: Option<Walrus>) {\n+    let walrus = match walrus {\n+        Some(it) => it,\n+        None => return,\n+    };\n+    ...\n+}\n+```\n+\n+## Premature Pessimization\n+\n+Avoid writing code which is slower than it needs to be.\n+Don't allocate a `Vec` where an iterator would do, don't allocate strings needlessly.\n+\n+```rust\n+// Good\n+use itertools::Itertools;\n+\n+let (first_word, second_word) = match text.split_ascii_whitespace().collect_tuple() {\n+    Some(it) => it,\n+    None => return,\n+}\n+\n+// Not as good\n+let words = text.split_ascii_whitespace().collect::<Vec<_>>();\n+if words.len() != 2 {\n+    return\n+}\n+```\n+\n+## Documentation\n+\n+For `.md` and `.adoc` files, prefer a sentence-per-line format, don't wrap lines.\n+If the line is too long, you want to split the sentence in two :-)\n+\n+## Commit Style\n+\n+We don't have specific rules around git history hygiene.\n+Maintaining clean git history is encouraged, but not enforced.\n+We use rebase workflow, it's OK to rewrite history during PR review process.\n+\n+Avoid @mentioning people in commit messages and pull request descriptions(they are added to commit message by bors).\n+Such messages create a lot of duplicate notification traffic during rebases."}]}