{"sha": "cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZDhmZTkwZmQ2MWM0MTBhYzNlN2U5N2E2YmUzN2M5NmNhNjZhNzI=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-11T19:09:57Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-20T13:38:03Z"}, "message": "rename `Predicate` to `PredicateKind`, introduce alias", "tree": {"sha": "41460058e0ef97b091d04e8f4de665c0a274dc06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41460058e0ef97b091d04e8f4de665c0a274dc06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "html_url": "https://github.com/rust-lang/rust/commit/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f182c4af8a22df906f6e901cb11a1a804f29f32c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f182c4af8a22df906f6e901cb11a1a804f29f32c", "html_url": "https://github.com/rust-lang/rust/commit/f182c4af8a22df906f6e901cb11a1a804f29f32c"}], "stats": {"total": 789, "additions": 406, "deletions": 383}, "files": [{"sha": "67c8265cb115383f03abd8c7a7592a2d1361b2be", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -532,12 +532,12 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 cause.clone(),\n                 param_env,\n                 match k1.unpack() {\n-                    GenericArgKind::Lifetime(r1) => ty::Predicate::RegionOutlives(\n+                    GenericArgKind::Lifetime(r1) => ty::PredicateKind::RegionOutlives(\n                         ty::Binder::bind(ty::OutlivesPredicate(r1, r2)),\n                     ),\n-                    GenericArgKind::Type(t1) => {\n-                        ty::Predicate::TypeOutlives(ty::Binder::bind(ty::OutlivesPredicate(t1, r2)))\n-                    }\n+                    GenericArgKind::Type(t1) => ty::PredicateKind::TypeOutlives(ty::Binder::bind(\n+                        ty::OutlivesPredicate(t1, r2),\n+                    )),\n                     GenericArgKind::Const(..) => {\n                         // Consts cannot outlive one another, so we don't expect to\n                         // ecounter this branch.\n@@ -664,7 +664,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         self.obligations.push(Obligation {\n             cause: self.cause.clone(),\n             param_env: self.param_env,\n-            predicate: ty::Predicate::RegionOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n+            predicate: ty::PredicateKind::RegionOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n                 sup, sub,\n             ))),\n             recursion_depth: 0,"}, {"sha": "2a188b21205565940e71d5467df1bb5e4cbe3bbe", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -307,7 +307,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             self.obligations.push(Obligation::new(\n                 self.trace.cause.clone(),\n                 self.param_env,\n-                ty::Predicate::WellFormed(b_ty),\n+                ty::PredicateKind::WellFormed(b_ty),\n             ));\n         }\n "}, {"sha": "e423137da8f7453f9d86a88b1cd3893a53c0c630", "filename": "src/librustc_infer/infer/outlives/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -12,16 +12,16 @@ pub fn explicit_outlives_bounds<'tcx>(\n ) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {\n     debug!(\"explicit_outlives_bounds()\");\n     param_env.caller_bounds.into_iter().filter_map(move |predicate| match predicate {\n-        ty::Predicate::Projection(..)\n-        | ty::Predicate::Trait(..)\n-        | ty::Predicate::Subtype(..)\n-        | ty::Predicate::WellFormed(..)\n-        | ty::Predicate::ObjectSafe(..)\n-        | ty::Predicate::ClosureKind(..)\n-        | ty::Predicate::TypeOutlives(..)\n-        | ty::Predicate::ConstEvaluatable(..)\n-        | ty::Predicate::ConstEquate(..) => None,\n-        ty::Predicate::RegionOutlives(ref data) => data\n+        ty::PredicateKind::Projection(..)\n+        | ty::PredicateKind::Trait(..)\n+        | ty::PredicateKind::Subtype(..)\n+        | ty::PredicateKind::WellFormed(..)\n+        | ty::PredicateKind::ObjectSafe(..)\n+        | ty::PredicateKind::ClosureKind(..)\n+        | ty::PredicateKind::TypeOutlives(..)\n+        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::ConstEquate(..) => None,\n+        ty::PredicateKind::RegionOutlives(ref data) => data\n             .no_bound_vars()\n             .map(|ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a)),\n     })"}, {"sha": "22231488b7b5c20742436dbfa5f97fc60332398a", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -100,7 +100,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n                 self.fields.obligations.push(Obligation::new(\n                     self.fields.trace.cause.clone(),\n                     self.fields.param_env,\n-                    ty::Predicate::Subtype(ty::Binder::dummy(ty::SubtypePredicate {\n+                    ty::PredicateKind::Subtype(ty::Binder::dummy(ty::SubtypePredicate {\n                         a_is_expected: self.a_is_expected,\n                         a,\n                         b,"}, {"sha": "400fe4d1321ca20510ea99f2257d8e10ffff36a1", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -11,39 +11,39 @@ pub fn anonymize_predicate<'tcx>(\n     pred: &ty::Predicate<'tcx>,\n ) -> ty::Predicate<'tcx> {\n     match *pred {\n-        ty::Predicate::Trait(ref data, constness) => {\n-            ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data), constness)\n+        ty::PredicateKind::Trait(ref data, constness) => {\n+            ty::PredicateKind::Trait(tcx.anonymize_late_bound_regions(data), constness)\n         }\n \n-        ty::Predicate::RegionOutlives(ref data) => {\n-            ty::Predicate::RegionOutlives(tcx.anonymize_late_bound_regions(data))\n+        ty::PredicateKind::RegionOutlives(ref data) => {\n+            ty::PredicateKind::RegionOutlives(tcx.anonymize_late_bound_regions(data))\n         }\n \n-        ty::Predicate::TypeOutlives(ref data) => {\n-            ty::Predicate::TypeOutlives(tcx.anonymize_late_bound_regions(data))\n+        ty::PredicateKind::TypeOutlives(ref data) => {\n+            ty::PredicateKind::TypeOutlives(tcx.anonymize_late_bound_regions(data))\n         }\n \n-        ty::Predicate::Projection(ref data) => {\n-            ty::Predicate::Projection(tcx.anonymize_late_bound_regions(data))\n+        ty::PredicateKind::Projection(ref data) => {\n+            ty::PredicateKind::Projection(tcx.anonymize_late_bound_regions(data))\n         }\n \n-        ty::Predicate::WellFormed(data) => ty::Predicate::WellFormed(data),\n+        ty::PredicateKind::WellFormed(data) => ty::PredicateKind::WellFormed(data),\n \n-        ty::Predicate::ObjectSafe(data) => ty::Predicate::ObjectSafe(data),\n+        ty::PredicateKind::ObjectSafe(data) => ty::PredicateKind::ObjectSafe(data),\n \n-        ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind)\n+        ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind)\n         }\n \n-        ty::Predicate::Subtype(ref data) => {\n-            ty::Predicate::Subtype(tcx.anonymize_late_bound_regions(data))\n+        ty::PredicateKind::Subtype(ref data) => {\n+            ty::PredicateKind::Subtype(tcx.anonymize_late_bound_regions(data))\n         }\n \n-        ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-            ty::Predicate::ConstEvaluatable(def_id, substs)\n+        ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs)\n         }\n \n-        ty::Predicate::ConstEquate(c1, c2) => ty::Predicate::ConstEquate(c1, c2),\n+        ty::PredicateKind::ConstEquate(c1, c2) => ty::Predicate::ConstEquate(c1, c2),\n     }\n }\n \n@@ -146,7 +146,7 @@ impl Elaborator<'tcx> {\n     fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n         let tcx = self.visited.tcx;\n         match obligation.predicate {\n-            ty::Predicate::Trait(ref data, _) => {\n+            ty::PredicateKind::Trait(ref data, _) => {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n@@ -167,36 +167,36 @@ impl Elaborator<'tcx> {\n \n                 self.stack.extend(obligations);\n             }\n-            ty::Predicate::WellFormed(..) => {\n+            ty::PredicateKind::WellFormed(..) => {\n                 // Currently, we do not elaborate WF predicates,\n                 // although we easily could.\n             }\n-            ty::Predicate::ObjectSafe(..) => {\n+            ty::PredicateKind::ObjectSafe(..) => {\n                 // Currently, we do not elaborate object-safe\n                 // predicates.\n             }\n-            ty::Predicate::Subtype(..) => {\n+            ty::PredicateKind::Subtype(..) => {\n                 // Currently, we do not \"elaborate\" predicates like `X <: Y`,\n                 // though conceivably we might.\n             }\n-            ty::Predicate::Projection(..) => {\n+            ty::PredicateKind::Projection(..) => {\n                 // Nothing to elaborate in a projection predicate.\n             }\n-            ty::Predicate::ClosureKind(..) => {\n+            ty::PredicateKind::ClosureKind(..) => {\n                 // Nothing to elaborate when waiting for a closure's kind to be inferred.\n             }\n-            ty::Predicate::ConstEvaluatable(..) => {\n+            ty::PredicateKind::ConstEvaluatable(..) => {\n                 // Currently, we do not elaborate const-evaluatable\n                 // predicates.\n             }\n-            ty::Predicate::ConstEquate(..) => {\n+            ty::PredicateKind::ConstEquate(..) => {\n                 // Currently, we do not elaborate const-equate\n                 // predicates.\n             }\n-            ty::Predicate::RegionOutlives(..) => {\n+            ty::PredicateKind::RegionOutlives(..) => {\n                 // Nothing to elaborate from `'a: 'b`.\n             }\n-            ty::Predicate::TypeOutlives(ref data) => {\n+            ty::PredicateKind::TypeOutlives(ref data) => {\n                 // We know that `T: 'a` for some type `T`. We can\n                 // often elaborate this. For example, if we know that\n                 // `[U]: 'a`, that implies that `U: 'a`. Similarly, if\n@@ -228,15 +228,15 @@ impl Elaborator<'tcx> {\n                                 if r.is_late_bound() {\n                                     None\n                                 } else {\n-                                    Some(ty::Predicate::RegionOutlives(ty::Binder::dummy(\n+                                    Some(ty::PredicateKind::RegionOutlives(ty::Binder::dummy(\n                                         ty::OutlivesPredicate(r, r_min),\n                                     )))\n                                 }\n                             }\n \n                             Component::Param(p) => {\n                                 let ty = tcx.mk_ty_param(p.index, p.name);\n-                                Some(ty::Predicate::TypeOutlives(ty::Binder::dummy(\n+                                Some(ty::PredicateKind::TypeOutlives(ty::Binder::dummy(\n                                     ty::OutlivesPredicate(ty, r_min),\n                                 )))\n                             }\n@@ -317,7 +317,7 @@ impl<'tcx, I: Iterator<Item = PredicateObligation<'tcx>>> Iterator for FilterToT\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n         while let Some(obligation) = self.base_iterator.next() {\n-            if let ty::Predicate::Trait(data, _) = obligation.predicate {\n+            if let ty::PredicateKind::Trait(data, _) = obligation.predicate {\n                 return Some(data.to_poly_trait_ref());\n             }\n         }"}, {"sha": "6e1258e25bbaf474bbf4ef0697a7ccdd16cff95c", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -1202,7 +1202,7 @@ declare_lint_pass!(\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item<'tcx>) {\n         use rustc_middle::ty::fold::TypeFoldable;\n-        use rustc_middle::ty::Predicate::*;\n+        use rustc_middle::ty::PredicateKind::*;\n \n         if cx.tcx.features().trivial_bounds {\n             let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n@@ -1498,7 +1498,7 @@ impl ExplicitOutlivesRequirements {\n         inferred_outlives\n             .iter()\n             .filter_map(|(pred, _)| match pred {\n-                ty::Predicate::RegionOutlives(outlives) => {\n+                ty::PredicateKind::RegionOutlives(outlives) => {\n                     let outlives = outlives.skip_binder();\n                     match outlives.0 {\n                         ty::ReEarlyBound(ebr) if ebr.index == index => Some(outlives.1),\n@@ -1517,7 +1517,7 @@ impl ExplicitOutlivesRequirements {\n         inferred_outlives\n             .iter()\n             .filter_map(|(pred, _)| match pred {\n-                ty::Predicate::TypeOutlives(outlives) => {\n+                ty::PredicateKind::TypeOutlives(outlives) => {\n                     let outlives = outlives.skip_binder();\n                     outlives.0.is_param(index).then_some(outlives.1)\n                 }"}, {"sha": "19146f68fce80e4552c1e4f6fb5f39f2ef091d4a", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -146,7 +146,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                 ty::Opaque(def, _) => {\n                     let mut has_emitted = false;\n                     for (predicate, _) in cx.tcx.predicates_of(def).predicates {\n-                        if let ty::Predicate::Trait(ref poly_trait_predicate, _) = predicate {\n+                        if let ty::PredicateKind::Trait(ref poly_trait_predicate, _) = predicate {\n                             let trait_ref = poly_trait_predicate.skip_binder().trait_ref;\n                             let def_id = trait_ref.def_id;\n                             let descr_pre ="}, {"sha": "7ebeb6243be411988d4ac6c891eb5dccd2b7c970", "filename": "src/librustc_middle/ty/codec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcodec.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -201,9 +201,9 @@ where\n                     assert!(pos >= SHORTHAND_OFFSET);\n                     let shorthand = pos - SHORTHAND_OFFSET;\n \n-                    decoder.with_position(shorthand, ty::Predicate::decode)\n+                    decoder.with_position(shorthand, ty::PredicateKind::decode)\n                 } else {\n-                    ty::Predicate::decode(decoder)\n+                    ty::PredicateKind::decode(decoder)\n                 }?;\n                 Ok((predicate, Decodable::decode(decoder)?))\n             })"}, {"sha": "e3aeb242dc034d23b1046e7ba0d31a6a0a25d55c", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -1016,9 +1016,11 @@ impl<'tcx> GenericPredicates<'tcx> {\n     }\n }\n \n+pub type Predicate<'tcx> = PredicateKind<'tcx>;\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n #[derive(HashStable, TypeFoldable)]\n-pub enum Predicate<'tcx> {\n+pub enum PredicateKind<'tcx> {\n     /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the type parameters.\n@@ -1079,7 +1081,7 @@ impl<'tcx> AsRef<Predicate<'tcx>> for Predicate<'tcx> {\n     }\n }\n \n-impl<'tcx> Predicate<'tcx> {\n+impl<'tcx> PredicateKind<'tcx> {\n     /// Performs a substitution suitable for going from a\n     /// poly-trait-ref to supertraits that must hold if that\n     /// poly-trait-ref holds. This is slightly different from a normal\n@@ -1152,31 +1154,31 @@ impl<'tcx> Predicate<'tcx> {\n \n         let substs = &trait_ref.skip_binder().substs;\n         match *self {\n-            Predicate::Trait(ref binder, constness) => {\n-                Predicate::Trait(binder.map_bound(|data| data.subst(tcx, substs)), constness)\n+            PredicateKind::Trait(ref binder, constness) => {\n+                PredicateKind::Trait(binder.map_bound(|data| data.subst(tcx, substs)), constness)\n             }\n-            Predicate::Subtype(ref binder) => {\n-                Predicate::Subtype(binder.map_bound(|data| data.subst(tcx, substs)))\n+            PredicateKind::Subtype(ref binder) => {\n+                PredicateKind::Subtype(binder.map_bound(|data| data.subst(tcx, substs)))\n             }\n-            Predicate::RegionOutlives(ref binder) => {\n-                Predicate::RegionOutlives(binder.map_bound(|data| data.subst(tcx, substs)))\n+            PredicateKind::RegionOutlives(ref binder) => {\n+                PredicateKind::RegionOutlives(binder.map_bound(|data| data.subst(tcx, substs)))\n             }\n-            Predicate::TypeOutlives(ref binder) => {\n-                Predicate::TypeOutlives(binder.map_bound(|data| data.subst(tcx, substs)))\n+            PredicateKind::TypeOutlives(ref binder) => {\n+                PredicateKind::TypeOutlives(binder.map_bound(|data| data.subst(tcx, substs)))\n             }\n-            Predicate::Projection(ref binder) => {\n-                Predicate::Projection(binder.map_bound(|data| data.subst(tcx, substs)))\n+            PredicateKind::Projection(ref binder) => {\n+                PredicateKind::Projection(binder.map_bound(|data| data.subst(tcx, substs)))\n             }\n-            Predicate::WellFormed(data) => Predicate::WellFormed(data.subst(tcx, substs)),\n-            Predicate::ObjectSafe(trait_def_id) => Predicate::ObjectSafe(trait_def_id),\n-            Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                Predicate::ClosureKind(closure_def_id, closure_substs.subst(tcx, substs), kind)\n+            PredicateKind::WellFormed(data) => PredicateKind::WellFormed(data.subst(tcx, substs)),\n+            PredicateKind::ObjectSafe(trait_def_id) => PredicateKind::ObjectSafe(trait_def_id),\n+            PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                PredicateKind::ClosureKind(closure_def_id, closure_substs.subst(tcx, substs), kind)\n             }\n-            Predicate::ConstEvaluatable(def_id, const_substs) => {\n-                Predicate::ConstEvaluatable(def_id, const_substs.subst(tcx, substs))\n+            PredicateKind::ConstEvaluatable(def_id, const_substs) => {\n+                PredicateKind::ConstEvaluatable(def_id, const_substs.subst(tcx, substs))\n             }\n-            Predicate::ConstEquate(c1, c2) => {\n-                Predicate::ConstEquate(c1.subst(tcx, substs), c2.subst(tcx, substs))\n+            PredicateKind::ConstEquate(c1, c2) => {\n+                PredicateKind::ConstEquate(c1.subst(tcx, substs), c2.subst(tcx, substs))\n             }\n         }\n     }\n@@ -1298,7 +1300,7 @@ pub trait ToPredicate<'tcx> {\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n     fn to_predicate(&self) -> Predicate<'tcx> {\n-        ty::Predicate::Trait(\n+        ty::PredicateKind::Trait(\n             ty::Binder::dummy(ty::TraitPredicate { trait_ref: self.value }),\n             self.constness,\n         )\n@@ -1307,7 +1309,7 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&TraitRef<'tcx>> {\n     fn to_predicate(&self) -> Predicate<'tcx> {\n-        ty::Predicate::Trait(\n+        ty::PredicateKind::Trait(\n             ty::Binder::dummy(ty::TraitPredicate { trait_ref: *self.value }),\n             self.constness,\n         )\n@@ -1316,62 +1318,62 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&TraitRef<'tcx>> {\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n     fn to_predicate(&self) -> Predicate<'tcx> {\n-        ty::Predicate::Trait(self.value.to_poly_trait_predicate(), self.constness)\n+        ty::PredicateKind::Trait(self.value.to_poly_trait_predicate(), self.constness)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&PolyTraitRef<'tcx>> {\n     fn to_predicate(&self) -> Predicate<'tcx> {\n-        ty::Predicate::Trait(self.value.to_poly_trait_predicate(), self.constness)\n+        ty::PredicateKind::Trait(self.value.to_poly_trait_predicate(), self.constness)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(&self) -> Predicate<'tcx> {\n-        Predicate::RegionOutlives(*self)\n+        PredicateKind::RegionOutlives(*self)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n     fn to_predicate(&self) -> Predicate<'tcx> {\n-        Predicate::TypeOutlives(*self)\n+        PredicateKind::TypeOutlives(*self)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     fn to_predicate(&self) -> Predicate<'tcx> {\n-        Predicate::Projection(*self)\n+        PredicateKind::Projection(*self)\n     }\n }\n \n-impl<'tcx> Predicate<'tcx> {\n+impl<'tcx> PredicateKind<'tcx> {\n     pub fn to_opt_poly_trait_ref(&self) -> Option<PolyTraitRef<'tcx>> {\n         match *self {\n-            Predicate::Trait(ref t, _) => Some(t.to_poly_trait_ref()),\n-            Predicate::Projection(..)\n-            | Predicate::Subtype(..)\n-            | Predicate::RegionOutlives(..)\n-            | Predicate::WellFormed(..)\n-            | Predicate::ObjectSafe(..)\n-            | Predicate::ClosureKind(..)\n-            | Predicate::TypeOutlives(..)\n-            | Predicate::ConstEvaluatable(..)\n-            | Predicate::ConstEquate(..) => None,\n+            PredicateKind::Trait(ref t, _) => Some(t.to_poly_trait_ref()),\n+            PredicateKind::Projection(..)\n+            | PredicateKind::Subtype(..)\n+            | PredicateKind::RegionOutlives(..)\n+            | PredicateKind::WellFormed(..)\n+            | PredicateKind::ObjectSafe(..)\n+            | PredicateKind::ClosureKind(..)\n+            | PredicateKind::TypeOutlives(..)\n+            | PredicateKind::ConstEvaluatable(..)\n+            | PredicateKind::ConstEquate(..) => None,\n         }\n     }\n \n     pub fn to_opt_type_outlives(&self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n         match *self {\n-            Predicate::TypeOutlives(data) => Some(data),\n-            Predicate::Trait(..)\n-            | Predicate::Projection(..)\n-            | Predicate::Subtype(..)\n-            | Predicate::RegionOutlives(..)\n-            | Predicate::WellFormed(..)\n-            | Predicate::ObjectSafe(..)\n-            | Predicate::ClosureKind(..)\n-            | Predicate::ConstEvaluatable(..)\n-            | Predicate::ConstEquate(..) => None,\n+            PredicateKind::TypeOutlives(data) => Some(data),\n+            PredicateKind::Trait(..)\n+            | PredicateKind::Projection(..)\n+            | PredicateKind::Subtype(..)\n+            | PredicateKind::RegionOutlives(..)\n+            | PredicateKind::WellFormed(..)\n+            | PredicateKind::ObjectSafe(..)\n+            | PredicateKind::ClosureKind(..)\n+            | PredicateKind::ConstEvaluatable(..)\n+            | PredicateKind::ConstEquate(..) => None,\n         }\n     }\n }"}, {"sha": "c224c937b07fec62c2ca802390bfd0448c722ce3", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -2032,28 +2032,28 @@ define_print_and_forward_display! {\n \n     ty::Predicate<'tcx> {\n         match *self {\n-            ty::Predicate::Trait(ref data, constness) => {\n+            ty::PredicateKind::Trait(ref data, constness) => {\n                 if let hir::Constness::Const = constness {\n                     p!(write(\"const \"));\n                 }\n                 p!(print(data))\n             }\n-            ty::Predicate::Subtype(ref predicate) => p!(print(predicate)),\n-            ty::Predicate::RegionOutlives(ref predicate) => p!(print(predicate)),\n-            ty::Predicate::TypeOutlives(ref predicate) => p!(print(predicate)),\n-            ty::Predicate::Projection(ref predicate) => p!(print(predicate)),\n-            ty::Predicate::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n-            ty::Predicate::ObjectSafe(trait_def_id) => {\n+            ty::PredicateKind::Subtype(ref predicate) => p!(print(predicate)),\n+            ty::PredicateKind::RegionOutlives(ref predicate) => p!(print(predicate)),\n+            ty::PredicateKind::TypeOutlives(ref predicate) => p!(print(predicate)),\n+            ty::PredicateKind::Projection(ref predicate) => p!(print(predicate)),\n+            ty::PredicateKind::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n+            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 p!(write(\"the trait `\"),\n                    print_def_path(trait_def_id, &[]),\n                    write(\"` is object-safe\"))\n             }\n-            ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n+            ty::PredicateKind::ClosureKind(closure_def_id, _closure_substs, kind) => {\n                 p!(write(\"the closure `\"),\n                    print_value_path(closure_def_id, &[]),\n                    write(\"` implements the trait `{}`\", kind))\n             }\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                 p!(write(\"the constant `\"),\n                    print_value_path(def_id, substs),\n                    write(\"` can be evaluated\"))"}, {"sha": "54f34a3e07815ff19cb36ba4bce6e51d777b03c5", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -219,25 +219,27 @@ impl fmt::Debug for ty::ProjectionPredicate<'tcx> {\n     }\n }\n \n-impl fmt::Debug for ty::Predicate<'tcx> {\n+impl fmt::Debug for ty::PredicateKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            ty::Predicate::Trait(ref a, constness) => {\n+            ty::PredicateKind::Trait(ref a, constness) => {\n                 if let hir::Constness::Const = constness {\n                     write!(f, \"const \")?;\n                 }\n                 a.fmt(f)\n             }\n-            ty::Predicate::Subtype(ref pair) => pair.fmt(f),\n-            ty::Predicate::RegionOutlives(ref pair) => pair.fmt(f),\n-            ty::Predicate::TypeOutlives(ref pair) => pair.fmt(f),\n-            ty::Predicate::Projection(ref pair) => pair.fmt(f),\n-            ty::Predicate::WellFormed(ty) => write!(f, \"WellFormed({:?})\", ty),\n-            ty::Predicate::ObjectSafe(trait_def_id) => write!(f, \"ObjectSafe({:?})\", trait_def_id),\n-            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::PredicateKind::Subtype(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::RegionOutlives(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::TypeOutlives(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::Projection(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::WellFormed(ty) => write!(f, \"WellFormed({:?})\", ty),\n+            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+                write!(f, \"ObjectSafe({:?})\", trait_def_id)\n+            }\n+            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n                 write!(f, \"ClosureKind({:?}, {:?}, {:?})\", closure_def_id, closure_substs, kind)\n             }\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                 write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n             }\n             ty::Predicate::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n@@ -471,30 +473,32 @@ impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n     type Lifted = ty::Predicate<'tcx>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n-            ty::Predicate::Trait(ref binder, constness) => {\n-                tcx.lift(binder).map(|binder| ty::Predicate::Trait(binder, constness))\n+            ty::PredicateKind::Trait(ref binder, constness) => {\n+                tcx.lift(binder).map(|binder| ty::PredicateKind::Trait(binder, constness))\n+            }\n+            ty::PredicateKind::Subtype(ref binder) => {\n+                tcx.lift(binder).map(ty::PredicateKind::Subtype)\n             }\n-            ty::Predicate::Subtype(ref binder) => tcx.lift(binder).map(ty::Predicate::Subtype),\n-            ty::Predicate::RegionOutlives(ref binder) => {\n-                tcx.lift(binder).map(ty::Predicate::RegionOutlives)\n+            ty::PredicateKind::RegionOutlives(ref binder) => {\n+                tcx.lift(binder).map(ty::PredicateKind::RegionOutlives)\n             }\n-            ty::Predicate::TypeOutlives(ref binder) => {\n-                tcx.lift(binder).map(ty::Predicate::TypeOutlives)\n+            ty::PredicateKind::TypeOutlives(ref binder) => {\n+                tcx.lift(binder).map(ty::PredicateKind::TypeOutlives)\n             }\n-            ty::Predicate::Projection(ref binder) => {\n-                tcx.lift(binder).map(ty::Predicate::Projection)\n+            ty::PredicateKind::Projection(ref binder) => {\n+                tcx.lift(binder).map(ty::PredicateKind::Projection)\n             }\n-            ty::Predicate::WellFormed(ty) => tcx.lift(&ty).map(ty::Predicate::WellFormed),\n-            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::PredicateKind::WellFormed(ty) => tcx.lift(&ty).map(ty::PredicateKind::WellFormed),\n+            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n                 tcx.lift(&closure_substs).map(|closure_substs| {\n-                    ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind)\n+                    ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind)\n                 })\n             }\n-            ty::Predicate::ObjectSafe(trait_def_id) => {\n-                Some(ty::Predicate::ObjectSafe(trait_def_id))\n+            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+                Some(ty::PredicateKind::ObjectSafe(trait_def_id))\n             }\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                tcx.lift(&substs).map(|substs| ty::Predicate::ConstEvaluatable(def_id, substs))\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n+                tcx.lift(&substs).map(|substs| ty::PredicateKind::ConstEvaluatable(def_id, substs))\n             }\n             ty::Predicate::ConstEquate(c1, c2) => {\n                 tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::Predicate::ConstEquate(c1, c2))"}, {"sha": "8962b243911b292ac6cee61d222857113d2d06b3", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -615,7 +615,7 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n                 Binder(tr).with_self_ty(tcx, self_ty).without_const().to_predicate()\n             }\n             ExistentialPredicate::Projection(p) => {\n-                ty::Predicate::Projection(Binder(p.with_self_ty(tcx, self_ty)))\n+                ty::PredicateKind::Projection(Binder(p.with_self_ty(tcx, self_ty)))\n             }\n             ExistentialPredicate::AutoTrait(did) => {\n                 let trait_ref ="}, {"sha": "d7ea88725ed1bcd75cfeccac2cf04acbdc3f10bc", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -576,7 +576,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                     let mut found = false;\n                     for predicate in bounds.predicates {\n-                        if let ty::Predicate::TypeOutlives(binder) = predicate {\n+                        if let ty::PredicateKind::TypeOutlives(binder) = predicate {\n                             if let ty::OutlivesPredicate(_, ty::RegionKind::ReStatic) =\n                                 binder.skip_binder()\n                             {"}, {"sha": "d3b1b92bdcd1044541eac427799eea81e344e891", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -1016,7 +1016,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     self.prove_predicate(\n-                        ty::Predicate::WellFormed(inferred_ty),\n+                        ty::PredicateKind::WellFormed(inferred_ty),\n                         Locations::All(span),\n                         ConstraintCategory::TypeAnnotation,\n                     );\n@@ -1268,7 +1268,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     obligations.obligations.push(traits::Obligation::new(\n                         ObligationCause::dummy(),\n                         param_env,\n-                        ty::Predicate::WellFormed(revealed_ty),\n+                        ty::PredicateKind::WellFormed(revealed_ty),\n                     ));\n                     obligations.add(\n                         infcx\n@@ -1612,7 +1612,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 self.check_call_dest(body, term, &sig, destination, term_location);\n \n                 self.prove_predicates(\n-                    sig.inputs_and_output.iter().map(|ty| ty::Predicate::WellFormed(ty)),\n+                    sig.inputs_and_output.iter().map(|ty| ty::PredicateKind::WellFormed(ty)),\n                     term_location.to_locations(),\n                     ConstraintCategory::Boring,\n                 );\n@@ -2017,7 +2017,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                         traits::ObligationCauseCode::RepeatVec(should_suggest),\n                                     ),\n                                     self.param_env,\n-                                    ty::Predicate::Trait(\n+                                    ty::PredicateKind::Trait(\n                                         ty::Binder::bind(ty::TraitPredicate {\n                                             trait_ref: ty::TraitRef::new(\n                                                 self.tcx().require_lang_item(\n@@ -2686,7 +2686,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory,\n     ) {\n         self.prove_predicates(\n-            Some(ty::Predicate::Trait(\n+            Some(ty::PredicateKind::Trait(\n                 trait_ref.to_poly_trait_ref().to_poly_trait_predicate(),\n                 hir::Constness::NotConst,\n             )),"}, {"sha": "7fdf9133dd4b9da7cccf8d81b404e389d03a0481", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -3,7 +3,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, adjustment::PointerCast, Predicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, adjustment::PointerCast, Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use std::borrow::Cow;\n@@ -24,20 +24,22 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n         let predicates = tcx.predicates_of(current);\n         for (predicate, _) in predicates.predicates {\n             match predicate {\n-                Predicate::RegionOutlives(_)\n-                | Predicate::TypeOutlives(_)\n-                | Predicate::WellFormed(_)\n-                | Predicate::Projection(_)\n-                | Predicate::ConstEvaluatable(..)\n-                | Predicate::ConstEquate(..) => continue,\n-                Predicate::ObjectSafe(_) => {\n+                ty::PredicateKind::RegionOutlives(_)\n+                | ty::PredicateKind::TypeOutlives(_)\n+                | ty::PredicateKind::WellFormed(_)\n+                | ty::PredicateKind::Projection(_)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..) => continue,\n+                ty::PredicateKind::ObjectSafe(_) => {\n                     bug!(\"object safe predicate on function: {:#?}\", predicate)\n                 }\n-                Predicate::ClosureKind(..) => {\n+                ty::PredicateKind::ClosureKind(..) => {\n                     bug!(\"closure kind predicate on function: {:#?}\", predicate)\n                 }\n-                Predicate::Subtype(_) => bug!(\"subtype predicate on function: {:#?}\", predicate),\n-                Predicate::Trait(pred, constness) => {\n+                ty::PredicateKind::Subtype(_) => {\n+                    bug!(\"subtype predicate on function: {:#?}\", predicate)\n+                }\n+                ty::PredicateKind::Trait(pred, constness) => {\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;\n                     }"}, {"sha": "64a2a9055f323fff669eaeab30aa664cdeeb9a8c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -91,13 +91,13 @@ where\n         let ty::GenericPredicates { parent: _, predicates } = predicates;\n         for (predicate, _span) in predicates {\n             match predicate {\n-                ty::Predicate::Trait(poly_predicate, _) => {\n+                ty::PredicateKind::Trait(poly_predicate, _) => {\n                     let ty::TraitPredicate { trait_ref } = *poly_predicate.skip_binder();\n                     if self.visit_trait(trait_ref) {\n                         return true;\n                     }\n                 }\n-                ty::Predicate::Projection(poly_predicate) => {\n+                ty::PredicateKind::Projection(poly_predicate) => {\n                     let ty::ProjectionPredicate { projection_ty, ty } =\n                         *poly_predicate.skip_binder();\n                     if ty.visit_with(self) {\n@@ -107,13 +107,13 @@ where\n                         return true;\n                     }\n                 }\n-                ty::Predicate::TypeOutlives(poly_predicate) => {\n+                ty::PredicateKind::TypeOutlives(poly_predicate) => {\n                     let ty::OutlivesPredicate(ty, _region) = *poly_predicate.skip_binder();\n                     if ty.visit_with(self) {\n                         return true;\n                     }\n                 }\n-                ty::Predicate::RegionOutlives(..) => {}\n+                ty::PredicateKind::RegionOutlives(..) => {}\n                 _ => bug!(\"unexpected predicate: {:?}\", predicate),\n             }\n         }"}, {"sha": "472f93201c3824912724bd524492ec607e6fb091", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -1168,7 +1168,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n \n         for predicate in &bounds.predicates {\n-            if let ty::Predicate::Projection(projection) = &predicate {\n+            if let ty::PredicateKind::Projection(projection) = &predicate {\n                 if projection.skip_binder().ty.references_error() {\n                     // No point on adding these obligations since there's a type error involved.\n                     return ty_var;\n@@ -1270,16 +1270,16 @@ crate fn required_region_bounds(\n         .filter_map(|obligation| {\n             debug!(\"required_region_bounds(obligation={:?})\", obligation);\n             match obligation.predicate {\n-                ty::Predicate::Projection(..)\n-                | ty::Predicate::Trait(..)\n-                | ty::Predicate::Subtype(..)\n-                | ty::Predicate::WellFormed(..)\n-                | ty::Predicate::ObjectSafe(..)\n-                | ty::Predicate::ClosureKind(..)\n-                | ty::Predicate::RegionOutlives(..)\n-                | ty::Predicate::ConstEvaluatable(..)\n-                | ty::Predicate::ConstEquate(..) => None,\n-                ty::Predicate::TypeOutlives(predicate) => {\n+                ty::PredicateKind::Projection(..)\n+                | ty::PredicateKind::Trait(..)\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..) => None,\n+                ty::PredicateKind::TypeOutlives(predicate) => {\n                     // Search for a bound of the form `erased_self_ty\n                     // : 'a`, but be wary of something like `for<'a>\n                     // erased_self_ty : 'a` (we interpret a"}, {"sha": "af9623c49981d7f67e3af4cb3b4f2336be7d42fb", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -341,7 +341,7 @@ impl AutoTraitFinder<'tcx> {\n                         already_visited.remove(&pred);\n                         self.add_user_pred(\n                             &mut user_computed_preds,\n-                            ty::Predicate::Trait(pred, hir::Constness::NotConst),\n+                            ty::PredicateKind::Trait(pred, hir::Constness::NotConst),\n                         );\n                         predicates.push_back(pred);\n                     } else {\n@@ -411,8 +411,10 @@ impl AutoTraitFinder<'tcx> {\n     ) {\n         let mut should_add_new = true;\n         user_computed_preds.retain(|&old_pred| {\n-            if let (&ty::Predicate::Trait(new_trait, _), ty::Predicate::Trait(old_trait, _)) =\n-                (&new_pred, old_pred)\n+            if let (\n+                &ty::PredicateKind::Trait(new_trait, _),\n+                ty::PredicateKind::Trait(old_trait, _),\n+            ) = (&new_pred, old_pred)\n             {\n                 if new_trait.def_id() == old_trait.def_id() {\n                     let new_substs = new_trait.skip_binder().trait_ref.substs;\n@@ -631,7 +633,7 @@ impl AutoTraitFinder<'tcx> {\n             // We check this by calling is_of_param on the relevant types\n             // from the various possible predicates\n             match &predicate {\n-                &ty::Predicate::Trait(p, _) => {\n+                &ty::PredicateKind::Trait(p, _) => {\n                     if self.is_param_no_infer(p.skip_binder().trait_ref.substs)\n                         && !only_projections\n                         && is_new_pred\n@@ -640,7 +642,7 @@ impl AutoTraitFinder<'tcx> {\n                     }\n                     predicates.push_back(p);\n                 }\n-                &ty::Predicate::Projection(p) => {\n+                &ty::PredicateKind::Projection(p) => {\n                     debug!(\n                         \"evaluate_nested_obligations: examining projection predicate {:?}\",\n                         predicate\n@@ -765,12 +767,12 @@ impl AutoTraitFinder<'tcx> {\n                         }\n                     }\n                 }\n-                &ty::Predicate::RegionOutlives(ref binder) => {\n+                &ty::PredicateKind::RegionOutlives(ref binder) => {\n                     if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n                         return false;\n                     }\n                 }\n-                &ty::Predicate::TypeOutlives(ref binder) => {\n+                &ty::PredicateKind::TypeOutlives(ref binder) => {\n                     match (\n                         binder.no_bound_vars(),\n                         binder.map_bound_ref(|pred| pred.0).no_bound_vars(),"}, {"sha": "ac119a0c3d81119ea22082bec14d375ff89f93dc", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     return;\n                 }\n                 match obligation.predicate {\n-                    ty::Predicate::Trait(ref trait_predicate, _) => {\n+                    ty::PredicateKind::Trait(ref trait_predicate, _) => {\n                         let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n \n                         if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n@@ -468,7 +468,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 trait_pred\n                             });\n                             let unit_obligation = Obligation {\n-                                predicate: ty::Predicate::Trait(\n+                                predicate: ty::PredicateKind::Trait(\n                                     predicate,\n                                     hir::Constness::NotConst,\n                                 ),\n@@ -489,14 +489,14 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         err\n                     }\n \n-                    ty::Predicate::Subtype(ref predicate) => {\n+                    ty::PredicateKind::Subtype(ref predicate) => {\n                         // Errors for Subtype predicates show up as\n                         // `FulfillmentErrorCode::CodeSubtypeError`,\n                         // not selection error.\n                         span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n                     }\n \n-                    ty::Predicate::RegionOutlives(ref predicate) => {\n+                    ty::PredicateKind::RegionOutlives(ref predicate) => {\n                         let predicate = self.resolve_vars_if_possible(predicate);\n                         let err = self\n                             .region_outlives_predicate(&obligation.cause, &predicate)\n@@ -512,7 +512,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         )\n                     }\n \n-                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n+                    ty::PredicateKind::Projection(..) | ty::PredicateKind::TypeOutlives(..) => {\n                         let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n                         struct_span_err!(\n                             self.tcx.sess,\n@@ -523,12 +523,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         )\n                     }\n \n-                    ty::Predicate::ObjectSafe(trait_def_id) => {\n+                    ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                         let violations = self.tcx.object_safety_violations(trait_def_id);\n                         report_object_safety_error(self.tcx, span, trait_def_id, violations)\n                     }\n \n-                    ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                    ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n                         let found_kind = self.closure_kind(closure_substs).unwrap();\n                         let closure_span =\n                             self.tcx.sess.source_map().guess_head_span(\n@@ -587,7 +587,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         return;\n                     }\n \n-                    ty::Predicate::WellFormed(ty) => {\n+                    ty::PredicateKind::WellFormed(ty) => {\n                         if !self.tcx.sess.opts.debugging_opts.chalk {\n                             // WF predicates cannot themselves make\n                             // errors. They can only block due to\n@@ -605,7 +605,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         }\n                     }\n \n-                    ty::Predicate::ConstEvaluatable(..) => {\n+                    ty::PredicateKind::ConstEvaluatable(..) => {\n                         // Errors for `ConstEvaluatable` predicates show up as\n                         // `SelectionError::ConstEvalFailure`,\n                         // not `Unimplemented`.\n@@ -1047,15 +1047,17 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n \n         let (cond, error) = match (cond, error) {\n-            (&ty::Predicate::Trait(..), &ty::Predicate::Trait(ref error, _)) => (cond, error),\n+            (&ty::PredicateKind::Trait(..), &ty::PredicateKind::Trait(ref error, _)) => {\n+                (cond, error)\n+            }\n             _ => {\n                 // FIXME: make this work in other cases too.\n                 return false;\n             }\n         };\n \n         for obligation in super::elaborate_predicates(self.tcx, std::iter::once(*cond)) {\n-            if let ty::Predicate::Trait(implication, _) = obligation.predicate {\n+            if let ty::PredicateKind::Trait(implication, _) = obligation.predicate {\n                 let error = error.to_poly_trait_ref();\n                 let implication = implication.to_poly_trait_ref();\n                 // FIXME: I'm just not taking associated types at all here.\n@@ -1135,7 +1137,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             //\n             // this can fail if the problem was higher-ranked, in which\n             // cause I have no idea for a good error message.\n-            if let ty::Predicate::Projection(ref data) = predicate {\n+            if let ty::PredicateKind::Projection(ref data) = predicate {\n                 let mut selcx = SelectionContext::new(self);\n                 let (data, _) = self.replace_bound_vars_with_fresh_vars(\n                     obligation.cause.span,\n@@ -1416,7 +1418,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n \n         let mut err = match predicate {\n-            ty::Predicate::Trait(ref data, _) => {\n+            ty::PredicateKind::Trait(ref data, _) => {\n                 let trait_ref = data.to_poly_trait_ref();\n                 let self_ty = trait_ref.self_ty();\n                 debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind, trait_ref);\n@@ -1515,7 +1517,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 err\n             }\n \n-            ty::Predicate::WellFormed(ty) => {\n+            ty::PredicateKind::WellFormed(ty) => {\n                 // Same hacky approach as above to avoid deluging user\n                 // with error messages.\n                 if ty.references_error() || self.tcx.sess.has_errors() {\n@@ -1524,7 +1526,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.need_type_info_err(body_id, span, ty, ErrorCode::E0282)\n             }\n \n-            ty::Predicate::Subtype(ref data) => {\n+            ty::PredicateKind::Subtype(ref data) => {\n                 if data.references_error() || self.tcx.sess.has_errors() {\n                     // no need to overload user in such cases\n                     return;\n@@ -1534,7 +1536,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 assert!(a.is_ty_var() && b.is_ty_var());\n                 self.need_type_info_err(body_id, span, a, ErrorCode::E0282)\n             }\n-            ty::Predicate::Projection(ref data) => {\n+            ty::PredicateKind::Projection(ref data) => {\n                 let trait_ref = data.to_poly_trait_ref(self.tcx);\n                 let self_ty = trait_ref.self_ty();\n                 let ty = data.skip_binder().ty;\n@@ -1658,7 +1660,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n         if let (\n-            ty::Predicate::Trait(pred, _),\n+            ty::PredicateKind::Trait(pred, _),\n             ObligationCauseCode::BindingObligation(item_def_id, span),\n         ) = (&obligation.predicate, &obligation.cause.code)\n         {"}, {"sha": "5baaf838caa72618625520886276a290f423366b", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -1238,7 +1238,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // bound was introduced. At least one generator should be present for this diagnostic to be\n         // modified.\n         let (mut trait_ref, mut target_ty) = match obligation.predicate {\n-            ty::Predicate::Trait(p, _) => {\n+            ty::PredicateKind::Trait(p, _) => {\n                 (Some(p.skip_binder().trait_ref), Some(p.skip_binder().self_ty()))\n             }\n             _ => (None, None),"}, {"sha": "0497dec4029d12ec36f644e96e1a9b50c5cff3da", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -323,7 +323,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n         let infcx = self.selcx.infcx();\n \n         match obligation.predicate {\n-            ty::Predicate::Trait(ref data, _) => {\n+            ty::PredicateKind::Trait(ref data, _) => {\n                 let trait_obligation = obligation.with(*data);\n \n                 if data.is_global() {\n@@ -378,14 +378,14 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::RegionOutlives(ref binder) => {\n+            ty::PredicateKind::RegionOutlives(ref binder) => {\n                 match infcx.region_outlives_predicate(&obligation.cause, binder) {\n                     Ok(()) => ProcessResult::Changed(vec![]),\n                     Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n                 }\n             }\n \n-            ty::Predicate::TypeOutlives(ref binder) => {\n+            ty::PredicateKind::TypeOutlives(ref binder) => {\n                 // Check if there are higher-ranked vars.\n                 match binder.no_bound_vars() {\n                     // If there are, inspect the underlying type further.\n@@ -429,7 +429,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::Projection(ref data) => {\n+            ty::PredicateKind::Projection(ref data) => {\n                 let project_obligation = obligation.with(*data);\n                 match project::poly_project_and_unify_type(self.selcx, &project_obligation) {\n                     Ok(None) => {\n@@ -443,15 +443,15 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::ObjectSafe(trait_def_id) => {\n+            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 if !self.selcx.tcx().is_object_safe(trait_def_id) {\n                     ProcessResult::Error(CodeSelectionError(Unimplemented))\n                 } else {\n                     ProcessResult::Changed(vec![])\n                 }\n             }\n \n-            ty::Predicate::ClosureKind(_, closure_substs, kind) => {\n+            ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {\n                 match self.selcx.infcx().closure_kind(closure_substs) {\n                     Some(closure_kind) => {\n                         if closure_kind.extends(kind) {\n@@ -464,7 +464,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::WellFormed(ty) => {\n+            ty::PredicateKind::WellFormed(ty) => {\n                 match wf::obligations(\n                     self.selcx.infcx(),\n                     obligation.param_env,\n@@ -481,7 +481,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::Subtype(ref subtype) => {\n+            ty::PredicateKind::Subtype(ref subtype) => {\n                 match self.selcx.infcx().subtype_predicate(\n                     &obligation.cause,\n                     obligation.param_env,\n@@ -510,7 +510,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                 match self.selcx.infcx().const_eval_resolve(\n                     obligation.param_env,\n                     def_id,"}, {"sha": "99d434c5c9292d7199f2b6ee4c8adc1af70db919", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -334,7 +334,7 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // TypeOutlives predicates - these are normally used by regionck.\n     let outlives_predicates: Vec<_> = predicates\n         .drain_filter(|predicate| match predicate {\n-            ty::Predicate::TypeOutlives(..) => true,\n+            ty::PredicateKind::TypeOutlives(..) => true,\n             _ => false,\n         })\n         .collect();"}, {"sha": "bb727055d03fbb8e8201d6346732cedfe9c143ad", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -246,15 +246,15 @@ fn predicates_reference_self(\n         .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), sp))\n         .filter_map(|(predicate, &sp)| {\n             match predicate {\n-                ty::Predicate::Trait(ref data, _) => {\n+                ty::PredicateKind::Trait(ref data, _) => {\n                     // In the case of a trait predicate, we can skip the \"self\" type.\n                     if data.skip_binder().trait_ref.substs[1..].iter().any(has_self_ty) {\n                         Some(sp)\n                     } else {\n                         None\n                     }\n                 }\n-                ty::Predicate::Projection(ref data) => {\n+                ty::PredicateKind::Projection(ref data) => {\n                     // And similarly for projections. This should be redundant with\n                     // the previous check because any projection should have a\n                     // matching `Trait` predicate with the same inputs, but we do\n@@ -276,14 +276,14 @@ fn predicates_reference_self(\n                         None\n                     }\n                 }\n-                ty::Predicate::WellFormed(..)\n-                | ty::Predicate::ObjectSafe(..)\n-                | ty::Predicate::TypeOutlives(..)\n-                | ty::Predicate::RegionOutlives(..)\n-                | ty::Predicate::ClosureKind(..)\n-                | ty::Predicate::Subtype(..)\n-                | ty::Predicate::ConstEvaluatable(..)\n-                | ty::Predicate::ConstEquate(..) => None,\n+                ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::TypeOutlives(..)\n+                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..) => None,\n             }\n         })\n         .collect()\n@@ -305,18 +305,18 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     let predicates = tcx.predicates_of(def_id);\n     let predicates = predicates.instantiate_identity(tcx).predicates;\n     elaborate_predicates(tcx, predicates.into_iter()).any(|obligation| match obligation.predicate {\n-        ty::Predicate::Trait(ref trait_pred, _) => {\n+        ty::PredicateKind::Trait(ref trait_pred, _) => {\n             trait_pred.def_id() == sized_def_id && trait_pred.skip_binder().self_ty().is_param(0)\n         }\n-        ty::Predicate::Projection(..)\n-        | ty::Predicate::Subtype(..)\n-        | ty::Predicate::RegionOutlives(..)\n-        | ty::Predicate::WellFormed(..)\n-        | ty::Predicate::ObjectSafe(..)\n-        | ty::Predicate::ClosureKind(..)\n-        | ty::Predicate::TypeOutlives(..)\n-        | ty::Predicate::ConstEvaluatable(..)\n-        | ty::Predicate::ConstEquate(..) => false,\n+        ty::PredicateKind::Projection(..)\n+        | ty::PredicateKind::Subtype(..)\n+        | ty::PredicateKind::RegionOutlives(..)\n+        | ty::PredicateKind::WellFormed(..)\n+        | ty::PredicateKind::ObjectSafe(..)\n+        | ty::PredicateKind::ClosureKind(..)\n+        | ty::PredicateKind::TypeOutlives(..)\n+        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::ConstEquate(..) => false,\n     })\n }\n "}, {"sha": "54b064359dcbd6265b2890292d5d3698bd5395d5", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -671,7 +671,9 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n             // indirect obligations (e.g., we project to `?0`,\n             // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n             // ?0>`).\n-            ty::Predicate::Projection(ref data) => infcx.unresolved_type_vars(&data.ty()).is_some(),\n+            ty::PredicateKind::Projection(ref data) => {\n+                infcx.unresolved_type_vars(&data.ty()).is_some()\n+            }\n \n             // We are only interested in `T: Foo<X = U>` predicates, whre\n             // `U` references one of `unresolved_type_vars`. =)\n@@ -928,7 +930,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n         debug!(\"assemble_candidates_from_predicates: predicate={:?}\", predicate);\n-        if let ty::Predicate::Projection(data) = predicate {\n+        if let ty::PredicateKind::Projection(data) = predicate {\n             let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n \n             let is_match = same_def_id\n@@ -1164,7 +1166,7 @@ fn confirm_object_candidate<'cx, 'tcx>(\n         // select only those projections that are actually projecting an\n         // item with the correct name\n         let env_predicates = env_predicates.filter_map(|o| match o.predicate {\n-            ty::Predicate::Projection(data) => {\n+            ty::PredicateKind::Projection(data) => {\n                 if data.projection_def_id() == obligation.predicate.item_def_id {\n                     Some(data)\n                 } else {"}, {"sha": "c0470084072a9a5093e578334a4c63ea9f12865d", "filename": "src/librustc_trait_selection/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n-use rustc_middle::ty::{ParamEnvAnd, Predicate, TyCtxt};\n+use rustc_middle::ty::{self, ParamEnvAnd, TyCtxt};\n \n pub use rustc_middle::traits::query::type_op::ProvePredicate;\n \n@@ -15,7 +15,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n         // `&T`, accounts for about 60% percentage of the predicates\n         // we have to prove. No need to canonicalize and all that for\n         // such cases.\n-        if let Predicate::Trait(trait_ref, _) = key.value.predicate {\n+        if let ty::PredicateKind::Trait(trait_ref, _) = key.value.predicate {\n             if let Some(sized_def_id) = tcx.lang_items().sized_trait() {\n                 if trait_ref.def_id() == sized_def_id {\n                     if trait_ref.skip_binder().self_ty().is_trivially_sized(tcx) {"}, {"sha": "02da6033a006471a3da97bd1217217a434e055c4", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -414,13 +414,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         match obligation.predicate {\n-            ty::Predicate::Trait(ref t, _) => {\n+            ty::PredicateKind::Trait(ref t, _) => {\n                 debug_assert!(!t.has_escaping_bound_vars());\n                 let obligation = obligation.with(*t);\n                 self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n             }\n \n-            ty::Predicate::Subtype(ref p) => {\n+            ty::PredicateKind::Subtype(ref p) => {\n                 // Does this code ever run?\n                 match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                     Some(Ok(InferOk { mut obligations, .. })) => {\n@@ -435,7 +435,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::WellFormed(ty) => match wf::obligations(\n+            ty::PredicateKind::WellFormed(ty) => match wf::obligations(\n                 self.infcx,\n                 obligation.param_env,\n                 obligation.cause.body_id,\n@@ -449,20 +449,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 None => Ok(EvaluatedToAmbig),\n             },\n \n-            ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => {\n+            ty::PredicateKind::TypeOutlives(..) | ty::PredicateKind::RegionOutlives(..) => {\n                 // We do not consider region relationships when evaluating trait matches.\n                 Ok(EvaluatedToOkModuloRegions)\n             }\n \n-            ty::Predicate::ObjectSafe(trait_def_id) => {\n+            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 if self.tcx().is_object_safe(trait_def_id) {\n                     Ok(EvaluatedToOk)\n                 } else {\n                     Ok(EvaluatedToErr)\n                 }\n             }\n \n-            ty::Predicate::Projection(ref data) => {\n+            ty::PredicateKind::Projection(ref data) => {\n                 let project_obligation = obligation.with(*data);\n                 match project::poly_project_and_unify_type(self, &project_obligation) {\n                     Ok(Some(mut subobligations)) => {\n@@ -483,7 +483,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::ClosureKind(_, closure_substs, kind) => {\n+            ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {\n                 match self.infcx.closure_kind(closure_substs) {\n                     Some(closure_kind) => {\n                         if closure_kind.extends(kind) {\n@@ -496,7 +496,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                 match self.tcx().const_eval_resolve(\n                     obligation.param_env,\n                     def_id,\n@@ -676,7 +676,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // if the regions match exactly.\n             let cycle = stack.iter().skip(1).take_while(|s| s.depth >= cycle_depth);\n             let cycle = cycle.map(|stack| {\n-                ty::Predicate::Trait(stack.obligation.predicate, hir::Constness::NotConst)\n+                ty::PredicateKind::Trait(stack.obligation.predicate, hir::Constness::NotConst)\n             });\n             if self.coinductive_match(cycle) {\n                 debug!(\"evaluate_stack({:?}) --> recursive, coinductive\", stack.fresh_trait_ref);\n@@ -792,7 +792,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n         let result = match predicate {\n-            ty::Predicate::Trait(ref data, _) => self.tcx().trait_is_auto(data.def_id()),\n+            ty::PredicateKind::Trait(ref data, _) => self.tcx().trait_is_auto(data.def_id()),\n             _ => false,\n         };\n         debug!(\"coinductive_predicate({:?}) = {:?}\", predicate, result);\n@@ -2921,7 +2921,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligations.push(Obligation::new(\n                 obligation.cause.clone(),\n                 obligation.param_env,\n-                ty::Predicate::ClosureKind(closure_def_id, substs, kind),\n+                ty::PredicateKind::ClosureKind(closure_def_id, substs, kind),\n             ));\n         }\n "}, {"sha": "b1b50eb2331e288624a6e489424a0b25d51350e5", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -73,28 +73,28 @@ pub fn predicate_obligations<'a, 'tcx>(\n \n     // (*) ok to skip binders, because wf code is prepared for it\n     match *predicate {\n-        ty::Predicate::Trait(ref t, _) => {\n+        ty::PredicateKind::Trait(ref t, _) => {\n             wf.compute_trait_ref(&t.skip_binder().trait_ref, Elaborate::None); // (*)\n         }\n-        ty::Predicate::RegionOutlives(..) => {}\n-        ty::Predicate::TypeOutlives(ref t) => {\n+        ty::PredicateKind::RegionOutlives(..) => {}\n+        ty::PredicateKind::TypeOutlives(ref t) => {\n             wf.compute(t.skip_binder().0);\n         }\n-        ty::Predicate::Projection(ref t) => {\n+        ty::PredicateKind::Projection(ref t) => {\n             let t = t.skip_binder(); // (*)\n             wf.compute_projection(t.projection_ty);\n             wf.compute(t.ty);\n         }\n-        ty::Predicate::WellFormed(t) => {\n+        ty::PredicateKind::WellFormed(t) => {\n             wf.compute(t);\n         }\n-        ty::Predicate::ObjectSafe(_) => {}\n-        ty::Predicate::ClosureKind(..) => {}\n-        ty::Predicate::Subtype(ref data) => {\n+        ty::PredicateKind::ObjectSafe(_) => {}\n+        ty::PredicateKind::ClosureKind(..) => {}\n+        ty::PredicateKind::Subtype(ref data) => {\n             wf.compute(data.skip_binder().a); // (*)\n             wf.compute(data.skip_binder().b); // (*)\n         }\n-        ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+        ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n             let obligations = wf.nominal_obligations(def_id, substs);\n             wf.out.extend(obligations);\n \n@@ -171,7 +171,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             _ => impl_item_ref.span,\n         };\n     match pred {\n-        ty::Predicate::Projection(proj) => {\n+        ty::PredicateKind::Projection(proj) => {\n             // The obligation comes not from the current `impl` nor the `trait` being\n             // implemented, but rather from a \"second order\" obligation, like in\n             // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs`.\n@@ -194,7 +194,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n                 }\n             }\n         }\n-        ty::Predicate::Trait(pred, _) => {\n+        ty::PredicateKind::Trait(pred, _) => {\n             // An associated item obligation born out of the `trait` failed to be met. An example\n             // can be seen in `ui/associated-types/point-at-type-on-obligation-failure-2.rs`.\n             debug!(\"extended_cause_with_original_assoc_item_obligation trait proj {:?}\", pred);\n@@ -276,7 +276,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         }\n \n         self.out.extend(trait_ref.substs.types().filter(|ty| !ty.has_escaping_bound_vars()).map(\n-            |ty| traits::Obligation::new(cause.clone(), param_env, ty::Predicate::WellFormed(ty)),\n+            |ty| {\n+                traits::Obligation::new(cause.clone(), param_env, ty::PredicateKind::WellFormed(ty))\n+            },\n         ));\n     }\n \n@@ -305,7 +307,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n             let obligations = self.nominal_obligations(def_id, substs);\n             self.out.extend(obligations);\n \n-            let predicate = ty::Predicate::ConstEvaluatable(def_id, substs);\n+            let predicate = ty::PredicateKind::ConstEvaluatable(def_id, substs);\n             let cause = self.cause(traits::MiscObligation);\n             self.out.push(traits::Obligation::new(cause, self.param_env, predicate));\n         }\n@@ -411,9 +413,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         self.out.push(traits::Obligation::new(\n                             cause,\n                             param_env,\n-                            ty::Predicate::TypeOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n-                                rty, r,\n-                            ))),\n+                            ty::PredicateKind::TypeOutlives(ty::Binder::dummy(\n+                                ty::OutlivesPredicate(rty, r),\n+                            )),\n                         ));\n                     }\n                 }\n@@ -502,7 +504,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             traits::Obligation::new(\n                                 cause.clone(),\n                                 param_env,\n-                                ty::Predicate::ObjectSafe(did),\n+                                ty::PredicateKind::ObjectSafe(did),\n                             )\n                         }));\n                     }\n@@ -528,7 +530,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         self.out.push(traits::Obligation::new(\n                             cause,\n                             param_env,\n-                            ty::Predicate::WellFormed(ty),\n+                            ty::PredicateKind::WellFormed(ty),\n                         ));\n                     } else {\n                         // Yes, resolved, proceed with the result."}, {"sha": "aed5729b34a2c708ef7a996e6e87c039cbd135c5", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -95,27 +95,27 @@ fn compute_implied_outlives_bounds<'tcx>(\n         implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n             assert!(!obligation.has_escaping_bound_vars());\n             match obligation.predicate {\n-                ty::Predicate::Trait(..)\n-                | ty::Predicate::Subtype(..)\n-                | ty::Predicate::Projection(..)\n-                | ty::Predicate::ClosureKind(..)\n-                | ty::Predicate::ObjectSafe(..)\n-                | ty::Predicate::ConstEvaluatable(..)\n-                | ty::Predicate::ConstEquate(..) => vec![],\n+                ty::PredicateKind::Trait(..)\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Projection(..)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..) => vec![],\n \n-                ty::Predicate::WellFormed(subty) => {\n+                ty::PredicateKind::WellFormed(subty) => {\n                     wf_types.push(subty);\n                     vec![]\n                 }\n \n-                ty::Predicate::RegionOutlives(ref data) => match data.no_bound_vars() {\n+                ty::PredicateKind::RegionOutlives(ref data) => match data.no_bound_vars() {\n                     None => vec![],\n                     Some(ty::OutlivesPredicate(r_a, r_b)) => {\n                         vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n                     }\n                 },\n \n-                ty::Predicate::TypeOutlives(ref data) => match data.no_bound_vars() {\n+                ty::PredicateKind::TypeOutlives(ref data) => match data.no_bound_vars() {\n                     None => vec![],\n                     Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n                         let ty_a = infcx.resolve_vars_if_possible(&ty_a);"}, {"sha": "11604cc31870f1def99eec57e1cf24321ac6856c", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -41,14 +41,14 @@ fn normalize_generic_arg_after_erasing_regions<'tcx>(\n \n fn not_outlives_predicate(p: &ty::Predicate<'_>) -> bool {\n     match p {\n-        ty::Predicate::RegionOutlives(..) | ty::Predicate::TypeOutlives(..) => false,\n-        ty::Predicate::Trait(..)\n-        | ty::Predicate::Projection(..)\n-        | ty::Predicate::WellFormed(..)\n-        | ty::Predicate::ObjectSafe(..)\n-        | ty::Predicate::ClosureKind(..)\n-        | ty::Predicate::Subtype(..)\n-        | ty::Predicate::ConstEvaluatable(..)\n-        | ty::Predicate::ConstEquate(..) => true,\n+        ty::PredicateKind::RegionOutlives(..) | ty::PredicateKind::TypeOutlives(..) => false,\n+        ty::PredicateKind::Trait(..)\n+        | ty::PredicateKind::Projection(..)\n+        | ty::PredicateKind::WellFormed(..)\n+        | ty::PredicateKind::ObjectSafe(..)\n+        | ty::PredicateKind::ClosureKind(..)\n+        | ty::PredicateKind::Subtype(..)\n+        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::ConstEquate(..) => true,\n     }\n }"}, {"sha": "58fa927c021e09b9492f67ddb1290ba8b14cbb92", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -7,7 +7,8 @@ use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArg, Subst, UserSelfTy, UserSubsts};\n use rustc_middle::ty::{\n-    FnSig, Lift, ParamEnv, ParamEnvAnd, PolyFnSig, Predicate, Ty, TyCtxt, TypeFoldable, Variance,\n+    self, FnSig, Lift, ParamEnv, ParamEnvAnd, PolyFnSig, Predicate, Ty, TyCtxt, TypeFoldable,\n+    Variance,\n };\n use rustc_span::DUMMY_SP;\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n@@ -140,7 +141,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n \n             self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n \n-            self.prove_predicate(Predicate::WellFormed(impl_self_ty));\n+            self.prove_predicate(ty::PredicateKind::WellFormed(impl_self_ty));\n         }\n \n         // In addition to proving the predicates, we have to\n@@ -154,7 +155,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n         // them?  This would only be relevant if some input\n         // type were ill-formed but did not appear in `ty`,\n         // which...could happen with normalization...\n-        self.prove_predicate(Predicate::WellFormed(ty));\n+        self.prove_predicate(ty::PredicateKind::WellFormed(ty));\n         Ok(())\n     }\n }"}, {"sha": "a697ae7cb877cfadf23dc6f3cb7d474670abc84a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -1597,15 +1597,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     obligation.predicate\n                 );\n                 match obligation.predicate {\n-                    ty::Predicate::Trait(pred, _) => {\n+                    ty::PredicateKind::Trait(pred, _) => {\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())\n                                 .in_definition_order()\n                                 .filter(|item| item.kind == ty::AssocKind::Type)\n                                 .map(|item| item.def_id),\n                         );\n                     }\n-                    ty::Predicate::Projection(pred) => {\n+                    ty::PredicateKind::Projection(pred) => {\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that.\n                         let references_self ="}, {"sha": "6ade48b80c8a5b47a312bbd8f33c569243fd7d04", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -206,7 +206,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     obligation.predicate\n                 );\n \n-                if let ty::Predicate::Projection(ref proj_predicate) = obligation.predicate {\n+                if let ty::PredicateKind::Projection(ref proj_predicate) = obligation.predicate {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n                     self.deduce_sig_from_projection(Some(obligation.cause.span), proj_predicate)\n@@ -526,7 +526,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 all_obligations.push(Obligation::new(\n                     cause,\n                     self.param_env,\n-                    ty::Predicate::TypeOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n+                    ty::PredicateKind::TypeOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n                         supplied_ty,\n                         closure_body_region,\n                     ))),\n@@ -641,7 +641,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // where R is the return type we are expecting. This type `T`\n         // will be our output.\n         let output_ty = self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n-            if let ty::Predicate::Projection(ref proj_predicate) = obligation.predicate {\n+            if let ty::PredicateKind::Projection(ref proj_predicate) = obligation.predicate {\n                 self.deduce_future_output_from_projection(obligation.cause.span, proj_predicate)\n             } else {\n                 None"}, {"sha": "8a93b05ac8db0a98a45454c99d97c8376a737edb", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -597,7 +597,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             let obligation = queue.remove(0);\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n             let trait_pred = match obligation.predicate {\n-                ty::Predicate::Trait(trait_pred, _) if traits.contains(&trait_pred.def_id()) => {\n+                ty::PredicateKind::Trait(trait_pred, _)\n+                    if traits.contains(&trait_pred.def_id()) =>\n+                {\n                     if unsize_did == trait_pred.def_id() {\n                         let unsize_ty = trait_pred.skip_binder().trait_ref.substs[1].expect_ty();\n                         if let ty::Tuple(..) = unsize_ty.kind {"}, {"sha": "550a2362795508b34cbf8f41f56da25266b3e5f6", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -644,7 +644,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .unwrap()\n                     .def_id;\n                 let predicate =\n-                    ty::Predicate::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n+                    ty::PredicateKind::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n                         // `<T as Deref>::Output`\n                         projection_ty: ty::ProjectionTy {\n                             // `T`"}, {"sha": "51d28f7c57c65cc63e85e5139566e7c240d17ea6", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -231,8 +231,10 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         let predicate_matches_closure = |p: &'_ Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n             match (predicate, p) {\n-                (Predicate::Trait(a, _), Predicate::Trait(b, _)) => relator.relate(a, b).is_ok(),\n-                (Predicate::Projection(a), Predicate::Projection(b)) => {\n+                (ty::PredicateKind::Trait(a, _), ty::PredicateKind::Trait(b, _)) => {\n+                    relator.relate(a, b).is_ok()\n+                }\n+                (ty::PredicateKind::Projection(a), ty::PredicateKind::Projection(b)) => {\n                     relator.relate(a, b).is_ok()\n                 }\n                 _ => predicate == p,"}, {"sha": "64917bf4c9f4421553183720ca905c9e8ec25c83", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -575,7 +575,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n         traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n             .filter_map(|obligation| match obligation.predicate {\n-                ty::Predicate::Trait(trait_pred, _) if trait_pred.def_id() == sized_def_id => {\n+                ty::PredicateKind::Trait(trait_pred, _) if trait_pred.def_id() == sized_def_id => {\n                     let span = predicates\n                         .predicates\n                         .iter()"}, {"sha": "135e02d6b5fac6cadbbb9ae9a569457219911151", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -401,7 +401,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         obligations.push(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::Predicate::WellFormed(method_ty),\n+            ty::PredicateKind::WellFormed(method_ty),\n         ));\n \n         let callee = MethodCallee { def_id, substs: trait_ref.substs, sig: fn_sig };"}, {"sha": "fbe8e7b7675116517e689231a1c8b199a4869370", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -797,21 +797,21 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // FIXME: do we want to commit to this behavior for param bounds?\n \n         let bounds = self.param_env.caller_bounds.iter().filter_map(|predicate| match *predicate {\n-            ty::Predicate::Trait(ref trait_predicate, _) => {\n+            ty::PredicateKind::Trait(ref trait_predicate, _) => {\n                 match trait_predicate.skip_binder().trait_ref.self_ty().kind {\n                     ty::Param(ref p) if *p == param_ty => Some(trait_predicate.to_poly_trait_ref()),\n                     _ => None,\n                 }\n             }\n-            ty::Predicate::Subtype(..)\n-            | ty::Predicate::Projection(..)\n-            | ty::Predicate::RegionOutlives(..)\n-            | ty::Predicate::WellFormed(..)\n-            | ty::Predicate::ObjectSafe(..)\n-            | ty::Predicate::ClosureKind(..)\n-            | ty::Predicate::TypeOutlives(..)\n-            | ty::Predicate::ConstEvaluatable(..)\n-            | ty::Predicate::ConstEquate(..) => None,\n+            ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::Projection(..)\n+            | ty::PredicateKind::RegionOutlives(..)\n+            | ty::PredicateKind::WellFormed(..)\n+            | ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::TypeOutlives(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..) => None,\n         });\n \n         self.elaborate_bounds(bounds, |this, poly_trait_ref, item| {"}, {"sha": "e0ab25e49224e8c0231ae3830b2aa391084e976d", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -574,7 +574,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let mut bound_spans = vec![];\n                     let mut collect_type_param_suggestions =\n                         |self_ty: Ty<'_>, parent_pred: &ty::Predicate<'_>, obligation: &str| {\n-                            if let (ty::Param(_), ty::Predicate::Trait(p, _)) =\n+                            if let (ty::Param(_), ty::PredicateKind::Trait(p, _)) =\n                                 (&self_ty.kind, parent_pred)\n                             {\n                                 if let ty::Adt(def, _) = p.skip_binder().trait_ref.self_ty().kind {\n@@ -628,7 +628,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     };\n                     let mut format_pred = |pred| {\n                         match pred {\n-                            ty::Predicate::Projection(pred) => {\n+                            ty::PredicateKind::Projection(pred) => {\n                                 // `<Foo as Iterator>::Item = String`.\n                                 let trait_ref =\n                                     pred.skip_binder().projection_ty.trait_ref(self.tcx);\n@@ -646,7 +646,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 bound_span_label(trait_ref.self_ty(), &obligation, &quiet);\n                                 Some((obligation, trait_ref.self_ty()))\n                             }\n-                            ty::Predicate::Trait(poly_trait_ref, _) => {\n+                            ty::PredicateKind::Trait(poly_trait_ref, _) => {\n                                 let p = poly_trait_ref.skip_binder().trait_ref;\n                                 let self_ty = p.self_ty();\n                                 let path = p.print_only_trait_path();\n@@ -949,8 +949,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 unsatisfied_predicates.iter().all(|(p, _)| match p {\n                     // Hide traits if they are present in predicates as they can be fixed without\n                     // having to implement them.\n-                    ty::Predicate::Trait(t, _) => t.def_id() == info.def_id,\n-                    ty::Predicate::Projection(p) => p.item_def_id() == info.def_id,\n+                    ty::PredicateKind::Trait(t, _) => t.def_id() == info.def_id,\n+                    ty::PredicateKind::Projection(p) => p.item_def_id() == info.def_id,\n                     _ => false,\n                 }) && (type_is_local || info.def_id.is_local())\n                     && self"}, {"sha": "79cb7a7fd0ffaaabf835e0a636c741d528c7eba3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -2224,7 +2224,7 @@ fn bounds_from_generic_predicates(\n     for (predicate, _) in predicates.predicates {\n         debug!(\"predicate {:?}\", predicate);\n         match predicate {\n-            ty::Predicate::Trait(trait_predicate, _) => {\n+            ty::PredicateKind::Trait(trait_predicate, _) => {\n                 let entry = types.entry(trait_predicate.skip_binder().self_ty()).or_default();\n                 let def_id = trait_predicate.skip_binder().def_id();\n                 if Some(def_id) != tcx.lang_items().sized_trait() {\n@@ -2233,7 +2233,7 @@ fn bounds_from_generic_predicates(\n                     entry.push(trait_predicate.skip_binder().def_id());\n                 }\n             }\n-            ty::Predicate::Projection(projection_pred) => {\n+            ty::PredicateKind::Projection(projection_pred) => {\n                 projections.push(projection_pred);\n             }\n             _ => {}\n@@ -2770,7 +2770,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n             parent: None,\n             predicates: tcx.arena.alloc_from_iter(self.param_env.caller_bounds.iter().filter_map(\n                 |&predicate| match predicate {\n-                    ty::Predicate::Trait(ref data, _)\n+                    ty::PredicateKind::Trait(ref data, _)\n                         if data.skip_binder().self_ty().is_param(index) =>\n                     {\n                         // HACK(eddyb) should get the original `Span`.\n@@ -3379,7 +3379,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.register_predicate(traits::Obligation::new(\n                 cause,\n                 self.param_env,\n-                ty::Predicate::ConstEvaluatable(def_id, substs),\n+                ty::PredicateKind::ConstEvaluatable(def_id, substs),\n             ));\n         }\n \n@@ -3428,7 +3428,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.register_predicate(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::Predicate::WellFormed(ty),\n+            ty::PredicateKind::WellFormed(ty),\n         ));\n     }\n \n@@ -3858,17 +3858,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .pending_obligations()\n             .into_iter()\n             .filter_map(move |obligation| match obligation.predicate {\n-                ty::Predicate::Projection(ref data) => {\n+                ty::PredicateKind::Projection(ref data) => {\n                     Some((data.to_poly_trait_ref(self.tcx), obligation))\n                 }\n-                ty::Predicate::Trait(ref data, _) => Some((data.to_poly_trait_ref(), obligation)),\n-                ty::Predicate::Subtype(..) => None,\n-                ty::Predicate::RegionOutlives(..) => None,\n-                ty::Predicate::TypeOutlives(..) => None,\n-                ty::Predicate::WellFormed(..) => None,\n-                ty::Predicate::ObjectSafe(..) => None,\n-                ty::Predicate::ConstEvaluatable(..) => None,\n-                ty::Predicate::ConstEquate(..) => None,\n+                ty::PredicateKind::Trait(ref data, _) => {\n+                    Some((data.to_poly_trait_ref(), obligation))\n+                }\n+                ty::PredicateKind::Subtype(..) => None,\n+                ty::PredicateKind::RegionOutlives(..) => None,\n+                ty::PredicateKind::TypeOutlives(..) => None,\n+                ty::PredicateKind::WellFormed(..) => None,\n+                ty::PredicateKind::ObjectSafe(..) => None,\n+                ty::PredicateKind::ConstEvaluatable(..) => None,\n+                ty::PredicateKind::ConstEquate(..) => None,\n                 // N.B., this predicate is created by breaking down a\n                 // `ClosureType: FnFoo()` predicate, where\n                 // `ClosureType` represents some `Closure`. It can't\n@@ -3877,7 +3879,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // this closure yet; this is exactly why the other\n                 // code is looking for a self type of a unresolved\n                 // inference variable.\n-                ty::Predicate::ClosureKind(..) => None,\n+                ty::PredicateKind::ClosureKind(..) => None,\n             })\n             .filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))\n     }\n@@ -4206,7 +4208,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 continue;\n             }\n \n-            if let ty::Predicate::Trait(predicate, _) = error.obligation.predicate {\n+            if let ty::PredicateKind::Trait(predicate, _) = error.obligation.predicate {\n                 // Collect the argument position for all arguments that could have caused this\n                 // `FulfillmentError`.\n                 let mut referenced_in = final_arg_types\n@@ -4253,7 +4255,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let hir::ExprKind::Path(qpath) = &path.kind {\n                 if let hir::QPath::Resolved(_, path) = &qpath {\n                     for error in errors {\n-                        if let ty::Predicate::Trait(predicate, _) = error.obligation.predicate {\n+                        if let ty::PredicateKind::Trait(predicate, _) = error.obligation.predicate {\n                             // If any of the type arguments in this path segment caused the\n                             // `FullfillmentError`, point at its span (#61860).\n                             for arg in path\n@@ -5322,7 +5324,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n \n                 let predicate =\n-                    ty::Predicate::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n+                    ty::PredicateKind::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n                         projection_ty,\n                         ty: expected,\n                     }));"}, {"sha": "cb3ee8d1ded0ac660db2e0ad4dea7f327960c09d", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -425,7 +425,7 @@ fn check_type_defn<'tcx, F>(\n                 fcx.register_predicate(traits::Obligation::new(\n                     cause,\n                     fcx.param_env,\n-                    ty::Predicate::ConstEvaluatable(discr_def_id.to_def_id(), discr_substs),\n+                    ty::PredicateKind::ConstEvaluatable(discr_def_id.to_def_id(), discr_substs),\n                 ));\n             }\n         }"}, {"sha": "c39df5df977edb5a52f3fca71c1623f75619d072", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -549,7 +549,9 @@ fn type_param_predicates(\n         icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty, OnlySelfBounds(true))\n             .into_iter()\n             .filter(|(predicate, _)| match predicate {\n-                ty::Predicate::Trait(ref data, _) => data.skip_binder().self_ty().is_param(index),\n+                ty::PredicateKind::Trait(ref data, _) => {\n+                    data.skip_binder().self_ty().is_param(index)\n+                }\n                 _ => false,\n             }),\n     );\n@@ -994,7 +996,7 @@ fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredi\n     // which will, in turn, reach indirect supertraits.\n     for &(pred, span) in superbounds {\n         debug!(\"superbound: {:?}\", pred);\n-        if let ty::Predicate::Trait(bound, _) = pred {\n+        if let ty::PredicateKind::Trait(bound, _) = pred {\n             tcx.at(span).super_predicates_of(bound.def_id());\n         }\n     }\n@@ -1899,7 +1901,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         let re_root_empty = tcx.lifetimes.re_root_empty;\n                         let predicate = ty::OutlivesPredicate(ty, re_root_empty);\n                         predicates.push((\n-                            ty::Predicate::TypeOutlives(ty::Binder::dummy(predicate)),\n+                            ty::PredicateKind::TypeOutlives(ty::Binder::dummy(predicate)),\n                             span,\n                         ));\n                     }\n@@ -1928,7 +1930,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         &hir::GenericBound::Outlives(ref lifetime) => {\n                             let region = AstConv::ast_region_to_region(&icx, lifetime, None);\n                             let pred = ty::Binder::bind(ty::OutlivesPredicate(ty, region));\n-                            predicates.push((ty::Predicate::TypeOutlives(pred), lifetime.span))\n+                            predicates.push((ty::PredicateKind::TypeOutlives(pred), lifetime.span))\n                         }\n                     }\n                 }\n@@ -1945,7 +1947,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                     };\n                     let pred = ty::Binder::bind(ty::OutlivesPredicate(r1, r2));\n \n-                    (ty::Predicate::RegionOutlives(pred), span)\n+                    (ty::PredicateKind::RegionOutlives(pred), span)\n                 }))\n             }\n \n@@ -2116,7 +2118,7 @@ fn predicates_from_bound<'tcx>(\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n             let pred = ty::Binder::bind(ty::OutlivesPredicate(param_ty, region));\n-            vec![(ty::Predicate::TypeOutlives(pred), lifetime.span)]\n+            vec![(ty::PredicateKind::TypeOutlives(pred), lifetime.span)]\n         }\n     }\n }"}, {"sha": "c1be430b93e983e551f4a113bf3f99df76f00377", "filename": "src/librustc_typeck/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -180,7 +180,7 @@ pub fn setup_constraining_predicates<'tcx>(\n         changed = false;\n \n         for j in i..predicates.len() {\n-            if let ty::Predicate::Projection(ref poly_projection) = predicates[j].0 {\n+            if let ty::PredicateKind::Projection(ref poly_projection) = predicates[j].0 {\n                 // Note that we can skip binder here because the impl\n                 // trait ref never contains any late-bound regions.\n                 let projection = poly_projection.skip_binder();"}, {"sha": "89d63107a9c29668c7135631f4e4dc64798df8ca", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -204,7 +204,7 @@ fn unconstrained_parent_impl_substs<'tcx>(\n     // the functions in `cgp` add the constrained parameters to a list of\n     // unconstrained parameters.\n     for (predicate, _) in impl_generic_predicates.predicates.iter() {\n-        if let ty::Predicate::Projection(proj) = predicate {\n+        if let ty::PredicateKind::Projection(proj) = predicate {\n             let projection_ty = proj.skip_binder().projection_ty;\n             let projected_ty = proj.skip_binder().ty;\n \n@@ -374,7 +374,7 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: &ty::Predicate<'t\n         _ if predicate.is_global() => (),\n         // We allow specializing on explicitly marked traits with no associated\n         // items.\n-        ty::Predicate::Trait(pred, hir::Constness::NotConst) => {\n+        ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {\n             if !matches!(\n                 trait_predicate_kind(tcx, predicate),\n                 Some(TraitSpecializationKind::Marker)\n@@ -402,18 +402,18 @@ fn trait_predicate_kind<'tcx>(\n     predicate: &ty::Predicate<'tcx>,\n ) -> Option<TraitSpecializationKind> {\n     match predicate {\n-        ty::Predicate::Trait(pred, hir::Constness::NotConst) => {\n+        ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {\n             Some(tcx.trait_def(pred.def_id()).specialization_kind)\n         }\n-        ty::Predicate::Trait(_, hir::Constness::Const)\n-        | ty::Predicate::RegionOutlives(_)\n-        | ty::Predicate::TypeOutlives(_)\n-        | ty::Predicate::Projection(_)\n-        | ty::Predicate::WellFormed(_)\n-        | ty::Predicate::Subtype(_)\n-        | ty::Predicate::ObjectSafe(_)\n-        | ty::Predicate::ClosureKind(..)\n-        | ty::Predicate::ConstEvaluatable(..)\n-        | ty::Predicate::ConstEquate(..) => None,\n+        ty::PredicateKind::Trait(_, hir::Constness::Const)\n+        | ty::PredicateKind::RegionOutlives(_)\n+        | ty::PredicateKind::TypeOutlives(_)\n+        | ty::PredicateKind::Projection(_)\n+        | ty::PredicateKind::WellFormed(_)\n+        | ty::PredicateKind::Subtype(_)\n+        | ty::PredicateKind::ObjectSafe(_)\n+        | ty::PredicateKind::ClosureKind(..)\n+        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::ConstEquate(..) => None,\n     }\n }"}, {"sha": "bc8d25f953820aa5099604233e63a34015a30289", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -30,7 +30,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n             // process predicates and convert to `RequiredPredicates` entry, see below\n             for &(predicate, span) in predicates.predicates {\n                 match predicate {\n-                    ty::Predicate::TypeOutlives(predicate) => {\n+                    ty::PredicateKind::TypeOutlives(predicate) => {\n                         let OutlivesPredicate(ref ty, ref reg) = predicate.skip_binder();\n                         insert_outlives_predicate(\n                             tcx,\n@@ -41,7 +41,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                         )\n                     }\n \n-                    ty::Predicate::RegionOutlives(predicate) => {\n+                    ty::PredicateKind::RegionOutlives(predicate) => {\n                         let OutlivesPredicate(ref reg1, ref reg2) = predicate.skip_binder();\n                         insert_outlives_predicate(\n                             tcx,\n@@ -52,14 +52,14 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                         )\n                     }\n \n-                    ty::Predicate::Trait(..)\n-                    | ty::Predicate::Projection(..)\n-                    | ty::Predicate::WellFormed(..)\n-                    | ty::Predicate::ObjectSafe(..)\n-                    | ty::Predicate::ClosureKind(..)\n-                    | ty::Predicate::Subtype(..)\n-                    | ty::Predicate::ConstEvaluatable(..)\n-                    | ty::Predicate::ConstEquate(..) => (),\n+                    ty::PredicateKind::Trait(..)\n+                    | ty::PredicateKind::Projection(..)\n+                    | ty::PredicateKind::WellFormed(..)\n+                    | ty::PredicateKind::ObjectSafe(..)\n+                    | ty::PredicateKind::ClosureKind(..)\n+                    | ty::PredicateKind::Subtype(..)\n+                    | ty::PredicateKind::ConstEvaluatable(..)\n+                    | ty::PredicateKind::ConstEquate(..) => (),\n                 }\n             }\n "}, {"sha": "d88fda355050040a26169f9b26a67af67b515ee8", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -31,8 +31,8 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate\n                     let mut pred: Vec<String> = predicates\n                         .iter()\n                         .map(|(out_pred, _)| match out_pred {\n-                            ty::Predicate::RegionOutlives(p) => p.to_string(),\n-                            ty::Predicate::TypeOutlives(p) => p.to_string(),\n+                            ty::PredicateKind::RegionOutlives(p) => p.to_string(),\n+                            ty::PredicateKind::TypeOutlives(p) => p.to_string(),\n                             err => bug!(\"unexpected predicate {:?}\", err),\n                         })\n                         .collect();\n@@ -84,13 +84,13 @@ fn inferred_outlives_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CratePredica\n             let predicates = &*tcx.arena.alloc_from_iter(set.iter().filter_map(\n                 |(ty::OutlivesPredicate(kind1, region2), &span)| match kind1.unpack() {\n                     GenericArgKind::Type(ty1) => Some((\n-                        ty::Predicate::TypeOutlives(ty::Binder::bind(ty::OutlivesPredicate(\n+                        ty::PredicateKind::TypeOutlives(ty::Binder::bind(ty::OutlivesPredicate(\n                             ty1, region2,\n                         ))),\n                         span,\n                     )),\n                     GenericArgKind::Lifetime(region1) => Some((\n-                        ty::Predicate::RegionOutlives(ty::Binder::bind(ty::OutlivesPredicate(\n+                        ty::PredicateKind::RegionOutlives(ty::Binder::bind(ty::OutlivesPredicate(\n                             region1, region2,\n                         ))),\n                         span,"}, {"sha": "ff05c4e583269e330746451de51f668017342af3", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -316,10 +316,10 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         pred: ty::Predicate<'tcx>,\n     ) -> FxHashSet<GenericParamDef> {\n         let regions = match pred {\n-            ty::Predicate::Trait(poly_trait_pred, _) => {\n+            ty::PredicateKind::Trait(poly_trait_pred, _) => {\n                 tcx.collect_referenced_late_bound_regions(&poly_trait_pred)\n             }\n-            ty::Predicate::Projection(poly_proj_pred) => {\n+            ty::PredicateKind::Projection(poly_proj_pred) => {\n                 tcx.collect_referenced_late_bound_regions(&poly_proj_pred)\n             }\n             _ => return FxHashSet::default(),\n@@ -466,7 +466,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             .filter(|p| {\n                 !orig_bounds.contains(p)\n                     || match p {\n-                        ty::Predicate::Trait(pred, _) => pred.def_id() == sized_trait,\n+                        ty::PredicateKind::Trait(pred, _) => pred.def_id() == sized_trait,\n                         _ => false,\n                     }\n             })"}, {"sha": "002af495ff226603e0abbb4e85d6000b1fe662d2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -481,20 +481,18 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n \n impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n     fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n-        use rustc_middle::ty::Predicate;\n-\n         match *self {\n-            Predicate::Trait(ref pred, _) => Some(pred.clean(cx)),\n-            Predicate::Subtype(ref pred) => Some(pred.clean(cx)),\n-            Predicate::RegionOutlives(ref pred) => pred.clean(cx),\n-            Predicate::TypeOutlives(ref pred) => pred.clean(cx),\n-            Predicate::Projection(ref pred) => Some(pred.clean(cx)),\n+            ty::PredicateKind::Trait(ref pred, _) => Some(pred.clean(cx)),\n+            ty::PredicateKind::Subtype(ref pred) => Some(pred.clean(cx)),\n+            ty::PredicateKind::RegionOutlives(ref pred) => pred.clean(cx),\n+            ty::PredicateKind::TypeOutlives(ref pred) => pred.clean(cx),\n+            ty::PredicateKind::Projection(ref pred) => Some(pred.clean(cx)),\n \n-            Predicate::WellFormed(..)\n-            | Predicate::ObjectSafe(..)\n-            | Predicate::ClosureKind(..)\n-            | Predicate::ConstEvaluatable(..)\n-            | Predicate::ConstEquate(..) => panic!(\"not user writable\"),\n+            ty::PredicateKind::WellFormed(..)\n+            | ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..) => panic!(\"not user writable\"),\n         }\n     }\n }\n@@ -765,7 +763,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n                         if let ty::Param(param) = outlives.skip_binder().0.kind {\n                             return Some(param.index);\n                         }\n-                    } else if let ty::Predicate::Projection(p) = p {\n+                    } else if let ty::PredicateKind::Projection(p) = p {\n                         if let ty::Param(param) = p.skip_binder().projection_ty.self_ty().kind {\n                             projection = Some(p);\n                             return Some(param.index);\n@@ -1663,7 +1661,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     .filter_map(|predicate| {\n                         let trait_ref = if let Some(tr) = predicate.to_opt_poly_trait_ref() {\n                             tr\n-                        } else if let ty::Predicate::TypeOutlives(pred) = *predicate {\n+                        } else if let ty::PredicateKind::TypeOutlives(pred) = *predicate {\n                             // these should turn up at the end\n                             if let Some(r) = pred.skip_binder().1.clean(cx) {\n                                 regions.push(GenericBound::Outlives(r));\n@@ -1684,7 +1682,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                             .predicates\n                             .iter()\n                             .filter_map(|pred| {\n-                                if let ty::Predicate::Projection(proj) = *pred {\n+                                if let ty::PredicateKind::Projection(proj) = *pred {\n                                     let proj = proj.skip_binder();\n                                     if proj.projection_ty.trait_ref(cx.tcx)\n                                         == *trait_ref.skip_binder()"}, {"sha": "cc91c503461803e7e7e68c8cd60cb3374e9f0636", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -141,7 +141,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext<'_>, child: DefId, trait_: DefId)\n         .predicates\n         .iter()\n         .filter_map(|(pred, _)| {\n-            if let ty::Predicate::Trait(ref pred, _) = *pred {\n+            if let ty::PredicateKind::Trait(ref pred, _) = *pred {\n                 if pred.skip_binder().trait_ref.self_ty() == self_ty {\n                     Some(pred.def_id())\n                 } else {"}, {"sha": "2c2965433fd0e96ddb30f760c30239aeca5bafde", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -3,7 +3,7 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, FnDecl, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{Opaque, Predicate::Trait, ToPolyTraitRef};\n+use rustc_middle::ty::{Opaque, PredicateKind::Trait, ToPolyTraitRef};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt;"}, {"sha": "79c21d9bc0a6424e16d10d0ddcf927db1e1e4158", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -18,7 +18,7 @@ use rustc_lint::{LateContext, LateLintPass, Lint, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, Predicate, Ty};\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, SymbolStr};\n@@ -1497,7 +1497,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                 // one of the associated types must be Self\n                 for predicate in cx.tcx.predicates_of(def_id).predicates {\n                     match predicate {\n-                        (Predicate::Projection(poly_projection_predicate), _) => {\n+                        (ty::PredicateKind::Projection(poly_projection_predicate), _) => {\n                             let binder = poly_projection_predicate.ty();\n                             let associated_type = binder.skip_binder();\n "}, {"sha": "8f94f143bae71e7c0362f911e15d6b88234bfefb", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds.iter().copied())\n             .filter(|p| !p.is_global())\n             .filter_map(|obligation| {\n-                if let ty::Predicate::Trait(poly_trait_ref, _) = obligation.predicate {\n+                if let ty::PredicateKind::Trait(poly_trait_ref, _) = obligation.predicate {\n                     if poly_trait_ref.def_id() == sized_trait || poly_trait_ref.skip_binder().has_escaping_bound_vars()\n                     {\n                         return None;"}, {"sha": "3f5693d7e6809cacbab0c21a37f03164da79be55", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cad8fe90fd61c410ac3e7e97a6be37c96ca66a72/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=cad8fe90fd61c410ac3e7e97a6be37c96ca66a72", "patch": "@@ -1299,7 +1299,7 @@ pub fn is_must_use_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> boo\n         ty::Tuple(ref substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(ref def_id, _) => {\n             for (predicate, _) in cx.tcx.predicates_of(*def_id).predicates {\n-                if let ty::Predicate::Trait(ref poly_trait_predicate, _) = predicate {\n+                if let ty::PredicateKind::Trait(ref poly_trait_predicate, _) = predicate {\n                     if must_use_attr(&cx.tcx.get_attrs(poly_trait_predicate.skip_binder().trait_ref.def_id)).is_some() {\n                         return true;\n                     }"}]}