{"sha": "a4f91e5fed85164a8535a2300ca6445520d25059", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZjkxZTVmZWQ4NTE2NGE4NTM1YTIzMDBjYTY0NDU1MjBkMjUwNTk=", "commit": {"author": {"name": "Michael Wu", "email": "mwu@mozilla.com", "date": "2015-08-04T02:16:24Z"}, "committer": {"name": "Michael Wu", "email": "mwu@mozilla.com", "date": "2016-01-14T22:35:55Z"}, "message": "Support generic associated consts", "tree": {"sha": "918343873a79c3699755c5f4728c25f0ad866b8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/918343873a79c3699755c5f4728c25f0ad866b8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4f91e5fed85164a8535a2300ca6445520d25059", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4f91e5fed85164a8535a2300ca6445520d25059", "html_url": "https://github.com/rust-lang/rust/commit/a4f91e5fed85164a8535a2300ca6445520d25059", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4f91e5fed85164a8535a2300ca6445520d25059/comments", "author": {"login": "michaelwu", "id": 719931, "node_id": "MDQ6VXNlcjcxOTkzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/719931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwu", "html_url": "https://github.com/michaelwu", "followers_url": "https://api.github.com/users/michaelwu/followers", "following_url": "https://api.github.com/users/michaelwu/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwu/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwu/subscriptions", "organizations_url": "https://api.github.com/users/michaelwu/orgs", "repos_url": "https://api.github.com/users/michaelwu/repos", "events_url": "https://api.github.com/users/michaelwu/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwu", "id": 719931, "node_id": "MDQ6VXNlcjcxOTkzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/719931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwu", "html_url": "https://github.com/michaelwu", "followers_url": "https://api.github.com/users/michaelwu/followers", "following_url": "https://api.github.com/users/michaelwu/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwu/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwu/subscriptions", "organizations_url": "https://api.github.com/users/michaelwu/orgs", "repos_url": "https://api.github.com/users/michaelwu/repos", "events_url": "https://api.github.com/users/michaelwu/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1447ce78fbd65a629f228ec8731a5cddc076a15c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1447ce78fbd65a629f228ec8731a5cddc076a15c", "html_url": "https://github.com/rust-lang/rust/commit/1447ce78fbd65a629f228ec8731a5cddc076a15c"}], "stats": {"total": 289, "additions": 217, "deletions": 72}, "files": [{"sha": "a458c2e14bee6eadd5dad27669af48372e4d3057", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=a4f91e5fed85164a8535a2300ca6445520d25059", "patch": "@@ -657,13 +657,10 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 Some(def::DefConst(did)) |\n                 Some(def::DefAssociatedConst(did)) => {\n                     if let Some(expr) = const_eval::lookup_const_by_id(v.tcx, did,\n-                                                                       Some(e.id)) {\n+                                                                       Some(e.id),\n+                                                                       None) {\n                         let inner = v.global_expr(Mode::Const, expr);\n                         v.add_qualif(inner);\n-                    } else {\n-                        v.tcx.sess.span_bug(e.span,\n-                                            \"DefConst or DefAssociatedConst \\\n-                                             doesn't point to a constant\");\n                     }\n                 }\n                 Some(def::DefLocal(..)) if v.mode == Mode::ConstFn => {"}, {"sha": "dc777585e4194e941b08b1478e5cde2ce88e7b31", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=a4f91e5fed85164a8535a2300ca6445520d25059", "patch": "@@ -455,7 +455,8 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n                     Some(DefAssociatedConst(did)) |\n-                    Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did, Some(pat.id)) {\n+                    Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did,\n+                                                                    Some(pat.id), None) {\n                         Some(const_expr) => {\n                             const_expr_to_pat(self.tcx, const_expr, pat.span).map(|new_pat| {\n "}, {"sha": "de7f543e3280d3702be57a6038d9267582320cb7", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=a4f91e5fed85164a8535a2300ca6445520d25059", "patch": "@@ -18,6 +18,7 @@ use front::map as ast_map;\n use front::map::blocks::FnLikeNode;\n use middle::cstore::{self, CrateStore, InlinedItem};\n use middle::{def, infer, subst, traits};\n+use middle::subst::Subst;\n use middle::def_id::DefId;\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty};\n@@ -48,7 +49,7 @@ fn lookup_const<'a>(tcx: &'a ty::ctxt, e: &Expr) -> Option<&'a Expr> {\n     match opt_def {\n         Some(def::DefConst(def_id)) |\n         Some(def::DefAssociatedConst(def_id)) => {\n-            lookup_const_by_id(tcx, def_id, Some(e.id))\n+            lookup_const_by_id(tcx, def_id, Some(e.id), None)\n         }\n         Some(def::DefVariant(enum_def, variant_def, _)) => {\n             lookup_variant_by_id(tcx, enum_def, variant_def)\n@@ -88,9 +89,17 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n     }\n }\n \n+/// * `def_id` is the id of the constant.\n+/// * `maybe_ref_id` is the id of the expr referencing the constant.\n+/// * `param_substs` is the monomorphization substitution for the expression.\n+///\n+/// `maybe_ref_id` and `param_substs` are optional and are used for\n+/// finding substitutions in associated constants. This generally\n+/// happens in late/trans const evaluation.\n pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                         def_id: DefId,\n-                                        maybe_ref_id: Option<ast::NodeId>)\n+                                        maybe_ref_id: Option<ast::NodeId>,\n+                                        param_substs: Option<&'tcx subst::Substs<'tcx>>)\n                                         -> Option<&'tcx Expr> {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         match tcx.map.find(node_id) {\n@@ -111,8 +120,11 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                         Some(ref_id) => {\n                             let trait_id = tcx.trait_of_item(def_id)\n                                               .unwrap();\n-                            let substs = tcx.node_id_item_substs(ref_id)\n-                                            .substs;\n+                            let mut substs = tcx.node_id_item_substs(ref_id)\n+                                                .substs;\n+                            if let Some(param_substs) = param_substs {\n+                                substs = substs.subst(tcx, param_substs);\n+                            }\n                             resolve_trait_associated_const(tcx, ti, trait_id,\n                                                            substs)\n                         }\n@@ -158,8 +170,11 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                         // a trait-associated const if the caller gives us\n                         // the expression that refers to it.\n                         Some(ref_id) => {\n-                            let substs = tcx.node_id_item_substs(ref_id)\n-                                            .substs;\n+                            let mut substs = tcx.node_id_item_substs(ref_id)\n+                                                .substs;\n+                            if let Some(param_substs) = param_substs {\n+                                substs = substs.subst(tcx, param_substs);\n+                            }\n                             resolve_trait_associated_const(tcx, ti, trait_id,\n                                                            substs).map(|e| e.id)\n                         }\n@@ -1013,7 +1028,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           _ => (None, None)\n                       }\n                   } else {\n-                      (lookup_const_by_id(tcx, def_id, Some(e.id)), None)\n+                      (lookup_const_by_id(tcx, def_id, Some(e.id), None), None)\n                   }\n               }\n               Some(def::DefAssociatedConst(def_id)) => {\n@@ -1048,7 +1063,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           },\n                       }\n                   } else {\n-                      (lookup_const_by_id(tcx, def_id, Some(e.id)), None)\n+                      (lookup_const_by_id(tcx, def_id, Some(e.id), None), None)\n                   }\n               }\n               Some(def::DefVariant(enum_def, variant_def, _)) => {\n@@ -1260,20 +1275,16 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n         Ok(None) => {\n             return None\n         }\n-        Err(e) => {\n-            tcx.sess.span_bug(ti.span,\n-                              &format!(\"Encountered error `{:?}` when trying \\\n-                                        to select an implementation for \\\n-                                        constant trait item reference.\",\n-                                       e))\n+        Err(_) => {\n+            return None\n         }\n     };\n \n     match selection {\n         traits::VtableImpl(ref impl_data) => {\n             match tcx.associated_consts(impl_data.impl_def_id)\n                      .iter().find(|ic| ic.name == ti.name) {\n-                Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n+                Some(ic) => lookup_const_by_id(tcx, ic.def_id, None, None),\n                 None => match ti.node {\n                     hir::ConstTraitItem(_, Some(ref expr)) => Some(&*expr),\n                     _ => None,"}, {"sha": "dc377ac731a6581ddf9346c4c7e1cebfb37d61ed", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=a4f91e5fed85164a8535a2300ca6445520d25059", "patch": "@@ -85,7 +85,8 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n                 match def {\n                     def::DefConst(def_id) | def::DefAssociatedConst(def_id) =>\n-                        match const_eval::lookup_const_by_id(self.cx.tcx, def_id, Some(pat.id)) {\n+                        match const_eval::lookup_const_by_id(self.cx.tcx, def_id,\n+                                                             Some(pat.id), None) {\n                             Some(const_expr) => {\n                                 let pat = const_eval::const_expr_to_pat(self.cx.tcx, const_expr,\n                                                                         pat.span);"}, {"sha": "d5a7995b65dfc21538e09db53899ed3720c53485", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=a4f91e5fed85164a8535a2300ca6445520d25059", "patch": "@@ -217,7 +217,8 @@ fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 def_id: DefId,\n-                                ref_expr: &hir::Expr)\n+                                ref_expr: &hir::Expr,\n+                                param_substs: &'tcx Substs<'tcx>)\n                                 -> &'tcx hir::Expr {\n     let def_id = inline::maybe_instantiate_inline(ccx, def_id);\n \n@@ -226,7 +227,7 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             \"cross crate constant could not be inlined\");\n     }\n \n-    match const_eval::lookup_const_by_id(ccx.tcx(), def_id, Some(ref_expr.id)) {\n+    match const_eval::lookup_const_by_id(ccx.tcx(), def_id, Some(ref_expr.id), Some(param_substs)) {\n         Some(ref expr) => expr,\n         None => {\n             ccx.sess().span_bug(ref_expr.span, \"constant item not found\")\n@@ -264,10 +265,12 @@ pub enum TrueConst {\n \n use self::ConstEvalFailure::*;\n \n-fn get_const_val(ccx: &CrateContext,\n-                 def_id: DefId,\n-                 ref_expr: &hir::Expr) -> Result<ValueRef, ConstEvalFailure> {\n-    let expr = get_const_expr(ccx, def_id, ref_expr);\n+fn get_const_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                           def_id: DefId,\n+                           ref_expr: &hir::Expr,\n+                           param_substs: &'tcx Substs<'tcx>)\n+                           -> Result<ValueRef, ConstEvalFailure> {\n+    let expr = get_const_expr(ccx, def_id, ref_expr, param_substs);\n     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n     match get_const_expr_as_global(ccx, expr, check_const::ConstQualif::empty(),\n                                    empty_substs, TrueConst::Yes) {\n@@ -297,7 +300,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 if !ccx.tcx().tables.borrow().adjustments.contains_key(&expr.id) {\n                     debug!(\"get_const_expr_as_global ({:?}): found const {:?}\",\n                            expr.id, def_id);\n-                    return get_const_val(ccx, def_id, expr);\n+                    return get_const_val(ccx, def_id, expr, param_substs);\n                 }\n             },\n             _ => {},\n@@ -888,7 +891,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                 }\n                 def::DefConst(def_id) | def::DefAssociatedConst(def_id) => {\n-                    const_deref_ptr(cx, try!(get_const_val(cx, def_id, e)))\n+                    const_deref_ptr(cx, try!(get_const_val(cx, def_id, e, param_substs)))\n                 }\n                 def::DefVariant(enum_did, variant_did, _) => {\n                     let vinfo = cx.tcx().lookup_adt_def(enum_did).variant_with_id(variant_did);"}, {"sha": "0a89fd92845881fc732990dfd36798b7f471899b", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=a4f91e5fed85164a8535a2300ca6445520d25059", "patch": "@@ -165,7 +165,9 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 hir::ExprPath(..) => {\n                     match bcx.def(expr.id) {\n                         def::DefConst(did) => {\n-                            let const_expr = consts::get_const_expr(bcx.ccx(), did, expr);\n+                            let empty_substs = bcx.tcx().mk_substs(Substs::trans_empty());\n+                            let const_expr = consts::get_const_expr(bcx.ccx(), did, expr,\n+                                                                    empty_substs);\n                             // Temporarily get cleanup scopes out of the way,\n                             // as they require sub-expressions to be contained\n                             // inside the current AST scope."}, {"sha": "3238869cac5c1ad9adb165faf70ec246ca769fba", "filename": "src/librustc_trans/trans/mir/did.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdid.rs?ref=a4f91e5fed85164a8535a2300ca6445520d25059", "patch": "@@ -50,7 +50,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             },\n             ItemKind::Constant => {\n                 let did = inline::maybe_instantiate_inline(bcx.ccx(), did);\n-                let expr = const_eval::lookup_const_by_id(bcx.tcx(), did, None)\n+                let expr = const_eval::lookup_const_by_id(bcx.tcx(), did, None, Some(substs))\n                             .expect(\"def was const, but lookup_const_by_id failed\");\n                 // FIXME: this is falling back to translating from HIR. This is not easy to fix,\n                 // because we would have somehow adapt const_eval to work on MIR rather than HIR."}, {"sha": "0f87dc888524378ab8a1615d713b848ef3620ac3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a4f91e5fed85164a8535a2300ca6445520d25059", "patch": "@@ -3785,35 +3785,8 @@ pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n                                                         def::Def)>\n {\n \n-    // Associated constants can't depend on generic types.\n-    fn have_disallowed_generic_consts<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                                def: def::Def,\n-                                                ty: Ty<'tcx>,\n-                                                span: Span,\n-                                                node_id: ast::NodeId) -> bool {\n-        match def {\n-            def::DefAssociatedConst(..) => {\n-                if ty.has_param_types() || ty.has_self_ty() {\n-                    span_err!(fcx.sess(), span, E0329,\n-                              \"Associated consts cannot depend \\\n-                               on type parameters or Self.\");\n-                    fcx.write_error(node_id);\n-                    return true;\n-                }\n-            }\n-            _ => {}\n-        }\n-        false\n-    }\n-\n     // If fully resolved already, we don't have to do anything.\n     if path_res.depth == 0 {\n-        if let Some(ty) = opt_self_ty {\n-            if have_disallowed_generic_consts(fcx, path_res.full_def(), ty,\n-                                              span, node_id) {\n-                return None;\n-            }\n-        }\n         Some((opt_self_ty, &path.segments, path_res.base_def))\n     } else {\n         let mut def = path_res.base_def;\n@@ -3829,9 +3802,6 @@ pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n         let item_name = item_segment.identifier.name;\n         match method::resolve_ufcs(fcx, span, item_name, ty, node_id) {\n             Ok((def, lp)) => {\n-                if have_disallowed_generic_consts(fcx, def, ty, span, node_id) {\n-                    return None;\n-                }\n                 // Write back the new resolution.\n                 fcx.ccx.tcx.def_map.borrow_mut()\n                        .insert(node_id, def::PathResolution {"}, {"sha": "30b478f486e0a8b1f771f0666b9e1824746152cd", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=a4f91e5fed85164a8535a2300ca6445520d25059", "patch": "@@ -321,7 +321,7 @@ pub fn build_impl(cx: &DocContext,\n                 let did = assoc_const.def_id;\n                 let type_scheme = tcx.lookup_item_type(did);\n                 let default = if assoc_const.has_value {\n-                    Some(const_eval::lookup_const_by_id(tcx, did, None)\n+                    Some(const_eval::lookup_const_by_id(tcx, did, None, None)\n                          .unwrap().span.to_src(cx))\n                 } else {\n                     None\n@@ -479,7 +479,7 @@ fn build_const(cx: &DocContext, tcx: &ty::ctxt,\n     use rustc::middle::const_eval;\n     use rustc_front::print::pprust;\n \n-    let expr = const_eval::lookup_const_by_id(tcx, did, None).unwrap_or_else(|| {\n+    let expr = const_eval::lookup_const_by_id(tcx, did, None, None).unwrap_or_else(|| {\n         panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n     });\n     debug!(\"converting constant expr {:?} to snippet\", expr);"}, {"sha": "5d8007defc9065d15bc3db1b33929f31ba56e11e", "filename": "src/test/compile-fail/associated-const-array-len.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Ftest%2Fcompile-fail%2Fassociated-const-array-len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Ftest%2Fcompile-fail%2Fassociated-const-array-len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-array-len.rs?ref=a4f91e5fed85164a8535a2300ca6445520d25059", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+trait Foo {\n+    const ID: usize;\n+}\n+\n+const X: [i32; <i32 as Foo>::ID] = [0, 1, 2]; //~ ERROR E0250\n+\n+fn main() {\n+    assert_eq!(1, X);\n+}"}, {"sha": "89d1ac13087a9bd2c687857506e252b13b54f829", "filename": "src/test/compile-fail/associated-const-no-item.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Ftest%2Fcompile-fail%2Fassociated-const-no-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Ftest%2Fcompile-fail%2Fassociated-const-no-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-no-item.rs?ref=a4f91e5fed85164a8535a2300ca6445520d25059", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+trait Foo {\n+    const ID: i32;\n+}\n+\n+const X: i32 = <i32>::ID;\n+//~^ ERROR no associated item named `ID` found for type `i32`\n+\n+fn main() {\n+    assert_eq!(1, X);\n+}"}, {"sha": "f564157b498147c98c40fae27cf758bb19cf8885", "filename": "src/test/compile-fail/associated-const-type-parameter-arms.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arms.rs?ref=a4f91e5fed85164a8535a2300ca6445520d25059", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+pub enum EFoo { A, B, C, D }\n+\n+pub trait Foo {\n+    const X: EFoo;\n+}\n+\n+struct Abc;\n+impl Foo for Abc {\n+    const X: EFoo = EFoo::B;\n+}\n+\n+struct Def;\n+impl Foo for Def {\n+    const X: EFoo = EFoo::D;\n+}\n+\n+pub fn test<A: Foo, B: Foo>(arg: EFoo) {\n+    match arg {\n+        A::X => println!(\"A::X\"), //~ error: statics cannot be referenced in patterns [E0158]\n+        B::X => println!(\"B::X\"), //~ error: statics cannot be referenced in patterns [E0158]\n+        _ => (),\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "2f687350f34e0bcd30b266f42fd7fa05854ccc77", "filename": "src/test/compile-fail/associated-const-type-parameter-arrays-2.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs?ref=a4f91e5fed85164a8535a2300ca6445520d25059", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+pub trait Foo {\n+    const Y: usize;\n+}\n+\n+struct Abc;\n+impl Foo for Abc {\n+    const Y: usize = 8;\n+}\n+\n+struct Def;\n+impl Foo for Def {\n+    const Y: usize = 33;\n+}\n+\n+pub fn test<A: Foo, B: Foo>() {\n+    let _array = [4; <A as Foo>::Y]; //~ error: expected constant integer\n+}\n+\n+fn main() {\n+}"}, {"sha": "3d3b795b2291a095241b5a94b59dd9575a07d231", "filename": "src/test/compile-fail/associated-const-type-parameter-arrays.rs", "status": "renamed", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs?ref=a4f91e5fed85164a8535a2300ca6445520d25059", "patch": "@@ -11,16 +11,22 @@\n #![feature(associated_consts)]\n \n pub trait Foo {\n-    const MIN: i32;\n+    const Y: usize;\n+}\n+\n+struct Abc;\n+impl Foo for Abc {\n+    const Y: usize = 8;\n+}\n \n-    fn get_min() -> i32 {\n-        Self::MIN //~ ERROR E0329\n-    }\n+struct Def;\n+impl Foo for Def {\n+    const Y: usize = 33;\n }\n \n-fn get_min<T: Foo>() -> i32 {\n-    T::MIN; //~ ERROR E0329\n-    <T as Foo>::MIN //~ ERROR E0329\n+pub fn test<A: Foo, B: Foo>() {\n+    let _array: [u32; <A as Foo>::Y]; //~ error: the parameter type\n }\n \n-fn main() {}\n+fn main() {\n+}", "previous_filename": "src/test/compile-fail/associated-const-type-parameters.rs"}, {"sha": "e3d1761dfffdbe6f3ce1c9029f211fea9e693f95", "filename": "src/test/run-pass/associated-const-type-parameters.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Ftest%2Frun-pass%2Fassociated-const-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f91e5fed85164a8535a2300ca6445520d25059/src%2Ftest%2Frun-pass%2Fassociated-const-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-type-parameters.rs?ref=a4f91e5fed85164a8535a2300ca6445520d25059", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+trait Foo {\n+    const X: i32;\n+    fn get_x() -> i32 {\n+       Self::X\n+    }\n+}\n+\n+struct Abc;\n+impl Foo for Abc {\n+    const X: i32 = 11;\n+}\n+\n+struct Def;\n+impl Foo for Def {\n+    const X: i32 = 97;\n+}\n+\n+fn sub<A: Foo, B: Foo>() -> i32 {\n+    A::X - B::X\n+}\n+\n+fn main() {\n+    assert_eq!(11, Abc::X);\n+    assert_eq!(97, Def::X);\n+    assert_eq!(11, Abc::get_x());\n+    assert_eq!(97, Def::get_x());\n+    assert_eq!(-86, sub::<Abc, Def>());\n+    assert_eq!(86, sub::<Def, Abc>());\n+}"}]}