{"sha": "7b5f4894f18a04042a652e4a25503f46aacfadb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiNWY0ODk0ZjE4YTA0MDQyYTY1MmU0YTI1NTAzZjQ2YWFjZmFkYjQ=", "commit": {"author": {"name": "Dan Gohman", "email": "sunfish@mozilla.com", "date": "2018-11-12T15:23:39Z"}, "committer": {"name": "Dan Gohman", "email": "sunfish@mozilla.com", "date": "2018-11-12T15:20:42Z"}, "message": "Change \"cton\" to \"clif\".", "tree": {"sha": "763ef7b1e0e36fa70dbedf81915e5e60777c5250", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/763ef7b1e0e36fa70dbedf81915e5e60777c5250"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b5f4894f18a04042a652e4a25503f46aacfadb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b5f4894f18a04042a652e4a25503f46aacfadb4", "html_url": "https://github.com/rust-lang/rust/commit/7b5f4894f18a04042a652e4a25503f46aacfadb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b5f4894f18a04042a652e4a25503f46aacfadb4/comments", "author": {"login": "sunfishcode", "id": 4503403, "node_id": "MDQ6VXNlcjQ1MDM0MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/4503403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunfishcode", "html_url": "https://github.com/sunfishcode", "followers_url": "https://api.github.com/users/sunfishcode/followers", "following_url": "https://api.github.com/users/sunfishcode/following{/other_user}", "gists_url": "https://api.github.com/users/sunfishcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunfishcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunfishcode/subscriptions", "organizations_url": "https://api.github.com/users/sunfishcode/orgs", "repos_url": "https://api.github.com/users/sunfishcode/repos", "events_url": "https://api.github.com/users/sunfishcode/events{/privacy}", "received_events_url": "https://api.github.com/users/sunfishcode/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sunfishcode", "id": 4503403, "node_id": "MDQ6VXNlcjQ1MDM0MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/4503403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunfishcode", "html_url": "https://github.com/sunfishcode", "followers_url": "https://api.github.com/users/sunfishcode/followers", "following_url": "https://api.github.com/users/sunfishcode/following{/other_user}", "gists_url": "https://api.github.com/users/sunfishcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunfishcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunfishcode/subscriptions", "organizations_url": "https://api.github.com/users/sunfishcode/orgs", "repos_url": "https://api.github.com/users/sunfishcode/repos", "events_url": "https://api.github.com/users/sunfishcode/events{/privacy}", "received_events_url": "https://api.github.com/users/sunfishcode/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27d90ab1d56fb9727f5f1fd5673c8845abca97cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/27d90ab1d56fb9727f5f1fd5673c8845abca97cd", "html_url": "https://github.com/rust-lang/rust/commit/27d90ab1d56fb9727f5f1fd5673c8845abca97cd"}], "stats": {"total": 108, "additions": 54, "deletions": 54}, "files": [{"sha": "597e288d6033d4218d04583faa72657e7dcd338b", "filename": "src/abi.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7b5f4894f18a04042a652e4a25503f46aacfadb4/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5f4894f18a04042a652e4a25503f46aacfadb4/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=7b5f4894f18a04042a652e4a25503f46aacfadb4", "patch": "@@ -16,7 +16,7 @@ impl PassMode {\n     fn get_param_ty(self, fx: &FunctionCx<impl Backend>) -> Type {\n         match self {\n             PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n-            PassMode::ByVal(cton_type) => cton_type,\n+            PassMode::ByVal(clif_type) => clif_type,\n             PassMode::ByRef => fx.pointer_type,\n         }\n     }\n@@ -44,7 +44,7 @@ fn get_pass_mode<'a, 'tcx: 'a>(\n         } else {\n             PassMode::ByRef\n         }\n-    } else if let Some(ret_ty) = crate::common::cton_type_from_ty(tcx, ty) {\n+    } else if let Some(ret_ty) = crate::common::clif_type_from_ty(tcx, ty) {\n         PassMode::ByVal(ret_ty)\n     } else {\n         if abi == Abi::C {\n@@ -70,7 +70,7 @@ fn adjust_arg_for_abi<'a, 'tcx: 'a>(\n     }\n }\n \n-pub fn cton_sig_from_fn_ty<'a, 'tcx: 'a>(\n+pub fn clif_sig_from_fn_ty<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     fn_ty: Ty<'tcx>,\n ) -> Signature {\n@@ -97,7 +97,7 @@ pub fn cton_sig_from_fn_ty<'a, 'tcx: 'a>(\n     let inputs = inputs\n         .into_iter()\n         .filter_map(|ty| match get_pass_mode(tcx, sig.abi, ty, false) {\n-            PassMode::ByVal(cton_ty) => Some(cton_ty),\n+            PassMode::ByVal(clif_ty) => Some(clif_ty),\n             PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n             PassMode::ByRef => Some(pointer_ty(tcx)),\n         });\n@@ -178,7 +178,7 @@ pub fn get_function_name_and_sig<'a, 'tcx>(\n ) -> (String, Signature) {\n     assert!(!inst.substs.needs_infer() && !inst.substs.has_param_types());\n     let fn_ty = inst.ty(tcx);\n-    let sig = cton_sig_from_fn_ty(tcx, fn_ty);\n+    let sig = clif_sig_from_fn_ty(tcx, fn_ty);\n     (tcx.symbol_name(inst).as_str().to_string(), sig)\n }\n \n@@ -238,7 +238,7 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n             .into_iter()\n             .map(|arg| {\n                 (\n-                    self.cton_type(arg.layout().ty).unwrap(),\n+                    self.clif_type(arg.layout().ty).unwrap(),\n                     arg.load_value(self),\n                 )\n             })\n@@ -250,7 +250,7 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n             }\n             None\n         } else {\n-            Some(self.cton_type(return_ty).unwrap())\n+            Some(self.clif_type(return_ty).unwrap())\n         };\n         if let Some(val) = self.lib_call(name, input_tys, return_ty, &args) {\n             CValue::ByVal(val, return_layout)\n@@ -307,18 +307,18 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n \n                 let mut ebb_params = Vec::new();\n                 for arg_ty in tupled_arg_tys.iter() {\n-                    let cton_type =\n+                    let clif_type =\n                         get_pass_mode(fx.tcx, fx.self_sig().abi, arg_ty, false).get_param_ty(fx);\n-                    ebb_params.push(fx.bcx.append_ebb_param(start_ebb, cton_type));\n+                    ebb_params.push(fx.bcx.append_ebb_param(start_ebb, clif_type));\n                 }\n \n                 (local, ArgKind::Spread(ebb_params), arg_ty)\n             } else {\n-                let cton_type =\n+                let clif_type =\n                     get_pass_mode(fx.tcx, fx.self_sig().abi, arg_ty, false).get_param_ty(fx);\n                 (\n                     local,\n-                    ArgKind::Normal(fx.bcx.append_ebb_param(start_ebb, cton_type)),\n+                    ArgKind::Normal(fx.bcx.append_ebb_param(start_ebb, clif_type)),\n                     arg_ty,\n                 )\n             }\n@@ -368,7 +368,7 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n                 .contains(crate::analyze::Flags::NOT_SSA)\n             {\n                 fx.bcx\n-                    .declare_var(mir_var(local), fx.cton_type(ty).unwrap());\n+                    .declare_var(mir_var(local), fx.clif_type(ty).unwrap());\n                 match get_pass_mode(fx.tcx, fx.self_sig().abi, ty, false) {\n                     PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n                     PassMode::ByVal(_) => fx.bcx.def_var(mir_var(local), ebb_param),\n@@ -434,7 +434,7 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n             CPlace::from_stack_slot(fx, stack_slot, ty)\n         } else {\n             fx.bcx\n-                .declare_var(mir_var(local), fx.cton_type(ty).unwrap());\n+                .declare_var(mir_var(local), fx.clif_type(ty).unwrap());\n             CPlace::Var(local, layout)\n         };\n \n@@ -568,7 +568,7 @@ pub fn codegen_call_inner<'a, 'tcx: 'a>(\n         )\n         .collect::<Vec<_>>();\n \n-    let sig = fx.bcx.import_signature(cton_sig_from_fn_ty(fx.tcx, fn_ty));\n+    let sig = fx.bcx.import_signature(clif_sig_from_fn_ty(fx.tcx, fn_ty));\n     let call_inst = if let Some(func_ref) = func_ref {\n         fx.bcx.ins().call_indirect(sig, func_ref, &call_args)\n     } else {"}, {"sha": "025fc1fecba6714436e95ef62f5854f9c9c5f7ca", "filename": "src/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b5f4894f18a04042a652e4a25503f46aacfadb4/src%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5f4894f18a04042a652e4a25503f46aacfadb4/src%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fanalyze.rs?ref=7b5f4894f18a04042a652e4a25503f46aacfadb4", "patch": "@@ -18,7 +18,7 @@ pub fn analyze<'a, 'tcx: 'a>(fx: &FunctionCx<'a, 'tcx, impl Backend>) -> HashMap\n     not_ssa(&mut flag_map, RETURN_PLACE);\n \n     for (local, local_decl) in fx.mir.local_decls.iter_enumerated() {\n-        if fx.cton_type(local_decl.ty).is_none() {\n+        if fx.clif_type(local_decl.ty).is_none() {\n             not_ssa(&mut flag_map, local);\n         }\n     }"}, {"sha": "00e80dfa8ca467bc69e3d99343db77ad196b1e5f", "filename": "src/base.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7b5f4894f18a04042a652e4a25503f46aacfadb4/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5f4894f18a04042a652e4a25503f46aacfadb4/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=7b5f4894f18a04042a652e4a25503f46aacfadb4", "patch": "@@ -110,17 +110,17 @@ fn trans_fn<'a, 'tcx: 'a>(\n     // Step 7. Write function to file for debugging\n     let mut writer = crate::pretty_clif::CommentWriter(fx.comments);\n \n-    let mut cton = String::new();\n+    let mut clif = String::new();\n     if cfg!(debug_assertions) {\n-        ::cranelift::codegen::write::decorate_function(&mut writer, &mut cton, &func, None)\n+        ::cranelift::codegen::write::decorate_function(&mut writer, &mut clif, &func, None)\n             .unwrap();\n         let clif_file_name = format!(\n             \"{}/{}__{}.clif\",\n             concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/target/out/clif\"),\n             tcx.crate_name(LOCAL_CRATE),\n             tcx.symbol_name(instance).as_str(),\n         );\n-        if let Err(e) = ::std::fs::write(clif_file_name, cton.as_bytes()) {\n+        if let Err(e) = ::std::fs::write(clif_file_name, clif.as_bytes()) {\n             tcx.sess.warn(&format!(\"err writing clif file: {:?}\", e));\n         }\n     }\n@@ -452,7 +452,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                         }\n                         UnOp::Neg => match layout.ty.sty {\n                             ty::Int(_) => {\n-                                let clif_ty = fx.cton_type(layout.ty).unwrap();\n+                                let clif_ty = fx.clif_type(layout.ty).unwrap();\n                                 let zero = fx.bcx.ins().iconst(clif_ty, 0);\n                                 fx.bcx.ins().isub(zero, val)\n                             }\n@@ -495,20 +495,20 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                         | (ty::Uint(_), ty::Int(_))\n                         | (ty::Uint(_), ty::Uint(_)) => {\n                             let from = operand.load_value(fx);\n-                            let res = crate::common::cton_intcast(\n+                            let res = crate::common::clif_intcast(\n                                 fx,\n                                 from,\n-                                fx.cton_type(to_ty).unwrap(),\n+                                fx.clif_type(to_ty).unwrap(),\n                                 false,\n                             );\n                             lval.write_cvalue(fx, CValue::ByVal(res, dest_layout));\n                         }\n                         (ty::Int(_), ty::Int(_)) | (ty::Int(_), ty::Uint(_)) => {\n                             let from = operand.load_value(fx);\n-                            let res = crate::common::cton_intcast(\n+                            let res = crate::common::clif_intcast(\n                                 fx,\n                                 from,\n-                                fx.cton_type(to_ty).unwrap(),\n+                                fx.clif_type(to_ty).unwrap(),\n                                 true,\n                             );\n                             lval.write_cvalue(fx, CValue::ByVal(res, dest_layout));\n@@ -527,33 +527,33 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                             lval.write_cvalue(fx, CValue::ByVal(res, dest_layout));\n                         }\n                         (ty::Int(_), ty::Float(_)) => {\n-                            let from_ty = fx.cton_type(from_ty).unwrap();\n+                            let from_ty = fx.clif_type(from_ty).unwrap();\n                             let from = operand.load_value(fx);\n                             // FIXME missing encoding for fcvt_from_sint.f32.i8\n                             let from = if from_ty == types::I8 || from_ty == types::I16 {\n                                 fx.bcx.ins().sextend(types::I32, from)\n                             } else {\n                                 from\n                             };\n-                            let f_type = fx.cton_type(to_ty).unwrap();\n+                            let f_type = fx.clif_type(to_ty).unwrap();\n                             let res = fx.bcx.ins().fcvt_from_sint(f_type, from);\n                             lval.write_cvalue(fx, CValue::ByVal(res, dest_layout));\n                         }\n                         (ty::Uint(_), ty::Float(_)) => {\n-                            let from_ty = fx.cton_type(from_ty).unwrap();\n+                            let from_ty = fx.clif_type(from_ty).unwrap();\n                             let from = operand.load_value(fx);\n                             // FIXME missing encoding for fcvt_from_uint.f32.i8\n                             let from = if from_ty == types::I8 || from_ty == types::I16 {\n                                 fx.bcx.ins().uextend(types::I32, from)\n                             } else {\n                                 from\n                             };\n-                            let f_type = fx.cton_type(to_ty).unwrap();\n+                            let f_type = fx.clif_type(to_ty).unwrap();\n                             let res = fx.bcx.ins().fcvt_from_uint(f_type, from);\n                             lval.write_cvalue(fx, CValue::ByVal(res, dest_layout));\n                         }\n                         (ty::Bool, ty::Uint(_)) | (ty::Bool, ty::Int(_)) => {\n-                            let to_ty = fx.cton_type(to_ty).unwrap();\n+                            let to_ty = fx.clif_type(to_ty).unwrap();\n                             let from = operand.load_value(fx);\n                             let res = if to_ty != types::I8 {\n                                 fx.bcx.ins().uextend(to_ty, from)\n@@ -605,7 +605,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                 Rvalue::NullaryOp(NullOp::Box, content_ty) => {\n                     use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n \n-                    let usize_type = fx.cton_type(fx.tcx.types.usize).unwrap();\n+                    let usize_type = fx.clif_type(fx.tcx.types.usize).unwrap();\n                     let (size, align) = fx.layout_of(content_ty).size_and_align();\n                     let llsize = fx.bcx.ins().iconst(usize_type, size.bytes() as i64);\n                     let llalign = fx.bcx.ins().iconst(usize_type, align.abi() as i64);\n@@ -690,7 +690,7 @@ pub fn trans_get_discriminant<'a, 'tcx: 'a>(\n                 layout::Int(_, signed) => signed,\n                 _ => false,\n             };\n-            let val = cton_intcast(fx, lldiscr, fx.cton_type(dest_layout.ty).unwrap(), signed);\n+            let val = clif_intcast(fx, lldiscr, fx.clif_type(dest_layout.ty).unwrap(), signed);\n             return CValue::ByVal(val, dest_layout);\n         }\n         layout::Variants::NicheFilling {\n@@ -699,8 +699,8 @@ pub fn trans_get_discriminant<'a, 'tcx: 'a>(\n             niche_start,\n             ..\n         } => {\n-            let niche_llty = fx.cton_type(discr_ty).unwrap();\n-            let dest_cton_ty = fx.cton_type(dest_layout.ty).unwrap();\n+            let niche_llty = fx.clif_type(discr_ty).unwrap();\n+            let dest_clif_ty = fx.clif_type(dest_layout.ty).unwrap();\n             if niche_variants.start() == niche_variants.end() {\n                 let b = fx\n                     .bcx\n@@ -709,11 +709,11 @@ pub fn trans_get_discriminant<'a, 'tcx: 'a>(\n                 let if_true = fx\n                     .bcx\n                     .ins()\n-                    .iconst(dest_cton_ty, *niche_variants.start() as u64 as i64);\n+                    .iconst(dest_clif_ty, *niche_variants.start() as u64 as i64);\n                 let if_false = fx\n                     .bcx\n                     .ins()\n-                    .iconst(dest_cton_ty, dataful_variant as u64 as i64);\n+                    .iconst(dest_clif_ty, dataful_variant as u64 as i64);\n                 let val = fx.bcx.ins().select(b, if_true, if_false);\n                 return CValue::ByVal(val, dest_layout);\n             } else {\n@@ -727,11 +727,11 @@ pub fn trans_get_discriminant<'a, 'tcx: 'a>(\n                     *niche_variants.end() as u64 as i64,\n                 );\n                 let if_true =\n-                    cton_intcast(fx, lldiscr, fx.cton_type(dest_layout.ty).unwrap(), false);\n+                    clif_intcast(fx, lldiscr, fx.clif_type(dest_layout.ty).unwrap(), false);\n                 let if_false = fx\n                     .bcx\n                     .ins()\n-                    .iconst(dest_cton_ty, dataful_variant as u64 as i64);\n+                    .iconst(dest_clif_ty, dataful_variant as u64 as i64);\n                 let val = fx.bcx.ins().select(b, if_true, if_false);\n                 return CValue::ByVal(val, dest_layout);\n             }\n@@ -748,10 +748,10 @@ macro_rules! binop_match {\n         let ret_layout = $fx.layout_of($ret_ty);\n \n         // TODO HACK no encoding for icmp.i8\n-        use crate::common::cton_intcast;\n+        use crate::common::clif_intcast;\n         let (lhs, rhs) = (\n-            cton_intcast($fx, $lhs, types::I64, $signed),\n-            cton_intcast($fx, $rhs, types::I64, $signed),\n+            clif_intcast($fx, $lhs, types::I64, $signed),\n+            clif_intcast($fx, $rhs, types::I64, $signed),\n         );\n         let b = $fx.bcx.ins().icmp(IntCC::$cc, lhs, rhs);\n "}, {"sha": "d024cb49e4fba340d8392635ddc7500f46a0b72a", "filename": "src/common.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7b5f4894f18a04042a652e4a25503f46aacfadb4/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5f4894f18a04042a652e4a25503f46aacfadb4/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=7b5f4894f18a04042a652e4a25503f46aacfadb4", "patch": "@@ -19,7 +19,7 @@ pub fn pointer_ty(tcx: TyCtxt) -> types::Type {\n     }\n }\n \n-fn scalar_to_cton_type(tcx: TyCtxt, scalar: &Scalar) -> Type {\n+fn scalar_to_clif_type(tcx: TyCtxt, scalar: &Scalar) -> Type {\n     match scalar.value.size(&tcx).bits() {\n         8 => types::I8,\n         16 => types::I16,\n@@ -29,7 +29,7 @@ fn scalar_to_cton_type(tcx: TyCtxt, scalar: &Scalar) -> Type {\n     }\n }\n \n-pub fn cton_type_from_ty<'a, 'tcx: 'a>(\n+pub fn clif_type_from_ty<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<types::Type> {\n@@ -157,7 +157,7 @@ impl<'tcx> CValue<'tcx> {\n     {\n         match self {\n             CValue::ByRef(addr, layout) => {\n-                let cton_ty = fx.cton_type(layout.ty).unwrap_or_else(|| {\n+                let clif_ty = fx.clif_type(layout.ty).unwrap_or_else(|| {\n                     if layout.ty.is_box()\n                         && !fx\n                             .layout_of(layout.ty.builtin_deref(true).unwrap().ty)\n@@ -169,7 +169,7 @@ impl<'tcx> CValue<'tcx> {\n                         panic!(\"load_value of type {:?}\", layout.ty);\n                     }\n                 });\n-                fx.bcx.ins().load(cton_ty, MemFlags::new(), addr, 0)\n+                fx.bcx.ins().load(clif_ty, MemFlags::new(), addr, 0)\n             }\n             CValue::ByVal(value, _layout) => value,\n             CValue::ByValPair(_, _, _layout) => bug!(\"Please use load_value_pair for ByValPair\"),\n@@ -294,9 +294,9 @@ impl<'tcx> CValue<'tcx> {\n     where\n         'tcx: 'a,\n     {\n-        let cton_ty = fx.cton_type(ty).unwrap();\n+        let clif_ty = fx.clif_type(ty).unwrap();\n         let layout = fx.layout_of(ty);\n-        CValue::ByVal(fx.bcx.ins().iconst(cton_ty, const_val), layout)\n+        CValue::ByVal(fx.bcx.ins().iconst(clif_ty, const_val), layout)\n     }\n \n     pub fn unchecked_cast_to(self, layout: TyLayout<'tcx>) -> Self {\n@@ -506,9 +506,9 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n                     let ptr =\n                         fx.bcx\n                             .ins()\n-                            .load(scalar_to_cton_type(fx.tcx, a), MemFlags::new(), addr, 0);\n+                            .load(scalar_to_clif_type(fx.tcx, a), MemFlags::new(), addr, 0);\n                     let extra = fx.bcx.ins().load(\n-                        scalar_to_cton_type(fx.tcx, b),\n+                        scalar_to_clif_type(fx.tcx, b),\n                         MemFlags::new(),\n                         addr,\n                         a.value.size(&fx.tcx).bytes() as u32 as i32,\n@@ -567,7 +567,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n     }\n }\n \n-pub fn cton_intcast<'a, 'tcx: 'a>(\n+pub fn clif_intcast<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     val: Value,\n     to: Type,\n@@ -664,8 +664,8 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n         )\n     }\n \n-    pub fn cton_type(&self, ty: Ty<'tcx>) -> Option<Type> {\n-        cton_type_from_ty(self.tcx, self.monomorphize(&ty))\n+    pub fn clif_type(&self, ty: Ty<'tcx>) -> Option<Type> {\n+        clif_type_from_ty(self.tcx, self.monomorphize(&ty))\n     }\n \n     pub fn get_ebb(&self, bb: BasicBlock) -> Ebb {"}, {"sha": "427ed7c1e5da65c6516dbd8b46e8e3397539835d", "filename": "src/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b5f4894f18a04042a652e4a25503f46aacfadb4/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b5f4894f18a04042a652e4a25503f46aacfadb4/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=7b5f4894f18a04042a652e4a25503f46aacfadb4", "patch": "@@ -59,7 +59,7 @@ macro_rules! intrinsic_match {\n \n macro_rules! atomic_binop_return_old {\n     ($fx:expr, $op:ident<$T:ident>($ptr:ident, $src:ident) -> $ret:ident) => {\n-        let clif_ty = $fx.cton_type($T).unwrap();\n+        let clif_ty = $fx.clif_type($T).unwrap();\n         let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n         let new = $fx.bcx.ins().band(old, $src);\n         $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n@@ -70,7 +70,7 @@ macro_rules! atomic_binop_return_old {\n macro_rules! atomic_minmax {\n     ($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $ret:ident) => {\n         // Read old\n-        let clif_ty = $fx.cton_type($T).unwrap();\n+        let clif_ty = $fx.clif_type($T).unwrap();\n         let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n \n         // Compare\n@@ -362,7 +362,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n         };\n         _ if intrinsic.starts_with(\"atomic_xchg\"), <T> (v ptr, c src) {\n             // Read old\n-            let clif_ty = fx.cton_type(T).unwrap();\n+            let clif_ty = fx.clif_type(T).unwrap();\n             let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n             ret.write_cvalue(fx, CValue::ByVal(old, fx.layout_of(T)));\n \n@@ -372,7 +372,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n         };\n         _ if intrinsic.starts_with(\"atomic_cxchg\"), <T> (v ptr, v test_old, v new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n             // Read old\n-            let clif_ty = fx.cton_type(T).unwrap();\n+            let clif_ty = fx.clif_type(T).unwrap();\n             let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n \n             // Compare"}]}