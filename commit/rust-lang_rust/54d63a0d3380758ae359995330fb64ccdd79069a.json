{"sha": "54d63a0d3380758ae359995330fb64ccdd79069a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZDYzYTBkMzM4MDc1OGFlMzU5OTk1MzMwZmI2NGNjZGQ3OTA2OWE=", "commit": {"author": {"name": "Christopher Vittal", "email": "christopher.vittal@gmail.com", "date": "2017-09-28T04:14:34Z"}, "committer": {"name": "Christopher Vittal", "email": "christopher.vittal@gmail.com", "date": "2017-10-05T03:45:09Z"}, "message": "Expand mir dump in order to handle NLL pass\n\nExtend `dump_mir` and functions it calls in order to allow callers to\nadd custom information. We do this by adding an enum `PassWhere` and\nan extra argument of type `FnMut(PassWhere, &mut Write) ->\nio::Result<()>`.  This callback is responsible for printing the extra\ninformation when MIR is dumped at various stages.\n\nFor the \"nll\" pass, use the new mechanism to dump the `Region`\ninformation after the header, but before the control flow graph for\nevery function.\n\nIn the interest of keeping the output somewhat concise, implement\na custom Debug impl for `Region`\n\nOpen Questions:\n\n    * What should we call what has been called `PassWhere` so far?", "tree": {"sha": "46e671e9c59c1c15af21c480711928fe3239dd8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46e671e9c59c1c15af21c480711928fe3239dd8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54d63a0d3380758ae359995330fb64ccdd79069a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54d63a0d3380758ae359995330fb64ccdd79069a", "html_url": "https://github.com/rust-lang/rust/commit/54d63a0d3380758ae359995330fb64ccdd79069a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54d63a0d3380758ae359995330fb64ccdd79069a/comments", "author": {"login": "chrisvittal", "id": 15916123, "node_id": "MDQ6VXNlcjE1OTE2MTIz", "avatar_url": "https://avatars.githubusercontent.com/u/15916123?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chrisvittal", "html_url": "https://github.com/chrisvittal", "followers_url": "https://api.github.com/users/chrisvittal/followers", "following_url": "https://api.github.com/users/chrisvittal/following{/other_user}", "gists_url": "https://api.github.com/users/chrisvittal/gists{/gist_id}", "starred_url": "https://api.github.com/users/chrisvittal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chrisvittal/subscriptions", "organizations_url": "https://api.github.com/users/chrisvittal/orgs", "repos_url": "https://api.github.com/users/chrisvittal/repos", "events_url": "https://api.github.com/users/chrisvittal/events{/privacy}", "received_events_url": "https://api.github.com/users/chrisvittal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chrisvittal", "id": 15916123, "node_id": "MDQ6VXNlcjE1OTE2MTIz", "avatar_url": "https://avatars.githubusercontent.com/u/15916123?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chrisvittal", "html_url": "https://github.com/chrisvittal", "followers_url": "https://api.github.com/users/chrisvittal/followers", "following_url": "https://api.github.com/users/chrisvittal/following{/other_user}", "gists_url": "https://api.github.com/users/chrisvittal/gists{/gist_id}", "starred_url": "https://api.github.com/users/chrisvittal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chrisvittal/subscriptions", "organizations_url": "https://api.github.com/users/chrisvittal/orgs", "repos_url": "https://api.github.com/users/chrisvittal/repos", "events_url": "https://api.github.com/users/chrisvittal/events{/privacy}", "received_events_url": "https://api.github.com/users/chrisvittal/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "271a492cb2028090c0198e893c18024c19bb6fc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/271a492cb2028090c0198e893c18024c19bb6fc7", "html_url": "https://github.com/rust-lang/rust/commit/271a492cb2028090c0198e893c18024c19bb6fc7"}], "stats": {"total": 151, "additions": 107, "deletions": 44}, "files": [{"sha": "b8bb2a404620e1a95d982c73b9ad0bbcc6bc1afe", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54d63a0d3380758ae359995330fb64ccdd79069a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54d63a0d3380758ae359995330fb64ccdd79069a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=54d63a0d3380758ae359995330fb64ccdd79069a", "patch": "@@ -149,7 +149,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             mem::transmute::<Mir, Mir<'tcx>>(mir)\n         };\n \n-        mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir);\n+        mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir, |_, _| Ok(()) );\n \n         mir\n     })\n@@ -227,7 +227,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 mem::transmute::<Mir, Mir<'tcx>>(mir)\n             };\n \n-            mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir);\n+            mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir, |_, _| Ok(()) );\n \n             mir\n         })"}, {"sha": "cea66837d9aaf9fe857ec0995935cede05b4bdd5", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/54d63a0d3380758ae359995330fb64ccdd79069a/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54d63a0d3380758ae359995330fb64ccdd79069a/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=54d63a0d3380758ae359995330fb64ccdd79069a", "patch": "@@ -65,7 +65,18 @@ impl PassHook for DumpMir {\n                                pass_name,\n                                &Disambiguator { is_after },\n                                source,\n-                               mir);\n+                               mir,\n+                               |_, _| Ok(()) );\n+            for (index, promoted_mir) in mir.promoted.iter_enumerated() {\n+                let promoted_source = MirSource::Promoted(source.item_id(), index);\n+                mir_util::dump_mir(tcx,\n+                                   Some((suite, pass_num)),\n+                                   pass_name,\n+                                   &Disambiguator { is_after },\n+                                   promoted_source,\n+                                   promoted_mir,\n+                                   |_, _| Ok(()) );\n+            }\n         }\n     }\n }"}, {"sha": "7d0814b67fba5b1e216d236b62a75466c0e792af", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54d63a0d3380758ae359995330fb64ccdd79069a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54d63a0d3380758ae359995330fb64ccdd79069a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=54d63a0d3380758ae359995330fb64ccdd79069a", "patch": "@@ -587,7 +587,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     // unrelated code from the resume part of the function\n     simplify::remove_dead_blocks(&mut mir);\n \n-    dump_mir(tcx, None, \"generator_drop\", &0, source, &mut mir);\n+    dump_mir(tcx, None, \"generator_drop\", &0, source, &mut mir, |_, _| Ok(()) );\n \n     mir\n }\n@@ -673,7 +673,7 @@ fn create_generator_resume_function<'a, 'tcx>(\n     // unrelated code from the drop part of the function\n     simplify::remove_dead_blocks(mir);\n \n-    dump_mir(tcx, None, \"generator_resume\", &0, source, mir);\n+    dump_mir(tcx, None, \"generator_resume\", &0, source, mir, |_, _| Ok(()) );\n }\n \n fn source_info<'a, 'tcx>(mir: &Mir<'tcx>) -> SourceInfo {\n@@ -816,14 +816,14 @@ impl MirPass for StateTransform {\n         // This is expanded to a drop ladder in `elaborate_generator_drops`.\n         let drop_clean = insert_clean_drop(mir);\n \n-        dump_mir(tcx, None, \"generator_pre-elab\", &0, source, mir);\n+        dump_mir(tcx, None, \"generator_pre-elab\", &0, source, mir, |_, _| Ok(()) );\n \n         // Expand `drop(generator_struct)` to a drop ladder which destroys upvars.\n         // If any upvars are moved out of, drop elaboration will handle upvar destruction.\n         // However we need to also elaborate the code generated by `insert_clean_drop`.\n         elaborate_generator_drops(tcx, def_id, mir);\n \n-        dump_mir(tcx, None, \"generator_post-transform\", &0, source, mir);\n+        dump_mir(tcx, None, \"generator_post-transform\", &0, source, mir, |_, _| Ok(()) );\n \n         // Create a copy of our MIR and use it to create the drop shim for the generator\n         let drop_shim = create_generator_drop_shim(tcx,"}, {"sha": "4925b1fcfed28ddf7ff2bfea0304d2bfd54587a6", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/54d63a0d3380758ae359995330fb64ccdd79069a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54d63a0d3380758ae359995330fb64ccdd79069a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=54d63a0d3380758ae359995330fb64ccdd79069a", "patch": "@@ -19,6 +19,10 @@ use rustc::util::nodemap::FxHashSet;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use syntax_pos::DUMMY_SP;\n use std::collections::HashMap;\n+use std::fmt;\n+\n+use util as mir_util;\n+use self::mir_util::PassWhere;\n \n #[allow(dead_code)]\n struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n@@ -134,7 +138,7 @@ pub struct NLL;\n impl MirPass for NLL {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _: MirSource,\n+                          source: MirSource,\n                           mir: &mut Mir<'tcx>) {\n         if !tcx.sess.opts.debugging_opts.nll {\n             return;\n@@ -145,14 +149,30 @@ impl MirPass for NLL {\n             let mut renumbered_mir = mir.clone();\n             let mut visitor = NLLVisitor::new(infcx);\n             visitor.visit_mir(&mut renumbered_mir);\n+            mir_util::dump_mir(tcx, None, \"nll\", &0, source, mir, |pass_where, out| {\n+                if let PassWhere::BeforeCFG = pass_where {\n+                    for (index, value) in visitor.regions.iter_enumerated() {\n+                        writeln!(out, \"// R{:03}: {:?}\", index.0, value)?;\n+                    }\n+                }\n+                Ok(())\n+            });\n             let _results = visitor.into_results();\n         })\n     }\n }\n \n-#[derive(Clone, Debug, Default, PartialEq, Eq)]\n+#[derive(Clone, Default, PartialEq, Eq)]\n struct Region {\n     points: FxHashSet<Location>,\n }\n \n+impl fmt::Debug for Region {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(formatter, \"{:?}\", self.points)\n+    }\n+}\n+\n+\n+\n newtype_index!(RegionIndex);"}, {"sha": "1424c063d73854c43b35102e81af7d14db80d478", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54d63a0d3380758ae359995330fb64ccdd79069a/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54d63a0d3380758ae359995330fb64ccdd79069a/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=54d63a0d3380758ae359995330fb64ccdd79069a", "patch": "@@ -232,7 +232,7 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             writeln!(w, \"{} {{{}}}\", prefix, live.join(\", \"))\n         };\n         print(w, \"   \", &result.ins)?;\n-        write_basic_block(tcx, block, mir, w)?;\n+        write_basic_block(tcx, block, mir, &mut |_, _| Ok(()), w)?;\n         print(w, \"   \", &result.outs)?;\n         if block.index() + 1 != mir.basic_blocks().len() {\n             writeln!(w, \"\")?;"}, {"sha": "13c14f8920f4ec600fd2a4e4c6768ba5c36438fa", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54d63a0d3380758ae359995330fb64ccdd79069a/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54d63a0d3380758ae359995330fb64ccdd79069a/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=54d63a0d3380758ae359995330fb64ccdd79069a", "patch": "@@ -17,6 +17,6 @@ mod graphviz;\n mod pretty;\n pub mod liveness;\n \n-pub use self::pretty::{dump_enabled, dump_mir, write_mir_pretty};\n+pub use self::pretty::{dump_enabled, dump_mir, write_mir_pretty, PassWhere};\n pub use self::graphviz::{write_mir_graphviz};\n pub use self::graphviz::write_node_label as write_graphviz_node_label;"}, {"sha": "8a9047fb4911c66a598dbec20daa0ffd3727f417", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 65, "deletions": 33, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/54d63a0d3380758ae359995330fb64ccdd79069a/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54d63a0d3380758ae359995330fb64ccdd79069a/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=54d63a0d3380758ae359995330fb64ccdd79069a", "patch": "@@ -25,6 +25,22 @@ const INDENT: &'static str = \"    \";\n /// Alignment for lining up comments following MIR statements\n const ALIGN: usize = 40;\n \n+/// An indication of where we are in the control flow graph. Used for printing\n+/// extra information in `dump_mir`\n+pub enum PassWhere {\n+    /// We have not started dumping the control flow graph, but we are about to.\n+    BeforeCFG,\n+\n+    /// We just finished dumping the control flow graph. This is right before EOF\n+    AfterCFG,\n+\n+    /// We are about to start dumping the given basic block.\n+    BeforeBlock(BasicBlock),\n+\n+    /// We are just about to dumpt the given statement or terminator.\n+    InCFG(Location),\n+}\n+\n /// If the session is properly configured, dumps a human-readable\n /// representation of the mir into:\n ///\n@@ -39,12 +55,16 @@ const ALIGN: usize = 40;\n /// - `substring1&substring2,...` -- `&`-separated list of substrings\n ///   that can appear in the pass-name or the `item_path_str` for the given\n ///   node-id. If any one of the substrings match, the data is dumped out.\n-pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          pass_num: Option<(MirSuite, MirPassIndex)>,\n-                          pass_name: &str,\n-                          disambiguator: &Display,\n-                          source: MirSource,\n-                          mir: &Mir<'tcx>) {\n+pub fn dump_mir<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             pass_num: Option<(MirSuite, MirPassIndex)>,\n+                             pass_name: &str,\n+                             disambiguator: &Display,\n+                             source: MirSource,\n+                             mir: &Mir<'tcx>,\n+                             extra_data: F)\n+where\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+{\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n     }\n@@ -53,12 +73,7 @@ pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx.item_path_str(tcx.hir.local_def_id(source.item_id()))\n     });\n     dump_matched_mir_node(tcx, pass_num, pass_name, &node_path,\n-                          disambiguator, source, mir);\n-    for (index, promoted_mir) in mir.promoted.iter_enumerated() {\n-        let promoted_source = MirSource::Promoted(source.item_id(), index);\n-        dump_matched_mir_node(tcx, pass_num, pass_name, &node_path, disambiguator,\n-                              promoted_source, promoted_mir);\n-    }\n+                          disambiguator, source, mir, extra_data);\n }\n \n pub fn dump_enabled<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -85,13 +100,17 @@ pub fn dump_enabled<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // `item_path_str()` would otherwise trigger `type_of`, and this can\n // run while we are already attempting to evaluate `type_of`.\n \n-fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   pass_num: Option<(MirSuite, MirPassIndex)>,\n-                                   pass_name: &str,\n-                                   node_path: &str,\n-                                   disambiguator: &Display,\n-                                   source: MirSource,\n-                                   mir: &Mir<'tcx>) {\n+fn dump_matched_mir_node<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      pass_num: Option<(MirSuite, MirPassIndex)>,\n+                                      pass_name: &str,\n+                                      node_path: &str,\n+                                      disambiguator: &Display,\n+                                      source: MirSource,\n+                                      mir: &Mir<'tcx>,\n+                                      mut extra_data: F)\n+where\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+{\n     let promotion_id = match source {\n         MirSource::Promoted(_, id) => format!(\"-{:?}\", id),\n         MirSource::GeneratorDrop(_) => format!(\"-drop\"),\n@@ -125,7 +144,9 @@ fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             writeln!(file, \"// generator_layout = {:?}\", layout)?;\n         }\n         writeln!(file, \"\")?;\n-        write_mir_fn(tcx, source, mir, &mut file)?;\n+        extra_data(PassWhere::BeforeCFG, &mut file)?;\n+        write_mir_fn(tcx, source, mir, &mut extra_data, &mut file)?;\n+        extra_data(PassWhere::AfterCFG, &mut file)?;\n         Ok(())\n     });\n }\n@@ -152,24 +173,29 @@ pub fn write_mir_pretty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         let id = tcx.hir.as_local_node_id(def_id).unwrap();\n         let src = MirSource::from_node(tcx, id);\n-        write_mir_fn(tcx, src, mir, w)?;\n+        write_mir_fn(tcx, src, mir, &mut |_, _| Ok(()), w)?;\n \n         for (i, mir) in mir.promoted.iter_enumerated() {\n             writeln!(w, \"\")?;\n-            write_mir_fn(tcx, MirSource::Promoted(id, i), mir, w)?;\n+            write_mir_fn(tcx, MirSource::Promoted(id, i), mir, &mut |_, _| Ok(()), w)?;\n         }\n     }\n     Ok(())\n }\n \n-pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              src: MirSource,\n-                              mir: &Mir<'tcx>,\n-                              w: &mut Write)\n-                              -> io::Result<()> {\n+pub fn write_mir_fn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 src: MirSource,\n+                                 mir: &Mir<'tcx>,\n+                                 extra_data: &mut F,\n+                                 w: &mut Write)\n+                                 -> io::Result<()>\n+where\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+{\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n-        write_basic_block(tcx, block, mir, w)?;\n+        extra_data(PassWhere::BeforeBlock(block), w)?;\n+        write_basic_block(tcx, block, mir, extra_data, w)?;\n         if block.index() + 1 != mir.basic_blocks().len() {\n             writeln!(w, \"\")?;\n         }\n@@ -180,11 +206,15 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n /// Write out a human-readable textual representation for the given basic block.\n-pub fn write_basic_block(tcx: TyCtxt,\n-                     block: BasicBlock,\n-                     mir: &Mir,\n-                     w: &mut Write)\n-                     -> io::Result<()> {\n+pub fn write_basic_block<F>(tcx: TyCtxt,\n+                            block: BasicBlock,\n+                            mir: &Mir,\n+                            extra_data: &mut F,\n+                            w: &mut Write)\n+                            -> io::Result<()>\n+where\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+{\n     let data = &mir[block];\n \n     // Basic block label at the top.\n@@ -195,6 +225,7 @@ pub fn write_basic_block(tcx: TyCtxt,\n     // List of statements in the middle.\n     let mut current_location = Location { block: block, statement_index: 0 };\n     for statement in &data.statements {\n+        extra_data(PassWhere::InCFG(current_location), w)?;\n         let indented_mir = format!(\"{0}{0}{1:?};\", INDENT, statement);\n         writeln!(w, \"{0:1$} // {2}\",\n                  indented_mir,\n@@ -205,6 +236,7 @@ pub fn write_basic_block(tcx: TyCtxt,\n     }\n \n     // Terminator at the bottom.\n+    extra_data(PassWhere::InCFG(current_location), w)?;\n     let indented_terminator = format!(\"{0}{0}{1:?};\", INDENT, data.terminator().kind);\n     writeln!(w, \"{0:1$} // {2}\",\n              indented_terminator,"}]}