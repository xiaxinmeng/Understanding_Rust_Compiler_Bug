{"sha": "6295bbe6ec9741538307cd619ada1c9566f99a5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyOTViYmU2ZWM5NzQxNTM4MzA3Y2Q2MTlhZGExYzk1NjZmOTlhNWQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-04T04:36:40Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-04T04:36:40Z"}, "message": "Merge #391\n\n391: docing parser methods r=csmoe a=csmoe\n\n\n\nCo-authored-by: csmoe <csmoe@msn.com>", "tree": {"sha": "9a004a531fce65c4a01e2d243dff638fb76ae373", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a004a531fce65c4a01e2d243dff638fb76ae373"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6295bbe6ec9741538307cd619ada1c9566f99a5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6295bbe6ec9741538307cd619ada1c9566f99a5d", "html_url": "https://github.com/rust-lang/rust/commit/6295bbe6ec9741538307cd619ada1c9566f99a5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6295bbe6ec9741538307cd619ada1c9566f99a5d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "2fcc6bdafa1caffd4ddf98968ee967e9fb091cc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fcc6bdafa1caffd4ddf98968ee967e9fb091cc0", "html_url": "https://github.com/rust-lang/rust/commit/2fcc6bdafa1caffd4ddf98968ee967e9fb091cc0"}, {"sha": "58139c558aa085588264ba659b8483a036c1da0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/58139c558aa085588264ba659b8483a036c1da0e", "html_url": "https://github.com/rust-lang/rust/commit/58139c558aa085588264ba659b8483a036c1da0e"}], "stats": {"total": 176, "additions": 117, "deletions": 59}, "files": [{"sha": "3487aef850894b4af17721b55c5fcdb5d7051f49", "filename": "crates/ra_syntax/src/parser_api.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6295bbe6ec9741538307cd619ada1c9566f99a5d/crates%2Fra_syntax%2Fsrc%2Fparser_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6295bbe6ec9741538307cd619ada1c9566f99a5d/crates%2Fra_syntax%2Fsrc%2Fparser_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_api.rs?ref=6295bbe6ec9741538307cd619ada1c9566f99a5d", "patch": "@@ -61,7 +61,7 @@ impl<'t> Parser<'t> {\n         Marker::new(self.0.start())\n     }\n \n-    /// Advances the parser by one token.\n+    /// Advances the parser by one token unconditionally.\n     pub(crate) fn bump(&mut self) {\n         self.0.bump();\n     }\n@@ -91,7 +91,7 @@ impl<'t> Parser<'t> {\n         self.0.error(message.into())\n     }\n \n-    /// Consume the next token if it is `kind`.\n+    /// Consume the next token if `kind` matches.\n     pub(crate) fn eat(&mut self, kind: SyntaxKind) -> bool {\n         if !self.at(kind) {\n             return false;\n@@ -142,11 +142,13 @@ impl Marker {\n         }\n     }\n \n-    /// Finishes the syntax tree node and assigns `kind` to it.\n+    /// Finishes the syntax tree node and assigns `kind` to it,\n+    /// and mark the create a `CompletedMarker` for possible future\n+    /// operation like `.precede()` to deal with forward_parent.\n     pub(crate) fn complete(mut self, p: &mut Parser, kind: SyntaxKind) -> CompletedMarker {\n         self.bomb.defuse();\n         p.0.complete(self.pos, kind);\n-        CompletedMarker(self.pos, kind)\n+        CompletedMarker::new(self.pos, kind)\n     }\n \n     /// Abandons the syntax tree node. All its children\n@@ -160,13 +162,22 @@ impl Marker {\n pub(crate) struct CompletedMarker(u32, SyntaxKind);\n \n impl CompletedMarker {\n-    /// This one is tricky :-)\n+    fn new(pos: u32, kind: SyntaxKind) -> Self {\n+        CompletedMarker(pos, kind)\n+    }\n+\n     /// This method allows to create a new node which starts\n     /// *before* the current one. That is, parser could start\n     /// node `A`, then complete it, and then after parsing the\n     /// whole `A`, decide that it should have started some node\n     /// `B` before starting `A`. `precede` allows to do exactly\n     /// that. See also docs about `forward_parent` in `Event::Start`.\n+    ///\n+    /// Given completed events `[START, FINISH]` and its corresponding\n+    /// `CompletedMarker(pos: 0, _)`.\n+    /// Append a new `START` events as `[START, FINISH, NEWSTART]`,\n+    /// then mark `NEWSTART` as `START`'s parent with saving its relative\n+    /// distance to `NEWSTART` into forward_parent(=2 in this case);\n     pub(crate) fn precede(self, p: &mut Parser) -> Marker {\n         Marker::new(p.0.precede(self.0))\n     }"}, {"sha": "01a51cd8d6d24bec1c0ff064d850d054d02e1ffb", "filename": "crates/ra_syntax/src/parser_impl.rs", "status": "modified", "additions": 43, "deletions": 28, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6295bbe6ec9741538307cd619ada1c9566f99a5d/crates%2Fra_syntax%2Fsrc%2Fparser_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6295bbe6ec9741538307cd619ada1c9566f99a5d/crates%2Fra_syntax%2Fsrc%2Fparser_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_impl.rs?ref=6295bbe6ec9741538307cd619ada1c9566f99a5d", "patch": "@@ -22,10 +22,21 @@ use crate::SyntaxKind::{self, EOF, TOMBSTONE};\n pub(crate) trait Sink {\n     type Tree;\n \n+    /// Adds new leaf to the current branch.\n     fn leaf(&mut self, kind: SyntaxKind, text: SmolStr);\n-    fn start_internal(&mut self, kind: SyntaxKind);\n-    fn finish_internal(&mut self);\n+\n+    /// Start new branch and make it current.\n+    fn start_branch(&mut self, kind: SyntaxKind);\n+\n+    /// Finish current branch and restore previous\n+    /// branch as current.\n+    fn finish_branch(&mut self);\n+\n     fn error(&mut self, error: SyntaxError);\n+\n+    /// Complete tree building. Make sure that\n+    /// `start_branch` and `finish_branch` calls\n+    /// are paired!\n     fn finish(self) -> Self::Tree;\n }\n \n@@ -52,8 +63,7 @@ pub(crate) fn parse_with<S: Sink>(\n /// to a separate struct in order not to pollute\n /// the public API of the `Parser`.\n pub(crate) struct ParserImpl<'t> {\n-    inp: &'t ParserInput<'t>,\n-\n+    parser_input: &'t ParserInput<'t>,\n     pos: InputPosition,\n     events: Vec<Event>,\n     steps: Cell<u32>,\n@@ -62,8 +72,7 @@ pub(crate) struct ParserImpl<'t> {\n impl<'t> ParserImpl<'t> {\n     pub(crate) fn new(inp: &'t ParserInput<'t>) -> ParserImpl<'t> {\n         ParserImpl {\n-            inp,\n-\n+            parser_input: inp,\n             pos: InputPosition::new(),\n             events: Vec::new(),\n             steps: Cell::new(0),\n@@ -76,52 +85,54 @@ impl<'t> ParserImpl<'t> {\n     }\n \n     pub(super) fn next2(&self) -> Option<(SyntaxKind, SyntaxKind)> {\n-        let c1 = self.inp.kind(self.pos);\n-        let c2 = self.inp.kind(self.pos + 1);\n-        if self.inp.start(self.pos + 1) == self.inp.start(self.pos) + self.inp.len(self.pos) {\n+        let c1 = self.parser_input.kind(self.pos);\n+        let c2 = self.parser_input.kind(self.pos + 1);\n+        if self.parser_input.token_start_at(self.pos + 1)\n+            == self.parser_input.token_start_at(self.pos) + self.parser_input.token_len(self.pos)\n+        {\n             Some((c1, c2))\n         } else {\n             None\n         }\n     }\n \n     pub(super) fn next3(&self) -> Option<(SyntaxKind, SyntaxKind, SyntaxKind)> {\n-        let c1 = self.inp.kind(self.pos);\n-        let c2 = self.inp.kind(self.pos + 1);\n-        let c3 = self.inp.kind(self.pos + 2);\n-        if self.inp.start(self.pos + 1) == self.inp.start(self.pos) + self.inp.len(self.pos)\n-            && self.inp.start(self.pos + 2)\n-                == self.inp.start(self.pos + 1) + self.inp.len(self.pos + 1)\n+        let c1 = self.parser_input.kind(self.pos);\n+        let c2 = self.parser_input.kind(self.pos + 1);\n+        let c3 = self.parser_input.kind(self.pos + 2);\n+        if self.parser_input.token_start_at(self.pos + 1)\n+            == self.parser_input.token_start_at(self.pos) + self.parser_input.token_len(self.pos)\n+            && self.parser_input.token_start_at(self.pos + 2)\n+                == self.parser_input.token_start_at(self.pos + 1)\n+                    + self.parser_input.token_len(self.pos + 1)\n         {\n             Some((c1, c2, c3))\n         } else {\n             None\n         }\n     }\n \n+    /// Get the syntax kind of the nth token.\n     pub(super) fn nth(&self, n: u32) -> SyntaxKind {\n         let steps = self.steps.get();\n-        if steps > 10_000_000 {\n-            panic!(\"the parser seems stuck\");\n-        }\n+        assert!(steps <= 10_000_000, \"the parser seems stuck\");\n         self.steps.set(steps + 1);\n \n-        self.inp.kind(self.pos + n)\n+        self.parser_input.kind(self.pos + n)\n     }\n \n     pub(super) fn at_kw(&self, t: &str) -> bool {\n-        self.inp.text(self.pos) == t\n+        self.parser_input.token_text(self.pos) == t\n     }\n \n+    /// Start parsing right behind the last event.\n     pub(super) fn start(&mut self) -> u32 {\n         let pos = self.events.len() as u32;\n-        self.event(Event::Start {\n-            kind: TOMBSTONE,\n-            forward_parent: None,\n-        });\n+        self.push_event(Event::tombstone());\n         pos\n     }\n \n+    /// Advances the parser by one token unconditionally.\n     pub(super) fn bump(&mut self) {\n         let kind = self.nth(0);\n         if kind == EOF {\n@@ -144,15 +155,17 @@ impl<'t> ParserImpl<'t> {\n \n     fn do_bump(&mut self, kind: SyntaxKind, n_raw_tokens: u8) {\n         self.pos += u32::from(n_raw_tokens);\n-        self.event(Event::Token { kind, n_raw_tokens });\n+        self.push_event(Event::Token { kind, n_raw_tokens });\n     }\n \n+    /// Append one Error event to the back of events.\n     pub(super) fn error(&mut self, msg: String) {\n-        self.event(Event::Error {\n+        self.push_event(Event::Error {\n             msg: ParseError(msg),\n         })\n     }\n \n+    /// Complete an event with appending a `Finish` event.\n     pub(super) fn complete(&mut self, pos: u32, kind: SyntaxKind) {\n         match self.events[pos as usize] {\n             Event::Start {\n@@ -162,9 +175,10 @@ impl<'t> ParserImpl<'t> {\n             }\n             _ => unreachable!(),\n         }\n-        self.event(Event::Finish);\n+        self.push_event(Event::Finish);\n     }\n \n+    /// Ignore the dummy `Start` event.\n     pub(super) fn abandon(&mut self, pos: u32) {\n         let idx = pos as usize;\n         if idx == self.events.len() - 1 {\n@@ -178,6 +192,7 @@ impl<'t> ParserImpl<'t> {\n         }\n     }\n \n+    /// Save the relative distance of a completed event to its forward_parent.\n     pub(super) fn precede(&mut self, pos: u32) -> u32 {\n         let new_pos = self.start();\n         match self.events[pos as usize] {\n@@ -192,7 +207,7 @@ impl<'t> ParserImpl<'t> {\n         new_pos\n     }\n \n-    fn event(&mut self, event: Event) {\n+    fn push_event(&mut self, event: Event) {\n         self.events.push(event)\n     }\n }"}, {"sha": "73dd6e02b14ff0ceda4036644b983e78f948a9aa", "filename": "crates/ra_syntax/src/parser_impl/event.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6295bbe6ec9741538307cd619ada1c9566f99a5d/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6295bbe6ec9741538307cd619ada1c9566f99a5d/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fevent.rs?ref=6295bbe6ec9741538307cd619ada1c9566f99a5d", "patch": "@@ -36,7 +36,7 @@ pub(crate) enum Event {\n     ///\n     /// For left-recursive syntactic constructs, the parser produces\n     /// a child node before it sees a parent. `forward_parent`\n-    /// exists to allow to tweak parent-child relationships.\n+    /// saves the position of current event's parent.\n     ///\n     /// Consider this path\n     ///\n@@ -84,6 +84,15 @@ pub(crate) enum Event {\n     },\n }\n \n+impl Event {\n+    pub(crate) fn tombstone() -> Self {\n+        Event::Start {\n+            kind: TOMBSTONE,\n+            forward_parent: None,\n+        }\n+    }\n+}\n+\n pub(super) struct EventProcessor<'a, S: Sink> {\n     sink: S,\n     text_pos: TextUnit,\n@@ -110,17 +119,12 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n         }\n     }\n \n+    /// Generate the syntax tree with the control of events.\n     pub(super) fn process(mut self) -> S {\n-        fn tombstone() -> Event {\n-            Event::Start {\n-                kind: TOMBSTONE,\n-                forward_parent: None,\n-            }\n-        }\n         let mut forward_parents = Vec::new();\n \n         for i in 0..self.events.len() {\n-            match mem::replace(&mut self.events[i], tombstone()) {\n+            match mem::replace(&mut self.events[i], Event::tombstone()) {\n                 Event::Start {\n                     kind: TOMBSTONE, ..\n                 } => (),\n@@ -129,12 +133,18 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n                     kind,\n                     forward_parent,\n                 } => {\n+                    // For events[A, B, C], B is A's forward_parent, C is B's forward_parent,\n+                    // in the normal control flow, the parent-child relation: `A -> B -> C`,\n+                    // while with the magic forward_parent, it writes: `C <- B <- A`.\n+\n+                    // append `A` into parents.\n                     forward_parents.push(kind);\n                     let mut idx = i;\n                     let mut fp = forward_parent;\n                     while let Some(fwd) = fp {\n                         idx += fwd as usize;\n-                        fp = match mem::replace(&mut self.events[idx], tombstone()) {\n+                        // append `A`'s forward_parent `B`\n+                        fp = match mem::replace(&mut self.events[idx], Event::tombstone()) {\n                             Event::Start {\n                                 kind,\n                                 forward_parent,\n@@ -144,17 +154,19 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n                             }\n                             _ => unreachable!(),\n                         };\n+                        // append `B`'s forward_parent `C` in the next stage.\n                     }\n+\n                     for kind in forward_parents.drain(..).rev() {\n                         self.start(kind);\n                     }\n                 }\n                 Event::Finish => {\n-                    let last = i == self.events.len() - 1;\n-                    self.finish(last);\n+                    let is_last = i == self.events.len() - 1;\n+                    self.finish(is_last);\n                 }\n                 Event::Token { kind, n_raw_tokens } => {\n-                    self.eat_ws();\n+                    self.eat_trivias();\n                     let n_raw_tokens = n_raw_tokens as usize;\n                     let len = self.tokens[self.token_pos..self.token_pos + n_raw_tokens]\n                         .iter()\n@@ -171,9 +183,10 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n         self.sink\n     }\n \n+    /// Add the node into syntax tree but discard the comments/whitespaces.\n     fn start(&mut self, kind: SyntaxKind) {\n         if kind == SOURCE_FILE {\n-            self.sink.start_internal(kind);\n+            self.sink.start_branch(kind);\n             return;\n         }\n         let n_trivias = self.tokens[self.token_pos..]\n@@ -194,18 +207,18 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n             n_attached_trivias(kind, leading_trivias)\n         };\n         self.eat_n_trivias(n_trivias - n_attached_trivias);\n-        self.sink.start_internal(kind);\n+        self.sink.start_branch(kind);\n         self.eat_n_trivias(n_attached_trivias);\n     }\n \n-    fn finish(&mut self, last: bool) {\n-        if last {\n-            self.eat_ws()\n+    fn finish(&mut self, is_last: bool) {\n+        if is_last {\n+            self.eat_trivias()\n         }\n-        self.sink.finish_internal();\n+        self.sink.finish_branch();\n     }\n \n-    fn eat_ws(&mut self) {\n+    fn eat_trivias(&mut self) {\n         while let Some(&token) = self.tokens.get(self.token_pos) {\n             if !token.kind.is_trivia() {\n                 break;\n@@ -236,7 +249,7 @@ fn n_attached_trivias<'a>(\n     trivias: impl Iterator<Item = (SyntaxKind, &'a str)>,\n ) -> usize {\n     match kind {\n-        STRUCT_DEF | ENUM_DEF | FN_DEF | TRAIT_DEF | MODULE => {\n+        CONST_DEF | TYPE_DEF | STRUCT_DEF | ENUM_DEF | FN_DEF | TRAIT_DEF | MODULE => {\n             let mut res = 0;\n             for (i, (kind, text)) in trivias.enumerate() {\n                 match kind {"}, {"sha": "7fde5b3ab19b1734d1f60aea367827510000a00a", "filename": "crates/ra_syntax/src/parser_impl/input.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6295bbe6ec9741538307cd619ada1c9566f99a5d/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6295bbe6ec9741538307cd619ada1c9566f99a5d/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Finput.rs?ref=6295bbe6ec9741538307cd619ada1c9566f99a5d", "patch": "@@ -4,11 +4,26 @@ use std::ops::{Add, AddAssign};\n \n pub(crate) struct ParserInput<'t> {\n     text: &'t str,\n+    /// start position of each token(expect whitespace and comment)\n+    /// ```non-rust\n+    ///  struct Foo;\n+    /// ^------^---\n+    /// |      |  ^-\n+    /// 0      7  10\n+    /// ```\n+    /// (token, start_offset): `[(struct, 0), (Foo, 7), (;, 10)]`\n     start_offsets: Vec<TextUnit>,\n-    tokens: Vec<Token>, // non-whitespace tokens\n+    /// non-whitespace/comment tokens\n+    /// ```non-rust\n+    /// struct Foo {}\n+    /// ^^^^^^ ^^^ ^^\n+    /// ```\n+    /// tokens: `[struct, Foo, {, }]`\n+    tokens: Vec<Token>,\n }\n \n impl<'t> ParserInput<'t> {\n+    /// Generate input from tokens(expect comment and whitespace).\n     pub fn new(text: &'t str, raw_tokens: &'t [Token]) -> ParserInput<'t> {\n         let mut tokens = Vec::new();\n         let mut start_offsets = Vec::new();\n@@ -28,6 +43,7 @@ impl<'t> ParserInput<'t> {\n         }\n     }\n \n+    /// Get the syntax kind of token at given input position.\n     pub fn kind(&self, pos: InputPosition) -> SyntaxKind {\n         let idx = pos.0 as usize;\n         if !(idx < self.tokens.len()) {\n@@ -36,23 +52,26 @@ impl<'t> ParserInput<'t> {\n         self.tokens[idx].kind\n     }\n \n-    pub fn len(&self, pos: InputPosition) -> TextUnit {\n+    /// Get the length of a token at given input position.\n+    pub fn token_len(&self, pos: InputPosition) -> TextUnit {\n         let idx = pos.0 as usize;\n         if !(idx < self.tokens.len()) {\n             return 0.into();\n         }\n         self.tokens[idx].len\n     }\n \n-    pub fn start(&self, pos: InputPosition) -> TextUnit {\n+    /// Get the start position of a taken at given input position.\n+    pub fn token_start_at(&self, pos: InputPosition) -> TextUnit {\n         let idx = pos.0 as usize;\n         if !(idx < self.tokens.len()) {\n             return 0.into();\n         }\n         self.start_offsets[idx]\n     }\n \n-    pub fn text(&self, pos: InputPosition) -> &'t str {\n+    /// Get the raw text of a token at given input position.\n+    pub fn token_text(&self, pos: InputPosition) -> &'t str {\n         let idx = pos.0 as usize;\n         if !(idx < self.tokens.len()) {\n             return \"\";"}, {"sha": "37ae6329b26c4ecaeffe10cb28e4851085906ed4", "filename": "crates/ra_syntax/src/yellow/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6295bbe6ec9741538307cd619ada1c9566f99a5d/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6295bbe6ec9741538307cd619ada1c9566f99a5d/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fbuilder.rs?ref=6295bbe6ec9741538307cd619ada1c9566f99a5d", "patch": "@@ -26,11 +26,11 @@ impl Sink for GreenBuilder {\n         self.inner.leaf(kind, text);\n     }\n \n-    fn start_internal(&mut self, kind: SyntaxKind) {\n+    fn start_branch(&mut self, kind: SyntaxKind) {\n         self.inner.start_internal(kind)\n     }\n \n-    fn finish_internal(&mut self) {\n+    fn finish_branch(&mut self) {\n         self.inner.finish_internal();\n     }\n "}]}