{"sha": "c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "node_id": "C_kwDOAAsO6NoAKGMwOTQxZGZiNWE3ZDA3ZWYyZDcwY2M1NGQzMTk2NjlkOWQ2ZjZjMDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-21T19:05:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-21T19:05:18Z"}, "message": "Auto merge of #100847 - matthiaskrgr:rollup-0ga531s, r=matthiaskrgr\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #100556 (Clamp Function for f32 and f64)\n - #100663 (Make slice::reverse const)\n - #100697 ( Minor syntax and formatting update to doc comment on `find_vtable_types_for_unsizing`)\n - #100760 (update test for LLVM change)\n - #100761 (some general mir typeck cleanup)\n - #100775 (rustdoc: Merge source code pages HTML elements together v2)\n - #100813 (Add `/build-rust-analyzer/` to .gitignore)\n - #100821 (Make some docs nicer wrt pointer offsets)\n - #100822 (Replace most uses of `pointer::offset` with `add` and `sub`)\n - #100839 (Make doc for stdin field of process consistent)\n - #100842 (Add diagnostics lints to `rustc_transmute` module (zero diags))\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "37525d0391e25a800121ccc4dcaf7b29d50fb86f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37525d0391e25a800121ccc4dcaf7b29d50fb86f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "html_url": "https://github.com/rust-lang/rust/commit/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "650bff80a623e17675ac72ae4d62ed200a4a3568", "url": "https://api.github.com/repos/rust-lang/rust/commits/650bff80a623e17675ac72ae4d62ed200a4a3568", "html_url": "https://github.com/rust-lang/rust/commit/650bff80a623e17675ac72ae4d62ed200a4a3568"}, {"sha": "5ba68df9884274ab3f8793effda72c2b62990804", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ba68df9884274ab3f8793effda72c2b62990804", "html_url": "https://github.com/rust-lang/rust/commit/5ba68df9884274ab3f8793effda72c2b62990804"}], "stats": {"total": 650, "additions": 350, "deletions": 300}, "files": [{"sha": "b16fb6341c2e50a2f37f04e563017a588365a4d7", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -42,6 +42,7 @@ no_llvm_build\n /llvm/\n /mingw-build/\n /build/\n+/build-rust-analyzer/\n /dist/\n /unicode-downloads\n /target"}, {"sha": "d2f8ef8eaae7dbc3904c4cd8cb03fa2df4195a4e", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -219,7 +219,7 @@ impl<T> TypedArena<T> {\n             } else {\n                 let ptr = self.ptr.get();\n                 // Advance the pointer.\n-                self.ptr.set(self.ptr.get().offset(1));\n+                self.ptr.set(self.ptr.get().add(1));\n                 // Write into uninitialized memory.\n                 ptr::write(ptr, object);\n                 &mut *ptr"}, {"sha": "451b82c5c18700f07f1967ab571f604ebc9cf584", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -90,12 +90,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n     ) {\n-        self.prove_predicates(\n-            Some(ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n+        self.prove_predicate(\n+            ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n                 trait_ref,\n                 constness: ty::BoundConstness::NotConst,\n                 polarity: ty::ImplPolarity::Positive,\n-            }))),\n+            }))\n+            .to_predicate(self.tcx()),\n             locations,\n             category,\n         );"}, {"sha": "bb28622edf931b98b00bdeb27db1aab5d4a6e1c8", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -268,7 +268,7 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                 // }\n                 // impl Foo for () {\n                 //   type Bar = ();\n-                //   fn foo(&self) ->&() {}\n+                //   fn foo(&self) -> &() {}\n                 // }\n                 // ```\n                 // Both &Self::Bar and &() are WF"}, {"sha": "293d847ec9ab7aafdc3be14fae88a2b6c286ee01", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 53, "deletions": 86, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -178,97 +178,15 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         upvars,\n     };\n \n-    let opaque_type_values = type_check_internal(\n+    let mut checker = TypeChecker::new(\n         infcx,\n-        param_env,\n         body,\n-        promoted,\n+        param_env,\n         &region_bound_pairs,\n         implicit_region_bound,\n         &mut borrowck_context,\n-        |mut cx| {\n-            debug!(\"inside extra closure of type_check_internal\");\n-            cx.equate_inputs_and_outputs(&body, universal_regions, &normalized_inputs_and_output);\n-            liveness::generate(\n-                &mut cx,\n-                body,\n-                elements,\n-                flow_inits,\n-                move_data,\n-                location_table,\n-                use_polonius,\n-            );\n-\n-            translate_outlives_facts(&mut cx);\n-            let opaque_type_values =\n-                infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-\n-            opaque_type_values\n-                .into_iter()\n-                .map(|(opaque_type_key, decl)| {\n-                    cx.fully_perform_op(\n-                        Locations::All(body.span),\n-                        ConstraintCategory::OpaqueType,\n-                        CustomTypeOp::new(\n-                            |infcx| {\n-                                infcx.register_member_constraints(\n-                                    param_env,\n-                                    opaque_type_key,\n-                                    decl.hidden_type.ty,\n-                                    decl.hidden_type.span,\n-                                );\n-                                Ok(InferOk { value: (), obligations: vec![] })\n-                            },\n-                            || \"opaque_type_map\".to_string(),\n-                        ),\n-                    )\n-                    .unwrap();\n-                    let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type);\n-                    trace!(\n-                        \"finalized opaque type {:?} to {:#?}\",\n-                        opaque_type_key,\n-                        hidden_type.ty.kind()\n-                    );\n-                    if hidden_type.has_infer_types_or_consts() {\n-                        infcx.tcx.sess.delay_span_bug(\n-                            decl.hidden_type.span,\n-                            &format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),\n-                        );\n-                        hidden_type.ty = infcx.tcx.ty_error();\n-                    }\n-\n-                    (opaque_type_key, (hidden_type, decl.origin))\n-                })\n-                .collect()\n-        },\n     );\n \n-    MirTypeckResults { constraints, universal_region_relations, opaque_type_values }\n-}\n-\n-#[instrument(\n-    skip(infcx, body, promoted, region_bound_pairs, borrowck_context, extra),\n-    level = \"debug\"\n-)]\n-fn type_check_internal<'a, 'tcx, R>(\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    body: &'a Body<'tcx>,\n-    promoted: &'a IndexVec<Promoted, Body<'tcx>>,\n-    region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n-    implicit_region_bound: ty::Region<'tcx>,\n-    borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n-    extra: impl FnOnce(TypeChecker<'a, 'tcx>) -> R,\n-) -> R {\n-    debug!(\"body: {:#?}\", body);\n-    let mut checker = TypeChecker::new(\n-        infcx,\n-        body,\n-        param_env,\n-        region_bound_pairs,\n-        implicit_region_bound,\n-        borrowck_context,\n-    );\n     let errors_reported = {\n         let mut verifier = TypeVerifier::new(&mut checker, promoted);\n         verifier.visit_body(&body);\n@@ -280,7 +198,56 @@ fn type_check_internal<'a, 'tcx, R>(\n         checker.typeck_mir(body);\n     }\n \n-    extra(checker)\n+    checker.equate_inputs_and_outputs(&body, universal_regions, &normalized_inputs_and_output);\n+    liveness::generate(\n+        &mut checker,\n+        body,\n+        elements,\n+        flow_inits,\n+        move_data,\n+        location_table,\n+        use_polonius,\n+    );\n+\n+    translate_outlives_facts(&mut checker);\n+    let opaque_type_values = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+\n+    let opaque_type_values = opaque_type_values\n+        .into_iter()\n+        .map(|(opaque_type_key, decl)| {\n+            checker\n+                .fully_perform_op(\n+                    Locations::All(body.span),\n+                    ConstraintCategory::OpaqueType,\n+                    CustomTypeOp::new(\n+                        |infcx| {\n+                            infcx.register_member_constraints(\n+                                param_env,\n+                                opaque_type_key,\n+                                decl.hidden_type.ty,\n+                                decl.hidden_type.span,\n+                            );\n+                            Ok(InferOk { value: (), obligations: vec![] })\n+                        },\n+                        || \"opaque_type_map\".to_string(),\n+                    ),\n+                )\n+                .unwrap();\n+            let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type);\n+            trace!(\"finalized opaque type {:?} to {:#?}\", opaque_type_key, hidden_type.ty.kind());\n+            if hidden_type.has_infer_types_or_consts() {\n+                infcx.tcx.sess.delay_span_bug(\n+                    decl.hidden_type.span,\n+                    &format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),\n+                );\n+                hidden_type.ty = infcx.tcx.ty_error();\n+            }\n+\n+            (opaque_type_key, (hidden_type, decl.origin))\n+        })\n+        .collect();\n+\n+    MirTypeckResults { constraints, universal_region_relations, opaque_type_values }\n }\n \n fn translate_outlives_facts(typeck: &mut TypeChecker<'_, '_>) {\n@@ -1911,7 +1878,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n \n-            &Rvalue::NullaryOp(_, ty) => {\n+            &Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, ty) => {\n                 let trait_ref = ty::TraitRef {\n                     def_id: tcx.require_lang_item(LangItem::Sized, Some(self.last_span)),\n                     substs: tcx.mk_substs_trait(ty, &[]),"}, {"sha": "50261c193973932d85be96140e1359129e8e6641", "filename": "compiler/rustc_codegen_cranelift/example/alloc_system.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -94,7 +94,7 @@ mod platform {\n     struct Header(*mut u8);\n     const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n     unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n-        &mut *(ptr as *mut Header).offset(-1)\n+        &mut *(ptr as *mut Header).sub(1)\n     }\n     unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n         let aligned = ptr.add(align - (ptr as usize & (align - 1)));"}, {"sha": "89661918d05a5d14e90359c267beb57f356dab98", "filename": "compiler/rustc_codegen_gcc/example/alloc_system.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -156,7 +156,7 @@ mod platform {\n     struct Header(*mut u8);\n     const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n     unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n-        &mut *(ptr as *mut Header).offset(-1)\n+        &mut *(ptr as *mut Header).sub(1)\n     }\n     unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n         let aligned = ptr.add(align - (ptr as usize & (align - 1)));"}, {"sha": "82ef16a7f72fc526f5c9bbf3319e8cdd3fdb7ccc", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -128,7 +128,7 @@\n //! #### Unsizing Casts\n //! A subtle way of introducing neighbor edges is by casting to a trait object.\n //! Since the resulting fat-pointer contains a reference to a vtable, we need to\n-//! instantiate all object-save methods of the trait, as we need to store\n+//! instantiate all object-safe methods of the trait, as we need to store\n //! pointers to these functions even if they never get called anywhere. This can\n //! be seen as a special case of taking a function reference.\n //!\n@@ -1044,10 +1044,12 @@ fn should_codegen_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx>) ->\n /// them.\n ///\n /// For example, the source type might be `&SomeStruct` and the target type\n-/// might be `&SomeTrait` in a cast like:\n+/// might be `&dyn SomeTrait` in a cast like:\n ///\n+/// ```rust,ignore (not real code)\n /// let src: &SomeStruct = ...;\n-/// let target = src as &SomeTrait;\n+/// let target = src as &dyn SomeTrait;\n+/// ```\n ///\n /// Then the output of this function would be (SomeStruct, SomeTrait) since for\n /// constructing the `target` fat-pointer we need the vtable for that pair.\n@@ -1068,8 +1070,10 @@ fn should_codegen_locally<'tcx>(tcx: TyCtxt<'tcx>, instance: &Instance<'tcx>) ->\n /// for the pair of `T` (which is a trait) and the concrete type that `T` was\n /// originally coerced from:\n ///\n+/// ```rust,ignore (not real code)\n /// let src: &ComplexStruct<SomeStruct> = ...;\n-/// let target = src as &ComplexStruct<SomeTrait>;\n+/// let target = src as &ComplexStruct<dyn SomeTrait>;\n+/// ```\n ///\n /// Again, we want this `find_vtable_types_for_unsizing()` to provide the pair\n /// `(SomeStruct, SomeTrait)`."}, {"sha": "9bd5550038fc605a24cd9aa510b668f46f4cf6ea", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -273,7 +273,7 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Vec<T> {\n         unsafe {\n             let ptr: *mut T = vec.as_mut_ptr();\n             for i in 0..len {\n-                std::ptr::write(ptr.offset(i as isize), Decodable::decode(d));\n+                std::ptr::write(ptr.add(i), Decodable::decode(d));\n             }\n             vec.set_len(len);\n         }"}, {"sha": "32e6cb9c64f7f3f804c0fd9ffbcb5c0101284098", "filename": "compiler/rustc_transmute/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flib.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -7,6 +7,8 @@\n     result_into_ok_or_err\n )]\n #![allow(dead_code, unused_variables)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate tracing;"}, {"sha": "b2f0194599b287057f41023545a244749eaf232f", "filename": "library/alloc/src/alloc/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -15,7 +15,7 @@ fn allocate_zeroed() {\n         let end = i.add(layout.size());\n         while i < end {\n             assert_eq!(*i, 0);\n-            i = i.offset(1);\n+            i = i.add(1);\n         }\n         Global.deallocate(ptr.as_non_null_ptr(), layout);\n     }"}, {"sha": "57ab74e01590bd1dabd52d96b93ab29f49da94ee", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -2447,8 +2447,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n                     let mut right_offset = 0;\n                     for i in left_edge..right_edge {\n                         right_offset = (i - left_edge) % (cap - right_edge);\n-                        let src: isize = (right_edge + right_offset) as isize;\n-                        ptr::swap(buf.add(i), buf.offset(src));\n+                        let src = right_edge + right_offset;\n+                        ptr::swap(buf.add(i), buf.add(src));\n                     }\n                     let n_ops = right_edge - left_edge;\n                     left_edge += n_ops;"}, {"sha": "be21d8c722d78217c8f27617f09b5a183f6f0f40", "filename": "library/alloc/src/ffi/c_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fffi%2Fc_str.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -436,9 +436,9 @@ impl CString {\n     ///\n     /// unsafe {\n     ///     assert_eq!(b'f', *ptr as u8);\n-    ///     assert_eq!(b'o', *ptr.offset(1) as u8);\n-    ///     assert_eq!(b'o', *ptr.offset(2) as u8);\n-    ///     assert_eq!(b'\\0', *ptr.offset(3) as u8);\n+    ///     assert_eq!(b'o', *ptr.add(1) as u8);\n+    ///     assert_eq!(b'o', *ptr.add(2) as u8);\n+    ///     assert_eq!(b'\\0', *ptr.add(3) as u8);\n     ///\n     ///     // retake pointer to free memory\n     ///     let _ = CString::from_raw(ptr);"}, {"sha": "5733124ec7565ecc22170cdaf74b9ab379998f07", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -1024,7 +1024,7 @@ where\n             // Consume the greater side.\n             // If equal, prefer the right run to maintain stability.\n             unsafe {\n-                let to_copy = if is_less(&*right.offset(-1), &*left.offset(-1)) {\n+                let to_copy = if is_less(&*right.sub(1), &*left.sub(1)) {\n                     decrement_and_get(left)\n                 } else {\n                     decrement_and_get(right)\n@@ -1038,12 +1038,12 @@ where\n \n     unsafe fn get_and_increment<T>(ptr: &mut *mut T) -> *mut T {\n         let old = *ptr;\n-        *ptr = unsafe { ptr.offset(1) };\n+        *ptr = unsafe { ptr.add(1) };\n         old\n     }\n \n     unsafe fn decrement_and_get<T>(ptr: &mut *mut T) -> *mut T {\n-        *ptr = unsafe { ptr.offset(-1) };\n+        *ptr = unsafe { ptr.sub(1) };\n         *ptr\n     }\n "}, {"sha": "b211421b20270f3787646651dd99025ca21903fc", "filename": "library/alloc/src/vec/in_place_collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -267,7 +267,7 @@ where\n             // one slot in the underlying storage will have been freed up and we can immediately\n             // write back the result.\n             unsafe {\n-                let dst = dst_buf.offset(i as isize);\n+                let dst = dst_buf.add(i);\n                 debug_assert!(dst as *const _ <= end, \"InPlaceIterable contract violation\");\n                 ptr::write(dst, self.__iterator_get_unchecked(i));\n                 // Since this executes user code which can panic we have to bump the pointer"}, {"sha": "e02ad391a595fae24192ab21931d64e38f47e00c", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -160,7 +160,7 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n             Some(unsafe { mem::zeroed() })\n         } else {\n             let old = self.ptr;\n-            self.ptr = unsafe { self.ptr.offset(1) };\n+            self.ptr = unsafe { self.ptr.add(1) };\n \n             Some(unsafe { ptr::read(old) })\n         }\n@@ -272,7 +272,7 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n             // Make up a value of this ZST.\n             Some(unsafe { mem::zeroed() })\n         } else {\n-            self.end = unsafe { self.end.offset(-1) };\n+            self.end = unsafe { self.end.sub(1) };\n \n             Some(unsafe { ptr::read(self.end) })\n         }\n@@ -288,7 +288,7 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n             }\n         } else {\n             // SAFETY: same as for advance_by()\n-            self.end = unsafe { self.end.offset(step_size.wrapping_neg() as isize) };\n+            self.end = unsafe { self.end.sub(step_size) };\n         }\n         let to_drop = ptr::slice_from_raw_parts_mut(self.end as *mut T, step_size);\n         // SAFETY: same as for advance_by()"}, {"sha": "cea943602f77024afd0a10ce5d84c1c369f25a0b", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -542,8 +542,8 @@ impl<T> Vec<T> {\n     ///\n     /// unsafe {\n     ///     // Overwrite memory with 4, 5, 6\n-    ///     for i in 0..len as isize {\n-    ///         ptr::write(p.offset(i), 4 + i);\n+    ///     for i in 0..len {\n+    ///         ptr::write(p.add(i), 4 + i);\n     ///     }\n     ///\n     ///     // Put everything back together into a Vec\n@@ -702,8 +702,8 @@ impl<T, A: Allocator> Vec<T, A> {\n     ///\n     /// unsafe {\n     ///     // Overwrite memory with 4, 5, 6\n-    ///     for i in 0..len as isize {\n-    ///         ptr::write(p.offset(i), 4 + i);\n+    ///     for i in 0..len {\n+    ///         ptr::write(p.add(i), 4 + i);\n     ///     }\n     ///\n     ///     // Put everything back together into a Vec\n@@ -1393,7 +1393,7 @@ impl<T, A: Allocator> Vec<T, A> {\n                 if index < len {\n                     // Shift everything over to make space. (Duplicating the\n                     // `index`th element into two consecutive places.)\n-                    ptr::copy(p, p.offset(1), len - index);\n+                    ptr::copy(p, p.add(1), len - index);\n                 } else if index == len {\n                     // No elements need shifting.\n                 } else {\n@@ -1455,7 +1455,7 @@ impl<T, A: Allocator> Vec<T, A> {\n                 ret = ptr::read(ptr);\n \n                 // Shift everything down to fill in that spot.\n-                ptr::copy(ptr.offset(1), ptr, len - index - 1);\n+                ptr::copy(ptr.add(1), ptr, len - index - 1);\n             }\n             self.set_len(len - 1);\n             ret\n@@ -2408,7 +2408,7 @@ impl<T, A: Allocator> Vec<T, A> {\n             // Write all elements except the last one\n             for _ in 1..n {\n                 ptr::write(ptr, value.next());\n-                ptr = ptr.offset(1);\n+                ptr = ptr.add(1);\n                 // Increment the length in every step in case next() panics\n                 local_len.increment_len(1);\n             }"}, {"sha": "1ea9c827afd70702f1254b843d6ed2e3b48e472a", "filename": "library/alloc/src/vec/spec_extend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -39,7 +39,7 @@ where\n                 let mut local_len = SetLenOnDrop::new(&mut self.len);\n                 iterator.for_each(move |element| {\n                     ptr::write(ptr, element);\n-                    ptr = ptr.offset(1);\n+                    ptr = ptr.add(1);\n                     // Since the loop executes user code which can panic we have to bump the pointer\n                     // after each step.\n                     // NB can't overflow since we would have had to alloc the address space"}, {"sha": "e30329aa1cb6c78e46c8952eae1f839763ec8df4", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -1010,11 +1010,11 @@ fn test_as_bytes_fail() {\n fn test_as_ptr() {\n     let buf = \"hello\".as_ptr();\n     unsafe {\n-        assert_eq!(*buf.offset(0), b'h');\n-        assert_eq!(*buf.offset(1), b'e');\n-        assert_eq!(*buf.offset(2), b'l');\n-        assert_eq!(*buf.offset(3), b'l');\n-        assert_eq!(*buf.offset(4), b'o');\n+        assert_eq!(*buf.add(0), b'h');\n+        assert_eq!(*buf.add(1), b'e');\n+        assert_eq!(*buf.add(2), b'l');\n+        assert_eq!(*buf.add(3), b'l');\n+        assert_eq!(*buf.add(4), b'o');\n     }\n }\n "}, {"sha": "3d7b875eac15d1f6756e240f07a7cb484cfc8da7", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -2209,9 +2209,9 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n ///     dst.reserve(src_len);\n ///\n ///     unsafe {\n-///         // The call to offset is always safe because `Vec` will never\n+///         // The call to add is always safe because `Vec` will never\n ///         // allocate more than `isize::MAX` bytes.\n-///         let dst_ptr = dst.as_mut_ptr().offset(dst_len as isize);\n+///         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n ///         let src_ptr = src.as_ptr();\n ///\n ///         // Truncate `src` without dropping its contents. We do this first,"}, {"sha": "efa434f2392666507a130c6f39da332b5e4cb1d8", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -1282,15 +1282,14 @@ impl f32 {\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"clamp\", since = \"1.50.0\")]\n     #[inline]\n-    pub fn clamp(self, min: f32, max: f32) -> f32 {\n+    pub fn clamp(mut self, min: f32, max: f32) -> f32 {\n         assert!(min <= max);\n-        let mut x = self;\n-        if x < min {\n-            x = min;\n+        if self < min {\n+            self = min;\n         }\n-        if x > max {\n-            x = max;\n+        if self > max {\n+            self = max;\n         }\n-        x\n+        self\n     }\n }"}, {"sha": "9e4334fe01ad85e6095e3d124650c2143bdcded7", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -1280,15 +1280,14 @@ impl f64 {\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"clamp\", since = \"1.50.0\")]\n     #[inline]\n-    pub fn clamp(self, min: f64, max: f64) -> f64 {\n+    pub fn clamp(mut self, min: f64, max: f64) -> f64 {\n         assert!(min <= max);\n-        let mut x = self;\n-        if x < min {\n-            x = min;\n+        if self < min {\n+            self = min;\n         }\n-        if x > max {\n-            x = max;\n+        if self > max {\n+            self = max;\n         }\n-        x\n+        self\n     }\n }"}, {"sha": "ea6a70c2f4e741db18b951125b257e2200c75f4e", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -674,8 +674,9 @@ impl<T> [T] {\n     /// assert!(v == [3, 2, 1]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_reverse\", issue = \"100784\")]\n     #[inline]\n-    pub fn reverse(&mut self) {\n+    pub const fn reverse(&mut self) {\n         let half_len = self.len() / 2;\n         let Range { start, end } = self.as_mut_ptr_range();\n \n@@ -698,18 +699,20 @@ impl<T> [T] {\n         revswap(front_half, back_half, half_len);\n \n         #[inline]\n-        fn revswap<T>(a: &mut [T], b: &mut [T], n: usize) {\n-            debug_assert_eq!(a.len(), n);\n-            debug_assert_eq!(b.len(), n);\n+        const fn revswap<T>(a: &mut [T], b: &mut [T], n: usize) {\n+            debug_assert!(a.len() == n);\n+            debug_assert!(b.len() == n);\n \n             // Because this function is first compiled in isolation,\n             // this check tells LLVM that the indexing below is\n             // in-bounds.  Then after inlining -- once the actual\n             // lengths of the slices are known -- it's removed.\n             let (a, b) = (&mut a[..n], &mut b[..n]);\n \n-            for i in 0..n {\n+            let mut i = 0;\n+            while i < n {\n                 mem::swap(&mut a[i], &mut b[n - 1 - i]);\n+                i += 1;\n             }\n         }\n     }\n@@ -2921,7 +2924,7 @@ impl<T> [T] {\n                 let prev_ptr_write = ptr.add(next_write - 1);\n                 if !same_bucket(&mut *ptr_read, &mut *prev_ptr_write) {\n                     if next_read != next_write {\n-                        let ptr_write = prev_ptr_write.offset(1);\n+                        let ptr_write = prev_ptr_write.add(1);\n                         mem::swap(&mut *ptr_read, &mut *ptr_write);\n                     }\n                     next_write += 1;"}, {"sha": "8b025da2a46ed02968b037e1fc122147500eefa0", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -326,8 +326,8 @@ where\n                 unsafe {\n                     // Branchless comparison.\n                     *end_l = i as u8;\n-                    end_l = end_l.offset(!is_less(&*elem, pivot) as isize);\n-                    elem = elem.offset(1);\n+                    end_l = end_l.add(!is_less(&*elem, pivot) as usize);\n+                    elem = elem.add(1);\n                 }\n             }\n         }\n@@ -352,9 +352,9 @@ where\n                 //        Plus, `block_r` was asserted to be less than `BLOCK` and `elem` will therefore at most be pointing to the beginning of the slice.\n                 unsafe {\n                     // Branchless comparison.\n-                    elem = elem.offset(-1);\n+                    elem = elem.sub(1);\n                     *end_r = i as u8;\n-                    end_r = end_r.offset(is_less(&*elem, pivot) as isize);\n+                    end_r = end_r.add(is_less(&*elem, pivot) as usize);\n                 }\n             }\n         }\n@@ -365,12 +365,12 @@ where\n         if count > 0 {\n             macro_rules! left {\n                 () => {\n-                    l.offset(*start_l as isize)\n+                    l.add(*start_l as usize)\n                 };\n             }\n             macro_rules! right {\n                 () => {\n-                    r.offset(-(*start_r as isize) - 1)\n+                    r.sub((*start_r as usize) + 1)\n                 };\n             }\n \n@@ -398,16 +398,16 @@ where\n                 ptr::copy_nonoverlapping(right!(), left!(), 1);\n \n                 for _ in 1..count {\n-                    start_l = start_l.offset(1);\n+                    start_l = start_l.add(1);\n                     ptr::copy_nonoverlapping(left!(), right!(), 1);\n-                    start_r = start_r.offset(1);\n+                    start_r = start_r.add(1);\n                     ptr::copy_nonoverlapping(right!(), left!(), 1);\n                 }\n \n                 ptr::copy_nonoverlapping(&tmp, right!(), 1);\n                 mem::forget(tmp);\n-                start_l = start_l.offset(1);\n-                start_r = start_r.offset(1);\n+                start_l = start_l.add(1);\n+                start_r = start_r.add(1);\n             }\n         }\n \n@@ -420,15 +420,15 @@ where\n             // safe. Otherwise, the debug assertions in the `is_done` case guarantee that\n             // `width(l, r) == block_l + block_r`, namely, that the block sizes have been adjusted to account\n             // for the smaller number of remaining elements.\n-            l = unsafe { l.offset(block_l as isize) };\n+            l = unsafe { l.add(block_l) };\n         }\n \n         if start_r == end_r {\n             // All out-of-order elements in the right block were moved. Move to the previous block.\n \n             // SAFETY: Same argument as [block-width-guarantee]. Either this is a full block `2*BLOCK`-wide,\n             // or `block_r` has been adjusted for the last handful of elements.\n-            r = unsafe { r.offset(-(block_r as isize)) };\n+            r = unsafe { r.sub(block_r) };\n         }\n \n         if is_done {\n@@ -457,9 +457,9 @@ where\n             //  - `offsets_l` contains valid offsets into `v` collected during the partitioning of\n             //    the last block, so the `l.offset` calls are valid.\n             unsafe {\n-                end_l = end_l.offset(-1);\n-                ptr::swap(l.offset(*end_l as isize), r.offset(-1));\n-                r = r.offset(-1);\n+                end_l = end_l.sub(1);\n+                ptr::swap(l.add(*end_l as usize), r.sub(1));\n+                r = r.sub(1);\n             }\n         }\n         width(v.as_mut_ptr(), r)\n@@ -470,9 +470,9 @@ where\n         while start_r < end_r {\n             // SAFETY: See the reasoning in [remaining-elements-safety].\n             unsafe {\n-                end_r = end_r.offset(-1);\n-                ptr::swap(l, r.offset(-(*end_r as isize) - 1));\n-                l = l.offset(1);\n+                end_r = end_r.sub(1);\n+                ptr::swap(l, r.sub((*end_r as usize) + 1));\n+                l = l.add(1);\n             }\n         }\n         width(v.as_mut_ptr(), l)"}, {"sha": "2acef432f2063a7978d7163f60e80a0b8f4d4460", "filename": "library/core/src/str/validations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -216,12 +216,12 @@ pub(super) const fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n                     // SAFETY: since `align - index` and `ascii_block_size` are\n                     // multiples of `usize_bytes`, `block = ptr.add(index)` is\n                     // always aligned with a `usize` so it's safe to dereference\n-                    // both `block` and `block.offset(1)`.\n+                    // both `block` and `block.add(1)`.\n                     unsafe {\n                         let block = ptr.add(index) as *const usize;\n                         // break if there is a nonascii byte\n                         let zu = contains_nonascii(*block);\n-                        let zv = contains_nonascii(*block.offset(1));\n+                        let zv = contains_nonascii(*block.add(1));\n                         if zu || zv {\n                             break;\n                         }"}, {"sha": "3c96290fc537e19bbe1e2b400a5eabf13ece5a0c", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -1554,8 +1554,8 @@ impl<T> AtomicPtr<T> {\n     /// Offsets the pointer's address by adding `val` *bytes*, returning the\n     /// previous pointer.\n     ///\n-    /// This is equivalent to using [`wrapping_add`] and [`cast`] to atomically\n-    /// perform `ptr = ptr.cast::<u8>().wrapping_add(val).cast::<T>()`.\n+    /// This is equivalent to using [`wrapping_byte_add`] to atomically\n+    /// perform `ptr = ptr.wrapping_byte_add(val)`.\n     ///\n     /// `fetch_byte_add` takes an [`Ordering`] argument which describes the\n     /// memory ordering of this operation. All ordering modes are possible. Note\n@@ -1565,8 +1565,7 @@ impl<T> AtomicPtr<T> {\n     /// **Note**: This method is only available on platforms that support atomic\n     /// operations on [`AtomicPtr`].\n     ///\n-    /// [`wrapping_add`]: pointer::wrapping_add\n-    /// [`cast`]: pointer::cast\n+    /// [`wrapping_byte_add`]: pointer::wrapping_byte_add\n     ///\n     /// # Examples\n     ///\n@@ -1591,8 +1590,8 @@ impl<T> AtomicPtr<T> {\n     /// Offsets the pointer's address by subtracting `val` *bytes*, returning the\n     /// previous pointer.\n     ///\n-    /// This is equivalent to using [`wrapping_sub`] and [`cast`] to atomically\n-    /// perform `ptr = ptr.cast::<u8>().wrapping_sub(val).cast::<T>()`.\n+    /// This is equivalent to using [`wrapping_byte_sub`] to atomically\n+    /// perform `ptr = ptr.wrapping_byte_sub(val)`.\n     ///\n     /// `fetch_byte_sub` takes an [`Ordering`] argument which describes the\n     /// memory ordering of this operation. All ordering modes are possible. Note\n@@ -1602,8 +1601,7 @@ impl<T> AtomicPtr<T> {\n     /// **Note**: This method is only available on platforms that support atomic\n     /// operations on [`AtomicPtr`].\n     ///\n-    /// [`wrapping_sub`]: pointer::wrapping_sub\n-    /// [`cast`]: pointer::cast\n+    /// [`wrapping_byte_sub`]: pointer::wrapping_byte_sub\n     ///\n     /// # Examples\n     ///"}, {"sha": "0fd824f8a458da3f19d77899e6aea18bd282f96f", "filename": "library/panic_abort/src/android.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fpanic_abort%2Fsrc%2Fandroid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fpanic_abort%2Fsrc%2Fandroid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_abort%2Fsrc%2Fandroid.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -42,7 +42,7 @@ pub(crate) unsafe fn android_set_abort_message(payload: *mut &mut dyn BoxMeUp) {\n         return; // allocation failure\n     }\n     copy_nonoverlapping(msg.as_ptr(), buf as *mut u8, msg.len());\n-    buf.offset(msg.len() as isize).write(0);\n+    buf.add(msg.len()).write(0);\n \n     let func = transmute::<usize, SetAbortMessageType>(func_addr);\n     func(buf);"}, {"sha": "9aa966b5063b1a0f91492db0deac919a026a2f28", "filename": "library/panic_unwind/src/dwarf/eh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fpanic_unwind%2Fsrc%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fpanic_unwind%2Fsrc%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fdwarf%2Feh.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -75,7 +75,7 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>) -> Result\n \n     let call_site_encoding = reader.read::<u8>();\n     let call_site_table_length = reader.read_uleb128();\n-    let action_table = reader.ptr.offset(call_site_table_length as isize);\n+    let action_table = reader.ptr.add(call_site_table_length as usize);\n     let ip = context.ip;\n \n     if !USING_SJLJ_EXCEPTIONS {"}, {"sha": "bb313c7597b6c87991a6da351698de7543e1a437", "filename": "library/std/src/os/unix/net/addr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -329,7 +329,7 @@ impl SocketAddr {\n \n             crate::ptr::copy_nonoverlapping(\n                 namespace.as_ptr(),\n-                addr.sun_path.as_mut_ptr().offset(1) as *mut u8,\n+                addr.sun_path.as_mut_ptr().add(1) as *mut u8,\n                 namespace.len(),\n             );\n             let len = (sun_path_offset(&addr) + 1 + namespace.len()) as libc::socklen_t;"}, {"sha": "d91d4fa64caa587300380f2ec6b689c5f7d17a3a", "filename": "library/std/src/process.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -169,15 +169,15 @@ use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n pub struct Child {\n     pub(crate) handle: imp::Process,\n \n-    /// The handle for writing to the child's standard input (stdin), if it has\n-    /// been captured. To avoid partially moving\n-    /// the `child` and thus blocking yourself from calling\n-    /// functions on `child` while using `stdin`,\n-    /// you might find it helpful:\n+    /// The handle for writing to the child's standard input (stdin), if it\n+    /// has been captured. You might find it helpful to do\n     ///\n     /// ```compile_fail,E0425\n     /// let stdin = child.stdin.take().unwrap();\n     /// ```\n+    ///\n+    /// to avoid partially moving the `child` and thus blocking yourself from calling\n+    /// functions on `child` while using `stdin`.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stdin: Option<ChildStdin>,\n "}, {"sha": "58b8eb215d73cc97fe29f4342d050ac5ffc5d8e8", "filename": "library/std/src/sys/sgx/abi/usercalls/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Ftests.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -17,12 +17,12 @@ fn test_copy_to_userspace_function() {\n             dst.copy_from_enclave(&[0u8; 100]);\n \n             // Copy src[0..size] to dst + offset\n-            unsafe { copy_to_userspace(src.as_ptr(), dst.as_mut_ptr().offset(offset), size) };\n+            unsafe { copy_to_userspace(src.as_ptr(), dst.as_mut_ptr().add(offset), size) };\n \n             // Verify copy\n             for byte in 0..size {\n                 unsafe {\n-                    assert_eq!(*dst.as_ptr().offset(offset + byte as isize), src[byte as usize]);\n+                    assert_eq!(*dst.as_ptr().add(offset + byte), src[byte as usize]);\n                 }\n             }\n         }"}, {"sha": "fe00c08aa6a9ae19c15d7035bd65624587a6fed6", "filename": "library/std/src/sys/windows/alloc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -168,7 +168,7 @@ unsafe fn allocate(layout: Layout, zeroed: bool) -> *mut u8 {\n         // SAFETY: Because the size and alignment of a header is <= `MIN_ALIGN` and `aligned`\n         // is aligned to at least `MIN_ALIGN` and has at least `MIN_ALIGN` bytes of padding before\n         // it, it is safe to write a header directly before it.\n-        unsafe { ptr::write((aligned as *mut Header).offset(-1), Header(ptr)) };\n+        unsafe { ptr::write((aligned as *mut Header).sub(1), Header(ptr)) };\n \n         // SAFETY: The returned pointer does not point to the to the start of an allocated block,\n         // but there is a header readable directly before it containing the location of the start\n@@ -213,7 +213,7 @@ unsafe impl GlobalAlloc for System {\n \n                 // SAFETY: Because of the contract of `System`, `ptr` is guaranteed to be non-null\n                 // and have a header readable directly before it.\n-                unsafe { ptr::read((ptr as *mut Header).offset(-1)).0 }\n+                unsafe { ptr::read((ptr as *mut Header).sub(1)).0 }\n             }\n         };\n "}, {"sha": "1361b9c90c021879e2cc097ae5437fcf47278dc5", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -512,7 +512,7 @@ impl File {\n                     ));\n                 }\n             };\n-            let subst_ptr = path_buffer.offset(subst_off as isize);\n+            let subst_ptr = path_buffer.add(subst_off.into());\n             let mut subst = slice::from_raw_parts(subst_ptr, subst_len as usize);\n             // Absolute paths start with an NT internal namespace prefix `\\??\\`\n             // We should not let it leak through.\n@@ -1345,10 +1345,10 @@ fn symlink_junction_inner(original: &Path, junction: &Path) -> io::Result<()> {\n         let v = br\"\\??\\\";\n         let v = v.iter().map(|x| *x as u16);\n         for c in v.chain(original.as_os_str().encode_wide()) {\n-            *buf.offset(i) = c;\n+            *buf.add(i) = c;\n             i += 1;\n         }\n-        *buf.offset(i) = 0;\n+        *buf.add(i) = 0;\n         i += 1;\n         (*db).ReparseTag = c::IO_REPARSE_TAG_MOUNT_POINT;\n         (*db).ReparseTargetMaximumLength = (i * 2) as c::WORD;"}, {"sha": "352337ba322371d77b89aedc5d1a7cc756351f0d", "filename": "library/std/src/sys/windows/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -99,11 +99,11 @@ impl Iterator for Env {\n                 }\n                 let p = self.cur as *const u16;\n                 let mut len = 0;\n-                while *p.offset(len) != 0 {\n+                while *p.add(len) != 0 {\n                     len += 1;\n                 }\n-                let s = slice::from_raw_parts(p, len as usize);\n-                self.cur = self.cur.offset(len + 1);\n+                let s = slice::from_raw_parts(p, len);\n+                self.cur = self.cur.add(len + 1);\n \n                 // Windows allows environment variables to start with an equals\n                 // symbol (in any other position, this is the separator between"}, {"sha": "4a12d74ddef5a5844dd89255ed451eee1f43e7af", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 133, "deletions": 91, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -111,53 +111,6 @@ fn write_header(out: &mut Buffer, class: &str, extra_content: Option<Buffer>) {\n     write!(out, \"<code>\");\n }\n \n-/// Write all the pending elements sharing a same (or at mergeable) `Class`.\n-///\n-/// If there is a \"parent\" (if a `EnterSpan` event was encountered) and the parent can be merged\n-/// with the elements' class, then we simply write the elements since the `ExitSpan` event will\n-/// close the tag.\n-///\n-/// Otherwise, if there is only one pending element, we let the `string` function handle both\n-/// opening and closing the tag, otherwise we do it into this function.\n-fn write_pending_elems(\n-    out: &mut Buffer,\n-    href_context: &Option<HrefContext<'_, '_, '_>>,\n-    pending_elems: &mut Vec<(&str, Option<Class>)>,\n-    current_class: &mut Option<Class>,\n-    closing_tags: &[(&str, Class)],\n-) {\n-    if pending_elems.is_empty() {\n-        return;\n-    }\n-    let mut done = false;\n-    if let Some((_, parent_class)) = closing_tags.last() {\n-        if can_merge(*current_class, Some(*parent_class), \"\") {\n-            for (text, class) in pending_elems.iter() {\n-                string(out, Escape(text), *class, &href_context, false);\n-            }\n-            done = true;\n-        }\n-    }\n-    if !done {\n-        // We only want to \"open\" the tag ourselves if we have more than one pending and if the current\n-        // parent tag is not the same as our pending content.\n-        let open_tag_ourselves = pending_elems.len() > 1;\n-        let close_tag = if open_tag_ourselves {\n-            enter_span(out, current_class.unwrap(), &href_context)\n-        } else {\n-            \"\"\n-        };\n-        for (text, class) in pending_elems.iter() {\n-            string(out, Escape(text), *class, &href_context, !open_tag_ourselves);\n-        }\n-        if open_tag_ourselves {\n-            exit_span(out, close_tag);\n-        }\n-    }\n-    pending_elems.clear();\n-    *current_class = None;\n-}\n-\n /// Check if two `Class` can be merged together. In the following rules, \"unclassified\" means `None`\n /// basically (since it's `Option<Class>`). The following rules apply:\n ///\n@@ -171,7 +124,88 @@ fn can_merge(class1: Option<Class>, class2: Option<Class>, text: &str) -> bool {\n         (Some(c1), Some(c2)) => c1.is_equal_to(c2),\n         (Some(Class::Ident(_)), None) | (None, Some(Class::Ident(_))) => true,\n         (Some(_), None) | (None, Some(_)) => text.trim().is_empty(),\n-        _ => false,\n+        (None, None) => true,\n+    }\n+}\n+\n+/// This type is used as a conveniency to prevent having to pass all its fields as arguments into\n+/// the various functions (which became its methods).\n+struct TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+    out: &'a mut Buffer,\n+    /// It contains the closing tag and the associated `Class`.\n+    closing_tags: Vec<(&'static str, Class)>,\n+    /// This is used because we don't automatically generate the closing tag on `ExitSpan` in\n+    /// case an `EnterSpan` event with the same class follows.\n+    pending_exit_span: Option<Class>,\n+    /// `current_class` and `pending_elems` are used to group HTML elements with same `class`\n+    /// attributes to reduce the DOM size.\n+    current_class: Option<Class>,\n+    /// We need to keep the `Class` for each element because it could contain a `Span` which is\n+    /// used to generate links.\n+    pending_elems: Vec<(&'b str, Option<Class>)>,\n+    href_context: Option<HrefContext<'c, 'd, 'e>>,\n+}\n+\n+impl<'a, 'b, 'c, 'd, 'e> TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+    fn handle_exit_span(&mut self) {\n+        // We can't get the last `closing_tags` element using `pop()` because `closing_tags` is\n+        // being used in `write_pending_elems`.\n+        let class = self.closing_tags.last().expect(\"ExitSpan without EnterSpan\").1;\n+        // We flush everything just in case...\n+        self.write_pending_elems(Some(class));\n+\n+        exit_span(self.out, self.closing_tags.pop().expect(\"ExitSpan without EnterSpan\").0);\n+        self.pending_exit_span = None;\n+    }\n+\n+    /// Write all the pending elements sharing a same (or at mergeable) `Class`.\n+    ///\n+    /// If there is a \"parent\" (if a `EnterSpan` event was encountered) and the parent can be merged\n+    /// with the elements' class, then we simply write the elements since the `ExitSpan` event will\n+    /// close the tag.\n+    ///\n+    /// Otherwise, if there is only one pending element, we let the `string` function handle both\n+    /// opening and closing the tag, otherwise we do it into this function.\n+    ///\n+    /// It returns `true` if `current_class` must be set to `None` afterwards.\n+    fn write_pending_elems(&mut self, current_class: Option<Class>) -> bool {\n+        if self.pending_elems.is_empty() {\n+            return false;\n+        }\n+        if let Some((_, parent_class)) = self.closing_tags.last() &&\n+            can_merge(current_class, Some(*parent_class), \"\")\n+        {\n+            for (text, class) in self.pending_elems.iter() {\n+                string(self.out, Escape(text), *class, &self.href_context, false);\n+            }\n+        } else {\n+            // We only want to \"open\" the tag ourselves if we have more than one pending and if the\n+            // current parent tag is not the same as our pending content.\n+            let close_tag = if self.pending_elems.len() > 1 && current_class.is_some() {\n+                Some(enter_span(self.out, current_class.unwrap(), &self.href_context))\n+            } else {\n+                None\n+            };\n+            for (text, class) in self.pending_elems.iter() {\n+                string(self.out, Escape(text), *class, &self.href_context, close_tag.is_none());\n+            }\n+            if let Some(close_tag) = close_tag {\n+                exit_span(self.out, close_tag);\n+            }\n+        }\n+        self.pending_elems.clear();\n+        true\n+    }\n+}\n+\n+impl<'a, 'b, 'c, 'd, 'e> Drop for TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+    /// When leaving, we need to flush all pending data to not have missing content.\n+    fn drop(&mut self) {\n+        if self.pending_exit_span.is_some() {\n+            self.handle_exit_span();\n+        } else {\n+            self.write_pending_elems(self.current_class);\n+        }\n     }\n }\n \n@@ -194,64 +228,72 @@ fn write_code(\n ) {\n     // This replace allows to fix how the code source with DOS backline characters is displayed.\n     let src = src.replace(\"\\r\\n\", \"\\n\");\n-    // It contains the closing tag and the associated `Class`.\n-    let mut closing_tags: Vec<(&'static str, Class)> = Vec::new();\n-    // The following two variables are used to group HTML elements with same `class` attributes\n-    // to reduce the DOM size.\n-    let mut current_class: Option<Class> = None;\n-    // We need to keep the `Class` for each element because it could contain a `Span` which is\n-    // used to generate links.\n-    let mut pending_elems: Vec<(&str, Option<Class>)> = Vec::new();\n+    let mut token_handler = TokenHandler {\n+        out,\n+        closing_tags: Vec::new(),\n+        pending_exit_span: None,\n+        current_class: None,\n+        pending_elems: Vec::new(),\n+        href_context,\n+    };\n \n     Classifier::new(\n         &src,\n-        href_context.as_ref().map(|c| c.file_span).unwrap_or(DUMMY_SP),\n+        token_handler.href_context.as_ref().map(|c| c.file_span).unwrap_or(DUMMY_SP),\n         decoration_info,\n     )\n     .highlight(&mut |highlight| {\n         match highlight {\n             Highlight::Token { text, class } => {\n+                // If we received a `ExitSpan` event and then have a non-compatible `Class`, we\n+                // need to close the `<span>`.\n+                let need_current_class_update = if let Some(pending) = token_handler.pending_exit_span &&\n+                    !can_merge(Some(pending), class, text) {\n+                        token_handler.handle_exit_span();\n+                        true\n                 // If the two `Class` are different, time to flush the current content and start\n                 // a new one.\n-                if !can_merge(current_class, class, text) {\n-                    write_pending_elems(\n-                        out,\n-                        &href_context,\n-                        &mut pending_elems,\n-                        &mut current_class,\n-                        &closing_tags,\n-                    );\n-                    current_class = class.map(Class::dummy);\n-                } else if current_class.is_none() {\n-                    current_class = class.map(Class::dummy);\n+                } else if !can_merge(token_handler.current_class, class, text) {\n+                    token_handler.write_pending_elems(token_handler.current_class);\n+                    true\n+                } else {\n+                    token_handler.current_class.is_none()\n+                };\n+\n+                if need_current_class_update {\n+                    token_handler.current_class = class.map(Class::dummy);\n                 }\n-                pending_elems.push((text, class));\n+                token_handler.pending_elems.push((text, class));\n             }\n             Highlight::EnterSpan { class } => {\n-                // We flush everything just in case...\n-                write_pending_elems(\n-                    out,\n-                    &href_context,\n-                    &mut pending_elems,\n-                    &mut current_class,\n-                    &closing_tags,\n-                );\n-                closing_tags.push((enter_span(out, class, &href_context), class))\n+                let mut should_add = true;\n+                if let Some(pending_exit_span) = token_handler.pending_exit_span {\n+                    if class.is_equal_to(pending_exit_span) {\n+                        should_add = false;\n+                    } else {\n+                        token_handler.handle_exit_span();\n+                    }\n+                } else {\n+                    // We flush everything just in case...\n+                    if token_handler.write_pending_elems(token_handler.current_class) {\n+                        token_handler.current_class = None;\n+                    }\n+                }\n+                if should_add {\n+                    let closing_tag = enter_span(token_handler.out, class, &token_handler.href_context);\n+                    token_handler.closing_tags.push((closing_tag, class));\n+                }\n+\n+                token_handler.current_class = None;\n+                token_handler.pending_exit_span = None;\n             }\n             Highlight::ExitSpan => {\n-                // We flush everything just in case...\n-                write_pending_elems(\n-                    out,\n-                    &href_context,\n-                    &mut pending_elems,\n-                    &mut current_class,\n-                    &closing_tags,\n-                );\n-                exit_span(out, closing_tags.pop().expect(\"ExitSpan without EnterSpan\").0)\n+                token_handler.current_class = None;\n+                token_handler.pending_exit_span =\n+                    Some(token_handler.closing_tags.last().as_ref().expect(\"ExitSpan without EnterSpan\").1);\n             }\n         };\n     });\n-    write_pending_elems(out, &href_context, &mut pending_elems, &mut current_class, &closing_tags);\n }\n \n fn write_footer(out: &mut Buffer, playground_button: Option<&str>) {\n@@ -291,8 +333,8 @@ impl Class {\n         match (self, other) {\n             (Self::Self_(_), Self::Self_(_))\n             | (Self::Macro(_), Self::Macro(_))\n-            | (Self::Ident(_), Self::Ident(_))\n-            | (Self::Decoration(_), Self::Decoration(_)) => true,\n+            | (Self::Ident(_), Self::Ident(_)) => true,\n+            (Self::Decoration(c1), Self::Decoration(c2)) => c1 == c2,\n             (x, y) => x == y,\n         }\n     }\n@@ -761,7 +803,7 @@ impl<'a> Classifier<'a> {\n             TokenKind::CloseBracket => {\n                 if self.in_attribute {\n                     self.in_attribute = false;\n-                    sink(Highlight::Token { text: \"]\", class: Some(Class::Attribute) });\n+                    sink(Highlight::Token { text: \"]\", class: None });\n                     sink(Highlight::ExitSpan);\n                     return;\n                 }"}, {"sha": "ebf29f9cb3a91616f151baa53722095c9e7b8f42", "filename": "src/librustdoc/html/highlight/fixtures/decorations.html", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fdecorations.html", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fdecorations.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fdecorations.html?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -1,2 +1,4 @@\n-<span class=\"example\"><span class=\"kw\">let </span>x = <span class=\"number\">1</span>;</span>\n-<span class=\"kw\">let </span>y = <span class=\"number\">2</span>;\n\\ No newline at end of file\n+<span class=\"example\"><span class=\"kw\">let </span>x = <span class=\"number\">1</span>;\n+<span class=\"kw\">let </span>y = <span class=\"number\">2</span>;\n+</span><span class=\"example2\"><span class=\"kw\">let </span>z = <span class=\"number\">3</span>;\n+</span><span class=\"kw\">let </span>a = <span class=\"number\">4</span>;\n\\ No newline at end of file"}, {"sha": "4a5a3cf609cd405956270d3f6c8465e250d73750", "filename": "src/librustdoc/html/highlight/fixtures/sample.html", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.html?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -8,12 +8,13 @@\n .lifetime { color: #B76514; }\n .question-mark { color: #ff9011; }\n </style>\n-<pre><code><span class=\"attribute\">#![crate_type = <span class=\"string\">&quot;lib&quot;</span>]</span>\n+<pre><code><span class=\"attribute\">#![crate_type = <span class=\"string\">&quot;lib&quot;</span>]\n \n-<span class=\"kw\">use </span>std::path::{Path, PathBuf};\n+</span><span class=\"kw\">use </span>std::path::{Path, PathBuf};\n \n-<span class=\"attribute\">#[cfg(target_os = <span class=\"string\">&quot;linux&quot;</span>)]</span>\n-<span class=\"kw\">fn </span>main() -&gt; () {\n+<span class=\"attribute\">#[cfg(target_os = <span class=\"string\">&quot;linux&quot;</span>)]\n+#[cfg(target_os = <span class=\"string\">&quot;windows&quot;</span>)]\n+</span><span class=\"kw\">fn </span>main() -&gt; () {\n     <span class=\"kw\">let </span>foo = <span class=\"bool-val\">true </span>&amp;&amp; <span class=\"bool-val\">false </span>|| <span class=\"bool-val\">true</span>;\n     <span class=\"kw\">let _</span>: <span class=\"kw-2\">*const </span>() = <span class=\"number\">0</span>;\n     <span class=\"kw\">let _ </span>= <span class=\"kw-2\">&amp;</span>foo;\n@@ -22,16 +23,16 @@\n     <span class=\"macro\">mac!</span>(foo, <span class=\"kw-2\">&amp;mut </span>bar);\n     <span class=\"macro\">assert!</span>(<span class=\"self\">self</span>.length &lt; N &amp;&amp; index &lt;= <span class=\"self\">self</span>.length);\n     ::std::env::var(<span class=\"string\">&quot;gateau&quot;</span>).is_ok();\n-    <span class=\"attribute\">#[rustfmt::skip]</span>\n-    <span class=\"kw\">let </span>s:std::path::PathBuf = std::path::PathBuf::new();\n+    <span class=\"attribute\">#[rustfmt::skip]\n+    </span><span class=\"kw\">let </span>s:std::path::PathBuf = std::path::PathBuf::new();\n     <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::new();\n \n     <span class=\"kw\">match </span><span class=\"kw-2\">&amp;</span>s {\n         <span class=\"kw-2\">ref mut </span>x =&gt; {}\n     }\n }\n \n-<span class=\"macro\">macro_rules!</span> bar {\n+<span class=\"macro\">macro_rules! </span>bar {\n     (<span class=\"macro-nonterminal\">$foo</span>:tt) =&gt; {};\n }\n </code></pre>"}, {"sha": "ef85b566cb3c487bf756d212f4a8b5b9d68f6eb1", "filename": "src/librustdoc/html/highlight/fixtures/sample.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ffixtures%2Fsample.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -3,6 +3,7 @@\n use std::path::{Path, PathBuf};\n \n #[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"windows\")]\n fn main() -> () {\n     let foo = true && false || true;\n     let _: *const () = 0;"}, {"sha": "a5e633df4344820f4b140d3f6d5714ad9df8e7a7", "filename": "src/librustdoc/html/highlight/tests.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -69,9 +69,12 @@ fn test_union_highlighting() {\n fn test_decorations() {\n     create_default_session_globals_then(|| {\n         let src = \"let x = 1;\n-let y = 2;\";\n+let y = 2;\n+let z = 3;\n+let a = 4;\";\n         let mut decorations = FxHashMap::default();\n-        decorations.insert(\"example\", vec![(0, 10)]);\n+        decorations.insert(\"example\", vec![(0, 10), (11, 21)]);\n+        decorations.insert(\"example2\", vec![(22, 32)]);\n \n         let mut html = Buffer::new();\n         write_code(&mut html, src, None, Some(DecorationInfo(decorations)));"}, {"sha": "0f3b465d08d4f13bdb831217333da782521f86a2", "filename": "src/test/assembly/x86_64-floating-point-clamp.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Ftest%2Fassembly%2Fx86_64-floating-point-clamp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Ftest%2Fassembly%2Fx86_64-floating-point-clamp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fx86_64-floating-point-clamp.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -0,0 +1,25 @@\n+// Floating-point clamp is designed to be implementable as max+min,\n+// so check to make sure that's what it's actually emitting.\n+\n+// assembly-output: emit-asm\n+// compile-flags: --crate-type=lib -O -C llvm-args=-x86-asm-syntax=intel\n+// only-x86_64\n+\n+// CHECK-LABEL: clamp_demo:\n+#[no_mangle]\n+pub fn clamp_demo(a: f32, x: f32, y: f32) -> f32 {\n+    // CHECK: maxss\n+    // CHECK: minss\n+    a.clamp(x, y)\n+}\n+\n+// CHECK-LABEL: clamp12_demo:\n+#[no_mangle]\n+pub fn clamp12_demo(a: f32) -> f32 {\n+    // CHECK: movss   xmm1\n+    // CHECK-NEXT: maxss   xmm1, xmm0\n+    // CHECK-NEXT: movss   xmm0\n+    // CHECK-NEXT: minss   xmm0, xmm1\n+    // CHECK: ret\n+    a.clamp(1.0, 2.0)\n+}"}, {"sha": "bcfe2f9af50bdeab63b71f70a655935165490c65", "filename": "src/test/codegen/pic-relocation-model.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Ftest%2Fcodegen%2Fpic-relocation-model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Ftest%2Fcodegen%2Fpic-relocation-model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpic-relocation-model.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -13,4 +13,4 @@ pub fn call_foreign_fn() -> u8 {\n // CHECK: declare zeroext i8 @foreign_fn()\n extern \"C\" {fn foreign_fn() -> u8;}\n \n-// CHECK: !{i32 7, !\"PIC Level\", i32 2}\n+// CHECK: !{i32 {{[78]}}, !\"PIC Level\", i32 2}"}, {"sha": "ec44edc0667741ad863b968aa99141a040f77963", "filename": "src/test/codegen/pie-relocation-model.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Ftest%2Fcodegen%2Fpie-relocation-model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Ftest%2Fcodegen%2Fpie-relocation-model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpie-relocation-model.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -18,5 +18,5 @@ pub fn call_foreign_fn() -> u8 {\n // CHECK: declare zeroext i8 @foreign_fn()\n extern \"C\" {fn foreign_fn() -> u8;}\n \n-// CHECK: !{i32 7, !\"PIC Level\", i32 2}\n+// CHECK: !{i32 {{[78]}}, !\"PIC Level\", i32 2}\n // CHECK: !{i32 7, !\"PIE Level\", i32 2}"}, {"sha": "89987491d1b46cbcc47fd36d1977d84202e65387", "filename": "src/test/rustdoc/issue-41783.codeblock.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Ftest%2Frustdoc%2Fissue-41783.codeblock.html", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Ftest%2Frustdoc%2Fissue-41783.codeblock.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-41783.codeblock.html?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -1,5 +1,5 @@\n <code># single\n ## double\n ### triple\n-<span class=\"attribute\">#[outer]</span>\n-<span class=\"attribute\">#![inner]</span></code>\n\\ No newline at end of file\n+<span class=\"attribute\">#[outer]\n+#![inner]</span></code>"}, {"sha": "87267a750c6151b1079e4d75948168b0a2cb1059", "filename": "src/test/rustdoc/issue-41783.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Ftest%2Frustdoc%2Fissue-41783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01/src%2Ftest%2Frustdoc%2Fissue-41783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-41783.rs?ref=c0941dfb5a7d07ef2d70cc54d319669d9d6f6c01", "patch": "@@ -1,8 +1,10 @@\n // @has issue_41783/struct.Foo.html\n // @!hasraw - 'space'\n // @!hasraw - 'comment'\n-// @hasraw - '<span class=\"attribute\">#[outer]</span>'\n-// @hasraw - '<span class=\"attribute\">#![inner]</span>'\n+// @hasraw - '<span class=\"attribute\">#[outer]'\n+// @!hasraw - '<span class=\"attribute\">#[outer]</span>'\n+// @hasraw - '#![inner]</span>'\n+// @!hasraw - '<span class=\"attribute\">#![inner]</span>'\n // @snapshot 'codeblock' - '//*[@class=\"rustdoc-toggle top-doc\"]/*[@class=\"docblock\"]//pre/code'\n \n /// ```no_run"}]}