{"sha": "84f5ad8679c7fc454473ffbf389030f3e5fee379", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ZjVhZDg2NzljN2ZjNDU0NDczZmZiZjM4OTAzMGYzZTVmZWUzNzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-30T17:51:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-30T17:51:21Z"}, "message": "auto merge of #20307 : nikomatsakis/rust/assoc-types-normalization-extend-bound, r=nrc\n\nRewrite associated types to use projection rather than dummy type parameters. This closes almost every (major) open issue, but I'm holding off on that until the code has landed and baked a bit. Probably it should have more tests, as well, but I wanted to get this landed as fast as possible so that we can collaborate on improving it.\r\n\r\nThe commit history is a little messy, particularly the merge commit at the end. If I get some time, I might just \"reset\" to the beginning and try to carve up the final state into logical pieces. Let me know if it seems hard to follow. By far the most crucial commit is \"Implement associated type projection and normalization.\"\r\n\r\nr? @nick29581", "tree": {"sha": "0ff540834e21c0927e1efa8bad5f4f37fac86286", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ff540834e21c0927e1efa8bad5f4f37fac86286"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84f5ad8679c7fc454473ffbf389030f3e5fee379", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84f5ad8679c7fc454473ffbf389030f3e5fee379", "html_url": "https://github.com/rust-lang/rust/commit/84f5ad8679c7fc454473ffbf389030f3e5fee379", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84f5ad8679c7fc454473ffbf389030f3e5fee379/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "023dfb0c898d851dee6ace2f8339b73b5287136b", "url": "https://api.github.com/repos/rust-lang/rust/commits/023dfb0c898d851dee6ace2f8339b73b5287136b", "html_url": "https://github.com/rust-lang/rust/commit/023dfb0c898d851dee6ace2f8339b73b5287136b"}, {"sha": "e186accbc43dad8c340112fc39d8df924a9a79e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e186accbc43dad8c340112fc39d8df924a9a79e9", "html_url": "https://github.com/rust-lang/rust/commit/e186accbc43dad8c340112fc39d8df924a9a79e9"}], "stats": {"total": 8627, "additions": 5519, "deletions": 3108}, "files": [{"sha": "2a58da8cb3be78825b8ccba819e692c144bdea25", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -256,3 +256,6 @@ pub const tag_predicate_space: uint = 0xa9;\n pub const tag_predicate_data: uint = 0xb0;\n \n pub const tag_unsafety: uint = 0xb1;\n+\n+pub const tag_associated_type_names: uint = 0xb2;\n+pub const tag_associated_type_name: uint = 0xb3;"}, {"sha": "0cbc94f379d80394e17ea054dbcdce97bb81b603", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -226,7 +226,7 @@ pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: ast::DefId) -> HashM\n \n pub fn get_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       def: ast::DefId)\n-                      -> ty::Polytype<'tcx> {\n+                      -> ty::TypeScheme<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_type(&*cdata, def.node, tcx)\n@@ -239,7 +239,7 @@ pub fn get_trait_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> ty::TraitDe\n }\n \n pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n-                            def: ast::DefId) -> ty::Polytype<'tcx> {\n+                            def: ast::DefId) -> ty::TypeScheme<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(class_id.krate);\n     let all_items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_items);\n@@ -257,7 +257,7 @@ pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n                     def)).to_string()\n         });\n     let ty = decoder::item_type(def, the_field, tcx, &*cdata);\n-    ty::Polytype {\n+    ty::TypeScheme {\n         generics: ty::Generics::empty(),\n         ty: ty,\n     }"}, {"sha": "a168ac7fa9a78b4395ad8effabbe42fe23386256", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -172,14 +172,15 @@ fn item_visibility(item: rbml::Doc) -> ast::Visibility {\n }\n \n fn item_sort(item: rbml::Doc) -> char {\n-    // NB(pcwalton): The default of 'r' here is relied upon in\n-    // `is_associated_type` below.\n-    let mut ret = 'r';\n+    let mut ret = None;\n     reader::tagged_docs(item, tag_item_trait_item_sort, |doc| {\n-        ret = doc.as_str_slice().as_bytes()[0] as char;\n+        ret = Some(doc.as_str_slice().as_bytes()[0] as char);\n         false\n     });\n-    ret\n+    match ret {\n+        Some(r) => r,\n+        None => panic!(\"No item_sort found\")\n+    }\n }\n \n fn item_symbol(item: rbml::Doc) -> String {\n@@ -245,13 +246,13 @@ pub fn item_type<'tcx>(_item_id: ast::DefId, item: rbml::Doc,\n }\n \n fn doc_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n-                       -> ty::TraitRef<'tcx> {\n+                       -> Rc<ty::TraitRef<'tcx>> {\n     parse_trait_ref_data(doc.data, cdata.cnum, doc.start, tcx,\n                          |_, did| translate_def_id(cdata, did))\n }\n \n fn item_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n-                        -> ty::TraitRef<'tcx> {\n+                        -> Rc<ty::TraitRef<'tcx>> {\n     let tp = reader::get_doc(doc, tag_item_trait_ref);\n     doc_trait_ref(tp, tcx, cdata)\n }\n@@ -369,6 +370,17 @@ fn parse_unsafety(item_doc: rbml::Doc) -> ast::Unsafety {\n     }\n }\n \n+fn parse_associated_type_names(item_doc: rbml::Doc) -> Vec<ast::Name> {\n+    let names_doc = reader::get_doc(item_doc, tag_associated_type_names);\n+    let mut names = Vec::new();\n+    reader::tagged_docs(names_doc, tag_associated_type_name, |name_doc| {\n+        let name = token::intern(name_doc.as_str_slice());\n+        names.push(name);\n+        true\n+    });\n+    names\n+}\n+\n pub fn get_trait_def<'tcx>(cdata: Cmd,\n                            item_id: ast::NodeId,\n                            tcx: &ty::ctxt<'tcx>) -> ty::TraitDef<'tcx>\n@@ -377,17 +389,19 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n     let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n     let bounds = trait_def_bounds(item_doc, tcx, cdata);\n     let unsafety = parse_unsafety(item_doc);\n+    let associated_type_names = parse_associated_type_names(item_doc);\n \n     ty::TraitDef {\n         unsafety: unsafety,\n         generics: generics,\n         bounds: bounds,\n-        trait_ref: Rc::new(item_trait_ref(item_doc, tcx, cdata))\n+        trait_ref: item_trait_ref(item_doc, tcx, cdata),\n+        associated_type_names: associated_type_names,\n     }\n }\n \n pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n-    -> ty::Polytype<'tcx> {\n+    -> ty::TypeScheme<'tcx> {\n \n     let item = lookup_item(id, cdata.data());\n \n@@ -396,7 +410,7 @@ pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n \n     let generics = doc_generics(item, tcx, cdata, tag_item_generics);\n \n-    ty::Polytype {\n+    ty::TypeScheme {\n         generics: generics,\n         ty: t\n     }\n@@ -428,7 +442,7 @@ pub fn get_impl_trait<'tcx>(cdata: Cmd,\n {\n     let item_doc = lookup_item(id, cdata.data());\n     reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n-        Rc::new(doc_trait_ref(tp, tcx, cdata))\n+        doc_trait_ref(tp, tcx, cdata)\n     })\n }\n \n@@ -924,7 +938,7 @@ pub fn get_supertraits<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n         // FIXME(#8559): The builtin bounds shouldn't be encoded in the first place.\n         let trait_ref = doc_trait_ref(trait_doc, tcx, cdata);\n         if tcx.lang_items.to_builtin_kind(trait_ref.def_id).is_none() {\n-            results.push(Rc::new(trait_ref));\n+            results.push(trait_ref);\n         }\n         true\n     });\n@@ -1353,7 +1367,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n         if spec.len() == 0 { continue }\n         let cnum = spec.split(':').nth(0).unwrap();\n         let link = spec.split(':').nth(1).unwrap();\n-        let cnum = cnum.parse().unwrap();\n+        let cnum: ast::CrateNum = cnum.parse().unwrap();\n         let cnum = match cdata.cnum_map.get(&cnum) {\n             Some(&n) => n,\n             None => panic!(\"didn't find a crate in the cnum_map\")"}, {"sha": "db29d0111f446bd9a431935a5e58fe408695300f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -142,7 +142,7 @@ fn encode_item_variances(rbml_w: &mut Encoder,\n \n fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n                                     ecx: &EncodeContext<'a, 'tcx>,\n-                                    pty: &ty::Polytype<'tcx>) {\n+                                    pty: &ty::TypeScheme<'tcx>) {\n     encode_generics(rbml_w, ecx, &pty.generics, tag_item_generics);\n     encode_type(ecx, rbml_w, pty.ty);\n }\n@@ -898,7 +898,10 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     encode_visibility(rbml_w, associated_type.vis);\n     encode_family(rbml_w, 'y');\n     encode_parent_item(rbml_w, local_def(parent_id));\n-    encode_item_sort(rbml_w, 'r');\n+    encode_item_sort(rbml_w, 't');\n+\n+    let type_scheme = ty::lookup_item_type(ecx.tcx, associated_type.def_id);\n+    encode_bounds_and_type(rbml_w, ecx, &type_scheme);\n \n     let stab = stability::lookup(ecx.tcx, associated_type.def_id);\n     encode_stability(rbml_w, stab);\n@@ -1316,6 +1319,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_item_variances(rbml_w, ecx, item.id);\n         let trait_def = ty::lookup_trait_def(tcx, def_id);\n         encode_unsafety(rbml_w, trait_def.unsafety);\n+        encode_associated_type_names(rbml_w, trait_def.associated_type_names.as_slice());\n         encode_generics(rbml_w, ecx, &trait_def.generics, tag_item_generics);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n@@ -1397,10 +1401,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         ty::StaticExplicitSelfCategory;\n                 }\n                 ty::TypeTraitItem(associated_type) => {\n+                    encode_name(rbml_w, associated_type.name);\n+\n                     let elem = ast_map::PathName(associated_type.name);\n                     encode_path(rbml_w,\n                                 path.clone().chain(Some(elem).into_iter()));\n \n+                    encode_item_sort(rbml_w, 't');\n                     encode_family(rbml_w, 'y');\n \n                     is_nonstatic_method = false;\n@@ -1689,6 +1696,14 @@ fn encode_unsafety(rbml_w: &mut Encoder, unsafety: ast::Unsafety) {\n     rbml_w.wr_tagged_u8(tag_unsafety, byte);\n }\n \n+fn encode_associated_type_names(rbml_w: &mut Encoder, names: &[ast::Name]) {\n+    rbml_w.start_tag(tag_associated_type_names);\n+    for &name in names.iter() {\n+        rbml_w.wr_tagged_str(tag_associated_type_name, token::get_name(name).get());\n+    }\n+    rbml_w.end_tag();\n+}\n+\n fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n     fn get_ordered_deps(cstore: &cstore::CStore) -> Vec<decoder::CrateDep> {\n         // Pull the cnums and name,vers,hash out of cstore"}, {"sha": "88c7ccf1b1e36e4860264db404f2d07c29a0bddc", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 82, "deletions": 52, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -180,7 +180,7 @@ pub fn parse_bare_fn_ty_data<'tcx>(data: &[u8], crate_num: ast::CrateNum, pos: u\n \n pub fn parse_trait_ref_data<'tcx>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n                                   tcx: &ty::ctxt<'tcx>, conv: conv_did)\n-                                  -> ty::TraitRef<'tcx> {\n+                                  -> Rc<ty::TraitRef<'tcx>> {\n     debug!(\"parse_trait_ref_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_trait_ref(&mut st, conv)\n@@ -200,9 +200,9 @@ pub fn parse_bounds_data<'tcx>(data: &[u8], crate_num: ast::CrateNum,\n     parse_bounds(&mut st, conv)\n }\n \n-pub fn parse_existential_bounds_data(data: &[u8], crate_num: ast::CrateNum,\n-                                     pos: uint, tcx: &ty::ctxt, conv: conv_did)\n-                                     -> ty::ExistentialBounds {\n+pub fn parse_existential_bounds_data<'tcx>(data: &[u8], crate_num: ast::CrateNum,\n+                                           pos: uint, tcx: &ty::ctxt<'tcx>, conv: conv_did)\n+                                           -> ty::ExistentialBounds<'tcx> {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_existential_bounds(&mut st, conv)\n }\n@@ -377,89 +377,90 @@ fn parse_str(st: &mut PState, term: char) -> String {\n }\n \n fn parse_trait_ref<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n-                             -> ty::TraitRef<'tcx> {\n+                             -> Rc<ty::TraitRef<'tcx>> {\n     let def = parse_def(st, NominalType, |x,y| conv(x,y));\n-    let substs = parse_substs(st, |x,y| conv(x,y));\n-    ty::TraitRef {def_id: def, substs: st.tcx.mk_substs(substs)}\n+    let substs = st.tcx.mk_substs(parse_substs(st, |x,y| conv(x,y)));\n+    Rc::new(ty::TraitRef {def_id: def, substs: substs})\n }\n \n fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n+    let tcx = st.tcx;\n     match next(st) {\n-      'b' => return ty::mk_bool(),\n-      'i' => return ty::mk_int(),\n-      'u' => return ty::mk_uint(),\n+      'b' => return tcx.types.bool,\n+      'i' => return tcx.types.int,\n+      'u' => return tcx.types.uint,\n       'M' => {\n         match next(st) {\n-          'b' => return ty::mk_mach_uint(ast::TyU8),\n-          'w' => return ty::mk_mach_uint(ast::TyU16),\n-          'l' => return ty::mk_mach_uint(ast::TyU32),\n-          'd' => return ty::mk_mach_uint(ast::TyU64),\n-          'B' => return ty::mk_mach_int(ast::TyI8),\n-          'W' => return ty::mk_mach_int(ast::TyI16),\n-          'L' => return ty::mk_mach_int(ast::TyI32),\n-          'D' => return ty::mk_mach_int(ast::TyI64),\n-          'f' => return ty::mk_mach_float(ast::TyF32),\n-          'F' => return ty::mk_mach_float(ast::TyF64),\n+          'b' => return tcx.types.u8,\n+          'w' => return tcx.types.u16,\n+          'l' => return tcx.types.u32,\n+          'd' => return tcx.types.u64,\n+          'B' => return tcx.types.i8,\n+          'W' => return tcx.types.i16,\n+          'L' => return tcx.types.i32,\n+          'D' => return tcx.types.i64,\n+          'f' => return tcx.types.f32,\n+          'F' => return tcx.types.f64,\n           _ => panic!(\"parse_ty: bad numeric type\")\n         }\n       }\n-      'c' => return ty::mk_char(),\n+      'c' => return tcx.types.char,\n       't' => {\n         assert_eq!(next(st), '[');\n         let def = parse_def(st, NominalType, |x,y| conv(x,y));\n         let substs = parse_substs(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n-        return ty::mk_enum(st.tcx, def, st.tcx.mk_substs(substs));\n+        return ty::mk_enum(tcx, def, st.tcx.mk_substs(substs));\n       }\n       'x' => {\n         assert_eq!(next(st), '[');\n         let trait_ref = ty::Binder(parse_trait_ref(st, |x,y| conv(x,y)));\n         let bounds = parse_existential_bounds(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n-        return ty::mk_trait(st.tcx, trait_ref, bounds);\n+        return ty::mk_trait(tcx, trait_ref, bounds);\n       }\n       'p' => {\n-        let did = parse_def(st, TypeParameter, |x,y| conv(x,y));\n-        debug!(\"parsed ty_param: did={}\", did);\n+        assert_eq!(next(st), '[');\n         let index = parse_u32(st);\n         assert_eq!(next(st), '|');\n         let space = parse_param_space(st);\n         assert_eq!(next(st), '|');\n-        return ty::mk_param(st.tcx, space, index, did);\n+        let name = token::intern(parse_str(st, ']')[]);\n+        return ty::mk_param(tcx, space, index, name);\n       }\n-      '~' => return ty::mk_uniq(st.tcx, parse_ty(st, |x,y| conv(x,y))),\n-      '*' => return ty::mk_ptr(st.tcx, parse_mt(st, |x,y| conv(x,y))),\n+      '~' => return ty::mk_uniq(tcx, parse_ty(st, |x,y| conv(x,y))),\n+      '*' => return ty::mk_ptr(tcx, parse_mt(st, |x,y| conv(x,y))),\n       '&' => {\n         let r = parse_region(st, |x,y| conv(x,y));\n         let mt = parse_mt(st, |x,y| conv(x,y));\n-        return ty::mk_rptr(st.tcx, st.tcx.mk_region(r), mt);\n+        return ty::mk_rptr(tcx, tcx.mk_region(r), mt);\n       }\n       'V' => {\n         let t = parse_ty(st, |x,y| conv(x,y));\n         let sz = parse_size(st);\n-        return ty::mk_vec(st.tcx, t, sz);\n+        return ty::mk_vec(tcx, t, sz);\n       }\n       'v' => {\n-        return ty::mk_str(st.tcx);\n+        return ty::mk_str(tcx);\n       }\n       'T' => {\n         assert_eq!(next(st), '[');\n         let mut params = Vec::new();\n         while peek(st) != ']' { params.push(parse_ty(st, |x,y| conv(x,y))); }\n         st.pos = st.pos + 1u;\n-        return ty::mk_tup(st.tcx, params);\n+        return ty::mk_tup(tcx, params);\n       }\n       'f' => {\n-        return ty::mk_closure(st.tcx, parse_closure_ty(st, |x,y| conv(x,y)));\n+        return ty::mk_closure(tcx, parse_closure_ty(st, |x,y| conv(x,y)));\n       }\n       'F' => {\n           let def_id = parse_def(st, NominalType, |x,y| conv(x,y));\n-          return ty::mk_bare_fn(st.tcx, Some(def_id),\n-                                st.tcx.mk_bare_fn(parse_bare_fn_ty(st, |x,y| conv(x,y))));\n+          return ty::mk_bare_fn(tcx, Some(def_id),\n+                                tcx.mk_bare_fn(parse_bare_fn_ty(st, |x,y| conv(x,y))));\n       }\n       'G' => {\n-          return ty::mk_bare_fn(st.tcx, None,\n-                                st.tcx.mk_bare_fn(parse_bare_fn_ty(st, |x,y| conv(x,y))));\n+          return ty::mk_bare_fn(tcx, None,\n+                                tcx.mk_bare_fn(parse_bare_fn_ty(st, |x,y| conv(x,y))));\n       }\n       '#' => {\n         let pos = parse_hex(st);\n@@ -470,7 +471,7 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n                                          pos: pos,\n                                          len: len };\n \n-        match st.tcx.rcache.borrow().get(&key).cloned() {\n+        match tcx.rcache.borrow().get(&key).cloned() {\n           Some(tt) => return tt,\n           None => {}\n         }\n@@ -479,7 +480,7 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n             .. *st\n         };\n         let tt = parse_ty(&mut ps, |x,y| conv(x,y));\n-        st.tcx.rcache.borrow_mut().insert(key, tt);\n+        tcx.rcache.borrow_mut().insert(key, tt);\n         return tt;\n       }\n       '\\\"' => {\n@@ -503,8 +504,14 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n           return ty::mk_unboxed_closure(st.tcx, did,\n                   st.tcx.mk_region(region), st.tcx.mk_substs(substs));\n       }\n+      'P' => {\n+          assert_eq!(next(st), '[');\n+          let trait_ref = parse_trait_ref(st, |x,y| conv(x,y));\n+          let name = token::intern(parse_str(st, ']').as_slice());\n+          return ty::mk_projection(tcx, trait_ref, name);\n+      }\n       'e' => {\n-          return ty::mk_err();\n+          return tcx.types.err;\n       }\n       c => { panic!(\"unexpected char in type string: {}\", c);}\n     }\n@@ -682,17 +689,32 @@ pub fn parse_predicate<'a,'tcx>(st: &mut PState<'a, 'tcx>,\n                                 -> ty::Predicate<'tcx>\n {\n     match next(st) {\n-        't' => Rc::new(ty::Binder(parse_trait_ref(st, conv))).as_predicate(),\n+        't' => ty::Binder(parse_trait_ref(st, conv)).as_predicate(),\n         'e' => ty::Binder(ty::EquatePredicate(parse_ty(st, |x,y| conv(x,y)),\n                                               parse_ty(st, |x,y| conv(x,y)))).as_predicate(),\n         'r' => ty::Binder(ty::OutlivesPredicate(parse_region(st, |x,y| conv(x,y)),\n                                                 parse_region(st, |x,y| conv(x,y)))).as_predicate(),\n         'o' => ty::Binder(ty::OutlivesPredicate(parse_ty(st, |x,y| conv(x,y)),\n                                                 parse_region(st, |x,y| conv(x,y)))).as_predicate(),\n+        'p' => ty::Binder(parse_projection_predicate(st, conv)).as_predicate(),\n         c => panic!(\"Encountered invalid character in metadata: {}\", c)\n     }\n }\n \n+fn parse_projection_predicate<'a,'tcx>(\n+    st: &mut PState<'a, 'tcx>,\n+    conv: conv_did)\n+     -> ty::ProjectionPredicate<'tcx>\n+{\n+    ty::ProjectionPredicate {\n+        projection_ty: ty::ProjectionTy {\n+            trait_ref: parse_trait_ref(st, |x,y| conv(x,y)),\n+            item_name: token::str_to_ident(parse_str(st, '|').as_slice()).name,\n+        },\n+        ty: parse_ty(st, |x,y| conv(x,y)),\n+    }\n+}\n+\n pub fn parse_type_param_def_data<'tcx>(data: &[u8], start: uint,\n                                        crate_num: ast::CrateNum, tcx: &ty::ctxt<'tcx>,\n                                        conv: conv_did) -> ty::TypeParameterDef<'tcx>\n@@ -709,10 +731,6 @@ fn parse_type_param_def<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n     assert_eq!(next(st), '|');\n     let index = parse_u32(st);\n     assert_eq!(next(st), '|');\n-    let associated_with = parse_opt(st, |st| {\n-        parse_def(st, NominalType, |x,y| conv(x,y))\n-    });\n-    assert_eq!(next(st), '|');\n     let bounds = parse_bounds(st, |x,y| conv(x,y));\n     let default = parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)));\n \n@@ -721,16 +739,23 @@ fn parse_type_param_def<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n         def_id: def_id,\n         space: space,\n         index: index,\n-        associated_with: associated_with,\n         bounds: bounds,\n         default: default\n     }\n }\n \n-fn parse_existential_bounds(st: &mut PState, conv: conv_did) -> ty::ExistentialBounds {\n-    let r = parse_region(st, |x,y| conv(x,y));\n-    let bb = parse_builtin_bounds(st, conv);\n-    return ty::ExistentialBounds { region_bound: r, builtin_bounds: bb };\n+fn parse_existential_bounds<'a,'tcx>(st: &mut PState<'a,'tcx>,\n+                                     conv: conv_did)\n+                                     -> ty::ExistentialBounds<'tcx>\n+{\n+    let ty::ParamBounds { trait_bounds, mut region_bounds, builtin_bounds, projection_bounds } =\n+         parse_bounds(st, conv);\n+    assert_eq!(region_bounds.len(), 1);\n+    assert_eq!(trait_bounds.len(), 0);\n+    let region_bound = region_bounds.pop().unwrap();\n+    return ty::ExistentialBounds { region_bound: region_bound,\n+                                   builtin_bounds: builtin_bounds,\n+                                   projection_bounds: projection_bounds };\n }\n \n fn parse_builtin_bounds(st: &mut PState, _conv: conv_did) -> ty::BuiltinBounds {\n@@ -767,7 +792,8 @@ fn parse_bounds<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n     let mut param_bounds = ty::ParamBounds {\n         region_bounds: Vec::new(),\n         builtin_bounds: builtin_bounds,\n-        trait_bounds: Vec::new()\n+        trait_bounds: Vec::new(),\n+        projection_bounds: Vec::new(),\n     };\n     loop {\n         match next(st) {\n@@ -777,7 +803,11 @@ fn parse_bounds<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n             }\n             'I' => {\n                 param_bounds.trait_bounds.push(\n-                    Rc::new(ty::Binder(parse_trait_ref(st, |x,y| conv(x,y)))));\n+                    ty::Binder(parse_trait_ref(st, |x,y| conv(x,y))));\n+            }\n+            'P' => {\n+                param_bounds.projection_bounds.push(\n+                    ty::Binder(parse_projection_predicate(st, |x,y| conv(x,y))));\n             }\n             '.' => {\n                 return param_bounds;"}, {"sha": "30746f51a8fe70dcf5a84e044d488e03c525e3a3", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -91,7 +91,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         ty::ty_trait(box ty::TyTrait { ref principal,\n                                        ref bounds }) => {\n             mywrite!(w, \"x[\");\n-            enc_trait_ref(w, cx, &principal.0);\n+            enc_trait_ref(w, cx, &*principal.0);\n             enc_existential_bounds(w, cx, bounds);\n             mywrite!(w, \"]\");\n         }\n@@ -135,8 +135,8 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n         ty::ty_infer(_) => {\n             cx.diag.handler().bug(\"cannot encode inference variable types\");\n         }\n-        ty::ty_param(ParamTy {space, idx: id, def_id: did}) => {\n-            mywrite!(w, \"p{}|{}|{}|\", (cx.ds)(did), id, space.to_uint())\n+        ty::ty_param(ParamTy {space, idx, name}) => {\n+            mywrite!(w, \"p[{}|{}|{}]\", idx, space.to_uint(), token::get_name(name))\n         }\n         ty::ty_struct(def, substs) => {\n             mywrite!(w, \"a[{}|\", (cx.ds)(def));\n@@ -149,6 +149,11 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n+        ty::ty_projection(ref data) => {\n+            mywrite!(w, \"P[\");\n+            enc_trait_ref(w, cx, &*data.trait_ref);\n+            mywrite!(w, \"{}]\", token::get_name(data.item_name));\n+        }\n         ty::ty_err => {\n             mywrite!(w, \"e\");\n         }\n@@ -387,9 +392,14 @@ pub fn enc_builtin_bounds(w: &mut SeekableMemWriter, _cx: &ctxt, bs: &ty::Builti\n     mywrite!(w, \".\");\n }\n \n-pub fn enc_existential_bounds(w: &mut SeekableMemWriter, cx: &ctxt, bs: &ty::ExistentialBounds) {\n-    enc_region(w, cx, bs.region_bound);\n-    enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n+pub fn enc_existential_bounds<'a,'tcx>(w: &mut SeekableMemWriter,\n+                                       cx: &ctxt<'a,'tcx>,\n+                                       bs: &ty::ExistentialBounds<'tcx>) {\n+    let param_bounds = ty::ParamBounds { trait_bounds: vec!(),\n+                                         region_bounds: vec!(bs.region_bound),\n+                                         builtin_bounds: bs.builtin_bounds,\n+                                         projection_bounds: bs.projection_bounds.clone() };\n+    enc_bounds(w, cx, &param_bounds);\n }\n \n pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n@@ -403,7 +413,12 @@ pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n \n     for tp in bs.trait_bounds.iter() {\n         mywrite!(w, \"I\");\n-        enc_trait_ref(w, cx, &tp.0);\n+        enc_trait_ref(w, cx, &*tp.0);\n+    }\n+\n+    for tp in bs.projection_bounds.iter() {\n+        mywrite!(w, \"P\");\n+        enc_projection_predicate(w, cx, &tp.0);\n     }\n \n     mywrite!(w, \".\");\n@@ -414,8 +429,6 @@ pub fn enc_type_param_def<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tc\n     mywrite!(w, \"{}:{}|{}|{}|\",\n              token::get_name(v.name), (cx.ds)(v.def_id),\n              v.space.to_uint(), v.index);\n-    enc_opt(w, v.associated_with, |w, did| mywrite!(w, \"{}\", (cx.ds)(did)));\n-    mywrite!(w, \"|\");\n     enc_bounds(w, cx, &v.bounds);\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n }\n@@ -427,7 +440,7 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n     match *p {\n         ty::Predicate::Trait(ref trait_ref) => {\n             mywrite!(w, \"t\");\n-            enc_trait_ref(w, cx, &trait_ref.0);\n+            enc_trait_ref(w, cx, &*trait_ref.0.trait_ref);\n         }\n         ty::Predicate::Equate(ty::Binder(ty::EquatePredicate(a, b))) => {\n             mywrite!(w, \"e\");\n@@ -444,5 +457,17 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n             enc_ty(w, cx, a);\n             enc_region(w, cx, b);\n         }\n+        ty::Predicate::Projection(ty::Binder(ref data)) => {\n+            mywrite!(w, \"p\");\n+            enc_projection_predicate(w, cx, data)\n+        }\n     }\n }\n+\n+fn enc_projection_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n+                                      cx: &ctxt<'a, 'tcx>,\n+                                      data: &ty::ProjectionPredicate<'tcx>) {\n+    enc_trait_ref(w, cx, &*data.projection_ty.trait_ref);\n+    mywrite!(w, \"{}|\", token::get_name(data.projection_ty.item_name));\n+    enc_ty(w, cx, data.ty);\n+}"}, {"sha": "b1b4fd831a0fa97ccc19838c485b4e2f02baffc6", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -57,23 +57,23 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n                     match nty {\n                         ast::TyBool => {\n                             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_bool())\n+                            Some(tcx.types.bool)\n                         }\n                         ast::TyChar => {\n                             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_char())\n+                            Some(tcx.types.char)\n                         }\n                         ast::TyInt(it) => {\n                             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_mach_int(it))\n+                            Some(ty::mk_mach_int(tcx, it))\n                         }\n                         ast::TyUint(uit) => {\n                             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_mach_uint(uit))\n+                            Some(ty::mk_mach_uint(tcx, uit))\n                         }\n                         ast::TyFloat(ft) => {\n                             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_mach_float(ft))\n+                            Some(ty::mk_mach_float(tcx, ft))\n                         }\n                         ast::TyStr => {\n                             Some(ty::mk_str(tcx))"}, {"sha": "6efc80ed8d343f4ed295afdd671890977352a026", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -448,7 +448,7 @@ impl tr for def::Def {\n           def::DefAssociatedPath(def::TyParamProvenance::FromParam(did), ident) =>\n               def::DefAssociatedPath(def::TyParamProvenance::FromParam(did.tr(dcx)), ident),\n           def::DefPrimTy(p) => def::DefPrimTy(p),\n-          def::DefTyParam(s, did, v) => def::DefTyParam(s, did.tr(dcx), v),\n+          def::DefTyParam(s, index, def_id, n) => def::DefTyParam(s, index, def_id.tr(dcx), n),\n           def::DefUse(did) => def::DefUse(did.tr(dcx)),\n           def::DefUpvar(nid1, nid2, nid3) => {\n             def::DefUpvar(dcx.tr_id(nid1),\n@@ -707,9 +707,8 @@ impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     {\n         let types = self.read_to_vec(|this| Ok(f(this))).unwrap();\n         let selfs = self.read_to_vec(|this| Ok(f(this))).unwrap();\n-        let assocs = self.read_to_vec(|this| Ok(f(this))).unwrap();\n         let fns = self.read_to_vec(|this| Ok(f(this))).unwrap();\n-        VecPerParamSpace::new(types, selfs, assocs, fns)\n+        VecPerParamSpace::new(types, selfs, fns)\n     }\n \n     fn read_vtable_res_with_key(&mut self,\n@@ -838,11 +837,12 @@ trait rbml_writer_helpers<'tcx> {\n                           predicate: &ty::Predicate<'tcx>);\n     fn emit_trait_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                           ty: &ty::TraitRef<'tcx>);\n-    fn emit_polytype<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                         pty: ty::Polytype<'tcx>);\n+    fn emit_type_scheme<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                            type_scheme: ty::TypeScheme<'tcx>);\n     fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                        substs: &subst::Substs<'tcx>);\n-    fn emit_existential_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::ExistentialBounds);\n+    fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n+                                   bounds: &ty::ExistentialBounds<'tcx>);\n     fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds);\n     fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                                 adj: &ty::AutoAdjustment<'tcx>);\n@@ -951,38 +951,39 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_polytype<'b>(&mut self,\n-                         ecx: &e::EncodeContext<'b, 'tcx>,\n-                         pty: ty::Polytype<'tcx>) {\n+    fn emit_type_scheme<'b>(&mut self,\n+                            ecx: &e::EncodeContext<'b, 'tcx>,\n+                            type_scheme: ty::TypeScheme<'tcx>) {\n         use serialize::Encoder;\n \n-        self.emit_struct(\"Polytype\", 2, |this| {\n+        self.emit_struct(\"TypeScheme\", 2, |this| {\n             this.emit_struct_field(\"generics\", 0, |this| {\n                 this.emit_struct(\"Generics\", 2, |this| {\n                     this.emit_struct_field(\"types\", 0, |this| {\n                         Ok(encode_vec_per_param_space(\n-                            this, &pty.generics.types,\n+                            this, &type_scheme.generics.types,\n                             |this, def| this.emit_type_param_def(ecx, def)))\n                     });\n                     this.emit_struct_field(\"regions\", 1, |this| {\n                         Ok(encode_vec_per_param_space(\n-                            this, &pty.generics.regions,\n+                            this, &type_scheme.generics.regions,\n                             |this, def| def.encode(this).unwrap()))\n                     });\n                     this.emit_struct_field(\"predicates\", 2, |this| {\n                         Ok(encode_vec_per_param_space(\n-                            this, &pty.generics.predicates,\n+                            this, &type_scheme.generics.predicates,\n                             |this, def| this.emit_predicate(ecx, def)))\n                     })\n                 })\n             });\n             this.emit_struct_field(\"ty\", 1, |this| {\n-                Ok(this.emit_ty(ecx, pty.ty))\n+                Ok(this.emit_ty(ecx, type_scheme.ty))\n             })\n         });\n     }\n \n-    fn emit_existential_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::ExistentialBounds) {\n+    fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n+                                   bounds: &ty::ExistentialBounds<'tcx>) {\n         self.emit_opaque(|this| Ok(tyencode::enc_existential_bounds(this.writer,\n                                                                     &ecx.ty_str_ctxt(),\n                                                                     bounds)));\n@@ -1120,7 +1121,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     this.emit_enum_variant(\"UnsizeVtable\", 2, 4, |this| {\n                         this.emit_enum_variant_arg(0, |this| {\n                             try!(this.emit_struct_field(\"principal\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &principal.0))\n+                                Ok(this.emit_trait_ref(ecx, &*principal.0))\n                             }));\n                             this.emit_struct_field(\"bounds\", 1, |this| {\n                                 Ok(this.emit_existential_bounds(ecx, b))\n@@ -1252,11 +1253,11 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n-    for &pty in tcx.tcache.borrow().get(&lid).iter() {\n+    for &type_scheme in tcx.tcache.borrow().get(&lid).iter() {\n         rbml_w.tag(c::tag_table_tcache, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_polytype(ecx, pty.clone());\n+                rbml_w.emit_type_scheme(ecx, type_scheme.clone());\n             })\n         })\n     }\n@@ -1284,7 +1285,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         rbml_w.tag(c::tag_table_object_cast_map, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_trait_ref(ecx, &trait_ref.0);\n+                rbml_w.emit_trait_ref(ecx, &*trait_ref.0);\n             })\n         })\n     }\n@@ -1364,15 +1365,15 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n     fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                               -> Rc<ty::TraitRef<'tcx>>;\n     fn read_poly_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                   -> Rc<ty::PolyTraitRef<'tcx>>;\n+                                   -> ty::PolyTraitRef<'tcx>;\n     fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                    -> ty::TypeParameterDef<'tcx>;\n     fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                               -> ty::Predicate<'tcx>;\n-    fn read_polytype<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                             -> ty::Polytype<'tcx>;\n+    fn read_type_scheme<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                -> ty::TypeScheme<'tcx>;\n     fn read_existential_bounds<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                       -> ty::ExistentialBounds;\n+                                       -> ty::ExistentialBounds<'tcx>;\n     fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                            -> subst::Substs<'tcx>;\n     fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1546,28 +1547,28 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n \n     fn read_trait_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                               -> Rc<ty::TraitRef<'tcx>> {\n-        Rc::new(self.read_opaque(|this, doc| {\n+        self.read_opaque(|this, doc| {\n             let ty = tydecode::parse_trait_ref_data(\n                 doc.data,\n                 dcx.cdata.cnum,\n                 doc.start,\n                 dcx.tcx,\n                 |s, a| this.convert_def_id(dcx, s, a));\n             Ok(ty)\n-        }).unwrap())\n+        }).unwrap()\n     }\n \n     fn read_poly_trait_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                   -> Rc<ty::PolyTraitRef<'tcx>> {\n-        Rc::new(ty::Binder(self.read_opaque(|this, doc| {\n+                                   -> ty::PolyTraitRef<'tcx> {\n+        ty::Binder(self.read_opaque(|this, doc| {\n             let ty = tydecode::parse_trait_ref_data(\n                 doc.data,\n                 dcx.cdata.cnum,\n                 doc.start,\n                 dcx.tcx,\n                 |s, a| this.convert_def_id(dcx, s, a));\n             Ok(ty)\n-        }).unwrap()))\n+        }).unwrap())\n     }\n \n     fn read_type_param_def<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n@@ -1591,10 +1592,10 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_polytype<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                             -> ty::Polytype<'tcx> {\n-        self.read_struct(\"Polytype\", 2, |this| {\n-            Ok(ty::Polytype {\n+    fn read_type_scheme<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n+                                -> ty::TypeScheme<'tcx> {\n+        self.read_struct(\"TypeScheme\", 2, |this| {\n+            Ok(ty::TypeScheme {\n                 generics: this.read_struct_field(\"generics\", 0, |this| {\n                     this.read_struct(\"Generics\", 2, |this| {\n                         Ok(ty::Generics {\n@@ -1626,7 +1627,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     }\n \n     fn read_existential_bounds<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                       -> ty::ExistentialBounds\n+                                       -> ty::ExistentialBounds<'tcx>\n     {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_existential_bounds_data(doc.data,\n@@ -1786,7 +1787,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                 Ok(this.read_poly_trait_ref(dcx))\n                             }));\n                             Ok(ty::TyTrait {\n-                                principal: (*principal).clone(),\n+                                principal: principal,\n                                 bounds: try!(this.read_struct_field(\"bounds\", 1, |this| {\n                                     Ok(this.read_existential_bounds(dcx))\n                                 })),\n@@ -1939,9 +1940,9 @@ fn decode_side_tables(dcx: &DecodeContext,\n                            .insert(id, capture_mode);\n                     }\n                     c::tag_table_tcache => {\n-                        let pty = val_dsr.read_polytype(dcx);\n+                        let type_scheme = val_dsr.read_type_scheme(dcx);\n                         let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n-                        dcx.tcx.tcache.borrow_mut().insert(lid, pty);\n+                        dcx.tcx.tcache.borrow_mut().insert(lid, type_scheme);\n                     }\n                     c::tag_table_param_defs => {\n                         let bounds = val_dsr.read_type_param_def(dcx);"}, {"sha": "b7e67ea4690594d7a2232f9f8b11e88264f27b64", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -1065,7 +1065,7 @@ fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n     };\n     let mut visitor = ExprUseVisitor::new(&mut checker,\n                                           checker.cx.tcx,\n-                                          cx.param_env.clone());\n+                                          &cx.param_env);\n     visitor.walk_expr(guard);\n }\n "}, {"sha": "3b4ea5234f43fda4e0b4f42c3d56a7f248a84db3", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -28,7 +28,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n }\n \n struct RvalueContext<'a, 'tcx: 'a> {\n-    tcx: &'a ty::ctxt<'tcx>\n+    tcx: &'a ty::ctxt<'tcx>,\n }\n \n impl<'a, 'tcx, 'v> visit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n@@ -40,21 +40,27 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n                 fn_id: ast::NodeId) {\n         {\n             let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n-            let mut euv = euv::ExprUseVisitor::new(self, self.tcx, param_env);\n+            let mut delegate = RvalueContextDelegate { tcx: self.tcx, param_env: &param_env };\n+            let mut euv = euv::ExprUseVisitor::new(&mut delegate, self.tcx, &param_env);\n             euv.walk_fn(fd, b);\n         }\n         visit::walk_fn(self, fk, fd, b, s)\n     }\n }\n \n-impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContext<'a, 'tcx> {\n+struct RvalueContextDelegate<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    param_env: &'a ty::ParameterEnvironment<'tcx>,\n+}\n+\n+impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n     fn consume(&mut self,\n                _: ast::NodeId,\n                span: Span,\n                cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n         debug!(\"consume; cmt: {}; type: {}\", *cmt, ty_to_string(self.tcx, cmt.ty));\n-        if !ty::type_is_sized(self.tcx, cmt.ty) {\n+        if !ty::type_is_sized(self.tcx, cmt.ty, self.param_env) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\",\n                 ty_to_string(self.tcx, cmt.ty));"}, {"sha": "fb20df020acf8b73fe35a71b84e0801089fcdb77", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -31,7 +31,6 @@ use middle::infer;\n use middle::traits;\n use middle::mem_categorization as mc;\n use middle::expr_use_visitor as euv;\n-use util::common::ErrorReported;\n use util::nodemap::NodeSet;\n \n use syntax::ast;\n@@ -72,7 +71,7 @@ pub fn check_crate(tcx: &ty::ctxt) {\n     };\n     {\n         let param_env = ty::empty_parameter_environment();\n-        let visitor = euv::ExprUseVisitor::new(&mut checker, tcx, param_env);\n+        let visitor = euv::ExprUseVisitor::new(&mut checker, tcx, &param_env);\n         visit::walk_crate(&mut GlobalVisitor(visitor), tcx.map.krate());\n     }\n     visit::walk_crate(&mut CheckStaticVisitor {\n@@ -120,19 +119,14 @@ impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n         let ty = ty::node_id_to_type(self.tcx, e.id);\n         let infcx = infer::new_infer_ctxt(self.tcx);\n         let mut fulfill_cx = traits::FulfillmentContext::new();\n-        match traits::poly_trait_ref_for_builtin_bound(self.tcx, ty::BoundSync, ty) {\n-            Ok(trait_ref) => {\n-                let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n-                fulfill_cx.register_trait_ref(self.tcx, trait_ref, cause);\n-                let env = ty::empty_parameter_environment();\n-                match fulfill_cx.select_all_or_error(&infcx, &env, self.tcx) {\n-                    Ok(()) => { },\n-                    Err(ref errors) => {\n-                      traits::report_fulfillment_errors(&infcx, errors);\n-                    }\n-                }\n+        let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n+        fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n+        let env = ty::empty_parameter_environment();\n+        match fulfill_cx.select_all_or_error(&infcx, &env, self.tcx) {\n+            Ok(()) => { },\n+            Err(ref errors) => {\n+                traits::report_fulfillment_errors(&infcx, errors);\n             }\n-            Err(ErrorReported) => { }\n         }\n     }\n }"}, {"sha": "ff1ee39496626077032c483bc16e79835e066c85", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -36,10 +36,11 @@ pub enum Def {\n     // A partially resolved path to an associated type `T::U` where `T` is a concrete\n     // type (indicated by the DefId) which implements a trait which has an associated\n     // type `U` (indicated by the Ident).\n+    // FIXME(#20301) -- should use Name\n     DefAssociatedPath(TyParamProvenance, ast::Ident),\n     DefTrait(ast::DefId),\n     DefPrimTy(ast::PrimTy),\n-    DefTyParam(ParamSpace, ast::DefId, u32),\n+    DefTyParam(ParamSpace, u32, ast::DefId, ast::Name),\n     DefUse(ast::DefId),\n     DefUpvar(ast::NodeId,  // id of closed over local\n              ast::NodeId,  // expr node that creates the closure\n@@ -130,7 +131,7 @@ impl Def {\n             DefFn(id, _) | DefStaticMethod(id, _) | DefMod(id) |\n             DefForeignMod(id) | DefStatic(id, _) |\n             DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(id) |\n-            DefTyParam(_, id, _) | DefUse(id) | DefStruct(id) | DefTrait(id) |\n+            DefTyParam(_, _, id, _) | DefUse(id) | DefStruct(id) | DefTrait(id) |\n             DefMethod(id, _, _) | DefConst(id) |\n             DefAssociatedPath(TyParamProvenance::FromSelf(id), _) |\n             DefAssociatedPath(TyParamProvenance::FromParam(id), _) => {"}, {"sha": "059f38f0930d19aab5e3948e445306b693274900", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -295,11 +295,11 @@ impl OverloadedCallType {\n // supplies types from the tree. After type checking is complete, you\n // can just use the tcx as the typer.\n \n-pub struct ExprUseVisitor<'d,'t,'tcx,TYPER:'t> {\n+pub struct ExprUseVisitor<'d,'t,'tcx:'t,TYPER:'t> {\n     typer: &'t TYPER,\n     mc: mc::MemCategorizationContext<'t,TYPER>,\n     delegate: &'d mut (Delegate<'tcx>+'d),\n-    param_env: ParameterEnvironment<'tcx>,\n+    param_env: &'t ParameterEnvironment<'tcx>,\n }\n \n /// Whether the elements of an overloaded operation are passed by value or by reference\n@@ -311,7 +311,7 @@ enum PassArgs {\n impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     pub fn new(delegate: &'d mut Delegate<'tcx>,\n                typer: &'t TYPER,\n-               param_env: ParameterEnvironment<'tcx>)\n+               param_env: &'t ParameterEnvironment<'tcx>)\n                -> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         ExprUseVisitor {\n             typer: typer,\n@@ -355,7 +355,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         cmt: mc::cmt<'tcx>) {\n         let mode = copy_or_move(self.tcx(),\n                                 cmt.ty,\n-                                &self.param_env,\n+                                self.param_env,\n                                 DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n@@ -998,7 +998,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     ast::PatIdent(ast::BindByValue(_), _, _) => {\n                         match copy_or_move(tcx,\n                                            cmt_pat.ty,\n-                                           &self.param_env,\n+                                           self.param_env,\n                                            PatBindingMove) {\n                             Copy => mode.lub(CopyingMatch),\n                             Move(_) => mode.lub(MovingMatch),\n@@ -1028,8 +1028,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         let typer = self.typer;\n         let def_map = &self.typer.tcx().def_map;\n         let delegate = &mut self.delegate;\n-        let param_env = &mut self.param_env;\n-\n+        let param_env = self.param_env;\n         mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n             if pat_util::pat_is_binding(def_map, pat) {\n                 let tcx = typer.tcx();\n@@ -1249,7 +1248,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                                 closure_expr.span,\n                                                 freevar.def);\n             let mode = copy_or_move(self.tcx(), cmt_var.ty,\n-                                    &self.param_env, CaptureMove);\n+                                    self.param_env, CaptureMove);\n             self.delegate.consume(closure_expr.id, freevar.span, cmt_var, mode);\n         }\n     }"}, {"sha": "dcbd94b8482fdd5516ab6b6b08490ecd6851f34d", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -58,7 +58,7 @@ pub fn simplify_type(tcx: &ty::ctxt,\n         ty::ty_vec(..) => Some(VecSimplifiedType),\n         ty::ty_ptr(_) => Some(PtrSimplifiedType),\n         ty::ty_trait(ref trait_info) => {\n-            Some(TraitSimplifiedType(trait_info.principal.def_id()))\n+            Some(TraitSimplifiedType(trait_info.principal_def_id()))\n         }\n         ty::ty_struct(def_id, _) => {\n             Some(StructSimplifiedType(def_id))\n@@ -86,6 +86,9 @@ pub fn simplify_type(tcx: &ty::ctxt,\n         ty::ty_bare_fn(_, ref f) => {\n             Some(FunctionSimplifiedType(f.sig.0.inputs.len()))\n         }\n+        ty::ty_projection(_) => {\n+            None\n+        }\n         ty::ty_param(_) => {\n             if can_simplify_params {\n                 Some(ParameterSimplifiedType)"}, {"sha": "11ca202971e1d5b77f437585099f345df98049ac", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -351,11 +351,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 (&ty::ty_trait(..), &ty::ty_trait(..)) => {\n                     None\n                 }\n-                (_, &ty::ty_trait(box ty::TyTrait { ref principal, bounds })) => {\n+                (_, &ty::ty_trait(box ty::TyTrait { ref principal, ref bounds })) => {\n                     // FIXME what is the purpose of `ty`?\n-                    let ty = ty::mk_trait(tcx, principal.clone(), bounds);\n-                    Some((ty, ty::UnsizeVtable(ty::TyTrait { principal: (*principal).clone(),\n-                                                             bounds: bounds },\n+                    let ty = ty::mk_trait(tcx, principal.clone(), bounds.clone());\n+                    Some((ty, ty::UnsizeVtable(ty::TyTrait { principal: principal.clone(),\n+                                                             bounds: bounds.clone() },\n                                                ty_a)))\n                 }\n                 (&ty::ty_struct(did_a, substs_a), &ty::ty_struct(did_b, substs_b))\n@@ -458,10 +458,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         match a.sty {\n             ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty.sty {\n-                ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n+                ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n                     debug!(\"mutbl={} b_mutbl={}\", mutbl, b_mutbl);\n-                    // FIXME what is purpose of this type `tr`?\n-                    let tr = ty::mk_trait(tcx, principal.clone(), bounds);\n+                    let tr = ty::mk_trait(tcx, principal.clone(), bounds.clone());\n                     try!(self.subtype(mk_ty(tr), b));\n                     Ok(Some(AdjustDerefRef(AutoDerefRef {\n                         autoderefs: 1,"}, {"sha": "e0bcdfc6d8d9375627b5702d13e4411349553548", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 87, "deletions": 13, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -51,6 +51,7 @@ use middle::ty_fold;\n use middle::ty_fold::{TypeFoldable};\n use util::ppaux::Repr;\n \n+use std::rc::Rc;\n use syntax::ast::{Onceness, Unsafety};\n use syntax::ast;\n use syntax::abi;\n@@ -221,7 +222,7 @@ pub trait Combine<'tcx> {\n         };\n         let unsafety = try!(self.unsafeties(a.unsafety, b.unsafety));\n         let onceness = try!(self.oncenesses(a.onceness, b.onceness));\n-        let bounds = try!(self.existential_bounds(a.bounds, b.bounds));\n+        let bounds = try!(self.existential_bounds(&a.bounds, &b.bounds));\n         let sig = try!(self.binders(&a.sig, &b.sig));\n         let abi = try!(self.abi(a.abi, b.abi));\n         Ok(ty::ClosureTy {\n@@ -288,15 +289,61 @@ pub trait Combine<'tcx> {\n \n     fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness>;\n \n+    fn projection_tys(&self,\n+                      a: &ty::ProjectionTy<'tcx>,\n+                      b: &ty::ProjectionTy<'tcx>)\n+                      -> cres<'tcx, ty::ProjectionTy<'tcx>>\n+    {\n+        if a.item_name != b.item_name {\n+            Err(ty::terr_projection_name_mismatched(\n+                expected_found(self, a.item_name, b.item_name)))\n+        } else {\n+            let trait_ref = try!(self.trait_refs(&*a.trait_ref, &*b.trait_ref));\n+            Ok(ty::ProjectionTy { trait_ref: Rc::new(trait_ref), item_name: a.item_name })\n+        }\n+    }\n+\n+    fn projection_predicates(&self,\n+                             a: &ty::ProjectionPredicate<'tcx>,\n+                             b: &ty::ProjectionPredicate<'tcx>)\n+                             -> cres<'tcx, ty::ProjectionPredicate<'tcx>>\n+    {\n+        let projection_ty = try!(self.projection_tys(&a.projection_ty, &b.projection_ty));\n+        let ty = try!(self.tys(a.ty, b.ty));\n+        Ok(ty::ProjectionPredicate { projection_ty: projection_ty, ty: ty })\n+    }\n+\n+    fn projection_bounds(&self,\n+                         a: &Vec<ty::PolyProjectionPredicate<'tcx>>,\n+                         b: &Vec<ty::PolyProjectionPredicate<'tcx>>)\n+                         -> cres<'tcx, Vec<ty::PolyProjectionPredicate<'tcx>>>\n+    {\n+        // To be compatible, `a` and `b` must be for precisely the\n+        // same set of traits and item names. We always require that\n+        // projection bounds lists are sorted by trait-def-id and item-name,\n+        // so we can just iterate through the lists pairwise, so long as they are the\n+        // same length.\n+        if a.len() != b.len() {\n+            Err(ty::terr_projection_bounds_length(expected_found(self, a.len(), b.len())))\n+        } else {\n+            a.iter()\n+                .zip(b.iter())\n+                .map(|(a, b)| self.binders(a, b))\n+                .collect()\n+        }\n+    }\n+\n     fn existential_bounds(&self,\n-                          a: ty::ExistentialBounds,\n-                          b: ty::ExistentialBounds)\n-                          -> cres<'tcx, ty::ExistentialBounds>\n+                          a: &ty::ExistentialBounds<'tcx>,\n+                          b: &ty::ExistentialBounds<'tcx>)\n+                          -> cres<'tcx, ty::ExistentialBounds<'tcx>>\n     {\n         let r = try!(self.contraregions(a.region_bound, b.region_bound));\n         let nb = try!(self.builtin_bounds(a.builtin_bounds, b.builtin_bounds));\n+        let pb = try!(self.projection_bounds(&a.projection_bounds, &b.projection_bounds));\n         Ok(ty::ExistentialBounds { region_bound: r,\n-                                   builtin_bounds: nb })\n+                                   builtin_bounds: nb,\n+                                   projection_bounds: pb })\n     }\n \n     fn builtin_bounds(&self,\n@@ -358,6 +405,18 @@ pub trait Combineable<'tcx> : Repr<'tcx> + TypeFoldable<'tcx> {\n     fn combine<C:Combine<'tcx>>(combiner: &C, a: &Self, b: &Self) -> cres<'tcx, Self>;\n }\n \n+impl<'tcx,T> Combineable<'tcx> for Rc<T>\n+    where T : Combineable<'tcx>\n+{\n+    fn combine<C:Combine<'tcx>>(combiner: &C,\n+                                a: &Rc<T>,\n+                                b: &Rc<T>)\n+                                -> cres<'tcx, Rc<T>>\n+    {\n+        Ok(Rc::new(try!(Combineable::combine(combiner, &**a, &**b))))\n+    }\n+}\n+\n impl<'tcx> Combineable<'tcx> for ty::TraitRef<'tcx> {\n     fn combine<C:Combine<'tcx>>(combiner: &C,\n                                 a: &ty::TraitRef<'tcx>,\n@@ -368,6 +427,16 @@ impl<'tcx> Combineable<'tcx> for ty::TraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> Combineable<'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn combine<C:Combine<'tcx>>(combiner: &C,\n+                                a: &ty::ProjectionPredicate<'tcx>,\n+                                b: &ty::ProjectionPredicate<'tcx>)\n+                                -> cres<'tcx, ty::ProjectionPredicate<'tcx>>\n+    {\n+        combiner.projection_predicates(a, b)\n+    }\n+}\n+\n impl<'tcx> Combineable<'tcx> for ty::FnSig<'tcx> {\n     fn combine<C:Combine<'tcx>>(combiner: &C,\n                                 a: &ty::FnSig<'tcx>,\n@@ -397,8 +466,8 @@ pub fn expected_found<'tcx, C: Combine<'tcx>, T>(\n pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n                                          a: Ty<'tcx>,\n                                          b: Ty<'tcx>)\n-                                         -> cres<'tcx, Ty<'tcx>> {\n-\n+                                         -> cres<'tcx, Ty<'tcx>>\n+{\n     let tcx = this.infcx().tcx;\n     let a_sty = &a.sty;\n     let b_sty = &b.sty;\n@@ -415,7 +484,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n       }\n \n       (&ty::ty_err, _) | (_, &ty::ty_err) => {\n-          Ok(ty::mk_err())\n+          Ok(tcx.types.err)\n       }\n \n         // Relate integral variables to other types\n@@ -483,7 +552,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n        &ty::ty_trait(ref b_)) => {\n           debug!(\"Trying to match traits {} and {}\", a, b);\n           let principal = try!(this.binders(&a_.principal, &b_.principal));\n-          let bounds = try!(this.existential_bounds(a_.bounds, b_.bounds));\n+          let bounds = try!(this.existential_bounds(&a_.bounds, &b_.bounds));\n           Ok(ty::mk_trait(tcx, principal, bounds))\n       }\n \n@@ -581,6 +650,11 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n         })\n       }\n \n+      (&ty::ty_projection(ref a_data), &ty::ty_projection(ref b_data)) => {\n+          let projection_ty = try!(this.projection_tys(a_data, b_data));\n+          Ok(ty::mk_projection(tcx, projection_ty.trait_ref, projection_ty.item_name))\n+      }\n+\n       _ => Err(ty::terr_sorts(expected_found(this, a, b)))\n     };\n \n@@ -592,8 +666,8 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n     {\n         try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         match val {\n-            IntType(v) => Ok(ty::mk_mach_int(v)),\n-            UintType(v) => Ok(ty::mk_mach_uint(v))\n+            IntType(v) => Ok(ty::mk_mach_int(this.tcx(), v)),\n+            UintType(v) => Ok(ty::mk_mach_uint(this.tcx(), v))\n         }\n     }\n \n@@ -604,7 +678,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n         val: ast::FloatTy) -> cres<'tcx, Ty<'tcx>>\n     {\n         try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n-        Ok(ty::mk_mach_float(val))\n+        Ok(ty::mk_mach_float(this.tcx(), val))\n     }\n }\n \n@@ -763,7 +837,7 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n             ty::ty_infer(ty::TyVar(vid)) => {\n                 if vid == self.for_vid {\n                     self.cycle_detected = true;\n-                    ty::mk_err()\n+                    self.tcx().types.err\n                 } else {\n                     match self.infcx.type_variables.borrow().probe(vid) {\n                         Some(u) => self.fold_ty(u),"}, {"sha": "e38b721ce2d0d82295b130766566f4fcd83636be", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -1437,6 +1437,11 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                 format!(\" for {}in generic type\",\n                         bound_region_to_string(self.tcx, \"lifetime parameter \", true, br))\n             }\n+            infer::LateBoundRegion(_, br, infer::AssocTypeProjection(type_name)) => {\n+                format!(\" for {}in trait containing associated type `{}`\",\n+                        bound_region_to_string(self.tcx, \"lifetime parameter \", true, br),\n+                        token::get_name(type_name))\n+            }\n             infer::EarlyBoundRegion(_, name) => {\n                 format!(\" for lifetime parameter `{}`\",\n                         token::get_name(name).get())\n@@ -1661,13 +1666,16 @@ impl<'tcx> Resolvable<'tcx> for Rc<ty::TraitRef<'tcx>> {\n     }\n }\n \n-impl<'tcx> Resolvable<'tcx> for Rc<ty::PolyTraitRef<'tcx>> {\n-    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n-                   -> Rc<ty::PolyTraitRef<'tcx>> {\n-        Rc::new(infcx.resolve_type_vars_if_possible(&**self))\n+impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n+    fn resolve<'a>(&self,\n+                   infcx: &InferCtxt<'a, 'tcx>)\n+                   -> ty::PolyTraitRef<'tcx>\n+    {\n+        infcx.resolve_type_vars_if_possible(self)\n     }\n+\n     fn contains_error(&self) -> bool {\n-        ty::trait_ref_contains_error(&self.0)\n+        ty::trait_ref_contains_error(&*self.0)\n     }\n }\n "}, {"sha": "33174409f899bec8b4bab9450a5551ac9553c251", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -157,6 +157,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::ty_struct(..) |\n             ty::ty_unboxed_closure(..) |\n             ty::ty_tup(..) |\n+            ty::ty_projection(..) |\n             ty::ty_param(..) => {\n                 ty_fold::super_fold_ty(self, t)\n             }"}, {"sha": "386768bd9d6f75e402735290a90f2544d4d77689", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -139,7 +139,7 @@ pub enum TypeOrigin {\n pub enum ValuePairs<'tcx> {\n     Types(ty::expected_found<Ty<'tcx>>),\n     TraitRefs(ty::expected_found<Rc<ty::TraitRef<'tcx>>>),\n-    PolyTraitRefs(ty::expected_found<Rc<ty::PolyTraitRef<'tcx>>>),\n+    PolyTraitRefs(ty::expected_found<ty::PolyTraitRef<'tcx>>),\n }\n \n /// The trace designates the path through inference that we took to\n@@ -231,6 +231,9 @@ pub enum LateBoundRegionConversionTime {\n \n     /// when two higher-ranked types are compared\n     HigherRankedType,\n+\n+    /// when projecting an associated type\n+    AssocTypeProjection(ast::Name),\n }\n \n /// Reasons to create a region inference variable\n@@ -324,7 +327,7 @@ pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n         Ok(t) => t,\n         Err(ref err) => {\n             cx.report_and_explain_type_error(trace, err);\n-            ty::mk_err()\n+            cx.tcx.types.err\n         }\n     }\n }\n@@ -407,8 +410,8 @@ pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                    a_is_expected: bool,\n                                    origin: TypeOrigin,\n-                                   a: Rc<ty::PolyTraitRef<'tcx>>,\n-                                   b: Rc<ty::PolyTraitRef<'tcx>>)\n+                                   a: ty::PolyTraitRef<'tcx>,\n+                                   b: ty::PolyTraitRef<'tcx>)\n                                    -> ures<'tcx>\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n@@ -703,8 +706,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn sub_poly_trait_refs(&self,\n                                a_is_expected: bool,\n                                origin: TypeOrigin,\n-                               a: Rc<ty::PolyTraitRef<'tcx>>,\n-                               b: Rc<ty::PolyTraitRef<'tcx>>)\n+                               a: ty::PolyTraitRef<'tcx>,\n+                               b: ty::PolyTraitRef<'tcx>)\n                                -> ures<'tcx>\n     {\n         debug!(\"sub_poly_trait_refs({} <: {})\",\n@@ -715,7 +718,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: origin,\n                 values: PolyTraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace).binders(&*a, &*b).to_ures()\n+            self.sub(a_is_expected, trace).binders(&a, &b).to_ures()\n         })\n     }\n \n@@ -750,7 +753,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                          -> T\n         where T : TypeFoldable<'tcx> + Repr<'tcx>\n     {\n-        /*! See `higher_ranked::leak_check` */\n+        /*! See `higher_ranked::plug_leaks` */\n \n         higher_ranked::plug_leaks(self, skol_map, snapshot, value)\n     }\n@@ -861,10 +864,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let region_param_defs = generics.regions.get_slice(subst::TypeSpace);\n         let regions = self.region_vars_for_defs(span, region_param_defs);\n \n-        let assoc_type_parameter_count = generics.types.len(subst::AssocSpace);\n-        let assoc_type_parameters = self.next_ty_vars(assoc_type_parameter_count);\n-\n-        subst::Substs::new_trait(type_parameters, regions, assoc_type_parameters, self_ty)\n+        subst::Substs::new_trait(type_parameters, regions, self_ty)\n     }\n \n     pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> ty::Region {\n@@ -1058,12 +1058,12 @@ impl<'tcx> TypeTrace<'tcx> {\n         self.origin.span()\n     }\n \n-    pub fn dummy() -> TypeTrace<'tcx> {\n+    pub fn dummy(tcx: &ty::ctxt<'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n             values: Types(ty::expected_found {\n-                expected: ty::mk_err(),\n-                found: ty::mk_err(),\n+                expected: tcx.types.err,\n+                found: tcx.types.err,\n             })\n         }\n     }"}, {"sha": "ca2ae25e6c63a7700fa7d81cda152f9ef6f3745a", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -83,15 +83,15 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n             match t.sty {\n                 ty::ty_infer(ty::TyVar(vid)) => {\n                     self.err = Some(unresolved_ty(vid));\n-                    ty::mk_err()\n+                    self.tcx().types.err\n                 }\n                 ty::ty_infer(ty::IntVar(vid)) => {\n                     self.err = Some(unresolved_int_ty(vid));\n-                    ty::mk_err()\n+                    self.tcx().types.err\n                 }\n                 ty::ty_infer(ty::FloatVar(vid)) => {\n                     self.err = Some(unresolved_float_ty(vid));\n-                    ty::mk_err()\n+                    self.tcx().types.err\n                 }\n                 ty::ty_infer(_) => {\n                     self.infcx.tcx.sess.bug("}, {"sha": "4bd3308728c10e86857b3eaf058cb8558f821388", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -146,7 +146,7 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n             }\n \n             (&ty::ty_err, _) | (_, &ty::ty_err) => {\n-                Ok(ty::mk_err())\n+                Ok(self.tcx().types.err)\n             }\n \n             _ => {"}, {"sha": "3127ef5d8a5f5ba7a1bcb64ffff87052127e3881", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -225,7 +225,7 @@ impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n /// Indicates a type that does not have any kind of subtyping\n /// relationship.\n pub trait SimplyUnifiable<'tcx> : Clone + PartialEq + Repr<'tcx> {\n-    fn to_type(&self) -> Ty<'tcx>;\n+    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n     fn to_type_err(expected_found<Self>) -> ty::type_err<'tcx>;\n }\n \n@@ -337,7 +337,7 @@ impl<'a,'tcx,V:SimplyUnifiable<'tcx>,K:UnifyKey<'tcx, Option<V>>>\n         let node_a = table.borrow_mut().get(tcx, a_id);\n         match node_a.value {\n             None => None,\n-            Some(ref a_t) => Some(a_t.to_type())\n+            Some(ref a_t) => Some(a_t.to_type(tcx))\n         }\n     }\n }\n@@ -363,10 +363,10 @@ impl<'tcx> UnifyKey<'tcx, Option<IntVarValue>> for ty::IntVid {\n }\n \n impl<'tcx> SimplyUnifiable<'tcx> for IntVarValue {\n-    fn to_type(&self) -> Ty<'tcx> {\n+    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n-            ty::IntType(i) => ty::mk_mach_int(i),\n-            ty::UintType(i) => ty::mk_mach_uint(i),\n+            ty::IntType(i) => ty::mk_mach_int(tcx, i),\n+            ty::UintType(i) => ty::mk_mach_uint(tcx, i),\n         }\n     }\n \n@@ -399,8 +399,8 @@ impl<'tcx> UnifyValue<'tcx> for Option<ast::FloatTy> {\n }\n \n impl<'tcx> SimplyUnifiable<'tcx> for ast::FloatTy {\n-    fn to_type(&self) -> Ty<'tcx> {\n-        ty::mk_mach_float(*self)\n+    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        ty::mk_mach_float(tcx, *self)\n     }\n \n     fn to_type_err(err: expected_found<ast::FloatTy>) -> ty::type_err<'tcx> {"}, {"sha": "df06b3b7789c98c779448b12f051ac3c0d4881ec", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 192, "deletions": 57, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -10,9 +10,10 @@\n \n use metadata::csearch;\n use middle::def::DefFn;\n-use middle::subst::Subst;\n+use middle::subst::{Subst, Substs, EnumeratedItems};\n use middle::ty::{TransmuteRestriction, ctxt, ty_bare_fn};\n use middle::ty::{mod, Ty};\n+use util::ppaux::Repr;\n \n use syntax::abi::RustIntrinsic;\n use syntax::ast::DefId;\n@@ -23,52 +24,31 @@ use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-fn type_size_is_affected_by_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>, typ: Ty<'tcx>)\n-                                                  -> bool {\n-    let mut result = false;\n-    ty::maybe_walk_ty(typ, |typ| {\n-        match typ.sty {\n-            ty::ty_uniq(_) | ty::ty_ptr(_) | ty::ty_rptr(..) |\n-            ty::ty_bare_fn(..) | ty::ty_closure(..) => {\n-                false\n-            }\n-            ty::ty_param(_) => {\n-                result = true;\n-                // No need to continue; we now know the result.\n-                false\n-            }\n-            ty::ty_enum(did, substs) => {\n-                for enum_variant in (*ty::enum_variants(tcx, did)).iter() {\n-                    for argument_type in enum_variant.args.iter() {\n-                        let argument_type = argument_type.subst(tcx, substs);\n-                        result = result ||\n-                            type_size_is_affected_by_type_parameters(\n-                                tcx,\n-                                argument_type);\n-                    }\n-                }\n-\n-                // Don't traverse substitutions.\n-                false\n-            }\n-            ty::ty_struct(did, substs) => {\n-                for field in ty::struct_fields(tcx, did, substs).iter() {\n-                    result = result ||\n-                        type_size_is_affected_by_type_parameters(tcx,\n-                                                                 field.mt.ty);\n-                }\n-\n-                // Don't traverse substitutions.\n-                false\n-            }\n-            _ => true,\n-        }\n-    });\n-    result\n+pub fn check_crate(tcx: &ctxt) {\n+    let mut visitor = IntrinsicCheckingVisitor {\n+        tcx: tcx,\n+        param_envs: Vec::new(),\n+        dummy_sized_ty: tcx.types.int,\n+        dummy_unsized_ty: ty::mk_vec(tcx, tcx.types.int, None),\n+    };\n+    visit::walk_crate(&mut visitor, tcx.map.krate());\n }\n \n struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ctxt<'tcx>,\n+\n+    // As we traverse the AST, we keep a stack of the parameter\n+    // environments for each function we encounter. When we find a\n+    // call to `transmute`, we can check it in the context of the top\n+    // of the stack (which ought not to be empty).\n+    param_envs: Vec<ty::ParameterEnvironment<'tcx>>,\n+\n+    // Dummy sized/unsized types that use to substitute for type\n+    // parameters in order to estimate how big a type will be for any\n+    // possible instantiation of the type parameters in scope.  See\n+    // `check_transmute` for more details.\n+    dummy_sized_ty: Ty<'tcx>,\n+    dummy_unsized_ty: Ty<'tcx>,\n }\n \n impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n@@ -97,26 +77,175 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     }\n \n     fn check_transmute(&self, span: Span, from: Ty<'tcx>, to: Ty<'tcx>, id: ast::NodeId) {\n-        if type_size_is_affected_by_type_parameters(self.tcx, from) {\n+        // Find the parameter environment for the most recent function that\n+        // we entered.\n+\n+        let param_env = match self.param_envs.last() {\n+            Some(p) => p,\n+            None => {\n+                self.tcx.sess.span_bug(\n+                    span,\n+                    \"transmute encountered outside of any fn\");\n+            }\n+        };\n+\n+        // Simple case: no type parameters involved.\n+        if\n+            !ty::type_has_params(from) && !ty::type_has_self(from) &&\n+            !ty::type_has_params(to) && !ty::type_has_self(to)\n+        {\n+            let restriction = TransmuteRestriction {\n+                span: span,\n+                original_from: from,\n+                original_to: to,\n+                substituted_from: from,\n+                substituted_to: to,\n+                id: id,\n+            };\n+            self.push_transmute_restriction(restriction);\n+            return;\n+        }\n+\n+        // The rules around type parameters are a bit subtle. We are\n+        // checking these rules before monomorphization, so there may\n+        // be unsubstituted type parameters present in the\n+        // types. Obviously we cannot create LLVM types for those.\n+        // However, if a type parameter appears only indirectly (i.e.,\n+        // through a pointer), it does not necessarily affect the\n+        // size, so that should be allowed. The only catch is that we\n+        // DO want to be careful around unsized type parameters, since\n+        // fat pointers have a different size than a thin pointer, and\n+        // hence `&T` and `&U` have different sizes if `T : Sized` but\n+        // `U : Sized` does not hold.\n+        //\n+        // However, it's not as simple as checking whether `T :\n+        // Sized`, because even if `T : Sized` does not hold, that\n+        // just means that `T` *may* not be sized.  After all, even a\n+        // type parameter `Sized? T` could be bound to a sized\n+        // type. (Issue #20116)\n+        //\n+        // To handle this, we first check for \"interior\" type\n+        // parameters, which are always illegal. If there are none of\n+        // those, then we know that the only way that all type\n+        // parameters `T` are referenced indirectly, e.g. via a\n+        // pointer type like `&T`. In that case, we only care whether\n+        // `T` is sized or not, because that influences whether `&T`\n+        // is a thin or fat pointer.\n+        //\n+        // One could imagine establishing a sophisticated constraint\n+        // system to ensure that the transmute is legal, but instead\n+        // we do something brutally dumb. We just substitute dummy\n+        // sized or unsized types for every type parameter in scope,\n+        // exhaustively checking all possible combinations. Here are some examples:\n+        //\n+        // ```\n+        // fn foo<T,U>() {\n+        //     // T=int, U=int\n+        // }\n+        //\n+        // fn bar<Sized? T,U>() {\n+        //     // T=int, U=int\n+        //     // T=[int], U=int\n+        // }\n+        //\n+        // fn baz<Sized? T, Sized?U>() {\n+        //     // T=int, U=int\n+        //     // T=[int], U=int\n+        //     // T=int, U=[int]\n+        //     // T=[int], U=[int]\n+        // }\n+        // ```\n+        //\n+        // In all cases, we keep the original unsubstituted types\n+        // around for error reporting.\n+\n+        let from_tc = ty::type_contents(self.tcx, from);\n+        let to_tc = ty::type_contents(self.tcx, to);\n+        if from_tc.interior_param() || to_tc.interior_param() {\n             span_err!(self.tcx.sess, span, E0139,\n-                      \"cannot transmute from a type that contains type parameters\");\n+                      \"cannot transmute to or from a type that contains \\\n+                       type parameters in its interior\");\n+            return;\n         }\n-        if type_size_is_affected_by_type_parameters(self.tcx, to) {\n-            span_err!(self.tcx.sess, span, E0140,\n-                      \"cannot transmute to a type that contains type parameters\");\n+\n+        let mut substs = param_env.free_substs.clone();\n+        self.with_each_combination(\n+            param_env,\n+            param_env.free_substs.types.iter_enumerated(),\n+            &mut substs,\n+            &mut |substs| {\n+                let restriction = TransmuteRestriction {\n+                    span: span,\n+                    original_from: from,\n+                    original_to: to,\n+                    substituted_from: from.subst(self.tcx, substs),\n+                    substituted_to: to.subst(self.tcx, substs),\n+                    id: id,\n+                };\n+                self.push_transmute_restriction(restriction);\n+            });\n+    }\n+\n+    fn with_each_combination(&self,\n+                             param_env: &ty::ParameterEnvironment<'tcx>,\n+                             mut types_in_scope: EnumeratedItems<Ty<'tcx>>,\n+                             substs: &mut Substs<'tcx>,\n+                             callback: &mut FnMut(&Substs<'tcx>))\n+    {\n+        // This parameter invokes `callback` many times with different\n+        // substitutions that replace all the parameters in scope with\n+        // either `int` or `[int]`, depending on whether the type\n+        // parameter is known to be sized. See big comment above for\n+        // an explanation of why this is a reasonable thing to do.\n+\n+        match types_in_scope.next() {\n+            None => {\n+                debug!(\"with_each_combination(substs={})\",\n+                       substs.repr(self.tcx));\n+\n+                callback.call_mut((substs,));\n+            }\n+\n+            Some((space, index, &param_ty)) => {\n+                debug!(\"with_each_combination: space={}, index={}, param_ty={}\",\n+                       space, index, param_ty.repr(self.tcx));\n+\n+                if !ty::type_is_sized(self.tcx, param_ty, param_env) {\n+                    debug!(\"with_each_combination: param_ty is not known to be sized\");\n+\n+                    substs.types.get_mut_slice(space)[index] = self.dummy_unsized_ty;\n+                    self.with_each_combination(param_env, types_in_scope.clone(), substs, callback);\n+                }\n+\n+                substs.types.get_mut_slice(space)[index] = self.dummy_sized_ty;\n+                self.with_each_combination(param_env, types_in_scope, substs, callback);\n+            }\n         }\n+    }\n \n-        let restriction = TransmuteRestriction {\n-            span: span,\n-            from: from,\n-            to: to,\n-            id: id,\n-        };\n+    fn push_transmute_restriction(&self, restriction: TransmuteRestriction<'tcx>) {\n+        debug!(\"Pushing transmute restriction: {}\", restriction.repr(self.tcx));\n         self.tcx.transmute_restrictions.borrow_mut().push(restriction);\n     }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n+    fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n+                b: &'v ast::Block, s: Span, id: ast::NodeId) {\n+        match fk {\n+            visit::FkItemFn(..) | visit::FkMethod(..) => {\n+                let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n+                self.param_envs.push(param_env);\n+                visit::walk_fn(self, fk, fd, b, s);\n+                self.param_envs.pop();\n+            }\n+            visit::FkFnBlock(..) => {\n+                visit::walk_fn(self, fk, fd, b, s);\n+            }\n+        }\n+\n+    }\n+\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         if let ast::ExprPath(..) = expr.node {\n             match ty::resolve_expr(self.tcx, expr) {\n@@ -144,7 +273,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &ctxt) {\n-    visit::walk_crate(&mut IntrinsicCheckingVisitor { tcx: tcx },\n-                      tcx.map.krate());\n+impl<'tcx> Repr<'tcx> for TransmuteRestriction<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"TransmuteRestriction(id={}, original=({},{}), substituted=({},{}))\",\n+                self.id,\n+                self.original_from.repr(tcx),\n+                self.original_to.repr(tcx),\n+                self.substituted_from.repr(tcx),\n+                self.substituted_to.repr(tcx))\n+    }\n }"}, {"sha": "c15001af68d96e0f78510eebdbfad67824b3f84b", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -755,7 +755,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         // instead of bothering to construct a proper\n                         // one.\n                         base.mutbl = McImmutable;\n-                        base.ty = ty::mk_err();\n+                        base.ty = self.tcx().types.err;\n                         Rc::new(cmt_ {\n                             id: id,\n                             span: span,\n@@ -781,7 +781,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         is_unboxed: is_unboxed\n                     }),\n                     mutbl: McImmutable,\n-                    ty: ty::mk_err(),\n+                    ty: self.tcx().types.err,\n                     note: NoteNone\n                 };\n \n@@ -792,7 +792,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                             span: span,\n                             cat: cat_deref(Rc::new(base), 0, env_ptr),\n                             mutbl: env_mutbl,\n-                            ty: ty::mk_err(),\n+                            ty: self.tcx().types.err,\n                             note: NoteClosureEnv(upvar_id)\n                         };\n                     }\n@@ -987,7 +987,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 ty::ty_fn_args(method_ty)[0]\n             }\n             None => {\n-                match ty::array_element_ty(base_cmt.ty) {\n+                match ty::array_element_ty(self.tcx(), base_cmt.ty) {\n                     Some(ty) => ty,\n                     None => {\n                         self.tcx().sess.span_bug("}, {"sha": "3066ae5b479ef7aeaa03ea51b3ea78af1210bb69", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 24, "deletions": 46, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -55,18 +55,17 @@ impl<'tcx> Substs<'tcx> {\n                     r: Vec<ty::Region>)\n                     -> Substs<'tcx>\n     {\n-        Substs::new(VecPerParamSpace::new(t, Vec::new(), Vec::new(), Vec::new()),\n-                    VecPerParamSpace::new(r, Vec::new(), Vec::new(), Vec::new()))\n+        Substs::new(VecPerParamSpace::new(t, Vec::new(), Vec::new()),\n+                    VecPerParamSpace::new(r, Vec::new(), Vec::new()))\n     }\n \n     pub fn new_trait(t: Vec<Ty<'tcx>>,\n                      r: Vec<ty::Region>,\n-                     a: Vec<Ty<'tcx>>,\n                      s: Ty<'tcx>)\n                     -> Substs<'tcx>\n     {\n-        Substs::new(VecPerParamSpace::new(t, vec!(s), a, Vec::new()),\n-                    VecPerParamSpace::new(r, Vec::new(), Vec::new(), Vec::new()))\n+        Substs::new(VecPerParamSpace::new(t, vec!(s), Vec::new()),\n+                    VecPerParamSpace::new(r, Vec::new(), Vec::new()))\n     }\n \n     pub fn erased(t: VecPerParamSpace<Ty<'tcx>>) -> Substs<'tcx>\n@@ -123,13 +122,6 @@ impl<'tcx> Substs<'tcx> {\n         s\n     }\n \n-    pub fn with_assoc_tys(&self, assoc_tys: Vec<Ty<'tcx>>) -> Substs<'tcx> {\n-        assert!(self.types.is_empty_in(AssocSpace));\n-        let mut s = (*self).clone();\n-        s.types.replace(AssocSpace, assoc_tys);\n-        s\n-    }\n-\n     pub fn erase_regions(self) -> Substs<'tcx> {\n         let Substs { types, regions: _ } = self;\n         Substs { types: types, regions: ErasedRegions }\n@@ -192,30 +184,27 @@ impl RegionSubsts {\n pub enum ParamSpace {\n     TypeSpace,  // Type parameters attached to a type definition, trait, or impl\n     SelfSpace,  // Self parameter on a trait\n-    AssocSpace, // Assoc types defined in a trait/impl\n     FnSpace,    // Type parameters attached to a method or fn\n }\n \n impl ParamSpace {\n-    pub fn all() -> [ParamSpace, ..4] {\n-        [TypeSpace, SelfSpace, AssocSpace, FnSpace]\n+    pub fn all() -> [ParamSpace, ..3] {\n+        [TypeSpace, SelfSpace, FnSpace]\n     }\n \n     pub fn to_uint(self) -> uint {\n         match self {\n             TypeSpace => 0,\n             SelfSpace => 1,\n-            AssocSpace => 2,\n-            FnSpace => 3,\n+            FnSpace => 2,\n         }\n     }\n \n     pub fn from_uint(u: uint) -> ParamSpace {\n         match u {\n             0 => TypeSpace,\n             1 => SelfSpace,\n-            2 => AssocSpace,\n-            3 => FnSpace,\n+            2 => FnSpace,\n             _ => panic!(\"Invalid ParamSpace: {}\", u)\n         }\n     }\n@@ -235,11 +224,9 @@ pub struct VecPerParamSpace<T> {\n     //\n     // AF(self) = (self.content[..self.type_limit],\n     //             self.content[self.type_limit..self.self_limit],\n-    //             self.content[self.self_limit..self.assoc_limit],\n-    //             self.content[self.assoc_limit..])\n+    //             self.content[self.self_limit..])\n     type_limit: uint,\n     self_limit: uint,\n-    assoc_limit: uint,\n     content: Vec<T>,\n }\n \n@@ -248,7 +235,6 @@ pub struct VecPerParamSpace<T> {\n pub struct SeparateVecsPerParamSpace<T> {\n     pub types: Vec<T>,\n     pub selfs: Vec<T>,\n-    pub assocs: Vec<T>,\n     pub fns: Vec<T>,\n }\n \n@@ -268,16 +254,14 @@ impl<T> VecPerParamSpace<T> {\n         match space {\n             TypeSpace => (0, self.type_limit),\n             SelfSpace => (self.type_limit, self.self_limit),\n-            AssocSpace => (self.self_limit, self.assoc_limit),\n-            FnSpace => (self.assoc_limit, self.content.len()),\n+            FnSpace => (self.self_limit, self.content.len()),\n         }\n     }\n \n     pub fn empty() -> VecPerParamSpace<T> {\n         VecPerParamSpace {\n             type_limit: 0,\n             self_limit: 0,\n-            assoc_limit: 0,\n             content: Vec::new()\n         }\n     }\n@@ -290,31 +274,27 @@ impl<T> VecPerParamSpace<T> {\n     /// `s` is the self space.\n     /// `a` is the assoc space.\n     /// `f` is the fn space.\n-    pub fn new(t: Vec<T>, s: Vec<T>, a: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n+    pub fn new(t: Vec<T>, s: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n         let type_limit = t.len();\n         let self_limit = type_limit + s.len();\n-        let assoc_limit = self_limit + a.len();\n \n         let mut content = t;\n         content.extend(s.into_iter());\n-        content.extend(a.into_iter());\n         content.extend(f.into_iter());\n \n         VecPerParamSpace {\n             type_limit: type_limit,\n             self_limit: self_limit,\n-            assoc_limit: assoc_limit,\n             content: content,\n         }\n     }\n \n-    fn new_internal(content: Vec<T>, type_limit: uint, self_limit: uint, assoc_limit: uint)\n+    fn new_internal(content: Vec<T>, type_limit: uint, self_limit: uint)\n                     -> VecPerParamSpace<T>\n     {\n         VecPerParamSpace {\n             type_limit: type_limit,\n             self_limit: self_limit,\n-            assoc_limit: assoc_limit,\n             content: content,\n         }\n     }\n@@ -326,9 +306,8 @@ impl<T> VecPerParamSpace<T> {\n     pub fn push(&mut self, space: ParamSpace, value: T) {\n         let (_, limit) = self.limits(space);\n         match space {\n-            TypeSpace => { self.type_limit += 1; self.self_limit += 1; self.assoc_limit += 1; }\n-            SelfSpace => { self.self_limit += 1; self.assoc_limit += 1; }\n-            AssocSpace => { self.assoc_limit += 1; }\n+            TypeSpace => { self.type_limit += 1; self.self_limit += 1; }\n+            SelfSpace => { self.self_limit += 1; }\n             FnSpace => { }\n         }\n         self.content.insert(limit, value);\n@@ -340,9 +319,8 @@ impl<T> VecPerParamSpace<T> {\n             None\n         } else {\n             match space {\n-                TypeSpace => { self.type_limit -= 1; self.self_limit -= 1; self.assoc_limit -= 1; }\n-                SelfSpace => { self.self_limit -= 1; self.assoc_limit -= 1; }\n-                AssocSpace => { self.assoc_limit -= 1; }\n+                TypeSpace => { self.type_limit -= 1; self.self_limit -= 1; }\n+                SelfSpace => { self.self_limit -= 1; }\n                 FnSpace => {}\n             }\n             self.content.remove(limit - 1)\n@@ -412,6 +390,10 @@ impl<T> VecPerParamSpace<T> {\n         self.content.as_slice()\n     }\n \n+    pub fn to_vec(self) -> Vec<T> {\n+        self.content\n+    }\n+\n     pub fn all_vecs<P>(&self, mut pred: P) -> bool where\n         P: FnMut(&[T]) -> bool,\n     {\n@@ -435,8 +417,7 @@ impl<T> VecPerParamSpace<T> {\n         let result = self.iter().map(pred).collect();\n         VecPerParamSpace::new_internal(result,\n                                        self.type_limit,\n-                                       self.self_limit,\n-                                       self.assoc_limit)\n+                                       self.self_limit)\n     }\n \n     pub fn map_enumerated<U, P>(&self, pred: P) -> VecPerParamSpace<U> where\n@@ -445,8 +426,7 @@ impl<T> VecPerParamSpace<T> {\n         let result = self.iter_enumerated().map(pred).collect();\n         VecPerParamSpace::new_internal(result,\n                                        self.type_limit,\n-                                       self.self_limit,\n-                                       self.assoc_limit)\n+                                       self.self_limit)\n     }\n \n     pub fn map_move<U, F>(self, mut pred: F) -> VecPerParamSpace<U> where\n@@ -455,25 +435,22 @@ impl<T> VecPerParamSpace<T> {\n         let SeparateVecsPerParamSpace {\n             types: t,\n             selfs: s,\n-            assocs: a,\n             fns: f\n         } = self.split();\n \n         VecPerParamSpace::new(t.into_iter().map(|p| pred(p)).collect(),\n                               s.into_iter().map(|p| pred(p)).collect(),\n-                              a.into_iter().map(|p| pred(p)).collect(),\n                               f.into_iter().map(|p| pred(p)).collect())\n     }\n \n     pub fn split(self) -> SeparateVecsPerParamSpace<T> {\n-        let VecPerParamSpace { type_limit, self_limit, assoc_limit, content } = self;\n+        let VecPerParamSpace { type_limit, self_limit, content } = self;\n \n         let mut content_iter = content.into_iter();\n \n         SeparateVecsPerParamSpace {\n             types: content_iter.by_ref().take(type_limit).collect(),\n             selfs: content_iter.by_ref().take(self_limit - type_limit).collect(),\n-            assocs: content_iter.by_ref().take(assoc_limit - self_limit).collect(),\n             fns: content_iter.collect()\n         }\n     }\n@@ -487,6 +464,7 @@ impl<T> VecPerParamSpace<T> {\n     }\n }\n \n+#[deriving(Clone)]\n pub struct EnumeratedItems<'a,T:'a> {\n     vec: &'a VecPerParamSpace<T>,\n     space_index: uint,"}, {"sha": "d8b39d92c692fad9ca0c392338ce1db322ef18ed", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -45,7 +45,9 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n     let param_env = ty::empty_parameter_environment();\n     let mut selcx = SelectionContext::intercrate(infcx, &param_env, infcx.tcx);\n     let obligation = Obligation::new(ObligationCause::dummy(),\n-                                     Rc::new(ty::Binder(impl1_trait_ref)));\n+                                     ty::Binder(ty::TraitPredicate {\n+                                         trait_ref: Rc::new(impl1_trait_ref),\n+                                     }));\n     debug!(\"impl_can_satisfy(obligation={})\", obligation.repr(infcx.tcx));\n     selcx.evaluate_impl(impl2_def_id, &obligation)\n }\n@@ -140,7 +142,7 @@ pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         }\n \n         ty::ty_trait(ref tt) => {\n-            tt.principal.def_id().krate == ast::LOCAL_CRATE\n+            tt.principal_def_id().krate == ast::LOCAL_CRATE\n         }\n \n         // Type parameters may be bound to types that are not local to\n@@ -149,6 +151,11 @@ pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n             false\n         }\n \n+        // Associated types could be anything, I guess.\n+        ty::ty_projection(..) => {\n+            false\n+        }\n+\n         ty::ty_infer(..) |\n         ty::ty_open(..) |\n         ty::ty_err => {"}, {"sha": "a3d92c698a2ad358ca7e368708e76c797146ab15", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 90, "deletions": 102, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -8,12 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{FulfillmentError, FulfillmentErrorCode,\n-            ObligationCauseCode, SelectionError,\n-            PredicateObligation, OutputTypeParameterMismatch};\n+use super::{\n+    FulfillmentError,\n+    FulfillmentErrorCode,\n+    MismatchedProjectionTypes,\n+    ObligationCauseCode,\n+    OutputTypeParameterMismatch,\n+    PredicateObligation,\n+    SelectionError,\n+};\n \n use middle::infer::InferCtxt;\n-use middle::ty::{mod};\n+use middle::ty::{mod, AsPredicate, ReferencesError, ToPolyTraitRef};\n use syntax::codemap::Span;\n use util::ppaux::{Repr, UserString};\n \n@@ -30,51 +36,46 @@ fn report_fulfillment_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         FulfillmentErrorCode::CodeSelectionError(ref e) => {\n             report_selection_error(infcx, &error.obligation, e);\n         }\n+        FulfillmentErrorCode::CodeProjectionError(ref e) => {\n+            report_projection_error(infcx, &error.obligation, e);\n+        }\n         FulfillmentErrorCode::CodeAmbiguity => {\n             maybe_report_ambiguity(infcx, &error.obligation);\n         }\n     }\n }\n \n+pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                         obligation: &PredicateObligation<'tcx>,\n+                                         error: &MismatchedProjectionTypes<'tcx>)\n+{\n+    let predicate =\n+        infcx.resolve_type_vars_if_possible(&obligation.predicate);\n+    if !predicate.references_error() {\n+        infcx.tcx.sess.span_err(\n+            obligation.cause.span,\n+            format!(\n+                \"type mismatch resolving `{}`: {}\",\n+                predicate.user_string(infcx.tcx),\n+                ty::type_err_to_str(infcx.tcx, &error.err)).as_slice());\n+        note_obligation_cause(infcx, obligation);\n+    }\n+}\n+\n pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                         obligation: &PredicateObligation<'tcx>,\n                                         error: &SelectionError<'tcx>)\n {\n     match *error {\n         SelectionError::Overflow => {\n             // We could track the stack here more precisely if we wanted, I imagine.\n-            match obligation.trait_ref {\n-                ty::Predicate::Trait(ref trait_ref) => {\n-                    let trait_ref =\n-                        infcx.resolve_type_vars_if_possible(&**trait_ref);\n-                    infcx.tcx.sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n-                            \"overflow evaluating the trait `{}` for the type `{}`\",\n-                            trait_ref.user_string(infcx.tcx),\n-                            trait_ref.self_ty().user_string(infcx.tcx))[]);\n-                }\n-\n-                ty::Predicate::Equate(ref predicate) => {\n-                    let predicate = infcx.resolve_type_vars_if_possible(predicate);\n-                    let err = infcx.equality_predicate(obligation.cause.span,\n-                                                       &predicate).unwrap_err();\n-\n-                    infcx.tcx.sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate.user_string(infcx.tcx),\n-                            ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n-                }\n-\n-                ty::Predicate::TypeOutlives(..) |\n-                ty::Predicate::RegionOutlives(..) => {\n-                    infcx.tcx.sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\"overflow evaluating lifetime predicate\").as_slice());\n-                }\n-            }\n+            let predicate =\n+                infcx.resolve_type_vars_if_possible(&obligation.predicate);\n+            infcx.tcx.sess.span_err(\n+                obligation.cause.span,\n+                format!(\n+                    \"overflow evaluating the requirement `{}`\",\n+                    predicate.user_string(infcx.tcx)).as_slice());\n \n             let current_limit = infcx.tcx.sess.recursion_limit.get();\n             let suggested_limit = current_limit * 2;\n@@ -87,27 +88,37 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             note_obligation_cause(infcx, obligation);\n         }\n         SelectionError::Unimplemented => {\n-            match obligation.trait_ref {\n-                ty::Predicate::Trait(ref trait_ref) => {\n-                    let trait_ref =\n-                        infcx.resolve_type_vars_if_possible(\n-                            &**trait_ref);\n-                    if !ty::type_is_error(trait_ref.self_ty()) {\n+            match obligation.predicate {\n+                ty::Predicate::Trait(ref trait_predicate) => {\n+                    let trait_predicate =\n+                        infcx.resolve_type_vars_if_possible(trait_predicate);\n+                    if !trait_predicate.references_error() {\n+                        let trait_ref = trait_predicate.to_poly_trait_ref();\n                         infcx.tcx.sess.span_err(\n                             obligation.cause.span,\n                             format!(\n                                 \"the trait `{}` is not implemented for the type `{}`\",\n                                 trait_ref.user_string(infcx.tcx),\n                                 trait_ref.self_ty().user_string(infcx.tcx)).as_slice());\n-                        note_obligation_cause(infcx, obligation);\n                     }\n                 }\n \n                 ty::Predicate::Equate(ref predicate) => {\n                     let predicate = infcx.resolve_type_vars_if_possible(predicate);\n                     let err = infcx.equality_predicate(obligation.cause.span,\n-                                                       &predicate).unwrap_err();\n+                                                             &predicate).unwrap_err();\n+                    infcx.tcx.sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate.user_string(infcx.tcx),\n+                            ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                }\n \n+                ty::Predicate::RegionOutlives(ref predicate) => {\n+                    let predicate = infcx.resolve_type_vars_if_possible(predicate);\n+                    let err = infcx.region_outlives_predicate(obligation.cause.span,\n+                                                              &predicate).unwrap_err();\n                     infcx.tcx.sess.span_err(\n                         obligation.cause.span,\n                         format!(\n@@ -116,9 +127,10 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n                 }\n \n-                ty::Predicate::TypeOutlives(..) |\n-                ty::Predicate::RegionOutlives(..) => {\n-                    let predicate = infcx.resolve_type_vars_if_possible(&obligation.trait_ref);\n+                ty::Predicate::Projection(..) |\n+                ty::Predicate::TypeOutlives(..) => {\n+                    let predicate =\n+                        infcx.resolve_type_vars_if_possible(&obligation.predicate);\n                     infcx.tcx.sess.span_err(\n                         obligation.cause.span,\n                         format!(\n@@ -128,12 +140,8 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             }\n         }\n         OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n-            let expected_trait_ref =\n-                infcx.resolve_type_vars_if_possible(\n-                    &**expected_trait_ref);\n-            let actual_trait_ref =\n-                infcx.resolve_type_vars_if_possible(\n-                    &**actual_trait_ref);\n+            let expected_trait_ref = infcx.resolve_type_vars_if_possible(&*expected_trait_ref);\n+            let actual_trait_ref = infcx.resolve_type_vars_if_possible(&*actual_trait_ref);\n             if !ty::type_is_error(actual_trait_ref.self_ty()) {\n                 infcx.tcx.sess.span_err(\n                     obligation.cause.span,\n@@ -150,24 +158,26 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n-fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                    obligation: &PredicateObligation<'tcx>) {\n+pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                        obligation: &PredicateObligation<'tcx>) {\n     // Unable to successfully determine, probably means\n     // insufficient type information, but could mean\n     // ambiguous impls. The latter *ought* to be a\n     // coherence violation, so we don't report it here.\n \n-    let trait_ref = match obligation.trait_ref {\n-        ty::Predicate::Trait(ref trait_ref) => {\n-            infcx.resolve_type_vars_if_possible(&**trait_ref)\n+    let trait_ref = match obligation.predicate {\n+        ty::Predicate::Trait(ref trait_predicate) => {\n+            infcx.resolve_type_vars_if_possible(\n+                &trait_predicate.to_poly_trait_ref())\n         }\n         _ => {\n             infcx.tcx.sess.span_bug(\n                 obligation.cause.span,\n                 format!(\"ambiguity from something other than a trait: {}\",\n-                        obligation.trait_ref.repr(infcx.tcx)).as_slice());\n+                        obligation.predicate.repr(infcx.tcx)).as_slice());\n         }\n     };\n+\n     let self_ty = trait_ref.self_ty();\n \n     debug!(\"maybe_report_ambiguity(trait_ref={}, self_ty={}, obligation={})\",\n@@ -208,7 +218,7 @@ fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                          locate the impl of the trait `{}` for \\\n                          the type `{}`; type annotations required\",\n                         trait_ref.user_string(infcx.tcx),\n-                        self_ty.user_string(infcx.tcx))[]);\n+                        self_ty.user_string(infcx.tcx)).as_slice());\n                 note_obligation_cause(infcx, obligation);\n             }\n         }\n@@ -221,56 +231,38 @@ fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                  cannot locate the impl of the trait `{}` for \\\n                  the type `{}`\",\n                 trait_ref.user_string(infcx.tcx),\n-                self_ty.user_string(infcx.tcx))[]);\n+                self_ty.user_string(infcx.tcx)).as_slice());\n     }\n }\n \n fn note_obligation_cause<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                    obligation: &PredicateObligation<'tcx>)\n {\n-    let trait_ref = match obligation.trait_ref {\n-        ty::Predicate::Trait(ref trait_ref) => {\n-            infcx.resolve_type_vars_if_possible(&**trait_ref)\n-        }\n-        _ => {\n-            infcx.tcx.sess.span_bug(\n-                obligation.cause.span,\n-                format!(\"ambiguity from something other than a trait: {}\",\n-                        obligation.trait_ref.repr(infcx.tcx)).as_slice());\n-        }\n-    };\n-\n     note_obligation_cause_code(infcx,\n-                               &trait_ref,\n+                               &obligation.predicate,\n                                obligation.cause.span,\n-                               &obligation.cause.code)\n+                               &obligation.cause.code);\n }\n \n fn note_obligation_cause_code<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                        trait_ref: &ty::PolyTraitRef<'tcx>,\n+                                        _predicate: &ty::Predicate<'tcx>,\n                                         cause_span: Span,\n                                         cause_code: &ObligationCauseCode<'tcx>)\n {\n     let tcx = infcx.tcx;\n-    let trait_name = ty::item_path_str(tcx, trait_ref.def_id());\n     match *cause_code {\n         ObligationCauseCode::MiscObligation => { }\n         ObligationCauseCode::ItemObligation(item_def_id) => {\n             let item_name = ty::item_path_str(tcx, item_def_id);\n             tcx.sess.span_note(\n                 cause_span,\n-                format!(\n-                    \"the trait `{}` must be implemented because it is required by `{}`\",\n-                    trait_name,\n-                    item_name).as_slice());\n+                format!(\"required by `{}`\", item_name).as_slice());\n         }\n         ObligationCauseCode::ObjectCastObligation(object_ty) => {\n             tcx.sess.span_note(\n                 cause_span,\n                 format!(\n-                    \"the trait `{}` must be implemented for the cast \\\n-                     to the object type `{}`\",\n-                    trait_name,\n+                    \"required for the cast to the object type `{}`\",\n                     infcx.ty_to_string(object_ty)).as_slice());\n         }\n         ObligationCauseCode::RepeatVec => {\n@@ -323,27 +315,23 @@ fn note_obligation_cause_code<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             span_note!(tcx.sess, cause_span,\n                        \"shared static variables must have a type that implements `Sync`\");\n         }\n-        ObligationCauseCode::BuiltinDerivedObligation(ref root_trait_ref, ref root_cause_code) => {\n-            let root_trait_ref =\n-                infcx.resolve_type_vars_if_possible(&**root_trait_ref);\n+        ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n+            let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n             span_note!(tcx.sess, cause_span,\n-                       \"the type `{}` must implement `{}` because it appears within the type `{}`\",\n-                       trait_ref.self_ty().user_string(infcx.tcx),\n-                       trait_ref.user_string(infcx.tcx),\n-                       root_trait_ref.self_ty().user_string(infcx.tcx));\n-            note_obligation_cause_code(infcx, &root_trait_ref, cause_span, &**root_cause_code);\n+                       \"required because it appears within the type `{}`\",\n+                       parent_trait_ref.0.self_ty().user_string(infcx.tcx));\n+            let parent_predicate = parent_trait_ref.as_predicate();\n+            note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n         }\n-        ObligationCauseCode::ImplDerivedObligation(ref root_trait_ref, ref root_cause_code) => {\n-            let root_trait_ref =\n-                infcx.resolve_type_vars_if_possible(&**root_trait_ref);\n+        ObligationCauseCode::ImplDerivedObligation(ref data) => {\n+            let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n             span_note!(tcx.sess, cause_span,\n-                       \"the type `{}` must implement `{}` due to the requirements \\\n-                        on the impl of `{}` for the type `{}`\",\n-                       trait_ref.self_ty().user_string(infcx.tcx),\n-                       trait_ref.user_string(infcx.tcx),\n-                       root_trait_ref.user_string(infcx.tcx),\n-                       root_trait_ref.self_ty().user_string(infcx.tcx));\n-            note_obligation_cause_code(infcx, &root_trait_ref, cause_span, &**root_cause_code);\n+                       \"required because of the requirements on the impl of `{}` for `{}`\",\n+                       parent_trait_ref.user_string(infcx.tcx),\n+                       parent_trait_ref.0.self_ty().user_string(infcx.tcx));\n+            let parent_predicate = parent_trait_ref.as_predicate();\n+            note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n         }\n     }\n }\n+"}, {"sha": "7ec221fcfa9037c7a591cf9410eb156ecead367c", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 187, "deletions": 61, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -8,28 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::infer::InferCtxt;\n+use middle::infer::{mod, InferCtxt};\n use middle::mem_categorization::Typer;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, AsPredicate, RegionEscape, Ty, ToPolyTraitRef};\n use std::collections::HashSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::default::Default;\n-use std::rc::Rc;\n use syntax::ast;\n use util::common::ErrorReported;\n use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n \n use super::CodeAmbiguity;\n+use super::CodeProjectionError;\n use super::CodeSelectionError;\n use super::FulfillmentError;\n use super::Obligation;\n use super::ObligationCause;\n use super::PredicateObligation;\n-use super::Selection;\n+use super::project;\n use super::select::SelectionContext;\n-use super::poly_trait_ref_for_builtin_bound;\n use super::Unimplemented;\n+use super::util::predicate_for_builtin_bound;\n \n /// The fulfillment context is used to drive trait resolution.  It\n /// consists of a list of obligations that must be (eventually)\n@@ -101,55 +101,74 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n-    pub fn register_builtin_bound(&mut self,\n-                                  tcx: &ty::ctxt<'tcx>,\n-                                  ty: Ty<'tcx>,\n-                                  builtin_bound: ty::BuiltinBound,\n-                                  cause: ObligationCause<'tcx>)\n+    /// \"Normalize\" a projection type `<SomeType as SomeTrait>::X` by\n+    /// creating a fresh type variable `$0` as well as a projection\n+    /// predicate `<SomeType as SomeTrait>::X == $0`. When the\n+    /// inference engine runs, it will attempt to find an impl of\n+    /// `SomeTrait` or a where clause that lets us unify `$0` with\n+    /// something concrete. If this fails, we'll unify `$0` with\n+    /// `projection_ty` again.\n+    pub fn normalize_projection_type<'a>(&mut self,\n+                                         infcx: &InferCtxt<'a,'tcx>,\n+                                         projection_ty: ty::ProjectionTy<'tcx>,\n+                                         cause: ObligationCause<'tcx>)\n+                                         -> Ty<'tcx>\n     {\n-        match poly_trait_ref_for_builtin_bound(tcx, builtin_bound, ty) {\n-            Ok(trait_ref) => {\n-                self.register_trait_ref(tcx, trait_ref, cause);\n-            }\n-            Err(ErrorReported) => { }\n-        }\n+        debug!(\"normalize_associated_type(projection_ty={})\",\n+               projection_ty.repr(infcx.tcx));\n+\n+        assert!(!projection_ty.has_escaping_regions());\n+\n+        // FIXME(#20304) -- cache\n+\n+        let ty_var = infcx.next_ty_var();\n+        let projection =\n+            ty::Binder(ty::ProjectionPredicate {\n+                projection_ty: projection_ty,\n+                ty: ty_var\n+            });\n+        let obligation = Obligation::new(cause, projection.as_predicate());\n+        self.register_predicate(infcx, obligation);\n+\n+        debug!(\"normalize_associated_type: result={}\", ty_var.repr(infcx.tcx));\n+\n+        ty_var\n     }\n \n-    pub fn register_trait_ref<'a>(&mut self,\n-                                  tcx: &ty::ctxt<'tcx>,\n-                                  trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n-                                  cause: ObligationCause<'tcx>)\n+    pub fn register_builtin_bound<'a>(&mut self,\n+                                      infcx: &InferCtxt<'a,'tcx>,\n+                                      ty: Ty<'tcx>,\n+                                      builtin_bound: ty::BuiltinBound,\n+                                      cause: ObligationCause<'tcx>)\n     {\n-        /*!\n-         * A convenience function for registering trait obligations.\n-         */\n-\n-        let trait_obligation = Obligation { cause: cause,\n-                                            recursion_depth: 0,\n-                                            trait_ref: ty::Predicate::Trait(trait_ref) };\n-        self.register_predicate(tcx, trait_obligation)\n+        match predicate_for_builtin_bound(infcx.tcx, cause, builtin_bound, 0, ty) {\n+            Ok(predicate) => {\n+                self.register_predicate(infcx, predicate);\n+            }\n+            Err(ErrorReported) => { }\n+        }\n     }\n \n-    pub fn register_region_obligation(&mut self,\n-                                      tcx: &ty::ctxt<'tcx>,\n-                                      t_a: Ty<'tcx>,\n-                                      r_b: ty::Region,\n-                                      cause: ObligationCause<'tcx>)\n+    pub fn register_region_obligation<'a>(&mut self,\n+                                          infcx: &InferCtxt<'a,'tcx>,\n+                                          t_a: Ty<'tcx>,\n+                                          r_b: ty::Region,\n+                                          cause: ObligationCause<'tcx>)\n     {\n-        register_region_obligation(tcx, t_a, r_b, cause, &mut self.region_obligations);\n+        register_region_obligation(infcx.tcx, t_a, r_b, cause, &mut self.region_obligations);\n     }\n \n     pub fn register_predicate<'a>(&mut self,\n-                                  tcx: &ty::ctxt<'tcx>,\n-                                  predicate: PredicateObligation<'tcx>)\n+                                  infcx: &InferCtxt<'a,'tcx>,\n+                                  obligation: PredicateObligation<'tcx>)\n     {\n-        if !self.duplicate_set.insert(predicate.trait_ref.clone()) {\n-            debug!(\"register_predicate({}) -- already seen, skip\", predicate.repr(tcx));\n+        if !self.duplicate_set.insert(obligation.predicate.clone()) {\n+            debug!(\"register_predicate({}) -- already seen, skip\", obligation.repr(infcx.tcx));\n             return;\n         }\n \n-        debug!(\"register_predicate({})\", predicate.repr(tcx));\n-        self.predicates.push(predicate);\n+        debug!(\"register_predicate({})\", obligation.repr(infcx.tcx));\n+        self.predicates.push(obligation);\n     }\n \n     pub fn region_obligations(&self,\n@@ -223,7 +242,6 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                self.predicates.len(),\n                only_new_obligations);\n \n-        let tcx = selcx.tcx();\n         let mut errors = Vec::new();\n \n         loop {\n@@ -232,7 +250,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             debug!(\"select_where_possible({} obligations) iteration\",\n                    count);\n \n-            let mut selections = Vec::new();\n+            let mut new_obligations = Vec::new();\n \n             // If we are only attempting obligations we haven't seen yet,\n             // then set `skip` to the number of obligations we've already\n@@ -253,7 +271,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                     let processed =\n                         if skip == 0 {\n                             process_predicate(selcx, predicate,\n-                                              &mut selections, &mut errors, region_obligations)\n+                                              &mut new_obligations, &mut errors, region_obligations)\n                         } else {\n                             skip -= 1;\n                             false\n@@ -271,8 +289,8 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n             // Now go through all the successful ones,\n             // registering any nested obligations for the future.\n-            for selection in selections.into_iter() {\n-                selection.map_move_nested(|p| self.register_predicate(tcx, p));\n+            for new_obligation in new_obligations.into_iter() {\n+                self.register_predicate(selcx.infcx(), new_obligation);\n             }\n         }\n \n@@ -289,8 +307,8 @@ impl<'tcx> FulfillmentContext<'tcx> {\n }\n \n fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                              predicate: &PredicateObligation<'tcx>,\n-                              selections: &mut Vec<Selection<'tcx>>,\n+                              obligation: &PredicateObligation<'tcx>,\n+                              new_obligations: &mut Vec<PredicateObligation<'tcx>>,\n                               errors: &mut Vec<FulfillmentError<'tcx>>,\n                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n                               -> bool\n@@ -303,52 +321,50 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n      */\n \n     let tcx = selcx.tcx();\n-    match predicate.trait_ref {\n-        ty::Predicate::Trait(ref trait_ref) => {\n-            let trait_obligation = Obligation { cause: predicate.cause.clone(),\n-                                                recursion_depth: predicate.recursion_depth,\n-                                                trait_ref: trait_ref.clone() };\n+    match obligation.predicate {\n+        ty::Predicate::Trait(ref data) => {\n+            let trait_obligation = obligation.with(data.clone());\n             match selcx.select(&trait_obligation) {\n                 Ok(None) => {\n                     false\n                 }\n                 Ok(Some(s)) => {\n-                    selections.push(s);\n+                    s.map_move_nested(|p| new_obligations.push(p));\n                     true\n                 }\n                 Err(selection_err) => {\n                     debug!(\"predicate: {} error: {}\",\n-                           predicate.repr(tcx),\n+                           obligation.repr(tcx),\n                            selection_err.repr(tcx));\n                     errors.push(\n                         FulfillmentError::new(\n-                            predicate.clone(),\n+                            obligation.clone(),\n                             CodeSelectionError(selection_err)));\n                     true\n                 }\n             }\n         }\n \n         ty::Predicate::Equate(ref binder) => {\n-            match selcx.infcx().equality_predicate(predicate.cause.span, binder) {\n+            match selcx.infcx().equality_predicate(obligation.cause.span, binder) {\n                 Ok(()) => { }\n                 Err(_) => {\n                     errors.push(\n                         FulfillmentError::new(\n-                            predicate.clone(),\n+                            obligation.clone(),\n                             CodeSelectionError(Unimplemented)));\n                 }\n             }\n             true\n         }\n \n         ty::Predicate::RegionOutlives(ref binder) => {\n-            match selcx.infcx().region_outlives_predicate(predicate.cause.span, binder) {\n+            match selcx.infcx().region_outlives_predicate(obligation.cause.span, binder) {\n                 Ok(()) => { }\n                 Err(_) => {\n                     errors.push(\n                         FulfillmentError::new(\n-                            predicate.clone(),\n+                            obligation.clone(),\n                             CodeSelectionError(Unimplemented)));\n                 }\n             }\n@@ -364,16 +380,126 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n             if ty::count_late_bound_regions(selcx.tcx(), binder) != 0 {\n                 errors.push(\n                     FulfillmentError::new(\n-                        predicate.clone(),\n+                        obligation.clone(),\n                         CodeSelectionError(Unimplemented)));\n             } else {\n                 let ty::OutlivesPredicate(t_a, r_b) = binder.0;\n                 register_region_obligation(tcx, t_a, r_b,\n-                                           predicate.cause.clone(),\n+                                           obligation.cause.clone(),\n                                            region_obligations);\n             }\n             true\n         }\n+\n+        ty::Predicate::Projection(ref data) => {\n+            let project_obligation = obligation.with(data.clone());\n+            let result = project::poly_project_and_unify_type(selcx, &project_obligation);\n+            debug!(\"poly_project_and_unify_type({}) = {}\",\n+                   project_obligation.repr(tcx),\n+                   result.repr(tcx));\n+            match result {\n+                Ok(()) => {\n+                    true\n+                }\n+                Err(project::ProjectionError::TooManyCandidates) => {\n+                    // Without more type information, we can't say much.\n+                    false\n+                }\n+                Err(project::ProjectionError::NoCandidate) => {\n+                    // This means that we have a type like `<T as\n+                    // Trait>::name = U` but we couldn't find any more\n+                    // information. This could just be that we're in a\n+                    // function like:\n+                    //\n+                    //     fn foo<T:Trait>(...)\n+                    //\n+                    // in which case this is not an error. But it\n+                    // might also mean we're in a situation where we\n+                    // don't actually know that `T : Trait` holds,\n+                    // which would be weird (e.g., if `T` was not a\n+                    // parameter type but a normal type, like `int`).\n+                    //\n+                    // So what we do is to (1) add a requirement that\n+                    // `T : Trait` (just in case) and (2) try to unify\n+                    // `U` with `<T as Trait>::name`.\n+\n+                    if !ty::binds_late_bound_regions(selcx.tcx(), data) {\n+                        // Check that `T : Trait` holds.\n+                        let trait_ref = data.to_poly_trait_ref();\n+                        new_obligations.push(obligation.with(trait_ref.as_predicate()));\n+\n+                        // Fallback to `<T as Trait>::name`. If this\n+                        // fails, then the output must be at least\n+                        // somewhat constrained, and we cannot verify\n+                        // that constraint, so yield an error.\n+                        let ty_projection = ty::mk_projection(tcx,\n+                                                              trait_ref.0.clone(),\n+                                                              data.0.projection_ty.item_name);\n+\n+                        debug!(\"process_predicate: falling back to projection {}\",\n+                               ty_projection.repr(selcx.tcx()));\n+\n+                        match infer::mk_eqty(selcx.infcx(),\n+                                             true,\n+                                             infer::EquatePredicate(obligation.cause.span),\n+                                             ty_projection,\n+                                             data.0.ty) {\n+                            Ok(()) => { }\n+                            Err(_) => {\n+                                debug!(\"process_predicate: fallback failed to unify; error\");\n+                                errors.push(\n+                                    FulfillmentError::new(\n+                                        obligation.clone(),\n+                                        CodeSelectionError(Unimplemented)));\n+                            }\n+                        }\n+\n+                        true\n+                    } else {\n+                        // If we have something like\n+                        //\n+                        //     for<'a> <T<'a> as Trait>::name == &'a int\n+                        //\n+                        // there is no \"canonical form\" for us to\n+                        // make, so just report the lack of candidates\n+                        // as an error.\n+\n+                        debug!(\"process_predicate: can't fallback, higher-ranked\");\n+                        errors.push(\n+                            FulfillmentError::new(\n+                                obligation.clone(),\n+                                CodeSelectionError(Unimplemented)));\n+\n+                        true\n+                    }\n+                }\n+                Err(project::ProjectionError::MismatchedTypes(e)) => {\n+                    errors.push(\n+                        FulfillmentError::new(\n+                            obligation.clone(),\n+                            CodeProjectionError(e)));\n+                    true\n+                }\n+                Err(project::ProjectionError::TraitSelectionError(_)) => {\n+                    // There was an error matching `T : Trait` (which\n+                    // is a pre-requisite for `<T as Trait>::Name`\n+                    // being valid).  We could just report the error\n+                    // now, but that tends to lead to double error\n+                    // reports for the user (one for the obligation `T\n+                    // : Trait`, typically incurred somewhere else,\n+                    // and one from here). Instead, we'll create the\n+                    // `T : Trait` obligation and add THAT as a\n+                    // requirement. This will (eventually) trigger the\n+                    // same error, but it will also wind up flagged as\n+                    // a duplicate if another requirement that `T :\n+                    // Trait` arises from somewhere else.\n+                    let trait_predicate = data.to_poly_trait_ref();\n+                    let trait_obligation = obligation.with(trait_predicate.as_predicate());\n+                    new_obligations.push(trait_obligation);\n+                    true\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "d4fa0c98ad5d14d348e222d85983999bd931cfdd", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 78, "deletions": 32, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -18,27 +18,31 @@ pub use self::ObligationCauseCode::*;\n use middle::subst;\n use middle::ty::{mod, Ty};\n use middle::infer::InferCtxt;\n-use std::rc::Rc;\n use std::slice::Iter;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n+use util::ppaux::Repr;\n \n pub use self::error_reporting::report_fulfillment_errors;\n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n+pub use self::project::MismatchedProjectionTypes;\n+pub use self::project::project_type;\n+pub use self::project::ProjectionResult;\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n pub use self::util::elaborate_predicates;\n+pub use self::util::trait_ref_for_builtin_bound;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n-pub use self::util::search_trait_and_supertraits_from_bound;\n pub use self::util::transitive_bounds;\n-pub use self::util::poly_trait_ref_for_builtin_bound;\n \n mod coherence;\n mod error_reporting;\n mod fulfill;\n+mod project;\n mod select;\n mod util;\n \n@@ -52,11 +56,11 @@ mod util;\n pub struct Obligation<'tcx, T> {\n     pub cause: ObligationCause<'tcx>,\n     pub recursion_depth: uint,\n-    pub trait_ref: T,\n+    pub predicate: T,\n }\n \n pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n-pub type TraitObligation<'tcx> = Obligation<'tcx, Rc<ty::PolyTraitRef<'tcx>>>;\n+pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n /// Why did we incur this obligation? Used for error reporting.\n #[deriving(Clone)]\n@@ -106,9 +110,21 @@ pub enum ObligationCauseCode<'tcx> {\n     // static items must have `Sync` type\n     SharedStatic,\n \n-    BuiltinDerivedObligation(Rc<ty::PolyTraitRef<'tcx>>, Rc<ObligationCauseCode<'tcx>>),\n+    BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n+\n+    ImplDerivedObligation(DerivedObligationCause<'tcx>),\n+}\n \n-    ImplDerivedObligation(Rc<ty::PolyTraitRef<'tcx>>, Rc<ObligationCauseCode<'tcx>>),\n+#[deriving(Clone)]\n+pub struct DerivedObligationCause<'tcx> {\n+    /// The trait reference of the parent obligation that led to the\n+    /// current obligation. Note that only trait obligations lead to\n+    /// derived obligations, so we just store the trait reference here\n+    /// directly.\n+    parent_trait_ref: ty::PolyTraitRef<'tcx>,\n+\n+    /// The parent trait had this cause\n+    parent_code: Rc<ObligationCauseCode<'tcx>>\n }\n \n pub type Obligations<'tcx, O> = subst::VecPerParamSpace<Obligation<'tcx, O>>;\n@@ -121,8 +137,8 @@ pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n pub enum SelectionError<'tcx> {\n     Unimplemented,\n     Overflow,\n-    OutputTypeParameterMismatch(Rc<ty::PolyTraitRef<'tcx>>,\n-                                Rc<ty::PolyTraitRef<'tcx>>,\n+    OutputTypeParameterMismatch(ty::PolyTraitRef<'tcx>,\n+                                ty::PolyTraitRef<'tcx>,\n                                 ty::type_err<'tcx>),\n }\n \n@@ -134,6 +150,7 @@ pub struct FulfillmentError<'tcx> {\n #[deriving(Clone)]\n pub enum FulfillmentErrorCode<'tcx> {\n     CodeSelectionError(SelectionError<'tcx>),\n+    CodeProjectionError(MismatchedProjectionTypes<'tcx>),\n     CodeAmbiguity,\n }\n \n@@ -174,10 +191,10 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n ///\n ///    // Case B: Vtable must be provided by caller. This applies when\n ///    // type is a type parameter.\n-///    param.clone();    // VtableParam(Oblig_1)\n+///    param.clone();    // VtableParam\n ///\n ///    // Case C: A mix of cases A and B.\n-///    mixed.clone();    // Vtable(Impl_1, [VtableParam(Oblig_1)])\n+///    mixed.clone();    // Vtable(Impl_1, [VtableParam])\n /// }\n /// ```\n ///\n@@ -191,7 +208,7 @@ pub enum Vtable<'tcx, N> {\n \n     /// Successful resolution to an obligation provided by the caller\n     /// for some type parameter.\n-    VtableParam(VtableParamData<'tcx>),\n+    VtableParam,\n \n     /// Successful resolution for a builtin trait.\n     VtableBuiltin(VtableBuiltinData<N>),\n@@ -228,15 +245,6 @@ pub struct VtableBuiltinData<N> {\n     pub nested: subst::VecPerParamSpace<N>\n }\n \n-/// A vtable provided as a parameter by the caller. For example, in a\n-/// function like `fn foo<T:Eq>(...)`, if the `eq()` method is invoked\n-/// on an instance of `T`, the vtable would be of type `VtableParam`.\n-#[deriving(PartialEq,Eq,Clone)]\n-pub struct VtableParamData<'tcx> {\n-    // In the above example, this would `Eq`\n-    pub bound: Rc<ty::PolyTraitRef<'tcx>>,\n-}\n-\n /// True if neither the trait nor self type is local. Note that `impl_def_id` must refer to an impl\n /// of a trait, not an inherent impl.\n pub fn is_orphan_impl(tcx: &ty::ctxt,\n@@ -265,14 +273,51 @@ pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n     util::predicates_for_generics(tcx, cause, 0, generic_bounds)\n }\n \n+/// Determines whether the type `ty` is known to meet `bound` and\n+/// returns true if so. Returns false if `ty` either does not meet\n+/// `bound` or is not known to meet bound (note that this is\n+/// conservative towards *no impl*, which is the opposite of the\n+/// `evaluate` methods).\n+pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                                 param_env: &ty::ParameterEnvironment<'tcx>,\n+                                                 ty: Ty<'tcx>,\n+                                                 bound: ty::BuiltinBound)\n+                                                 -> bool\n+{\n+    debug!(\"type_known_to_meet_builtin_bound(ty={}, bound={})\",\n+           ty.repr(infcx.tcx),\n+           bound);\n+\n+    let mut fulfill_cx = FulfillmentContext::new();\n+\n+    // We can use dummy values here because we won't report any errors\n+    // that result nor will we pay any mind to region obligations that arise\n+    // (there shouldn't really be any anyhow).\n+    let cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n+\n+    fulfill_cx.register_builtin_bound(infcx, ty, bound, cause);\n+\n+    // Note: we only assume something is `Copy` if we can\n+    // *definitively* show that it implements `Copy`. Otherwise,\n+    // assume it is move; linear is always ok.\n+    let result = fulfill_cx.select_all_or_error(infcx, param_env, infcx.tcx).is_ok();\n+\n+    debug!(\"type_known_to_meet_builtin_bound: ty={} bound={} result={}\",\n+           ty.repr(infcx.tcx),\n+           bound,\n+           result);\n+\n+    result\n+}\n+\n impl<'tcx,O> Obligation<'tcx,O> {\n     pub fn new(cause: ObligationCause<'tcx>,\n                trait_ref: O)\n                -> Obligation<'tcx, O>\n     {\n         Obligation { cause: cause,\n                      recursion_depth: 0,\n-                     trait_ref: trait_ref }\n+                     predicate: trait_ref }\n     }\n \n     pub fn misc(span: Span, body_id: ast::NodeId, trait_ref: O) -> Obligation<'tcx, O> {\n@@ -282,13 +327,7 @@ impl<'tcx,O> Obligation<'tcx,O> {\n     pub fn with<P>(&self, value: P) -> Obligation<'tcx,P> {\n         Obligation { cause: self.cause.clone(),\n                      recursion_depth: self.recursion_depth,\n-                     trait_ref: value }\n-    }\n-}\n-\n-impl<'tcx> TraitObligation<'tcx> {\n-    pub fn self_ty(&self) -> Ty<'tcx> {\n-        self.trait_ref.self_ty()\n+                     predicate: value }\n     }\n }\n \n@@ -315,7 +354,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableImpl(ref i) => i.iter_nested(),\n             VtableFnPointer(..) => (&[]).iter(),\n             VtableUnboxedClosure(..) => (&[]).iter(),\n-            VtableParam(_) => (&[]).iter(),\n+            VtableParam => (&[]).iter(),\n             VtableBuiltin(ref i) => i.iter_nested(),\n         }\n     }\n@@ -325,7 +364,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableImpl(ref i) => VtableImpl(i.map_nested(op)),\n             VtableFnPointer(ref sig) => VtableFnPointer((*sig).clone()),\n             VtableUnboxedClosure(d, ref s) => VtableUnboxedClosure(d, s.clone()),\n-            VtableParam(ref p) => VtableParam((*p).clone()),\n+            VtableParam => VtableParam,\n             VtableBuiltin(ref b) => VtableBuiltin(b.map_nested(op)),\n         }\n     }\n@@ -337,7 +376,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableImpl(i) => VtableImpl(i.map_move_nested(op)),\n             VtableFnPointer(sig) => VtableFnPointer(sig),\n             VtableUnboxedClosure(d, s) => VtableUnboxedClosure(d, s),\n-            VtableParam(p) => VtableParam(p),\n+            VtableParam => VtableParam,\n             VtableBuiltin(no) => VtableBuiltin(no.map_move_nested(op)),\n         }\n     }\n@@ -403,6 +442,13 @@ impl<'tcx> FulfillmentError<'tcx> {\n             CodeAmbiguity => false,\n             CodeSelectionError(Overflow) => true,\n             CodeSelectionError(_) => false,\n+            CodeProjectionError(_) => false,\n         }\n     }\n }\n+\n+impl<'tcx> TraitObligation<'tcx> {\n+    fn self_ty(&self) -> Ty<'tcx> {\n+        self.predicate.0.self_ty()\n+    }\n+}"}, {"sha": "435babf168e86d79abd53f6218469c67e5d7e4a6", "filename": "src/librustc/middle/traits/project.rs", "status": "added", "additions": 414, "deletions": 0, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,414 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code for projecting associated types out of trait references.\n+\n+use super::elaborate_predicates;\n+use super::Obligation;\n+use super::PredicateObligation;\n+use super::SelectionContext;\n+use super::SelectionError;\n+use super::VtableImplData;\n+\n+use middle::infer;\n+use middle::subst::Subst;\n+use middle::ty::{mod, AsPredicate, ToPolyTraitRef, Ty};\n+use util::ppaux::Repr;\n+\n+pub type PolyProjectionObligation<'tcx> =\n+    Obligation<'tcx, ty::PolyProjectionPredicate<'tcx>>;\n+\n+pub type ProjectionObligation<'tcx> =\n+    Obligation<'tcx, ty::ProjectionPredicate<'tcx>>;\n+\n+pub type ProjectionTyObligation<'tcx> =\n+    Obligation<'tcx, ty::ProjectionTy<'tcx>>;\n+\n+/// When attempting to resolve `<T as TraitRef>::Name == U`...\n+pub enum ProjectionError<'tcx> {\n+    /// ...we could not find any helpful information on what `Name`\n+    /// might be. This could occur, for example, if there is a where\n+    /// clause `T : TraitRef` but not `T : TraitRef<Name=V>`. When\n+    /// normalizing, this case is where we opt to normalize back to\n+    /// the projection type `<T as TraitRef>::Name`.\n+    NoCandidate,\n+\n+    /// ...we found multiple sources of information and couldn't resolve the ambiguity.\n+    TooManyCandidates,\n+\n+    /// ...`<T as TraitRef::Name>` ws resolved to some type `V` that failed to unify with `U`\n+    MismatchedTypes(MismatchedProjectionTypes<'tcx>),\n+\n+    /// ...an error occurred matching `T : TraitRef`\n+    TraitSelectionError(SelectionError<'tcx>),\n+}\n+\n+#[deriving(Clone)]\n+pub struct MismatchedProjectionTypes<'tcx> {\n+    pub err: ty::type_err<'tcx>\n+}\n+\n+pub type ProjectionResult<'tcx, T> = Result<T, ProjectionError<'tcx>>;\n+\n+enum ProjectionTyCandidate<'tcx> {\n+    ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n+    Impl(VtableImplData<'tcx, PredicateObligation<'tcx>>),\n+}\n+\n+struct ProjectionTyCandidateSet<'tcx> {\n+    vec: Vec<ProjectionTyCandidate<'tcx>>,\n+    ambiguous: bool\n+}\n+\n+pub fn poly_project_and_unify_type<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &PolyProjectionObligation<'tcx>)\n+    -> ProjectionResult<'tcx, ()>\n+{\n+    debug!(\"poly_project(obligation={})\",\n+           obligation.repr(selcx.tcx()));\n+\n+    let infcx = selcx.infcx();\n+\n+    infcx.try(|snapshot| {\n+        let (skol_predicate, skol_map) =\n+            infcx.skolemize_late_bound_regions(&obligation.predicate, snapshot);\n+\n+        let skol_obligation = obligation.with(skol_predicate);\n+        let () = try!(project_and_unify_type(selcx, &skol_obligation));\n+        match infcx.leak_check(&skol_map, snapshot) {\n+            Ok(()) => Ok(()),\n+            Err(e) => Err(ProjectionError::MismatchedTypes(MismatchedProjectionTypes{err: e})),\n+        }\n+    })\n+}\n+\n+/// Compute result of projecting an associated type and unify it with\n+/// `obligation.predicate.ty` (if we can).\n+pub fn project_and_unify_type<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionObligation<'tcx>)\n+    -> ProjectionResult<'tcx, ()>\n+{\n+    debug!(\"project_and_unify(obligation={})\",\n+           obligation.repr(selcx.tcx()));\n+\n+    let ty_obligation = obligation.with(obligation.predicate.projection_ty.clone());\n+    let projected_ty = try!(project_type(selcx, &ty_obligation));\n+    let infcx = selcx.infcx();\n+    let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+    debug!(\"project_and_unify_type: projected_ty = {}\", projected_ty.repr(selcx.tcx()));\n+    match infer::mk_eqty(infcx, true, origin, projected_ty, obligation.predicate.ty) {\n+        Ok(()) => Ok(()),\n+        Err(e) => Err(ProjectionError::MismatchedTypes(MismatchedProjectionTypes{err: e})),\n+    }\n+}\n+\n+/// Compute the result of a projection type (if we can).\n+pub fn project_type<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>)\n+    -> ProjectionResult<'tcx, Ty<'tcx>>\n+{\n+    debug!(\"project(obligation={})\",\n+           obligation.repr(selcx.tcx()));\n+\n+    let mut candidates = ProjectionTyCandidateSet {\n+        vec: Vec::new(),\n+        ambiguous: false,\n+    };\n+\n+    let () = assemble_candidates_from_param_env(selcx,\n+                                                obligation,\n+                                                &mut candidates);\n+\n+    let () = assemble_candidates_from_object_type(selcx,\n+                                                  obligation,\n+                                                  &mut candidates);\n+\n+    if candidates.vec.is_empty() {\n+        // FIXME(#20297) -- In `select.rs` there is similar logic that\n+        // gives precedence to where-clauses, but it's a bit more\n+        // fine-grained. I was lazy here and just always give\n+        // precedence to where-clauses or other such sources over\n+        // actually dredging through impls. This logic probably should\n+        // be tightened up.\n+\n+        let () = try!(assemble_candidates_from_impls(selcx,\n+                                                     obligation,\n+                                                     &mut candidates));\n+    }\n+\n+    debug!(\"{} candidates, ambiguous={}\",\n+           candidates.vec.len(),\n+           candidates.ambiguous);\n+\n+    // We probably need some winnowing logic similar to select here.\n+\n+    if candidates.ambiguous || candidates.vec.len() > 1 {\n+        return Err(ProjectionError::TooManyCandidates);\n+    }\n+\n+    match candidates.vec.pop() {\n+        Some(candidate) => {\n+            Ok(try!(confirm_candidate(selcx, obligation, candidate)))\n+        }\n+        None => {\n+            Err(ProjectionError::NoCandidate)\n+        }\n+    }\n+}\n+\n+/// The first thing we have to do is scan through the parameter\n+/// environment to see whether there are any projection predicates\n+/// there that can answer this question.\n+fn assemble_candidates_from_param_env<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation:  &ProjectionTyObligation<'tcx>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n+{\n+    let env_predicates = selcx.param_env().caller_bounds.predicates.clone();\n+    let env_predicates = env_predicates.iter().cloned().collect();\n+    assemble_candidates_from_predicates(selcx, obligation, candidate_set, env_predicates);\n+}\n+\n+fn assemble_candidates_from_predicates<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation:  &ProjectionTyObligation<'tcx>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+    env_predicates: Vec<ty::Predicate<'tcx>>)\n+{\n+    debug!(\"assemble_candidates_from_predicates(obligation={}, env_predicates={})\",\n+           obligation.repr(selcx.tcx()),\n+           env_predicates.repr(selcx.tcx()));\n+    let infcx = selcx.infcx();\n+    for predicate in elaborate_predicates(selcx.tcx(), env_predicates) {\n+        match predicate {\n+            ty::Predicate::Projection(ref data) => {\n+                let is_match = infcx.probe(|_| {\n+                    let origin = infer::Misc(obligation.cause.span);\n+                    let obligation_poly_trait_ref =\n+                        obligation.predicate.trait_ref.to_poly_trait_ref();\n+                    let data_poly_trait_ref =\n+                        data.to_poly_trait_ref();\n+                    infcx.sub_poly_trait_refs(false,\n+                                              origin,\n+                                              obligation_poly_trait_ref,\n+                                              data_poly_trait_ref).is_ok()\n+                });\n+\n+                if is_match {\n+                    candidate_set.vec.push(\n+                        ProjectionTyCandidate::ParamEnv(data.clone()));\n+                }\n+            }\n+            _ => { }\n+        }\n+    }\n+}\n+\n+fn assemble_candidates_from_object_type<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation:  &ProjectionTyObligation<'tcx>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n+{\n+    let infcx = selcx.infcx();\n+    let trait_ref = infcx.resolve_type_vars_if_possible(&obligation.predicate.trait_ref);\n+    debug!(\"assemble_candidates_from_object_type(trait_ref={})\",\n+           trait_ref.repr(infcx.tcx));\n+    let self_ty = trait_ref.self_ty();\n+    let data = match self_ty.sty {\n+        ty::ty_trait(ref data) => data,\n+        _ => { return; }\n+    };\n+    let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), self_ty);\n+    let env_predicates = projection_bounds.iter()\n+                                          .map(|p| p.as_predicate())\n+                                          .collect();\n+    assemble_candidates_from_predicates(selcx, obligation, candidate_set, env_predicates)\n+}\n+\n+fn assemble_candidates_from_impls<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation:  &ProjectionTyObligation<'tcx>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n+    -> ProjectionResult<'tcx, ()>\n+{\n+    // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n+    // start out by selecting the predicate `T as TraitRef<...>`:\n+    let trait_ref =\n+        obligation.predicate.trait_ref.to_poly_trait_ref();\n+    let trait_obligation =\n+        obligation.with(trait_ref.to_poly_trait_predicate());\n+    let vtable = match selcx.select(&trait_obligation) {\n+        Ok(Some(vtable)) => vtable,\n+        Ok(None) => {\n+            candidate_set.ambiguous = true;\n+            return Ok(());\n+        }\n+        Err(e) => {\n+            debug!(\"assemble_candidates_from_impls: selection error {}\",\n+                   e.repr(selcx.tcx()));\n+            return Err(ProjectionError::TraitSelectionError(e));\n+        }\n+    };\n+\n+    match vtable {\n+        super::VtableImpl(data) => {\n+            candidate_set.vec.push(\n+                ProjectionTyCandidate::Impl(data));\n+        }\n+        super::VtableParam(..) => {\n+            // This case tell us nothing about the value of an\n+            // associated type. Consider:\n+            //\n+            // ```\n+            // trait SomeTrait { type Foo; }\n+            // fn foo<T:SomeTrait>(...) { }\n+            // ```\n+            //\n+            // If the user writes `<T as SomeTrait>::Foo`, then the `T\n+            // : SomeTrait` binding does not help us decide what the\n+            // type `Foo` is (at least, not more specifically than\n+            // what we already knew).\n+            //\n+            // But wait, you say! What about an example like this:\n+            //\n+            // ```\n+            // fn bar<T:SomeTrait<Foo=uint>>(...) { ... }\n+            // ```\n+            //\n+            // Doesn't the `T : Sometrait<Foo=uint>` predicate help\n+            // resolve `T::Foo`? And of course it does, but in fact\n+            // that single predicate is desugared into two predicates\n+            // in the compiler: a trait predicate (`T : SomeTrait`) and a\n+            // projection. And the projection where clause is handled\n+            // in `assemble_candidates_from_param_env`.\n+        }\n+        super::VtableBuiltin(..) |\n+        super::VtableUnboxedClosure(..) |\n+        super::VtableFnPointer(..) => {\n+            // These traits have no associated types.\n+            selcx.tcx().sess.span_bug(\n+                obligation.cause.span,\n+                format!(\"Cannot project an associated type from `{}`\",\n+                        vtable.repr(selcx.tcx())).as_slice());\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn confirm_candidate<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation:  &ProjectionTyObligation<'tcx>,\n+    candidate: ProjectionTyCandidate<'tcx>)\n+    -> ProjectionResult<'tcx, Ty<'tcx>>\n+{\n+    let infcx = selcx.infcx();\n+\n+    debug!(\"confirm_candidate(candidate={}, obligation={})\",\n+           candidate.repr(infcx.tcx),\n+           obligation.repr(infcx.tcx));\n+\n+    let projected_ty = match candidate {\n+        ProjectionTyCandidate::ParamEnv(poly_projection) => {\n+            let projection =\n+                infcx.replace_late_bound_regions_with_fresh_var(\n+                    obligation.cause.span,\n+                    infer::LateBoundRegionConversionTime::HigherRankedType,\n+                    &poly_projection).0;\n+\n+            assert_eq!(projection.projection_ty.item_name,\n+                       obligation.predicate.item_name);\n+\n+            let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+            match infcx.sub_trait_refs(false,\n+                                       origin,\n+                                       obligation.predicate.trait_ref.clone(),\n+                                       projection.projection_ty.trait_ref.clone()) {\n+                Ok(()) => { }\n+                Err(e) => {\n+                    selcx.tcx().sess.span_bug(\n+                        obligation.cause.span,\n+                        format!(\"Failed to unify `{}` and `{}` in projection: {}\",\n+                                obligation.repr(selcx.tcx()),\n+                                projection.repr(selcx.tcx()),\n+                                ty::type_err_to_str(selcx.tcx(), &e)).as_slice());\n+                }\n+            }\n+\n+            projection.ty\n+        }\n+\n+        ProjectionTyCandidate::Impl(impl_vtable) => {\n+            // there don't seem to be nicer accessors to these:\n+            let impl_items_map = selcx.tcx().impl_items.borrow();\n+            let impl_or_trait_items_map = selcx.tcx().impl_or_trait_items.borrow();\n+\n+            let impl_items = &impl_items_map[impl_vtable.impl_def_id];\n+            let mut impl_ty = None;\n+            for impl_item in impl_items.iter() {\n+                let assoc_type = match impl_or_trait_items_map[impl_item.def_id()] {\n+                    ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n+                    ty::MethodTraitItem(..) => { continue; }\n+                };\n+\n+                if assoc_type.name != obligation.predicate.item_name {\n+                    continue;\n+                }\n+\n+                let impl_poly_ty = ty::lookup_item_type(selcx.tcx(), assoc_type.def_id);\n+                impl_ty = Some(impl_poly_ty.ty.subst(selcx.tcx(), &impl_vtable.substs));\n+                break;\n+            }\n+\n+            match impl_ty {\n+                Some(ty) => ty,\n+                None => {\n+                    selcx.tcx().sess.span_bug(\n+                        obligation.cause.span,\n+                        format!(\"impl `{}` did not contain projection for `{}`\",\n+                                impl_vtable.repr(selcx.tcx()),\n+                                obligation.repr(selcx.tcx())).as_slice());\n+                }\n+            }\n+        }\n+    };\n+\n+    Ok(projected_ty)\n+}\n+\n+impl<'tcx> Repr<'tcx> for ProjectionError<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match *self {\n+            ProjectionError::NoCandidate =>\n+                format!(\"NoCandidate\"),\n+            ProjectionError::TooManyCandidates =>\n+                format!(\"NoCandidate\"),\n+            ProjectionError::MismatchedTypes(ref m) =>\n+                format!(\"MismatchedTypes({})\", m.repr(tcx)),\n+            ProjectionError::TraitSelectionError(ref e) =>\n+                format!(\"TraitSelectionError({})\", e.repr(tcx)),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ProjectionTyCandidate<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match *self {\n+            ProjectionTyCandidate::ParamEnv(ref data) =>\n+                format!(\"ParamEnv({})\", data.repr(tcx)),\n+            ProjectionTyCandidate::Impl(ref data) =>\n+                format!(\"Impl({})\", data.repr(tcx))\n+        }\n+    }\n+}\n+"}, {"sha": "ce5337a58e10c102bab3fde612f46eb4659cb613", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 325, "deletions": 122, "changes": 447, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -13,23 +13,24 @@\n \n pub use self::MethodMatchResult::*;\n pub use self::MethodMatchedData::*;\n-use self::Candidate::*;\n+use self::SelectionCandidate::*;\n use self::BuiltinBoundConditions::*;\n use self::EvaluationResult::*;\n \n+use super::{DerivedObligationCause};\n use super::{PredicateObligation, Obligation, TraitObligation, ObligationCause};\n use super::{ObligationCauseCode, BuiltinDerivedObligation};\n use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n use super::{Selection};\n use super::{SelectionResult};\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure, VtableFnPointer};\n-use super::{VtableImplData, VtableParamData, VtableBuiltinData};\n+use super::{VtableImplData, VtableBuiltinData};\n use super::{util};\n \n use middle::fast_reject;\n use middle::mem_categorization::Typer;\n use middle::subst::{Subst, Substs, VecPerParamSpace};\n-use middle::ty::{mod, AsPredicate, RegionEscape, Ty};\n+use middle::ty::{mod, AsPredicate, RegionEscape, ToPolyTraitRef, Ty};\n use middle::infer;\n use middle::infer::{InferCtxt, TypeFreshener};\n use middle::ty_fold::TypeFoldable;\n@@ -75,15 +76,15 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n \n     /// Trait ref from `obligation` but skolemized with the\n     /// selection-context's freshener. Used to check for recursion.\n-    fresh_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n+    fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n \n     previous: Option<&'prev TraitObligationStack<'prev, 'tcx>>\n }\n \n #[deriving(Clone)]\n pub struct SelectionCache<'tcx> {\n-    hashmap: RefCell<HashMap<Rc<ty::PolyTraitRef<'tcx>>,\n-                             SelectionResult<'tcx, Candidate<'tcx>>>>,\n+    hashmap: RefCell<HashMap<Rc<ty::TraitRef<'tcx>>,\n+                             SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n }\n \n pub enum MethodMatchResult {\n@@ -128,11 +129,15 @@ pub enum MethodMatchedData {\n /// clauses can give additional information (like, the types of output\n /// parameters) that would have to be inferred from the impl.\n #[deriving(PartialEq,Eq,Show,Clone)]\n-enum Candidate<'tcx> {\n+enum SelectionCandidate<'tcx> {\n     BuiltinCandidate(ty::BuiltinBound),\n-    ParamCandidate(VtableParamData<'tcx>),\n+    ParamCandidate(ty::PolyTraitRef<'tcx>),\n     ImplCandidate(ast::DefId),\n \n+    /// This is a trait matching with a projected type as `Self`, and\n+    /// we found an applicable bound in the trait definition.\n+    ProjectionCandidate,\n+\n     /// Implementation of a `Fn`-family trait by one of the\n     /// anonymous types generated for a `||` expression.\n     UnboxedClosureCandidate(/* closure */ ast::DefId, Substs<'tcx>),\n@@ -144,9 +149,16 @@ enum Candidate<'tcx> {\n     ErrorCandidate,\n }\n \n-struct CandidateSet<'tcx> {\n-    vec: Vec<Candidate<'tcx>>,\n-    ambiguous: bool\n+struct SelectionCandidateSet<'tcx> {\n+    // a list of candidates that definitely apply to the current\n+    // obligation (meaning: types unify).\n+    vec: Vec<SelectionCandidate<'tcx>>,\n+\n+    // if this is true, then there were candidates that might or might\n+    // not have applied, but we couldn't tell. This occurs when some\n+    // of the input types are type variables, in which case there are\n+    // various \"builtin\" rules that might or might not trigger.\n+    ambiguous: bool,\n }\n \n enum BuiltinBoundConditions<'tcx> {\n@@ -193,6 +205,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx\n     }\n \n+    pub fn param_env(&self) -> &'cx ty::ParameterEnvironment<'tcx> {\n+        self.param_env\n+    }\n+\n     pub fn tcx(&self) -> &'cx ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -218,7 +234,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn select(&mut self, obligation: &TraitObligation<'tcx>)\n                   -> SelectionResult<'tcx, Selection<'tcx>> {\n         debug!(\"select({})\", obligation.repr(self.tcx()));\n-        assert!(!obligation.trait_ref.has_escaping_regions());\n+        assert!(!obligation.predicate.has_escaping_regions());\n \n         let stack = self.push_stack(None, obligation);\n         match try!(self.candidate_from_obligation(&stack)) {\n@@ -280,7 +296,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"evaluate_predicate_recursively({})\",\n                obligation.repr(self.tcx()));\n \n-        match obligation.trait_ref {\n+        match obligation.predicate {\n             ty::Predicate::Trait(ref t) => {\n                 assert!(!t.has_escaping_regions());\n                 let obligation = obligation.with(t.clone());\n@@ -302,6 +318,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // evaluating trait matches\n                 EvaluatedToOk\n             }\n+\n+            ty::Predicate::Projection(..) => {\n+                // FIXME(#20296) -- we should be able to give a more precise answer here\n+                EvaluatedToAmbig\n+            }\n         }\n     }\n \n@@ -411,9 +432,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         self.infcx.probe(|snapshot| {\n             let (skol_obligation_trait_ref, skol_map) =\n-                self.infcx().skolemize_late_bound_regions(&*obligation.trait_ref, snapshot);\n+                self.infcx().skolemize_late_bound_regions(&obligation.predicate, snapshot);\n             match self.match_impl(impl_def_id, obligation, snapshot,\n-                                  &skol_map, Rc::new(skol_obligation_trait_ref)) {\n+                                  &skol_map, skol_obligation_trait_ref.trait_ref.clone()) {\n                 Ok(substs) => {\n                     let vtable_impl = self.vtable_impl(impl_def_id,\n                                                        substs,\n@@ -439,7 +460,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn candidate_from_obligation<'o>(&mut self,\n                                      stack: &TraitObligationStack<'o, 'tcx>)\n-                                     -> SelectionResult<'tcx, Candidate<'tcx>>\n+                                     -> SelectionResult<'tcx, SelectionCandidate<'tcx>>\n     {\n         // Watch out for overflow. This intentionally bypasses (and does\n         // not update) the cache.\n@@ -455,17 +476,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // separately rather than using `stack.fresh_trait_ref` -- this\n         // is because we want the unbound variables to be replaced\n         // with fresh skolemized types starting from index 0.\n-        let cache_fresh_trait_ref =\n-            self.infcx.freshen(stack.obligation.trait_ref.clone());\n-        debug!(\"candidate_from_obligation(cache_fresh_trait_ref={}, obligation={})\",\n-               cache_fresh_trait_ref.repr(self.tcx()),\n+        let cache_fresh_trait_pred =\n+            self.infcx.freshen(stack.obligation.predicate.clone());\n+        debug!(\"candidate_from_obligation(cache_fresh_trait_pred={}, obligation={})\",\n+               cache_fresh_trait_pred.repr(self.tcx()),\n                stack.repr(self.tcx()));\n-        assert!(!stack.obligation.trait_ref.has_escaping_regions());\n+        assert!(!stack.obligation.predicate.has_escaping_regions());\n \n-        match self.check_candidate_cache(cache_fresh_trait_ref.clone()) {\n+        match self.check_candidate_cache(&cache_fresh_trait_pred) {\n             Some(c) => {\n-                debug!(\"CACHE HIT: cache_fresh_trait_ref={}, candidate={}\",\n-                       cache_fresh_trait_ref.repr(self.tcx()),\n+                debug!(\"CACHE HIT: cache_fresh_trait_pred={}, candidate={}\",\n+                       cache_fresh_trait_pred.repr(self.tcx()),\n                        c.repr(self.tcx()));\n                 return c;\n             }\n@@ -474,17 +495,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // If no match, compute result and insert into cache.\n         let candidate = self.candidate_from_obligation_no_cache(stack);\n-        debug!(\"CACHE MISS: cache_fresh_trait_ref={}, candidate={}\",\n-               cache_fresh_trait_ref.repr(self.tcx()), candidate.repr(self.tcx()));\n-        self.insert_candidate_cache(cache_fresh_trait_ref, candidate.clone());\n+        debug!(\"CACHE MISS: cache_fresh_trait_pred={}, candidate={}\",\n+               cache_fresh_trait_pred.repr(self.tcx()), candidate.repr(self.tcx()));\n+        self.insert_candidate_cache(cache_fresh_trait_pred, candidate.clone());\n         candidate\n     }\n \n     fn candidate_from_obligation_no_cache<'o>(&mut self,\n                                               stack: &TraitObligationStack<'o, 'tcx>)\n-                                              -> SelectionResult<'tcx, Candidate<'tcx>>\n+                                              -> SelectionResult<'tcx, SelectionCandidate<'tcx>>\n     {\n-        if ty::type_is_error(stack.obligation.self_ty()) {\n+        if ty::type_is_error(stack.obligation.predicate.0.self_ty()) {\n             return Ok(Some(ErrorCandidate));\n         }\n \n@@ -497,8 +518,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let mut candidates = candidate_set.vec;\n \n-        debug!(\"assembled {} candidates for {}\",\n-               candidates.len(), stack.repr(self.tcx()));\n+        debug!(\"assembled {} candidates for {}: {}\",\n+               candidates.len(),\n+               stack.repr(self.tcx()),\n+               candidates.repr(self.tcx()));\n \n         // At this point, we know that each of the entries in the\n         // candidate set is *individually* applicable. Now we have to\n@@ -576,7 +599,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn pick_candidate_cache(&self,\n-                            cache_fresh_trait_ref: &Rc<ty::PolyTraitRef<'tcx>>)\n+                            cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>)\n                             -> &SelectionCache<'tcx>\n     {\n         // High-level idea: we have to decide whether to consult the\n@@ -598,7 +621,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // If the trait refers to any parameters in scope, then use\n         // the cache of the param-environment.\n         if\n-            cache_fresh_trait_ref.0.input_types().iter().any(\n+            cache_fresh_trait_pred.0.input_types().iter().any(\n                 |&t| ty::type_has_self(t) || ty::type_has_params(t))\n         {\n             return &self.param_env.selection_cache;\n@@ -611,7 +634,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // See the discussion in doc.rs for more details.\n         if\n             !self.param_env.caller_bounds.is_empty() &&\n-            cache_fresh_trait_ref.0.input_types().iter().any(\n+            cache_fresh_trait_pred.0.input_types().iter().any(\n                 |&t| ty::type_has_ty_infer(t))\n         {\n             return &self.param_env.selection_cache;\n@@ -622,43 +645,43 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn check_candidate_cache(&mut self,\n-                             cache_fresh_trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n-                             -> Option<SelectionResult<'tcx, Candidate<'tcx>>>\n+                             cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>)\n+                             -> Option<SelectionResult<'tcx, SelectionCandidate<'tcx>>>\n     {\n-        let cache = self.pick_candidate_cache(&cache_fresh_trait_ref);\n+        let cache = self.pick_candidate_cache(cache_fresh_trait_pred);\n         let hashmap = cache.hashmap.borrow();\n-        hashmap.get(&cache_fresh_trait_ref).map(|c| (*c).clone())\n+        hashmap.get(&cache_fresh_trait_pred.0.trait_ref).map(|c| (*c).clone())\n     }\n \n     fn insert_candidate_cache(&mut self,\n-                              cache_fresh_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n-                              candidate: SelectionResult<'tcx, Candidate<'tcx>>)\n+                              cache_fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n+                              candidate: SelectionResult<'tcx, SelectionCandidate<'tcx>>)\n     {\n-        let cache = self.pick_candidate_cache(&cache_fresh_trait_ref);\n+        let cache = self.pick_candidate_cache(&cache_fresh_trait_pred);\n         let mut hashmap = cache.hashmap.borrow_mut();\n-        hashmap.insert(cache_fresh_trait_ref, candidate);\n+        hashmap.insert(cache_fresh_trait_pred.0.trait_ref.clone(), candidate);\n     }\n \n     fn assemble_candidates<'o>(&mut self,\n                                stack: &TraitObligationStack<'o, 'tcx>)\n-                               -> Result<CandidateSet<'tcx>, SelectionError<'tcx>>\n+                               -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>>\n     {\n         // Check for overflow.\n \n         let TraitObligationStack { obligation, .. } = *stack;\n \n-        let mut candidates = CandidateSet {\n+        let mut candidates = SelectionCandidateSet {\n             vec: Vec::new(),\n             ambiguous: false\n         };\n \n         // Other bounds. Consider both in-scope bounds from fn decl\n         // and applicable impls. There is a certain set of precedence rules here.\n \n-        match self.tcx().lang_items.to_builtin_kind(obligation.trait_ref.def_id()) {\n+        match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n             Some(ty::BoundCopy) => {\n                 debug!(\"obligation self ty is {}\",\n-                       obligation.self_ty().repr(self.tcx()));\n+                       obligation.predicate.0.self_ty().repr(self.tcx()));\n \n                 // If the user has asked for the older, compatibility\n                 // behavior, ignore user-defined impls here. This will\n@@ -696,26 +719,155 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         }\n \n+        self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n         try!(self.assemble_candidates_from_caller_bounds(obligation, &mut candidates));\n         debug!(\"candidate list size: {}\", candidates.vec.len());\n         Ok(candidates)\n     }\n \n+    fn assemble_candidates_from_projected_tys(&mut self,\n+                                              obligation: &TraitObligation<'tcx>,\n+                                              candidates: &mut SelectionCandidateSet<'tcx>)\n+    {\n+        let poly_trait_predicate =\n+            self.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n+\n+        debug!(\"assemble_candidates_for_projected_tys({},{})\",\n+               obligation.repr(self.tcx()),\n+               poly_trait_predicate.repr(self.tcx()));\n+\n+        // FIXME(#20297) -- just examining the self-type is very simplistic\n+\n+        // before we go into the whole skolemization thing, just\n+        // quickly check if the self-type is a projection at all.\n+        let trait_def_id = match poly_trait_predicate.0.trait_ref.self_ty().sty {\n+            ty::ty_projection(ref data) => data.trait_ref.def_id,\n+            ty::ty_infer(ty::TyVar(_)) => {\n+                // If the self-type is an inference variable, then it MAY wind up\n+                // being a projected type, so induce an ambiguity.\n+                //\n+                // FIXME(#20297) -- being strict about this can cause\n+                // inference failures with BorrowFrom, which is\n+                // unfortunate. Can we do better here?\n+                candidates.ambiguous = true;\n+                return;\n+            }\n+            _ => { return; }\n+        };\n+\n+        debug!(\"assemble_candidates_for_projected_tys: trait_def_id={}\",\n+               trait_def_id.repr(self.tcx()));\n+\n+        let result = self.infcx.probe(|snapshot| {\n+            self.match_projection_obligation_against_bounds_from_trait(obligation,\n+                                                                       snapshot)\n+        });\n+\n+        if result {\n+            candidates.vec.push(ProjectionCandidate);\n+        }\n+    }\n+\n+    fn match_projection_obligation_against_bounds_from_trait(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        snapshot: &infer::CombinedSnapshot)\n+        -> bool\n+    {\n+        let poly_trait_predicate =\n+            self.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n+        let (skol_trait_predicate, skol_map) =\n+            self.infcx().skolemize_late_bound_regions(&poly_trait_predicate, snapshot);\n+        debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n+                skol_trait_predicate={} skol_map={}\",\n+               skol_trait_predicate.repr(self.tcx()),\n+               skol_map.repr(self.tcx()));\n+\n+        let projection_trait_ref = match skol_trait_predicate.trait_ref.self_ty().sty {\n+            ty::ty_projection(ref data) => &data.trait_ref,\n+            _ => {\n+                self.tcx().sess.span_bug(\n+                    obligation.cause.span,\n+                    format!(\"match_projection_obligation_against_bounds_from_trait() called \\\n+                             but self-ty not a projection: {}\",\n+                            skol_trait_predicate.trait_ref.self_ty().repr(self.tcx())).as_slice());\n+            }\n+        };\n+        debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n+                projection_trait_ref={}\",\n+               projection_trait_ref.repr(self.tcx()));\n+\n+        let trait_def = ty::lookup_trait_def(self.tcx(), projection_trait_ref.def_id);\n+        let bounds = trait_def.generics.to_bounds(self.tcx(), projection_trait_ref.substs);\n+        debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n+                bounds={}\",\n+               bounds.repr(self.tcx()));\n+\n+        let matching_bound =\n+            util::elaborate_predicates(self.tcx(), bounds.predicates.to_vec())\n+            .filter_to_traits()\n+            .find(\n+                |bound| self.infcx.probe(\n+                    |_| self.match_projection(obligation,\n+                                              bound.clone(),\n+                                              skol_trait_predicate.trait_ref.clone(),\n+                                              &skol_map,\n+                                              snapshot)));\n+\n+        debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n+                matching_bound={}\",\n+               matching_bound.repr(self.tcx()));\n+        match matching_bound {\n+            None => false,\n+            Some(bound) => {\n+                // Repeat the successful match, if any, this time outside of a probe.\n+                let result = self.match_projection(obligation,\n+                                                   bound,\n+                                                   skol_trait_predicate.trait_ref.clone(),\n+                                                   &skol_map,\n+                                                   snapshot);\n+                assert!(result);\n+                true\n+            }\n+        }\n+    }\n+\n+    fn match_projection(&mut self,\n+                        obligation: &TraitObligation<'tcx>,\n+                        trait_bound: ty::PolyTraitRef<'tcx>,\n+                        skol_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                        skol_map: &infer::SkolemizationMap,\n+                        snapshot: &infer::CombinedSnapshot)\n+                        -> bool\n+    {\n+        assert!(!skol_trait_ref.has_escaping_regions());\n+        let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+        match self.infcx.sub_poly_trait_refs(false,\n+                                             origin,\n+                                             trait_bound.clone(),\n+                                             ty::Binder(skol_trait_ref.clone())) {\n+            Ok(()) => { }\n+            Err(_) => { return false; }\n+        }\n+\n+        self.infcx.leak_check(skol_map, snapshot).is_ok()\n+    }\n+\n     /// Given an obligation like `<SomeTrait for T>`, search the obligations that the caller\n     /// supplied to find out whether it is listed among them.\n     ///\n     /// Never affects inference environment.\n     fn assemble_candidates_from_caller_bounds(&mut self,\n                                               obligation: &TraitObligation<'tcx>,\n-                                              candidates: &mut CandidateSet<'tcx>)\n+                                              candidates: &mut SelectionCandidateSet<'tcx>)\n                                               -> Result<(),SelectionError<'tcx>>\n     {\n         debug!(\"assemble_candidates_from_caller_bounds({})\",\n                obligation.repr(self.tcx()));\n \n         let caller_trait_refs: Vec<_> =\n             self.param_env.caller_bounds.predicates.iter()\n-            .filter_map(|o| o.to_trait())\n+            .filter_map(|o| o.to_opt_poly_trait_ref())\n             .collect();\n \n         let all_bounds =\n@@ -728,8 +880,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     |_| self.match_where_clause(obligation, bound.clone())).is_ok());\n \n         let param_candidates =\n-            matching_bounds.map(\n-                |bound| ParamCandidate(VtableParamData { bound: bound }));\n+            matching_bounds.map(|bound| ParamCandidate(bound));\n \n         candidates.vec.extend(param_candidates);\n \n@@ -744,10 +895,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// unified during the confirmation step.\n     fn assemble_unboxed_closure_candidates(&mut self,\n                                            obligation: &TraitObligation<'tcx>,\n-                                           candidates: &mut CandidateSet<'tcx>)\n+                                           candidates: &mut SelectionCandidateSet<'tcx>)\n                                            -> Result<(),SelectionError<'tcx>>\n     {\n-        let kind = match self.fn_family_trait_kind(obligation.trait_ref.def_id()) {\n+        let kind = match self.fn_family_trait_kind(obligation.predicate.0.def_id()) {\n             Some(k) => k,\n             None => { return Ok(()); }\n         };\n@@ -789,13 +940,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Implement one of the `Fn()` family for a fn pointer.\n     fn assemble_fn_pointer_candidates(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n-                                      candidates: &mut CandidateSet<'tcx>)\n+                                      candidates: &mut SelectionCandidateSet<'tcx>)\n                                       -> Result<(),SelectionError<'tcx>>\n     {\n         // We provide a `Fn` impl for fn pointers. There is no need to provide\n         // the other traits (e.g. `FnMut`) since those are provided by blanket\n         // impls.\n-        if Some(obligation.trait_ref.def_id()) != self.tcx().lang_items.fn_trait() {\n+        if Some(obligation.predicate.def_id()) != self.tcx().lang_items.fn_trait() {\n             return Ok(());\n         }\n \n@@ -827,16 +978,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Search for impls that might apply to `obligation`.\n     fn assemble_candidates_from_impls(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n-                                      candidate_vec: &mut Vec<Candidate<'tcx>>)\n+                                      candidate_vec: &mut Vec<SelectionCandidate<'tcx>>)\n                                       -> Result<(), SelectionError<'tcx>>\n     {\n-        let all_impls = self.all_impls(obligation.trait_ref.def_id());\n+        let all_impls = self.all_impls(obligation.predicate.def_id());\n         for &impl_def_id in all_impls.iter() {\n             self.infcx.probe(|snapshot| {\n-                let (skol_obligation_trait_ref, skol_map) =\n-                    self.infcx().skolemize_late_bound_regions(&*obligation.trait_ref, snapshot);\n+                let (skol_obligation_trait_pred, skol_map) =\n+                    self.infcx().skolemize_late_bound_regions(&obligation.predicate, snapshot);\n                 match self.match_impl(impl_def_id, obligation, snapshot,\n-                                      &skol_map, Rc::new(skol_obligation_trait_ref)) {\n+                                      &skol_map, skol_obligation_trait_pred.trait_ref.clone()) {\n                     Ok(_) => {\n                         candidate_vec.push(ImplCandidate(impl_def_id));\n                     }\n@@ -861,7 +1012,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// scrutiny.\n     fn winnow_candidate<'o>(&mut self,\n                             stack: &TraitObligationStack<'o, 'tcx>,\n-                            candidate: &Candidate<'tcx>)\n+                            candidate: &SelectionCandidate<'tcx>)\n                             -> EvaluationResult<'tcx>\n     {\n         debug!(\"winnow_candidate: candidate={}\", candidate.repr(self.tcx()));\n@@ -918,36 +1069,49 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// a case where doing the opposite caused us harm.\n     fn candidate_should_be_dropped_in_favor_of<'o>(&mut self,\n                                                    stack: &TraitObligationStack<'o, 'tcx>,\n-                                                   candidate_i: &Candidate<'tcx>,\n-                                                   candidate_j: &Candidate<'tcx>)\n+                                                   candidate_i: &SelectionCandidate<'tcx>,\n+                                                   candidate_j: &SelectionCandidate<'tcx>)\n                                                    -> bool\n     {\n         match (candidate_i, candidate_j) {\n-            (&ImplCandidate(impl_def_id), &ParamCandidate(ref vt)) => {\n+            (&ImplCandidate(impl_def_id), &ParamCandidate(ref bound)) => {\n                 debug!(\"Considering whether to drop param {} in favor of impl {}\",\n                        candidate_i.repr(self.tcx()),\n                        candidate_j.repr(self.tcx()));\n \n                 self.infcx.probe(|snapshot| {\n                     let (skol_obligation_trait_ref, skol_map) =\n                         self.infcx().skolemize_late_bound_regions(\n-                            &*stack.obligation.trait_ref, snapshot);\n+                            &stack.obligation.predicate, snapshot);\n                     let impl_substs =\n                         self.rematch_impl(impl_def_id, stack.obligation, snapshot,\n-                                          &skol_map, Rc::new(skol_obligation_trait_ref));\n+                                          &skol_map, skol_obligation_trait_ref.trait_ref.clone());\n                     let impl_trait_ref =\n                         ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap();\n                     let impl_trait_ref =\n                         impl_trait_ref.subst(self.tcx(), &impl_substs);\n                     let poly_impl_trait_ref =\n-                        Rc::new(ty::Binder((*impl_trait_ref).clone()));\n+                        ty::Binder(impl_trait_ref);\n                     let origin =\n                         infer::RelateOutputImplTypes(stack.obligation.cause.span);\n                     self.infcx\n-                        .sub_poly_trait_refs(false, origin, poly_impl_trait_ref, vt.bound.clone())\n+                        .sub_poly_trait_refs(false, origin, poly_impl_trait_ref, bound.clone())\n                         .is_ok()\n                 })\n             }\n+            (&ProjectionCandidate, &ParamCandidate(_)) => {\n+                // FIXME(#20297) -- this gives where clauses precedent\n+                // over projections. Really these are just two means\n+                // of deducing information (one based on the where\n+                // clauses on the trait definition; one based on those\n+                // on the enclosing scope), and it'd be better to\n+                // integrate them more intelligently. But for now this\n+                // seems ok. If we DON'T give where clauses\n+                // precedence, we run into trouble in default methods,\n+                // where both the projection bounds for `Self::A` and\n+                // the where clauses are in scope.\n+                true\n+            }\n             _ => {\n                 *candidate_i == *candidate_j\n             }\n@@ -966,7 +1130,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn assemble_builtin_bound_candidates<'o>(&mut self,\n                                              bound: ty::BuiltinBound,\n                                              stack: &TraitObligationStack<'o, 'tcx>,\n-                                             candidates: &mut CandidateSet<'tcx>)\n+                                             candidates: &mut SelectionCandidateSet<'tcx>)\n                                              -> Result<(),SelectionError<'tcx>>\n     {\n         match self.builtin_bound(bound, stack.obligation) {\n@@ -987,7 +1151,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                      obligation: &TraitObligation<'tcx>)\n                      -> Result<BuiltinBoundConditions<'tcx>,SelectionError<'tcx>>\n     {\n-        let self_ty = self.infcx.shallow_resolve(obligation.trait_ref.self_ty());\n+        // Note: these tests operate on types that may contain bound\n+        // regions. To be proper, we ought to skolemize here, but we\n+        // forego the skolemization and defer it until the\n+        // confirmation step.\n+\n+        let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n         return match self_ty.sty {\n             ty::ty_infer(ty::IntVar(_)) |\n             ty::ty_infer(ty::FloatVar(_)) |\n@@ -1100,11 +1269,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         } else {\n                             // Recursively check all supertraits to find out if any further\n                             // bounds are required and thus we must fulfill.\n-                            let tmp_tr = data.principal_trait_ref_with_self_ty(self.tcx(),\n-                                                                               ty::mk_err());\n-                            for tr in util::supertraits(self.tcx(), tmp_tr) {\n+                            let principal =\n+                                data.principal_trait_ref_with_self_ty(self.tcx(),\n+                                                                      self.tcx().types.err);\n+                            for tr in util::supertraits(self.tcx(), principal) {\n                                 let td = ty::lookup_trait_def(self.tcx(), tr.def_id());\n-\n                                 if td.bounds.builtin_bounds.contains(&bound) {\n                                     return Ok(If(Vec::new()))\n                                 }\n@@ -1268,6 +1437,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 nominal(self, bound, def_id, types)\n             }\n \n+            ty::ty_projection(_) |\n             ty::ty_param(_) => {\n                 // Note: A type parameter is only considered to meet a\n                 // particular bound if there is a where clause telling\n@@ -1359,7 +1529,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn confirm_candidate(&mut self,\n                          obligation: &TraitObligation<'tcx>,\n-                         candidate: Candidate<'tcx>)\n+                         candidate: SelectionCandidate<'tcx>)\n                          -> Result<Selection<'tcx>,SelectionError<'tcx>>\n     {\n         debug!(\"confirm_candidate({}, {})\",\n@@ -1377,8 +1547,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ParamCandidate(param) => {\n-                Ok(VtableParam(\n-                    try!(self.confirm_param_candidate(obligation, param))))\n+                self.confirm_param_candidate(obligation, param);\n+                Ok(VtableParam)\n             }\n \n             ImplCandidate(impl_def_id) => {\n@@ -1397,14 +1567,30 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     try!(self.confirm_fn_pointer_candidate(obligation));\n                 Ok(VtableFnPointer(fn_type))\n             }\n+\n+            ProjectionCandidate => {\n+                self.confirm_projection_candidate(obligation);\n+                Ok(VtableParam)\n+            }\n         }\n     }\n \n+    fn confirm_projection_candidate(&mut self,\n+                                    obligation: &TraitObligation<'tcx>)\n+    {\n+        let _: Result<(),()> =\n+            self.infcx.try(|snapshot| {\n+                let result =\n+                    self.match_projection_obligation_against_bounds_from_trait(obligation,\n+                                                                               snapshot);\n+                assert!(result);\n+                Ok(())\n+            });\n+    }\n+\n     fn confirm_param_candidate(&mut self,\n                                obligation: &TraitObligation<'tcx>,\n-                               param: VtableParamData<'tcx>)\n-                               -> Result<VtableParamData<'tcx>,\n-                                         SelectionError<'tcx>>\n+                               param: ty::PolyTraitRef<'tcx>)\n     {\n         debug!(\"confirm_param_candidate({},{})\",\n                obligation.repr(self.tcx()),\n@@ -1415,13 +1601,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // trait-ref. Repeat that unification now without any\n         // transactional boundary; it should not fail.\n         match self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                           obligation.trait_ref.clone(),\n-                                           param.bound.clone()) {\n-            Ok(()) => Ok(param),\n+                                           obligation.predicate.to_poly_trait_ref(),\n+                                           param.clone()) {\n+            Ok(()) => { }\n             Err(_) => {\n                 self.tcx().sess.bug(\n                     format!(\"Where clause `{}` was applicable to `{}` but now is not\",\n-                            param.bound.repr(self.tcx()),\n+                            param.repr(self.tcx()),\n                             obligation.repr(self.tcx())).as_slice());\n             }\n         }\n@@ -1454,13 +1640,31 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                            -> VtableBuiltinData<PredicateObligation<'tcx>>\n     {\n         let derived_cause = self.derived_cause(obligation, BuiltinDerivedObligation);\n-        let obligations = nested.iter().map(|&t| {\n-            util::predicate_for_builtin_bound(\n-                self.tcx(),\n-                derived_cause.clone(),\n-                bound,\n-                obligation.recursion_depth + 1,\n-                t)\n+        let obligations = nested.iter().map(|&bound_ty| {\n+            // the obligation might be higher-ranked, e.g. for<'a> &'a\n+            // int : Copy. In that case, we will wind up with\n+            // late-bound regions in the `nested` vector. So for each\n+            // one we instantiate to a skolemized region, do our work\n+            // to produce something like `&'0 int : Copy`, and then\n+            // re-bind it. This is a bit of busy-work but preserves\n+            // the invariant that we only manipulate free regions, not\n+            // bound ones.\n+            self.infcx.try(|snapshot| {\n+                let (skol_ty, skol_map) =\n+                    self.infcx().skolemize_late_bound_regions(&ty::Binder(bound_ty), snapshot);\n+                let skol_predicate =\n+                    util::predicate_for_builtin_bound(\n+                        self.tcx(),\n+                        derived_cause.clone(),\n+                        bound,\n+                        obligation.recursion_depth + 1,\n+                        skol_ty);\n+                match skol_predicate {\n+                    Ok(skol_predicate) => Ok(self.infcx().plug_leaks(skol_map, snapshot,\n+                                                                     &skol_predicate)),\n+                    Err(ErrorReported) => Err(ErrorReported)\n+                }\n+            })\n         }).collect::<Result<_, _>>();\n         let mut obligations = match obligations {\n             Ok(o) => o,\n@@ -1472,13 +1676,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligations.push(Obligation {\n                 cause: obligation.cause.clone(),\n                 recursion_depth: obligation.recursion_depth+1,\n-                trait_ref: ty::Binder(ty::OutlivesPredicate(obligation.self_ty(),\n+                predicate: ty::Binder(ty::OutlivesPredicate(obligation.self_ty(),\n                                                             ty::ReStatic)).as_predicate(),\n             });\n         }\n \n-        let obligations = VecPerParamSpace::new(obligations, Vec::new(),\n-                                                Vec::new(), Vec::new());\n+        let obligations = VecPerParamSpace::new(obligations, Vec::new(), Vec::new());\n \n         debug!(\"vtable_builtin_data: obligations={}\",\n                obligations.repr(self.tcx()));\n@@ -1500,9 +1703,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // this time not in a probe.\n         self.infcx.try(|snapshot| {\n             let (skol_obligation_trait_ref, skol_map) =\n-                self.infcx().skolemize_late_bound_regions(&*obligation.trait_ref, snapshot);\n-            let substs = self.rematch_impl(impl_def_id, obligation,\n-                                           snapshot, &skol_map, Rc::new(skol_obligation_trait_ref));\n+                self.infcx().skolemize_late_bound_regions(&obligation.predicate, snapshot);\n+            let substs =\n+                self.rematch_impl(impl_def_id, obligation,\n+                                  snapshot, &skol_map, skol_obligation_trait_ref.trait_ref);\n             debug!(\"confirm_impl_candidate substs={}\", substs);\n             Ok(self.vtable_impl(impl_def_id, substs, obligation.cause.clone(),\n                                 obligation.recursion_depth + 1, skol_map, snapshot))\n@@ -1571,15 +1775,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Substs::new_trait(\n                 vec![arguments_tuple, output_type],\n                 vec![],\n-                vec![],\n                 self_ty);\n-        let trait_ref = Rc::new(ty::Binder(ty::TraitRef {\n-            def_id: obligation.trait_ref.def_id(),\n+        let trait_ref = ty::Binder(Rc::new(ty::TraitRef {\n+            def_id: obligation.predicate.def_id(),\n             substs: self.tcx().mk_substs(substs),\n         }));\n \n         try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                          obligation.trait_ref.clone(),\n+                                          obligation.predicate.to_poly_trait_ref(),\n                                           trait_ref));\n         Ok(self_ty)\n     }\n@@ -1612,10 +1815,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 vec![arguments_tuple.subst(self.tcx(), substs),\n                      closure_sig.0.output.unwrap().subst(self.tcx(), substs)],\n                 vec![],\n-                vec![],\n                 obligation.self_ty());\n-        let trait_ref = Rc::new(ty::Binder(ty::TraitRef {\n-            def_id: obligation.trait_ref.def_id(),\n+        let trait_ref = ty::Binder(Rc::new(ty::TraitRef {\n+            def_id: obligation.predicate.def_id(),\n             substs: self.tcx().mk_substs(substs),\n         }));\n \n@@ -1624,7 +1826,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                trait_ref.repr(self.tcx()));\n \n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                     obligation.trait_ref.clone(),\n+                                     obligation.predicate.to_poly_trait_ref(),\n                                      trait_ref)\n     }\n \n@@ -1655,8 +1857,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// report an error to the user.\n     fn confirm_poly_trait_refs(&mut self,\n                                obligation_cause: ObligationCause,\n-                               obligation_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n-                               expected_trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n+                               obligation_trait_ref: ty::PolyTraitRef<'tcx>,\n+                               expected_trait_ref: ty::PolyTraitRef<'tcx>)\n                                -> Result<(), SelectionError<'tcx>>\n     {\n         let origin = infer::RelateOutputImplTypes(obligation_cause.span);\n@@ -1769,7 +1971,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // substitution if we find that any of the input types, when\n         // simplified, do not match.\n \n-        obligation.trait_ref.input_types().iter()\n+        obligation.predicate.0.input_types().iter()\n             .zip(impl_trait_ref.input_types().iter())\n             .any(|(&obligation_ty, &impl_ty)| {\n                 let simplified_obligation_ty =\n@@ -1785,7 +1987,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn match_where_clause(&mut self,\n                           obligation: &TraitObligation<'tcx>,\n-                          where_clause_trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n+                          where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n                         -> Result<(),()>\n     {\n         debug!(\"match_where_clause: obligation={} where_clause_trait_ref={}\",\n@@ -1796,7 +1998,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.infcx.sub_poly_trait_refs(false,\n                                              origin,\n                                              where_clause_trait_ref,\n-                                             obligation.trait_ref.clone()) {\n+                                             obligation.predicate.to_poly_trait_ref()) {\n             Ok(()) => Ok(()),\n             Err(_) => Err(()),\n         }\n@@ -1878,7 +2080,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             obligation: &'o TraitObligation<'tcx>)\n                             -> TraitObligationStack<'o, 'tcx>\n     {\n-        let fresh_trait_ref = obligation.trait_ref.fold_with(&mut self.freshener);\n+        let fresh_trait_ref =\n+            obligation.predicate.to_poly_trait_ref().fold_with(&mut self.freshener);\n \n         TraitObligationStack {\n             obligation: obligation,\n@@ -1931,9 +2134,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     #[allow(unused_comparisons)]\n     fn derived_cause(&self,\n                      obligation: &TraitObligation<'tcx>,\n-                     variant: fn(Rc<ty::Binder<ty::TraitRef<'tcx>>>,\n-                                 Rc<ObligationCauseCode<'tcx>>)\n-                                 -> ObligationCauseCode<'tcx>)\n+                     variant: fn(DerivedObligationCause<'tcx>) -> ObligationCauseCode<'tcx>)\n                      -> ObligationCause<'tcx>\n     {\n         /*!\n@@ -1950,29 +2151,31 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // chain. Ideally, we should have a way to configure this either\n         // by using -Z verbose or just a CLI argument.\n         if obligation.recursion_depth >= 0 {\n+            let derived_cause = DerivedObligationCause {\n+                parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n+                parent_code: Rc::new(obligation.cause.code.clone()),\n+            };\n             ObligationCause::new(obligation.cause.span,\n-                                 obligation.trait_ref.def_id().node,\n-                                 variant(obligation.trait_ref.clone(),\n-                                         Rc::new(obligation.cause.code.clone())))\n+                                 obligation.cause.body_id,\n+                                 variant(derived_cause))\n         } else {\n             obligation.cause.clone()\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for Candidate<'tcx> {\n+impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n             BuiltinCandidate(b) => format!(\"BuiltinCandidate({})\", b),\n+            ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),\n+            ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n+            ProjectionCandidate => format!(\"ProjectionCandidate\"),\n+            FnPointerCandidate => format!(\"FnPointerCandidate\"),\n             UnboxedClosureCandidate(c, ref s) => {\n                 format!(\"UnboxedClosureCandidate({},{})\", c, s.repr(tcx))\n             }\n-            FnPointerCandidate => {\n-                format!(\"FnPointerCandidate\")\n-            }\n-            ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),\n-            ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n         }\n     }\n }"}, {"sha": "109810fc7eec3efacb5bea0a141b1087fafe8544", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 54, "deletions": 81, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::subst::{Subst, Substs, VecPerParamSpace};\n+use middle::subst::{Substs, VecPerParamSpace};\n use middle::infer::InferCtxt;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, Ty, AsPredicate, ToPolyTraitRef};\n use std::collections::HashSet;\n use std::fmt;\n use std::rc::Rc;\n@@ -20,7 +20,7 @@ use util::common::ErrorReported;\n use util::ppaux::Repr;\n \n use super::{Obligation, ObligationCause, PredicateObligation,\n-            VtableImpl, VtableParam, VtableParamData, VtableImplData};\n+            VtableImpl, VtableParam, VtableImplData};\n \n ///////////////////////////////////////////////////////////////////////////\n // `Elaboration` iterator\n@@ -46,19 +46,19 @@ struct StackEntry<'tcx> {\n \n pub fn elaborate_trait_ref<'cx, 'tcx>(\n     tcx: &'cx ty::ctxt<'tcx>,\n-    trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n+    trait_ref: ty::PolyTraitRef<'tcx>)\n     -> Elaborator<'cx, 'tcx>\n {\n-    elaborate_predicates(tcx, vec![ty::Predicate::Trait(trait_ref)])\n+    elaborate_predicates(tcx, vec![trait_ref.as_predicate()])\n }\n \n pub fn elaborate_trait_refs<'cx, 'tcx>(\n     tcx: &'cx ty::ctxt<'tcx>,\n-    trait_refs: &[Rc<ty::PolyTraitRef<'tcx>>])\n+    trait_refs: &[ty::PolyTraitRef<'tcx>])\n     -> Elaborator<'cx, 'tcx>\n {\n     let predicates = trait_refs.iter()\n-                               .map(|trait_ref| ty::Predicate::Trait((*trait_ref).clone()))\n+                               .map(|trait_ref| trait_ref.as_predicate())\n                                .collect();\n     elaborate_predicates(tcx, predicates)\n }\n@@ -78,23 +78,34 @@ pub fn elaborate_predicates<'cx, 'tcx>(\n }\n \n impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n+    pub fn filter_to_traits(self) -> Supertraits<'cx, 'tcx> {\n+        Supertraits { elaborator: self }\n+    }\n+\n     fn push(&mut self, predicate: &ty::Predicate<'tcx>) {\n         match *predicate {\n-            ty::Predicate::Trait(ref trait_ref) => {\n+            ty::Predicate::Trait(ref data) => {\n                 let mut predicates =\n-                    ty::predicates_for_trait_ref(self.tcx, &**trait_ref);\n+                    ty::predicates_for_trait_ref(self.tcx,\n+                                                 &data.to_poly_trait_ref());\n \n                 // Only keep those bounds that we haven't already\n                 // seen.  This is necessary to prevent infinite\n                 // recursion in some cases.  One common case is when\n                 // people define `trait Sized { }` rather than `trait\n                 // Sized for Sized? { }`.\n-                predicates.retain(|r| self.visited.insert((*r).clone()));\n+                predicates.retain(|r| self.visited.insert(r.clone()));\n \n                 self.stack.push(StackEntry { position: 0,\n                                              predicates: predicates });\n             }\n             ty::Predicate::Equate(..) => {\n+                // Currently, we do not \"elaborate\" predicates like\n+                // `X == Y`, though conceivably we might. For example,\n+                // `&X == &Y` implies that `X == Y`.\n+            }\n+            ty::Predicate::Projection(..) => {\n+                // Nothing to elaborate in a projection predicate.\n             }\n             ty::Predicate::RegionOutlives(..) |\n             ty::Predicate::TypeOutlives(..) => {\n@@ -173,34 +184,30 @@ pub struct Supertraits<'cx, 'tcx:'cx> {\n }\n \n pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                              trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n+                              trait_ref: ty::PolyTraitRef<'tcx>)\n                               -> Supertraits<'cx, 'tcx>\n {\n-    let elaborator = elaborate_trait_ref(tcx, trait_ref);\n-    Supertraits { elaborator: elaborator }\n+    elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n }\n \n pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                                    bounds: &[Rc<ty::PolyTraitRef<'tcx>>])\n+                                    bounds: &[ty::PolyTraitRef<'tcx>])\n                                     -> Supertraits<'cx, 'tcx>\n {\n-    let elaborator = elaborate_trait_refs(tcx, bounds);\n-    Supertraits { elaborator: elaborator }\n+    elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n-impl<'cx, 'tcx> Iterator<Rc<ty::PolyTraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n-    fn next(&mut self) -> Option<Rc<ty::PolyTraitRef<'tcx>>> {\n+impl<'cx, 'tcx> Iterator<ty::PolyTraitRef<'tcx>> for Supertraits<'cx, 'tcx> {\n+    fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n         loop {\n             match self.elaborator.next() {\n                 None => {\n                     return None;\n                 }\n-                Some(ty::Predicate::Trait(trait_ref)) => {\n-                    return Some(trait_ref);\n+                Some(ty::Predicate::Trait(data)) => {\n+                    return Some(data.to_poly_trait_ref());\n                 }\n-                Some(ty::Predicate::Equate(..)) |\n-                Some(ty::Predicate::RegionOutlives(..)) |\n-                Some(ty::Predicate::TypeOutlives(..)) => {\n+                Some(_) => {\n                 }\n             }\n         }\n@@ -222,18 +229,7 @@ pub fn fresh_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n {\n     let tcx = infcx.tcx;\n     let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n-    let input_substs = infcx.fresh_substs_for_generics(span, &impl_generics);\n-\n-    // Add substs for the associated types bound in the impl.\n-    let ref items = tcx.impl_items.borrow()[impl_def_id];\n-    let mut assoc_tys = Vec::new();\n-    for item in items.iter() {\n-        if let &ty::ImplOrTraitItemId::TypeTraitItemId(id) = item {\n-            assoc_tys.push(tcx.tcache.borrow()[id].ty.subst(tcx, &input_substs));\n-        }\n-    }\n-\n-    input_substs.with_assoc_tys(assoc_tys)\n+    infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n \n impl<'tcx, N> fmt::Show for VtableImplData<'tcx, N> {\n@@ -242,12 +238,6 @@ impl<'tcx, N> fmt::Show for VtableImplData<'tcx, N> {\n     }\n }\n \n-impl<'tcx> fmt::Show for VtableParamData<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableParam(...)\")\n-    }\n-}\n-\n /// See `super::obligations_for_generics`\n pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      cause: ObligationCause<'tcx>,\n@@ -261,22 +251,22 @@ pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n     generic_bounds.predicates.map(|predicate| {\n         Obligation { cause: cause.clone(),\n                      recursion_depth: recursion_depth,\n-                     trait_ref: predicate.clone() }\n+                     predicate: predicate.clone() }\n     })\n }\n \n-pub fn poly_trait_ref_for_builtin_bound<'tcx>(\n+pub fn trait_ref_for_builtin_bound<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n     param_ty: Ty<'tcx>)\n-    -> Result<Rc<ty::PolyTraitRef<'tcx>>, ErrorReported>\n+    -> Result<Rc<ty::TraitRef<'tcx>>, ErrorReported>\n {\n     match tcx.lang_items.from_builtin_kind(builtin_bound) {\n         Ok(def_id) => {\n-            Ok(Rc::new(ty::Binder(ty::TraitRef {\n+            Ok(Rc::new(ty::TraitRef {\n                 def_id: def_id,\n                 substs: tcx.mk_substs(Substs::empty().with_self_ty(param_ty))\n-            })))\n+            }))\n         }\n         Err(e) => {\n             tcx.sess.err(e.as_slice());\n@@ -293,38 +283,18 @@ pub fn predicate_for_builtin_bound<'tcx>(\n     param_ty: Ty<'tcx>)\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n-    let trait_ref = try!(poly_trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty));\n+    let trait_ref = try!(trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty));\n     Ok(Obligation {\n         cause: cause,\n         recursion_depth: recursion_depth,\n-        trait_ref: ty::Predicate::Trait(trait_ref),\n+        predicate: trait_ref.as_predicate(),\n     })\n }\n \n-/// Starting from a caller obligation `caller_bound` (which has coordinates `space`/`i` in the list\n-/// of caller obligations), search through the trait and supertraits to find one where `test(d)` is\n-/// true, where `d` is the def-id of the trait/supertrait. If any is found, return `Some(p)` where\n-/// `p` is the path to that trait/supertrait. Else `None`.\n-pub fn search_trait_and_supertraits_from_bound<'tcx,F>(tcx: &ty::ctxt<'tcx>,\n-                                                       caller_bound: Rc<ty::PolyTraitRef<'tcx>>,\n-                                                       mut test: F)\n-                                                       -> Option<VtableParamData<'tcx>>\n-    where F: FnMut(ast::DefId) -> bool,\n-{\n-    for bound in transitive_bounds(tcx, &[caller_bound]) {\n-        if test(bound.def_id()) {\n-            let vtable_param = VtableParamData { bound: bound };\n-            return Some(vtable_param);\n-        }\n-    }\n-\n-    return None;\n-}\n-\n impl<'tcx,O:Repr<'tcx>> Repr<'tcx> for super::Obligation<'tcx, O> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"Obligation(trait_ref={},depth={})\",\n-                self.trait_ref.repr(tcx),\n+        format!(\"Obligation(predicate={},depth={})\",\n+                self.predicate.repr(tcx),\n                 self.recursion_depth)\n     }\n }\n@@ -344,8 +314,8 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::Vtable<'tcx, N> {\n                 format!(\"VtableFnPointer({})\",\n                         d.repr(tcx)),\n \n-            super::VtableParam(ref v) =>\n-                format!(\"VtableParam({})\", v.repr(tcx)),\n+            super::VtableParam =>\n+                format!(\"VtableParam\"),\n \n             super::VtableBuiltin(ref d) =>\n                 d.repr(tcx)\n@@ -369,13 +339,6 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableBuiltinData<N> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for super::VtableParamData<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"VtableParam(bound={})\",\n-                self.bound.repr(tcx))\n-    }\n-}\n-\n impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n@@ -406,6 +369,7 @@ impl<'tcx> Repr<'tcx> for super::FulfillmentErrorCode<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             super::CodeSelectionError(ref o) => o.repr(tcx),\n+            super::CodeProjectionError(ref o) => o.repr(tcx),\n             super::CodeAmbiguity => format!(\"Ambiguity\")\n         }\n     }\n@@ -415,13 +379,22 @@ impl<'tcx> fmt::Show for super::FulfillmentErrorCode<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             super::CodeSelectionError(ref e) => write!(f, \"{}\", e),\n+            super::CodeProjectionError(ref e) => write!(f, \"{}\", e),\n             super::CodeAmbiguity => write!(f, \"Ambiguity\")\n         }\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::type_err<'tcx> {\n+impl<'tcx> Repr<'tcx> for super::MismatchedProjectionTypes<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        ty::type_err_to_str(tcx, self)\n+        self.err.repr(tcx)\n     }\n }\n+\n+impl<'tcx> fmt::Show for super::MismatchedProjectionTypes<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"MismatchedProjectionTypes(..)\")\n+    }\n+}\n+\n+"}, {"sha": "ab39c761a3861ce644a2598acc31248a20bef5c6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 793, "deletions": 369, "changes": 1162, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -56,16 +56,15 @@ use middle::resolve_lifetime;\n use middle::infer;\n use middle::stability;\n use middle::subst::{mod, Subst, Substs, VecPerParamSpace};\n-use middle::traits::ObligationCause;\n use middle::traits;\n use middle::ty;\n use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n use util::ppaux::{trait_store_to_string, ty_to_string};\n use util::ppaux::{Repr, UserString};\n-use util::common::{indenter, memoized, ErrorReported};\n+use util::common::{memoized, ErrorReported};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FnvHashMap};\n \n use arena::TypedArena;\n use std::borrow::BorrowFrom;\n@@ -80,14 +79,14 @@ use collections::enum_set::{EnumSet, CLike};\n use std::collections::{HashMap, HashSet};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use syntax::abi;\n-use syntax::ast::{CrateNum, DefId, DUMMY_NODE_ID, Ident, ItemTrait, LOCAL_CRATE};\n+use syntax::ast::{CrateNum, DefId, Ident, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n use syntax::ast::{Onceness, StmtExpr, StmtSemi, StructField, UnnamedField};\n use syntax::ast::{Visibility};\n use syntax::ast_util::{mod, is_local, lit_is_str, local_def, PostExpansionMethod};\n use syntax::attr::{mod, AttrMetaMethods};\n-use syntax::codemap::{DUMMY_SP, Span};\n-use syntax::parse::token::{mod, InternedString};\n+use syntax::codemap::Span;\n+use syntax::parse::token::{mod, InternedString, special_idents};\n use syntax::{ast, ast_map};\n \n pub type Disr = u64;\n@@ -397,14 +396,14 @@ pub fn type_of_adjust<'tcx>(cx: &ctxt<'tcx>, adj: &AutoAdjustment<'tcx>) -> Opti\n     fn type_of_autoref<'tcx>(cx: &ctxt<'tcx>, autoref: &AutoRef<'tcx>) -> Option<Ty<'tcx>> {\n         match autoref {\n             &AutoUnsize(ref k) => match k {\n-                &UnsizeVtable(TyTrait { ref principal, bounds }, _) => {\n-                    Some(mk_trait(cx, (*principal).clone(), bounds))\n+                &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n+                    Some(mk_trait(cx, principal.clone(), bounds.clone()))\n                 }\n                 _ => None\n             },\n             &AutoUnsizeUniq(ref k) => match k {\n-                &UnsizeVtable(TyTrait { ref principal, bounds }, _) => {\n-                    Some(mk_uniq(cx, mk_trait(cx, (*principal).clone(), bounds)))\n+                &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n+                    Some(mk_uniq(cx, mk_trait(cx, principal.clone(), bounds.clone())))\n                 }\n                 _ => None\n             },\n@@ -588,19 +587,36 @@ pub enum vtable_origin<'tcx> {\n \n // For every explicit cast into an object type, maps from the cast\n // expr to the associated trait ref.\n-pub type ObjectCastMap<'tcx> = RefCell<NodeMap<Rc<ty::PolyTraitRef<'tcx>>>>;\n+pub type ObjectCastMap<'tcx> = RefCell<NodeMap<ty::PolyTraitRef<'tcx>>>;\n \n /// A restriction that certain types must be the same size. The use of\n-/// `transmute` gives rise to these restrictions.\n+/// `transmute` gives rise to these restrictions. These generally\n+/// cannot be checked until trans; therefore, each call to `transmute`\n+/// will push one or more such restriction into the\n+/// `transmute_restrictions` vector during `intrinsicck`. They are\n+/// then checked during `trans` by the fn `check_intrinsics`.\n #[deriving(Copy)]\n pub struct TransmuteRestriction<'tcx> {\n-    /// The span from whence the restriction comes.\n+    /// The span whence the restriction comes.\n     pub span: Span,\n+\n     /// The type being transmuted from.\n-    pub from: Ty<'tcx>,\n+    pub original_from: Ty<'tcx>,\n+\n     /// The type being transmuted to.\n-    pub to: Ty<'tcx>,\n-    /// NodeIf of the transmute intrinsic.\n+    pub original_to: Ty<'tcx>,\n+\n+    /// The type being transmuted from, with all type parameters\n+    /// substituted for an arbitrary representative. Not to be shown\n+    /// to the end user.\n+    pub substituted_from: Ty<'tcx>,\n+\n+    /// The type being transmuted to, with all type parameters\n+    /// substituted for an arbitrary representative. Not to be shown\n+    /// to the end user.\n+    pub substituted_to: Ty<'tcx>,\n+\n+    /// NodeId of the transmute intrinsic.\n     pub id: ast::NodeId,\n }\n \n@@ -623,6 +639,24 @@ impl<'tcx> CtxtArenas<'tcx> {\n     }\n }\n \n+pub struct CommonTypes<'tcx> {\n+    pub bool: Ty<'tcx>,\n+    pub char: Ty<'tcx>,\n+    pub int: Ty<'tcx>,\n+    pub i8: Ty<'tcx>,\n+    pub i16: Ty<'tcx>,\n+    pub i32: Ty<'tcx>,\n+    pub i64: Ty<'tcx>,\n+    pub uint: Ty<'tcx>,\n+    pub u8: Ty<'tcx>,\n+    pub u16: Ty<'tcx>,\n+    pub u32: Ty<'tcx>,\n+    pub u64: Ty<'tcx>,\n+    pub f32: Ty<'tcx>,\n+    pub f64: Ty<'tcx>,\n+    pub err: Ty<'tcx>,\n+}\n+\n /// The data structure to keep track of all the information that typechecker\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n@@ -635,11 +669,15 @@ pub struct ctxt<'tcx> {\n     // FIXME(eddyb) use a FnvHashSet<InternedTy<'tcx>> when equivalent keys can\n     // queried from a HashSet.\n     interner: RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>,\n+\n     // FIXME as above, use a hashset if equivalent elements can be queried.\n     substs_interner: RefCell<FnvHashMap<&'tcx Substs<'tcx>, &'tcx Substs<'tcx>>>,\n     bare_fn_interner: RefCell<FnvHashMap<&'tcx BareFnTy<'tcx>, &'tcx BareFnTy<'tcx>>>,\n     region_interner: RefCell<FnvHashMap<&'tcx Region, &'tcx Region>>,\n \n+    /// Common types, pre-interned for your convenience.\n+    pub types: CommonTypes<'tcx>,\n+\n     pub sess: Session,\n     pub def_map: DefMap,\n \n@@ -679,10 +717,9 @@ pub struct ctxt<'tcx> {\n     pub map: ast_map::Map<'tcx>,\n     pub intrinsic_defs: RefCell<DefIdMap<Ty<'tcx>>>,\n     pub freevars: RefCell<FreevarMap>,\n-    pub tcache: RefCell<DefIdMap<Polytype<'tcx>>>,\n+    pub tcache: RefCell<DefIdMap<TypeScheme<'tcx>>>,\n     pub rcache: RefCell<FnvHashMap<creader_cache_key, Ty<'tcx>>>,\n     pub short_names_cache: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n-    pub needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n     pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, TypeContents>>,\n     pub ast_ty_to_ty_cache: RefCell<NodeMap<ast_ty_to_ty_cache_entry<'tcx>>>,\n     pub enum_var_cache: RefCell<DefIdMap<Rc<Vec<Rc<VariantInfo<'tcx>>>>>>,\n@@ -781,8 +818,15 @@ pub struct ctxt<'tcx> {\n     /// Caches the representation hints for struct definitions.\n     pub repr_hint_cache: RefCell<DefIdMap<Rc<Vec<attr::ReprAttr>>>>,\n \n-    /// Caches whether types move by default.\n-    pub type_moves_by_default_cache: RefCell<HashMap<Ty<'tcx>,bool>>,\n+    /// Caches whether types are known to impl Copy. Note that type\n+    /// parameters are never placed into this cache, because their\n+    /// results are dependent on the parameter environment.\n+    pub type_impls_copy_cache: RefCell<HashMap<Ty<'tcx>,bool>>,\n+\n+    /// Caches whether types are known to impl Sized. Note that type\n+    /// parameters are never placed into this cache, because their\n+    /// results are dependent on the parameter environment.\n+    pub type_impls_sized_cache: RefCell<HashMap<Ty<'tcx>,bool>>,\n }\n \n // Flags that we track on types. These flags are propagated upwards\n@@ -799,6 +843,7 @@ bitflags! {\n         const HAS_RE_LATE_BOUND   = 0b10000,\n         const HAS_REGIONS         = 0b100000,\n         const HAS_TY_ERR          = 0b1000000,\n+        const HAS_PROJECTION      = 0b10000000,\n         const NEEDS_SUBST   = HAS_PARAMS.bits | HAS_SELF.bits | HAS_REGIONS.bits,\n     }\n }\n@@ -869,7 +914,7 @@ impl<'tcx> ctxt<'tcx> {\n         sty_debug_print!(\n             self,\n             ty_enum, ty_uniq, ty_vec, ty_ptr, ty_rptr, ty_bare_fn, ty_closure, ty_trait,\n-            ty_struct, ty_unboxed_closure, ty_tup, ty_param, ty_open, ty_infer);\n+            ty_struct, ty_unboxed_closure, ty_tup, ty_param, ty_open, ty_infer, ty_projection);\n \n         println!(\"Substs interner: #{}\", self.substs_interner.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.bare_fn_interner.borrow().len());\n@@ -945,6 +990,9 @@ pub fn type_has_ty_infer(ty: Ty) -> bool {\n pub fn type_needs_infer(ty: Ty) -> bool {\n     ty.flags.intersects(HAS_TY_INFER | HAS_RE_INFER)\n }\n+pub fn type_has_projection(ty: Ty) -> bool {\n+    ty.flags.intersects(HAS_PROJECTION)\n+}\n \n pub fn type_has_late_bound_regions(ty: Ty) -> bool {\n     ty.flags.intersects(HAS_RE_LATE_BOUND)\n@@ -992,7 +1040,7 @@ pub struct ClosureTy<'tcx> {\n     pub unsafety: ast::Unsafety,\n     pub onceness: ast::Onceness,\n     pub store: TraitStore,\n-    pub bounds: ExistentialBounds,\n+    pub bounds: ExistentialBounds<'tcx>,\n     pub sig: PolyFnSig<'tcx>,\n     pub abi: abi::Abi,\n }\n@@ -1031,7 +1079,7 @@ pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n pub struct ParamTy {\n     pub space: subst::ParamSpace,\n     pub idx: u32,\n-    pub def_id: DefId\n+    pub name: ast::Name,\n }\n \n /// A [De Bruijn index][dbi] is a standard means of representing\n@@ -1275,54 +1323,6 @@ pub enum BoundRegion {\n     BrEnv\n }\n \n-#[inline]\n-pub fn mk_prim_t<'tcx>(primitive: &'tcx TyS<'static>) -> Ty<'tcx> {\n-    // FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n-    unsafe { &*(primitive as *const _ as *const TyS<'tcx>) }\n-}\n-\n-// Do not change these from static to const, interning types requires\n-// the primitives to have a significant address.\n-macro_rules! def_prim_tys {\n-    ($($name:ident -> $sty:expr;)*) => (\n-        $(#[inline] pub fn $name<'tcx>() -> Ty<'tcx> {\n-            static PRIM_TY: TyS<'static> = TyS {\n-                sty: $sty,\n-                flags: NO_TYPE_FLAGS,\n-                region_depth: 0,\n-            };\n-            mk_prim_t(&PRIM_TY)\n-        })*\n-    )\n-}\n-\n-def_prim_tys!{\n-    mk_bool ->  ty_bool;\n-    mk_char ->  ty_char;\n-    mk_int ->   ty_int(ast::TyI);\n-    mk_i8 ->    ty_int(ast::TyI8);\n-    mk_i16 ->   ty_int(ast::TyI16);\n-    mk_i32 ->   ty_int(ast::TyI32);\n-    mk_i64 ->   ty_int(ast::TyI64);\n-    mk_uint ->  ty_uint(ast::TyU);\n-    mk_u8 ->    ty_uint(ast::TyU8);\n-    mk_u16 ->   ty_uint(ast::TyU16);\n-    mk_u32 ->   ty_uint(ast::TyU32);\n-    mk_u64 ->   ty_uint(ast::TyU64);\n-    mk_f32 ->   ty_float(ast::TyF32);\n-    mk_f64 ->   ty_float(ast::TyF64);\n-}\n-\n-#[inline]\n-pub fn mk_err<'tcx>() -> Ty<'tcx> {\n-    static TY_ERR: TyS<'static> = TyS {\n-        sty: ty_err,\n-        flags: HAS_TY_ERR,\n-        region_depth: 0,\n-    };\n-    mk_prim_t(&TY_ERR)\n-}\n-\n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n@@ -1358,7 +1358,9 @@ pub enum sty<'tcx> {\n \n     ty_tup(Vec<Ty<'tcx>>),\n \n+    ty_projection(ProjectionTy<'tcx>),\n     ty_param(ParamTy), // type parameter\n+\n     ty_open(Ty<'tcx>), // A deref'ed fat pointer, i.e., a dynamically sized value\n                        // and its size. Only ever used in trans. It is not necessary\n                        // earlier since we don't need to distinguish a DST with its\n@@ -1373,25 +1375,59 @@ pub enum sty<'tcx> {\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct TyTrait<'tcx> {\n-    // Principal trait reference.\n-    pub principal: PolyTraitRef<'tcx>,\n-    pub bounds: ExistentialBounds\n+    pub principal: ty::PolyTraitRef<'tcx>,\n+    pub bounds: ExistentialBounds<'tcx>,\n }\n \n impl<'tcx> TyTrait<'tcx> {\n+    pub fn principal_def_id(&self) -> ast::DefId {\n+        self.principal.0.def_id\n+    }\n+\n     /// Object types don't have a self-type specified. Therefore, when\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self-type. A common choice is `mk_err()`\n     /// or some skolemized type.\n     pub fn principal_trait_ref_with_self_ty(&self,\n-                                            tcx: &ctxt<'tcx>, self_ty: Ty<'tcx>)\n-                                            -> Rc<ty::PolyTraitRef<'tcx>>\n+                                            tcx: &ctxt<'tcx>,\n+                                            self_ty: Ty<'tcx>)\n+                                            -> ty::PolyTraitRef<'tcx>\n     {\n-        Rc::new(ty::Binder(ty::TraitRef {\n-            def_id: self.principal.def_id(),\n-            substs: tcx.mk_substs(self.principal.substs().with_self_ty(self_ty)),\n+        // otherwise the escaping regions would be captured by the binder\n+        assert!(!self_ty.has_escaping_regions());\n+\n+        ty::Binder(Rc::new(ty::TraitRef {\n+            def_id: self.principal.0.def_id,\n+            substs: tcx.mk_substs(self.principal.0.substs.with_self_ty(self_ty)),\n         }))\n     }\n+\n+    pub fn projection_bounds_with_self_ty(&self,\n+                                          tcx: &ctxt<'tcx>,\n+                                          self_ty: Ty<'tcx>)\n+                                          -> Vec<ty::PolyProjectionPredicate<'tcx>>\n+    {\n+        // otherwise the escaping regions would be captured by the binders\n+        assert!(!self_ty.has_escaping_regions());\n+\n+        self.bounds.projection_bounds.iter()\n+            .map(|in_poly_projection_predicate| {\n+                let in_projection_ty = &in_poly_projection_predicate.0.projection_ty;\n+                let substs = tcx.mk_substs(in_projection_ty.trait_ref.substs.with_self_ty(self_ty));\n+                let trait_ref =\n+                    Rc::new(ty::TraitRef::new(in_projection_ty.trait_ref.def_id,\n+                                              substs));\n+                let projection_ty = ty::ProjectionTy {\n+                    trait_ref: trait_ref,\n+                    item_name: in_projection_ty.item_name\n+                };\n+                ty::Binder(ty::ProjectionPredicate {\n+                    projection_ty: projection_ty,\n+                    ty: in_poly_projection_predicate.0.ty\n+                })\n+            })\n+            .collect()\n+    }\n }\n \n /// A complete reference to a trait. These take numerous guises in syntax,\n@@ -1415,7 +1451,7 @@ pub struct TraitRef<'tcx> {\n     pub substs: &'tcx Substs<'tcx>,\n }\n \n-pub type PolyTraitRef<'tcx> = Binder<TraitRef<'tcx>>;\n+pub type PolyTraitRef<'tcx> = Binder<Rc<TraitRef<'tcx>>>;\n \n impl<'tcx> PolyTraitRef<'tcx> {\n     pub fn self_ty(&self) -> Ty<'tcx> {\n@@ -1433,6 +1469,11 @@ impl<'tcx> PolyTraitRef<'tcx> {\n     pub fn input_types(&self) -> &[Ty<'tcx>] {\n         self.0.input_types()\n     }\n+\n+    pub fn to_poly_trait_predicate(&self) -> PolyTraitPredicate<'tcx> {\n+        // Note that we preserve binding levels\n+        Binder(TraitPredicate { trait_ref: self.0.clone() })\n+    }\n }\n \n /// Binder is a binder for higher-ranked lifetimes. It is part of the\n@@ -1496,7 +1537,9 @@ pub enum type_err<'tcx> {\n     terr_builtin_bounds(expected_found<BuiltinBounds>),\n     terr_variadic_mismatch(expected_found<bool>),\n     terr_cyclic_ty,\n-    terr_convergence_mismatch(expected_found<bool>)\n+    terr_convergence_mismatch(expected_found<bool>),\n+    terr_projection_name_mismatched(expected_found<ast::Name>),\n+    terr_projection_bounds_length(expected_found<uint>),\n }\n \n /// Bounds suitable for a named type parameter like `A` in `fn foo<A>`\n@@ -1505,18 +1548,20 @@ pub enum type_err<'tcx> {\n pub struct ParamBounds<'tcx> {\n     pub region_bounds: Vec<ty::Region>,\n     pub builtin_bounds: BuiltinBounds,\n-    pub trait_bounds: Vec<Rc<PolyTraitRef<'tcx>>>\n+    pub trait_bounds: Vec<PolyTraitRef<'tcx>>,\n+    pub projection_bounds: Vec<PolyProjectionPredicate<'tcx>>,\n }\n \n /// Bounds suitable for an existentially quantified type parameter\n /// such as those that appear in object types or closure types. The\n /// major difference between this case and `ParamBounds` is that\n /// general purpose trait bounds are omitted and there must be\n /// *exactly one* region.\n-#[deriving(Copy, PartialEq, Eq, Hash, Clone, Show)]\n-pub struct ExistentialBounds {\n+#[deriving(PartialEq, Eq, Hash, Clone, Show)]\n+pub struct ExistentialBounds<'tcx> {\n     pub region_bound: ty::Region,\n-    pub builtin_bounds: BuiltinBounds\n+    pub builtin_bounds: BuiltinBounds,\n+    pub projection_bounds: Vec<PolyProjectionPredicate<'tcx>>,\n }\n \n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n@@ -1544,9 +1589,10 @@ pub fn all_builtin_bounds() -> BuiltinBounds {\n }\n \n /// An existential bound that does not implement any traits.\n-pub fn region_existential_bound(r: ty::Region) -> ExistentialBounds {\n+pub fn region_existential_bound<'tcx>(r: ty::Region) -> ExistentialBounds<'tcx> {\n     ty::ExistentialBounds { region_bound: r,\n-                            builtin_bounds: empty_builtin_bounds() }\n+                            builtin_bounds: empty_builtin_bounds(),\n+                            projection_bounds: Vec::new() }\n }\n \n impl CLike for BuiltinBound {\n@@ -1676,7 +1722,6 @@ pub struct TypeParameterDef<'tcx> {\n     pub def_id: ast::DefId,\n     pub space: subst::ParamSpace,\n     pub index: u32,\n-    pub associated_with: Option<ast::DefId>,\n     pub bounds: ParamBounds<'tcx>,\n     pub default: Option<Ty<'tcx>>,\n }\n@@ -1735,7 +1780,7 @@ pub enum Predicate<'tcx> {\n     /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the parameters in the `TypeSpace`.\n-    Trait(Rc<PolyTraitRef<'tcx>>),\n+    Trait(PolyTraitPredicate<'tcx>),\n \n     /// where `T1 == T2`.\n     Equate(PolyEquatePredicate<'tcx>),\n@@ -1745,6 +1790,36 @@ pub enum Predicate<'tcx> {\n \n     /// where T : 'a\n     TypeOutlives(PolyTypeOutlivesPredicate<'tcx>),\n+\n+    /// where <T as TraitRef>::Name == X, approximately.\n+    /// See `ProjectionPredicate` struct for details.\n+    Projection(PolyProjectionPredicate<'tcx>),\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+pub struct TraitPredicate<'tcx> {\n+    pub trait_ref: Rc<TraitRef<'tcx>>\n+}\n+pub type PolyTraitPredicate<'tcx> = ty::Binder<TraitPredicate<'tcx>>;\n+\n+impl<'tcx> TraitPredicate<'tcx> {\n+    pub fn def_id(&self) -> ast::DefId {\n+        self.trait_ref.def_id\n+    }\n+\n+    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+        self.trait_ref.substs.types.as_slice()\n+    }\n+\n+    pub fn self_ty(&self) -> Ty<'tcx> {\n+        self.trait_ref.self_ty()\n+    }\n+}\n+\n+impl<'tcx> PolyTraitPredicate<'tcx> {\n+    pub fn def_id(&self) -> ast::DefId {\n+        self.0.def_id()\n+    }\n }\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n@@ -1757,13 +1832,98 @@ pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n pub type PolyRegionOutlivesPredicate = PolyOutlivesPredicate<ty::Region, ty::Region>;\n pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, ty::Region>;\n \n+/// This kind of predicate has no *direct* correspondent in the\n+/// syntax, but it roughly corresponds to the syntactic forms:\n+///\n+/// 1. `T : TraitRef<..., Item=Type>`\n+/// 2. `<T as TraitRef<...>>::Item == Type` (NYI)\n+///\n+/// In particular, form #1 is \"desugared\" to the combination of a\n+/// normal trait predicate (`T : TraitRef<...>`) and one of these\n+/// predicates. Form #2 is a broader form in that it also permits\n+/// equality between arbitrary types. Processing an instance of Form\n+/// #2 eventually yields one of these `ProjectionPredicate`\n+/// instances to normalize the LHS.\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+pub struct ProjectionPredicate<'tcx> {\n+    pub projection_ty: ProjectionTy<'tcx>,\n+    pub ty: Ty<'tcx>,\n+}\n+\n+pub type PolyProjectionPredicate<'tcx> = Binder<ProjectionPredicate<'tcx>>;\n+\n+impl<'tcx> PolyProjectionPredicate<'tcx> {\n+    pub fn sort_key(&self) -> (ast::DefId, ast::Name) {\n+        self.0.projection_ty.sort_key()\n+    }\n+}\n+\n+/// Represents the projection of an associated type. In explicit UFCS\n+/// form this would be written `<T as Trait<..>>::N`.\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+pub struct ProjectionTy<'tcx> {\n+    /// The trait reference `T as Trait<..>`.\n+    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n+\n+    /// The name `N` of the associated type.\n+    pub item_name: ast::Name,\n+}\n+\n+impl<'tcx> ProjectionTy<'tcx> {\n+    pub fn sort_key(&self) -> (ast::DefId, ast::Name) {\n+        (self.trait_ref.def_id, self.item_name)\n+    }\n+}\n+\n+pub trait ToPolyTraitRef<'tcx> {\n+    fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx>;\n+}\n+\n+impl<'tcx> ToPolyTraitRef<'tcx> for Rc<TraitRef<'tcx>> {\n+    fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx> {\n+        assert!(!self.has_escaping_regions());\n+        ty::Binder(self.clone())\n+    }\n+}\n+\n+impl<'tcx> ToPolyTraitRef<'tcx> for PolyTraitPredicate<'tcx> {\n+    fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx> {\n+        // We are just preserving the binder levels here\n+        ty::Binder(self.0.trait_ref.clone())\n+    }\n+}\n+\n+impl<'tcx> ToPolyTraitRef<'tcx> for PolyProjectionPredicate<'tcx> {\n+    fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx> {\n+        // Note: unlike with TraitRef::to_poly_trait_ref(),\n+        // self.0.trait_ref is permitted to have escaping regions.\n+        // This is because here `self` has a `Binder` and so does our\n+        // return value, so we are preserving the number of binding\n+        // levels.\n+        ty::Binder(self.0.projection_ty.trait_ref.clone())\n+    }\n+}\n+\n pub trait AsPredicate<'tcx> {\n     fn as_predicate(&self) -> Predicate<'tcx>;\n }\n \n-impl<'tcx> AsPredicate<'tcx> for Rc<PolyTraitRef<'tcx>> {\n+impl<'tcx> AsPredicate<'tcx> for Rc<TraitRef<'tcx>> {\n+    fn as_predicate(&self) -> Predicate<'tcx> {\n+        // we're about to add a binder, so let's check that we don't\n+        // accidentally capture anything, or else that might be some\n+        // weird debruijn accounting.\n+        assert!(!self.has_escaping_regions());\n+\n+        ty::Predicate::Trait(ty::Binder(ty::TraitPredicate {\n+            trait_ref: self.clone()\n+        }))\n+    }\n+}\n+\n+impl<'tcx> AsPredicate<'tcx> for PolyTraitRef<'tcx> {\n     fn as_predicate(&self) -> Predicate<'tcx> {\n-        Predicate::Trait(self.clone())\n+        ty::Predicate::Trait(self.to_poly_trait_predicate())\n     }\n }\n \n@@ -1785,21 +1945,29 @@ impl<'tcx> AsPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> AsPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n+    fn as_predicate(&self) -> Predicate<'tcx> {\n+        Predicate::Projection(self.clone())\n+    }\n+}\n+\n impl<'tcx> Predicate<'tcx> {\n     pub fn has_escaping_regions(&self) -> bool {\n         match *self {\n             Predicate::Trait(ref trait_ref) => trait_ref.has_escaping_regions(),\n             Predicate::Equate(ref p) => p.has_escaping_regions(),\n             Predicate::RegionOutlives(ref p) => p.has_escaping_regions(),\n             Predicate::TypeOutlives(ref p) => p.has_escaping_regions(),\n+            Predicate::Projection(ref p) => p.has_escaping_regions(),\n         }\n     }\n \n-    pub fn to_trait(&self) -> Option<Rc<PolyTraitRef<'tcx>>> {\n+    pub fn to_opt_poly_trait_ref(&self) -> Option<PolyTraitRef<'tcx>> {\n         match *self {\n             Predicate::Trait(ref t) => {\n-                Some(t.clone())\n+                Some(t.to_poly_trait_ref())\n             }\n+            Predicate::Projection(..) |\n             Predicate::Equate(..) |\n             Predicate::RegionOutlives(..) |\n             Predicate::TypeOutlives(..) => {\n@@ -2007,18 +2175,29 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n     }\n }\n \n-/// A polytype.\n+/// A \"type scheme\", in ML terminology, is a type combined with some\n+/// set of generic types that the type is, well, generic over. In Rust\n+/// terms, it is the \"type\" of a fn item or struct -- this type will\n+/// include various generic parameters that must be substituted when\n+/// the item/struct is referenced. That is called converting the type\n+/// scheme to a monotype.\n ///\n /// - `generics`: the set of type parameters and their bounds\n /// - `ty`: the base types, which may reference the parameters defined\n ///   in `generics`\n+///\n+/// Note that TypeSchemes are also sometimes called \"polytypes\" (and\n+/// in fact this struct used to carry that name, so you may find some\n+/// stray references in a comment or something). We try to reserve the\n+/// \"poly\" prefix to refer to higher-ranked things, as in\n+/// `PolyTraitRef`.\n #[deriving(Clone, Show)]\n-pub struct Polytype<'tcx> {\n+pub struct TypeScheme<'tcx> {\n     pub generics: Generics<'tcx>,\n     pub ty: Ty<'tcx>\n }\n \n-/// As `Polytype` but for a trait ref.\n+/// As `TypeScheme` but for a trait ref.\n pub struct TraitDef<'tcx> {\n     pub unsafety: ast::Unsafety,\n \n@@ -2031,7 +2210,12 @@ pub struct TraitDef<'tcx> {\n \n     /// The \"supertrait\" bounds.\n     pub bounds: ParamBounds<'tcx>,\n+\n     pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n+\n+    /// A list of the associated types defined in this trait. Useful\n+    /// for resolving `X::Foo` type markers.\n+    pub associated_type_names: Vec<ast::Name>,\n }\n \n /// Records the substitutions used to translate the polytype for an\n@@ -2075,6 +2259,31 @@ impl UnboxedClosureKind {\n     }\n }\n \n+impl<'tcx> CommonTypes<'tcx> {\n+    fn new(arena: &'tcx TypedArena<TyS<'tcx>>,\n+           interner: &mut FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>)\n+           -> CommonTypes<'tcx>\n+    {\n+        CommonTypes {\n+            bool: intern_ty(arena, interner, ty_bool),\n+            char: intern_ty(arena, interner, ty_char),\n+            err: intern_ty(arena, interner, ty_err),\n+            int: intern_ty(arena, interner, ty_int(ast::TyI)),\n+            i8: intern_ty(arena, interner, ty_int(ast::TyI8)),\n+            i16: intern_ty(arena, interner, ty_int(ast::TyI16)),\n+            i32: intern_ty(arena, interner, ty_int(ast::TyI32)),\n+            i64: intern_ty(arena, interner, ty_int(ast::TyI64)),\n+            uint: intern_ty(arena, interner, ty_uint(ast::TyU)),\n+            u8: intern_ty(arena, interner, ty_uint(ast::TyU8)),\n+            u16: intern_ty(arena, interner, ty_uint(ast::TyU16)),\n+            u32: intern_ty(arena, interner, ty_uint(ast::TyU32)),\n+            u64: intern_ty(arena, interner, ty_uint(ast::TyU64)),\n+            f32: intern_ty(arena, interner, ty_float(ast::TyF32)),\n+            f64: intern_ty(arena, interner, ty_float(ast::TyF64)),\n+        }\n+    }\n+}\n+\n pub fn mk_ctxt<'tcx>(s: Session,\n                      arenas: &'tcx CtxtArenas<'tcx>,\n                      dm: DefMap,\n@@ -2084,13 +2293,18 @@ pub fn mk_ctxt<'tcx>(s: Session,\n                      capture_modes: RefCell<CaptureModeMap>,\n                      region_maps: middle::region::RegionMaps,\n                      lang_items: middle::lang_items::LanguageItems,\n-                     stability: stability::Index) -> ctxt<'tcx> {\n+                     stability: stability::Index) -> ctxt<'tcx>\n+{\n+    let mut interner = FnvHashMap::new();\n+    let common_types = CommonTypes::new(&arenas.type_, &mut interner);\n+\n     ctxt {\n         arenas: arenas,\n-        interner: RefCell::new(FnvHashMap::new()),\n+        interner: RefCell::new(interner),\n         substs_interner: RefCell::new(FnvHashMap::new()),\n         bare_fn_interner: RefCell::new(FnvHashMap::new()),\n         region_interner: RefCell::new(FnvHashMap::new()),\n+        types: common_types,\n         named_region_map: named_region_map,\n         item_variance_map: RefCell::new(DefIdMap::new()),\n         variance_computed: Cell::new(false),\n@@ -2108,7 +2322,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         tcache: RefCell::new(DefIdMap::new()),\n         rcache: RefCell::new(FnvHashMap::new()),\n         short_names_cache: RefCell::new(FnvHashMap::new()),\n-        needs_unwind_cleanup_cache: RefCell::new(FnvHashMap::new()),\n         tc_cache: RefCell::new(FnvHashMap::new()),\n         ast_ty_to_ty_cache: RefCell::new(NodeMap::new()),\n         enum_var_cache: RefCell::new(DefIdMap::new()),\n@@ -2144,7 +2357,8 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         associated_types: RefCell::new(DefIdMap::new()),\n         selection_cache: traits::SelectionCache::new(),\n         repr_hint_cache: RefCell::new(DefIdMap::new()),\n-        type_moves_by_default_cache: RefCell::new(HashMap::new()),\n+        type_impls_copy_cache: RefCell::new(HashMap::new()),\n+        type_impls_sized_cache: RefCell::new(HashMap::new()),\n    }\n }\n \n@@ -2185,31 +2399,32 @@ impl<'tcx> ctxt<'tcx> {\n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for Ty above).\n pub fn mk_t<'tcx>(cx: &ctxt<'tcx>, st: sty<'tcx>) -> Ty<'tcx> {\n-    // Check for primitive types.\n-    match st {\n-        ty_err => return mk_err(),\n-        ty_bool => return mk_bool(),\n-        ty_int(i) => return mk_mach_int(i),\n-        ty_uint(u) => return mk_mach_uint(u),\n-        ty_float(f) => return mk_mach_float(f),\n-        ty_char => return mk_char(),\n-        _ => {}\n-    };\n+    let mut interner = cx.interner.borrow_mut();\n+    intern_ty(&cx.arenas.type_, &mut *interner, st)\n+}\n \n-    match cx.interner.borrow().get(&st) {\n+fn intern_ty<'tcx>(type_arena: &'tcx TypedArena<TyS<'tcx>>,\n+                   interner: &mut FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>,\n+                   st: sty<'tcx>)\n+                   -> Ty<'tcx>\n+{\n+    match interner.get(&st) {\n         Some(ty) => return *ty,\n         _ => ()\n     }\n \n     let flags = FlagComputation::for_sty(&st);\n \n-    let ty = cx.arenas.type_.alloc(TyS {\n+    let ty = type_arena.alloc(TyS {\n         sty: st,\n         flags: flags.flags,\n         region_depth: flags.depth,\n     });\n \n-    cx.interner.borrow_mut().insert(InternedTy { ty: ty }, ty);\n+    debug!(\"Interned type: {} Pointer: {}\",\n+           ty, ty as *const _);\n+\n+    interner.insert(InternedTy { ty: ty }, ty);\n \n     ty\n }\n@@ -2298,9 +2513,14 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n+            &ty_projection(ref data) => {\n+                self.add_flags(HAS_PROJECTION);\n+                self.add_substs(data.trait_ref.substs);\n+            }\n+\n             &ty_trait(box TyTrait { ref principal, ref bounds }) => {\n                 let mut computation = FlagComputation::new();\n-                computation.add_substs(principal.substs());\n+                computation.add_substs(principal.0.substs);\n                 self.add_bound_computation(&computation);\n \n                 self.add_bounds(bounds);\n@@ -2389,30 +2609,30 @@ impl FlagComputation {\n     }\n }\n \n-pub fn mk_mach_int<'tcx>(tm: ast::IntTy) -> Ty<'tcx> {\n+pub fn mk_mach_int<'tcx>(tcx: &ctxt<'tcx>, tm: ast::IntTy) -> Ty<'tcx> {\n     match tm {\n-        ast::TyI    => mk_int(),\n-        ast::TyI8   => mk_i8(),\n-        ast::TyI16  => mk_i16(),\n-        ast::TyI32  => mk_i32(),\n-        ast::TyI64  => mk_i64(),\n+        ast::TyI    => tcx.types.int,\n+        ast::TyI8   => tcx.types.i8,\n+        ast::TyI16  => tcx.types.i16,\n+        ast::TyI32  => tcx.types.i32,\n+        ast::TyI64  => tcx.types.i64,\n     }\n }\n \n-pub fn mk_mach_uint<'tcx>(tm: ast::UintTy) -> Ty<'tcx> {\n+pub fn mk_mach_uint<'tcx>(tcx: &ctxt<'tcx>, tm: ast::UintTy) -> Ty<'tcx> {\n     match tm {\n-        ast::TyU    => mk_uint(),\n-        ast::TyU8   => mk_u8(),\n-        ast::TyU16  => mk_u16(),\n-        ast::TyU32  => mk_u32(),\n-        ast::TyU64  => mk_u64(),\n+        ast::TyU    => tcx.types.uint,\n+        ast::TyU8   => tcx.types.u8,\n+        ast::TyU16  => tcx.types.u16,\n+        ast::TyU32  => tcx.types.u32,\n+        ast::TyU64  => tcx.types.u64,\n     }\n }\n \n-pub fn mk_mach_float<'tcx>(tm: ast::FloatTy) -> Ty<'tcx> {\n+pub fn mk_mach_float<'tcx>(tcx: &ctxt<'tcx>, tm: ast::FloatTy) -> Ty<'tcx> {\n     match tm {\n-        ast::TyF32  => mk_f32(),\n-        ast::TyF64  => mk_f64(),\n+        ast::TyF32  => tcx.types.f32,\n+        ast::TyF64  => tcx.types.f64,\n     }\n }\n \n@@ -2508,19 +2728,39 @@ pub fn mk_ctor_fn<'tcx>(cx: &ctxt<'tcx>,\n                 }))\n }\n \n-\n pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n                       principal: ty::PolyTraitRef<'tcx>,\n-                      bounds: ExistentialBounds)\n-                      -> Ty<'tcx> {\n-    // take a copy of substs so that we own the vectors inside\n+                      bounds: ExistentialBounds<'tcx>)\n+                      -> Ty<'tcx>\n+{\n+    assert!(bound_list_is_sorted(bounds.projection_bounds.as_slice()));\n+\n     let inner = box TyTrait {\n         principal: principal,\n         bounds: bounds\n     };\n     mk_t(cx, ty_trait(inner))\n }\n \n+fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n+    bounds.len() == 0 ||\n+        bounds[1..].iter().enumerate().all(\n+            |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n+}\n+\n+pub fn sort_bounds_list(bounds: &mut [ty::PolyProjectionPredicate]) {\n+    bounds.sort_by(|a, b| a.sort_key().cmp(&b.sort_key()))\n+}\n+\n+pub fn mk_projection<'tcx>(cx: &ctxt<'tcx>,\n+                           trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                           item_name: ast::Name)\n+                           -> Ty<'tcx> {\n+    // take a copy of substs so that we own the vectors inside\n+    let inner = ProjectionTy { trait_ref: trait_ref, item_name: item_name };\n+    mk_t(cx, ty_projection(inner))\n+}\n+\n pub fn mk_struct<'tcx>(cx: &ctxt<'tcx>, struct_id: ast::DefId,\n                        substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n     // take a copy of substs so that we own the vectors inside\n@@ -2549,17 +2789,19 @@ pub fn mk_infer<'tcx>(cx: &ctxt<'tcx>, it: InferTy) -> Ty<'tcx> {\n     mk_t(cx, ty_infer(it))\n }\n \n-pub fn mk_param<'tcx>(cx: &ctxt<'tcx>, space: subst::ParamSpace,\n-                      n: u32, k: DefId) -> Ty<'tcx> {\n-    mk_t(cx, ty_param(ParamTy { space: space, idx: n, def_id: k }))\n+pub fn mk_param<'tcx>(cx: &ctxt<'tcx>,\n+                      space: subst::ParamSpace,\n+                      index: u32,\n+                      name: ast::Name) -> Ty<'tcx> {\n+    mk_t(cx, ty_param(ParamTy { space: space, idx: index, name: name }))\n }\n \n-pub fn mk_self_type<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId) -> Ty<'tcx> {\n-    mk_param(cx, subst::SelfSpace, 0, did)\n+pub fn mk_self_type<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n+    mk_param(cx, subst::SelfSpace, 0, special_idents::type_self.name)\n }\n \n pub fn mk_param_from_def<'tcx>(cx: &ctxt<'tcx>, def: &TypeParameterDef) -> Ty<'tcx> {\n-    mk_param(cx, def.space, def.index, def.def_id)\n+    mk_param(cx, def.space, def.index, def.name)\n }\n \n pub fn mk_open<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> { mk_t(cx, ty_open(ty)) }\n@@ -2583,7 +2825,12 @@ pub fn maybe_walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>| -> bool) {\n             maybe_walk_ty(tm.ty, f);\n         }\n         ty_trait(box TyTrait { ref principal, .. }) => {\n-            for subty in principal.substs().types.iter() {\n+            for subty in principal.0.substs.types.iter() {\n+                maybe_walk_ty(*subty, |x| f(x));\n+            }\n+        }\n+        ty_projection(ProjectionTy { ref trait_ref, .. }) => {\n+            for subty in trait_ref.substs.types.iter() {\n                 maybe_walk_ty(*subty, |x| f(x));\n             }\n         }\n@@ -2623,21 +2870,21 @@ pub fn fold_ty<'tcx, F>(cx: &ctxt<'tcx>, t0: Ty<'tcx>,\n impl ParamTy {\n     pub fn new(space: subst::ParamSpace,\n                index: u32,\n-               def_id: ast::DefId)\n+               name: ast::Name)\n                -> ParamTy {\n-        ParamTy { space: space, idx: index, def_id: def_id }\n+        ParamTy { space: space, idx: index, name: name }\n     }\n \n-    pub fn for_self(trait_def_id: ast::DefId) -> ParamTy {\n-        ParamTy::new(subst::SelfSpace, 0, trait_def_id)\n+    pub fn for_self() -> ParamTy {\n+        ParamTy::new(subst::SelfSpace, 0, special_idents::type_self.name)\n     }\n \n     pub fn for_def(def: &TypeParameterDef) -> ParamTy {\n-        ParamTy::new(def.space, def.index, def.def_id)\n+        ParamTy::new(def.space, def.index, def.name)\n     }\n \n     pub fn to_ty<'tcx>(self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n-        ty::mk_param(tcx, self.space, self.idx, self.def_id)\n+        ty::mk_param(tcx, self.space, self.idx, self.name)\n     }\n \n     pub fn is_self(&self) -> bool {\n@@ -2661,6 +2908,7 @@ impl<'tcx> ParamBounds<'tcx> {\n             builtin_bounds: empty_builtin_bounds(),\n             trait_bounds: Vec::new(),\n             region_bounds: Vec::new(),\n+            projection_bounds: Vec::new(),\n         }\n     }\n }\n@@ -2742,7 +2990,7 @@ pub fn type_is_simd(cx: &ctxt, ty: Ty) -> bool {\n pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_vec(ty, _) => ty,\n-        ty_str => mk_mach_uint(ast::TyU8),\n+        ty_str => mk_mach_uint(cx, ast::TyU8),\n         ty_open(ty) => sequence_element_type(cx, ty),\n         _ => cx.sess.bug(format!(\"sequence_element_type called on non-sequence value: {}\",\n                                  ty_to_string(cx, ty))[]),\n@@ -2793,14 +3041,6 @@ pub fn type_is_unique(ty: Ty) -> bool {\n     }\n }\n \n-pub fn type_is_fat_ptr<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n-        ty_ptr(mt{ty, ..}) | ty_rptr(_, mt{ty, ..})\n-        | ty_uniq(ty) if !type_is_sized(cx, ty) => true,\n-        _ => false,\n-    }\n-}\n-\n /*\n  A scalar type is one that denotes an atomic datum, with no sub-components.\n  (A ty_ptr is scalar because it represents a non-managed pointer, so its\n@@ -2824,48 +3064,6 @@ pub fn type_is_floating_point(ty: Ty) -> bool {\n     }\n }\n \n-pub fn type_needs_drop<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    type_contents(cx, ty).needs_drop(cx)\n-}\n-\n-// Some things don't need cleanups during unwinding because the\n-// task can free them all at once later. Currently only things\n-// that only contain scalars and shared boxes can avoid unwind\n-// cleanups.\n-pub fn type_needs_unwind_cleanup<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    return memoized(&cx.needs_unwind_cleanup_cache, ty, |ty| {\n-        type_needs_unwind_cleanup_(cx, ty, &mut FnvHashSet::new())\n-    });\n-\n-    fn type_needs_unwind_cleanup_<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>,\n-                                        tycache: &mut FnvHashSet<Ty<'tcx>>) -> bool {\n-        // Prevent infinite recursion\n-        if !tycache.insert(ty) {\n-            return false;\n-        }\n-\n-        let mut needs_unwind_cleanup = false;\n-        maybe_walk_ty(ty, |ty| {\n-            needs_unwind_cleanup |= match ty.sty {\n-                ty_bool | ty_int(_) | ty_uint(_) |\n-                ty_float(_) | ty_tup(_) | ty_ptr(_) => false,\n-\n-                ty_enum(did, substs) =>\n-                    enum_variants(cx, did).iter().any(|v|\n-                        v.args.iter().any(|aty| {\n-                            let t = aty.subst(cx, substs);\n-                            type_needs_unwind_cleanup_(cx, t, tycache)\n-                        })\n-                    ),\n-\n-                _ => true\n-            };\n-            !needs_unwind_cleanup\n-        });\n-        needs_unwind_cleanup\n-    }\n-}\n-\n /// Type contents is how the type checker reasons about kinds.\n /// They track what kinds of things are found within a type.  You can\n /// think of them as kind of an \"anti-kind\".  They track the kinds of values\n@@ -2901,6 +3099,7 @@ def_type_content_sets! {\n         // Things that are interior to the value (first nibble):\n         InteriorUnsized                     = 0b0000_0000__0000_0000__0001,\n         InteriorUnsafe                      = 0b0000_0000__0000_0000__0010,\n+        InteriorParam                       = 0b0000_0000__0000_0000__0100,\n         // InteriorAll                         = 0b00000000__00000000__1111,\n \n         // Things that are owned by the value (second and third nibbles):\n@@ -2955,6 +3154,10 @@ impl TypeContents {\n         !self.intersects(TC::Nonsized)\n     }\n \n+    pub fn interior_param(&self) -> bool {\n+        self.intersects(TC::InteriorParam)\n+    }\n+\n     pub fn interior_unsafe(&self) -> bool {\n         self.intersects(TC::InteriorUnsafe)\n     }\n@@ -3083,7 +3286,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n \n             ty_closure(ref c) => {\n-                closure_contents(cx, &**c) | TC::ReachesFfiUnsafe\n+                closure_contents(&**c) | TC::ReachesFfiUnsafe\n             }\n \n             ty_uniq(typ) => {\n@@ -3093,8 +3296,8 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 }\n             }\n \n-            ty_trait(box TyTrait { bounds, .. }) => {\n-                object_contents(cx, bounds) | TC::ReachesFfiUnsafe | TC::Nonsized\n+            ty_trait(box TyTrait { ref bounds, .. }) => {\n+                object_contents(bounds) | TC::ReachesFfiUnsafe | TC::Nonsized\n             }\n \n             ty_ptr(ref mt) => {\n@@ -3204,26 +3407,8 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 apply_lang_items(cx, did, res)\n             }\n \n-            ty_param(p) => {\n-                // We only ever ask for the kind of types that are defined in\n-                // the current crate; therefore, the only type parameters that\n-                // could be in scope are those defined in the current crate.\n-                // If this assertion fails, it is likely because of a\n-                // failure of the cross-crate inlining code to translate a\n-                // def-id.\n-                assert_eq!(p.def_id.krate, ast::LOCAL_CRATE);\n-\n-                let ty_param_defs = cx.ty_param_defs.borrow();\n-                let tp_def = &(*ty_param_defs)[p.def_id.node];\n-                kind_bounds_to_contents(\n-                    cx,\n-                    tp_def.bounds.builtin_bounds,\n-                    tp_def.bounds.trait_bounds[])\n-            }\n-\n-            ty_infer(_) => {\n-                // This occurs during coherence, but shouldn't occur at other\n-                // times.\n+            ty_projection(..) |\n+            ty_param(_) => {\n                 TC::All\n             }\n \n@@ -3233,6 +3418,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 result.unsafe_pointer() | TC::Nonsized\n             }\n \n+            ty_infer(_) |\n             ty_err => {\n                 cx.sess.bug(\"asked to compute contents of error type\");\n             }\n@@ -3272,10 +3458,10 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n         b | (TC::ReachesBorrowed).when(region != ty::ReStatic)\n     }\n \n-    fn closure_contents(cx: &ctxt, cty: &ClosureTy) -> TypeContents {\n+    fn closure_contents(cty: &ClosureTy) -> TypeContents {\n         // Closure contents are just like trait contents, but with potentially\n         // even more stuff.\n-        let st = object_contents(cx, cty.bounds);\n+        let st = object_contents(&cty.bounds);\n \n         let st = match cty.store {\n             UniqTraitStore => {\n@@ -3289,89 +3475,73 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n         st\n     }\n \n-    fn object_contents(cx: &ctxt,\n-                       bounds: ExistentialBounds)\n-                       -> TypeContents {\n-        // These are the type contents of the (opaque) interior\n-        kind_bounds_to_contents(cx, bounds.builtin_bounds, &[])\n-    }\n-\n-    fn kind_bounds_to_contents<'tcx>(cx: &ctxt<'tcx>,\n-                                     bounds: BuiltinBounds,\n-                                     traits: &[Rc<PolyTraitRef<'tcx>>])\n-                                     -> TypeContents {\n-        let _i = indenter();\n-        let mut tc = TC::All;\n-        each_inherited_builtin_bound(cx, bounds, traits, |bound| {\n+    fn object_contents(bounds: &ExistentialBounds) -> TypeContents {\n+        // These are the type contents of the (opaque) interior. We\n+        // make no assumptions (other than that it cannot have an\n+        // in-scope type parameter within, which makes no sense).\n+        let mut tc = TC::All - TC::InteriorParam;\n+        for bound in bounds.builtin_bounds.iter() {\n             tc = tc - match bound {\n                 BoundSync | BoundSend | BoundCopy => TC::None,\n                 BoundSized => TC::Nonsized,\n             };\n-        });\n-        return tc;\n-\n-        // Iterates over all builtin bounds on the type parameter def, including\n-        // those inherited from traits with builtin-kind-supertraits.\n-        fn each_inherited_builtin_bound<'tcx, F>(cx: &ctxt<'tcx>,\n-                                                 bounds: BuiltinBounds,\n-                                                 traits: &[Rc<PolyTraitRef<'tcx>>],\n-                                                 mut f: F) where\n-            F: FnMut(BuiltinBound),\n-        {\n-            for bound in bounds.iter() {\n-                f(bound);\n-            }\n-\n-            each_bound_trait_and_supertraits(cx, traits, |trait_ref| {\n-                let trait_def = lookup_trait_def(cx, trait_ref.def_id());\n-                for bound in trait_def.bounds.builtin_bounds.iter() {\n-                    f(bound);\n-                }\n-                true\n-            });\n         }\n+        return tc;\n     }\n }\n \n-pub fn type_moves_by_default<'tcx>(cx: &ctxt<'tcx>,\n-                                   ty: Ty<'tcx>,\n-                                   param_env: &ParameterEnvironment<'tcx>)\n-                                   -> bool\n+fn type_impls_bound<'tcx>(cx: &ctxt<'tcx>,\n+                          cache: &RefCell<HashMap<Ty<'tcx>,bool>>,\n+                          param_env: &ParameterEnvironment<'tcx>,\n+                          ty: Ty<'tcx>,\n+                          bound: ty::BuiltinBound)\n+                          -> bool\n {\n+    assert!(!ty::type_needs_infer(ty));\n+\n     if !type_has_params(ty) && !type_has_self(ty) {\n-        match cx.type_moves_by_default_cache.borrow().get(&ty) {\n+        match cache.borrow().get(&ty) {\n             None => {}\n             Some(&result) => {\n-                debug!(\"determined whether {} moves by default (cached): {}\",\n+                debug!(\"type_impls_bound({}, {}) = {} (cached)\",\n                        ty_to_string(cx, ty),\n+                       bound,\n                        result);\n                 return result\n             }\n         }\n     }\n \n     let infcx = infer::new_infer_ctxt(cx);\n-    let mut fulfill_cx = traits::FulfillmentContext::new();\n+    let is_impld = traits::type_known_to_meet_builtin_bound(&infcx, param_env, ty, bound);\n \n-    // we can use dummy values here because we won't report any errors\n-    // that result nor will we pay any mind to region obligations that arise\n-    // (there shouldn't really be any anyhow)\n-    let cause = ObligationCause::misc(DUMMY_SP, DUMMY_NODE_ID);\n+    debug!(\"type_impls_bound({}, {}) = {}\",\n+           ty_to_string(cx, ty),\n+           bound,\n+           is_impld);\n \n-    fulfill_cx.register_builtin_bound(cx, ty, ty::BoundCopy, cause);\n+    if !type_has_params(ty) && !type_has_self(ty) {\n+        let old_value = cache.borrow_mut().insert(ty, is_impld);\n+        assert!(old_value.is_none());\n+    }\n \n-    // Note: we only assuming something is `Copy` if we can\n-    // *definitively* show that it implements `Copy`. Otherwise,\n-    // assume it is move; linear is always ok.\n-    let is_copy = fulfill_cx.select_all_or_error(&infcx, param_env, cx).is_ok();\n-    let is_move = !is_copy;\n+    is_impld\n+}\n \n-    debug!(\"determined whether {} moves by default: {}\",\n-           ty_to_string(cx, ty),\n-           is_move);\n+pub fn type_moves_by_default<'tcx>(cx: &ctxt<'tcx>,\n+                                   ty: Ty<'tcx>,\n+                                   param_env: &ParameterEnvironment<'tcx>)\n+                                   -> bool\n+{\n+    !type_impls_bound(cx, &cx.type_impls_copy_cache, param_env, ty, ty::BoundCopy)\n+}\n \n-    cx.type_moves_by_default_cache.borrow_mut().insert(ty, is_move);\n-    is_move\n+pub fn type_is_sized<'tcx>(cx: &ctxt<'tcx>,\n+                           ty: Ty<'tcx>,\n+                           param_env: &ParameterEnvironment<'tcx>)\n+                           -> bool\n+{\n+    type_impls_bound(cx, &cx.type_impls_sized_cache, param_env, ty, ty::BoundSized)\n }\n \n pub fn is_ffi_safe<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -3419,6 +3589,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n             ty_infer(_) |\n             ty_err |\n             ty_param(_) |\n+            ty_projection(_) |\n             ty_vec(_, None) => {\n                 false\n             }\n@@ -3743,40 +3914,6 @@ pub fn type_is_machine(ty: Ty) -> bool {\n     }\n }\n \n-// Is the type's representation size known at compile time?\n-pub fn type_is_sized<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    type_contents(cx, ty).is_sized(cx)\n-}\n-\n-pub fn lltype_is_sized<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n-        ty_open(_) => true,\n-        _ => type_contents(cx, ty).is_sized(cx)\n-    }\n-}\n-\n-// Return the smallest part of `ty` which is unsized. Fails if `ty` is sized.\n-// 'Smallest' here means component of the static representation of the type; not\n-// the size of an object at runtime.\n-pub fn unsized_part_of_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match ty.sty {\n-        ty_str | ty_trait(..) | ty_vec(..) => ty,\n-        ty_struct(def_id, substs) => {\n-            let unsized_fields: Vec<_> = struct_fields(cx, def_id, substs).iter()\n-                .map(|f| f.mt.ty).filter(|ty| !type_is_sized(cx, *ty)).collect();\n-            // Exactly one of the fields must be unsized.\n-            assert!(unsized_fields.len() == 1);\n-\n-            unsized_part_of_type(cx, unsized_fields[0])\n-        }\n-        _ => {\n-            assert!(type_is_sized(cx, ty),\n-                    \"unsized_part_of_type failed even though ty is unsized\");\n-            panic!(\"called unsized_part_of_type with sized ty\");\n-        }\n-    }\n-}\n-\n // Whether a type is enum like, that is an enum type with only nullary\n // constructors\n pub fn type_is_c_like_enum(cx: &ctxt, ty: Ty) -> bool {\n@@ -3846,10 +3983,10 @@ pub fn index<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n // Returns the type of elements contained within an 'array-like' type.\n // This is exactly the same as the above, except it supports strings,\n // which can't actually be indexed.\n-pub fn array_element_ty<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+pub fn array_element_ty<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     match ty.sty {\n         ty_vec(ty, _) => Some(ty),\n-        ty_str => Some(mk_u8()),\n+        ty_str => Some(tcx.types.u8),\n         _ => None\n     }\n }\n@@ -4138,6 +4275,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                             let bounds = ty::ExistentialBounds {\n                                 region_bound: ReStatic,\n                                 builtin_bounds: all_builtin_bounds(),\n+                                projection_bounds: vec!(),\n                             };\n \n                             ty::mk_closure(\n@@ -4272,8 +4410,8 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n                                   format!(\"UnsizeStruct with bad sty: {}\",\n                                           ty_to_string(cx, ty))[])\n         },\n-        &UnsizeVtable(TyTrait { ref principal, bounds }, _) => {\n-            mk_trait(cx, (*principal).clone(), bounds)\n+        &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n+            mk_trait(cx, principal.clone(), bounds.clone())\n         }\n     }\n }\n@@ -4529,7 +4667,7 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n         ty_bare_fn(None, _) => \"fn pointer\".to_string(),\n         ty_closure(_) => \"fn\".to_string(),\n         ty_trait(ref inner) => {\n-            format!(\"trait {}\", item_path_str(cx, inner.principal.def_id()))\n+            format!(\"trait {}\", item_path_str(cx, inner.principal_def_id()))\n         }\n         ty_struct(id, _) => {\n             format!(\"struct {}\", item_path_str(cx, id))\n@@ -4541,6 +4679,7 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n         ty_infer(FloatVar(_)) => \"floating-point variable\".to_string(),\n         ty_infer(FreshTy(_)) => \"skolemized type\".to_string(),\n         ty_infer(FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n+        ty_projection(_) => \"associated type\".to_string(),\n         ty_param(ref p) => {\n             if p.space == subst::SelfSpace {\n                 \"Self\".to_string()\n@@ -4553,6 +4692,12 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for ty::type_err<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        ty::type_err_to_str(tcx, self)\n+    }\n+}\n+\n /// Explains the source of a type err in a short, human readable way. This is meant to be placed\n /// in parentheses after some larger message. You should also invoke `note_and_explain_type_err()`\n /// afterwards to present additional details, particularly when it comes to lifetime-related\n@@ -4692,6 +4837,16 @@ pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n                     if values.expected { \"converging\" } else { \"diverging\" },\n                     if values.found { \"converging\" } else { \"diverging\" })\n         }\n+        terr_projection_name_mismatched(ref values) => {\n+            format!(\"expected {}, found {}\",\n+                    token::get_name(values.expected),\n+                    token::get_name(values.found))\n+        }\n+        terr_projection_bounds_length(ref values) => {\n+            format!(\"expected {} associated type bindings, found {}\",\n+                    values.expected,\n+                    values.found)\n+        }\n     }\n }\n \n@@ -4952,7 +5107,7 @@ pub fn try_add_builtin_trait(\n pub fn ty_to_def_id(ty: Ty) -> Option<ast::DefId> {\n     match ty.sty {\n         ty_trait(ref tt) =>\n-            Some(tt.principal.def_id()),\n+            Some(tt.principal_def_id()),\n         ty_struct(id, _) |\n         ty_enum(id, _) |\n         ty_unboxed_closure(id, _, _) =>\n@@ -5193,7 +5348,7 @@ pub fn enum_variant_with_id<'tcx>(cx: &ctxt<'tcx>,\n // the type cache. Returns the type parameters and type.\n pub fn lookup_item_type<'tcx>(cx: &ctxt<'tcx>,\n                               did: ast::DefId)\n-                              -> Polytype<'tcx> {\n+                              -> TypeScheme<'tcx> {\n     lookup_locally_or_in_crate_store(\n         \"tcache\", did, &mut *cx.tcache.borrow_mut(),\n         || csearch::get_type(cx, did))\n@@ -5209,7 +5364,12 @@ pub fn lookup_trait_def<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n }\n \n /// Given a reference to a trait, returns the \"superbounds\" declared\n-/// on the trait, with appropriate substitutions applied.\n+/// on the trait, with appropriate substitutions applied. Basically,\n+/// this applies a filter to the where clauses on the trait, returning\n+/// those that have the form:\n+///\n+///     Self : SuperTrait<...>\n+///     Self : 'region\n pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n                                       trait_ref: &PolyTraitRef<'tcx>)\n                                       -> Vec<ty::Predicate<'tcx>>\n@@ -5286,13 +5446,7 @@ pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n     let trait_bounds: Vec<_> =\n         trait_def.bounds.trait_bounds\n         .iter()\n-        .map(|bound_trait_ref| {\n-            let substs = tcx.mk_substs(bound_trait_ref.substs().subst(tcx, trait_ref.substs()));\n-            ty::Binder(\n-                ty::TraitRef::new(bound_trait_ref.def_id(),\n-                                  substs))\n-        })\n-        .map(|bound_trait_ref| Rc::new(bound_trait_ref))\n+        .map(|poly_trait_ref| ty::Binder(poly_trait_ref.0.subst(tcx, trait_ref.substs())))\n         .collect();\n \n     debug!(\"bounds_for_trait_ref: trait_bounds={}\",\n@@ -5309,6 +5463,11 @@ pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n         trait_bounds: trait_bounds,\n         region_bounds: region_bounds,\n         builtin_bounds: builtin_bounds,\n+\n+        // FIXME(#19451) -- if a trait has a bound like `trait Foo :\n+        // Bar<T=X>`, we should probably be returning that, but this\n+        // code here will just ignore it.\n+        projection_bounds: Vec::new(),\n     };\n \n     predicates(tcx, trait_ref.self_ty(), &bounds)\n@@ -5323,7 +5482,7 @@ pub fn predicates<'tcx>(\n     let mut vec = Vec::new();\n \n     for builtin_bound in bounds.builtin_bounds.iter() {\n-        match traits::poly_trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty) {\n+        match traits::trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty) {\n             Ok(trait_ref) => { vec.push(trait_ref.as_predicate()); }\n             Err(ErrorReported) => { }\n         }\n@@ -5340,6 +5499,10 @@ pub fn predicates<'tcx>(\n         vec.push(bound_trait_ref.as_predicate());\n     }\n \n+    for projection in bounds.projection_bounds.iter() {\n+        vec.push(projection.as_predicate());\n+    }\n+\n     vec\n }\n \n@@ -5675,10 +5838,10 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n // relation on the supertraits from each bounded trait's constraint\n // list.\n pub fn each_bound_trait_and_supertraits<'tcx, F>(tcx: &ctxt<'tcx>,\n-                                                 bounds: &[Rc<PolyTraitRef<'tcx>>],\n+                                                 bounds: &[PolyTraitRef<'tcx>],\n                                                  mut f: F)\n                                                  -> bool where\n-    F: FnMut(Rc<PolyTraitRef<'tcx>>) -> bool,\n+    F: FnMut(PolyTraitRef<'tcx>) -> bool,\n {\n     for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n         if !f(bound_trait_ref) {\n@@ -5688,25 +5851,29 @@ pub fn each_bound_trait_and_supertraits<'tcx, F>(tcx: &ctxt<'tcx>,\n     return true;\n }\n \n-pub fn object_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n-                                  opt_principal: Option<&PolyTraitRef<'tcx>>, // None for closures\n-                                  others: BuiltinBounds)\n-                                  -> Vec<ty::Region>\n+pub fn object_region_bounds<'tcx>(\n+    tcx: &ctxt<'tcx>,\n+    opt_principal: Option<&PolyTraitRef<'tcx>>, // None for closures\n+    others: BuiltinBounds)\n+    -> Vec<ty::Region>\n {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically\n     // a skolemized type.\n     let open_ty = ty::mk_infer(tcx, FreshTy(0));\n \n     let opt_trait_ref = opt_principal.map_or(Vec::new(), |principal| {\n-        let substs = principal.substs().with_self_ty(open_ty);\n-        vec!(Rc::new(ty::Binder(ty::TraitRef::new(principal.def_id(), tcx.mk_substs(substs)))))\n+        // Note that we preserve the overall binding levels here.\n+        assert!(!open_ty.has_escaping_regions());\n+        let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n+        vec!(ty::Binder(Rc::new(ty::TraitRef::new(principal.0.def_id, substs))))\n     });\n \n     let param_bounds = ty::ParamBounds {\n         region_bounds: Vec::new(),\n         builtin_bounds: others,\n         trait_bounds: opt_trait_ref,\n+        projection_bounds: Vec::new(), // not relevant to computing region bounds\n     };\n \n     let predicates = ty::predicates(tcx, open_ty, &param_bounds);\n@@ -5737,6 +5904,7 @@ pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|predicate| {\n             match predicate {\n+                ty::Predicate::Projection(..) |\n                 ty::Predicate::Trait(..) |\n                 ty::Predicate::Equate(..) |\n                 ty::Predicate::RegionOutlives(..) => {\n@@ -6088,12 +6256,12 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n \n                     return false;\n                 }\n-                ty_trait(box TyTrait { ref principal, bounds }) => {\n+                ty_trait(ref data) => {\n                     byte!(17);\n-                    did(state, principal.def_id());\n-                    hash!(bounds);\n+                    did(state, data.principal_def_id());\n+                    hash!(data.bounds);\n \n-                    let principal = anonymize_late_bound_regions(tcx, principal);\n+                    let principal = anonymize_late_bound_regions(tcx, &data.principal);\n                     for subty in principal.substs.types.iter() {\n                         helper(tcx, *subty, svh, state);\n                     }\n@@ -6110,8 +6278,9 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                 }\n                 ty_param(p) => {\n                     byte!(20);\n+                    hash!(p.space);\n                     hash!(p.idx);\n-                    did(state, p.def_id);\n+                    hash!(token::get_name(p.name));\n                 }\n                 ty_open(_) => byte!(22),\n                 ty_infer(_) => unreachable!(),\n@@ -6121,6 +6290,11 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                     did(state, d);\n                     region(state, *r);\n                 }\n+                ty_projection(ref data) => {\n+                    byte!(25);\n+                    did(state, data.trait_ref.def_id);\n+                    hash!(token::get_name(data.item_name));\n+                }\n             }\n             true\n         });\n@@ -6161,17 +6335,11 @@ pub fn construct_parameter_environment<'tcx>(\n \n     // map T => T\n     let mut types = VecPerParamSpace::empty();\n-    for &space in subst::ParamSpace::all().iter() {\n-        push_types_from_defs(tcx, &mut types, space,\n-                             generics.types.get_slice(space));\n-    }\n+    push_types_from_defs(tcx, &mut types, generics.types.as_slice());\n \n     // map bound 'a => free 'a\n     let mut regions = VecPerParamSpace::empty();\n-    for &space in subst::ParamSpace::all().iter() {\n-        push_region_params(&mut regions, space, free_id,\n-                           generics.regions.get_slice(space));\n-    }\n+    push_region_params(&mut regions, free_id, generics.regions.as_slice());\n \n     let free_substs = Substs {\n         types: types,\n@@ -6208,27 +6376,22 @@ pub fn construct_parameter_environment<'tcx>(\n     };\n \n     fn push_region_params(regions: &mut VecPerParamSpace<ty::Region>,\n-                          space: subst::ParamSpace,\n                           free_id: ast::NodeId,\n                           region_params: &[RegionParameterDef])\n     {\n         for r in region_params.iter() {\n-            regions.push(space, ty::free_region_from_def(free_id, r));\n+            regions.push(r.space, ty::free_region_from_def(free_id, r));\n         }\n     }\n \n     fn push_types_from_defs<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   types: &mut subst::VecPerParamSpace<Ty<'tcx>>,\n-                                  space: subst::ParamSpace,\n                                   defs: &[TypeParameterDef<'tcx>]) {\n-        for (i, def) in defs.iter().enumerate() {\n-            debug!(\"construct_parameter_environment(): push_types_from_defs: \\\n-                    space={} def={} index={}\",\n-                   space,\n-                   def.repr(tcx),\n-                   i);\n-            let ty = ty::mk_param(tcx, space, i as u32, def.def_id);\n-            types.push(space, ty);\n+        for def in defs.iter() {\n+            debug!(\"construct_parameter_environment(): push_types_from_defs: def={}\",\n+                   def.repr(tcx));\n+            let ty = ty::mk_param_from_def(tcx, def);\n+            types.push(def.space, ty);\n         }\n     }\n \n@@ -6237,7 +6400,10 @@ pub fn construct_parameter_environment<'tcx>(\n \n         for predicate in bounds.predicates.iter() {\n             match *predicate {\n-                Predicate::Trait(..) | Predicate::Equate(..) | Predicate::TypeOutlives(..) => {\n+                Predicate::Projection(..) |\n+                Predicate::Trait(..) |\n+                Predicate::Equate(..) |\n+                Predicate::TypeOutlives(..) => {\n                     // No region bounds here\n                 }\n                 Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {\n@@ -6364,7 +6530,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n                 accumulator.push(*region)\n             }\n             ty_trait(ref t) => {\n-                accumulator.push_all(t.principal.substs().regions().as_slice());\n+                accumulator.push_all(t.principal.0.substs.regions().as_slice());\n             }\n             ty_enum(_, substs) |\n             ty_struct(_, substs) => {\n@@ -6391,6 +6557,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             ty_ptr(_) |\n             ty_bare_fn(..) |\n             ty_tup(_) |\n+            ty_projection(_) |\n             ty_param(_) |\n             ty_infer(_) |\n             ty_open(_) |\n@@ -6481,6 +6648,15 @@ pub fn count_late_bound_regions<'tcx, T>(\n     skol_map.len()\n }\n \n+pub fn binds_late_bound_regions<'tcx, T>(\n+    tcx: &ty::ctxt<'tcx>,\n+    value: &Binder<T>)\n+    -> bool\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+{\n+    count_late_bound_regions(tcx, value) > 0\n+}\n+\n /// Replace any late-bound regions bound in `value` with `'static`. Useful in trans but also\n /// method lookup and a few other places where precise region relationships are not required.\n pub fn erase_late_bound_regions<'tcx, T>(\n@@ -6621,9 +6797,10 @@ impl<'tcx> Repr<'tcx> for ty::Predicate<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match *self {\n             Predicate::Trait(ref a) => a.repr(tcx),\n-            Predicate::Equate(ref pair) => format!(\"Equate({})\", pair.repr(tcx)),\n-            Predicate::RegionOutlives(ref pair) => format!(\"Outlives({})\", pair.repr(tcx)),\n-            Predicate::TypeOutlives(ref pair) => format!(\"Outlives({})\", pair.repr(tcx)),\n+            Predicate::Equate(ref pair) => pair.repr(tcx),\n+            Predicate::RegionOutlives(ref pair) => pair.repr(tcx),\n+            Predicate::TypeOutlives(ref pair) => pair.repr(tcx),\n+            Predicate::Projection(ref pair) => pair.repr(tcx),\n         }\n     }\n }\n@@ -6719,6 +6896,11 @@ pub fn can_type_implement_copy<'tcx>(tcx: &ctxt<'tcx>,\n     Ok(())\n }\n \n+// FIXME(#20298) -- all of these types basically walk various\n+// structures to test whether types/regions are reachable with various\n+// properties. It should be possible to express them in terms of one\n+// common \"walker\" trait or something.\n+\n pub trait RegionEscape {\n     fn has_escaping_regions(&self) -> bool {\n         self.has_regions_escaping_depth(0)\n@@ -6741,8 +6923,19 @@ impl RegionEscape for Region {\n \n impl<'tcx> RegionEscape for TraitRef<'tcx> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.substs.types.iter().any(|t| t.has_regions_escaping_depth(depth)) &&\n-            self.substs.regions().iter().any(|t| t.has_regions_escaping_depth(depth))\n+        self.substs.types.iter().any(|t| t.has_regions_escaping_depth(depth)) ||\n+            self.substs.regions.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for subst::RegionSubsts {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        match *self {\n+            subst::ErasedRegions => false,\n+            subst::NonerasedRegions(ref r) => {\n+                r.iter().any(|t| t.has_regions_escaping_depth(depth))\n+            }\n+        }\n     }\n }\n \n@@ -6758,8 +6951,239 @@ impl<'tcx> RegionEscape for EquatePredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> RegionEscape for TraitPredicate<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.trait_ref.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n impl<T:RegionEscape,U:RegionEscape> RegionEscape for OutlivesPredicate<T,U> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.0.has_regions_escaping_depth(depth) || self.1.has_regions_escaping_depth(depth)\n     }\n }\n+\n+impl<'tcx> RegionEscape for ProjectionPredicate<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.projection_ty.has_regions_escaping_depth(depth) ||\n+            self.ty.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ProjectionTy<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.trait_ref.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"ProjectionPredicate({}, {})\",\n+                self.projection_ty.repr(tcx),\n+                self.ty.repr(tcx))\n+    }\n+}\n+\n+pub trait HasProjectionTypes {\n+    fn has_projection_types(&self) -> bool;\n+}\n+\n+impl<'tcx> HasProjectionTypes for ty::GenericBounds<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.predicates.iter().any(|p| p.has_projection_types())\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for Predicate<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        match *self {\n+            Predicate::Trait(ref data) => data.has_projection_types(),\n+            Predicate::Equate(ref data) => data.has_projection_types(),\n+            Predicate::RegionOutlives(ref data) => data.has_projection_types(),\n+            Predicate::TypeOutlives(ref data) => data.has_projection_types(),\n+            Predicate::Projection(ref data) => data.has_projection_types(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for TraitPredicate<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.trait_ref.has_projection_types()\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for EquatePredicate<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.0.has_projection_types() || self.1.has_projection_types()\n+    }\n+}\n+\n+impl HasProjectionTypes for Region {\n+    fn has_projection_types(&self) -> bool {\n+        false\n+    }\n+}\n+\n+impl<T:HasProjectionTypes,U:HasProjectionTypes> HasProjectionTypes for OutlivesPredicate<T,U> {\n+    fn has_projection_types(&self) -> bool {\n+        self.0.has_projection_types() || self.1.has_projection_types()\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for ProjectionPredicate<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.projection_ty.has_projection_types() || self.ty.has_projection_types()\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for ProjectionTy<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.trait_ref.has_projection_types()\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for Ty<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        ty::type_has_projection(*self)\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for TraitRef<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.substs.has_projection_types()\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for subst::Substs<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.types.iter().any(|t| t.has_projection_types())\n+    }\n+}\n+\n+impl<'tcx,T> HasProjectionTypes for Option<T>\n+    where T : HasProjectionTypes\n+{\n+    fn has_projection_types(&self) -> bool {\n+        self.iter().any(|t| t.has_projection_types())\n+    }\n+}\n+\n+impl<'tcx,T> HasProjectionTypes for Rc<T>\n+    where T : HasProjectionTypes\n+{\n+    fn has_projection_types(&self) -> bool {\n+        (**self).has_projection_types()\n+    }\n+}\n+\n+impl<'tcx,T> HasProjectionTypes for Box<T>\n+    where T : HasProjectionTypes\n+{\n+    fn has_projection_types(&self) -> bool {\n+        (**self).has_projection_types()\n+    }\n+}\n+\n+impl<T> HasProjectionTypes for Binder<T>\n+    where T : HasProjectionTypes\n+{\n+    fn has_projection_types(&self) -> bool {\n+        self.0.has_projection_types()\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for FnOutput<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        match *self {\n+            FnConverging(t) => t.has_projection_types(),\n+            FnDiverging => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for FnSig<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.inputs.iter().any(|t| t.has_projection_types()) ||\n+            self.output.has_projection_types()\n+    }\n+}\n+\n+impl<'tcx> HasProjectionTypes for BareFnTy<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.sig.has_projection_types()\n+    }\n+}\n+\n+pub trait ReferencesError {\n+    fn references_error(&self) -> bool;\n+}\n+\n+impl<T:ReferencesError> ReferencesError for Binder<T> {\n+    fn references_error(&self) -> bool {\n+        self.0.references_error()\n+    }\n+}\n+\n+impl<T:ReferencesError> ReferencesError for Rc<T> {\n+    fn references_error(&self) -> bool {\n+        (&*self).references_error()\n+    }\n+}\n+\n+impl<'tcx> ReferencesError for TraitPredicate<'tcx> {\n+    fn references_error(&self) -> bool {\n+        self.trait_ref.references_error()\n+    }\n+}\n+\n+impl<'tcx> ReferencesError for ProjectionPredicate<'tcx> {\n+    fn references_error(&self) -> bool {\n+        self.projection_ty.trait_ref.references_error() || self.ty.references_error()\n+    }\n+}\n+\n+impl<'tcx> ReferencesError for TraitRef<'tcx> {\n+    fn references_error(&self) -> bool {\n+        self.input_types().iter().any(|t| t.references_error())\n+    }\n+}\n+\n+impl<'tcx> ReferencesError for Ty<'tcx> {\n+    fn references_error(&self) -> bool {\n+        type_is_error(*self)\n+    }\n+}\n+\n+impl<'tcx> ReferencesError for Predicate<'tcx> {\n+    fn references_error(&self) -> bool {\n+        match *self {\n+            Predicate::Trait(ref data) => data.references_error(),\n+            Predicate::Equate(ref data) => data.references_error(),\n+            Predicate::RegionOutlives(ref data) => data.references_error(),\n+            Predicate::TypeOutlives(ref data) => data.references_error(),\n+            Predicate::Projection(ref data) => data.references_error(),\n+        }\n+    }\n+}\n+\n+impl<A,B> ReferencesError for OutlivesPredicate<A,B>\n+    where A : ReferencesError, B : ReferencesError\n+{\n+    fn references_error(&self) -> bool {\n+        self.0.references_error() || self.1.references_error()\n+    }\n+}\n+\n+impl<'tcx> ReferencesError for EquatePredicate<'tcx>\n+{\n+    fn references_error(&self) -> bool {\n+        self.0.references_error() || self.1.references_error()\n+    }\n+}\n+\n+impl ReferencesError for Region\n+{\n+    fn references_error(&self) -> bool {\n+        false\n+    }\n+}"}, {"sha": "1e7605c0f171c44b8b42fd779b635b92cb7f67f9", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 56, "deletions": 23, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -121,8 +121,8 @@ pub trait TypeFolder<'tcx> {\n         super_fold_trait_store(self, s)\n     }\n \n-    fn fold_existential_bounds(&mut self, s: ty::ExistentialBounds)\n-                               -> ty::ExistentialBounds {\n+    fn fold_existential_bounds(&mut self, s: &ty::ExistentialBounds<'tcx>)\n+                               -> ty::ExistentialBounds<'tcx> {\n         super_fold_existential_bounds(self, s)\n     }\n \n@@ -170,6 +170,13 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n     }\n }\n \n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Box<T> {\n+        let content: T = (**self).fold_with(folder);\n+        box content\n+    }\n+}\n+\n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Vec<T> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n@@ -342,9 +349,9 @@ impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ExistentialBounds {\n-        folder.fold_existential_bounds(*self)\n+impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ExistentialBounds<'tcx> {\n+        folder.fold_existential_bounds(self)\n     }\n }\n \n@@ -354,6 +361,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ParamBounds<'tcx> {\n             region_bounds: self.region_bounds.fold_with(folder),\n             builtin_bounds: self.builtin_bounds.fold_with(folder),\n             trait_bounds: self.trait_bounds.fold_with(folder),\n+            projection_bounds: self.projection_bounds.fold_with(folder),\n         }\n     }\n }\n@@ -365,7 +373,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n             def_id: self.def_id,\n             space: self.space,\n             index: self.index,\n-            associated_with: self.associated_with,\n             bounds: self.bounds.fold_with(folder),\n             default: self.default.fold_with(folder),\n         }\n@@ -405,6 +412,26 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n                 ty::Predicate::RegionOutlives(binder.fold_with(folder)),\n             ty::Predicate::TypeOutlives(ref binder) =>\n                 ty::Predicate::TypeOutlives(binder.fold_with(folder)),\n+            ty::Predicate::Projection(ref binder) =>\n+                ty::Predicate::Projection(binder.fold_with(folder)),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ProjectionPredicate<'tcx> {\n+        ty::ProjectionPredicate {\n+            projection_ty: self.projection_ty.fold_with(folder),\n+            ty: self.ty.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ProjectionTy<'tcx> {\n+        ty::ProjectionTy {\n+            trait_ref: self.trait_ref.fold_with(folder),\n+            item_name: self.item_name,\n         }\n     }\n }\n@@ -422,7 +449,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::UnsizeKind<'tcx> {\n         match *self {\n             ty::UnsizeLength(len) => ty::UnsizeLength(len),\n             ty::UnsizeStruct(box ref k, n) => ty::UnsizeStruct(box k.fold_with(folder), n),\n-            ty::UnsizeVtable(ty::TyTrait{ref principal, bounds}, self_ty) => {\n+            ty::UnsizeVtable(ty::TyTrait{ref principal, ref bounds}, self_ty) => {\n                 ty::UnsizeVtable(\n                     ty::TyTrait {\n                         principal: principal.fold_with(folder),\n@@ -441,7 +468,7 @@ impl<'tcx,O> TypeFoldable<'tcx> for traits::Obligation<'tcx,O>\n         traits::Obligation {\n             cause: self.cause.clone(),\n             recursion_depth: self.recursion_depth,\n-            trait_ref: self.trait_ref.fold_with(folder),\n+            predicate: self.predicate.fold_with(folder),\n         }\n     }\n }\n@@ -474,27 +501,27 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n             traits::VtableFnPointer(ref d) => {\n                 traits::VtableFnPointer(d.fold_with(folder))\n             }\n-            traits::VtableParam(ref p) => traits::VtableParam(p.fold_with(folder)),\n+            traits::VtableParam => traits::VtableParam,\n             traits::VtableBuiltin(ref d) => traits::VtableBuiltin(d.fold_with(folder)),\n         }\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for traits::VtableParamData<'tcx> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableParamData<'tcx> {\n-        traits::VtableParamData {\n-            bound: self.bound.fold_with(folder),\n-        }\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::EquatePredicate<'tcx> {\n         ty::EquatePredicate(self.0.fold_with(folder),\n                             self.1.fold_with(folder))\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::TraitPredicate<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitPredicate<'tcx> {\n+        ty::TraitPredicate {\n+            trait_ref: self.trait_ref.fold_with(folder)\n+        }\n+    }\n+}\n+\n impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n     where T : TypeFoldable<'tcx>,\n           U : TypeFoldable<'tcx>,\n@@ -530,9 +557,9 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             let substs = substs.fold_with(this);\n             ty::ty_enum(tid, this.tcx().mk_substs(substs))\n         }\n-        ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n+        ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n             ty::ty_trait(box ty::TyTrait {\n-                principal: (*principal).fold_with(this),\n+                principal: principal.fold_with(this),\n                 bounds: bounds.fold_with(this),\n             })\n         }\n@@ -544,7 +571,7 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             ty::ty_bare_fn(opt_def_id, this.tcx().mk_bare_fn(bfn))\n         }\n         ty::ty_closure(ref f) => {\n-            ty::ty_closure(box f.fold_with(this))\n+            ty::ty_closure(f.fold_with(this))\n         }\n         ty::ty_rptr(r, ref tm) => {\n             let r = r.fold_with(this);\n@@ -559,6 +586,9 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             let s = substs.fold_with(this);\n             ty::ty_unboxed_closure(did, this.tcx().mk_region(r), this.tcx().mk_substs(s))\n         }\n+        ty::ty_projection(ref data) => {\n+            ty::ty_projection(data.fold_with(this))\n+        }\n         ty::ty_bool | ty::ty_char | ty::ty_str |\n         ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n         ty::ty_err | ty::ty_infer(_) |\n@@ -655,12 +685,15 @@ pub fn super_fold_trait_store<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n     }\n }\n \n-pub fn super_fold_existential_bounds<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                                bounds: ty::ExistentialBounds)\n-                                                                -> ty::ExistentialBounds {\n+pub fn super_fold_existential_bounds<'tcx, T: TypeFolder<'tcx>>(\n+    this: &mut T,\n+    bounds: &ty::ExistentialBounds<'tcx>)\n+    -> ty::ExistentialBounds<'tcx>\n+{\n     ty::ExistentialBounds {\n         region_bound: bounds.region_bound.fold_with(this),\n         builtin_bounds: bounds.builtin_bounds,\n+        projection_bounds: bounds.projection_bounds.fold_with(this),\n     }\n }\n "}, {"sha": "9639af5ca1cd53ec49789ac81ed9f31d5fd64d6e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 58, "deletions": 24, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -448,6 +448,12 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                     bound_sep,\n                     bound_str)\n         }\n+        ty::ty_projection(ref data) => {\n+            format!(\"<{} as {}>::{}\",\n+                    data.trait_ref.self_ty().user_string(cx),\n+                    data.trait_ref.user_string(cx),\n+                    data.item_name.user_string(cx))\n+        }\n         ty_str => \"str\".to_string(),\n         ty_unboxed_closure(ref did, _, substs) => {\n             let unboxed_closures = cx.unboxed_closures.borrow();\n@@ -695,10 +701,9 @@ impl<'tcx> Repr<'tcx> for subst::Substs<'tcx> {\n \n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for subst::VecPerParamSpace<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"[{};{};{};{}]\",\n+        format!(\"[{};{};{}]\",\n                 self.get_slice(subst::TypeSpace).repr(tcx),\n                 self.get_slice(subst::SelfSpace).repr(tcx),\n-                self.get_slice(subst::AssocSpace).repr(tcx),\n                 self.get_slice(subst::FnSpace).repr(tcx))\n     }\n }\n@@ -733,8 +738,8 @@ impl<'tcx> Repr<'tcx> for ty::BuiltinBounds {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ExistentialBounds {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::ExistentialBounds<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         self.user_string(tcx)\n     }\n }\n@@ -929,9 +934,9 @@ impl<'tcx> Repr<'tcx> for ast::DefId {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::Polytype<'tcx> {\n+impl<'tcx> Repr<'tcx> for ty::TypeScheme<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"Polytype {{generics: {}, ty: {}}}\",\n+        format!(\"TypeScheme {{generics: {}, ty: {}}}\",\n                 self.generics.repr(tcx),\n                 self.ty.repr(tcx))\n     }\n@@ -1136,8 +1141,8 @@ impl<'tcx> UserString<'tcx> for ty::ParamBounds<'tcx> {\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::ExistentialBounds {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n+impl<'tcx> UserString<'tcx> for ty::ExistentialBounds<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         if self.builtin_bounds.contains(&ty::BoundSend) &&\n             self.region_bound == ty::ReStatic\n         { // Region bound is implied by builtin bounds:\n@@ -1322,17 +1327,8 @@ impl<'tcx> Repr<'tcx> for ty::ExplicitSelfCategory {\n }\n \n impl<'tcx> UserString<'tcx> for ParamTy {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n-        let id = self.idx;\n-        let did = self.def_id;\n-        let ident = match tcx.ty_param_defs.borrow().get(&did.node) {\n-            Some(def) => token::get_name(def.name).get().to_string(),\n-\n-            // This can only happen when a type mismatch error happens and\n-            // the actual type has more type parameters than the expected one.\n-            None => format!(\"<generic #{}>\", id),\n-        };\n-        ident\n+    fn user_string(&self, _tcx: &ctxt) -> String {\n+        format!(\"{}\", token::get_name(self.name))\n     }\n }\n \n@@ -1408,17 +1404,55 @@ impl<'tcx> UserString<'tcx> for ty::EquatePredicate<'tcx> {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for ty::TraitPredicate<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"TraitPredicate({})\",\n+                self.trait_ref.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for ty::TraitPredicate<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"{} : {}\",\n+                self.trait_ref.self_ty().user_string(tcx),\n+                self.trait_ref.user_string(tcx))\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"{} == {}\",\n+                self.projection_ty.user_string(tcx),\n+                self.ty.user_string(tcx))\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ty::ProjectionTy<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"<{} as {}>::{}\",\n+                self.trait_ref.self_ty().repr(tcx),\n+                self.trait_ref.repr(tcx),\n+                self.item_name.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for ty::ProjectionTy<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"<{} as {}>::{}\",\n+                self.trait_ref.self_ty().user_string(tcx),\n+                self.trait_ref.user_string(tcx),\n+                self.item_name.user_string(tcx))\n+    }\n+}\n+\n impl<'tcx> UserString<'tcx> for ty::Predicate<'tcx> {\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         match *self {\n-            ty::Predicate::Trait(ref trait_ref) => {\n-                format!(\"{} : {}\",\n-                        trait_ref.self_ty().user_string(tcx),\n-                        trait_ref.user_string(tcx))\n-            }\n+            ty::Predicate::Trait(ref data) => data.user_string(tcx),\n             ty::Predicate::Equate(ref predicate) => predicate.user_string(tcx),\n             ty::Predicate::RegionOutlives(ref predicate) => predicate.user_string(tcx),\n             ty::Predicate::TypeOutlives(ref predicate) => predicate.user_string(tcx),\n+            ty::Predicate::Projection(ref predicate) => predicate.user_string(tcx),\n         }\n     }\n }"}, {"sha": "2062685f4c86698ba35f230765b6e332389580c2", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -210,7 +210,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     {\n         let mut euv = euv::ExprUseVisitor::new(&mut clcx,\n                                                bccx.tcx,\n-                                               param_env.clone());\n+                                               &param_env);\n         euv.walk_fn(decl, body);\n     }\n }"}, {"sha": "7854c8acb4796a145fc36e498dab3b587a899bfd", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -53,7 +53,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     {\n         let mut euv = euv::ExprUseVisitor::new(&mut glcx,\n                                                bccx.tcx,\n-                                               param_env);\n+                                               &param_env);\n         euv.walk_fn(decl, body);\n     }\n "}, {"sha": "6329acfb57805c5372a30eeed9dfd99199c76ada", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 57, "deletions": 46, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -28,7 +28,7 @@ use rustc_typeck::middle::infer::glb::Glb;\n use rustc_typeck::middle::infer::sub::Sub;\n use rustc_typeck::util::ppaux::{ty_to_string, Repr, UserString};\n use rustc::session::{mod,config};\n-use syntax::{abi, ast, ast_map, ast_util};\n+use syntax::{abi, ast, ast_map};\n use syntax::codemap;\n use syntax::codemap::{Span, CodeMap, DUMMY_SP};\n use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note, Help};\n@@ -145,6 +145,10 @@ fn test_env<F>(source_string: &str,\n }\n \n impl<'a, 'tcx> Env<'a, 'tcx> {\n+    pub fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n     pub fn create_region_hierarchy(&self, rh: &RH) {\n         for child_rh in rh.sub.iter() {\n             self.create_region_hierarchy(child_rh);\n@@ -296,7 +300,8 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn t_param(&self, space: subst::ParamSpace, index: u32) -> Ty<'tcx> {\n-        ty::mk_param(self.infcx.tcx, space, index, ast_util::local_def(ast::DUMMY_NODE_ID))\n+        let name = format!(\"T{}\", index);\n+        ty::mk_param(self.infcx.tcx, space, index, token::intern(name[]))\n     }\n \n     pub fn re_early_bound(&self,\n@@ -314,14 +319,16 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn t_rptr(&self, r: ty::Region) -> Ty<'tcx> {\n-        ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(r), ty::mk_int())\n+        ty::mk_imm_rptr(self.infcx.tcx,\n+                        self.infcx.tcx.mk_region(r),\n+                        self.tcx().types.int)\n     }\n \n     pub fn t_rptr_late_bound(&self, id: u32) -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, ty::DebruijnIndex::new(1));\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.infcx.tcx.mk_region(r),\n-                        ty::mk_int())\n+                        self.tcx().types.int)\n     }\n \n     pub fn t_rptr_late_bound_with_debruijn(&self,\n@@ -331,12 +338,13 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, debruijn);\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.infcx.tcx.mk_region(r),\n-                        ty::mk_int())\n+                        self.tcx().types.int)\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n         let r = ty::ReScope(CodeExtent::from_node_id(id));\n-        ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(r), ty::mk_int())\n+        ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(r),\n+                        self.tcx().types.int)\n     }\n \n     pub fn re_free(&self, nid: ast::NodeId, id: u32) -> ty::Region {\n@@ -346,15 +354,19 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn t_rptr_free(&self, nid: ast::NodeId, id: u32) -> Ty<'tcx> {\n         let r = self.re_free(nid, id);\n-        ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(r), ty::mk_int())\n+        ty::mk_imm_rptr(self.infcx.tcx,\n+                        self.infcx.tcx.mk_region(r),\n+                        self.tcx().types.int)\n     }\n \n     pub fn t_rptr_static(&self) -> Ty<'tcx> {\n-        ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(ty::ReStatic), ty::mk_int())\n+        ty::mk_imm_rptr(self.infcx.tcx,\n+                        self.infcx.tcx.mk_region(ty::ReStatic),\n+                        self.tcx().types.int)\n     }\n \n     pub fn dummy_type_trace(&self) -> infer::TypeTrace<'tcx> {\n-        infer::TypeTrace::dummy()\n+        infer::TypeTrace::dummy(self.tcx())\n     }\n \n     pub fn sub(&self) -> Sub<'a, 'tcx> {\n@@ -480,8 +492,8 @@ fn sub_free_bound_false() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        env.check_not_sub(env.t_fn(&[t_rptr_free1], ty::mk_int()),\n-                          env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+        env.check_not_sub(env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n+                          env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n     })\n }\n \n@@ -496,8 +508,8 @@ fn sub_bound_free_true() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_sub(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_free1], ty::mk_int()));\n+        env.check_sub(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.int));\n     })\n }\n \n@@ -512,8 +524,8 @@ fn sub_free_bound_false_infer() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_infer1 = env.infcx.next_ty_var();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        env.check_not_sub(env.t_fn(&[t_infer1], ty::mk_int()),\n-                          env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+        env.check_not_sub(env.t_fn(&[t_infer1], env.tcx().types.int),\n+                          env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n     })\n }\n \n@@ -531,9 +543,9 @@ fn lub_free_bound_infer() {\n         let t_infer1 = env.infcx.next_ty_var();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_lub(env.t_fn(&[t_infer1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_free1], ty::mk_int()));\n+        env.check_lub(env.t_fn(&[t_infer1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.int));\n     });\n }\n \n@@ -542,9 +554,9 @@ fn lub_bound_bound() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_bound2 = env.t_rptr_late_bound(2);\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_bound2], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_bound2], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n     })\n }\n \n@@ -553,9 +565,9 @@ fn lub_bound_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_free1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_free1], ty::mk_int()));\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.int));\n     })\n }\n \n@@ -564,9 +576,9 @@ fn lub_bound_static() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_static], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_static], ty::mk_int()));\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_static], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_static], env.tcx().types.int));\n     })\n }\n \n@@ -587,9 +599,9 @@ fn lub_free_free() {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_free2 = env.t_rptr_free(0, 2);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(&[t_rptr_free1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_free2], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_static], ty::mk_int()));\n+        env.check_lub(env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_free2], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_static], env.tcx().types.int));\n     })\n }\n \n@@ -612,9 +624,9 @@ fn glb_free_free_with_common_scope() {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_free2 = env.t_rptr_free(0, 2);\n         let t_rptr_scope = env.t_rptr_scope(0);\n-        env.check_glb(env.t_fn(&[t_rptr_free1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_free2], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_scope], ty::mk_int()));\n+        env.check_glb(env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_free2], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_scope], env.tcx().types.int));\n     })\n }\n \n@@ -623,9 +635,9 @@ fn glb_bound_bound() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_bound2 = env.t_rptr_late_bound(2);\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_bound2], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_bound2], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n     })\n }\n \n@@ -634,9 +646,9 @@ fn glb_bound_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_free1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n     })\n }\n \n@@ -648,9 +660,9 @@ fn glb_bound_free_infer() {\n \n         // compute GLB(fn(_) -> int, for<'b> fn(&'b int) -> int),\n         // which should yield for<'b> fn(&'b int) -> int\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_infer1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_infer1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n \n         // as a side-effect, computing GLB should unify `_` with\n         // `&'_ int`\n@@ -667,9 +679,9 @@ fn glb_bound_static() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_static], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_static], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n     })\n }\n \n@@ -790,7 +802,6 @@ fn escaping() {\n /// late-bound region.\n #[test]\n fn subst_region_renumber_region() {\n-\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let re_bound1 = env.re_late_bound_with_debruijn(1, ty::DebruijnIndex::new(1));\n "}, {"sha": "52bd096eb83dea2f5b45f0675d02a0ddae1ff6f2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -3906,7 +3906,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // If the def is a ty param, and came from the parent\n                             // item, it's ok\n                             match def {\n-                                DefTyParam(_, did, _) if {\n+                                DefTyParam(_, _, did, _) if {\n                                     self.def_map.borrow().get(&did.node).cloned()\n                                         == Some(DefTyParamBinder(item_id))\n                                 } => {} // ok\n@@ -3959,7 +3959,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // If the def is a ty param, and came from the parent\n                             // item, it's ok\n                             match def {\n-                                DefTyParam(_, did, _) if {\n+                                DefTyParam(_, _, did, _) if {\n                                     self.def_map.borrow().get(&did.node).cloned()\n                                         == Some(DefTyParamBinder(item_id))\n                                 } => {} // ok\n@@ -4265,8 +4265,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     seen_bindings.insert(name);\n \n                     let def_like = DlDef(DefTyParam(space,\n+                                                    index as u32,\n                                                     local_def(type_parameter.id),\n-                                                    index as u32));\n+                                                    name));\n                     // Associate this type parameter with\n                     // the item that bound it\n                     self.record_def(type_parameter.id,\n@@ -5161,7 +5162,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                           path.span) {\n                 Some((def, last_private)) => {\n                     match def {\n-                        DefTyParam(_, did, _) => {\n+                        DefTyParam(_, _, did, _) => {\n                             let def = DefAssociatedPath(TyParamProvenance::FromParam(did),\n                                                         path.segments.last()\n                                                             .unwrap().identifier);"}, {"sha": "0e37cd0f3b8d62cb1d275dd8d28fd48257272841", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -1122,7 +1122,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     let t = if kind == Compare {\n                         left_ty\n                     } else {\n-                        ty::mk_uint() // vector length\n+                        tcx.types.uint // vector length\n                     };\n                     let Result { bcx: after_cx, val: matches } = {\n                         match opt.trans(bcx) {\n@@ -1263,7 +1263,7 @@ fn is_discr_reassigned(bcx: Block, discr: &ast::Expr, body: &ast::Expr) -> bool\n     };\n     {\n         let param_env = ty::empty_parameter_environment();\n-        let mut visitor = euv::ExprUseVisitor::new(&mut rc, bcx, param_env);\n+        let mut visitor = euv::ExprUseVisitor::new(&mut rc, bcx, &param_env);\n         visitor.walk_expr(body);\n     }\n     rc.reassigned"}, {"sha": "d01047c53b955003e2482e254e7555d98702ca50", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -163,7 +163,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }).collect::<Vec<_>>();\n             let packed = ty::lookup_packed(cx.tcx(), def_id);\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n-            if dtor { ftys.push(ty::mk_bool()); }\n+            if dtor { ftys.push(cx.tcx().types.bool); }\n \n             Univariant(mk_struct(cx, ftys[], packed, t), dtor)\n         }\n@@ -183,7 +183,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // Uninhabitable; represent as unit\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n-                let ftys = if dtor { vec!(ty::mk_bool()) } else { vec!() };\n+                let ftys = if dtor { vec!(cx.tcx().types.bool) } else { vec!() };\n                 return Univariant(mk_struct(cx, ftys[], false, t),\n                                   dtor);\n             }\n@@ -215,7 +215,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n                 let mut ftys = cases[0].tys.clone();\n-                if dtor { ftys.push(ty::mk_bool()); }\n+                if dtor { ftys.push(cx.tcx().types.bool); }\n                 return Univariant(mk_struct(cx, ftys[], false, t),\n                                   dtor);\n             }\n@@ -261,9 +261,9 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // Create the set of structs that represent each variant\n             // Use the minimum integer type we figured out above\n             let fields : Vec<_> = cases.iter().map(|c| {\n-                let mut ftys = vec!(ty_of_inttype(min_ity));\n+                let mut ftys = vec!(ty_of_inttype(cx.tcx(), min_ity));\n                 ftys.push_all(c.tys.as_slice());\n-                if dtor { ftys.push(ty::mk_bool()); }\n+                if dtor { ftys.push(cx.tcx().types.bool); }\n                 mk_struct(cx, ftys.as_slice(), false, t)\n             }).collect();\n \n@@ -314,9 +314,9 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             };\n \n             let fields : Vec<_> = cases.iter().map(|c| {\n-                let mut ftys = vec!(ty_of_inttype(ity));\n+                let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n                 ftys.push_all(c.tys[]);\n-                if dtor { ftys.push(ty::mk_bool()); }\n+                if dtor { ftys.push(cx.tcx().types.bool); }\n                 mk_struct(cx, ftys[], false, t)\n             }).collect();\n \n@@ -343,7 +343,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                     mut path: DiscrField) -> Option<DiscrField> {\n     match ty.sty {\n         // Fat &T/&mut T/Box<T> i.e. T is [T], str, or Trait\n-        ty::ty_rptr(_, ty::mt { ty, .. }) | ty::ty_uniq(ty) if !ty::type_is_sized(tcx, ty) => {\n+        ty::ty_rptr(_, ty::mt { ty, .. }) | ty::ty_uniq(ty) if !type_is_sized(tcx, ty) => {\n             path.push(FAT_PTR_ADDR);\n             Some(path)\n         },\n@@ -447,12 +447,12 @@ fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                        tys: &[Ty<'tcx>], packed: bool,\n                        scapegoat: Ty<'tcx>)\n                        -> Struct<'tcx> {\n-    let sized = tys.iter().all(|&ty| ty::type_is_sized(cx.tcx(), ty));\n+    let sized = tys.iter().all(|&ty| type_is_sized(cx.tcx(), ty));\n     let lltys : Vec<Type> = if sized {\n         tys.iter()\n            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n-        tys.iter().filter(|&ty| ty::type_is_sized(cx.tcx(), *ty))\n+        tys.iter().filter(|&ty| type_is_sized(cx.tcx(), *ty))\n            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     };\n \n@@ -553,11 +553,10 @@ fn bounds_usable(cx: &CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n     }\n }\n \n-// FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n-pub fn ty_of_inttype<'tcx>(ity: IntType) -> Ty<'tcx> {\n+pub fn ty_of_inttype<'tcx>(tcx: &ty::ctxt<'tcx>, ity: IntType) -> Ty<'tcx> {\n     match ity {\n-        attr::SignedInt(t) => ty::mk_mach_int(t),\n-        attr::UnsignedInt(t) => ty::mk_mach_uint(t)\n+        attr::SignedInt(t) => ty::mk_mach_int(tcx, t),\n+        attr::UnsignedInt(t) => ty::mk_mach_uint(tcx, t)\n     }\n }\n \n@@ -704,7 +703,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, st: &Struct<'tcx>,\n                              sizing: bool, dst: bool) -> Vec<Type> {\n     if sizing {\n-        st.fields.iter().filter(|&ty| !dst || ty::type_is_sized(cx.tcx(), *ty))\n+        st.fields.iter().filter(|&ty| !dst || type_is_sized(cx.tcx(), *ty))\n             .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n         st.fields.iter().map(|&ty| type_of::type_of(cx, ty)).collect()\n@@ -995,8 +994,10 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n /// Access the struct drop flag, if present.\n pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>, val: ValueRef)\n-                                       -> datum::DatumBlock<'blk, 'tcx, datum::Expr> {\n-    let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), ty::mk_bool());\n+                                       -> datum::DatumBlock<'blk, 'tcx, datum::Expr>\n+{\n+    let tcx = bcx.tcx();\n+    let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), tcx.types.bool);\n     match *r {\n         Univariant(ref st, true) => {\n             let flag_ptr = GEPi(bcx, val, &[0, st.fields.len() - 1]);\n@@ -1006,7 +1007,7 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr<'tcx\n             let fcx = bcx.fcx;\n             let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n             let scratch = unpack_datum!(bcx, datum::lvalue_scratch_datum(\n-                bcx, ty::mk_bool(), \"drop_flag\", false,\n+                bcx, tcx.types.bool, \"drop_flag\", false,\n                 cleanup::CustomScope(custom_cleanup_scope), (), |_, bcx, _| bcx\n             ));\n             bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {"}, {"sha": "c5d3ad805d93428d013b93507efcc379de8c655c", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -281,6 +281,8 @@ pub fn kind_for_unboxed_closure(ccx: &CrateContext, closure_id: ast::DefId)\n \n pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n+    let fn_ty = monomorphize::normalize_associated_type(ccx.tcx(), &fn_ty);\n+\n     let (inputs, output, abi, env) = match fn_ty.sty {\n         ty::ty_bare_fn(_, ref f) => {\n             (f.sig.0.inputs.clone(), f.sig.0.output, f.abi, None)\n@@ -581,7 +583,7 @@ pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     match t.sty {\n         ty::ty_tup(ref tys) if tys.is_empty() => f(nil_type),\n         ty::ty_bool | ty::ty_uint(_) | ty::ty_char => f(unsigned_int),\n-        ty::ty_ptr(mt) if ty::type_is_sized(cx.tcx(), mt.ty) => f(unsigned_int),\n+        ty::ty_ptr(mt) if common::type_is_sized(cx.tcx(), mt.ty) => f(unsigned_int),\n         ty::ty_int(_) => f(signed_int),\n         ty::ty_float(_) => f(floating_point),\n             // Should never get here, because t is scalar.\n@@ -719,7 +721,7 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         return cx;\n     }\n \n-    let (data_ptr, info) = if ty::type_is_sized(cx.tcx(), t) {\n+    let (data_ptr, info) = if common::type_is_sized(cx.tcx(), t) {\n         (av, None)\n     } else {\n         let data = GEPi(cx, av, &[0, abi::FAT_PTR_ADDR]);\n@@ -736,7 +738,7 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                   let field_ty = field_ty.mt.ty;\n                   let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, discr, i);\n \n-                  let val = if ty::type_is_sized(cx.tcx(), field_ty) {\n+                  let val = if common::type_is_sized(cx.tcx(), field_ty) {\n                       llfld_a\n                   } else {\n                       let boxed_ty = ty::mk_open(cx.tcx(), field_ty);\n@@ -786,7 +788,7 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                     substs, f);\n               }\n               (_match::Switch, Some(lldiscrim_a)) => {\n-                  cx = f(cx, lldiscrim_a, ty::mk_int());\n+                  cx = f(cx, lldiscrim_a, cx.tcx().types.int);\n                   let unr_cx = fcx.new_temp_block(\"enum-iter-unr\");\n                   Unreachable(unr_cx);\n                   let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb,\n@@ -1453,7 +1455,8 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n \n     let uses_outptr = match output_type {\n         ty::FnConverging(output_type) => {\n-            let substd_output_type = output_type.subst(ccx.tcx(), param_substs);\n+            let substd_output_type =\n+                monomorphize::apply_param_substs(ccx.tcx(), param_substs, &output_type);\n             type_of::return_uses_outptr(ccx, substd_output_type)\n         }\n         ty::FnDiverging => false\n@@ -1512,7 +1515,7 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n     if let ty::FnConverging(output_type) = output {\n         // This shouldn't need to recompute the return type,\n         // as new_fn_ctxt did it already.\n-        let substd_output_type = output_type.subst(fcx.ccx.tcx(), fcx.param_substs);\n+        let substd_output_type = fcx.monomorphize(&output_type);\n         if !return_type_is_void(fcx.ccx, substd_output_type) {\n             // If the function returns nil/bot, there is no real return\n             // value, so do not set `llretslotptr`.\n@@ -1732,7 +1735,7 @@ pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n \n     // This shouldn't need to recompute the return type,\n     // as new_fn_ctxt did it already.\n-    let substd_retty = retty.subst(fcx.ccx.tcx(), fcx.param_substs);\n+    let substd_retty = fcx.monomorphize(&retty);\n     build_return_block(fcx, ret_cx, substd_retty);\n \n     debuginfo::clear_source_location(fcx);\n@@ -1765,7 +1768,7 @@ pub fn build_return_block<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n                 retptr.erase_from_parent();\n             }\n \n-            let retval = if retty == ty::FnConverging(ty::mk_bool()) {\n+            let retval = if retty == ty::FnConverging(fcx.ccx.tcx().types.bool) {\n                 Trunc(ret_cx, retval, Type::i1(fcx.ccx))\n             } else {\n                 retval\n@@ -2074,7 +2077,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n                                                      param_substs: &Substs<'tcx>,\n                                                      llfndecl: ValueRef) {\n     let ctor_ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n-    let ctor_ty = ctor_ty.subst(ccx.tcx(), param_substs);\n+    let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &ctor_ty);\n \n     let result_ty = match ctor_ty.sty {\n         ty::ty_bare_fn(_, ref bft) => bft.sig.0.output,\n@@ -2522,7 +2525,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n             match ret_ty.sty {\n                 // `~` pointer return values never alias because ownership\n                 // is transferred\n-                ty::ty_uniq(it) if !ty::type_is_sized(ccx.tcx(), it) => {}\n+                ty::ty_uniq(it) if !common::type_is_sized(ccx.tcx(), it) => {}\n                 ty::ty_uniq(_) => {\n                     attrs.ret(llvm::NoAliasAttribute);\n                 }\n@@ -2533,7 +2536,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n             match ret_ty.sty {\n                 // These are not really pointers but pairs, (pointer, len)\n                 ty::ty_uniq(it) |\n-                ty::ty_rptr(_, ty::mt { ty: it, .. }) if !ty::type_is_sized(ccx.tcx(), it) => {}\n+                ty::ty_rptr(_, ty::mt { ty: it, .. }) if !common::type_is_sized(ccx.tcx(), it) => {}\n                 ty::ty_uniq(inner) | ty::ty_rptr(_, ty::mt { ty: inner, .. }) => {\n                     let llret_sz = llsize_of_real(ccx, type_of::type_of(ccx, inner));\n                     attrs.ret(llvm::DereferenceableAttribute(llret_sz));\n@@ -2764,6 +2767,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     }\n \n     let item = ccx.tcx().map.get(id);\n+    debug!(\"get_item_val: id={} item={}\", id, item);\n     let val = match item {\n         ast_map::NodeItem(i) => {\n             let ty = ty::node_id_to_type(ccx.tcx(), i.id);"}, {"sha": "169e52bcfe5bef7e280477cb832d16a1f15b6ba3", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -514,8 +514,9 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n         return val;\n     }\n \n-    // Polytype of the function item (may have type params)\n-    let fn_tpt = ty::lookup_item_type(tcx, def_id);\n+    // Type scheme of the function item (may have type params)\n+    let fn_type_scheme = ty::lookup_item_type(tcx, def_id);\n+    let fn_type = monomorphize::normalize_associated_type(tcx, &fn_type_scheme.ty);\n \n     // Find the actual function pointer.\n     let mut val = {\n@@ -524,7 +525,7 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n             get_item_val(ccx, def_id.node)\n         } else {\n             // External reference.\n-            trans_external_path(ccx, def_id, fn_tpt.ty)\n+            trans_external_path(ccx, def_id, fn_type)\n         }\n     };\n \n@@ -551,7 +552,7 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n     // This can occur on either a crate-local or crate-external\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n-    let llty = type_of::type_of_fn_from_ty(ccx, fn_tpt.ty);\n+    let llty = type_of::type_of_fn_from_ty(ccx, fn_type);\n     let llptrty = llty.ptr_to();\n     if val_ty(val) != llptrty {\n         debug!(\"trans_fn_ref_with_vtables(): casting pointer!\");\n@@ -722,7 +723,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             };\n             if !is_rust_fn ||\n               type_of::return_uses_outptr(ccx, ret_ty) ||\n-              ty::type_needs_drop(bcx.tcx(), ret_ty) {\n+              type_needs_drop(bcx.tcx(), ret_ty) {\n                 // Push the out-pointer if we use an out-pointer for this\n                 // return type, otherwise push \"undef\".\n                 if type_is_zero_size(ccx, ret_ty) {"}, {"sha": "b4deea4c72fc812a12828e9fb934b98d72eb756d", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -279,10 +279,10 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n                          ty: Ty<'tcx>) {\n-        if !ty::type_needs_drop(self.ccx.tcx(), ty) { return; }\n+        if !common::type_needs_drop(self.ccx.tcx(), ty) { return; }\n         let drop = box DropValue {\n             is_immediate: false,\n-            must_unwind: ty::type_needs_unwind_cleanup(self.ccx.tcx(), ty),\n+            must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n             val: val,\n             ty: ty,\n             zero: false\n@@ -301,10 +301,10 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n                                   ty: Ty<'tcx>) {\n-        if !ty::type_needs_drop(self.ccx.tcx(), ty) { return; }\n+        if !common::type_needs_drop(self.ccx.tcx(), ty) { return; }\n         let drop = box DropValue {\n             is_immediate: false,\n-            must_unwind: ty::type_needs_unwind_cleanup(self.ccx.tcx(), ty),\n+            must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n             val: val,\n             ty: ty,\n             zero: true\n@@ -325,10 +325,10 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                                val: ValueRef,\n                                ty: Ty<'tcx>) {\n \n-        if !ty::type_needs_drop(self.ccx.tcx(), ty) { return; }\n+        if !common::type_needs_drop(self.ccx.tcx(), ty) { return; }\n         let drop = box DropValue {\n             is_immediate: true,\n-            must_unwind: ty::type_needs_unwind_cleanup(self.ccx.tcx(), ty),\n+            must_unwind: common::type_needs_unwind_cleanup(self.ccx, ty),\n             val: val,\n             ty: ty,\n             zero: false\n@@ -736,7 +736,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                         let f = base::decl_cdecl_fn(self.ccx,\n                                                     \"rust_eh_personality\",\n                                                     fty,\n-                                                    ty::mk_i32());\n+                                                    self.ccx.tcx().types.i32);\n                         *personality = Some(f);\n                         f\n                     }"}, {"sha": "ed3c820f2faf4e999d10ba3417dce30cc6f05522", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -133,8 +133,8 @@ pub fn mk_closure_tys<'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n \n fn tuplify_box_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n-    let ptr = ty::mk_imm_ptr(tcx, ty::mk_i8());\n-    ty::mk_tup(tcx, vec!(ty::mk_uint(), ty::mk_nil_ptr(tcx), ptr, ptr, t))\n+    let ptr = ty::mk_imm_ptr(tcx, tcx.types.i8);\n+    ty::mk_tup(tcx, vec!(tcx.types.uint, ty::mk_nil_ptr(tcx), ptr, ptr, t))\n }\n \n fn allocate_cbox<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,"}, {"sha": "06819aac5bc04b5e37688dd64ccdfb691571e80c", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 130, "deletions": 13, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -24,38 +24,138 @@ use middle::infer;\n use middle::lang_items::LangItem;\n use middle::mem_categorization as mc;\n use middle::region;\n-use middle::subst;\n-use middle::subst::{Subst, Substs};\n+use middle::subst::{mod, Subst, Substs};\n use trans::base;\n use trans::build;\n use trans::cleanup;\n use trans::datum;\n use trans::debuginfo;\n use trans::machine;\n+use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n use middle::traits;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, HasProjectionTypes, Ty};\n use middle::ty_fold;\n-use middle::ty_fold::TypeFoldable;\n+use middle::ty_fold::{TypeFolder, TypeFoldable};\n use util::ppaux::Repr;\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use arena::TypedArena;\n use libc::{c_uint, c_char};\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n-use std::rc::Rc;\n use std::vec::Vec;\n use syntax::ast::Ident;\n use syntax::ast;\n use syntax::ast_map::{PathElem, PathName};\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n+use util::common::memoized;\n+use util::nodemap::FnvHashSet;\n \n pub use trans::context::CrateContext;\n \n+// Is the type's representation size known at compile time?\n+pub fn type_is_sized<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+    ty::type_contents(cx, ty).is_sized(cx)\n+}\n+\n+pub fn lltype_is_sized<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match ty.sty {\n+        ty::ty_open(_) => true,\n+        _ => type_is_sized(cx, ty),\n+    }\n+}\n+\n+pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match ty.sty {\n+        ty::ty_ptr(ty::mt{ty, ..}) |\n+        ty::ty_rptr(_, ty::mt{ty, ..}) |\n+        ty::ty_uniq(ty) => {\n+            !type_is_sized(cx, ty)\n+        }\n+        _ => {\n+            false\n+        }\n+    }\n+}\n+\n+// Return the smallest part of `ty` which is unsized. Fails if `ty` is sized.\n+// 'Smallest' here means component of the static representation of the type; not\n+// the size of an object at runtime.\n+pub fn unsized_part_of_type<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    match ty.sty {\n+        ty::ty_str | ty::ty_trait(..) | ty::ty_vec(..) => ty,\n+        ty::ty_struct(def_id, substs) => {\n+            let unsized_fields: Vec<_> =\n+                ty::struct_fields(cx, def_id, substs)\n+                .iter()\n+                .map(|f| f.mt.ty)\n+                .filter(|ty| !type_is_sized(cx, *ty))\n+                .collect();\n+\n+            // Exactly one of the fields must be unsized.\n+            assert!(unsized_fields.len() == 1);\n+\n+            unsized_part_of_type(cx, unsized_fields[0])\n+        }\n+        _ => {\n+            assert!(type_is_sized(cx, ty),\n+                    \"unsized_part_of_type failed even though ty is unsized\");\n+            panic!(\"called unsized_part_of_type with sized ty\");\n+        }\n+    }\n+}\n+\n+// Some things don't need cleanups during unwinding because the\n+// task can free them all at once later. Currently only things\n+// that only contain scalars and shared boxes can avoid unwind\n+// cleanups.\n+pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    return memoized(ccx.needs_unwind_cleanup_cache(), ty, |ty| {\n+        type_needs_unwind_cleanup_(ccx.tcx(), ty, &mut FnvHashSet::new())\n+    });\n+\n+    fn type_needs_unwind_cleanup_<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                        ty: Ty<'tcx>,\n+                                        tycache: &mut FnvHashSet<Ty<'tcx>>)\n+                                        -> bool\n+    {\n+        // Prevent infinite recursion\n+        if !tycache.insert(ty) {\n+            return false;\n+        }\n+\n+        let mut needs_unwind_cleanup = false;\n+        ty::maybe_walk_ty(ty, |ty| {\n+            needs_unwind_cleanup |= match ty.sty {\n+                ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_) |\n+                ty::ty_float(_) | ty::ty_tup(_) | ty::ty_ptr(_) => false,\n+\n+                ty::ty_enum(did, substs) =>\n+                    ty::enum_variants(tcx, did).iter().any(|v|\n+                        v.args.iter().any(|&aty| {\n+                            let t = aty.subst(tcx, substs);\n+                            type_needs_unwind_cleanup_(tcx, t, tycache)\n+                        })\n+                    ),\n+\n+                _ => true\n+            };\n+            !needs_unwind_cleanup\n+        });\n+        needs_unwind_cleanup\n+    }\n+}\n+\n+pub fn type_needs_drop<'tcx>(cx: &ty::ctxt<'tcx>,\n+                             ty: Ty<'tcx>)\n+                             -> bool {\n+    ty::type_contents(cx, ty).needs_drop(cx)\n+}\n+\n fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                        ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n@@ -79,10 +179,10 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n         ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n         type_is_newtype_immediate(ccx, ty) ||\n         ty::type_is_simd(tcx, ty);\n-    if simple && !ty::type_is_fat_ptr(tcx, ty) {\n+    if simple && !type_is_fat_ptr(tcx, ty) {\n         return true;\n     }\n-    if !ty::type_is_sized(tcx, ty) {\n+    if !type_is_sized(tcx, ty) {\n         return false;\n     }\n     match ty.sty {\n@@ -364,6 +464,14 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         }\n         return out;\n     }\n+\n+    pub fn monomorphize<T>(&self, value: &T) -> T\n+        where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+    {\n+        monomorphize::apply_param_substs(self.ccx.tcx(),\n+                                         self.param_substs,\n+                                         value)\n+    }\n }\n \n // Basic block context.  We create a block context for each basic block\n@@ -456,6 +564,14 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     pub fn to_str(&self) -> String {\n         format!(\"[block {:p}]\", self)\n     }\n+\n+    pub fn monomorphize<T>(&self, value: &T) -> T\n+        where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+    {\n+        monomorphize::apply_param_substs(self.tcx(),\n+                                         self.fcx.param_substs,\n+                                         value)\n+    }\n }\n \n impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n@@ -758,7 +874,7 @@ pub fn is_null(val: ValueRef) -> bool {\n }\n \n pub fn monomorphize_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n-    t.subst(bcx.tcx(), bcx.fcx.param_substs)\n+    bcx.fcx.monomorphize(&t)\n }\n \n pub fn node_id_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n@@ -780,7 +896,7 @@ pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, ex: &ast::Expr) ->\n /// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     span: Span,\n-                                    trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n+                                    trait_ref: ty::PolyTraitRef<'tcx>)\n                                     -> traits::Vtable<'tcx, ()>\n {\n     let tcx = ccx.tcx();\n@@ -810,7 +926,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // shallow result we are looking for -- that is, what specific impl.\n     let mut selcx = traits::SelectionContext::new(&infcx, &param_env, tcx);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n-                                             trait_ref.clone());\n+                                             trait_ref.to_poly_trait_predicate());\n     let selection = match selcx.select(&obligation) {\n         Ok(Some(selection)) => selection,\n         Ok(None) => {\n@@ -844,7 +960,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // iterating early.\n     let mut fulfill_cx = traits::FulfillmentContext::new();\n     let vtable = selection.map_move_nested(|predicate| {\n-        fulfill_cx.register_predicate(infcx.tcx, predicate);\n+        fulfill_cx.register_predicate(&infcx, predicate);\n     });\n     match fulfill_cx.select_all_or_error(&infcx, &param_env, tcx) {\n         Ok(()) => { }\n@@ -890,7 +1006,8 @@ pub enum ExprOrMethodCall {\n \n pub fn node_id_substs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   node: ExprOrMethodCall)\n-                                  -> subst::Substs<'tcx> {\n+                                  -> subst::Substs<'tcx>\n+{\n     let tcx = bcx.tcx();\n \n     let substs = match node {\n@@ -911,7 +1028,7 @@ pub fn node_id_substs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     let substs = substs.erase_regions();\n-    substs.subst(tcx, bcx.fcx.param_substs)\n+    bcx.monomorphize(&substs)\n }\n \n pub fn langcall(bcx: Block,"}, {"sha": "0fd6d286e8b2de2dff8be49bcabc325d69491440", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -138,7 +138,7 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, v: ValueRef,\n         Some(ref mt) => {\n             match t.sty {\n                 ty::ty_ptr(mt) | ty::ty_rptr(_, mt) => {\n-                    if ty::type_is_sized(cx.tcx(), mt.ty) {\n+                    if type_is_sized(cx.tcx(), mt.ty) {\n                         (const_deref_ptr(cx, v), mt.ty)\n                     } else {\n                         // Derefing a fat pointer does not change the representation,"}, {"sha": "9ceb0c63990936164226641f939b79f13eac1164", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -84,6 +84,7 @@ pub struct LocalCrateContext<'tcx> {\n     tn: TypeNames,\n     externs: RefCell<ExternMap>,\n     item_vals: RefCell<NodeMap<ValueRef>>,\n+    needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n     fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n     drop_glues: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n     tydescs: RefCell<FnvHashMap<Ty<'tcx>, Rc<tydesc_info<'tcx>>>>,\n@@ -99,7 +100,7 @@ pub struct LocalCrateContext<'tcx> {\n     monomorphized: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<uint>>,\n     /// Cache generated vtables\n-    vtables: RefCell<FnvHashMap<(Ty<'tcx>, Rc<ty::PolyTraitRef<'tcx>>), ValueRef>>,\n+    vtables: RefCell<FnvHashMap<(Ty<'tcx>, ty::PolyTraitRef<'tcx>), ValueRef>>,\n     /// Cache of constant strings,\n     const_cstr_cache: RefCell<FnvHashMap<InternedString, ValueRef>>,\n \n@@ -150,7 +151,7 @@ pub struct LocalCrateContext<'tcx> {\n     /// contexts around the same size.\n     n_llvm_insns: Cell<uint>,\n \n-    trait_cache: RefCell<FnvHashMap<Rc<ty::PolyTraitRef<'tcx>>,\n+    trait_cache: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>,\n                                     traits::Vtable<'tcx, ()>>>,\n }\n \n@@ -389,6 +390,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 tn: TypeNames::new(),\n                 externs: RefCell::new(FnvHashMap::new()),\n                 item_vals: RefCell::new(NodeMap::new()),\n+                needs_unwind_cleanup_cache: RefCell::new(FnvHashMap::new()),\n                 fn_pointer_shims: RefCell::new(FnvHashMap::new()),\n                 drop_glues: RefCell::new(FnvHashMap::new()),\n                 tydescs: RefCell::new(FnvHashMap::new()),\n@@ -569,6 +571,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.link_meta\n     }\n \n+    pub fn needs_unwind_cleanup_cache(&self) -> &RefCell<FnvHashMap<Ty<'tcx>, bool>> {\n+        &self.local.needs_unwind_cleanup_cache\n+    }\n+\n     pub fn fn_pointer_shims(&self) -> &RefCell<FnvHashMap<Ty<'tcx>, ValueRef>> {\n         &self.local.fn_pointer_shims\n     }\n@@ -601,7 +607,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.monomorphizing\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(Ty<'tcx>, Rc<ty::PolyTraitRef<'tcx>>),\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(Ty<'tcx>, ty::PolyTraitRef<'tcx>),\n                                                             ValueRef>> {\n         &self.local.vtables\n     }\n@@ -699,7 +705,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.n_llvm_insns.set(self.local.n_llvm_insns.get() + 1);\n     }\n \n-    pub fn trait_cache(&self) -> &RefCell<FnvHashMap<Rc<ty::PolyTraitRef<'tcx>>,\n+    pub fn trait_cache(&self) -> &RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>,\n                                                      traits::Vtable<'tcx, ()>>> {\n         &self.local.trait_cache\n     }"}, {"sha": "768de89d5935d0803c44427b6d66e2cfcc751f2e", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -87,7 +87,7 @@ pub fn trans_stmt_semi<'blk, 'tcx>(cx: Block<'blk, 'tcx>, e: &ast::Expr)\n                                    -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_stmt_semi\");\n     let ty = expr_ty(cx, e);\n-    if ty::type_needs_drop(cx.tcx(), ty) {\n+    if type_needs_drop(cx.tcx(), ty) {\n         expr::trans_to_lvalue(cx, e, \"stmt\").bcx\n     } else {\n         expr::trans_into(cx, e, expr::Ignore)"}, {"sha": "83bf06383a89cef9649279dbc3c2f8e8bff6064e", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -218,7 +218,7 @@ impl KindOps for Lvalue {\n                               val: ValueRef,\n                               ty: Ty<'tcx>)\n                               -> Block<'blk, 'tcx> {\n-        if ty::type_needs_drop(bcx.tcx(), ty) {\n+        if type_needs_drop(bcx.tcx(), ty) {\n             // cancel cleanup of affine values by zeroing out\n             let () = zero_mem(bcx, val, ty);\n             bcx\n@@ -398,7 +398,7 @@ impl<'tcx> Datum<'tcx, Expr> {\n                                  -> DatumBlock<'blk, 'tcx, Lvalue> {\n         debug!(\"to_lvalue_datum self: {}\", self.to_string(bcx.ccx()));\n \n-        assert!(ty::lltype_is_sized(bcx.tcx(), self.ty),\n+        assert!(lltype_is_sized(bcx.tcx(), self.ty),\n                 \"Trying to convert unsized value to lval\");\n         self.match_kind(\n             |l| DatumBlock::new(bcx, l),\n@@ -456,7 +456,7 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n         F: FnOnce(ValueRef) -> ValueRef,\n     {\n         let val = match self.ty.sty {\n-            _ if ty::type_is_sized(bcx.tcx(), self.ty) => gep(self.val),\n+            _ if type_is_sized(bcx.tcx(), self.ty) => gep(self.val),\n             ty::ty_open(_) => {\n                 let base = Load(bcx, expr::get_dataptr(bcx, self.val));\n                 gep(base)\n@@ -567,7 +567,7 @@ impl<'tcx, K: KindOps + fmt::Show> Datum<'tcx, K> {\n     /// scalar-ish (like an int or a pointer) which (1) does not require drop glue and (2) is\n     /// naturally passed around by value, and not by reference.\n     pub fn to_llscalarish<'blk>(self, bcx: Block<'blk, 'tcx>) -> ValueRef {\n-        assert!(!ty::type_needs_drop(bcx.tcx(), self.ty));\n+        assert!(!type_needs_drop(bcx.tcx(), self.ty));\n         assert!(self.appropriate_rvalue_mode(bcx.ccx()) == ByValue);\n         if self.kind.is_by_ref() {\n             load_ty(bcx, self.val, self.ty)"}, {"sha": "b5b1c6ff86479a1b1544ca7e540239162a7fb0f5", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -198,6 +198,7 @@ use middle::subst::{mod, Subst, Substs};\n use trans::{mod, adt, machine, type_of};\n use trans::common::*;\n use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n+use trans::monomorphize;\n use trans::type_::Type;\n use middle::ty::{mod, Ty};\n use middle::pat_util;\n@@ -426,8 +427,8 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 from_def_id_and_substs(self,\n                                        cx,\n-                                       trait_data.principal.def_id(),\n-                                       trait_data.principal.substs(),\n+                                       trait_data.principal_def_id(),\n+                                       trait_data.principal.0.substs,\n                                        &mut unique_type_id);\n             },\n             ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n@@ -1438,7 +1439,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 assert_type_for_node_id(cx, fn_ast_id, error_reporting_span);\n \n                 let return_type = ty::node_id_to_type(cx.tcx(), fn_ast_id);\n-                let return_type = return_type.subst(cx.tcx(), param_substs);\n+                let return_type = monomorphize::apply_param_substs(cx.tcx(),\n+                                                                   param_substs,\n+                                                                   &return_type);\n                 signature.push(type_metadata(cx, return_type, codemap::DUMMY_SP));\n             }\n         }\n@@ -1447,7 +1450,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         for arg in fn_decl.inputs.iter() {\n             assert_type_for_node_id(cx, arg.pat.id, arg.pat.span);\n             let arg_type = ty::node_id_to_type(cx.tcx(), arg.pat.id);\n-            let arg_type = arg_type.subst(cx.tcx(), param_substs);\n+            let arg_type = monomorphize::apply_param_substs(cx.tcx(),\n+                                                            param_substs,\n+                                                            &arg_type);\n             signature.push(type_metadata(cx, arg_type, codemap::DUMMY_SP));\n         }\n \n@@ -1459,8 +1464,10 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                          param_substs: &Substs<'tcx>,\n                                          file_metadata: DIFile,\n                                          name_to_append_suffix_to: &mut String)\n-                                         -> DIArray {\n+                                         -> DIArray\n+    {\n         let self_type = param_substs.self_ty();\n+        let self_type = monomorphize::normalize_associated_type(cx.tcx(), &self_type);\n \n         // Only true for static default methods:\n         let has_self_type = self_type.is_some();\n@@ -2487,9 +2494,10 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let discriminant_llvm_type = adt::ll_inttype(cx, inttype);\n                 let (discriminant_size, discriminant_align) =\n                     size_and_align_of(cx, discriminant_llvm_type);\n-                let discriminant_base_type_metadata = type_metadata(cx,\n-                                                                    adt::ty_of_inttype(inttype),\n-                                                                    codemap::DUMMY_SP);\n+                let discriminant_base_type_metadata =\n+                    type_metadata(cx,\n+                                  adt::ty_of_inttype(cx.tcx(), inttype),\n+                                  codemap::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n \n                 let discriminant_type_metadata = discriminant_name.get().with_c_str(|name| {\n@@ -2797,7 +2805,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         MemberDescription {\n             name: \"length\".to_string(),\n             llvm_type: member_llvm_types[1],\n-            type_metadata: type_metadata(cx, ty::mk_uint(), span),\n+            type_metadata: type_metadata(cx, cx.tcx().types.uint, span),\n             offset: ComputedMemberOffset,\n             flags: FLAGS_NONE\n         },\n@@ -2877,7 +2885,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // But it does not describe the trait's methods.\n \n     let def_id = match trait_type.sty {\n-        ty::ty_trait(box ty::TyTrait { ref principal, .. }) => principal.def_id(),\n+        ty::ty_trait(ref data) => data.principal_def_id(),\n         _ => {\n             let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n             cx.sess().bug(format!(\"debuginfo: Unexpected trait-object type in \\\n@@ -2963,7 +2971,7 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         // FIXME Can we do better than this for unsized vec/str fields?\n         ty::ty_vec(typ, None) => fixed_vec_metadata(cx, unique_type_id, typ, 0, usage_site_span),\n-        ty::ty_str => fixed_vec_metadata(cx, unique_type_id, ty::mk_i8(), 0, usage_site_span),\n+        ty::ty_str => fixed_vec_metadata(cx, unique_type_id, cx.tcx().types.i8, 0, usage_site_span),\n         ty::ty_trait(..) => {\n             MetadataCreationResult::new(\n                         trait_pointer_metadata(cx, t, None, unique_type_id),\n@@ -2975,7 +2983,7 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span)\n                 }\n                 ty::ty_str => {\n-                    vec_slice_metadata(cx, t, ty::mk_u8(), unique_type_id, usage_site_span)\n+                    vec_slice_metadata(cx, t, cx.tcx().types.u8, unique_type_id, usage_site_span)\n                 }\n                 ty::ty_trait(..) => {\n                     MetadataCreationResult::new(\n@@ -3810,8 +3818,8 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             output.push(']');\n         },\n         ty::ty_trait(ref trait_data) => {\n-            push_item_name(cx, trait_data.principal.def_id(), false, output);\n-            push_type_params(cx, trait_data.principal.substs(), output);\n+            push_item_name(cx, trait_data.principal_def_id(), false, output);\n+            push_type_params(cx, trait_data.principal.0.substs, output);\n         },\n         ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n             if unsafety == ast::Unsafety::Unsafe {\n@@ -3919,9 +3927,10 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_unboxed_closure(..) => {\n             output.push_str(\"closure\");\n         }\n-        ty::ty_err      |\n+        ty::ty_err |\n         ty::ty_infer(_) |\n         ty::ty_open(_) |\n+        ty::ty_projection(..) |\n         ty::ty_param(_) => {\n             cx.sess().bug(format!(\"debuginfo: Trying to create type name for \\\n                 unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t))[]);"}, {"sha": "5a20a297fdb09ddfe569910aacb421738310bd9e", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -39,7 +39,7 @@ use back::abi;\n use llvm::{mod, ValueRef};\n use middle::def;\n use middle::mem_categorization::Typer;\n-use middle::subst::{mod, Subst, Substs};\n+use middle::subst::{mod, Substs};\n use trans::{_match, adt, asm, base, callee, closure, consts, controlflow};\n use trans::base::*;\n use trans::build::*;\n@@ -280,7 +280,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                expr.repr(bcx.tcx()),\n                datum.to_string(bcx.ccx()));\n \n-        if !ty::type_is_sized(bcx.tcx(), datum.ty) {\n+        if !type_is_sized(bcx.tcx(), datum.ty) {\n             debug!(\"Taking address of unsized type {}\",\n                    bcx.ty_to_string(datum.ty));\n             ref_fat_ptr(bcx, expr, datum)\n@@ -319,11 +319,13 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           bcx.ty_to_string(unadjusted_ty))[])\n             },\n             &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n-                let substs = principal.substs().with_self_ty(unadjusted_ty).erase_regions();\n+                // Note that we preserve binding levels here:\n+                let substs = principal.0.substs.with_self_ty(unadjusted_ty).erase_regions();\n+                let substs = bcx.tcx().mk_substs(substs);\n                 let trait_ref =\n-                    Rc::new(ty::Binder(ty::TraitRef { def_id: principal.def_id(),\n-                                                      substs: bcx.tcx().mk_substs(substs) }));\n-                let trait_ref = trait_ref.subst(bcx.tcx(), bcx.fcx.param_substs);\n+                    ty::Binder(Rc::new(ty::TraitRef { def_id: principal.def_id(),\n+                                                      substs: substs }));\n+                let trait_ref = bcx.monomorphize(&trait_ref);\n                 let box_ty = mk_ty(unadjusted_ty);\n                 PointerCast(bcx,\n                             meth::get_vtable(bcx, box_ty, trait_ref),\n@@ -693,7 +695,7 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             field_tys[ix].mt.ty,\n             |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, ix));\n \n-        if ty::type_is_sized(bcx.tcx(), d.ty) {\n+        if type_is_sized(bcx.tcx(), d.ty) {\n             DatumBlock { datum: d.to_expr_datum(), bcx: bcx }\n         } else {\n             let scratch = rvalue_scratch_datum(bcx, ty::mk_open(bcx.tcx(), d.ty), \"\");\n@@ -773,7 +775,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                Some(SaveIn(scratch.val)),\n                                                true));\n             let datum = scratch.to_expr_datum();\n-            if ty::type_is_sized(bcx.tcx(), elt_ty) {\n+            if type_is_sized(bcx.tcx(), elt_ty) {\n                 Datum::new(datum.to_llscalarish(bcx), elt_ty, LvalueExpr)\n             } else {\n                 Datum::new(datum.val, ty::mk_open(bcx.tcx(), elt_ty), LvalueExpr)\n@@ -976,7 +978,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let src_datum = unpack_datum!(bcx, trans(bcx, &**src));\n             let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &**dst, \"assign\"));\n \n-            if ty::type_needs_drop(bcx.tcx(), dst_datum.ty) {\n+            if type_needs_drop(bcx.tcx(), dst_datum.ty) {\n                 // If there are destructors involved, make sure we\n                 // are copying from an rvalue, since that cannot possible\n                 // alias an lvalue. We are concerned about code like:\n@@ -1204,7 +1206,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                              .get(&expr.id)\n                                              .map(|t| (*t).clone())\n                                              .unwrap();\n-                let trait_ref = trait_ref.subst(bcx.tcx(), bcx.fcx.param_substs);\n+                let trait_ref = bcx.monomorphize(&trait_ref);\n                 let datum = unpack_datum!(bcx, trans(bcx, &**val));\n                 meth::trans_trait_cast(bcx, datum, expr.id,\n                                        trait_ref, dest)\n@@ -1513,7 +1515,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         assert_eq!(discr, 0);\n \n         match ty::expr_kind(bcx.tcx(), &*base.expr) {\n-            ty::RvalueDpsExpr | ty::RvalueDatumExpr if !ty::type_needs_drop(bcx.tcx(), ty) => {\n+            ty::RvalueDpsExpr | ty::RvalueDatumExpr if !type_needs_drop(bcx.tcx(), ty) => {\n                 bcx = trans_into(bcx, &*base.expr, SaveIn(addr));\n             },\n             ty::RvalueStmtExpr => bcx.tcx().sess.bug(\"unexpected expr kind for struct base expr\"),\n@@ -1522,7 +1524,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 for &(i, t) in base.fields.iter() {\n                     let datum = base_datum.get_element(\n                             bcx, t, |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, i));\n-                    assert!(ty::type_is_sized(bcx.tcx(), datum.ty));\n+                    assert!(type_is_sized(bcx.tcx(), datum.ty));\n                     let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n                     bcx = datum.store_to(bcx, dest);\n                 }\n@@ -1650,7 +1652,7 @@ fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_uniq_expr\");\n     let fcx = bcx.fcx;\n-    assert!(ty::type_is_sized(bcx.tcx(), contents_ty));\n+    assert!(type_is_sized(bcx.tcx(), contents_ty));\n     let llty = type_of::type_of(bcx.ccx(), contents_ty);\n     let size = llsize_of(bcx.ccx(), llty);\n     let align = C_uint(bcx.ccx(), type_of::align_of(bcx.ccx(), contents_ty));\n@@ -1985,7 +1987,7 @@ pub fn cast_type_kind<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> cast_kind {\n         ty::ty_char        => cast_integral,\n         ty::ty_float(..)   => cast_float,\n         ty::ty_rptr(_, mt) | ty::ty_ptr(mt) => {\n-            if ty::type_is_sized(tcx, mt.ty) {\n+            if type_is_sized(tcx, mt.ty) {\n                 cast_pointer\n             } else {\n                 cast_other\n@@ -2117,7 +2119,7 @@ fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Evaluate LHS (destination), which should be an lvalue\n     let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n-    assert!(!ty::type_needs_drop(bcx.tcx(), dst_datum.ty));\n+    assert!(!type_needs_drop(bcx.tcx(), dst_datum.ty));\n     let dst_ty = dst_datum.ty;\n     let dst = load_ty(bcx, dst_datum.val, dst_datum.ty);\n \n@@ -2217,7 +2219,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let r = match datum.ty.sty {\n         ty::ty_uniq(content_ty) => {\n-            if ty::type_is_sized(bcx.tcx(), content_ty) {\n+            if type_is_sized(bcx.tcx(), content_ty) {\n                 deref_owned_pointer(bcx, expr, datum, content_ty)\n             } else {\n                 // A fat pointer and an opened DST value have the same\n@@ -2236,7 +2238,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         ty::ty_ptr(ty::mt { ty: content_ty, .. }) |\n         ty::ty_rptr(_, ty::mt { ty: content_ty, .. }) => {\n-            if ty::type_is_sized(bcx.tcx(), content_ty) {\n+            if type_is_sized(bcx.tcx(), content_ty) {\n                 let ptr = datum.to_llscalarish(bcx);\n \n                 // Always generate an lvalue datum, even if datum.mode is"}, {"sha": "e234d77914b646e010614804676c7333f3822d6b", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -19,11 +19,12 @@ use trans::build::*;\n use trans::cabi;\n use trans::common::*;\n use trans::machine;\n+use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of::*;\n use trans::type_of;\n use middle::ty::{mod, Ty};\n-use middle::subst::{Subst, Substs};\n+use middle::subst::{Substs};\n use std::cmp;\n use libc::c_uint;\n use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n@@ -525,7 +526,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n \n     let fnty = ty::node_id_to_type(ccx.tcx(), id);\n-    let mty = fnty.subst(ccx.tcx(), param_substs);\n+    let mty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fnty);\n     let tys = foreign_types_for_fn_ty(ccx, mty);\n \n     unsafe { // unsafe because we call LLVM operations\n@@ -543,10 +544,12 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                attrs: &[ast::Attribute],\n                                id: ast::NodeId,\n                                hash: Option<&str>)\n-                               -> ValueRef {\n+                               -> ValueRef\n+    {\n         let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n         let tcx = ccx.tcx();\n-        let t = ty::node_id_to_type(tcx, id).subst(ccx.tcx(), param_substs);\n+        let t = ty::node_id_to_type(tcx, id);\n+        let t = monomorphize::apply_param_substs(tcx, param_substs, &t);\n \n         let ps = ccx.tcx().map.with_path(id, |path| {\n             let abi = Some(ast_map::PathName(special_idents::clownshoe_abi.name));"}, {"sha": "ab5c670ef5a2dd03a6769f4145a61e20078f84ad", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -63,7 +63,7 @@ pub fn trans_exchange_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n \n pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef,\n                                           content_ty: Ty<'tcx>) -> Block<'blk, 'tcx> {\n-    assert!(ty::type_is_sized(bcx.ccx().tcx(), content_ty));\n+    assert!(type_is_sized(bcx.ccx().tcx(), content_ty));\n     let sizing_type = sizing_type_of(bcx.ccx(), content_ty);\n     let content_size = llsize_of_alloc(bcx.ccx(), sizing_type);\n \n@@ -81,19 +81,19 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let tcx = ccx.tcx();\n     // Even if there is no dtor for t, there might be one deeper down and we\n     // might need to pass in the vtable ptr.\n-    if !ty::type_is_sized(tcx, t) {\n+    if !type_is_sized(tcx, t) {\n         return t\n     }\n-    if !ty::type_needs_drop(tcx, t) {\n-        return ty::mk_i8();\n+    if !type_needs_drop(tcx, t) {\n+        return tcx.types.i8;\n     }\n     match t.sty {\n-        ty::ty_uniq(typ) if !ty::type_needs_drop(tcx, typ)\n-                         && ty::type_is_sized(tcx, typ) => {\n+        ty::ty_uniq(typ) if !type_needs_drop(tcx, typ)\n+                         && type_is_sized(tcx, typ) => {\n             let llty = sizing_type_of(ccx, typ);\n             // `Box<ZeroSizeType>` does not allocate.\n             if llsize_of_alloc(ccx, llty) == 0 {\n-                ty::mk_i8()\n+                tcx.types.i8\n             } else {\n                 t\n             }\n@@ -110,7 +110,7 @@ pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // NB: v is an *alias* of type t here, not a direct value.\n     debug!(\"drop_ty(t={})\", t.repr(bcx.tcx()));\n     let _icx = push_ctxt(\"drop_ty\");\n-    if ty::type_needs_drop(bcx.tcx(), t) {\n+    if type_needs_drop(bcx.tcx(), t) {\n         let ccx = bcx.ccx();\n         let glue = get_drop_glue(ccx, t);\n         let glue_type = get_drop_glue_type(ccx, t);\n@@ -150,7 +150,7 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n         _ => { }\n     }\n \n-    let llty = if ty::type_is_sized(ccx.tcx(), t) {\n+    let llty = if type_is_sized(ccx.tcx(), t) {\n         type_of(ccx, t).ptr_to()\n     } else {\n         type_of(ccx, ty::mk_uniq(ccx.tcx(), t)).ptr_to()\n@@ -193,14 +193,14 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                       substs: &subst::Substs<'tcx>)\n                                       -> Block<'blk, 'tcx> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n-    let struct_data = if ty::type_is_sized(bcx.tcx(), t) {\n+    let struct_data = if type_is_sized(bcx.tcx(), t) {\n         v0\n     } else {\n         let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n         Load(bcx, llval)\n     };\n     let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &*repr, struct_data));\n-    with_cond(bcx, load_ty(bcx, drop_flag.val, ty::mk_bool()), |cx| {\n+    with_cond(bcx, load_ty(bcx, drop_flag.val, bcx.tcx().types.bool), |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n     })\n }\n@@ -234,7 +234,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     bcx.ty_to_string(fty))[])\n     };\n \n-    let (struct_data, info) = if ty::type_is_sized(bcx.tcx(), t) {\n+    let (struct_data, info) = if type_is_sized(bcx.tcx(), t) {\n         (v0, None)\n     } else {\n         let data = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n@@ -251,7 +251,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // Class dtors have no explicit args, so the params should\n         // just consist of the environment (self).\n         assert_eq!(params.len(), 1);\n-        let self_arg = if ty::type_is_fat_ptr(bcx.tcx(), self_ty) {\n+        let self_arg = if type_is_fat_ptr(bcx.tcx(), self_ty) {\n             // The dtor expects a fat pointer, so make one, even if we have to fake it.\n             let boxed_ty = ty::mk_open(bcx.tcx(), t);\n             let scratch = datum::rvalue_scratch_datum(bcx, boxed_ty, \"__fat_ptr_drop_self\");\n@@ -275,7 +275,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         for (i, ty) in st.fields.iter().enumerate().rev() {\n             let llfld_a = adt::struct_field_ptr(variant_cx, &*st, value, i, false);\n \n-            let val = if ty::type_is_sized(bcx.tcx(), *ty) {\n+            let val = if type_is_sized(bcx.tcx(), *ty) {\n                 llfld_a\n             } else {\n                 let boxed_ty = ty::mk_open(bcx.tcx(), *ty);\n@@ -303,7 +303,7 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n                                      -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {}\",\n            bcx.ty_to_string(t), bcx.val_to_string(info));\n-    if ty::type_is_sized(bcx.tcx(), t) {\n+    if type_is_sized(bcx.tcx(), t) {\n         let sizing_type = sizing_type_of(bcx.ccx(), t);\n         let size = C_uint(bcx.ccx(), llsize_of_alloc(bcx.ccx(), sizing_type));\n         let align = C_uint(bcx.ccx(), align_of(bcx.ccx(), t));\n@@ -383,7 +383,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                         bcx\n                     })\n                 }\n-                ty::ty_struct(..) if !ty::type_is_sized(bcx.tcx(), content_ty) => {\n+                ty::ty_struct(..) if !type_is_sized(bcx.tcx(), content_ty) => {\n                     let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n                     let llbox = Load(bcx, llval);\n                     let not_null = IsNotNull(bcx, llbox);\n@@ -396,7 +396,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                     })\n                 }\n                 _ => {\n-                    assert!(ty::type_is_sized(bcx.tcx(), content_ty));\n+                    assert!(type_is_sized(bcx.tcx(), content_ty));\n                     let llval = v0;\n                     let llbox = Load(bcx, llval);\n                     let not_null = IsNotNull(bcx, llbox);\n@@ -415,7 +415,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                     // find the drop flag (which is at the end of the struct).\n                     // Lets just ignore the flag and pretend everything will be\n                     // OK.\n-                    if ty::type_is_sized(bcx.tcx(), t) {\n+                    if type_is_sized(bcx.tcx(), t) {\n                         trans_struct_drop_flag(bcx, t, v0, dtor, did, substs)\n                     } else {\n                         // Give the user a heads up that we are doing something\n@@ -468,8 +468,8 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n         }\n         ty::ty_vec(ty, None) => tvec::make_drop_glue_unboxed(bcx, v0, ty, false),\n         _ => {\n-            assert!(ty::type_is_sized(bcx.tcx(), t));\n-            if ty::type_needs_drop(bcx.tcx(), t) &&\n+            assert!(type_is_sized(bcx.tcx(), t));\n+            if type_needs_drop(bcx.tcx(), t) &&\n                 ty::type_is_structural(t) {\n                 iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, None))\n             } else {"}, {"sha": "d49018e00c1cbb6078b47430ecd15ddda3aa6602", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -32,7 +32,7 @@ use middle::ty::{mod, Ty};\n use syntax::abi::RustIntrinsic;\n use syntax::ast;\n use syntax::parse::token;\n-use util::ppaux::ty_to_string;\n+use util::ppaux::{Repr, ty_to_string};\n \n pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Option<ValueRef> {\n     let name = match token::get_ident(item.ident).get() {\n@@ -90,46 +90,53 @@ pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Opti\n /// Performs late verification that intrinsics are used correctly. At present,\n /// the only intrinsic that needs such verification is `transmute`.\n pub fn check_intrinsics(ccx: &CrateContext) {\n-    for transmute_restriction in ccx.tcx()\n-                                    .transmute_restrictions\n-                                    .borrow()\n-                                    .iter() {\n+    let mut last_failing_id = None;\n+    for transmute_restriction in ccx.tcx().transmute_restrictions.borrow().iter() {\n+        // Sometimes, a single call to transmute will push multiple\n+        // type pairs to test in order to exhaustively test the\n+        // possibility around a type parameter. If one of those fails,\n+        // there is no sense reporting errors on the others.\n+        if last_failing_id == Some(transmute_restriction.id) {\n+            continue;\n+        }\n+\n+        debug!(\"transmute_restriction: {}\", transmute_restriction.repr(ccx.tcx()));\n+\n+        assert!(!ty::type_has_params(transmute_restriction.substituted_from));\n+        assert!(!ty::type_has_params(transmute_restriction.substituted_to));\n+\n         let llfromtype = type_of::sizing_type_of(ccx,\n-                                                 transmute_restriction.from);\n+                                                 transmute_restriction.substituted_from);\n         let lltotype = type_of::sizing_type_of(ccx,\n-                                               transmute_restriction.to);\n+                                               transmute_restriction.substituted_to);\n         let from_type_size = machine::llbitsize_of_real(ccx, llfromtype);\n         let to_type_size = machine::llbitsize_of_real(ccx, lltotype);\n         if from_type_size != to_type_size {\n-            ccx.sess()\n-               .span_err(transmute_restriction.span,\n-                format!(\"transmute called on types with different sizes: \\\n-                         {} ({} bit{}) to {} ({} bit{})\",\n-                        ty_to_string(ccx.tcx(), transmute_restriction.from),\n-                        from_type_size as uint,\n-                        if from_type_size == 1 {\n-                            \"\"\n-                        } else {\n-                            \"s\"\n-                        },\n-                        ty_to_string(ccx.tcx(), transmute_restriction.to),\n-                        to_type_size as uint,\n-                        if to_type_size == 1 {\n-                            \"\"\n-                        } else {\n-                            \"s\"\n-                        })[]);\n-        }\n-        if ty::type_is_fat_ptr(ccx.tcx(), transmute_restriction.to) ||\n-           ty::type_is_fat_ptr(ccx.tcx(), transmute_restriction.from) {\n-            ccx.sess()\n-               .add_lint(::lint::builtin::FAT_PTR_TRANSMUTES,\n-                         transmute_restriction.id,\n-                         transmute_restriction.span,\n-                         format!(\"Transmuting fat pointer types; {} to {}.\\\n-                                  Beware of relying on the compiler's representation\",\n-                                 ty_to_string(ccx.tcx(), transmute_restriction.from),\n-                                 ty_to_string(ccx.tcx(), transmute_restriction.to)));\n+            last_failing_id = Some(transmute_restriction.id);\n+\n+            if transmute_restriction.original_from != transmute_restriction.substituted_from {\n+                ccx.sess().span_err(\n+                    transmute_restriction.span,\n+                    format!(\"transmute called on types with potentially different sizes: \\\n+                             {} (could be {} bit{}) to {} (could be {} bit{})\",\n+                            ty_to_string(ccx.tcx(), transmute_restriction.original_from),\n+                            from_type_size as uint,\n+                            if from_type_size == 1 {\"\"} else {\"s\"},\n+                            ty_to_string(ccx.tcx(), transmute_restriction.original_to),\n+                            to_type_size as uint,\n+                            if to_type_size == 1 {\"\"} else {\"s\"}).as_slice());\n+            } else {\n+                ccx.sess().span_err(\n+                    transmute_restriction.span,\n+                    format!(\"transmute called on types with different sizes: \\\n+                             {} ({} bit{}) to {} ({} bit{})\",\n+                            ty_to_string(ccx.tcx(), transmute_restriction.original_from),\n+                            from_type_size as uint,\n+                            if from_type_size == 1 {\"\"} else {\"s\"},\n+                            ty_to_string(ccx.tcx(), transmute_restriction.original_to),\n+                            to_type_size as uint,\n+                            if to_type_size == 1 {\"\"} else {\"s\"}).as_slice());\n+            }\n         }\n     }\n     ccx.sess().abort_if_errors();\n@@ -365,7 +372,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, \"needs_drop\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            C_bool(ccx, ty::type_needs_drop(ccx.tcx(), tp_ty))\n+            C_bool(ccx, type_needs_drop(ccx.tcx(), tp_ty))\n         }\n         (_, \"owns_managed\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);"}, {"sha": "9535ffaec0e6a182b9b925387ac4ac4dd68bccc9", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -13,7 +13,7 @@ use back::abi;\n use llvm;\n use llvm::ValueRef;\n use metadata::csearch;\n-use middle::subst::{Subst,Substs};\n+use middle::subst::{Substs};\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n use middle::traits;\n@@ -132,8 +132,7 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             ref trait_ref,\n             method_num\n         }) => {\n-            let trait_ref =\n-                Rc::new(ty::Binder((**trait_ref).subst(bcx.tcx(), bcx.fcx.param_substs)));\n+            let trait_ref = ty::Binder(bcx.monomorphize(trait_ref));\n             let span = bcx.tcx().map.span(method_call.expr_id);\n             debug!(\"method_call={} trait_ref={}\",\n                    method_call,\n@@ -142,8 +141,11 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                             span,\n                                             trait_ref.clone());\n             debug!(\"origin = {}\", origin.repr(bcx.tcx()));\n-            trans_monomorphized_callee(bcx, method_call, trait_ref.def_id(),\n-                                       method_num, origin)\n+            trans_monomorphized_callee(bcx,\n+                                       method_call,\n+                                       trait_ref.def_id(),\n+                                       method_num,\n+                                       origin)\n         }\n \n         ty::MethodTraitObject(ref mt) => {\n@@ -207,7 +209,6 @@ pub fn trans_static_method_callee(bcx: Block,\n     let subst::SeparateVecsPerParamSpace {\n         types: rcvr_type,\n         selfs: rcvr_self,\n-        assocs: rcvr_assoc,\n         fns: rcvr_method\n     } = rcvr_substs.types.split();\n \n@@ -236,11 +237,11 @@ pub fn trans_static_method_callee(bcx: Block,\n     let trait_substs =\n         Substs::erased(VecPerParamSpace::new(rcvr_type,\n                                              rcvr_self,\n-                                             rcvr_assoc,\n                                              Vec::new()));\n+    let trait_substs = bcx.tcx().mk_substs(trait_substs);\n     debug!(\"trait_substs={}\", trait_substs.repr(bcx.tcx()));\n-    let trait_ref = Rc::new(ty::Binder(ty::TraitRef { def_id: trait_id,\n-                                                      substs: bcx.tcx().mk_substs(trait_substs) }));\n+    let trait_ref = ty::Binder(Rc::new(ty::TraitRef { def_id: trait_id,\n+                                                      substs: trait_substs }));\n     let vtbl = fulfill_obligation(bcx.ccx(),\n                                   DUMMY_SP,\n                                   trait_ref);\n@@ -273,13 +274,11 @@ pub fn trans_static_method_callee(bcx: Block,\n             let subst::SeparateVecsPerParamSpace {\n                 types: impl_type,\n                 selfs: impl_self,\n-                assocs: impl_assoc,\n                 fns: _\n             } = impl_substs.types.split();\n             let callee_substs =\n                 Substs::erased(VecPerParamSpace::new(impl_type,\n                                                      impl_self,\n-                                                     impl_assoc,\n                                                      rcvr_method));\n \n             let mth_id = method_with_name(ccx, impl_did, mname);\n@@ -408,13 +407,12 @@ fn combine_impl_and_methods_tps<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let subst::SeparateVecsPerParamSpace {\n         types: rcvr_type,\n         selfs: rcvr_self,\n-        assocs: rcvr_assoc,\n         fns: rcvr_method\n     } = rcvr_substs.types.clone().split();\n     assert!(rcvr_method.is_empty());\n     subst::Substs {\n         regions: subst::ErasedRegions,\n-        types: subst::VecPerParamSpace::new(rcvr_type, rcvr_self, rcvr_assoc, node_method)\n+        types: subst::VecPerParamSpace::new(rcvr_type, rcvr_self, node_method)\n     }\n }\n \n@@ -436,7 +434,7 @@ fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let self_datum = unpack_datum!(\n         bcx, expr::trans(bcx, self_expr));\n \n-    let llval = if ty::type_needs_drop(bcx.tcx(), self_datum.ty) {\n+    let llval = if type_needs_drop(bcx.tcx(), self_datum.ty) {\n         let self_datum = unpack_datum!(\n             bcx, self_datum.to_rvalue_datum(bcx, \"trait_callee\"));\n \n@@ -515,7 +513,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// This will hopefully change now that DST is underway.\n pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               box_ty: Ty<'tcx>,\n-                              trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n+                              trait_ref: ty::PolyTraitRef<'tcx>)\n                               -> ValueRef\n {\n     debug!(\"get_vtable(box_ty={}, trait_ref={})\",\n@@ -562,7 +560,7 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let llfn = vec![trans_fn_pointer_shim(bcx.ccx(), bare_fn_ty)];\n                 llfn.into_iter()\n             }\n-            traits::VtableParam(..) => {\n+            traits::VtableParam => {\n                 bcx.sess().bug(\n                     format!(\"resolved vtable for {} to bad vtable {} in trans\",\n                             trait_ref.repr(bcx.tcx()),\n@@ -671,7 +669,7 @@ fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     datum: Datum<'tcx, Expr>,\n                                     id: ast::NodeId,\n-                                    trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n+                                    trait_ref: ty::PolyTraitRef<'tcx>,\n                                     dest: expr::Dest)\n                                     -> Block<'blk, 'tcx> {\n     let mut bcx = bcx;"}, {"sha": "3b7043e4f40f065fd8e112d70edeef141698b9ca", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 93, "deletions": 2, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -12,15 +12,18 @@ use back::link::exported_name;\n use session;\n use llvm::ValueRef;\n use llvm;\n+use middle::infer;\n use middle::subst;\n-use middle::subst::Subst;\n+use middle::subst::{Subst, Substs};\n+use middle::traits;\n+use middle::ty_fold::{mod, TypeFolder, TypeFoldable};\n use trans::base::{set_llvm_fn_attrs, set_inline_hint};\n use trans::base::{trans_enum_variant, push_ctxt, get_item_val};\n use trans::base::{trans_fn, decl_internal_rust_fn};\n use trans::base;\n use trans::common::*;\n use trans::foreign;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, HasProjectionTypes, Ty};\n use util::ppaux::Repr;\n \n use syntax::abi;\n@@ -29,6 +32,7 @@ use syntax::ast_map;\n use syntax::ast_util::{local_def, PostExpansionMethod};\n use syntax::attr;\n use std::hash::{sip, Hash};\n+use std::rc::Rc;\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: ast::DefId,\n@@ -92,7 +96,12 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx()));\n+\n     let mono_ty = llitem_ty.subst(ccx.tcx(), psubsts);\n+    debug!(\"mono_ty = {} (post-substitution)\", mono_ty.repr(ccx.tcx()));\n+\n+    let mono_ty = normalize_associated_type(ccx.tcx(), &mono_ty);\n+    debug!(\"mono_ty = {} (post-normalization)\", mono_ty.repr(ccx.tcx()));\n \n     ccx.stats().n_monos.set(ccx.stats().n_monos.get() + 1);\n \n@@ -282,3 +291,85 @@ pub struct MonoId<'tcx> {\n     pub def: ast::DefId,\n     pub params: subst::VecPerParamSpace<Ty<'tcx>>\n }\n+\n+/// Monomorphizes a type from the AST by first applying the in-scope\n+/// substitutions and then normalizing any associated types.\n+pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n+                                  param_substs: &Substs<'tcx>,\n+                                  value: &T)\n+                                  -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+{\n+    assert!(param_substs.regions.is_erased());\n+\n+    let substituted = value.subst(tcx, param_substs);\n+    normalize_associated_type(tcx, &substituted)\n+}\n+\n+/// Removes associated types, if any. Since this during\n+/// monomorphization, we know that only concrete types are involved,\n+/// and hence we can be sure that all associated types will be\n+/// completely normalized away.\n+pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, t: &T) -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n+{\n+    debug!(\"normalize_associated_type(t={})\", t.repr(tcx));\n+\n+    if !t.has_projection_types() {\n+        return t.clone();\n+    }\n+\n+    // FIXME(#20304) -- cache\n+\n+    let infcx = infer::new_infer_ctxt(tcx);\n+    let param_env = ty::empty_parameter_environment();\n+    let mut selcx = traits::SelectionContext::new(&infcx, &param_env, tcx);\n+    let mut normalizer = AssociatedTypeNormalizer { selcx: &mut selcx };\n+    let result = t.fold_with(&mut normalizer);\n+\n+    debug!(\"normalize_associated_type: t={} result={}\",\n+           t.repr(tcx),\n+           result.repr(tcx));\n+\n+    result\n+}\n+\n+struct AssociatedTypeNormalizer<'a,'tcx:'a> {\n+    selcx: &'a mut traits::SelectionContext<'a,'tcx>,\n+}\n+\n+impl<'a,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.selcx.tcx() }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match ty.sty {\n+            ty::ty_projection(ref data) => {\n+                debug!(\"ty_projection({})\", data.repr(self.tcx()));\n+\n+                let tcx = self.selcx.tcx();\n+                let substs = data.trait_ref.substs.clone().erase_regions();\n+                let substs = self.tcx().mk_substs(substs);\n+                assert!(substs.types.iter().all(|&t| (!ty::type_has_params(t) &&\n+                                                      !ty::type_has_self(t))));\n+                let trait_ref = Rc::new(ty::TraitRef::new(data.trait_ref.def_id, substs));\n+                let projection_ty = ty::ProjectionTy { trait_ref: trait_ref.clone(),\n+                                                       item_name: data.item_name };\n+                let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n+                                                         projection_ty);\n+                match traits::project_type(self.selcx, &obligation) {\n+                    Ok(ty) => ty,\n+                    Err(errors) => {\n+                        tcx.sess.bug(\n+                            format!(\"Encountered error(s) `{}` selecting `{}` during trans\",\n+                                    errors.repr(tcx),\n+                                    trait_ref.repr(tcx)).as_slice());\n+                    }\n+                }\n+            }\n+\n+            _ => {\n+                ty_fold::super_fold_ty(self, ty)\n+            }\n+        }\n+    }\n+}"}, {"sha": "688a0d0725058288f405673796494be319f8252a", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -62,7 +62,7 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n \n         let dataptr = get_dataptr(bcx, vptr);\n-        let bcx = if ty::type_needs_drop(tcx, unit_ty) {\n+        let bcx = if type_needs_drop(tcx, unit_ty) {\n             let len = get_len(bcx, vptr);\n             iter_vec_raw(bcx, dataptr, unit_ty, len, |bb, vv, tt| glue::drop_ty(bb, vv, tt, None))\n         } else {"}, {"sha": "0bc35390cd7c090c9308be9c28e519f928d5e98c", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -187,7 +187,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     }\n \n     let llsizingty = match t.sty {\n-        _ if !ty::lltype_is_sized(cx.tcx(), t) => {\n+        _ if !lltype_is_sized(cx.tcx(), t) => {\n             cx.sess().bug(format!(\"trying to take the sizing type of {}, an unsized type\",\n                                   ppaux::ty_to_string(cx.tcx(), t))[])\n         }\n@@ -199,7 +199,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         ty::ty_float(t) => Type::float_from_ty(cx, t),\n \n         ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n-            if ty::type_is_sized(cx.tcx(), ty) {\n+            if type_is_sized(cx.tcx(), ty) {\n                 Type::i8p(cx)\n             } else {\n                 Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n@@ -241,7 +241,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n         }\n \n-        ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n+        ty::ty_projection(..) | ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n             cx.sess().bug(format!(\"fictitious type {} in sizing_type_of()\",\n                                   ppaux::ty_to_string(cx.tcx(), t))[])\n         }\n@@ -267,11 +267,11 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n         // struct which might be unsized, but is monomorphised to a sized type.\n         // In this case we'll fake a fat pointer with no unsize info (we use 0).\n         // However, its still a fat pointer, so we need some type use.\n-        if ty::type_is_sized(cx.tcx(), t) {\n+        if type_is_sized(cx.tcx(), t) {\n             return Type::i8p(cx);\n         }\n \n-        match ty::unsized_part_of_type(cx.tcx(), t).sty {\n+        match unsized_part_of_type(cx.tcx(), t).sty {\n             ty::ty_str | ty::ty_vec(..) => Type::uint_from_ty(cx, ast::TyU),\n             ty::ty_trait(_) => Type::vtable_ptr(cx),\n             _ => panic!(\"Unexpected type returned from unsized_part_of_type : {}\",\n@@ -342,7 +342,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n                   cx.tn().find_type(\"str_slice\").unwrap()\n               }\n               ty::ty_trait(..) => Type::opaque_trait(cx),\n-              _ if !ty::type_is_sized(cx.tcx(), ty) => {\n+              _ if !type_is_sized(cx.tcx(), ty) => {\n                   let p_ty = type_of(cx, ty).ptr_to();\n                   Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, ty)], false)\n               }\n@@ -414,6 +414,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n       },\n \n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),\n+      ty::ty_projection(..) => cx.sess().bug(\"type_of with ty_projection\"),\n       ty::ty_param(..) => cx.sess().bug(\"type_of with ty_param\"),\n       ty::ty_err(..) => cx.sess().bug(\"type_of with ty_err\"),\n     };"}, {"sha": "587a85cfcbac4cd7e9d93960aad02260ce026397", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 303, "deletions": 219, "changes": 522, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -16,11 +16,11 @@\n //! somewhat differently during the collect and check phases,\n //! particularly with respect to looking up the types of top-level\n //! items.  In the collect phase, the crate context is used as the\n-//! `AstConv` instance; in this phase, the `get_item_ty()` function\n+//! `AstConv` instance; in this phase, the `get_item_type_scheme()` function\n //! triggers a recursive call to `ty_of_item()`  (note that\n //! `ast_ty_to_ty()` will detect recursive types and report an error).\n //! In the check phase, when the FnCtxt is used as the `AstConv`,\n-//! `get_item_ty()` just looks up the item type in `tcx.tcache`.\n+//! `get_item_type_scheme()` just looks up the item type in `tcx.tcache`.\n //!\n //! The `RegionScope` trait controls what happens when the user does\n //! not specify a region in some location where a region is required\n@@ -51,7 +51,7 @@ use middle::astconv_util::{ast_ty_to_prim_ty, check_path_args, NO_TPS, NO_REGION\n use middle::const_eval;\n use middle::def;\n use middle::resolve_lifetime as rl;\n-use middle::subst::{FnSpace, TypeSpace, AssocSpace, SelfSpace, Subst, Substs};\n+use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n use middle::ty::{mod, RegionEscape, Ty};\n use rscope::{mod, UnelidableRscope, RegionScope, SpecificRscope,\n@@ -70,7 +70,7 @@ use syntax::print::pprust;\n \n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx>;\n+    fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx>;\n     fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>>;\n \n     /// Return an (optional) substitution to convert bound type parameters that\n@@ -84,25 +84,45 @@ pub trait AstConv<'tcx> {\n     /// What type should we use when a type is omitted?\n     fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n \n-    /// Returns true if associated types from the given trait and type are\n-    /// allowed to be used here and false otherwise.\n-    fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty<'tcx>,\n-                                           trait_id: ast::DefId)\n-                                           -> bool;\n-\n-    /// Returns the concrete type bound to the given associated type (indicated\n-    /// by associated_type_id) in the current context. For example,\n-    /// in `trait Foo { type A; }` looking up `A` will give a type variable;\n-    /// in `impl Foo for ... { type A = int; ... }` looking up `A` will give `int`.\n-    fn associated_type_binding(&self,\n-                               span: Span,\n-                               self_ty: Option<Ty<'tcx>>,\n-                               // DefId for the declaration of the trait\n-                               // in which the associated type is declared.\n-                               trait_id: ast::DefId,\n-                               associated_type_id: ast::DefId)\n-                               -> Option<Ty<'tcx>>;\n+    /// Projecting an associated type from a (potentially)\n+    /// higher-ranked trait reference is more complicated, because of\n+    /// the possibility of late-bound regions appearing in the\n+    /// associated type binding. This is not legal in function\n+    /// signatures for that reason. In a function body, we can always\n+    /// handle it because we can use inference variables to remove the\n+    /// late-bound regions.\n+    fn projected_ty_from_poly_trait_ref(&self,\n+                                        span: Span,\n+                                        poly_trait_ref: ty::PolyTraitRef<'tcx>,\n+                                        item_name: ast::Name)\n+                                        -> Ty<'tcx>\n+    {\n+        if ty::binds_late_bound_regions(self.tcx(), &poly_trait_ref) {\n+            self.tcx().sess.span_err(\n+                span,\n+                \"cannot extract an associated type from a higher-ranked trait bound \\\n+                 in this context\");\n+            self.tcx().types.err\n+        } else {\n+            // no late-bound regions, we can just ignore the binder\n+            self.projected_ty(span, poly_trait_ref.0.clone(), item_name)\n+        }\n+    }\n+\n+    /// Project an associated type from a non-higher-ranked trait reference.\n+    /// This is fairly straightforward and can be accommodated in any context.\n+    fn projected_ty(&self,\n+                    span: Span,\n+                    _trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                    _item_name: ast::Name)\n+                    -> Ty<'tcx>\n+    {\n+        self.tcx().sess.span_err(\n+            span,\n+            \"associated types are not accepted in this context\");\n+\n+        self.tcx().types.err\n+    }\n }\n \n pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n@@ -224,7 +244,6 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n fn ast_path_substs_for_ty<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n-    decl_def_id: ast::DefId,\n     decl_generics: &ty::Generics<'tcx>,\n     path: &ast::Path)\n     -> Substs<'tcx>\n@@ -255,28 +274,26 @@ fn ast_path_substs_for_ty<'tcx,AC,RS>(\n         }\n     };\n \n+    prohibit_projections(this.tcx(), assoc_bindings.as_slice());\n+\n     create_substs_for_ast_path(this,\n                                rscope,\n                                path.span,\n-                               decl_def_id,\n                                decl_generics,\n                                None,\n                                types,\n-                               regions,\n-                               assoc_bindings)\n+                               regions)\n }\n \n fn create_substs_for_ast_path<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    decl_def_id: ast::DefId,\n     decl_generics: &ty::Generics<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n     types: Vec<Ty<'tcx>>,\n-    regions: Vec<ty::Region>,\n-    assoc_bindings: Vec<(ast::Ident, Ty<'tcx>)>)\n-    -> Substs<'tcx>\n+    regions: Vec<ty::Region>)\n+ -> Substs<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let tcx = this.tcx();\n@@ -382,52 +399,21 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n         }\n     }\n \n-    for formal_assoc in decl_generics.types.get_slice(AssocSpace).iter() {\n-        let mut found = false;\n-        for &(ident, ty) in assoc_bindings.iter() {\n-            if formal_assoc.name.ident() == ident {\n-                substs.types.push(AssocSpace, ty);\n-                found = true;\n-                break;\n-            }\n-        }\n-        if !found {\n-            match this.associated_type_binding(span,\n-                                               self_ty,\n-                                               decl_def_id,\n-                                               formal_assoc.def_id) {\n-                Some(ty) => {\n-                    substs.types.push(AssocSpace, ty);\n-                }\n-                None => {\n-                    substs.types.push(AssocSpace, ty::mk_err());\n-                    span_err!(this.tcx().sess, span, E0171,\n-                              \"missing type for associated type `{}`\",\n-                              token::get_ident(formal_assoc.name.ident()));\n-                }\n-            }\n-        }\n-    }\n-\n-    for &(ident, _) in assoc_bindings.iter() {\n-        let mut formal_idents = decl_generics.types.get_slice(AssocSpace)\n-                                .iter().map(|t| t.name.ident());\n-        if !formal_idents.any(|i| i == ident) {\n-            span_err!(this.tcx().sess, span, E0177,\n-                      \"associated type `{}` does not exist\",\n-                      token::get_ident(ident));\n-        }\n-    }\n-\n     return substs;\n }\n \n+struct ConvertedBinding<'tcx> {\n+    item_name: ast::Name,\n+    ty: Ty<'tcx>,\n+    span: Span,\n+}\n+\n fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n                                                     rscope: &RS,\n                                                     data: &ast::AngleBracketedParameterData)\n                                                     -> (Vec<ty::Region>,\n                                                         Vec<Ty<'tcx>>,\n-                                                        Vec<(ast::Ident, Ty<'tcx>)>)\n+                                                        Vec<ConvertedBinding<'tcx>>)\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let regions: Vec<_> =\n@@ -442,7 +428,9 @@ fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n \n     let assoc_bindings: Vec<_> =\n         data.bindings.iter()\n-        .map(|b| (b.ident, ast_ty_to_ty(this, rscope, &*b.ty)))\n+        .map(|b| ConvertedBinding { item_name: b.ident.name,\n+                                    ty: ast_ty_to_ty(this, rscope, &*b.ty),\n+                                    span: b.span })\n         .collect();\n \n     (regions, types, assoc_bindings)\n@@ -534,38 +522,47 @@ pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n     rscope: &RS,\n     ast_trait_ref: &ast::PolyTraitRef,\n     self_ty: Option<Ty<'tcx>>,\n-    allow_eq: AllowEqConstraints)\n-    -> Rc<ty::PolyTraitRef<'tcx>>\n+    poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n+    -> ty::PolyTraitRef<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n+    let mut projections = Vec::new();\n+\n     let trait_ref =\n-        instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty, allow_eq);\n-    let trait_ref = (*trait_ref).clone();\n-    Rc::new(ty::Binder(trait_ref)) // Ugh.\n+        instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref,\n+                              self_ty, Some(&mut projections));\n+\n+    for projection in projections.into_iter() {\n+        poly_projections.push(ty::Binder(projection));\n+    }\n+\n+    ty::Binder(trait_ref)\n }\n \n /// Instantiates the path for the given trait reference, assuming that it's\n /// bound to a valid trait type. Returns the def_id for the defining trait.\n /// Fails if the type is a type other than a trait type.\n-pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n-                                         rscope: &RS,\n-                                         ast_trait_ref: &ast::TraitRef,\n-                                         self_ty: Option<Ty<'tcx>>,\n-                                         allow_eq: AllowEqConstraints)\n-                                         -> Rc<ty::TraitRef<'tcx>>\n-                                         where AC: AstConv<'tcx>,\n-                                               RS: RegionScope\n+///\n+/// If the `projections` argument is `None`, then assoc type bindings like `Foo<T=X>`\n+/// are disallowed. Otherwise, they are pushed onto the vector given.\n+pub fn instantiate_trait_ref<'tcx,AC,RS>(\n+    this: &AC,\n+    rscope: &RS,\n+    ast_trait_ref: &ast::TraitRef,\n+    self_ty: Option<Ty<'tcx>>,\n+    projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n+    -> Rc<ty::TraitRef<'tcx>>\n+    where AC: AstConv<'tcx>, RS: RegionScope\n {\n     match ::lookup_def_tcx(this.tcx(), ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n         def::DefTrait(trait_def_id) => {\n-            let trait_ref = Rc::new(ast_path_to_trait_ref(this,\n-                                                          rscope,\n-                                                          trait_def_id,\n-                                                          self_ty,\n-                                                          &ast_trait_ref.path,\n-                                                          allow_eq));\n-            this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n-                                                      trait_ref.clone());\n+            let trait_ref = ast_path_to_trait_ref(this,\n+                                                  rscope,\n+                                                  trait_def_id,\n+                                                  self_ty,\n+                                                  &ast_trait_ref.path,\n+                                                  projections);\n+            this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id, trait_ref.clone());\n             trait_ref\n         }\n         _ => {\n@@ -576,20 +573,14 @@ pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n     }\n }\n \n-#[deriving(PartialEq,Show)]\n-pub enum AllowEqConstraints {\n-    Allow,\n-    DontAllow\n-}\n-\n-fn ast_path_to_trait_ref<'tcx,AC,RS>(\n+fn ast_path_to_trait_ref<'a,'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     trait_def_id: ast::DefId,\n     self_ty: Option<Ty<'tcx>>,\n     path: &ast::Path,\n-    allow_eq: AllowEqConstraints)\n-    -> ty::TraitRef<'tcx>\n+    mut projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n+    -> Rc<ty::TraitRef<'tcx>>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     debug!(\"ast_path_to_trait_ref {}\", path);\n@@ -624,22 +615,75 @@ fn ast_path_to_trait_ref<'tcx,AC,RS>(\n         }\n     };\n \n-    if allow_eq == AllowEqConstraints::DontAllow && assoc_bindings.len() > 0 {\n-        span_err!(this.tcx().sess, path.span, E0173,\n-                  \"equality constraints are not allowed in this position\");\n-    }\n-\n     let substs = create_substs_for_ast_path(this,\n                                             &shifted_rscope,\n                                             path.span,\n-                                            trait_def_id,\n                                             &trait_def.generics,\n                                             self_ty,\n                                             types,\n-                                            regions,\n-                                            assoc_bindings);\n+                                            regions);\n+    let substs = this.tcx().mk_substs(substs);\n+\n+    let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs));\n+\n+    match projections {\n+        None => {\n+            prohibit_projections(this.tcx(), assoc_bindings.as_slice());\n+        }\n+        Some(ref mut v) => {\n+            for binding in assoc_bindings.iter() {\n+                match ast_type_binding_to_projection_predicate(this, trait_ref.clone(), binding) {\n+                    Ok(pp) => { v.push(pp); }\n+                    Err(ErrorReported) => { }\n+                }\n+            }\n+        }\n+    }\n \n-    ty::TraitRef::new(trait_def_id, this.tcx().mk_substs(substs))\n+    trait_ref\n+}\n+\n+pub fn ast_type_binding_to_projection_predicate<'tcx,AC>(\n+    this: &AC,\n+    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    binding: &ConvertedBinding<'tcx>)\n+    -> Result<ty::ProjectionPredicate<'tcx>, ErrorReported>\n+    where AC : AstConv<'tcx>\n+{\n+    // Given something like `U : SomeTrait<T=X>`, we want to produce a\n+    // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n+    // subtle in the event that `T` is defined in a supertrait of\n+    // `SomeTrait`, because in that case we need to upcast.\n+    //\n+    // That is, consider this case:\n+    //\n+    // ```\n+    // trait SubTrait : SuperTrait<int> { }\n+    // trait SuperTrait<A> { type T; }\n+    //\n+    // ... B : SubTrait<T=foo> ...\n+    // ```\n+    //\n+    // We want to produce `<B as SuperTrait<int>>::T == foo`.\n+\n+    // FIXME(#19541): supertrait upcasting not actually impl'd :)\n+\n+    if !trait_defines_associated_type_named(this, trait_ref.def_id, binding.item_name) {\n+        this.tcx().sess.span_err(\n+            binding.span,\n+            format!(\"no associated type `{}` defined in `{}`\",\n+                    token::get_name(binding.item_name),\n+                    trait_ref.user_string(this.tcx())).as_slice());\n+        return Err(ErrorReported);\n+    }\n+\n+    Ok(ty::ProjectionPredicate {\n+        projection_ty: ty::ProjectionTy {\n+            trait_ref: trait_ref,\n+            item_name: binding.item_name,\n+        },\n+        ty: binding.ty,\n+    })\n }\n \n pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n@@ -650,14 +694,13 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     -> TypeAndSubsts<'tcx>\n {\n     let tcx = this.tcx();\n-    let ty::Polytype {\n+    let ty::TypeScheme {\n         generics,\n         ty: decl_ty\n-    } = this.get_item_ty(did);\n+    } = this.get_item_type_scheme(did);\n \n     let substs = ast_path_substs_for_ty(this,\n                                         rscope,\n-                                        did,\n                                         &generics,\n                                         path);\n     let ty = decl_ty.subst(tcx, &substs);\n@@ -678,10 +721,10 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n     where AC : AstConv<'tcx>, RS : RegionScope\n {\n     let tcx = this.tcx();\n-    let ty::Polytype {\n+    let ty::TypeScheme {\n         generics,\n         ty: decl_ty\n-    } = this.get_item_ty(did);\n+    } = this.get_item_type_scheme(did);\n \n     let wants_params =\n         generics.has_type_params(TypeSpace) || generics.has_region_params(TypeSpace);\n@@ -699,7 +742,7 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n         Substs::new(VecPerParamSpace::params_from_type(type_params),\n                     VecPerParamSpace::params_from_type(region_params))\n     } else {\n-        ast_path_substs_for_ty(this, rscope, did, &generics, path)\n+        ast_path_substs_for_ty(this, rscope, &generics, path)\n     };\n \n     let ty = decl_ty.subst(tcx, &substs);\n@@ -762,11 +805,13 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     }\n }\n \n+type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>);\n+\n fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                    rscope: &RS,\n                                    ty: &ast::Ty,\n                                    bounds: &[ast::TyParamBound])\n-                                   -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n+                                   -> Result<TraitAndProjections<'tcx>, ErrorReported>\n     where AC : AstConv<'tcx>, RS : RegionScope\n {\n     /*!\n@@ -784,12 +829,17 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n         ast::TyPath(ref path, id) => {\n             match this.tcx().def_map.borrow().get(&id) {\n                 Some(&def::DefTrait(trait_def_id)) => {\n-                    return Ok(ty::Binder(ast_path_to_trait_ref(this,\n-                                                               rscope,\n-                                                               trait_def_id,\n-                                                               None,\n-                                                               path,\n-                                                               AllowEqConstraints::Allow)));\n+                    let mut projection_bounds = Vec::new();\n+                    let trait_ref = ty::Binder(ast_path_to_trait_ref(this,\n+                                                                     rscope,\n+                                                                     trait_def_id,\n+                                                                     None,\n+                                                                     path,\n+                                                                     Some(&mut projection_bounds)));\n+                    let projection_bounds = projection_bounds.into_iter()\n+                                                             .map(ty::Binder)\n+                                                             .collect();\n+                    Ok((trait_ref, projection_bounds))\n                 }\n                 _ => {\n                     span_err!(this.tcx().sess, ty.span, E0172, \"expected a reference to a trait\");\n@@ -832,14 +882,16 @@ fn trait_ref_to_object_type<'tcx,AC,RS>(this: &AC,\n                                         rscope: &RS,\n                                         span: Span,\n                                         trait_ref: ty::PolyTraitRef<'tcx>,\n+                                        projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n                                         bounds: &[ast::TyParamBound])\n                                         -> Ty<'tcx>\n     where AC : AstConv<'tcx>, RS : RegionScope\n {\n     let existential_bounds = conv_existential_bounds(this,\n                                                      rscope,\n                                                      span,\n-                                                     Some(&trait_ref),\n+                                                     Some(trait_ref.clone()),\n+                                                     projection_bounds,\n                                                      bounds);\n \n     let result = ty::mk_trait(this.tcx(), trait_ref, existential_bounds);\n@@ -849,6 +901,68 @@ fn trait_ref_to_object_type<'tcx,AC,RS>(this: &AC,\n     result\n }\n \n+fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n+                                   ast_ty: &ast::Ty,\n+                                   provenance: def::TyParamProvenance,\n+                                   assoc_name: ast::Name)\n+                                   -> Ty<'tcx>\n+{\n+    let tcx = this.tcx();\n+    let ty_param_def_id = provenance.def_id();\n+    let mut suitable_bounds: Vec<_>;\n+    let ty_param_name: ast::Name;\n+    { // contain scope of refcell:\n+        let ty_param_defs = tcx.ty_param_defs.borrow();\n+        let ty_param_def = &ty_param_defs[ty_param_def_id.node];\n+        ty_param_name = ty_param_def.name;\n+\n+        // FIXME(#19541): we should consider associated types in\n+        // super-traits. Probably by elaborating the bounds.\n+\n+        suitable_bounds =\n+            ty_param_def.bounds.trait_bounds // FIXME(#20300) -- search where clauses, not bounds\n+            .iter()\n+            .cloned()\n+            .filter(|b| trait_defines_associated_type_named(this, b.def_id(), assoc_name))\n+            .collect();\n+    }\n+\n+    if suitable_bounds.len() == 0 {\n+        tcx.sess.span_err(ast_ty.span,\n+                          format!(\"associated type `{}` not found for type parameter `{}`\",\n+                                  token::get_name(assoc_name),\n+                                  token::get_name(ty_param_name)).as_slice());\n+        return this.tcx().types.err;\n+    }\n+\n+    if suitable_bounds.len() > 1 {\n+        tcx.sess.span_err(ast_ty.span,\n+                          format!(\"ambiguous associated type `{}` in bounds of `{}`\",\n+                                  token::get_name(assoc_name),\n+                                  token::get_name(ty_param_name)).as_slice());\n+\n+        for suitable_bound in suitable_bounds.iter() {\n+            span_note!(this.tcx().sess, ast_ty.span,\n+                       \"associated type `{}` could derive from `{}`\",\n+                       token::get_name(ty_param_name),\n+                       suitable_bound.user_string(this.tcx()));\n+        }\n+    }\n+\n+    let suitable_bound = suitable_bounds.pop().unwrap().clone();\n+    return this.projected_ty_from_poly_trait_ref(ast_ty.span, suitable_bound, assoc_name);\n+}\n+\n+fn trait_defines_associated_type_named(this: &AstConv,\n+                                       trait_def_id: ast::DefId,\n+                                       assoc_name: ast::Name)\n+                                       -> bool\n+{\n+    let tcx = this.tcx();\n+    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+    trait_def.associated_type_names.contains(&assoc_name)\n+}\n+\n fn qpath_to_ty<'tcx,AC,RS>(this: &AC,\n                            rscope: &RS,\n                            ast_ty: &ast::Ty, // the TyQPath\n@@ -867,33 +981,13 @@ fn qpath_to_ty<'tcx,AC,RS>(this: &AC,\n                                           rscope,\n                                           &*qpath.trait_ref,\n                                           Some(self_type),\n-                                          AllowEqConstraints::DontAllow);\n+                                          None);\n \n     debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(this.tcx()));\n \n-    if let Some(ty) = find_assoc_ty(this, &*trait_ref, qpath.item_name) {\n-        return ty;\n-    }\n-\n-    this.tcx().sess.span_bug(ast_ty.span,\n-                             \"this associated type didn't get added \\\n-                              as a parameter for some reason\")\n-}\n-\n-fn find_assoc_ty<'tcx, AC>(this: &AC,\n-                           trait_ref: &ty::TraitRef<'tcx>,\n-                           type_name: ast::Ident)\n-                           -> Option<Ty<'tcx>>\n-where AC: AstConv<'tcx> {\n-    let trait_def = this.get_trait_def(trait_ref.def_id);\n-\n-    for ty_param_def in trait_def.generics.types.get_slice(AssocSpace).iter() {\n-        if ty_param_def.name == type_name.name {\n-            return Some(trait_ref.substs.type_for_def(ty_param_def));\n-        }\n-    }\n-\n-    None\n+    return this.projected_ty(ast_ty.span,\n+                             trait_ref,\n+                             qpath.item_name.name);\n }\n \n // Parses the programmer's textual representation of a type into our\n@@ -927,12 +1021,12 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n                 match ast_ty_to_trait_ref(this, rscope, &**ty, bounds[]) {\n-                    Ok(trait_ref) => {\n+                    Ok((trait_ref, projection_bounds)) => {\n                         trait_ref_to_object_type(this, rscope, ast_ty.span,\n-                                                 trait_ref, bounds[])\n+                                                 trait_ref, projection_bounds, bounds[])\n                     }\n                     Err(ErrorReported) => {\n-                        ty::mk_err()\n+                        this.tcx().types.err\n                     }\n                 }\n             }\n@@ -970,13 +1064,15 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                      rscope,\n                                                      ast_ty.span,\n                                                      None,\n+                                                     Vec::new(),\n                                                      f.bounds.as_slice());\n+                let region_bound = bounds.region_bound;\n                 let fn_decl = ty_of_closure(this,\n                                             f.unsafety,\n                                             f.onceness,\n                                             bounds,\n                                             ty::RegionTraitStore(\n-                                                bounds.region_bound,\n+                                                region_bound,\n                                                 ast::MutMutable),\n                                             &*f.decl,\n                                             abi::Rust,\n@@ -1000,28 +1096,33 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     def::DefTrait(trait_def_id) => {\n                         // N.B. this case overlaps somewhat with\n                         // TyObjectSum, see that fn for details\n-                        let result = ty::Binder(ast_path_to_trait_ref(this,\n-                                                                      rscope,\n-                                                                      trait_def_id,\n-                                                                      None,\n-                                                                      path,\n-                                                                      AllowEqConstraints::Allow));\n-                        trait_ref_to_object_type(this, rscope, path.span, result, &[])\n+                        let mut projection_bounds = Vec::new();\n+                        let trait_ref = ast_path_to_trait_ref(this,\n+                                                              rscope,\n+                                                              trait_def_id,\n+                                                              None,\n+                                                              path,\n+                                                              Some(&mut projection_bounds));\n+                        let trait_ref = ty::Binder(trait_ref);\n+                        let projection_bounds = projection_bounds.into_iter()\n+                                                                 .map(ty::Binder)\n+                                                                 .collect();\n+                        trait_ref_to_object_type(this, rscope, path.span,\n+                                                 trait_ref, projection_bounds, &[])\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n                         ast_path_to_ty(this, rscope, did, path).ty\n                     }\n-                    def::DefTyParam(space, id, n) => {\n+                    def::DefTyParam(space, index, _, name) => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                        ty::mk_param(tcx, space, n, id)\n+                        ty::mk_param(tcx, space, index, name)\n                     }\n-                    def::DefSelfTy(id) => {\n+                    def::DefSelfTy(_) => {\n                         // n.b.: resolve guarantees that the this type only appears in a\n                         // trait, which we rely upon in various places when creating\n                         // substs\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                        let did = ast_util::local_def(id);\n-                        ty::mk_self_type(tcx, did)\n+                        ty::mk_self_type(tcx)\n                     }\n                     def::DefMod(id) => {\n                         tcx.sess.span_fatal(ast_ty.span,\n@@ -1046,46 +1147,10 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                           .unwrap()\n                                                           .identifier)\n                                                   .get())[]);\n-                        ty::mk_err()\n+                        this.tcx().types.err\n                     }\n-                    def::DefAssociatedPath(typ, assoc_ident) => {\n-                        // FIXME(#19541): in both branches we should consider\n-                        // associated types in super-traits.\n-                        let (assoc_tys, tp_name): (Vec<_>, _) = match typ {\n-                            def::TyParamProvenance::FromParam(did) |\n-                            def::TyParamProvenance::FromSelf(did) => {\n-                                let ty_param_defs = tcx.ty_param_defs.borrow();\n-                                let tp_def = &(*ty_param_defs)[did.node];\n-                                let assoc_tys = tp_def.bounds.trait_bounds.iter()\n-                                    .filter_map(|b| find_assoc_ty(this, &b.0, assoc_ident))\n-                                    .collect();\n-                                (assoc_tys, token::get_name(tp_def.name).to_string())\n-                            }\n-                        };\n-\n-                        if assoc_tys.len() == 0 {\n-                            tcx.sess.span_err(ast_ty.span,\n-                                              format!(\"associated type `{}` not \\\n-                                                       found for type parameter `{}`\",\n-                                                      token::get_ident(assoc_ident),\n-                                                      tp_name).as_slice());\n-                            return ty::mk_err()\n-                        }\n-\n-                        if assoc_tys.len() > 1 {\n-                            tcx.sess.span_err(ast_ty.span,\n-                                              format!(\"ambiguous associated type \\\n-                                                       `{}` in bounds of `{}`\",\n-                                                      token::get_ident(assoc_ident),\n-                                                      tp_name).as_slice());\n-                        }\n-\n-                        let mut result_ty = assoc_tys[0];\n-                        if let Some(substs) = this.get_free_substs() {\n-                            result_ty = result_ty.subst(tcx, substs);\n-                        }\n-\n-                        result_ty\n+                    def::DefAssociatedPath(provenance, assoc_ident) => {\n+                        associated_path_def_to_ty(this, ast_ty, provenance, assoc_ident.name)\n                     }\n                     _ => {\n                         tcx.sess.span_fatal(ast_ty.span,\n@@ -1378,7 +1443,7 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n     this: &AC,\n     unsafety: ast::Unsafety,\n     onceness: ast::Onceness,\n-    bounds: ty::ExistentialBounds,\n+    bounds: ty::ExistentialBounds<'tcx>,\n     store: ty::TraitStore,\n     decl: &ast::FnDecl,\n     abi: abi::Abi,\n@@ -1440,15 +1505,16 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    principal_trait_ref: Option<&ty::PolyTraitRef<'tcx>>, // None for boxed closures\n+    principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for boxed closures\n+    projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n     ast_bounds: &[ast::TyParamBound])\n-    -> ty::ExistentialBounds\n+    -> ty::ExistentialBounds<'tcx>\n {\n     let partitioned_bounds =\n         partition_bounds(this.tcx(), span, ast_bounds);\n \n     conv_existential_bounds_from_partitioned_bounds(\n-        this, rscope, span, principal_trait_ref, partitioned_bounds)\n+        this, rscope, span, principal_trait_ref, projection_bounds, partitioned_bounds)\n }\n \n fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n@@ -1461,13 +1527,15 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n {\n     let mut partitioned_bounds = partition_bounds(this.tcx(), span, ast_bounds[]);\n \n+    let mut projection_bounds = Vec::new();\n     let main_trait_bound = match partitioned_bounds.trait_bounds.remove(0) {\n         Some(trait_bound) => {\n-            Some(instantiate_poly_trait_ref(this,\n-                                            rscope,\n-                                            trait_bound,\n-                                            None,\n-                                            AllowEqConstraints::Allow))\n+            let ptr = instantiate_poly_trait_ref(this,\n+                                                 rscope,\n+                                                 trait_bound,\n+                                                 None,\n+                                                 &mut projection_bounds);\n+            Some(ptr)\n         }\n         None => {\n             this.tcx().sess.span_err(\n@@ -1481,22 +1549,24 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n         conv_existential_bounds_from_partitioned_bounds(this,\n                                                         rscope,\n                                                         span,\n-                                                        main_trait_bound.as_ref().map(|tr| &**tr),\n+                                                        main_trait_bound.clone(),\n+                                                        projection_bounds,\n                                                         partitioned_bounds);\n \n     match main_trait_bound {\n-        None => ty::mk_err(),\n-        Some(principal) => ty::mk_trait(this.tcx(), (*principal).clone(), bounds)\n+        None => this.tcx().types.err,\n+        Some(principal) => ty::mk_trait(this.tcx(), principal, bounds)\n     }\n }\n \n pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    principal_trait_ref: Option<&ty::PolyTraitRef<'tcx>>, // None for boxed closures\n+    principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for boxed closures\n+    mut projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>, // Empty for boxed closures\n     partitioned_bounds: PartitionedBounds)\n-    -> ty::ExistentialBounds\n+    -> ty::ExistentialBounds<'tcx>\n     where AC: AstConv<'tcx>, RS:RegionScope\n {\n     let PartitionedBounds { builtin_bounds,\n@@ -1519,9 +1589,12 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n                                             principal_trait_ref,\n                                             builtin_bounds);\n \n+    ty::sort_bounds_list(projection_bounds.as_mut_slice());\n+\n     ty::ExistentialBounds {\n         region_bound: region_bound,\n         builtin_bounds: builtin_bounds,\n+        projection_bounds: projection_bounds,\n     }\n }\n \n@@ -1532,7 +1605,7 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   span: Span,\n                                   explicit_region_bounds: &[&ast::Lifetime],\n-                                  principal_trait_ref: Option<&ty::PolyTraitRef<'tcx>>,\n+                                  principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>,\n                                   builtin_bounds: ty::BuiltinBounds)\n                                   -> Option<ty::Region>\n {\n@@ -1557,7 +1630,7 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // No explicit region bound specified. Therefore, examine trait\n     // bounds and see if we can derive region bounds from those.\n     let derived_region_bounds =\n-        ty::object_region_bounds(tcx, principal_trait_ref, builtin_bounds);\n+        ty::object_region_bounds(tcx, principal_trait_ref.as_ref(), builtin_bounds);\n \n     // If there are no derived region bounds, then report back that we\n     // can find no region bound.\n@@ -1592,7 +1665,7 @@ fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     rscope: &RS,\n     span: Span,\n     region_bounds: &[&ast::Lifetime],\n-    principal_trait_ref: Option<&ty::PolyTraitRef<'tcx>>, // None for closures\n+    principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for closures\n     builtin_bounds: ty::BuiltinBounds)\n     -> ty::Region\n {\n@@ -1660,6 +1733,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n                         if ty::try_add_builtin_trait(tcx,\n                                                      trait_did,\n                                                      &mut builtin_bounds) {\n+                            // FIXME(#20302) -- we should check for things like Copy<T>\n                             continue; // success\n                         }\n                     }\n@@ -1683,3 +1757,13 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n         region_bounds: region_bounds,\n     }\n }\n+\n+fn prohibit_projections<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                              bindings: &[ConvertedBinding<'tcx>])\n+{\n+    for binding in bindings.iter().take(1) {\n+        tcx.sess.span_err(\n+            binding.span,\n+            \"associated type bindings are not allowed here\");\n+    }\n+}"}, {"sha": "0e8b5b373f14471c4c05b89f93d46474a8ee97a8", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -11,7 +11,7 @@\n use middle::def;\n use middle::infer;\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n-use middle::subst::{Subst, Substs};\n+use middle::subst::{Substs};\n use middle::ty::{mod, Ty};\n use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n use check::{check_expr_coercable_to_type, demand, FnCtxt, Expectation};\n@@ -79,9 +79,9 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         }\n         ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n             let const_did = tcx.def_map.borrow()[pat.id].clone().def_id();\n-            let const_pty = ty::lookup_item_type(tcx, const_did);\n-            fcx.write_ty(pat.id, const_pty.ty);\n-            demand::suptype(fcx, pat.span, expected, const_pty.ty);\n+            let const_scheme = ty::lookup_item_type(tcx, const_did);\n+            fcx.write_ty(pat.id, const_scheme.ty);\n+            demand::suptype(fcx, pat.span, expected, const_scheme.ty);\n         }\n         ast::PatIdent(bm, ref path, ref sub) if pat_is_binding(&tcx.def_map, pat) => {\n             let typ = fcx.local_ty(pat.span, pat.id);\n@@ -142,7 +142,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 check_pat(pcx, &**inner, inner_ty);\n             } else {\n                 fcx.write_error(pat.id);\n-                check_pat(pcx, &**inner, ty::mk_err());\n+                check_pat(pcx, &**inner, tcx.types.err);\n             }\n         }\n         ast::PatRegion(ref inner) => {\n@@ -162,7 +162,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 check_pat(pcx, &**inner, inner_ty);\n             } else {\n                 fcx.write_error(pat.id);\n-                check_pat(pcx, &**inner, ty::mk_err());\n+                check_pat(pcx, &**inner, tcx.types.err);\n             }\n         }\n         ast::PatVec(ref before, ref slice, ref after) => {\n@@ -285,11 +285,11 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n \n         if let Some(ref e) = arm.guard {\n-            check_expr_has_type(fcx, &**e, ty::mk_bool());\n+            check_expr_has_type(fcx, &**e, tcx.types.bool);\n         }\n \n         if ty::type_is_error(result_ty) || ty::type_is_error(bty) {\n-            ty::mk_err()\n+            tcx.types.err\n         } else {\n             let (origin, expected, found) = match match_src {\n                 /* if-let construct without an else block */\n@@ -339,7 +339,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n             fcx.write_error(pat.id);\n \n             for field in fields.iter() {\n-                check_pat(pcx, &*field.node.pat, ty::mk_err());\n+                check_pat(pcx, &*field.node.pat, tcx.types.err);\n             }\n             return;\n         },\n@@ -358,7 +358,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n                     fcx.write_error(pat.id);\n \n                     for field in fields.iter() {\n-                        check_pat(pcx, &*field.node.pat, ty::mk_err());\n+                        check_pat(pcx, &*field.node.pat, tcx.types.err);\n                     }\n                     return;\n                 }\n@@ -395,32 +395,39 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n     let enum_def = def.variant_def_ids()\n         .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n \n-    let ctor_pty = ty::lookup_item_type(tcx, enum_def);\n-    let path_ty = if ty::is_fn_ty(ctor_pty.ty) {\n-        ty::Polytype {\n-            ty: ty::ty_fn_ret(ctor_pty.ty).unwrap(),\n-            ..ctor_pty\n+    let ctor_scheme = ty::lookup_item_type(tcx, enum_def);\n+    let path_scheme = if ty::is_fn_ty(ctor_scheme.ty) {\n+        ty::TypeScheme {\n+            ty: ty::ty_fn_ret(ctor_scheme.ty).unwrap(),\n+            ..ctor_scheme\n         }\n     } else {\n-        ctor_pty\n+        ctor_scheme\n     };\n-    instantiate_path(pcx.fcx, path, path_ty, def, pat.span, pat.id);\n+    instantiate_path(pcx.fcx, path, path_scheme, def, pat.span, pat.id);\n \n     let pat_ty = fcx.node_ty(pat.id);\n     demand::eqtype(fcx, pat.span, expected, pat_ty);\n \n     let real_path_ty = fcx.node_ty(pat.id);\n-    let (arg_tys, kind_name) = match real_path_ty.sty {\n+    let (arg_tys, kind_name): (Vec<_>, &'static str) = match real_path_ty.sty {\n         ty::ty_enum(enum_def_id, expected_substs)\n-            if def == def::DefVariant(enum_def_id, def.def_id(), false) => {\n+            if def == def::DefVariant(enum_def_id, def.def_id(), false) =>\n+        {\n             let variant = ty::enum_variant_with_id(tcx, enum_def_id, def.def_id());\n-            (variant.args.iter().map(|t| t.subst(tcx, expected_substs)).collect::<Vec<_>>(),\n-                \"variant\")\n+            (variant.args.iter()\n+                         .map(|t| fcx.instantiate_type_scheme(pat.span, expected_substs, t))\n+                         .collect(),\n+             \"variant\")\n         }\n         ty::ty_struct(struct_def_id, expected_substs) => {\n             let struct_fields = ty::struct_fields(tcx, struct_def_id, expected_substs);\n-            (struct_fields.iter().map(|field| field.mt.ty).collect::<Vec<_>>(),\n-                \"struct\")\n+            (struct_fields.iter()\n+                          .map(|field| fcx.instantiate_type_scheme(pat.span,\n+                                                                   expected_substs,\n+                                                                   &field.mt.ty))\n+                          .collect(),\n+             \"struct\")\n         }\n         _ => {\n             let name = pprust::path_to_string(path);\n@@ -430,7 +437,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n \n             if let Some(ref subpats) = *subpats {\n                 for pat in subpats.iter() {\n-                    check_pat(pcx, &**pat, ty::mk_err());\n+                    check_pat(pcx, &**pat, tcx.types.err);\n                 }\n             }\n             return;\n@@ -448,7 +455,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n                       subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"}, kind_name);\n \n             for pat in subpats.iter() {\n-                check_pat(pcx, &**pat, ty::mk_err());\n+                check_pat(pcx, &**pat, tcx.types.err);\n             }\n         } else {\n             span_err!(tcx.sess, pat.span, E0023,\n@@ -458,7 +465,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n                       arg_tys.len(), if arg_tys.len() == 1 {\"\"} else {\"s\"});\n \n             for pat in subpats.iter() {\n-                check_pat(pcx, &**pat, ty::mk_err());\n+                check_pat(pcx, &**pat, tcx.types.err);\n             }\n         }\n     }\n@@ -496,7 +503,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 span_note!(tcx.sess, *occupied.get(),\n                     \"field `{}` previously bound here\",\n                     token::get_ident(field.ident));\n-                ty::mk_err()\n+                tcx.types.err\n             }\n             Vacant(vacant) => {\n                 vacant.set(span);\n@@ -506,7 +513,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                             \"struct `{}` does not have a field named `{}`\",\n                             ty::item_path_str(tcx, struct_id),\n                             token::get_ident(field.ident));\n-                        ty::mk_err()\n+                        tcx.types.err\n                     })\n             }\n         };"}, {"sha": "081959a4efa4a9f8e64255d4355bfd4a26887867", "filename": "src/librustc_typeck/check/assoc.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,93 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::infer::InferCtxt;\n+use middle::traits::{ObligationCause, ObligationCauseCode, FulfillmentContext};\n+use middle::ty::{mod, RegionEscape, HasProjectionTypes, Ty};\n+use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n+use syntax::ast;\n+use syntax::codemap::Span;\n+\n+pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n+                                                fulfillment_cx: &mut FulfillmentContext<'tcx>,\n+                                                span: Span,\n+                                                body_id: ast::NodeId,\n+                                                value: &T)\n+                                                -> T\n+    where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone\n+{\n+    let value = infcx.resolve_type_vars_if_possible(value);\n+\n+    if !value.has_projection_types() {\n+        return value.clone();\n+    }\n+\n+    let mut normalizer = AssociatedTypeNormalizer { span: span,\n+                                                    body_id: body_id,\n+                                                    infcx: infcx,\n+                                                    fulfillment_cx: fulfillment_cx };\n+    value.fold_with(&mut normalizer)\n+}\n+\n+struct AssociatedTypeNormalizer<'a,'tcx:'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    fulfillment_cx: &'a mut FulfillmentContext<'tcx>,\n+    span: Span,\n+    body_id: ast::NodeId,\n+}\n+\n+impl<'a,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        // We don't want to normalize associated types that occur inside of region\n+        // binders, because they may contain bound regions, and we can't cope with that.\n+        //\n+        // Example:\n+        //\n+        //     for<'a> fn(<T as Foo<&'a>>::A)\n+        //\n+        // Instead of normalizing `<T as Foo<&'a>>::A` here, we'll\n+        // normalize it when we instantiate those bound regions (which\n+        // should occur eventually).\n+\n+        match ty.sty {\n+            ty::ty_projection(ref data) if !data.has_escaping_regions() => { // (*)\n+\n+                // (*) This is kind of hacky -- we need to be able to\n+                // handle normalization within binders because\n+                // otherwise we wind up a need to normalize when doing\n+                // trait matching (since you can have a trait\n+                // obligation like `for<'a> T::B : Fn(&'a int)`), but\n+                // we can't normalize with bound regions in scope. So\n+                // far now we just ignore binders but only normalize\n+                // if all bound regions are gone (and then we still\n+                // have to renormalize whenever we instantiate a\n+                // binder). It would be better to normalize in a\n+                // binding-aware fashion.\n+\n+                let cause =\n+                    ObligationCause::new(\n+                        self.span,\n+                        self.body_id,\n+                        ObligationCauseCode::MiscObligation);\n+                self.fulfillment_cx\n+                    .normalize_projection_type(self.infcx,\n+                                               data.clone(),\n+                                               cause)\n+            }\n+            _ => {\n+                ty_fold::super_fold_ty(self, ty)\n+            }\n+        }\n+    }\n+}"}, {"sha": "eba040e7ea8b6ad226ab6ad9515f80d4d816b689", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -14,8 +14,9 @@ use super::{check_fn, Expectation, FnCtxt};\n \n use astconv;\n use middle::infer;\n+use middle::region::CodeExtent;\n use middle::subst;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, ToPolyTraitRef, Ty};\n use rscope::RegionScope;\n use syntax::abi;\n use syntax::ast;\n@@ -47,7 +48,7 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n             match expected_sig_and_kind {\n                 None => { // doesn't look like an unboxed closure\n                     let region = astconv::opt_ast_region_to_region(fcx,\n-                                                                   fcx.infcx(),\n+                                                                   fcx,\n                                                                    expr.span,\n                                                                    &None);\n \n@@ -116,7 +117,7 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         abi::RustCall,\n         expected_sig);\n \n-    let region = match fcx.infcx().anon_regions(expr.span, 1) {\n+    let region = match fcx.anon_regions(expr.span, 1) {\n         Err(_) => {\n             fcx.ccx.tcx.sess.span_bug(expr.span,\n                                       \"can't make anon regions here?!\")\n@@ -132,10 +133,13 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n \n     fcx.write_ty(expr.id, closure_type);\n \n+    let fn_sig =\n+        ty::liberate_late_bound_regions(fcx.tcx(), CodeExtent::from_node_id(body.id), &fn_ty.sig);\n+\n     check_fn(fcx.ccx,\n              ast::Unsafety::Normal,\n              expr.id,\n-             &fn_ty.sig,\n+             &fn_sig,\n              decl,\n              expr.id,\n              &*body,\n@@ -168,7 +172,10 @@ fn deduce_unboxed_closure_expectations_from_expected_type<'a,'tcx>(\n {\n     match expected_ty.sty {\n         ty::ty_trait(ref object_type) => {\n-            deduce_unboxed_closure_expectations_from_trait_ref(fcx, &object_type.principal)\n+            let trait_ref =\n+                object_type.principal_trait_ref_with_self_ty(fcx.tcx(),\n+                                                             fcx.tcx().types.err);\n+            deduce_unboxed_closure_expectations_from_trait_ref(fcx, &trait_ref)\n         }\n         ty::ty_infer(ty::TyVar(vid)) => {\n             deduce_unboxed_closure_expectations_from_obligations(fcx, vid)\n@@ -227,23 +234,21 @@ fn deduce_unboxed_closure_expectations_from_obligations<'a,'tcx>(\n {\n     // Here `expected_ty` is known to be a type inference variable.\n     for obligation in fcx.inh.fulfillment_cx.borrow().pending_obligations().iter() {\n-        match obligation.trait_ref {\n-            ty::Predicate::Trait(ref trait_ref) => {\n+        match obligation.predicate {\n+            ty::Predicate::Trait(ref trait_predicate) => {\n+                let trait_ref = trait_predicate.to_poly_trait_ref();\n                 let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n                 match self_ty.sty {\n                     ty::ty_infer(ty::TyVar(v)) if expected_vid == v => { }\n                     _ => { continue; }\n                 }\n \n-                match deduce_unboxed_closure_expectations_from_trait_ref(fcx, &**trait_ref) {\n+                match deduce_unboxed_closure_expectations_from_trait_ref(fcx, &trait_ref) {\n                     Some(e) => { return Some(e); }\n                     None => { }\n                 }\n             }\n-            ty::Predicate::Equate(..) |\n-            ty::Predicate::RegionOutlives(..) |\n-            ty::Predicate::TypeOutlives(..) => {\n-            }\n+            _ => { }\n         }\n     }\n \n@@ -290,7 +295,7 @@ fn check_boxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                 (&ty::UniqTraitStore, _) => ast::Once,\n                 (&ty::RegionTraitStore(..), _) => ast::Many,\n             };\n-            (Some(sig), onceness, cenv.bounds)\n+            (Some(sig), onceness, cenv.bounds.clone())\n         }\n         _ => {\n             // Not an error! Means we're inferring the closure type\n@@ -311,7 +316,7 @@ fn check_boxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                        decl,\n                                        abi::Rust,\n                                        expected_sig);\n-    let fty_sig = fn_ty.sig.clone();\n+    let fn_sig = fn_ty.sig.clone();\n     let fty = ty::mk_closure(tcx, fn_ty);\n     debug!(\"check_expr_fn fty={}\", fcx.infcx().ty_to_string(fty));\n \n@@ -326,10 +331,13 @@ fn check_boxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         ty::UniqTraitStore => (ast::Unsafety::Normal, expr.id)\n     };\n \n+    let fn_sig =\n+        ty::liberate_late_bound_regions(tcx, CodeExtent::from_node_id(body.id), &fn_sig);\n+\n     check_fn(fcx.ccx,\n              inherited_style,\n              inherited_style_id,\n-             &fty_sig,\n+             &fn_sig,\n              &*decl,\n              expr.id,\n              &*body,"}, {"sha": "a189f780b0c270e2956f256acac4f2f84970752f", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 51, "deletions": 49, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -10,8 +10,9 @@\n \n use super::probe;\n \n-use check::{mod, FnCtxt, NoPreference, PreferMutLvalue, callee};\n-use middle::subst::{mod, Subst};\n+use check::{mod, FnCtxt, NoPreference, PreferMutLvalue, callee, demand};\n+use middle::mem_categorization::Typer;\n+use middle::subst::{mod};\n use middle::traits;\n use middle::ty::{mod, Ty};\n use middle::ty::{MethodCall, MethodCallee, MethodObject, MethodOrigin,\n@@ -41,12 +42,6 @@ struct InstantiatedMethodSig<'tcx> {\n     /// the method.\n     all_substs: subst::Substs<'tcx>,\n \n-    /// Substitution to use when adding obligations from the method\n-    /// bounds. Normally equal to `all_substs` except for object\n-    /// receivers. See FIXME in instantiate_method_sig() for\n-    /// explanation.\n-    method_bounds_substs: subst::Substs<'tcx>,\n-\n     /// Generic bounds on the method's parameters which must be added\n     /// as pending obligations.\n     method_bounds: ty::GenericBounds<'tcx>,\n@@ -102,15 +97,15 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // Create the final signature for the method, replacing late-bound regions.\n         let InstantiatedMethodSig {\n-            method_sig, all_substs, method_bounds_substs, method_bounds\n+            method_sig, all_substs, method_bounds\n         } = self.instantiate_method_sig(&pick, all_substs);\n         let method_self_ty = method_sig.inputs[0];\n \n         // Unify the (adjusted) self type with what the method expects.\n         self.unify_receivers(self_ty, method_self_ty);\n \n         // Add any trait/regions obligations specified on the method's type parameters.\n-        self.add_obligations(&pick, &method_bounds_substs, &method_bounds);\n+        self.add_obligations(&pick, &all_substs, &method_bounds);\n \n         // Create the final `MethodCallee`.\n         let fty = ty::mk_bare_fn(self.tcx(), None, self.tcx().mk_bare_fn(ty::BareFnTy {\n@@ -227,14 +222,14 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     let upcast_poly_trait_ref =\n                         this.upcast(original_poly_trait_ref.clone(), trait_def_id);\n                     let upcast_trait_ref =\n-                        this.replace_late_bound_regions_with_fresh_var(&*upcast_poly_trait_ref);\n+                        this.replace_late_bound_regions_with_fresh_var(&upcast_poly_trait_ref);\n                     debug!(\"original_poly_trait_ref={} upcast_trait_ref={} target_trait={}\",\n                            original_poly_trait_ref.repr(this.tcx()),\n                            upcast_trait_ref.repr(this.tcx()),\n                            trait_def_id.repr(this.tcx()));\n                     let substs = upcast_trait_ref.substs.clone();\n                     let origin = MethodTraitObject(MethodObject {\n-                        trait_ref: Rc::new(upcast_trait_ref),\n+                        trait_ref: upcast_trait_ref,\n                         object_trait_id: trait_def_id,\n                         method_num: method_num,\n                         real_index: real_index,\n@@ -254,9 +249,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 // parameters from the trait ([$A,$B]), not those from\n                 // the impl ([$A,$B,$C]) not the receiver type ([$C]).\n                 let impl_polytype = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n-                let impl_trait_ref = ty::impl_trait_ref(self.tcx(), impl_def_id)\n-                                     .unwrap()\n-                                     .subst(self.tcx(), &impl_polytype.substs);\n+                let impl_trait_ref =\n+                    self.fcx.instantiate_type_scheme(\n+                        self.span,\n+                        &impl_polytype.substs,\n+                        &ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap());\n                 let origin = MethodTypeParam(MethodParam { trait_ref: impl_trait_ref.clone(),\n                                                            method_num: method_num });\n                 (impl_trait_ref.substs.clone(), origin)\n@@ -284,9 +281,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             probe::WhereClausePick(ref poly_trait_ref, method_num) => {\n                 // Where clauses can have bound regions in them. We need to instantiate\n                 // those to convert from a poly-trait-ref to a trait-ref.\n-                let trait_ref = self.replace_late_bound_regions_with_fresh_var(&**poly_trait_ref);\n+                let trait_ref = self.replace_late_bound_regions_with_fresh_var(&*poly_trait_ref);\n                 let substs = trait_ref.substs.clone();\n-                let origin = MethodTypeParam(MethodParam { trait_ref: Rc::new(trait_ref),\n+                let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n                                                            method_num: method_num });\n                 (substs, origin)\n             }\n@@ -342,7 +339,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             } else if num_supplied_types != num_method_types {\n                 span_err!(self.tcx().sess, self.span, E0036,\n                     \"incorrect number of type parameters given for this method\");\n-                Vec::from_elem(num_method_types, ty::mk_err())\n+                Vec::from_elem(num_method_types, self.tcx().types.err)\n             } else {\n                 supplied_method_types\n             }\n@@ -400,60 +397,57 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // type `Trait`, this leads to an obligation\n         // `Trait:Trait`. Until such time we DST is fully implemented,\n         // that obligation is not necessarily satisfied. (In the\n-        // future, it would be.)\n-        //\n-        // To sidestep this, we overwrite the binding for `Self` with\n-        // `err` (just for trait objects) when we generate the\n-        // obligations.  This causes us to generate the obligation\n-        // `err:Trait`, and the error type is considered to implement\n-        // all traits, so we're all good. Hack hack hack.\n-        let method_bounds_substs = match pick.kind {\n+        // future, it would be.) But we know that the true `Self` DOES implement\n+        // the trait. So we just delete this requirement. Hack hack hack.\n+        let mut method_bounds = pick.method_ty.generics.to_bounds(self.tcx(), &all_substs);\n+        match pick.kind {\n             probe::ObjectPick(..) => {\n-                let mut temp_substs = all_substs.clone();\n-                temp_substs.types.get_mut_slice(subst::SelfSpace)[0] = ty::mk_err();\n-                temp_substs\n+                assert_eq!(method_bounds.predicates.get_slice(subst::SelfSpace).len(), 1);\n+                method_bounds.predicates.pop(subst::SelfSpace);\n             }\n-            _ => {\n-                all_substs.clone()\n-            }\n-        };\n-        let method_bounds = pick.method_ty.generics.to_bounds(self.tcx(), &method_bounds_substs);\n+            _ => { }\n+        }\n+        let method_bounds = self.fcx.normalize_associated_types_in(self.span, &method_bounds);\n \n         debug!(\"method_bounds after subst = {}\",\n                method_bounds.repr(self.tcx()));\n \n-        // Substitute the type/early-bound-regions into the method\n-        // signature. In addition, the method signature may bind\n-        // late-bound regions, so instantiate those.\n-        let method_sig = pick.method_ty.fty.sig.subst(self.tcx(), &all_substs);\n-        let method_sig = self.replace_late_bound_regions_with_fresh_var(&method_sig);\n-\n+        // Instantiate late-bound regions and substitute the trait\n+        // parameters into the method type to get the actual method type.\n+        //\n+        // NB: Instantiate late-bound regions first so that\n+        // `instantiate_type_scheme` can normalize associated types that\n+        // may reference those regions.\n+        let method_sig = self.replace_late_bound_regions_with_fresh_var(&pick.method_ty.fty.sig);\n         debug!(\"late-bound lifetimes from method instantiated, method_sig={}\",\n                method_sig.repr(self.tcx()));\n \n+        let method_sig = self.fcx.instantiate_type_scheme(self.span, &all_substs, &method_sig);\n+        debug!(\"type scheme substituted, method_sig={}\",\n+               method_sig.repr(self.tcx()));\n+\n         InstantiatedMethodSig {\n             method_sig: method_sig,\n             all_substs: all_substs,\n-            method_bounds_substs: method_bounds_substs,\n             method_bounds: method_bounds,\n         }\n     }\n \n     fn add_obligations(&mut self,\n                        pick: &probe::Pick<'tcx>,\n-                       method_bounds_substs: &subst::Substs<'tcx>,\n+                       all_substs: &subst::Substs<'tcx>,\n                        method_bounds: &ty::GenericBounds<'tcx>) {\n-        debug!(\"add_obligations: pick={} method_bounds_substs={} method_bounds={}\",\n+        debug!(\"add_obligations: pick={} all_substs={} method_bounds={}\",\n                pick.repr(self.tcx()),\n-               method_bounds_substs.repr(self.tcx()),\n+               all_substs.repr(self.tcx()),\n                method_bounds.repr(self.tcx()));\n \n         self.fcx.add_obligations_for_parameters(\n             traits::ObligationCause::misc(self.span, self.fcx.body_id),\n             method_bounds);\n \n         self.fcx.add_default_region_param_bounds(\n-            method_bounds_substs,\n+            all_substs,\n             self.call_expr);\n     }\n \n@@ -533,7 +527,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             // Don't retry the first one or we might infinite loop!\n             if i != 0 {\n                 match expr.node {\n-                    ast::ExprIndex(ref base_expr, _) => {\n+                    ast::ExprIndex(ref base_expr, ref index_expr) => {\n                         let mut base_adjustment =\n                             match self.fcx.inh.adjustments.borrow().get(&base_expr.id) {\n                                 Some(&ty::AdjustDerefRef(ref adr)) => (*adr).clone(),\n@@ -569,14 +563,22 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                 &**base_expr,\n                                 Some(&ty::AdjustDerefRef(base_adjustment.clone())));\n \n-                        check::try_index_step(\n+                        let result = check::try_index_step(\n                             self.fcx,\n                             MethodCall::expr(expr.id),\n                             *expr,\n                             &**base_expr,\n                             adjusted_base_ty,\n                             base_adjustment,\n                             PreferMutLvalue);\n+\n+                        if let Some((input_ty, return_ty)) = result {\n+                            let index_expr_ty = self.fcx.expr_ty(&**index_expr);\n+                            demand::suptype(self.fcx, index_expr.span, input_ty, index_expr_ty);\n+\n+                            let expr_ty = self.fcx.expr_ty(&**expr);\n+                            demand::suptype(self.fcx, expr.span, expr_ty, return_ty);\n+                        }\n                     }\n                     ast::ExprUnary(ast::UnDeref, ref base_expr) => {\n                         // if this is an overloaded deref, then re-evaluate with\n@@ -626,9 +628,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn upcast(&mut self,\n-              source_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n+              source_trait_ref: ty::PolyTraitRef<'tcx>,\n               target_trait_def_id: ast::DefId)\n-              -> Rc<ty::PolyTraitRef<'tcx>>\n+              -> ty::PolyTraitRef<'tcx>\n     {\n         for super_trait_ref in traits::supertraits(self.tcx(), source_trait_ref.clone()) {\n             if super_trait_ref.def_id() == target_trait_def_id {"}, {"sha": "1971be117605c4655213053dba716baa32de7b19", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -16,7 +16,6 @@ use check::{impl_self_ty};\n use check::vtable;\n use check::vtable::select_new_fcx_obligations;\n use middle::subst;\n-use middle::subst::{Subst};\n use middle::traits;\n use middle::ty::*;\n use middle::ty;\n@@ -156,18 +155,15 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n         }\n     };\n \n-    let number_assoc_types = trait_def.generics.types.len(subst::AssocSpace);\n-    let assoc_types = fcx.inh.infcx.next_ty_vars(number_assoc_types);\n-\n     assert_eq!(trait_def.generics.types.len(subst::FnSpace), 0);\n     assert!(trait_def.generics.regions.is_empty());\n \n     // Construct a trait-reference `self_ty : Trait<input_tys>`\n-    let substs = subst::Substs::new_trait(input_types, Vec::new(), assoc_types, self_ty);\n+    let substs = subst::Substs::new_trait(input_types, Vec::new(), self_ty);\n     let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, fcx.tcx().mk_substs(substs)));\n \n     // Construct an obligation\n-    let poly_trait_ref = Rc::new(ty::Binder((*trait_ref).clone()));\n+    let poly_trait_ref = trait_ref.to_poly_trait_ref();\n     let obligation = traits::Obligation::misc(span,\n                                               fcx.body_id,\n                                               poly_trait_ref.as_predicate());\n@@ -191,18 +187,21 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     debug!(\"lookup_in_trait_adjusted: method_num={} method_ty={}\",\n            method_num, method_ty.repr(fcx.tcx()));\n \n-    // Substitute the trait parameters into the method type and\n-    // instantiate late-bound regions to get the actual method type.\n-    let ref bare_fn_ty = method_ty.fty;\n-    let fn_sig = bare_fn_ty.sig.subst(tcx, trait_ref.substs);\n+    // Instantiate late-bound regions and substitute the trait\n+    // parameters into the method type to get the actual method type.\n+    //\n+    // NB: Instantiate late-bound regions first so that\n+    // `instantiate_type_scheme` can normalize associated types that\n+    // may reference those regions.\n     let fn_sig = fcx.infcx().replace_late_bound_regions_with_fresh_var(span,\n                                                                        infer::FnCall,\n-                                                                       &fn_sig).0;\n+                                                                       &method_ty.fty.sig).0;\n+    let fn_sig = fcx.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n     let transformed_self_ty = fn_sig.inputs[0];\n     let fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(ty::BareFnTy {\n         sig: ty::Binder(fn_sig),\n-        unsafety: bare_fn_ty.unsafety,\n-        abi: bare_fn_ty.abi.clone(),\n+        unsafety: method_ty.fty.unsafety,\n+        abi: method_ty.fty.abi.clone(),\n     }));\n \n     debug!(\"lookup_in_trait_adjusted: matched method fty={} obligation={}\","}, {"sha": "1a9e124521e0f4d9f78c9a5a24b6339adcf9ba10", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -18,7 +18,7 @@ use middle::fast_reject;\n use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, Ty, ToPolyTraitRef};\n use middle::ty_fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n@@ -61,7 +61,7 @@ enum CandidateKind<'tcx> {\n     ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n                            subst::Substs<'tcx>, MethodIndex),\n     UnboxedClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClauseCandidate(Rc<ty::PolyTraitRef<'tcx>>, MethodIndex),\n+    WhereClauseCandidate(ty::PolyTraitRef<'tcx>, MethodIndex),\n }\n \n pub struct Pick<'tcx> {\n@@ -76,7 +76,7 @@ pub enum PickKind<'tcx> {\n     ObjectPick(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n     ExtensionImplPick(/* Impl */ ast::DefId, MethodIndex),\n     TraitPick(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClausePick(/* Trait */ Rc<ty::PolyTraitRef<'tcx>>, MethodIndex),\n+    WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>, MethodIndex),\n }\n \n pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError>;\n@@ -235,7 +235,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         match self_ty.sty {\n             ty::ty_trait(box ref data) => {\n                 self.assemble_inherent_candidates_from_object(self_ty, data);\n-                self.assemble_inherent_impl_candidates_for_type(data.principal.def_id());\n+                self.assemble_inherent_impl_candidates_for_type(data.principal_def_id());\n             }\n             ty::ty_enum(did, _) |\n             ty::ty_struct(did, _) |\n@@ -308,7 +308,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(), self_ty);\n         self.elaborate_bounds(&[trait_ref.clone()], false, |this, new_trait_ref, m, method_num| {\n             let vtable_index =\n-                get_method_index(tcx, &*new_trait_ref, trait_ref.clone(), method_num);\n+                get_method_index(tcx, &new_trait_ref, trait_ref.clone(), method_num);\n \n             let xform_self_ty = this.xform_self_ty(&m, new_trait_ref.substs());\n \n@@ -330,13 +330,16 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             .iter()\n             .filter_map(|predicate| {\n                 match *predicate {\n-                    ty::Predicate::Trait(ref trait_ref) => {\n-                        match trait_ref.self_ty().sty {\n-                            ty::ty_param(ref p) if *p == param_ty => Some(trait_ref.clone()),\n+                    ty::Predicate::Trait(ref trait_predicate) => {\n+                        match trait_predicate.0.trait_ref.self_ty().sty {\n+                            ty::ty_param(ref p) if *p == param_ty => {\n+                                Some(trait_predicate.to_poly_trait_ref())\n+                            }\n                             _ => None\n                         }\n                     }\n                     ty::Predicate::Equate(..) |\n+                    ty::Predicate::Projection(..) |\n                     ty::Predicate::RegionOutlives(..) |\n                     ty::Predicate::TypeOutlives(..) => {\n                         None\n@@ -381,10 +384,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     // create the candidates.\n     fn elaborate_bounds(\n         &mut self,\n-        bounds: &[Rc<ty::PolyTraitRef<'tcx>>],\n+        bounds: &[ty::PolyTraitRef<'tcx>],\n         num_includes_types: bool,\n         mk_cand: for<'b> |this: &mut ProbeContext<'b, 'tcx>,\n-                          tr: Rc<ty::PolyTraitRef<'tcx>>,\n+                          tr: ty::PolyTraitRef<'tcx>,\n                           m: Rc<ty::Method<'tcx>>,\n                           method_num: uint|)\n     {\n@@ -996,7 +999,7 @@ fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n // to a trait and its supertraits.\n fn get_method_index<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           trait_ref: &ty::PolyTraitRef<'tcx>,\n-                          subtrait: Rc<ty::PolyTraitRef<'tcx>>,\n+                          subtrait: ty::PolyTraitRef<'tcx>,\n                           n_method: uint) -> uint {\n     // We need to figure the \"real index\" of the method in a\n     // listing of all the methods of an object. We do this by"}, {"sha": "8069d00dda826fc8f4aa002b305e890e29d92267", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 421, "deletions": 282, "changes": 703, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -91,12 +91,12 @@ use middle::pat_util::{mod, pat_id_map};\n use middle::region::CodeExtent;\n use middle::subst::{mod, Subst, Substs, VecPerParamSpace, ParamSpace};\n use middle::traits;\n-use middle::ty::{FnSig, VariantInfo, Polytype};\n+use middle::ty::{FnSig, VariantInfo, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, HasProjectionTypes, Ty};\n use middle::ty::liberate_late_bound_regions;\n use middle::ty::{MethodCall, MethodCallee, MethodMap, ObjectCastMap};\n-use middle::ty_fold::TypeFolder;\n+use middle::ty_fold::{TypeFolder, TypeFoldable};\n use rscope::RegionScope;\n use session::Session;\n use {CrateCtxt, lookup_def_ccx, no_params, require_same_types};\n@@ -120,6 +120,7 @@ use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::visit::{mod, Visitor};\n \n+mod assoc;\n pub mod _match;\n pub mod vtable;\n pub mod writeback;\n@@ -348,6 +349,17 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n         }\n     }\n+\n+    fn normalize_associated_types_in<T>(&self, span: Span, body_id: ast::NodeId, value: &T) -> T\n+        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes\n+    {\n+        let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n+        assoc::normalize_associated_types_in(&self.infcx,\n+                                             &mut *fulfillment_cx, span,\n+                                             body_id,\n+                                             value)\n+    }\n+\n }\n \n // Used by check_const and check_enum_variants\n@@ -386,7 +398,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &ast::Ty) {\n         match t.node {\n             ast::TyFixedLengthVec(_, ref expr) => {\n-                check_const_in_type(self.ccx, &**expr, ty::mk_uint());\n+                check_const_in_type(self.ccx, &**expr, self.ccx.tcx.types.uint);\n             }\n             _ => {}\n         }\n@@ -414,16 +426,21 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            decl: &ast::FnDecl,\n                            body: &ast::Block,\n                            id: ast::NodeId,\n-                           fty: Ty<'tcx>,\n+                           raw_fty: Ty<'tcx>,\n                            param_env: ty::ParameterEnvironment<'tcx>) {\n-    // Compute the fty from point of view of inside fn\n-    // (replace any type-scheme with a type)\n-    let fty = fty.subst(ccx.tcx, &param_env.free_substs);\n-\n-    match fty.sty {\n+    match raw_fty.sty {\n         ty::ty_bare_fn(_, ref fn_ty) => {\n             let inh = Inherited::new(ccx.tcx, param_env);\n-            let fcx = check_fn(ccx, fn_ty.unsafety, id, &fn_ty.sig,\n+\n+            // Compute the fty from point of view of inside fn.\n+            let fn_sig =\n+                fn_ty.sig.subst(ccx.tcx, &inh.param_env.free_substs);\n+            let fn_sig =\n+                liberate_late_bound_regions(ccx.tcx, CodeExtent::from_node_id(body.id), &fn_sig);\n+            let fn_sig =\n+                inh.normalize_associated_types_in(body.span, body.id, &fn_sig);\n+\n+            let fcx = check_fn(ccx, fn_ty.unsafety, id, &fn_sig,\n                                decl, id, body, &inh);\n \n             vtable::select_all_fcx_obligations_or_error(&fcx);\n@@ -505,7 +522,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n         match t.node {\n             ast::TyFixedLengthVec(ref ty, ref count_expr) => {\n                 self.visit_ty(&**ty);\n-                check_expr_with_hint(self.fcx, &**count_expr, ty::mk_uint());\n+                check_expr_with_hint(self.fcx, &**count_expr, self.fcx.tcx().types.uint);\n             }\n             _ => visit::walk_ty(self, t)\n         }\n@@ -527,19 +544,16 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                       unsafety: ast::Unsafety,\n                       unsafety_id: ast::NodeId,\n-                      fn_sig: &ty::PolyFnSig<'tcx>,\n+                      fn_sig: &ty::FnSig<'tcx>,\n                       decl: &ast::FnDecl,\n                       fn_id: ast::NodeId,\n                       body: &ast::Block,\n                       inherited: &'a Inherited<'a, 'tcx>)\n-                      -> FnCtxt<'a, 'tcx> {\n+                      -> FnCtxt<'a, 'tcx>\n+{\n     let tcx = ccx.tcx;\n     let err_count_on_creation = tcx.sess.err_count();\n \n-    // First, we have to replace any bound regions in the fn type with free ones.\n-    // The free region references will be bound the node_id of the body block.\n-    let fn_sig = liberate_late_bound_regions(tcx, CodeExtent::from_node_id(body.id), fn_sig);\n-\n     let arg_tys = fn_sig.inputs[];\n     let ret_ty = fn_sig.output;\n \n@@ -771,9 +785,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 // corresponding method definition in the trait.\n                 let opt_trait_method_ty =\n                     trait_items.iter()\n-                               .find(|ti| {\n-                                   ti.name() == impl_item_ty.name()\n-                               });\n+                               .find(|ti| ti.name() == impl_item_ty.name());\n                 match opt_trait_method_ty {\n                     Some(trait_method_ty) => {\n                         match (trait_method_ty, &impl_item_ty) {\n@@ -917,6 +929,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n            impl_trait_ref.repr(tcx));\n \n     let infcx = infer::new_infer_ctxt(tcx);\n+    let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n     let trait_to_impl_substs = &impl_trait_ref.substs;\n \n@@ -1034,21 +1047,15 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // this kind of equivalency just fine.\n \n     // Create mapping from impl to skolemized.\n-    let skol_tps =\n-        impl_m.generics.types.map(\n-            |d| ty::mk_param_from_def(tcx, d));\n-    let skol_regions =\n-        impl_m.generics.regions.map(\n-            |l| ty::free_region_from_def(impl_m_body_id, l));\n-    let impl_to_skol_substs =\n-        subst::Substs::new(skol_tps.clone(), skol_regions.clone());\n+    let impl_param_env = ty::construct_parameter_environment(tcx, &impl_m.generics, impl_m_body_id);\n+    let impl_to_skol_substs = &impl_param_env.free_substs;\n \n     // Create mapping from trait to skolemized.\n     let trait_to_skol_substs =\n         trait_to_impl_substs\n-        .subst(tcx, &impl_to_skol_substs)\n-        .with_method(skol_tps.get_slice(subst::FnSpace).to_vec(),\n-                     skol_regions.get_slice(subst::FnSpace).to_vec());\n+        .subst(tcx, impl_to_skol_substs)\n+        .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n+                     impl_to_skol_substs.regions().get_slice(subst::FnSpace).to_vec());\n \n     // Check region bounds.\n     if !check_region_bounds_on_impl_method(tcx,\n@@ -1057,7 +1064,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                            &trait_m.generics,\n                                            &impl_m.generics,\n                                            &trait_to_skol_substs,\n-                                           &impl_to_skol_substs) {\n+                                           impl_to_skol_substs) {\n         return;\n     }\n \n@@ -1120,7 +1127,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         for impl_trait_bound in impl_param_bounds.trait_bounds.iter() {\n             debug!(\"compare_impl_method(): impl-trait-bound subst\");\n             let impl_trait_bound =\n-                impl_trait_bound.subst(tcx, &impl_to_skol_substs);\n+                impl_trait_bound.subst(tcx, impl_to_skol_substs);\n \n             // There may be late-bound regions from the impl in the\n             // impl's bound, so \"liberate\" those. Note that the\n@@ -1134,7 +1141,6 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     debug!(\"compare_impl_method(): trait-bound subst\");\n                     let trait_bound =\n                         trait_bound.subst(tcx, &trait_to_skol_substs);\n-                    let infcx = infer::new_infer_ctxt(tcx);\n                     infer::mk_sub_poly_trait_refs(&infcx,\n                                                   true,\n                                                   infer::Misc(impl_m_span),\n@@ -1153,33 +1159,95 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n     }\n \n+    // We now need to check that the signature of the impl method is\n+    // compatible with that of the trait method. We do this by\n+    // checking that `impl_fty <: trait_fty`.\n+    //\n+    // FIXME. Unfortunately, this doesn't quite work right now because\n+    // associated type normalization is not integrated into subtype\n+    // checks. For the comparison to be valid, we need to\n+    // normalize the associated types in the impl/trait methods\n+    // first. However, because function types bind regions, just\n+    // calling `normalize_associated_types_in` would have no effect on\n+    // any associated types appearing in the fn arguments or return\n+    // type.\n+\n+\n     // Compute skolemized form of impl and trait method tys.\n     let impl_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(impl_m.fty.clone()));\n-    let impl_fty = impl_fty.subst(tcx, &impl_to_skol_substs);\n+    let impl_fty = impl_fty.subst(tcx, impl_to_skol_substs);\n     let trait_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(trait_m.fty.clone()));\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n-    // Check the impl method type IM is a subtype of the trait method\n-    // type TM. To see why this makes sense, think of a vtable. The\n-    // expected type of the function pointers in the vtable is the\n-    // type TM of the trait method.  The actual type will be the type\n-    // IM of the impl method. Because we know that IM <: TM, that\n-    // means that anywhere a TM is expected, a IM will do instead. In\n-    // other words, anyone expecting to call a method with the type\n-    // from the trait, can safely call a method with the type from the\n-    // impl instead.\n-    debug!(\"checking trait method for compatibility: impl ty {}, trait ty {}\",\n-           impl_fty.repr(tcx),\n-           trait_fty.repr(tcx));\n-    match infer::mk_subty(&infcx, false, infer::MethodCompatCheck(impl_m_span),\n-                          impl_fty, trait_fty) {\n-        Ok(()) => {}\n-        Err(ref terr) => {\n+    let err = infcx.try(|snapshot| {\n+        let origin = infer::MethodCompatCheck(impl_m_span);\n+\n+        let (impl_sig, _) =\n+            infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n+                                                            infer::HigherRankedType,\n+                                                            &impl_m.fty.sig);\n+        let impl_sig =\n+            impl_sig.subst(tcx, impl_to_skol_substs);\n+        let impl_sig =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &mut fulfillment_cx,\n+                                                 impl_m_span,\n+                                                 impl_m_body_id,\n+                                                 &impl_sig);\n+        let impl_fty =\n+            ty::mk_bare_fn(tcx,\n+                           None,\n+                           tcx.mk_bare_fn(ty::BareFnTy { unsafety: impl_m.fty.unsafety,\n+                                                         abi: impl_m.fty.abi,\n+                                                         sig: ty::Binder(impl_sig) }));\n+        debug!(\"compare_impl_method: impl_fty={}\",\n+               impl_fty.repr(tcx));\n+\n+        let (trait_sig, skol_map) =\n+            infcx.skolemize_late_bound_regions(&trait_m.fty.sig, snapshot);\n+        let trait_sig =\n+            trait_sig.subst(tcx, &trait_to_skol_substs);\n+        let trait_sig =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &mut fulfillment_cx,\n+                                                 impl_m_span,\n+                                                 impl_m_body_id,\n+                                                 &trait_sig);\n+        let trait_fty =\n+            ty::mk_bare_fn(tcx,\n+                           None,\n+                           tcx.mk_bare_fn(ty::BareFnTy { unsafety: trait_m.fty.unsafety,\n+                                                         abi: trait_m.fty.abi,\n+                                                         sig: ty::Binder(trait_sig) }));\n+\n+        debug!(\"compare_impl_method: trait_fty={}\",\n+               trait_fty.repr(tcx));\n+\n+        try!(infer::mk_subty(&infcx, false, origin, impl_fty, trait_fty));\n+\n+        infcx.leak_check(&skol_map, snapshot)\n+    });\n+\n+    match err {\n+        Ok(()) => { }\n+        Err(terr) => {\n+            debug!(\"checking trait method for compatibility: impl ty {}, trait ty {}\",\n+                   impl_fty.repr(tcx),\n+                   trait_fty.repr(tcx));\n             span_err!(tcx.sess, impl_m_span, E0053,\n-                \"method `{}` has an incompatible type for trait: {}\",\n-                token::get_name(trait_m.name),\n-                ty::type_err_to_str(tcx, terr));\n-            ty::note_and_explain_type_err(tcx, terr);\n+                      \"method `{}` has an incompatible type for trait: {}\",\n+                      token::get_name(trait_m.name),\n+                      ty::type_err_to_str(tcx, &terr));\n+            return;\n+        }\n+    }\n+\n+    // Run the fulfillment context to completion to accommodate any\n+    // associated type normalizations that may have occurred.\n+    match fulfillment_cx.select_all_or_error(&infcx, &impl_param_env, tcx) {\n+        Ok(()) => { }\n+        Err(errors) => {\n+            traits::report_fulfillment_errors(&infcx, &errors);\n         }\n     }\n \n@@ -1356,7 +1424,7 @@ fn check_cast(fcx: &FnCtxt,\n         return\n     }\n \n-    if !ty::type_is_sized(fcx.tcx(), t_1) {\n+    if !fcx.type_is_known_to_be_sized(t_1) {\n         let tstr = fcx.infcx().ty_to_string(t_1);\n         fcx.type_error_message(span, |actual| {\n             format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n@@ -1510,7 +1578,7 @@ fn check_cast(fcx: &FnCtxt,\n impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n+    fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx> {\n         ty::lookup_item_type(self.tcx(), id)\n     }\n \n@@ -1526,52 +1594,50 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         self.infcx().next_ty_var()\n     }\n \n-    fn associated_types_of_trait_are_valid(&self, _: Ty, _: ast::DefId)\n-                                           -> bool {\n-        false\n+    fn projected_ty_from_poly_trait_ref(&self,\n+                                        span: Span,\n+                                        poly_trait_ref: ty::PolyTraitRef<'tcx>,\n+                                        item_name: ast::Name)\n+                                        -> Ty<'tcx>\n+    {\n+        let (trait_ref, _) =\n+            self.infcx().replace_late_bound_regions_with_fresh_var(\n+                span,\n+                infer::LateBoundRegionConversionTime::AssocTypeProjection(item_name),\n+                &poly_trait_ref);\n+\n+        self.normalize_associated_type(span, trait_ref, item_name)\n     }\n \n-    fn associated_type_binding(&self,\n-                               span: Span,\n-                               _: Option<Ty<'tcx>>,\n-                               _: ast::DefId,\n-                               _: ast::DefId)\n-                               -> Option<Ty<'tcx>> {\n-        self.tcx().sess.span_err(span, \"unsupported associated type binding\");\n-        Some(ty::mk_err())\n+    fn projected_ty(&self,\n+                    span: Span,\n+                    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                    item_name: ast::Name)\n+                    -> Ty<'tcx>\n+    {\n+        self.normalize_associated_type(span, trait_ref, item_name)\n     }\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n-    pub fn infcx<'b>(&'b self) -> &'b infer::InferCtxt<'a, 'tcx> {\n+    pub fn infcx(&self) -> &infer::InferCtxt<'a, 'tcx> {\n         &self.inh.infcx\n     }\n \n+    pub fn param_env(&self) -> &ty::ParameterEnvironment<'tcx> {\n+        &self.inh.param_env\n+    }\n+\n     pub fn sess(&self) -> &Session {\n         &self.tcx().sess\n     }\n \n     pub fn err_count_since_creation(&self) -> uint {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n-}\n-\n-impl<'a, 'tcx> RegionScope for infer::InferCtxt<'a, 'tcx> {\n-    fn default_region_bound(&self, span: Span) -> Option<ty::Region> {\n-        Some(self.next_region_var(infer::MiscVariable(span)))\n-    }\n-\n-    fn anon_regions(&self, span: Span, count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n-        Ok(Vec::from_fn(count, |_| {\n-            self.next_region_var(infer::MiscVariable(span))\n-        }))\n-    }\n-}\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn tag(&self) -> String {\n         format!(\"{}\", self as *const FnCtxt)\n     }\n@@ -1605,7 +1671,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn write_object_cast(&self,\n                              key: ast::NodeId,\n-                             trait_ref: Rc<ty::PolyTraitRef<'tcx>>) {\n+                             trait_ref: ty::PolyTraitRef<'tcx>) {\n         debug!(\"write_object_cast key={} trait_ref={}\",\n                key, trait_ref.repr(self.tcx()));\n         self.inh.object_cast_map.borrow_mut().insert(key, trait_ref);\n@@ -1656,6 +1722,50 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.inh.adjustments.borrow_mut().insert(node_id, adj);\n     }\n \n+    /// Basically whenever we are converting from a type scheme into\n+    /// the fn body space, we always want to normalize associated\n+    /// types as well. This function combines the two.\n+    fn instantiate_type_scheme<T>(&self,\n+                                  span: Span,\n+                                  substs: &Substs<'tcx>,\n+                                  value: &T)\n+                                  -> T\n+        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes + Repr<'tcx>\n+    {\n+        let value = value.subst(self.tcx(), substs);\n+        let result = self.normalize_associated_types_in(span, &value);\n+        debug!(\"instantiate_type_scheme(value={}, substs={}) = {}\",\n+               value.repr(self.tcx()),\n+               substs.repr(self.tcx()),\n+               result.repr(self.tcx()));\n+        result\n+    }\n+\n+    fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n+        where T : TypeFoldable<'tcx> + Clone + HasProjectionTypes\n+    {\n+        self.inh.normalize_associated_types_in(span, self.body_id, value)\n+    }\n+\n+    fn normalize_associated_type(&self,\n+                                 span: Span,\n+                                 trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                                 item_name: ast::Name)\n+                                 -> Ty<'tcx>\n+    {\n+        let cause = traits::ObligationCause::new(span,\n+                                                 self.body_id,\n+                                                 traits::ObligationCauseCode::MiscObligation);\n+        self.inh.fulfillment_cx\n+            .borrow_mut()\n+            .normalize_projection_type(self.infcx(),\n+                                       ty::ProjectionTy {\n+                                           trait_ref: trait_ref,\n+                                           item_name: item_name,\n+                                       },\n+                                       cause)\n+    }\n+\n     fn register_adjustment_obligations(&self,\n                                        span: Span,\n                                        adj: &ty::AutoAdjustment<'tcx>) {\n@@ -1728,29 +1838,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Also returns the substitution from the type parameters on `def_id` to the fresh variables.\n     /// Registers any trait obligations specified on `def_id` at the same time.\n     ///\n-    /// Note that function is only intended to be used with types (notably, not impls). This is\n+    /// Note that function is only intended to be used with types (notably, not fns). This is\n     /// because it doesn't do any instantiation of late-bound regions.\n     pub fn instantiate_type(&self,\n                             span: Span,\n                             def_id: ast::DefId)\n                             -> TypeAndSubsts<'tcx>\n     {\n-        let polytype =\n+        let type_scheme =\n             ty::lookup_item_type(self.tcx(), def_id);\n         let substs =\n             self.infcx().fresh_substs_for_generics(\n                 span,\n-                &polytype.generics);\n+                &type_scheme.generics);\n         let bounds =\n-            polytype.generics.to_bounds(self.tcx(), &substs);\n+            type_scheme.generics.to_bounds(self.tcx(), &substs);\n         self.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n                 span,\n                 self.body_id,\n                 traits::ItemObligation(def_id)),\n             &bounds);\n         let monotype =\n-            polytype.ty.subst(self.tcx(), &substs);\n+            self.instantiate_type_scheme(span, &substs, &type_scheme.ty);\n \n         TypeAndSubsts {\n             ty: monotype,\n@@ -1762,7 +1872,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.write_ty(node_id, ty::mk_nil(self.tcx()));\n     }\n     pub fn write_error(&self, node_id: ast::NodeId) {\n-        self.write_ty(node_id, ty::mk_err());\n+        self.write_ty(node_id, self.tcx().types.err);\n     }\n \n     pub fn require_type_meets(&self,\n@@ -1792,13 +1902,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.require_type_is_sized(self.expr_ty(expr), expr.span, code);\n     }\n \n+    pub fn type_is_known_to_be_sized(&self,\n+                                     ty: Ty<'tcx>)\n+                                     -> bool\n+    {\n+        traits::type_known_to_meet_builtin_bound(self.infcx(),\n+                                                 self.param_env(),\n+                                                 ty,\n+                                                 ty::BoundSized)\n+    }\n+\n     pub fn register_builtin_bound(&self,\n                                   ty: Ty<'tcx>,\n                                   builtin_bound: ty::BuiltinBound,\n                                   cause: traits::ObligationCause<'tcx>)\n     {\n         self.inh.fulfillment_cx.borrow_mut()\n-            .register_builtin_bound(self.tcx(), ty, builtin_bound, cause);\n+            .register_builtin_bound(self.infcx(), ty, builtin_bound, cause);\n     }\n \n     pub fn register_predicate(&self,\n@@ -1809,11 +1929,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.inh.fulfillment_cx\n             .borrow_mut()\n-            .register_predicate(self.tcx(), obligation);\n+            .register_predicate(self.infcx(), obligation);\n     }\n \n     pub fn to_ty(&self, ast_t: &ast::Ty) -> Ty<'tcx> {\n-        let t = ast_ty_to_ty(self, self.infcx(), ast_t);\n+        let t = ast_ty_to_ty(self, self, ast_t);\n \n         let mut bounds_checker = wf::BoundsChecker::new(self,\n                                                         ast_t.span,\n@@ -1953,7 +2073,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                       cause: traits::ObligationCause<'tcx>)\n     {\n         let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n-        fulfillment_cx.register_region_obligation(self.tcx(), ty, region, cause);\n+        fulfillment_cx.register_region_obligation(self.infcx(), ty, region, cause);\n     }\n \n     pub fn add_default_region_param_bounds(&self,\n@@ -2003,7 +2123,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n-#[deriving(Copy, Show,PartialEq,Eq)]\n+impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n+    fn default_region_bound(&self, span: Span) -> Option<ty::Region> {\n+        Some(self.infcx().next_region_var(infer::MiscVariable(span)))\n+    }\n+\n+    fn anon_regions(&self, span: Span, count: uint)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n+        Ok(Vec::from_fn(count, |_| {\n+            self.infcx().next_region_var(infer::MiscVariable(span))\n+        }))\n+    }\n+}\n+\n+#[deriving(Copy, Show, PartialEq, Eq)]\n pub enum LvaluePreference {\n     PreferMutLvalue,\n     NoPreference\n@@ -2058,7 +2191,7 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n     span_err!(fcx.tcx().sess, sp, E0055,\n         \"reached the recursion limit while auto-dereferencing {}\",\n         base_ty.repr(fcx.tcx()));\n-    (ty::mk_err(), 0, None)\n+    (fcx.tcx().types.err, 0, None)\n }\n \n /// Attempts to resolve a call expression as an overloaded call.\n@@ -2214,7 +2347,6 @@ fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-\n /// Checks for a `Slice` (or `SliceMut`) impl at the relevant level of autoderef. If it finds one,\n /// installs method info and returns type of method (else None).\n fn try_overloaded_slice_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -2322,7 +2454,7 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match ty::index(adjusted_ty) {\n         Some(ty) => {\n             fcx.write_adjustment(base_expr.id, base_expr.span, ty::AdjustDerefRef(adjustment));\n-            return Some((ty::mk_uint(), ty));\n+            return Some((fcx.tcx().types.uint, ty));\n         }\n \n         None => { }\n@@ -2384,7 +2516,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Err(ref err_string) => {\n             fcx.tcx().sess.span_err(iterator_expr.span,\n                                     err_string[]);\n-            return ty::mk_err()\n+            return fcx.tcx().types.err\n         }\n     };\n \n@@ -2412,7 +2544,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 maybe try .iter()\",\n                                                 ty_string)[]);\n             }\n-            ty::mk_err()\n+            fcx.tcx().types.err\n         }\n     };\n     let return_type = check_method_argument_types(fcx,\n@@ -2433,27 +2565,27 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let return_type = match return_type {\n                 ty::FnConverging(return_type) =>\n                     structurally_resolved_type(fcx, iterator_expr.span, return_type),\n-                ty::FnDiverging => ty::mk_err()\n+                ty::FnDiverging => fcx.tcx().types.err\n             };\n             match return_type.sty {\n                 ty::ty_enum(_, ref substs)\n                         if !substs.types.is_empty_in(subst::TypeSpace) => {\n                     *substs.types.get(subst::TypeSpace, 0)\n                 }\n                 ty::ty_err => {\n-                    ty::mk_err()\n+                    fcx.tcx().types.err\n                 }\n                 _ => {\n                     fcx.tcx().sess.span_err(iterator_expr.span,\n                                             format!(\"`next` method of the `Iterator` \\\n                                                     trait has an unexpected type `{}`\",\n                                                     fcx.infcx().ty_to_string(return_type))\n                                             []);\n-                    ty::mk_err()\n+                    fcx.tcx().types.err\n                 }\n             }\n         }\n-        None => ty::mk_err()\n+        None => fcx.tcx().types.err\n     }\n }\n \n@@ -2466,7 +2598,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          tuple_arguments: TupleArgumentsFlag)\n                                          -> ty::FnOutput<'tcx> {\n     if ty::type_is_error(method_fn_ty) {\n-        let err_inputs = err_args(args_no_rcvr.len());\n+        let err_inputs = err_args(fcx.tcx(), args_no_rcvr.len());\n \n         let err_inputs = match tuple_arguments {\n             DontTupleArguments => err_inputs,\n@@ -2481,7 +2613,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              autoref_args,\n                              false,\n                              tuple_arguments);\n-        ty::FnConverging(ty::mk_err())\n+        ty::FnConverging(fcx.tcx().types.err)\n     } else {\n         match method_fn_ty.sty {\n             ty::ty_bare_fn(_, ref fty) => {\n@@ -2536,7 +2668,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         if arg_types.len() == 1 {\"\"} else {\"s\"},\n                         args.len(),\n                         if args.len() == 1 {\" was\"} else {\"s were\"});\n-                    err_args(args.len())\n+                    err_args(fcx.tcx(), args.len())\n                 } else {\n                     (*arg_types).clone()\n                 }\n@@ -2545,7 +2677,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 span_err!(tcx.sess, sp, E0059,\n                     \"cannot use call notation; the first type parameter \\\n                      for the function trait is neither a tuple nor unit\");\n-                err_args(args.len())\n+                err_args(fcx.tcx(), args.len())\n             }\n         }\n     } else if expected_arg_count == supplied_arg_count {\n@@ -2561,7 +2693,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 if expected_arg_count == 1 {\"\"} else {\"s\"},\n                 supplied_arg_count,\n                 if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n-            err_args(supplied_arg_count)\n+            err_args(fcx.tcx(), supplied_arg_count)\n         }\n     } else {\n         span_err!(tcx.sess, sp, E0061,\n@@ -2570,7 +2702,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if expected_arg_count == 1 {\"\"} else {\"s\"},\n             supplied_arg_count,\n             if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n-        err_args(supplied_arg_count)\n+        err_args(fcx.tcx(), supplied_arg_count)\n     };\n \n     debug!(\"check_argument_types: formal_tys={}\",\n@@ -2626,7 +2758,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                 // mismatch impl/trait method phase no need to\n                                 // ICE here.\n                                 // See: #11450\n-                                formal_ty = ty::mk_err();\n+                                formal_ty = tcx.types.err;\n                             }\n                         }\n                     }\n@@ -2677,8 +2809,8 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n // FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n-fn err_args<'tcx>(len: uint) -> Vec<Ty<'tcx>> {\n-    Vec::from_fn(len, |_| ty::mk_err())\n+fn err_args<'tcx>(tcx: &ty::ctxt<'tcx>, len: uint) -> Vec<Ty<'tcx>> {\n+    Vec::from_fn(len, |_| tcx.types.err)\n }\n \n fn write_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -2701,27 +2833,28 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match lit.node {\n         ast::LitStr(..) => ty::mk_str_slice(tcx, tcx.mk_region(ty::ReStatic), ast::MutImmutable),\n         ast::LitBinary(..) => {\n-            ty::mk_slice(tcx, tcx.mk_region(ty::ReStatic),\n-                         ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable })\n-        }\n-        ast::LitByte(_) => ty::mk_u8(),\n-        ast::LitChar(_) => ty::mk_char(),\n-        ast::LitInt(_, ast::SignedIntLit(t, _)) => ty::mk_mach_int(t),\n-        ast::LitInt(_, ast::UnsignedIntLit(t)) => ty::mk_mach_uint(t),\n+            ty::mk_slice(tcx,\n+                         tcx.mk_region(ty::ReStatic),\n+                         ty::mt{ ty: tcx.types.u8, mutbl: ast::MutImmutable })\n+        }\n+        ast::LitByte(_) => tcx.types.u8,\n+        ast::LitChar(_) => tcx.types.char,\n+        ast::LitInt(_, ast::SignedIntLit(t, _)) => ty::mk_mach_int(tcx, t),\n+        ast::LitInt(_, ast::UnsignedIntLit(t)) => ty::mk_mach_uint(tcx, t),\n         ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n             let opt_ty = expected.map_to_option(fcx, |ty| {\n                 match ty.sty {\n                     ty::ty_int(_) | ty::ty_uint(_) => Some(ty),\n-                    ty::ty_char => Some(ty::mk_mach_uint(ast::TyU8)),\n-                    ty::ty_ptr(..) => Some(ty::mk_mach_uint(ast::TyU)),\n-                    ty::ty_bare_fn(..) => Some(ty::mk_mach_uint(ast::TyU)),\n+                    ty::ty_char => Some(tcx.types.u8),\n+                    ty::ty_ptr(..) => Some(tcx.types.uint),\n+                    ty::ty_bare_fn(..) => Some(tcx.types.uint),\n                     _ => None\n                 }\n             });\n             opt_ty.unwrap_or_else(\n                 || ty::mk_int_var(tcx, fcx.infcx().next_int_var_id()))\n         }\n-        ast::LitFloat(_, t) => ty::mk_mach_float(t),\n+        ast::LitFloat(_, t) => ty::mk_mach_float(tcx, t),\n         ast::LitFloatUnsuffixed(_) => {\n             let opt_ty = expected.map_to_option(fcx, |ty| {\n                 match ty.sty {\n@@ -2732,7 +2865,7 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             opt_ty.unwrap_or_else(\n                 || ty::mk_float_var(tcx, fcx.infcx().next_float_var_id()))\n         }\n-        ast::LitBool(_) => ty::mk_bool()\n+        ast::LitBool(_) => tcx.types.bool\n     }\n }\n \n@@ -2813,7 +2946,7 @@ pub fn impl_self_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let rps = fcx.inh.infcx.region_vars_for_defs(span, rps);\n     let tps = fcx.inh.infcx.next_ty_vars(n_tps);\n     let substs = subst::Substs::new_type(tps, rps);\n-    let substd_ty = raw_ty.subst(tcx, &substs);\n+    let substd_ty = fcx.instantiate_type_scheme(span, &substs, &raw_ty);\n \n     TypeAndSubsts { substs: substs, ty: substd_ty }\n }\n@@ -2907,8 +3040,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         // In that case, we check each argument against \"error\" in order to\n         // set up all the node type bindings.\n         let error_fn_sig = ty::Binder(FnSig {\n-            inputs: err_args(args.len()),\n-            output: ty::FnConverging(ty::mk_err()),\n+            inputs: err_args(fcx.tcx(), args.len()),\n+            output: ty::FnConverging(fcx.tcx().types.err),\n             variadic: false\n         });\n \n@@ -2923,12 +3056,18 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n         };\n \n-        // Replace any bound regions that appear in the function\n-        // signature with region variables\n+        // Replace any late-bound regions that appear in the function\n+        // signature with region variables. We also have to\n+        // renormalize the associated types at this point, since they\n+        // previously appeared within a `Binder<>` and hence would not\n+        // have been normalized before.\n         let fn_sig =\n             fcx.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n                                                                   infer::FnCall,\n                                                                   fn_sig).0;\n+        let fn_sig =\n+            fcx.normalize_associated_types_in(call_expr.span,\n+                                              &fn_sig);\n \n         // Call the generic checker.\n         check_argument_types(fcx,\n@@ -2975,7 +3114,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             Err(error) => {\n                 method::report_error(fcx, method_name.span, expr_t, method_name.node.name, error);\n                 fcx.write_error(expr.id);\n-                ty::mk_err()\n+                fcx.tcx().types.err\n             }\n         };\n \n@@ -3001,7 +3140,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  id: ast::NodeId,\n                                  sp: Span,\n                                  expected: Expectation<'tcx>) {\n-        check_expr_has_type(fcx, cond_expr, ty::mk_bool());\n+        check_expr_has_type(fcx, cond_expr, fcx.tcx().types.bool);\n \n         let expected = expected.adjust_for_branches(fcx);\n         check_block_with_expected(fcx, then_blk, expected);\n@@ -3028,7 +3167,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         let cond_ty = fcx.expr_ty(cond_expr);\n         let if_ty = if ty::type_is_error(cond_ty) {\n-            ty::mk_err()\n+            fcx.tcx().types.err\n         } else {\n             branches_ty\n         };\n@@ -3100,22 +3239,22 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                             autoref_args,\n                                             DontTupleArguments) {\n                     ty::FnConverging(result_type) => result_type,\n-                    ty::FnDiverging => ty::mk_err()\n+                    ty::FnDiverging => fcx.tcx().types.err\n                 }\n             }\n             None => {\n                 unbound_method();\n                 // Check the args anyway\n                 // so we get all the error messages\n-                let expected_ty = ty::mk_err();\n+                let expected_ty = fcx.tcx().types.err;\n                 check_method_argument_types(fcx,\n                                             op_ex.span,\n                                             expected_ty,\n                                             op_ex,\n                                             args.as_slice(),\n                                             autoref_args,\n                                             DontTupleArguments);\n-                ty::mk_err()\n+                fcx.tcx().types.err\n             }\n         }\n     }\n@@ -3141,7 +3280,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op) {\n             // Shift is a special case: rhs must be uint, no matter what lhs is\n-            check_expr_has_type(fcx, &**rhs, ty::mk_uint());\n+            check_expr_has_type(fcx, &**rhs, fcx.tcx().types.uint);\n             fcx.write_ty(expr.id, lhs_t);\n             return;\n         }\n@@ -3168,12 +3307,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                 lhs_t,\n                                 None\n                             );\n-                            ty::mk_err()\n+                            fcx.tcx().types.err\n                         } else {\n                             lhs_t\n                         }\n                     } else {\n-                        ty::mk_bool()\n+                        fcx.tcx().types.bool\n                     }\n                 },\n                 _ => lhs_t,\n@@ -3215,7 +3354,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                    lhs_t,\n                                    None);\n             check_expr(fcx, &**rhs);\n-            ty::mk_err()\n+            fcx.tcx().types.err\n         };\n \n         fcx.write_ty(expr.id, result_t);\n@@ -3251,7 +3390,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             ast::BiNe => (\"ne\", lang.eq_trait()),\n             ast::BiAnd | ast::BiOr => {\n                 check_expr(fcx, &**rhs);\n-                return ty::mk_err();\n+                return tcx.types.err;\n             }\n         };\n         lookup_op_method(fcx, ex, lhs_resolved_t, token::intern(name),\n@@ -3424,7 +3563,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         // Typecheck each field.\n         for field in ast_fields.iter() {\n-            let mut expected_field_type = ty::mk_err();\n+            let mut expected_field_type = tcx.types.err;\n \n             let pair = class_field_map.get(&field.ident.node.name).map(|x| *x);\n             match pair {\n@@ -3531,7 +3670,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        base_expr.is_none(),\n                                        None);\n         if ty::type_is_error(fcx.node_ty(id)) {\n-            struct_type = ty::mk_err();\n+            struct_type = tcx.types.err;\n         }\n \n         // Check the base expression if necessary.\n@@ -3620,7 +3759,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           if !checked {\n               span_err!(tcx.sess, expr.span, E0066,\n                   \"only the managed heap and exchange heap are currently supported\");\n-              fcx.write_ty(id, ty::mk_err());\n+              fcx.write_ty(id, tcx.types.err);\n           }\n       }\n \n@@ -3720,7 +3859,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 dereferenced\", actual)\n                                     }, oprnd_t, None);\n                                 }\n-                                ty::mk_err()\n+                                tcx.types.err\n                             }\n                         }\n                     };\n@@ -3777,7 +3916,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         let tm = ty::mt { ty: fcx.expr_ty(&**oprnd), mutbl: mutbl };\n         let oprnd_t = if ty::type_is_error(tm.ty) {\n-            ty::mk_err()\n+            tcx.types.err\n         } else {\n             // Note: at this point, we cannot say what the best lifetime\n             // is to use for resulting pointer.  We want to use the\n@@ -3815,7 +3954,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprPath(ref pth) => {\n           let defn = lookup_def(fcx, pth.span, id);\n-          let pty = polytype_for_def(fcx, expr.span, defn);\n+          let pty = type_scheme_for_def(fcx, expr.span, defn);\n           instantiate_path(fcx, pth, pty, defn, expr.span, expr.id);\n \n           // We always require that the type provided as the value for\n@@ -3895,7 +4034,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n       }\n       ast::ExprWhile(ref cond, ref body, _) => {\n-        check_expr_has_type(fcx, &**cond, ty::mk_bool());\n+        check_expr_has_type(fcx, &**cond, tcx.types.bool);\n         check_block_no_value(fcx, &**body);\n         let cond_ty = fcx.expr_ty(&**cond);\n         let body_ty = fcx.node_ty(body.id);\n@@ -3975,7 +4114,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprCast(ref e, ref t) => {\n         if let ast::TyFixedLengthVec(_, ref count_expr) = t.node {\n-            check_expr_with_hint(fcx, &**count_expr, ty::mk_uint());\n+            check_expr_with_hint(fcx, &**count_expr, tcx.types.uint);\n         }\n         check_cast(fcx, expr, &**e, &**t);\n       }\n@@ -4006,7 +4145,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprRepeat(ref element, ref count_expr) => {\n-        check_expr_has_type(fcx, &**count_expr, ty::mk_uint());\n+        check_expr_has_type(fcx, &**count_expr, tcx.types.uint);\n         let count = ty::eval_repeat_count(fcx.tcx(), &**count_expr);\n \n         let uty = match expected {\n@@ -4136,7 +4275,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let actual_structure_type = fcx.expr_ty(&*expr);\n         if !ty::type_is_error(actual_structure_type) {\n             let type_and_substs = astconv::ast_path_to_ty_relaxed(fcx,\n-                                                                  fcx.infcx(),\n+                                                                  fcx,\n                                                                   struct_id,\n                                                                   path);\n             match fcx.mk_subty(false,\n@@ -4219,8 +4358,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                              },\n                              base_t,\n                              None);\n-                          fcx.write_ty(idx.id, ty::mk_err());\n-                          fcx.write_ty(id, ty::mk_err())\n+                          fcx.write_ty(idx.id, fcx.tcx().types.err);\n+                          fcx.write_ty(id, fcx.tcx().types.err);\n                       }\n                   }\n                 }\n@@ -4249,7 +4388,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                               fcx.write_ty(id, element_ty);\n                           }\n                           _ => {\n-                              check_expr_has_type(fcx, &**idx, ty::mk_err());\n+                              check_expr_has_type(fcx, &**idx, fcx.tcx().types.err);\n                               fcx.type_error_message(\n                                   expr.span,\n                                   |actual| {\n@@ -4258,7 +4397,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                   },\n                                   base_t,\n                                   None);\n-                              fcx.write_ty(id, ty::mk_err())\n+                              fcx.write_ty(id, fcx.tcx().types.err);\n                           }\n                       }\n                   }\n@@ -4277,19 +4416,21 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           });\n \n           let idx_type = match (t_start, t_end) {\n-            (Some(ty), None) | (None, Some(ty)) => Some(ty),\n-            (Some(t_start), Some(t_end))\n-              if ty::type_is_error(t_start) || ty::type_is_error(t_end) => {\n-                Some(ty::mk_err())\n-            }\n-            (Some(t_start), Some(t_end)) => {\n-                Some(infer::common_supertype(fcx.infcx(),\n-                                             infer::RangeExpression(expr.span),\n-                                             true,\n-                                             t_start,\n-                                             t_end))\n-            }\n-            _ => None\n+              (Some(ty), None) | (None, Some(ty)) => {\n+                  Some(ty)\n+              }\n+              (Some(t_start), Some(t_end)) if (ty::type_is_error(t_start) ||\n+                                               ty::type_is_error(t_end)) => {\n+                  Some(fcx.tcx().types.err)\n+              }\n+              (Some(t_start), Some(t_end)) => {\n+                  Some(infer::common_supertype(fcx.infcx(),\n+                                               infer::RangeExpression(expr.span),\n+                                               true,\n+                                               t_start,\n+                                               t_end))\n+              }\n+              _ => None\n           };\n \n           // Note that we don't check the type of start/end satisfy any\n@@ -4298,7 +4439,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n           let range_type = match idx_type {\n             Some(idx_type) if ty::type_is_error(idx_type) => {\n-                ty::mk_err()\n+                fcx.tcx().types.err\n             }\n             Some(idx_type) => {\n                 // Find the did from the appropriate lang item.\n@@ -4324,7 +4465,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n                 } else {\n                     tcx.sess.span_err(expr.span, \"No lang item for range syntax\");\n-                    ty::mk_err()\n+                    fcx.tcx().types.err\n                 }\n             }\n             None => {\n@@ -4334,7 +4475,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n                 } else {\n                     tcx.sess.span_err(expr.span, \"No lang item for range syntax\");\n-                    ty::mk_err()\n+                    fcx.tcx().types.err\n                 }\n             }\n           };\n@@ -4810,12 +4951,12 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                     let inh = static_inherited_fields(ccx);\n                     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n                     let declty = match hint {\n-                        attr::ReprAny | attr::ReprPacked | attr::ReprExtern => ty::mk_int(),\n+                        attr::ReprAny | attr::ReprPacked | attr::ReprExtern => fcx.tcx().types.int,\n                         attr::ReprInt(_, attr::SignedInt(ity)) => {\n-                            ty::mk_mach_int(ity)\n+                            ty::mk_mach_int(fcx.tcx(), ity)\n                         }\n                         attr::ReprInt(_, attr::UnsignedInt(ity)) => {\n-                            ty::mk_mach_uint(ity)\n+                            ty::mk_mach_uint(fcx.tcx(), ity)\n                         },\n                     };\n                     check_const_with_ty(&fcx, e.span, &**e, declty);\n@@ -4908,10 +5049,10 @@ pub fn lookup_def(fcx: &FnCtxt, sp: Span, id: ast::NodeId) -> def::Def {\n }\n \n // Returns the type parameter count and the type for the given definition.\n-pub fn polytype_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                  sp: Span,\n-                                  defn: def::Def)\n-                                  -> Polytype<'tcx> {\n+pub fn type_scheme_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                     sp: Span,\n+                                     defn: def::Def)\n+                                     -> TypeScheme<'tcx> {\n     match defn {\n       def::DefLocal(nid) | def::DefUpvar(nid, _, _) => {\n           let typ = fcx.local_ty(sp, nid);\n@@ -4927,7 +5068,7 @@ pub fn polytype_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n       def::DefAssociatedTy(..) |\n       def::DefAssociatedPath(..) |\n       def::DefPrimTy(_) |\n-      def::DefTyParam(..)=> {\n+      def::DefTyParam(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found type\");\n       }\n       def::DefMod(..) | def::DefForeignMod(..) => {\n@@ -4955,15 +5096,15 @@ pub fn polytype_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n // number of type parameters and type.\n pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   path: &ast::Path,\n-                                  polytype: Polytype<'tcx>,\n+                                  type_scheme: TypeScheme<'tcx>,\n                                   def: def::Def,\n                                   span: Span,\n                                   node_id: ast::NodeId) {\n-    debug!(\"instantiate_path(path={}, def={}, node_id={}, polytype={})\",\n+    debug!(\"instantiate_path(path={}, def={}, node_id={}, type_scheme={})\",\n            path.repr(fcx.tcx()),\n            def.repr(fcx.tcx()),\n            node_id,\n-           polytype.repr(fcx.tcx()));\n+           type_scheme.repr(fcx.tcx()));\n \n     // We need to extract the type parameters supplied by the user in\n     // the path `path`. Due to the current setup, this is a bit of a\n@@ -5088,8 +5229,8 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // Next, examine the definition, and determine how many type\n     // parameters we expect from each space.\n-    let type_defs = &polytype.generics.types;\n-    let region_defs = &polytype.generics.regions;\n+    let type_defs = &type_scheme.generics.types;\n+    let region_defs = &type_scheme.generics.regions;\n \n     // Now that we have categorized what space the parameters for each\n     // segment belong to, let's sort out the parameters that the user\n@@ -5137,12 +5278,12 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // the fn itself). Those should be replaced with fresh variables\n     // now. These can appear either on the type being referenced, or\n     // on the associated bounds.\n-    let bounds = polytype.generics.to_bounds(fcx.tcx(), &substs);\n+    let bounds = type_scheme.generics.to_bounds(fcx.tcx(), &substs);\n     let (ty_late_bound, bounds) =\n         fcx.infcx().replace_late_bound_regions_with_fresh_var(\n             span,\n             infer::FnCall,\n-            &ty::Binder((polytype.ty, bounds))).0;\n+            &ty::Binder((type_scheme.ty, bounds))).0;\n \n     debug!(\"after late-bounds have been replaced: ty_late_bound={}\", ty_late_bound.repr(fcx.tcx()));\n     debug!(\"after late-bounds have been replaced: bounds={}\", bounds.repr(fcx.tcx()));\n@@ -5153,9 +5294,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // Substitute the values for the type parameters into the type of\n     // the referenced item.\n-    let ty_substituted = ty_late_bound.subst(fcx.tcx(), &substs);\n-\n-    debug!(\"ty_substituted: ty_substituted={}\", ty_substituted.repr(fcx.tcx()));\n+    let ty_substituted = fcx.instantiate_type_scheme(span, &substs, &ty_late_bound);\n \n     fcx.write_ty(node_id, ty_substituted);\n     fcx.write_substs(node_id, ty::ItemSubsts { substs: substs });\n@@ -5243,7 +5382,6 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             span_err!(fcx.tcx().sess, data.bindings[0].span, E0182,\n                       \"unexpected binding of associated item in expression path \\\n                        (only allowed in type paths)\");\n-            substs.types.truncate(subst::ParamSpace::AssocSpace, 0);\n         }\n \n         {\n@@ -5352,7 +5490,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 , found {} parameter(s)\",\n                 qualifier, required_len, provided_len);\n             substs.types.replace(space,\n-                                 Vec::from_elem(desired.len(), ty::mk_err()));\n+                                 Vec::from_elem(desired.len(), fcx.tcx().types.err));\n             return;\n         }\n \n@@ -5436,8 +5574,8 @@ pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n             \"the type of this value must be known in this \\\n              context\".to_string()\n         }, ty, None);\n-        demand::suptype(fcx, sp, ty::mk_err(), ty);\n-        ty = ty::mk_err();\n+        demand::suptype(fcx, sp, fcx.tcx().types.err, ty);\n+        ty = fcx.tcx().types.err;\n     }\n \n     ty\n@@ -5499,7 +5637,8 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n-        ty::mk_param(ccx.tcx, subst::FnSpace, n, local_def(0))\n+        let name = token::intern(format!(\"P{}\", n).as_slice());\n+        ty::mk_param(ccx.tcx, subst::FnSpace, n, name)\n     }\n \n     let tcx = ccx.tcx;\n@@ -5540,7 +5679,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         let (n_tps, inputs, output) = match name.get() {\n             \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n             \"size_of\" |\n-            \"pref_align_of\" | \"min_align_of\" => (1u, Vec::new(), ty::mk_uint()),\n+            \"pref_align_of\" | \"min_align_of\" => (1u, Vec::new(), ccx.tcx.types.uint),\n             \"init\" => (1u, Vec::new(), param(ccx, 0)),\n             \"uninit\" => (1u, Vec::new(), param(ccx, 0)),\n             \"forget\" => (1u, vec!( param(ccx, 0) ), ty::mk_nil(tcx)),\n@@ -5556,8 +5695,8 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                   ),\n                ty::mk_nil(tcx))\n             }\n-            \"needs_drop\" => (1u, Vec::new(), ty::mk_bool()),\n-            \"owns_managed\" => (1u, Vec::new(), ty::mk_bool()),\n+            \"needs_drop\" => (1u, Vec::new(), ccx.tcx.types.bool),\n+            \"owns_managed\" => (1u, Vec::new(), ccx.tcx.types.bool),\n \n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n@@ -5589,7 +5728,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n-                  ty::mk_int()\n+                  ccx.tcx.types.int\n                ),\n                ty::mk_ptr(tcx, ty::mt {\n                    ty: param(ccx, 0),\n@@ -5608,7 +5747,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n-                  ty::mk_uint()\n+                  tcx.types.uint,\n                ),\n                ty::mk_nil(tcx))\n             }\n@@ -5619,129 +5758,129 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n                   }),\n-                  ty::mk_u8(),\n-                  ty::mk_uint()\n+                  tcx.types.u8,\n+                  tcx.types.uint,\n                ),\n                ty::mk_nil(tcx))\n             }\n-            \"sqrtf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"sqrtf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"sqrtf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"sqrtf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n             \"powif32\" => {\n                (0,\n-                vec!( ty::mk_f32(), ty::mk_i32() ),\n-                ty::mk_f32())\n+                vec!( tcx.types.f32, tcx.types.i32 ),\n+                tcx.types.f32)\n             }\n             \"powif64\" => {\n                (0,\n-                vec!( ty::mk_f64(), ty::mk_i32() ),\n-                ty::mk_f64())\n+                vec!( tcx.types.f64, tcx.types.i32 ),\n+                tcx.types.f64)\n             }\n-            \"sinf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"sinf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"cosf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"cosf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"sinf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"sinf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"cosf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"cosf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n             \"powf32\" => {\n                (0,\n-                vec!( ty::mk_f32(), ty::mk_f32() ),\n-                ty::mk_f32())\n+                vec!( tcx.types.f32, tcx.types.f32 ),\n+                tcx.types.f32)\n             }\n             \"powf64\" => {\n                (0,\n-                vec!( ty::mk_f64(), ty::mk_f64() ),\n-                ty::mk_f64())\n-            }\n-            \"expf32\"   => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"expf64\"   => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"exp2f32\"  => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"exp2f64\"  => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"logf32\"   => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"logf64\"   => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"log10f32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"log10f64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"log2f32\"  => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"log2f64\"  => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+                vec!( tcx.types.f64, tcx.types.f64 ),\n+                tcx.types.f64)\n+            }\n+            \"expf32\"   => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"expf64\"   => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"exp2f32\"  => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"exp2f64\"  => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"logf32\"   => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"logf64\"   => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"log10f32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"log10f64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"log2f32\"  => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"log2f64\"  => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n             \"fmaf32\" => {\n                 (0,\n-                 vec!( ty::mk_f32(), ty::mk_f32(), ty::mk_f32() ),\n-                 ty::mk_f32())\n+                 vec!( tcx.types.f32, tcx.types.f32, tcx.types.f32 ),\n+                 tcx.types.f32)\n             }\n             \"fmaf64\" => {\n                 (0,\n-                 vec!( ty::mk_f64(), ty::mk_f64(), ty::mk_f64() ),\n-                 ty::mk_f64())\n-            }\n-            \"fabsf32\"      => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"fabsf64\"      => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"copysignf32\"  => (0, vec!( ty::mk_f32(), ty::mk_f32() ), ty::mk_f32()),\n-            \"copysignf64\"  => (0, vec!( ty::mk_f64(), ty::mk_f64() ), ty::mk_f64()),\n-            \"floorf32\"     => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"floorf64\"     => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"ceilf32\"      => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"ceilf64\"      => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"truncf32\"     => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"truncf64\"     => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"rintf32\"      => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"rintf64\"      => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"nearbyintf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"nearbyintf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"roundf32\"     => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"roundf64\"     => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"ctpop8\"       => (0, vec!( ty::mk_u8()  ), ty::mk_u8()),\n-            \"ctpop16\"      => (0, vec!( ty::mk_u16() ), ty::mk_u16()),\n-            \"ctpop32\"      => (0, vec!( ty::mk_u32() ), ty::mk_u32()),\n-            \"ctpop64\"      => (0, vec!( ty::mk_u64() ), ty::mk_u64()),\n-            \"ctlz8\"        => (0, vec!( ty::mk_u8()  ), ty::mk_u8()),\n-            \"ctlz16\"       => (0, vec!( ty::mk_u16() ), ty::mk_u16()),\n-            \"ctlz32\"       => (0, vec!( ty::mk_u32() ), ty::mk_u32()),\n-            \"ctlz64\"       => (0, vec!( ty::mk_u64() ), ty::mk_u64()),\n-            \"cttz8\"        => (0, vec!( ty::mk_u8()  ), ty::mk_u8()),\n-            \"cttz16\"       => (0, vec!( ty::mk_u16() ), ty::mk_u16()),\n-            \"cttz32\"       => (0, vec!( ty::mk_u32() ), ty::mk_u32()),\n-            \"cttz64\"       => (0, vec!( ty::mk_u64() ), ty::mk_u64()),\n-            \"bswap16\"      => (0, vec!( ty::mk_u16() ), ty::mk_u16()),\n-            \"bswap32\"      => (0, vec!( ty::mk_u32() ), ty::mk_u32()),\n-            \"bswap64\"      => (0, vec!( ty::mk_u64() ), ty::mk_u64()),\n+                 vec!( tcx.types.f64, tcx.types.f64, tcx.types.f64 ),\n+                 tcx.types.f64)\n+            }\n+            \"fabsf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"fabsf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"copysignf32\"  => (0, vec!( tcx.types.f32, tcx.types.f32 ), tcx.types.f32),\n+            \"copysignf64\"  => (0, vec!( tcx.types.f64, tcx.types.f64 ), tcx.types.f64),\n+            \"floorf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"floorf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"ceilf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"ceilf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"truncf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"truncf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"rintf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"rintf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"nearbyintf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"nearbyintf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"roundf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"roundf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"ctpop8\"       => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n+            \"ctpop16\"      => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n+            \"ctpop32\"      => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n+            \"ctpop64\"      => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n+            \"ctlz8\"        => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n+            \"ctlz16\"       => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n+            \"ctlz32\"       => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n+            \"ctlz64\"       => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n+            \"cttz8\"        => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n+            \"cttz16\"       => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n+            \"cttz32\"       => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n+            \"cttz64\"       => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n+            \"bswap16\"      => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n+            \"bswap32\"      => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n+            \"bswap64\"      => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n \n             \"volatile_load\" =>\n                 (1, vec!( ty::mk_imm_ptr(tcx, param(ccx, 0)) ), param(ccx, 0)),\n             \"volatile_store\" =>\n                 (1, vec!( ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0) ), ty::mk_nil(tcx)),\n \n             \"i8_add_with_overflow\" | \"i8_sub_with_overflow\" | \"i8_mul_with_overflow\" =>\n-                (0, vec!(ty::mk_i8(), ty::mk_i8()),\n-                ty::mk_tup(tcx, vec!(ty::mk_i8(), ty::mk_bool()))),\n+                (0, vec!(tcx.types.i8, tcx.types.i8),\n+                ty::mk_tup(tcx, vec!(tcx.types.i8, tcx.types.bool))),\n \n             \"i16_add_with_overflow\" | \"i16_sub_with_overflow\" | \"i16_mul_with_overflow\" =>\n-                (0, vec!(ty::mk_i16(), ty::mk_i16()),\n-                ty::mk_tup(tcx, vec!(ty::mk_i16(), ty::mk_bool()))),\n+                (0, vec!(tcx.types.i16, tcx.types.i16),\n+                ty::mk_tup(tcx, vec!(tcx.types.i16, tcx.types.bool))),\n \n             \"i32_add_with_overflow\" | \"i32_sub_with_overflow\" | \"i32_mul_with_overflow\" =>\n-                (0, vec!(ty::mk_i32(), ty::mk_i32()),\n-                ty::mk_tup(tcx, vec!(ty::mk_i32(), ty::mk_bool()))),\n+                (0, vec!(tcx.types.i32, tcx.types.i32),\n+                ty::mk_tup(tcx, vec!(tcx.types.i32, tcx.types.bool))),\n \n             \"i64_add_with_overflow\" | \"i64_sub_with_overflow\" | \"i64_mul_with_overflow\" =>\n-                (0, vec!(ty::mk_i64(), ty::mk_i64()),\n-                ty::mk_tup(tcx, vec!(ty::mk_i64(), ty::mk_bool()))),\n+                (0, vec!(tcx.types.i64, tcx.types.i64),\n+                ty::mk_tup(tcx, vec!(tcx.types.i64, tcx.types.bool))),\n \n             \"u8_add_with_overflow\" | \"u8_sub_with_overflow\" | \"u8_mul_with_overflow\" =>\n-                (0, vec!(ty::mk_u8(), ty::mk_u8()),\n-                ty::mk_tup(tcx, vec!(ty::mk_u8(), ty::mk_bool()))),\n+                (0, vec!(tcx.types.u8, tcx.types.u8),\n+                ty::mk_tup(tcx, vec!(tcx.types.u8, tcx.types.bool))),\n \n             \"u16_add_with_overflow\" | \"u16_sub_with_overflow\" | \"u16_mul_with_overflow\" =>\n-                (0, vec!(ty::mk_u16(), ty::mk_u16()),\n-                ty::mk_tup(tcx, vec!(ty::mk_u16(), ty::mk_bool()))),\n+                (0, vec!(tcx.types.u16, tcx.types.u16),\n+                ty::mk_tup(tcx, vec!(tcx.types.u16, tcx.types.bool))),\n \n             \"u32_add_with_overflow\" | \"u32_sub_with_overflow\" | \"u32_mul_with_overflow\"=>\n-                (0, vec!(ty::mk_u32(), ty::mk_u32()),\n-                ty::mk_tup(tcx, vec!(ty::mk_u32(), ty::mk_bool()))),\n+                (0, vec!(tcx.types.u32, tcx.types.u32),\n+                ty::mk_tup(tcx, vec!(tcx.types.u32, tcx.types.bool))),\n \n             \"u64_add_with_overflow\" | \"u64_sub_with_overflow\"  | \"u64_mul_with_overflow\" =>\n-                (0, vec!(ty::mk_u64(), ty::mk_u64()),\n-                ty::mk_tup(tcx, vec!(ty::mk_u64(), ty::mk_bool()))),\n+                (0, vec!(tcx.types.u64, tcx.types.u64),\n+                ty::mk_tup(tcx, vec!(tcx.types.u64, tcx.types.bool))),\n \n-            \"return_address\" => (0, vec![], ty::mk_imm_ptr(tcx, ty::mk_u8())),\n+            \"return_address\" => (0, vec![], ty::mk_imm_ptr(tcx, tcx.types.u8)),\n \n-            \"assume\" => (0, vec![ty::mk_bool()], ty::mk_nil(tcx)),\n+            \"assume\" => (0, vec![tcx.types.bool], ty::mk_nil(tcx)),\n \n             ref other => {\n                 span_err!(tcx.sess, it.span, E0093,"}, {"sha": "d01b79068aa2c17a72bbc973fd4c545e30c976b4", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -768,7 +768,7 @@ fn constrain_cast(rcx: &mut Rcx,\n             }\n \n             /*From:*/ (_,\n-            /*To:  */  &ty::ty_trait(box ty::TyTrait { bounds, .. })) => {\n+            /*To:  */  &ty::ty_trait(box ty::TyTrait { ref bounds, .. })) => {\n                 // When T is existentially quantified as a trait\n                 // `Foo+'to`, it must outlive the region bound `'to`.\n                 type_must_outlive(rcx, infer::RelateObjectBound(cast_expr.span),\n@@ -851,15 +851,15 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     }\n \n     match function_type.sty {\n-        ty::ty_closure(box ty::ClosureTy {bounds, ..}) => {\n+        ty::ty_closure(box ty::ClosureTy {ref bounds, ..}) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n                 ensure_free_variable_types_outlive_closure_bound(rcx, bounds, expr, freevars);\n             })\n         }\n         ty::ty_unboxed_closure(_, region, _) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n                 let bounds = ty::region_existential_bound(*region);\n-                ensure_free_variable_types_outlive_closure_bound(rcx, bounds, expr, freevars);\n+                ensure_free_variable_types_outlive_closure_bound(rcx, &bounds, expr, freevars);\n             })\n         }\n         _ => {}\n@@ -870,7 +870,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     /// over values outliving the object's lifetime bound.\n     fn ensure_free_variable_types_outlive_closure_bound(\n         rcx: &mut Rcx,\n-        bounds: ty::ExistentialBounds,\n+        bounds: &ty::ExistentialBounds,\n         expr: &ast::Expr,\n         freevars: &[ty::Freevar])\n     {\n@@ -1848,11 +1848,9 @@ fn param_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // well-formed, then, A must be lower-bounded by `'a`, but we\n     // don't know that this holds from first principles.\n     for &(ref r, ref p) in rcx.region_param_pairs.iter() {\n-        debug!(\"param_ty={}/{} p={}/{}\",\n+        debug!(\"param_ty={} p={}\",\n                param_ty.repr(rcx.tcx()),\n-               param_ty.def_id,\n-               p.repr(rcx.tcx()),\n-               p.def_id);\n+               p.repr(rcx.tcx()));\n         if param_ty == *p {\n             param_bounds.push(*r);\n         }"}, {"sha": "bb051ab15250ca9cdbc97ef764a5f17bcf9a97d9", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -104,7 +104,8 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n \n             ty::ty_enum(def_id, substs) |\n             ty::ty_struct(def_id, substs) => {\n-                self.accumulate_from_adt(ty, def_id, substs)\n+                let item_scheme = ty::lookup_item_type(self.tcx, def_id);\n+                self.accumulate_from_adt(ty, def_id, &item_scheme.generics, substs)\n             }\n \n             ty::ty_vec(t, _) |\n@@ -121,6 +122,18 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                 self.push_param_constraint_from_top(p);\n             }\n \n+            ty::ty_projection(ref data) => {\n+                // `<T as TraitRef<..>>::Name`\n+\n+                // FIXME(#20303) -- gain ability to require that ty_projection : in-scope region,\n+                // like a type parameter\n+\n+                // this seems like a minimal requirement:\n+                let trait_def = ty::lookup_trait_def(self.tcx, data.trait_ref.def_id);\n+                self.accumulate_from_adt(ty, data.trait_ref.def_id,\n+                                         &trait_def.generics, data.trait_ref.substs)\n+            }\n+\n             ty::ty_tup(ref tuptys) => {\n                 for &tupty in tuptys.iter() {\n                     self.accumulate_from_ty(tupty);\n@@ -213,14 +226,12 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n     fn accumulate_from_adt(&mut self,\n                            ty: Ty<'tcx>,\n                            def_id: ast::DefId,\n+                           generics: &ty::Generics<'tcx>,\n                            substs: &Substs<'tcx>)\n     {\n         // The generic declarations from the type, appropriately\n         // substituted for the actual substitutions.\n-        let generics =\n-            ty::lookup_item_type(self.tcx, def_id)\n-            .generics\n-            .subst(self.tcx, substs);\n+        let generics = generics.subst(self.tcx, substs);\n \n         // Variance of each type/region parameter.\n         let variances = ty::item_variances(self.tcx, def_id);"}, {"sha": "23a8643aadcf535da46ce16952766268bba05628", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 147, "deletions": 20, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -9,16 +9,16 @@\n // except according to those terms.\n \n use check::{FnCtxt, structurally_resolved_type};\n-use middle::subst::{FnSpace};\n+use middle::subst::{FnSpace, SelfSpace};\n use middle::traits;\n use middle::traits::{Obligation, ObligationCause};\n use middle::traits::report_fulfillment_errors;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, Ty, AsPredicate};\n use middle::infer;\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n-use util::ppaux::{Repr, ty_to_string};\n+use util::nodemap::FnvHashSet;\n+use util::ppaux::{Repr, UserString};\n \n pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                    cast_expr: &ast::Expr,\n@@ -133,22 +133,46 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  object_trait: &ty::TyTrait<'tcx>,\n                                  span: Span)\n {\n-    let object_trait_ref = object_trait.principal_trait_ref_with_self_ty(tcx, ty::mk_err());\n-    for tr in traits::supertraits(tcx, object_trait_ref) {\n-        check_object_safety_inner(tcx, &*tr, span);\n+    // Also check that the type `object_trait` specifies all\n+    // associated types for all supertraits.\n+    let mut associated_types: FnvHashSet<(ast::DefId, ast::Name)> = FnvHashSet::new();\n+\n+    let object_trait_ref =\n+        object_trait.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n+    for tr in traits::supertraits(tcx, object_trait_ref.clone()) {\n+        check_object_safety_inner(tcx, &tr, span);\n+\n+        let trait_def = ty::lookup_trait_def(tcx, object_trait_ref.def_id());\n+        for &associated_type_name in trait_def.associated_type_names.iter() {\n+            associated_types.insert((object_trait_ref.def_id(), associated_type_name));\n+        }\n+    }\n+\n+    for projection_bound in object_trait.bounds.projection_bounds.iter() {\n+        let pair = (projection_bound.0.projection_ty.trait_ref.def_id,\n+                    projection_bound.0.projection_ty.item_name);\n+        associated_types.remove(&pair);\n+    }\n+\n+    for (trait_def_id, name) in associated_types.into_iter() {\n+        tcx.sess.span_err(\n+            span,\n+            format!(\"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n+                    name.user_string(tcx),\n+                    ty::item_path_str(tcx, trait_def_id)).as_slice());\n     }\n }\n \n fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                 object_trait: &ty::PolyTraitRef<'tcx>,\n-                                 span: Span) {\n+                                   object_trait: &ty::PolyTraitRef<'tcx>,\n+                                   span: Span) {\n     let trait_items = ty::trait_items(tcx, object_trait.def_id());\n \n     let mut errors = Vec::new();\n     for item in trait_items.iter() {\n         match *item {\n             ty::MethodTraitItem(ref m) => {\n-                errors.push(check_object_safety_of_method(tcx, &**m))\n+                errors.push(check_object_safety_of_method(tcx, object_trait, &**m))\n             }\n             ty::TypeTraitItem(_) => {}\n         }\n@@ -172,6 +196,7 @@ fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n     /// type is not known (that's the whole point of a trait instance, after all, to obscure the\n     /// self type) and (b) the call must go through a vtable and hence cannot be monomorphized.\n     fn check_object_safety_of_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                           object_trait: &ty::PolyTraitRef<'tcx>,\n                                            method: &ty::Method<'tcx>)\n                                            -> Vec<String> {\n         let mut msgs = Vec::new();\n@@ -195,11 +220,11 @@ fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         // reason (a) above\n         let check_for_self_ty = |ty| {\n-            if ty::type_has_self(ty) {\n+            if contains_illegal_self_type_reference(tcx, object_trait.def_id(), ty) {\n                 Some(format!(\n                     \"cannot call a method (`{}`) whose type contains \\\n                      a self-type (`{}`) through a trait object\",\n-                    method_name, ty_to_string(tcx, ty)))\n+                    method_name, ty.user_string(tcx)))\n             } else {\n                 None\n             }\n@@ -224,13 +249,105 @@ fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         msgs\n     }\n+\n+    fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                                  trait_def_id: ast::DefId,\n+                                                  ty: Ty<'tcx>)\n+                                                  -> bool\n+    {\n+        // This is somewhat subtle. In general, we want to forbid\n+        // references to `Self` in the argument and return types,\n+        // since the value of `Self` is erased. However, there is one\n+        // exception: it is ok to reference `Self` in order to access\n+        // an associated type of the current trait, since we retain\n+        // the value of those associated types in the object type\n+        // itself.\n+        //\n+        // ```rust\n+        // trait SuperTrait {\n+        //     type X;\n+        // }\n+        //\n+        // trait Trait : SuperTrait {\n+        //     type Y;\n+        //     fn foo(&self, x: Self) // bad\n+        //     fn foo(&self) -> Self // bad\n+        //     fn foo(&self) -> Option<Self> // bad\n+        //     fn foo(&self) -> Self::Y // OK, desugars to next example\n+        //     fn foo(&self) -> <Self as Trait>::Y // OK\n+        //     fn foo(&self) -> Self::X // OK, desugars to next example\n+        //     fn foo(&self) -> <Self as SuperTrait>::X // OK\n+        // }\n+        // ```\n+        //\n+        // However, it is not as simple as allowing `Self` in a projected\n+        // type, because there are illegal ways to use `Self` as well:\n+        //\n+        // ```rust\n+        // trait Trait : SuperTrait {\n+        //     ...\n+        //     fn foo(&self) -> <Self as SomeOtherTrait>::X;\n+        // }\n+        // ```\n+        //\n+        // Here we will not have the type of `X` recorded in the\n+        // object type, and we cannot resolve `Self as SomeOtherTrait`\n+        // without knowing what `Self` is.\n+\n+        let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n+        let mut error = false;\n+        ty::maybe_walk_ty(ty, |ty| {\n+            match ty.sty {\n+                ty::ty_param(ref param_ty) => {\n+                    if param_ty.space == SelfSpace {\n+                        error = true;\n+                    }\n+\n+                    false // no contained types to walk\n+                }\n+\n+                ty::ty_projection(ref data) => {\n+                    // This is a projected type `<Foo as SomeTrait>::X`.\n+\n+                    // Compute supertraits of current trait lazilly.\n+                    if supertraits.is_none() {\n+                        let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+                        let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n+                        supertraits = Some(traits::supertraits(tcx, trait_ref).collect());\n+                    }\n+\n+                    // Determine whether the trait reference `Foo as\n+                    // SomeTrait` is in fact a supertrait of the\n+                    // current trait. In that case, this type is\n+                    // legal, because the type `X` will be specified\n+                    // in the object type.  Note that we can just use\n+                    // direct equality here because all of these types\n+                    // are part of the formal parameter listing, and\n+                    // hence there should be no inference variables.\n+                    let projection_trait_ref = ty::Binder(data.trait_ref.clone());\n+                    let is_supertrait_of_current_trait =\n+                        supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n+\n+                    if is_supertrait_of_current_trait {\n+                        false // do not walk contained types, do not report error, do collect $200\n+                    } else {\n+                        true // DO walk contained types, POSSIBLY reporting an error\n+                    }\n+                }\n+\n+                _ => true, // walk contained types, if any\n+            }\n+        });\n+\n+        error\n+    }\n }\n \n pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   span: Span,\n                                                   object_trait: &ty::TyTrait<'tcx>,\n                                                   referent_ty: Ty<'tcx>)\n-                                                  -> Rc<ty::PolyTraitRef<'tcx>>\n+                                                  -> ty::PolyTraitRef<'tcx>\n {\n     // We can only make objects from sized types.\n     fcx.register_builtin_bound(\n@@ -243,21 +360,21 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let object_trait_ty =\n         ty::mk_trait(fcx.tcx(),\n                      object_trait.principal.clone(),\n-                     object_trait.bounds);\n+                     object_trait.bounds.clone());\n \n     debug!(\"register_object_cast_obligations: referent_ty={} object_trait_ty={}\",\n            referent_ty.repr(fcx.tcx()),\n            object_trait_ty.repr(fcx.tcx()));\n \n+    let cause = ObligationCause::new(span,\n+                                     fcx.body_id,\n+                                     traits::ObjectCastObligation(object_trait_ty));\n+\n     // Create the obligation for casting from T to Trait.\n     let object_trait_ref =\n         object_trait.principal_trait_ref_with_self_ty(fcx.tcx(), referent_ty);\n     let object_obligation =\n-        Obligation::new(\n-            ObligationCause::new(span,\n-                                 fcx.body_id,\n-                                 traits::ObjectCastObligation(object_trait_ty)),\n-            ty::Predicate::Trait(object_trait_ref.clone()));\n+        Obligation::new(cause.clone(), object_trait_ref.as_predicate());\n     fcx.register_predicate(object_obligation);\n \n     // Create additional obligations for all the various builtin\n@@ -268,7 +385,16 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.register_builtin_bound(\n             referent_ty,\n             builtin_bound,\n-            ObligationCause::new(span, fcx.body_id, traits::ObjectCastObligation(object_trait_ty)));\n+            cause.clone());\n+    }\n+\n+    // Finally, create obligations for the projection predicates.\n+    let projection_bounds =\n+        object_trait.projection_bounds_with_self_ty(fcx.tcx(), referent_ty);\n+    for projection_bound in projection_bounds.iter() {\n+        let projection_obligation =\n+            Obligation::new(cause.clone(), projection_bound.as_predicate());\n+        fcx.register_predicate(projection_obligation);\n     }\n \n     object_trait_ref\n@@ -313,3 +439,4 @@ pub fn select_new_fcx_obligations(fcx: &FnCtxt) {\n         Err(errors) => { report_fulfillment_errors(fcx.infcx(), &errors); }\n     }\n }\n+"}, {"sha": "2a3f528809cfd883776e85f39b997dfe95a5ce3f", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -13,7 +13,6 @@ use check::{FnCtxt, Inherited, blank_fn_ctxt, vtable, regionck};\n use CrateCtxt;\n use middle::region;\n use middle::subst;\n-use middle::subst::{Subst};\n use middle::traits;\n use middle::ty::{mod, Ty};\n use middle::ty::liberate_late_bound_regions;\n@@ -147,8 +146,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                         item.span,\n                                                         region::CodeExtent::from_node_id(item.id),\n                                                         Some(&mut this.cache));\n-            let polytype = ty::lookup_item_type(fcx.tcx(), local_def(item.id));\n-            let item_ty = polytype.ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            let type_scheme = ty::lookup_item_type(fcx.tcx(), local_def(item.id));\n+            let item_ty = fcx.instantiate_type_scheme(item.span,\n+                                                      &fcx.inh.param_env.free_substs,\n+                                                      &type_scheme.ty);\n             bounds_checker.check_traits_in_ty(item_ty);\n         });\n     }\n@@ -168,7 +169,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // that is, with all type parameters converted from bound\n             // to free.\n             let self_ty = ty::node_id_to_type(fcx.tcx(), item.id);\n-            let self_ty = self_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            let self_ty = fcx.instantiate_type_scheme(item.span,\n+                                                      &fcx.inh.param_env.free_substs,\n+                                                      &self_ty);\n \n             bounds_checker.check_traits_in_ty(self_ty);\n \n@@ -178,7 +181,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 None => { return; }\n                 Some(t) => { t }\n             };\n-            let trait_ref = (*trait_ref).subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            let trait_ref = fcx.instantiate_type_scheme(item.span,\n+                                                        &fcx.inh.param_env.free_substs,\n+                                                        &trait_ref);\n \n             // There are special rules that apply to drop.\n             if\n@@ -209,7 +214,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // trait reference. Instead, this is done at the impl site.\n             // Arguably this is wrong and we should treat the trait-reference\n             // the same way as we treat the self-type.\n-            bounds_checker.check_trait_ref(&trait_ref);\n+            bounds_checker.check_trait_ref(&*trait_ref);\n \n             let cause =\n                 traits::ObligationCause::new(\n@@ -313,14 +318,14 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         match t.sty{\n             ty::ty_struct(type_id, substs) |\n             ty::ty_enum(type_id, substs) => {\n-                let polytype = ty::lookup_item_type(self.fcx.tcx(), type_id);\n+                let type_scheme = ty::lookup_item_type(self.fcx.tcx(), type_id);\n \n                 if self.binding_count == 0 {\n                     self.fcx.add_obligations_for_parameters(\n                         traits::ObligationCause::new(self.span,\n                                                      self.fcx.body_id,\n                                                      traits::ItemObligation(type_id)),\n-                        &polytype.generics.to_bounds(self.tcx(), substs));\n+                        &type_scheme.generics.to_bounds(self.tcx(), substs));\n                 } else {\n                     // There are two circumstances in which we ignore\n                     // region obligations.\n@@ -344,7 +349,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n                     //\n                     // (I believe we should do the same for traits, but\n                     // that will require an RFC. -nmatsakis)\n-                    let bounds = polytype.generics.to_bounds(self.tcx(), substs);\n+                    let bounds = type_scheme.generics.to_bounds(self.tcx(), substs);\n                     let bounds = filter_to_trait_obligations(bounds);\n                     self.fcx.add_obligations_for_parameters(\n                         traits::ObligationCause::new(self.span,\n@@ -397,7 +402,9 @@ fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         .iter()\n         .map(|field| {\n             let field_ty = ty::node_id_to_type(fcx.tcx(), field.node.id);\n-            let field_ty = field_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            let field_ty = fcx.instantiate_type_scheme(field.span,\n+                                                       &fcx.inh.param_env.free_substs,\n+                                                       &field_ty);\n             AdtField { ty: field_ty, span: field.span }\n         })\n         .collect();\n@@ -416,7 +423,10 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     AdtVariant {\n                         fields: args.iter().enumerate().map(|(index, arg)| {\n                             let arg_ty = arg_tys[index];\n-                            let arg_ty = arg_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+                            let arg_ty =\n+                                fcx.instantiate_type_scheme(variant.span,\n+                                                            &fcx.inh.param_env.free_substs,\n+                                                            &arg_ty);\n                             AdtField {\n                                 ty: arg_ty,\n                                 span: arg.ty.span\n@@ -443,7 +453,8 @@ fn filter_to_trait_obligations<'tcx>(bounds: ty::GenericBounds<'tcx>)\n     let mut result = ty::GenericBounds::empty();\n     for (space, _, predicate) in bounds.predicates.iter_enumerated() {\n         match *predicate {\n-            ty::Predicate::Trait(..) => {\n+            ty::Predicate::Trait(..) |\n+            ty::Predicate::Projection(..) => {\n                 result.predicates.push(space, predicate.clone())\n             }\n             ty::Predicate::Equate(..) |"}, {"sha": "5ef9757b91ac250367a9fee6176eca09041e95c2", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -169,7 +169,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n         match t.node {\n             ast::TyFixedLengthVec(ref ty, ref count_expr) => {\n                 self.visit_ty(&**ty);\n-                write_ty_to_tcx(self.tcx(), count_expr.id, ty::mk_uint());\n+                write_ty_to_tcx(self.tcx(), count_expr.id, self.tcx().types.uint);\n             }\n             _ => visit::walk_ty(self, t)\n         }\n@@ -441,7 +441,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n                 debug!(\"Resolver::fold_ty: input type `{}` not fully resolvable\",\n                        t.repr(self.tcx));\n                 self.report_error(e);\n-                ty::mk_err()\n+                self.tcx().types.err\n             }\n         }\n     }"}, {"sha": "79e1efa618f536430aafc9652e39101d312751c2", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -23,10 +23,11 @@ use middle::ty::RegionEscape;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n use middle::ty::{ParameterEnvironment, TypeTraitItemId, lookup_item_type};\n use middle::ty::{Ty, ty_bool, ty_char, ty_closure, ty_enum, ty_err};\n-use middle::ty::{ty_param, Polytype, ty_ptr};\n+use middle::ty::{ty_param, TypeScheme, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_open};\n use middle::ty::{ty_uint, ty_unboxed_closure, ty_uniq, ty_bare_fn};\n+use middle::ty::{ty_projection};\n use middle::ty;\n use CrateCtxt;\n use middle::infer::combine::Combine;\n@@ -64,13 +65,13 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n         }\n \n         ty_trait(ref t) => {\n-            Some(t.principal.def_id())\n+            Some(t.principal_def_id())\n         }\n \n         ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n         ty_param(..) | ty_err | ty_open(..) | ty_uniq(_) |\n-        ty_ptr(_) | ty_rptr(_, _) => {\n+        ty_ptr(_) | ty_rptr(_, _) | ty_projection(..) => {\n             None\n         }\n \n@@ -206,7 +207,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         debug!(\"instantiate_default_methods(impl_id={}, trait_ref={})\",\n                impl_id, trait_ref.repr(tcx));\n \n-        let impl_poly_type = ty::lookup_item_type(tcx, impl_id);\n+        let impl_type_scheme = ty::lookup_item_type(tcx, impl_id);\n \n         let prov = ty::provided_trait_methods(tcx, trait_ref.def_id);\n         for trait_method in prov.iter() {\n@@ -221,7 +222,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 Rc::new(subst_receiver_types_in_method_ty(\n                     tcx,\n                     impl_id,\n-                    &impl_poly_type,\n+                    &impl_type_scheme,\n                     trait_ref,\n                     new_did,\n                     &**trait_method,\n@@ -233,7 +234,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             // construct the polytype for the method based on the\n             // method_ty.  it will have all the generics from the\n             // impl, plus its own.\n-            let new_polytype = ty::Polytype {\n+            let new_polytype = ty::TypeScheme {\n                 generics: new_method_ty.generics.clone(),\n                 ty: ty::mk_bare_fn(tcx, Some(new_did),\n                                    tcx.mk_bare_fn(new_method_ty.fty.clone()))\n@@ -275,7 +276,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     }\n \n     fn get_self_type_for_implementation(&self, impl_did: DefId)\n-                                        -> Polytype<'tcx> {\n+                                        -> TypeScheme<'tcx> {\n         self.crate_context.tcx.tcache.borrow()[impl_did].clone()\n     }\n \n@@ -535,7 +536,7 @@ fn enforce_trait_manually_implementable(tcx: &ty::ctxt, sp: Span, trait_def_id:\n \n fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                            impl_id: ast::DefId,\n-                                           impl_poly_type: &ty::Polytype<'tcx>,\n+                                           impl_type_scheme: &ty::TypeScheme<'tcx>,\n                                            trait_ref: &ty::TraitRef<'tcx>,\n                                            new_def_id: ast::DefId,\n                                            method: &ty::Method<'tcx>,\n@@ -554,10 +555,10 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n     for &space in [subst::TypeSpace, subst::SelfSpace].iter() {\n         method_generics.types.replace(\n             space,\n-            impl_poly_type.generics.types.get_slice(space).to_vec());\n+            impl_type_scheme.generics.types.get_slice(space).to_vec());\n         method_generics.regions.replace(\n             space,\n-            impl_poly_type.generics.regions.get_slice(space).to_vec());\n+            impl_type_scheme.generics.regions.get_slice(space).to_vec());\n     }\n \n     debug!(\"subst_receiver_types_in_method_ty: method_generics={}\","}, {"sha": "79443200ddf0e10eef6f2ec00174b4155c904c19", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -54,8 +54,8 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                     ty::ty_struct(def_id, _) => {\n                         self.check_def_id(item.span, def_id);\n                     }\n-                    ty::ty_trait(box ty::TyTrait{ ref principal, ..}) => {\n-                        self.check_def_id(item.span, principal.def_id());\n+                    ty::ty_trait(ref data) => {\n+                        self.check_def_id(item.span, data.principal_def_id());\n                     }\n                     _ => {\n                         span_err!(self.tcx.sess, item.span, E0118,"}, {"sha": "9e184db3b84fec1ea943f578c037ae3e24f0d5fc", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 215, "deletions": 888, "changes": 1103, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -23,31 +23,25 @@ Unlike most of the types that are present in Rust, the types computed\n for each item are in fact polytypes.  In \"layman's terms\", this means\n that they are generic types that may have type parameters (more\n mathematically phrased, they are universally quantified over a set of\n-type parameters).  Polytypes are represented by an instance of\n-`ty::Polytype`.  This combines the core type along with a list of the\n+type parameters).  TypeSchemes are represented by an instance of\n+`ty::TypeScheme`.  This combines the core type along with a list of the\n bounds for each parameter.  Type parameters themselves are represented\n as `ty_param()` instances.\n \n */\n-use self::ConvertMethodContext::*;\n-use self::CreateTypeParametersForAssociatedTypesFlag::*;\n-\n-use astconv::{AstConv, ty_of_arg, AllowEqConstraints};\n-use astconv::{ast_ty_to_ty, ast_region_to_region};\n-use astconv;\n+use astconv::{mod, AstConv, ty_of_arg, ast_ty_to_ty, ast_region_to_region};\n use metadata::csearch;\n-use middle::def;\n use middle::lang_items::SizedTraitLangItem;\n use middle::region;\n use middle::resolve_lifetime;\n use middle::subst;\n use middle::subst::{Substs};\n use middle::ty::{AsPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n-use middle::ty::{mod, RegionEscape, Ty, Polytype};\n+use middle::ty::{mod, RegionEscape, Ty, TypeScheme};\n use middle::ty_fold::{mod, TypeFolder, TypeFoldable};\n use middle::infer;\n use rscope::*;\n-use {CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n+use {CrateCtxt, no_params, write_ty_to_tcx};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux;\n use util::ppaux::{Repr,UserString};\n@@ -70,8 +64,8 @@ use syntax::visit;\n pub fn collect_item_types(ccx: &CrateCtxt) {\n     fn collect_intrinsic_type(ccx: &CrateCtxt,\n                               lang_item: ast::DefId) {\n-        let ty::Polytype { ty, .. } =\n-            ccx.get_item_ty(lang_item);\n+        let ty::TypeScheme { ty, .. } =\n+            ccx.get_item_type_scheme(lang_item);\n         ccx.tcx.intrinsic_defs.borrow_mut().insert(lang_item, ty);\n     }\n \n@@ -139,12 +133,6 @@ pub trait ToTy<'tcx> {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx>;\n }\n \n-impl<'a,'tcx> ToTy<'tcx> for ImplCtxt<'a,'tcx> {\n-    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx> {\n-        ast_ty_to_ty(self, rs, ast_ty)\n-    }\n-}\n-\n impl<'a,'tcx> ToTy<'tcx> for CrateCtxt<'a,'tcx> {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx> {\n         ast_ty_to_ty(self, rs, ast_ty)\n@@ -154,7 +142,7 @@ impl<'a,'tcx> ToTy<'tcx> for CrateCtxt<'a,'tcx> {\n impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n+    fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx> {\n         if id.krate != ast::LOCAL_CRATE {\n             return csearch::get_type(self.tcx, id)\n         }\n@@ -165,13 +153,10 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n                 let abi = self.tcx.map.get_foreign_abi(id.node);\n                 ty_of_foreign_item(self, &*foreign_item, abi)\n             }\n-            Some(ast_map::NodeTraitItem(trait_item)) => {\n-                ty_of_trait_item(self, &*trait_item)\n-            }\n             x => {\n                 self.tcx.sess.bug(format!(\"unexpected sort of node \\\n-                                           in get_item_ty(): {}\",\n-                                          x)[]);\n+                                           in get_item_type_scheme(): {}\",\n+                                          x).as_slice());\n             }\n         }\n     }\n@@ -183,23 +168,16 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         span_err!(self.tcx.sess, span, E0121,\n                   \"the type placeholder `_` is not allowed within types on item signatures\");\n-        ty::mk_err()\n+        self.tcx().types.err\n     }\n \n-    fn associated_types_of_trait_are_valid(&self, _: Ty<'tcx>, _: ast::DefId)\n-                                           -> bool {\n-        false\n-    }\n-\n-    fn associated_type_binding(&self,\n-                               span: Span,\n-                               _: Option<Ty<'tcx>>,\n-                               _: ast::DefId,\n-                               _: ast::DefId)\n-                               -> Option<Ty<'tcx>> {\n-        self.tcx().sess.span_err(span, \"associated types may not be \\\n-                                        referenced here\");\n-        Some(ty::mk_err())\n+    fn projected_ty(&self,\n+                    _span: Span,\n+                    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                    item_name: ast::Name)\n+                    -> Ty<'tcx>\n+    {\n+        ty::mk_projection(self.tcx, trait_ref, item_name)\n     }\n }\n \n@@ -227,28 +205,22 @@ pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             }\n \n             ast::StructVariantKind(ref struct_def) => {\n-                let pty = Polytype {\n-                    generics: ty_generics_for_type_or_impl(\n-                        ccx,\n-                        generics,\n-                        DontCreateTypeParametersForAssociatedTypes),\n+                let scheme = TypeScheme {\n+                    generics: ty_generics_for_type_or_impl(ccx, generics),\n                     ty: enum_ty\n                 };\n \n-                convert_struct(ccx, &**struct_def, pty, variant.node.id);\n+                convert_struct(ccx, &**struct_def, scheme, variant.node.id);\n                 enum_ty\n             }\n         };\n \n-        let pty = Polytype {\n-            generics: ty_generics_for_type_or_impl(\n-                          ccx,\n-                          generics,\n-                          DontCreateTypeParametersForAssociatedTypes),\n+        let scheme = TypeScheme {\n+            generics: ty_generics_for_type_or_impl(ccx, generics),\n             ty: result_ty\n         };\n \n-        tcx.tcache.borrow_mut().insert(variant_def_id, pty);\n+        tcx.tcache.borrow_mut().insert(variant_def_id, scheme);\n \n         write_ty_to_tcx(tcx, variant.node.id, result_ty);\n     }\n@@ -353,15 +325,15 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     fn make_method_ty<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, m: &ty::Method<'tcx>) {\n         ccx.tcx.tcache.borrow_mut().insert(\n             m.def_id,\n-            Polytype {\n+            TypeScheme {\n                 generics: m.generics.clone(),\n                 ty: ty::mk_bare_fn(ccx.tcx, Some(m.def_id), ccx.tcx.mk_bare_fn(m.fty.clone())) });\n     }\n \n     fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            trait_id: ast::NodeId,\n                                            trait_generics: &ty::Generics<'tcx>,\n-                                           trait_items: &[ast::TraitItem],\n+                                           _trait_items: &[ast::TraitItem],\n                                            m_id: &ast::NodeId,\n                                            m_name: &ast::Name,\n                                            m_explicit_self: &ast::ExplicitSelf,\n@@ -374,19 +346,11 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ty_generics_for_fn_or_method(\n                 ccx,\n                 m_generics,\n-                (*trait_generics).clone(),\n-                DontCreateTypeParametersForAssociatedTypes);\n+                (*trait_generics).clone());\n \n         let (fty, explicit_self_category) = {\n-            let tmcx = TraitMethodCtxt {\n-                ccx: ccx,\n-                trait_id: local_def(trait_id),\n-                trait_items: trait_items[],\n-                method_generics: &ty_generics,\n-            };\n-            let trait_self_ty = ty::mk_self_type(tmcx.tcx(),\n-                                                 local_def(trait_id));\n-            astconv::ty_of_method(&tmcx,\n+            let trait_self_ty = ty::mk_self_type(ccx.tcx);\n+            astconv::ty_of_method(ccx,\n                                   *m_unsafety,\n                                   trait_self_ty,\n                                   m_explicit_self,\n@@ -416,7 +380,7 @@ pub fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n     ccx.tcx.tcache.borrow_mut().insert(local_def(v.node.id),\n-                                       ty::Polytype {\n+                                       ty::TypeScheme {\n                                            generics: struct_generics.clone(),\n                                            ty: tt\n                                        });\n@@ -444,36 +408,7 @@ pub fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      trait_def: &ty::TraitDef<'tcx>,\n                                      associated_type: &ast::AssociatedType)\n-                                     -> ty::Polytype<'tcx> {\n-    // Find the type parameter ID corresponding to this\n-    // associated type.\n-    let type_parameter_def = trait_def.generics\n-                                      .types\n-                                      .get_slice(subst::AssocSpace)\n-                                      .iter()\n-                                      .find(|def| {\n-        def.def_id == local_def(associated_type.ty_param.id)\n-    });\n-    let type_parameter_def = match type_parameter_def {\n-        Some(type_parameter_def) => type_parameter_def,\n-        None => {\n-            ccx.tcx().sess.span_bug(associated_type.ty_param.span,\n-                                    \"`convert_associated_type()` didn't find \\\n-                                     a type parameter ID corresponding to \\\n-                                     this type\")\n-        }\n-    };\n-    let param_type = ty::mk_param(ccx.tcx,\n-                                  type_parameter_def.space,\n-                                  type_parameter_def.index,\n-                                  local_def(associated_type.ty_param.id));\n-    ccx.tcx.tcache.borrow_mut().insert(local_def(associated_type.ty_param.id),\n-                                       Polytype {\n-                                        generics: ty::Generics::empty(),\n-                                        ty: param_type,\n-                                       });\n-    write_ty_to_tcx(ccx.tcx, associated_type.ty_param.id, param_type);\n-\n+{\n     let associated_type = Rc::new(ty::AssociatedType {\n         name: associated_type.ty_param.ident.name,\n         vis: ast::Public,\n@@ -485,32 +420,16 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n        .borrow_mut()\n        .insert(associated_type.def_id,\n                ty::TypeTraitItem(associated_type));\n-\n-    Polytype {\n-        generics: ty::Generics::empty(),\n-        ty: param_type,\n-    }\n-}\n-\n-#[deriving(Copy)]\n-enum ConvertMethodContext<'a> {\n-    /// Used when converting implementation methods.\n-    ImplConvertMethodContext,\n-    /// Used when converting method signatures. The def ID is the def ID of\n-    /// the trait we're translating.\n-    TraitConvertMethodContext(ast::DefId, &'a [ast::TraitItem]),\n }\n \n fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                 convert_method_context: ConvertMethodContext,\n                                  container: ImplOrTraitItemContainer,\n                                  mut ms: I,\n                                  untransformed_rcvr_ty: Ty<'tcx>,\n                                  rcvr_ty_generics: &ty::Generics<'tcx>,\n                                  rcvr_visibility: ast::Visibility)\n                                  where I: Iterator<&'i ast::Method> {\n-    debug!(\"convert_methods(untransformed_rcvr_ty={}, \\\n-            rcvr_ty_generics={})\",\n+    debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={})\",\n            untransformed_rcvr_ty.repr(ccx.tcx),\n            rcvr_ty_generics.repr(ccx.tcx));\n \n@@ -523,7 +442,6 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         let m_def_id = local_def(m.id);\n         let mty = Rc::new(ty_of_method(ccx,\n-                                       convert_method_context,\n                                        container,\n                                        m,\n                                        untransformed_rcvr_ty,\n@@ -536,7 +454,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                 fty.repr(tcx));\n         tcx.tcache.borrow_mut().insert(\n             m_def_id,\n-            Polytype {\n+            TypeScheme {\n                 generics: mty.generics.clone(),\n                 ty: fty\n             });\n@@ -552,7 +470,6 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n \n     fn ty_of_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                    convert_method_context: ConvertMethodContext,\n                               container: ImplOrTraitItemContainer,\n                               m: &ast::Method,\n                               untransformed_rcvr_ty: Ty<'tcx>,\n@@ -563,37 +480,14 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n             ty_generics_for_fn_or_method(\n                 ccx,\n                 m.pe_generics(),\n-                (*rcvr_ty_generics).clone(),\n-                CreateTypeParametersForAssociatedTypes);\n-\n-        let (fty, explicit_self_category) = match convert_method_context {\n-            ImplConvertMethodContext => {\n-                let imcx = ImplMethodCtxt {\n-                    ccx: ccx,\n-                    method_generics: &m_ty_generics,\n-                };\n-                astconv::ty_of_method(&imcx,\n-                                      m.pe_unsafety(),\n-                                      untransformed_rcvr_ty,\n-                                      m.pe_explicit_self(),\n-                                      &*m.pe_fn_decl(),\n-                                      m.pe_abi())\n-            }\n-            TraitConvertMethodContext(trait_id, trait_items) => {\n-                let tmcx = TraitMethodCtxt {\n-                    ccx: ccx,\n-                    trait_id: trait_id,\n-                    trait_items: trait_items,\n-                    method_generics: &m_ty_generics,\n-                };\n-                astconv::ty_of_method(&tmcx,\n-                                      m.pe_unsafety(),\n-                                      untransformed_rcvr_ty,\n-                                      m.pe_explicit_self(),\n-                                      &*m.pe_fn_decl(),\n-                                      m.pe_abi())\n-            }\n-        };\n+                (*rcvr_ty_generics).clone());\n+\n+        let (fty, explicit_self_category) = astconv::ty_of_method(ccx,\n+                                                                  m.pe_unsafety(),\n+                                                                  untransformed_rcvr_ty,\n+                                                                  m.pe_explicit_self(),\n+                                                                  &*m.pe_fn_decl(),\n+                                                                  m.pe_abi());\n \n         // if the method specifies a visibility, use that, otherwise\n         // inherit the visibility from the impl (so `foo` in `pub impl\n@@ -641,404 +535,18 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n     }\n }\n \n-fn is_associated_type_valid_for_param(ty: Ty,\n-                                      trait_id: ast::DefId,\n-                                      generics: &ty::Generics)\n-                                      -> bool {\n-    if let ty::ty_param(param_ty) = ty.sty {\n-        let type_parameter = generics.types.get(param_ty.space, param_ty.idx as uint);\n-        for trait_bound in type_parameter.bounds.trait_bounds.iter() {\n-            if trait_bound.def_id() == trait_id {\n-                return true\n-            }\n-        }\n-    }\n-\n-    false\n-}\n-\n-fn find_associated_type_in_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                          span: Span,\n-                                          self_ty: Option<Ty<'tcx>>,\n-                                          associated_type_id: ast::DefId,\n-                                          generics: &ty::Generics<'tcx>)\n-                                          -> Option<Ty<'tcx>>\n-{\n-    debug!(\"find_associated_type_in_generics(ty={}, associated_type_id={}, generics={}\",\n-           self_ty.repr(tcx), associated_type_id.repr(tcx), generics.repr(tcx));\n-\n-    let self_ty = match self_ty {\n-        None => {\n-            return None;\n-        }\n-        Some(ty) => ty,\n-    };\n-\n-    match self_ty.sty {\n-        ty::ty_param(ref param_ty) => {\n-            let param_id = param_ty.def_id;\n-            for type_parameter in generics.types.iter() {\n-                if type_parameter.def_id == associated_type_id\n-                    && type_parameter.associated_with == Some(param_id) {\n-                    return Some(ty::mk_param_from_def(tcx, type_parameter));\n-                }\n-            }\n-\n-            tcx.sess.span_err(\n-                span,\n-                format!(\"no suitable bound on `{}`\",\n-                        self_ty.user_string(tcx))[]);\n-            Some(ty::mk_err())\n-        }\n-        _ => {\n-            tcx.sess.span_err(\n-                span,\n-                \"it is currently unsupported to access associated types except \\\n-                 through a type parameter; this restriction will be lifted in time\");\n-            Some(ty::mk_err())\n-        }\n-    }\n-}\n-\n-fn type_is_self(ty: Ty) -> bool {\n-    match ty.sty {\n-        ty::ty_param(ref param_ty) if param_ty.is_self() => true,\n-        _ => false,\n-    }\n-}\n-\n-struct ImplCtxt<'a,'tcx:'a> {\n-    ccx: &'a CrateCtxt<'a,'tcx>,\n-    opt_trait_ref_id: Option<ast::DefId>,\n-    impl_items: &'a [ast::ImplItem],\n-    impl_generics: &'a ty::Generics<'tcx>,\n-}\n-\n-impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.ccx.tcx\n-    }\n-\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n-        self.ccx.get_item_ty(id)\n-    }\n-\n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n-        self.ccx.get_trait_def(id)\n-    }\n-\n-    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        self.ccx.ty_infer(span)\n-    }\n-\n-    fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty<'tcx>,\n-                                           trait_id: ast::DefId)\n-                                           -> bool {\n-        // OK if the trait with the associated type is the trait we're\n-        // implementing.\n-        match self.opt_trait_ref_id {\n-            Some(trait_ref_id) if trait_ref_id == trait_id => {\n-                if type_is_self(ty) {\n-                    return true\n-                }\n-            }\n-            Some(_) | None => {}\n-        }\n-\n-        // OK if the trait with the associated type is one of the traits in\n-        // our bounds.\n-        is_associated_type_valid_for_param(ty, trait_id, self.impl_generics)\n-    }\n-\n-    fn associated_type_binding(&self,\n-                               span: Span,\n-                               self_ty: Option<Ty<'tcx>>,\n-                               trait_id: ast::DefId,\n-                               associated_type_id: ast::DefId)\n-                               -> Option<Ty<'tcx>>\n-    {\n-        match self.opt_trait_ref_id {\n-            // It's an associated type on the trait that we're\n-            // implementing.\n-            Some(trait_ref_id) if trait_ref_id == trait_id => {\n-                let trait_def = ty::lookup_trait_def(self.tcx(), trait_id);\n-                assert!(trait_def.generics.types\n-                        .get_slice(subst::AssocSpace)\n-                        .iter()\n-                        .any(|type_param_def| type_param_def.def_id == associated_type_id));\n-                let associated_type = ty::impl_or_trait_item(self.ccx.tcx, associated_type_id);\n-                for impl_item in self.impl_items.iter() {\n-                    match *impl_item {\n-                        ast::MethodImplItem(_) => {}\n-                        ast::TypeImplItem(ref typedef) => {\n-                            if associated_type.name() == typedef.ident.name {\n-                                return Some(self.ccx.to_ty(&ExplicitRscope, &*typedef.typ))\n-                            }\n-                        }\n-                    }\n-                }\n-                self.ccx\n-                    .tcx\n-                    .sess\n-                    .span_bug(span,\n-                              \"ImplCtxt::associated_type_binding(): didn't \\\n-                               find associated type\")\n-            }\n-            Some(_) | None => {}\n-        }\n-\n-        // OK then, it should be an associated type on one of the traits in\n-        // our bounds.\n-        find_associated_type_in_generics(self.ccx.tcx,\n-                                         span,\n-                                         self_ty,\n-                                         associated_type_id,\n-                                         self.impl_generics)\n-    }\n-}\n-\n-struct FnCtxt<'a,'tcx:'a> {\n-    ccx: &'a CrateCtxt<'a,'tcx>,\n-    generics: &'a ty::Generics<'tcx>,\n-}\n-\n-impl<'a,'tcx> AstConv<'tcx> for FnCtxt<'a,'tcx> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.ccx.tcx\n-    }\n-\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n-        self.ccx.get_item_ty(id)\n-    }\n-\n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n-        self.ccx.get_trait_def(id)\n-    }\n-\n-    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        self.ccx.ty_infer(span)\n-    }\n-\n-    fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty<'tcx>,\n-                                           trait_id: ast::DefId)\n-                                           -> bool {\n-        // OK if the trait with the associated type is one of the traits in\n-        // our bounds.\n-        is_associated_type_valid_for_param(ty, trait_id, self.generics)\n-    }\n-\n-    fn associated_type_binding(&self,\n-                               span: Span,\n-                               self_ty: Option<Ty<'tcx>>,\n-                               _: ast::DefId,\n-                               associated_type_id: ast::DefId)\n-                               -> Option<Ty<'tcx>> {\n-        debug!(\"collect::FnCtxt::associated_type_binding()\");\n-\n-        // The ID should map to an associated type on one of the traits in\n-        // our bounds.\n-        find_associated_type_in_generics(self.ccx.tcx,\n-                                         span,\n-                                         self_ty,\n-                                         associated_type_id,\n-                                         self.generics)\n-    }\n-}\n-\n-struct ImplMethodCtxt<'a,'tcx:'a> {\n-    ccx: &'a CrateCtxt<'a,'tcx>,\n-    method_generics: &'a ty::Generics<'tcx>,\n-}\n-\n-impl<'a,'tcx> AstConv<'tcx> for ImplMethodCtxt<'a,'tcx> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.ccx.tcx\n-    }\n-\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n-        self.ccx.get_item_ty(id)\n-    }\n-\n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n-        self.ccx.get_trait_def(id)\n-    }\n-\n-    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        self.ccx.ty_infer(span)\n-    }\n-\n-    fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty<'tcx>,\n-                                           trait_id: ast::DefId)\n-                                           -> bool {\n-        is_associated_type_valid_for_param(ty, trait_id, self.method_generics)\n-    }\n-\n-    fn associated_type_binding(&self,\n-                               span: Span,\n-                               self_ty: Option<Ty<'tcx>>,\n-                               _: ast::DefId,\n-                               associated_type_id: ast::DefId)\n-                               -> Option<Ty<'tcx>> {\n-        debug!(\"collect::ImplMethodCtxt::associated_type_binding()\");\n-\n-        // The ID should map to an associated type on one of the traits in\n-        // our bounds.\n-        find_associated_type_in_generics(self.ccx.tcx,\n-                                         span,\n-                                         self_ty,\n-                                         associated_type_id,\n-                                         self.method_generics)\n-    }\n-}\n-\n-struct TraitMethodCtxt<'a,'tcx:'a> {\n-    ccx: &'a CrateCtxt<'a,'tcx>,\n-    trait_id: ast::DefId,\n-    trait_items: &'a [ast::TraitItem],\n-    method_generics: &'a ty::Generics<'tcx>,\n-}\n-\n-impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.ccx.tcx\n-    }\n-\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n-        self.ccx.get_item_ty(id)\n-    }\n-\n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n-        self.ccx.get_trait_def(id)\n-    }\n-\n-    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        self.ccx.ty_infer(span)\n-    }\n-\n-    fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty<'tcx>,\n-                                           trait_id: ast::DefId)\n-                                           -> bool {\n-        // OK if the trait with the associated type is this trait.\n-        if self.trait_id == trait_id && type_is_self(ty) {\n-            return true\n-        }\n-\n-        // OK if the trait with the associated type is one of the traits in\n-        // our bounds.\n-        is_associated_type_valid_for_param(ty, trait_id, self.method_generics)\n-    }\n-\n-    fn associated_type_binding(&self,\n-                               span: Span,\n-                               self_ty: Option<Ty<'tcx>>,\n-                               trait_id: ast::DefId,\n-                               associated_type_id: ast::DefId)\n-                               -> Option<Ty<'tcx>> {\n-        debug!(\"collect::TraitMethodCtxt::associated_type_binding()\");\n-\n-        // If this is one of our own associated types, return it.\n-        if trait_id == self.trait_id {\n-            let mut index = 0;\n-            for item in self.trait_items.iter() {\n-                match *item {\n-                    ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {}\n-                    ast::TypeTraitItem(ref item) => {\n-                        if local_def(item.ty_param.id) == associated_type_id {\n-                            return Some(ty::mk_param(self.tcx(),\n-                                                     subst::AssocSpace,\n-                                                     index,\n-                                                     associated_type_id))\n-                        }\n-                        index += 1;\n-                    }\n-                }\n-            }\n-            self.ccx\n-                .tcx\n-                .sess\n-                .span_bug(span,\n-                          \"TraitMethodCtxt::associated_type_binding(): \\\n-                           didn't find associated type anywhere in the item \\\n-                           list\")\n-        }\n-\n-        // The ID should map to an associated type on one of the traits in\n-        // our bounds.\n-        find_associated_type_in_generics(self.ccx.tcx,\n-                                         span,\n-                                         self_ty,\n-                                         associated_type_id,\n-                                         self.method_generics)\n-    }\n-}\n-\n-struct GenericsCtxt<'a,'tcx:'a,AC:'a> {\n-    chain: &'a AC,\n-    associated_types_generics: &'a ty::Generics<'tcx>,\n-}\n-\n-impl<'a,'tcx,AC:AstConv<'tcx>> AstConv<'tcx> for GenericsCtxt<'a,'tcx,AC> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.chain.tcx()\n-    }\n-\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n-        self.chain.get_item_ty(id)\n-    }\n-\n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n-        self.chain.get_trait_def(id)\n-    }\n-\n-    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        self.chain.ty_infer(span)\n-    }\n-\n-    fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty<'tcx>,\n-                                           trait_id: ast::DefId)\n-                                           -> bool {\n-        // OK if the trait with the associated type is one of the traits in\n-        // our bounds.\n-        is_associated_type_valid_for_param(ty,\n-                                           trait_id,\n-                                           self.associated_types_generics)\n-    }\n-\n-    fn associated_type_binding(&self,\n-                               span: Span,\n-                               self_ty: Option<Ty<'tcx>>,\n-                               _: ast::DefId,\n-                               associated_type_id: ast::DefId)\n-                               -> Option<Ty<'tcx>> {\n-        debug!(\"collect::GenericsCtxt::associated_type_binding()\");\n-\n-        // The ID should map to an associated type on one of the traits in\n-        // our bounds.\n-        find_associated_type_in_generics(self.chain.tcx(),\n-                                         span,\n-                                         self_ty,\n-                                         associated_type_id,\n-                                         self.associated_types_generics)\n-    }\n-}\n-\n pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n     let tcx = ccx.tcx;\n     debug!(\"convert: item {} with id {}\", token::get_ident(it.ident), it.id);\n     match it.node {\n         // These don't define types.\n         ast::ItemForeignMod(_) | ast::ItemMod(_) | ast::ItemMac(_) => {}\n         ast::ItemEnum(ref enum_definition, ref generics) => {\n-            let pty = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, pty.ty);\n+            let scheme = ty_of_item(ccx, it);\n+            write_ty_to_tcx(tcx, it.id, scheme.ty);\n             get_enum_variant_types(ccx,\n-                                   pty.ty,\n-                                   enum_definition.variants[],\n+                                   scheme.ty,\n+                                   enum_definition.variants.as_slice(),\n                                    generics);\n         },\n         ast::ItemImpl(_,\n@@ -1047,18 +555,15 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                       ref selfty,\n                       ref impl_items) => {\n             // Create generics from the generics specified in the impl head.\n-            let ty_generics = ty_generics_for_type_or_impl(\n-                    ccx,\n-                    generics,\n-                    CreateTypeParametersForAssociatedTypes);\n+            let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n \n             let selfty = ccx.to_ty(&ExplicitRscope, &**selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n             tcx.tcache\n                .borrow_mut()\n                .insert(local_def(it.id),\n-                       Polytype {\n+                       TypeScheme {\n                         generics: ty_generics.clone(),\n                         ty: selfty,\n                        });\n@@ -1074,20 +579,6 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                 it.vis\n             };\n \n-            let icx = ImplCtxt {\n-                ccx: ccx,\n-                opt_trait_ref_id: match *opt_trait_ref {\n-                    None => None,\n-                    Some(ref ast_trait_ref) => {\n-                        Some(lookup_def_tcx(tcx,\n-                                            ast_trait_ref.path.span,\n-                                            ast_trait_ref.ref_id).def_id())\n-                    }\n-                },\n-                impl_items: impl_items[],\n-                impl_generics: &ty_generics,\n-            };\n-\n             let mut methods = Vec::new();\n             for impl_item in impl_items.iter() {\n                 match *impl_item {\n@@ -1101,11 +592,11 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                         methods.push(&**method);\n                     }\n                     ast::TypeImplItem(ref typedef) => {\n-                        let typ = icx.to_ty(&ExplicitRscope, &*typedef.typ);\n+                        let typ = ccx.to_ty(&ExplicitRscope, &*typedef.typ);\n                         tcx.tcache\n                            .borrow_mut()\n                            .insert(local_def(typedef.id),\n-                                   Polytype {\n+                                   TypeScheme {\n                                     generics: ty::Generics::empty(),\n                                     ty: typ,\n                                    });\n@@ -1126,19 +617,18 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             }\n \n             convert_methods(ccx,\n-                            ImplConvertMethodContext,\n                             ImplContainer(local_def(it.id)),\n                             methods.into_iter(),\n                             selfty,\n                             &ty_generics,\n                             parent_visibility);\n \n             for trait_ref in opt_trait_ref.iter() {\n-                astconv::instantiate_trait_ref(&icx,\n+                astconv::instantiate_trait_ref(ccx,\n                                                &ExplicitRscope,\n                                                trait_ref,\n                                                Some(selfty),\n-                                               AllowEqConstraints::DontAllow);\n+                                               None);\n             }\n         },\n         ast::ItemTrait(_, _, _, ref trait_methods) => {\n@@ -1149,10 +639,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                    trait_def.repr(ccx.tcx()));\n \n             for trait_method in trait_methods.iter() {\n-                let self_type = ty::mk_param(ccx.tcx,\n-                                             subst::SelfSpace,\n-                                             0,\n-                                             local_def(it.id));\n+                let self_type = ty::mk_self_type(tcx);\n                 match *trait_method {\n                     ast::RequiredMethod(ref type_method) => {\n                         let rscope = BindingRscope::new();\n@@ -1178,13 +665,8 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             }\n \n             // Run convert_methods on the provided methods.\n-            let untransformed_rcvr_ty = ty::mk_self_type(tcx,\n-                                                         local_def(it.id));\n-            let convert_method_context =\n-                TraitConvertMethodContext(local_def(it.id),\n-                                          trait_methods[]);\n+            let untransformed_rcvr_ty = ty::mk_self_type(tcx);\n             convert_methods(ccx,\n-                            convert_method_context,\n                             TraitContainer(local_def(it.id)),\n                             trait_methods.iter().filter_map(|m| match *m {\n                                 ast::RequiredMethod(_) => None,\n@@ -1202,12 +684,12 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n         },\n         ast::ItemStruct(ref struct_def, _) => {\n             // Write the class type.\n-            let pty = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, pty.ty);\n+            let scheme = ty_of_item(ccx, it);\n+            write_ty_to_tcx(tcx, it.id, scheme.ty);\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n \n-            convert_struct(ccx, &**struct_def, pty, it.id);\n+            convert_struct(ccx, &**struct_def, scheme, it.id);\n         },\n         ast::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n@@ -1218,22 +700,22 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             // This call populates the type cache with the converted type\n             // of the item in passing. All we have to do here is to write\n             // it into the node type table.\n-            let pty = ty_of_item(ccx, it);\n-            write_ty_to_tcx(tcx, it.id, pty.ty);\n+            let scheme = ty_of_item(ccx, it);\n+            write_ty_to_tcx(tcx, it.id, scheme.ty);\n         },\n     }\n }\n \n pub fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 struct_def: &ast::StructDef,\n-                                pty: ty::Polytype<'tcx>,\n+                                scheme: ty::TypeScheme<'tcx>,\n                                 id: ast::NodeId) {\n     let tcx = ccx.tcx;\n \n     // Write the type of each of the members and check for duplicate fields.\n     let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap::new();\n     let field_tys = struct_def.fields.iter().map(|f| {\n-        let result = convert_field(ccx, &pty.generics, f, local_def(id));\n+        let result = convert_field(ccx, &scheme.generics, f, local_def(id));\n \n         if result.name != special_idents::unnamed_field.name {\n             let dup = match seen_fields.get(&result.name) {\n@@ -1258,7 +740,7 @@ pub fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     tcx.struct_fields.borrow_mut().insert(local_def(id), Rc::new(field_tys));\n \n-    let substs = mk_item_substs(ccx, &pty.generics);\n+    let substs = mk_item_substs(ccx, &scheme.generics);\n     let selfty = ty::mk_struct(tcx, local_def(id), tcx.mk_substs(substs));\n \n     // If this struct is enum-like or tuple-like, create the type of its\n@@ -1270,7 +752,7 @@ pub fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 // Enum-like.\n                 write_ty_to_tcx(tcx, ctor_id, selfty);\n \n-                tcx.tcache.borrow_mut().insert(local_def(ctor_id), pty);\n+                tcx.tcache.borrow_mut().insert(local_def(ctor_id), scheme);\n             } else if struct_def.fields[0].node.kind.is_unnamed() {\n                 // Tuple-like.\n                 let inputs: Vec<_> = struct_def.fields.iter().map(\n@@ -1282,8 +764,8 @@ pub fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.borrow_mut().insert(local_def(ctor_id),\n-                                  Polytype {\n-                    generics: pty.generics,\n+                                  TypeScheme {\n+                    generics: scheme.generics,\n                     ty: ctor_fn_ty\n                 });\n             }\n@@ -1302,10 +784,10 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n     // convenient way to extract the ABI. - ndm\n     let abi = ccx.tcx.map.get_foreign_abi(i.id);\n \n-    let pty = ty_of_foreign_item(ccx, i, abi);\n-    write_ty_to_tcx(ccx.tcx, i.id, pty.ty);\n+    let scheme = ty_of_foreign_item(ccx, i, abi);\n+    write_ty_to_tcx(ccx.tcx, i.id, scheme.ty);\n \n-    ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), pty);\n+    ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), scheme);\n }\n \n fn get_trait_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -1326,7 +808,8 @@ fn get_trait_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    it: &ast::Item)\n-                                   -> Rc<ty::TraitDef<'tcx>> {\n+                                   -> Rc<ty::TraitDef<'tcx>>\n+{\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n     if let Some(def) = tcx.trait_defs.borrow().get(&def_id) {\n@@ -1347,40 +830,49 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     };\n \n-    let substs = ccx.tcx.mk_substs(mk_trait_substs(ccx, it.id, generics, items));\n+    let substs = ccx.tcx.mk_substs(mk_trait_substs(ccx, generics));\n \n     let ty_generics = ty_generics_for_trait(ccx,\n                                             it.id,\n                                             substs,\n                                             generics,\n                                             items);\n \n-    let self_param_ty = ty::ParamTy::for_self(def_id);\n+    let self_param_ty = ty::ParamTy::for_self();\n \n     let bounds = compute_bounds(ccx,\n-                                token::SELF_KEYWORD_NAME,\n-                                self_param_ty,\n+                                self_param_ty.to_ty(ccx.tcx),\n                                 bounds.as_slice(),\n                                 it.span);\n \n-    let substs = mk_item_substs(ccx, &ty_generics);\n+    let associated_type_names: Vec<_> =\n+        items.iter()\n+             .filter_map(|item| {\n+                 match *item {\n+                     ast::RequiredMethod(_) | ast::ProvidedMethod(_) => None,\n+                     ast::TypeTraitItem(ref data) => Some(data.ty_param.ident.name),\n+                 }\n+             })\n+            .collect();\n+\n+    let trait_ref = Rc::new(ty::TraitRef {\n+        def_id: def_id,\n+        substs: substs\n+    });\n+\n     let trait_def = Rc::new(ty::TraitDef {\n         unsafety: unsafety,\n         generics: ty_generics,\n         bounds: bounds,\n-        trait_ref: Rc::new(ty::TraitRef {\n-            def_id: def_id,\n-            substs: ccx.tcx.mk_substs(substs)\n-        })\n+        trait_ref: trait_ref,\n+        associated_type_names: associated_type_names,\n     });\n     tcx.trait_defs.borrow_mut().insert(def_id, trait_def.clone());\n \n     return trait_def;\n \n     fn mk_trait_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                 trait_id: ast::NodeId,\n-                                 generics: &ast::Generics,\n-                                 items: &[ast::TraitItem])\n+                                 generics: &ast::Generics)\n                                  -> subst::Substs<'tcx>\n     {\n         // Creates a no-op substitution for the trait's type parameters.\n@@ -1400,127 +892,92 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     .iter()\n                     .enumerate()\n                     .map(|(i, def)| ty::mk_param(ccx.tcx, subst::TypeSpace,\n-                                                 i as u32, local_def(def.id)))\n+                                                 i as u32, def.ident.name))\n                     .collect();\n \n-        // ...and also create generics synthesized from the associated types.\n-        let mut index = 0;\n-        let assoc_types: Vec<_> =\n-            items.iter()\n-            .flat_map(|item| match *item {\n-                ast::TypeTraitItem(ref trait_item) => {\n-                    index += 1;\n-                    Some(ty::mk_param(ccx.tcx,\n-                                      subst::AssocSpace,\n-                                      index - 1,\n-                                      local_def(trait_item.ty_param.id))).into_iter()\n-                }\n-                ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {\n-                    None.into_iter()\n-                }\n-            })\n-            .collect();\n-\n-        let self_ty =\n-            ty::mk_param(ccx.tcx, subst::SelfSpace, 0, local_def(trait_id));\n+        // ...and also create the `Self` parameter.\n+        let self_ty = ty::mk_self_type(ccx.tcx);\n \n-        subst::Substs::new_trait(types, regions, assoc_types, self_ty)\n+        subst::Substs::new_trait(types, regions, self_ty)\n     }\n }\n \n pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n-                            -> ty::Polytype<'tcx> {\n+                            -> ty::TypeScheme<'tcx> {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n-    if let Some(pty) = tcx.tcache.borrow().get(&def_id) {\n-        return pty.clone();\n+    if let Some(scheme) = tcx.tcache.borrow().get(&def_id) {\n+        return scheme.clone();\n     }\n     match it.node {\n         ast::ItemStatic(ref t, _, _) | ast::ItemConst(ref t, _) => {\n             let typ = ccx.to_ty(&ExplicitRscope, &**t);\n-            let pty = no_params(typ);\n+            let scheme = no_params(typ);\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n-            return pty;\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n+            return scheme;\n         }\n         ast::ItemFn(ref decl, unsafety, abi, ref generics, _) => {\n-            let ty_generics = ty_generics_for_fn_or_method(\n-                ccx,\n-                generics,\n-                ty::Generics::empty(),\n-                CreateTypeParametersForAssociatedTypes);\n-            let tofd = {\n-                let fcx = FnCtxt {\n-                    ccx: ccx,\n-                    generics: &ty_generics,\n-                };\n-                astconv::ty_of_bare_fn(&fcx, unsafety, abi, &**decl)\n-            };\n-            let pty = Polytype {\n+            let ty_generics = ty_generics_for_fn_or_method(ccx,\n+                                                           generics,\n+                                                           ty::Generics::empty());\n+            let tofd = astconv::ty_of_bare_fn(ccx, unsafety, abi, &**decl);\n+            let scheme = TypeScheme {\n                 generics: ty_generics,\n                 ty: ty::mk_bare_fn(ccx.tcx, Some(local_def(it.id)), ccx.tcx.mk_bare_fn(tofd))\n             };\n             debug!(\"type of {} (id {}) is {}\",\n                     token::get_ident(it.ident),\n                     it.id,\n-                    pty.repr(tcx));\n+                    scheme.repr(tcx));\n \n-            ccx.tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n-            return pty;\n+            ccx.tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n+            return scheme;\n         }\n         ast::ItemTy(ref t, ref generics) => {\n             match tcx.tcache.borrow_mut().get(&local_def(it.id)) {\n-                Some(pty) => return pty.clone(),\n+                Some(scheme) => return scheme.clone(),\n                 None => { }\n             }\n \n-            let pty = {\n+            let scheme = {\n                 let ty = ccx.to_ty(&ExplicitRscope, &**t);\n-                Polytype {\n-                    generics: ty_generics_for_type_or_impl(\n-                                  ccx,\n-                                  generics,\n-                                  DontCreateTypeParametersForAssociatedTypes),\n+                TypeScheme {\n+                    generics: ty_generics_for_type_or_impl(ccx, generics),\n                     ty: ty\n                 }\n             };\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n-            return pty;\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n+            return scheme;\n         }\n         ast::ItemEnum(_, ref generics) => {\n             // Create a new generic polytype.\n-            let ty_generics = ty_generics_for_type_or_impl(\n-                ccx,\n-                generics,\n-                DontCreateTypeParametersForAssociatedTypes);\n+            let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n             let t = ty::mk_enum(tcx, local_def(it.id), tcx.mk_substs(substs));\n-            let pty = Polytype {\n+            let scheme = TypeScheme {\n                 generics: ty_generics,\n                 ty: t\n             };\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n-            return pty;\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n+            return scheme;\n         }\n         ast::ItemTrait(..) => {\n             tcx.sess.span_bug(it.span, \"invoked ty_of_item on trait\");\n         }\n         ast::ItemStruct(_, ref generics) => {\n-            let ty_generics = ty_generics_for_type_or_impl(\n-                ccx,\n-                generics,\n-                DontCreateTypeParametersForAssociatedTypes);\n+            let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n             let t = ty::mk_struct(tcx, local_def(it.id), tcx.mk_substs(substs));\n-            let pty = Polytype {\n+            let scheme = TypeScheme {\n                 generics: ty_generics,\n                 ty: t\n             };\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n-            return pty;\n+            tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n+            return scheme;\n         }\n         ast::ItemImpl(..) | ast::ItemMod(_) |\n         ast::ItemForeignMod(_) | ast::ItemMac(_) => panic!(),\n@@ -1529,7 +986,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n \n pub fn ty_of_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     it: &ast::ForeignItem,\n-                                    abi: abi::Abi) -> ty::Polytype<'tcx>\n+                                    abi: abi::Abi) -> ty::TypeScheme<'tcx>\n {\n     match it.node {\n         ast::ForeignItemFn(ref fn_decl, ref generics) => {\n@@ -1540,89 +997,42 @@ pub fn ty_of_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   abi)\n         }\n         ast::ForeignItemStatic(ref t, _) => {\n-            ty::Polytype {\n+            ty::TypeScheme {\n                 generics: ty::Generics::empty(),\n                 ty: ast_ty_to_ty(ccx, &ExplicitRscope, &**t)\n             }\n         }\n     }\n }\n \n-fn ty_of_trait_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                              trait_item: &ast::TraitItem)\n-                              -> ty::Polytype<'tcx> {\n-    match *trait_item {\n-        ast::RequiredMethod(ref m) => {\n-            ccx.tcx.sess.span_bug(m.span,\n-                                  \"ty_of_trait_item() on required method\")\n-        }\n-        ast::ProvidedMethod(ref m) => {\n-            ccx.tcx.sess.span_bug(m.span,\n-                                  \"ty_of_trait_item() on provided method\")\n-        }\n-        ast::TypeTraitItem(ref associated_type) => {\n-            let parent = ccx.tcx.map.get_parent(associated_type.ty_param.id);\n-            let trait_def = match ccx.tcx.map.get(parent) {\n-                ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n-                _ => {\n-                    ccx.tcx.sess.span_bug(associated_type.ty_param.span,\n-                                          \"associated type's parent wasn't \\\n-                                           an item?!\")\n-                }\n-            };\n-            convert_associated_type(ccx, &*trait_def, &**associated_type)\n-        }\n-    }\n-}\n-\n fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                          generics: &ast::Generics,\n-                                          create_type_parameters_for_associated_types:\n-                                          CreateTypeParametersForAssociatedTypesFlag)\n+                                          generics: &ast::Generics)\n                                           -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n                 subst::TypeSpace,\n                 generics.lifetimes[],\n                 generics.ty_params[],\n                 ty::Generics::empty(),\n-                &generics.where_clause,\n-                create_type_parameters_for_associated_types)\n+                &generics.where_clause)\n }\n \n fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n                                    substs: &'tcx subst::Substs<'tcx>,\n                                    ast_generics: &ast::Generics,\n-                                   items: &[ast::TraitItem])\n+                                   trait_items: &[ast::TraitItem])\n                                    -> ty::Generics<'tcx>\n {\n+    debug!(\"ty_generics_for_trait(trait_id={}, substs={})\",\n+           local_def(trait_id).repr(ccx.tcx), substs.repr(ccx.tcx));\n+\n     let mut generics =\n         ty_generics(ccx,\n                     subst::TypeSpace,\n                     ast_generics.lifetimes[],\n                     ast_generics.ty_params[],\n                     ty::Generics::empty(),\n-                    &ast_generics.where_clause,\n-                    DontCreateTypeParametersForAssociatedTypes);\n-\n-    // Add in type parameters for any associated types.\n-    for item in items.iter() {\n-        match *item {\n-            ast::TypeTraitItem(ref associated_type) => {\n-                let def =\n-                    get_or_create_type_parameter_def(\n-                        ccx,\n-                        subst::AssocSpace,\n-                        &associated_type.ty_param,\n-                        generics.types.len(subst::AssocSpace) as u32,\n-                        Some(local_def(trait_id)));\n-                ccx.tcx.ty_param_defs.borrow_mut().insert(associated_type.ty_param.id,\n-                                                          def.clone());\n-                generics.types.push(subst::AssocSpace, def);\n-            }\n-            ast::ProvidedMethod(_) | ast::RequiredMethod(_) => {}\n-        }\n-    }\n+                    &ast_generics.where_clause);\n \n     // Add in the self type parameter.\n     //\n@@ -1631,8 +1041,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let param_id = trait_id;\n \n     let self_trait_ref =\n-        Rc::new(ty::Binder(ty::TraitRef { def_id: local_def(trait_id),\n-                                          substs: substs }));\n+        Rc::new(ty::TraitRef { def_id: local_def(trait_id),\n+                               substs: substs });\n \n     let def = ty::TypeParameterDef {\n         space: subst::SelfSpace,\n@@ -1642,28 +1052,64 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         bounds: ty::ParamBounds {\n             region_bounds: vec!(),\n             builtin_bounds: ty::empty_builtin_bounds(),\n-            trait_bounds: vec!(self_trait_ref.clone()),\n+            trait_bounds: vec!(ty::Binder(self_trait_ref.clone())),\n+            projection_bounds: vec!(),\n         },\n-        associated_with: None,\n         default: None\n     };\n \n     ccx.tcx.ty_param_defs.borrow_mut().insert(param_id, def.clone());\n \n     generics.types.push(subst::SelfSpace, def);\n \n-    generics.predicates.push(subst::SelfSpace,\n-                             ty::Predicate::Trait(self_trait_ref));\n+    generics.predicates.push(subst::SelfSpace, self_trait_ref.as_predicate());\n \n-    generics\n+    let assoc_predicates = predicates_for_associated_types(ccx,\n+                                                           &self_trait_ref,\n+                                                           trait_items);\n+\n+    debug!(\"ty_generics_for_trait: assoc_predicates={}\", assoc_predicates.repr(ccx.tcx));\n+\n+    for assoc_predicate in assoc_predicates.into_iter() {\n+        generics.predicates.push(subst::TypeSpace, assoc_predicate);\n+    }\n+\n+    return generics;\n+\n+    fn predicates_for_associated_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                                 self_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+                                                 trait_items: &[ast::TraitItem])\n+                                                 -> Vec<ty::Predicate<'tcx>>\n+    {\n+        trait_items\n+            .iter()\n+            .flat_map(|trait_item| {\n+                let assoc_type_def = match *trait_item {\n+                    ast::TypeTraitItem(ref assoc_type) => &assoc_type.ty_param,\n+                    ast::RequiredMethod(..) | ast::ProvidedMethod(..) => {\n+                        return vec!().into_iter();\n+                    }\n+                };\n+\n+                let assoc_ty = ty::mk_projection(ccx.tcx,\n+                                                 self_trait_ref.clone(),\n+                                                 assoc_type_def.ident.name);\n+\n+                let bounds = compute_bounds(ccx,\n+                                            assoc_ty,\n+                                            assoc_type_def.bounds.as_slice(),\n+                                            assoc_type_def.span);\n+\n+                ty::predicates(ccx.tcx, assoc_ty, &bounds).into_iter()\n+            })\n+            .collect()\n+    }\n }\n \n fn ty_generics_for_fn_or_method<'tcx,AC>(\n         this: &AC,\n         generics: &ast::Generics,\n-        base_generics: ty::Generics<'tcx>,\n-        create_type_parameters_for_associated_types:\n-        CreateTypeParametersForAssociatedTypesFlag)\n+        base_generics: ty::Generics<'tcx>)\n         -> ty::Generics<'tcx>\n         where AC: AstConv<'tcx> {\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n@@ -1672,8 +1118,7 @@ fn ty_generics_for_fn_or_method<'tcx,AC>(\n                 early_lifetimes[],\n                 generics.ty_params[],\n                 base_generics,\n-                &generics.where_clause,\n-                create_type_parameters_for_associated_types)\n+                &generics.where_clause)\n }\n \n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n@@ -1722,20 +1167,12 @@ fn add_unsized_bound<'tcx,AC>(this: &AC,\n     }\n }\n \n-#[deriving(Clone, PartialEq, Eq)]\n-enum CreateTypeParametersForAssociatedTypesFlag {\n-    DontCreateTypeParametersForAssociatedTypes,\n-    CreateTypeParametersForAssociatedTypes,\n-}\n-\n fn ty_generics<'tcx,AC>(this: &AC,\n                         space: subst::ParamSpace,\n                         lifetime_defs: &[ast::LifetimeDef],\n                         types: &[ast::TyParam],\n                         base_generics: ty::Generics<'tcx>,\n-                        where_clause: &ast::WhereClause,\n-                        create_type_parameters_for_associated_types_flag:\n-                        CreateTypeParametersForAssociatedTypesFlag)\n+                        where_clause: &ast::WhereClause)\n                         -> ty::Generics<'tcx>\n                         where AC: AstConv<'tcx>\n {\n@@ -1756,46 +1193,18 @@ fn ty_generics<'tcx,AC>(this: &AC,\n \n     assert!(result.types.is_empty_in(space));\n \n-    // First, create the virtual type parameters for associated types if\n-    // necessary.\n-    let mut associated_types_generics = ty::Generics::empty();\n-    match create_type_parameters_for_associated_types_flag {\n-        DontCreateTypeParametersForAssociatedTypes => {}\n-        CreateTypeParametersForAssociatedTypes => {\n-            create_type_parameters_for_associated_types(this, space, types,\n-                                                        &mut associated_types_generics);\n-        }\n-    }\n-\n     // Now create the real type parameters.\n-    let gcx = GenericsCtxt {\n-        chain: this,\n-        associated_types_generics: &associated_types_generics,\n-    };\n     for (i, param) in types.iter().enumerate() {\n-        let def = get_or_create_type_parameter_def(&gcx,\n+        let def = get_or_create_type_parameter_def(this,\n                                                    space,\n                                                    param,\n-                                                   i as u32,\n-                                                   None);\n+                                                   i as u32);\n         debug!(\"ty_generics: def for type param: {}, {}\",\n                def.repr(this.tcx()),\n                space);\n         result.types.push(space, def);\n     }\n \n-    // Append the associated types to the result.\n-    for associated_type_param in associated_types_generics.types\n-                                                          .get_slice(space)\n-                                                          .iter() {\n-        assert!(result.types.get_slice(space).len() ==\n-                associated_type_param.index as uint);\n-        debug!(\"ty_generics: def for associated type: {}, {}\",\n-               associated_type_param.repr(this.tcx()),\n-               space);\n-        result.types.push(space, (*associated_type_param).clone());\n-    }\n-\n     // Just for fun, also push the bounds from the type parameters\n     // into the predicates list. This is currently kind of non-DRY.\n     create_predicates(this.tcx(), &mut result, space);\n@@ -1809,16 +1218,21 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                 for bound in bound_pred.bounds.iter() {\n                     match bound {\n                         &ast::TyParamBound::TraitTyParamBound(ref poly_trait_ref, _) => {\n+                            let mut projections = Vec::new();\n+\n                             let trait_ref = astconv::instantiate_poly_trait_ref(\n                                 this,\n                                 &ExplicitRscope,\n-                                //@jroesch: for now trait_ref, poly_trait_ref?\n                                 poly_trait_ref,\n                                 Some(ty),\n-                                AllowEqConstraints::Allow\n+                                &mut projections,\n                             );\n \n-                            result.predicates.push(space, ty::Predicate::Trait(trait_ref));\n+                            result.predicates.push(space, trait_ref.as_predicate());\n+\n+                            for projection in projections.iter() {\n+                                result.predicates.push(space, projection.as_predicate());\n+                            }\n                         }\n \n                         &ast::TyParamBound::RegionTyParamBound(ref lifetime) => {\n@@ -1850,91 +1264,6 @@ fn ty_generics<'tcx,AC>(this: &AC,\n \n     return result;\n \n-    fn create_type_parameters_for_associated_types<'tcx, AC>(\n-        this: &AC,\n-        space: subst::ParamSpace,\n-        types: &[ast::TyParam],\n-        associated_types_generics: &mut ty::Generics<'tcx>)\n-        where AC: AstConv<'tcx>\n-    {\n-        // The idea here is roughly as follows. We start with\n-        // an item that is paramerized by various type parameters\n-        // with bounds:\n-        //\n-        //    fn foo<T:Iterator>(t: T) { ... }\n-        //\n-        // The traits in those bounds declare associated types:\n-        //\n-        //    trait Iterator { type Elem; ... }\n-        //\n-        // And we rewrite the original function so that every associated\n-        // type is bound to some fresh type parameter:\n-        //\n-        //    fn foo<A,T:Iterator<Elem=A>>(t: T) { ... }\n-\n-        // Number of synthetic type parameters created thus far\n-        let mut index = 0;\n-\n-        // Iterate over the each type parameter `T` (from the example)\n-        for param in types.iter() {\n-            // Iterate over the bound `Iterator`\n-            for bound in param.bounds.iter() {\n-                // In the above example, `ast_trait_ref` is `Iterator`.\n-                let ast_trait_ref = match *bound {\n-                    ast::TraitTyParamBound(ref r, _) => r,\n-                    ast::RegionTyParamBound(..) => { continue; }\n-                };\n-\n-                let trait_def_id =\n-                    match lookup_def_tcx(this.tcx(),\n-                                         ast_trait_ref.trait_ref.path.span,\n-                                         ast_trait_ref.trait_ref.ref_id) {\n-                        def::DefTrait(trait_def_id) => trait_def_id,\n-                        _ => {\n-                            this.tcx().sess.span_bug(ast_trait_ref.trait_ref.path.span,\n-                                                     \"not a trait?!\")\n-                        }\n-                    };\n-\n-                // trait_def_id is def-id of `Iterator`\n-                let trait_def = ty::lookup_trait_def(this.tcx(), trait_def_id);\n-                let associated_type_defs = trait_def.generics.types.get_slice(subst::AssocSpace);\n-\n-                // Find any associated type bindings in the bound.\n-                let ref segments = ast_trait_ref.trait_ref.path.segments;\n-                let bindings = segments[segments.len() -1].parameters.bindings();\n-\n-                // Iterate over each associated type `Elem`\n-                for associated_type_def in associated_type_defs.iter() {\n-                    if bindings.iter().any(|b| associated_type_def.name.ident() == b.ident) {\n-                        // Don't add a variable for a bound associated type.\n-                        continue;\n-                    }\n-\n-                    // Create the fresh type parameter `A`\n-                    let def = ty::TypeParameterDef {\n-                        name: associated_type_def.name,\n-                        def_id: associated_type_def.def_id,\n-                        space: space,\n-                        index: types.len() as u32 + index,\n-                        bounds: ty::ParamBounds {\n-                            builtin_bounds: associated_type_def.bounds.builtin_bounds,\n-\n-                            // FIXME(#18178) -- we should add the other bounds, but\n-                            // that requires subst and more logic\n-                            trait_bounds: Vec::new(),\n-                            region_bounds: Vec::new(),\n-                        },\n-                        associated_with: Some(local_def(param.id)),\n-                        default: None,\n-                    };\n-                    associated_types_generics.types.push(space, def);\n-                    index += 1;\n-                }\n-            }\n-        }\n-    }\n-\n     fn create_predicates<'tcx>(\n         tcx: &ty::ctxt<'tcx>,\n         result: &mut ty::Generics<'tcx>,\n@@ -1964,8 +1293,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n                                              space: subst::ParamSpace,\n                                              param: &ast::TyParam,\n-                                             index: u32,\n-                                             associated_with: Option<ast::DefId>)\n+                                             index: u32)\n                                              -> ty::TypeParameterDef<'tcx>\n     where AC: AstConv<'tcx>\n {\n@@ -1974,10 +1302,9 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n         None => { }\n     }\n \n-    let param_ty = ty::ParamTy::new(space, index, local_def(param.id));\n+    let param_ty = ty::ParamTy::new(space, index, param.ident.name);\n     let bounds = compute_bounds(this,\n-                                param.ident.name,\n-                                param_ty,\n+                                param_ty.to_ty(this.tcx()),\n                                 param.bounds[],\n                                 param.span);\n     let default = match param.default {\n@@ -2006,7 +1333,6 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n         index: index,\n         name: param.ident.name,\n         def_id: local_def(param.id),\n-        associated_with: associated_with,\n         bounds: bounds,\n         default: default\n     };\n@@ -2020,8 +1346,7 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n /// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n /// built-in trait (formerly known as kind): Send.\n fn compute_bounds<'tcx,AC>(this: &AC,\n-                           name_of_bounded_thing: ast::Name,\n-                           param_ty: ty::ParamTy,\n+                           param_ty: ty::Ty<'tcx>,\n                            ast_bounds: &[ast::TyParamBound],\n                            span: Span)\n                            -> ty::ParamBounds<'tcx>\n@@ -2037,7 +1362,7 @@ fn compute_bounds<'tcx,AC>(this: &AC,\n                       span);\n \n     check_bounds_compatible(this.tcx(),\n-                            name_of_bounded_thing,\n+                            param_ty,\n                             &param_bounds,\n                             span);\n \n@@ -2047,7 +1372,7 @@ fn compute_bounds<'tcx,AC>(this: &AC,\n }\n \n fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                 name_of_bounded_thing: ast::Name,\n+                                 param_ty: Ty<'tcx>,\n                                  param_bounds: &ty::ParamBounds<'tcx>,\n                                  span: Span) {\n     // Currently the only bound which is incompatible with other bounds is\n@@ -2060,9 +1385,9 @@ fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id());\n                 if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {\n                     span_err!(tcx.sess, span, E0129,\n-                              \"incompatible bounds on type parameter `{}`, \\\n+                              \"incompatible bounds on `{}`, \\\n                                bound `{}` does not allow unsized type\",\n-                              name_of_bounded_thing.user_string(tcx),\n+                              param_ty.user_string(tcx),\n                               trait_ref.user_string(tcx));\n                 }\n                 true\n@@ -2072,7 +1397,7 @@ fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n fn conv_param_bounds<'tcx,AC>(this: &AC,\n                               span: Span,\n-                              param_ty: ty::ParamTy,\n+                              param_ty: ty::Ty<'tcx>,\n                               ast_bounds: &[ast::TyParamBound])\n                               -> ty::ParamBounds<'tcx>\n                               where AC: AstConv<'tcx>\n@@ -2081,14 +1406,17 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n                                      trait_bounds,\n                                      region_bounds } =\n         astconv::partition_bounds(this.tcx(), span, ast_bounds.as_slice());\n-    let trait_bounds: Vec<Rc<ty::PolyTraitRef>> =\n+\n+    let mut projection_bounds = Vec::new();\n+\n+    let trait_bounds: Vec<ty::PolyTraitRef> =\n         trait_bounds.into_iter()\n         .map(|bound| {\n             astconv::instantiate_poly_trait_ref(this,\n                                                 &ExplicitRscope,\n                                                 bound,\n-                                                Some(param_ty.to_ty(this.tcx())),\n-                                                AllowEqConstraints::Allow)\n+                                                Some(param_ty),\n+                                                &mut projection_bounds)\n         })\n         .collect();\n     let region_bounds: Vec<ty::Region> =\n@@ -2099,6 +1427,7 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n         region_bounds: region_bounds,\n         builtin_bounds: builtin_bounds,\n         trait_bounds: trait_bounds,\n+        projection_bounds: projection_bounds,\n     }\n }\n \n@@ -2107,7 +1436,7 @@ pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                        def_id: ast::DefId,\n                                        ast_generics: &ast::Generics,\n                                        abi: abi::Abi)\n-                                       -> ty::Polytype<'tcx> {\n+                                       -> ty::TypeScheme<'tcx> {\n     for i in decl.inputs.iter() {\n         match (*i).pat.node {\n             ast::PatIdent(_, _, _) => (),\n@@ -2119,11 +1448,9 @@ pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     }\n \n-    let ty_generics_for_fn_or_method = ty_generics_for_fn_or_method(\n-            ccx,\n-            ast_generics,\n-            ty::Generics::empty(),\n-            DontCreateTypeParametersForAssociatedTypes);\n+    let ty_generics_for_fn_or_method = ty_generics_for_fn_or_method(ccx,\n+                                                                    ast_generics,\n+                                                                    ty::Generics::empty());\n     let rb = BindingRscope::new();\n     let input_tys = decl.inputs\n                         .iter()\n@@ -2144,16 +1471,16 @@ pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             abi: abi,\n             unsafety: ast::Unsafety::Unsafe,\n             sig: ty::Binder(ty::FnSig {inputs: input_tys,\n-                            output: output,\n-                            variadic: decl.variadic})\n+                                       output: output,\n+                                       variadic: decl.variadic}),\n         }));\n-    let pty = Polytype {\n+    let scheme = TypeScheme {\n         generics: ty_generics_for_fn_or_method,\n         ty: t_fn\n     };\n \n-    ccx.tcx.tcache.borrow_mut().insert(def_id, pty.clone());\n-    return pty;\n+    ccx.tcx.tcache.borrow_mut().insert(def_id, scheme.clone());\n+    return scheme;\n }\n \n pub fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,"}, {"sha": "353db82eb027de64c2ad4fb6c0f19d41521d9dff", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -159,8 +159,8 @@ fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n     lookup_def_tcx(ccx.tcx, sp, id)\n }\n \n-fn no_params<'tcx>(t: Ty<'tcx>) -> ty::Polytype<'tcx> {\n-    ty::Polytype {\n+fn no_params<'tcx>(t: Ty<'tcx>) -> ty::TypeScheme<'tcx> {\n+    ty::TypeScheme {\n         generics: ty::Generics {\n             types: VecPerParamSpace::empty(),\n             regions: VecPerParamSpace::empty(),\n@@ -278,11 +278,11 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: vec!(\n-                        ty::mk_int(),\n-                        ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, ty::mk_u8()))\n+                        tcx.types.int,\n+                        ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, tcx.types.u8))\n                     ),\n-                    output: ty::FnConverging(ty::mk_int()),\n-                    variadic: false\n+                    output: ty::FnConverging(tcx.types.int),\n+                    variadic: false,\n                 }),\n             }));\n "}, {"sha": "c4c33f24f87e2d9b4a57198514ccaec34ac6608f", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 65, "deletions": 45, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -479,8 +479,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n         let did = ast_util::local_def(item.id);\n         let tcx = self.terms_cx.tcx;\n \n+        debug!(\"visit_item item={}\",\n+               item.repr(tcx));\n+\n         match item.node {\n             ast::ItemEnum(ref enum_definition, _) => {\n+                let generics = &ty::lookup_item_type(tcx, did).generics;\n+\n                 // Hack: If we directly call `ty::enum_variants`, it\n                 // annoyingly takes it upon itself to run off and\n                 // evaluate the discriminants eagerly (*grumpy* that's\n@@ -497,17 +502,18 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n                                                           &**ast_variant,\n                                                           /*discriminant*/ 0);\n                     for arg_ty in variant.args.iter() {\n-                        self.add_constraints_from_ty(*arg_ty, self.covariant);\n+                        self.add_constraints_from_ty(generics, *arg_ty, self.covariant);\n                     }\n                 }\n             }\n \n             ast::ItemStruct(..) => {\n+                let generics = &ty::lookup_item_type(tcx, did).generics;\n                 let struct_fields = ty::lookup_struct_fields(tcx, did);\n                 for field_info in struct_fields.iter() {\n                     assert_eq!(field_info.id.krate, ast::LOCAL_CRATE);\n                     let field_ty = ty::node_id_to_type(tcx, field_info.id.node);\n-                    self.add_constraints_from_ty(field_ty, self.covariant);\n+                    self.add_constraints_from_ty(generics, field_ty, self.covariant);\n                 }\n             }\n \n@@ -516,7 +522,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n                 for trait_item in trait_items.iter() {\n                     match *trait_item {\n                         ty::MethodTraitItem(ref method) => {\n-                            self.add_constraints_from_sig(&method.fty.sig,\n+                            self.add_constraints_from_sig(&method.generics,\n+                                                          &method.fty.sig,\n                                                           self.covariant);\n                         }\n                         ty::TypeTraitItem(_) => {}\n@@ -713,8 +720,10 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     }\n \n     /// Adds constraints appropriate for an instance of `ty` appearing\n-    /// in a context with ambient variance `variance`\n+    /// in a context with the generics defined in `generics` and\n+    /// ambient variance `variance`\n     fn add_constraints_from_ty(&mut self,\n+                               generics: &ty::Generics<'tcx>,\n                                ty: Ty<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_ty(ty={})\", ty.repr(self.tcx()));\n@@ -732,75 +741,82 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::ty_rptr(region, ref mt) => {\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(*region, contra);\n-                self.add_constraints_from_mt(mt, variance);\n+                self.add_constraints_from_region(generics, *region, contra);\n+                self.add_constraints_from_mt(generics, mt, variance);\n             }\n \n             ty::ty_uniq(typ) | ty::ty_vec(typ, _) | ty::ty_open(typ) => {\n-                self.add_constraints_from_ty(typ, variance);\n+                self.add_constraints_from_ty(generics, typ, variance);\n             }\n \n             ty::ty_ptr(ref mt) => {\n-                self.add_constraints_from_mt(mt, variance);\n+                self.add_constraints_from_mt(generics, mt, variance);\n             }\n \n             ty::ty_tup(ref subtys) => {\n                 for &subty in subtys.iter() {\n-                    self.add_constraints_from_ty(subty, variance);\n+                    self.add_constraints_from_ty(generics, subty, variance);\n                 }\n             }\n \n             ty::ty_enum(def_id, substs) |\n             ty::ty_struct(def_id, substs) => {\n                 let item_type = ty::lookup_item_type(self.tcx(), def_id);\n-                let generics = &item_type.generics;\n \n                 // All type parameters on enums and structs should be\n                 // in the TypeSpace.\n-                assert!(generics.types.is_empty_in(subst::SelfSpace));\n-                assert!(generics.types.is_empty_in(subst::FnSpace));\n-                assert!(generics.regions.is_empty_in(subst::SelfSpace));\n-                assert!(generics.regions.is_empty_in(subst::FnSpace));\n+                assert!(item_type.generics.types.is_empty_in(subst::SelfSpace));\n+                assert!(item_type.generics.types.is_empty_in(subst::FnSpace));\n+                assert!(item_type.generics.regions.is_empty_in(subst::SelfSpace));\n+                assert!(item_type.generics.regions.is_empty_in(subst::FnSpace));\n \n                 self.add_constraints_from_substs(\n+                    generics,\n                     def_id,\n-                    generics.types.get_slice(subst::TypeSpace),\n-                    generics.regions.get_slice(subst::TypeSpace),\n+                    item_type.generics.types.get_slice(subst::TypeSpace),\n+                    item_type.generics.regions.get_slice(subst::TypeSpace),\n                     substs,\n                     variance);\n             }\n \n-            ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n-                let trait_def = ty::lookup_trait_def(self.tcx(), principal.def_id());\n-                let generics = &trait_def.generics;\n+            ty::ty_projection(ref data) => {\n+                let trait_ref = &data.trait_ref;\n+                let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id);\n+                self.add_constraints_from_substs(\n+                    generics,\n+                    trait_ref.def_id,\n+                    trait_def.generics.types.as_slice(),\n+                    trait_def.generics.regions.as_slice(),\n+                    trait_ref.substs,\n+                    variance);\n+            }\n \n-                // Traits DO have a Self type parameter, but it is\n-                // erased from object types.\n-                assert!(!generics.types.is_empty_in(subst::SelfSpace) &&\n-                        principal.substs().types.is_empty_in(subst::SelfSpace));\n+            ty::ty_trait(ref data) => {\n+                let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(),\n+                                                                      self.tcx().types.err);\n+                let trait_def = ty::lookup_trait_def(self.tcx(), trait_ref.def_id());\n \n                 // Traits never declare region parameters in the self\n-                // space.\n-                assert!(generics.regions.is_empty_in(subst::SelfSpace));\n-\n-                // Traits never declare type/region parameters in the\n-                // fn space.\n-                assert!(generics.types.is_empty_in(subst::FnSpace));\n-                assert!(generics.regions.is_empty_in(subst::FnSpace));\n+                // space nor anything in the fn space.\n+                assert!(trait_def.generics.regions.is_empty_in(subst::SelfSpace));\n+                assert!(trait_def.generics.types.is_empty_in(subst::FnSpace));\n+                assert!(trait_def.generics.regions.is_empty_in(subst::FnSpace));\n \n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(bounds.region_bound, contra);\n+                self.add_constraints_from_region(generics, data.bounds.region_bound, contra);\n \n                 self.add_constraints_from_substs(\n-                    principal.def_id(),\n-                    generics.types.get_slice(subst::TypeSpace),\n-                    generics.regions.get_slice(subst::TypeSpace),\n-                    principal.substs(),\n+                    generics,\n+                    trait_ref.def_id(),\n+                    trait_def.generics.types.get_slice(subst::TypeSpace),\n+                    trait_def.generics.regions.get_slice(subst::TypeSpace),\n+                    trait_ref.substs(),\n                     variance);\n             }\n \n-            ty::ty_param(ty::ParamTy { ref def_id, .. }) => {\n+            ty::ty_param(ref data) => {\n+                let def_id = generics.types.get(data.space, data.idx as uint).def_id;\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n                 match self.terms_cx.inferred_map.get(&def_id.node) {\n                     Some(&index) => {\n@@ -821,14 +837,14 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                     ..\n                 }) =>\n             {\n-                self.add_constraints_from_sig(sig, variance);\n+                self.add_constraints_from_sig(generics, sig, variance);\n             }\n \n             ty::ty_closure(box ty::ClosureTy { ref sig,\n                     store: ty::RegionTraitStore(region, _), .. }) => {\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(region, contra);\n-                self.add_constraints_from_sig(sig, variance);\n+                self.add_constraints_from_region(generics, region, contra);\n+                self.add_constraints_from_sig(generics, sig, variance);\n             }\n \n             ty::ty_infer(..) | ty::ty_err => {\n@@ -844,6 +860,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a nominal type (enum, struct,\n     /// object, etc) appearing in a context with ambient variance `variance`\n     fn add_constraints_from_substs(&mut self,\n+                                   generics: &ty::Generics<'tcx>,\n                                    def_id: ast::DefId,\n                                    type_param_defs: &[ty::TypeParameterDef<'tcx>],\n                                    region_param_defs: &[ty::RegionParameterDef],\n@@ -857,7 +874,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                        p.space, p.index as uint);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_ty = *substs.types.get(p.space, p.index as uint);\n-            self.add_constraints_from_ty(substs_ty, variance_i);\n+            self.add_constraints_from_ty(generics, substs_ty, variance_i);\n         }\n \n         for p in region_param_defs.iter() {\n@@ -866,27 +883,29 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                        RegionParam, p.space, p.index as uint);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_r = *substs.regions().get(p.space, p.index as uint);\n-            self.add_constraints_from_region(substs_r, variance_i);\n+            self.add_constraints_from_region(generics, substs_r, variance_i);\n         }\n     }\n \n     /// Adds constraints appropriate for a function with signature\n     /// `sig` appearing in a context with ambient variance `variance`\n     fn add_constraints_from_sig(&mut self,\n+                                generics: &ty::Generics<'tcx>,\n                                 sig: &ty::PolyFnSig<'tcx>,\n                                 variance: VarianceTermPtr<'a>) {\n         let contra = self.contravariant(variance);\n         for &input in sig.0.inputs.iter() {\n-            self.add_constraints_from_ty(input, contra);\n+            self.add_constraints_from_ty(generics, input, contra);\n         }\n         if let ty::FnConverging(result_type) = sig.0.output {\n-            self.add_constraints_from_ty(result_type, variance);\n+            self.add_constraints_from_ty(generics, result_type, variance);\n         }\n     }\n \n     /// Adds constraints appropriate for a region appearing in a\n     /// context with ambient variance `variance`\n     fn add_constraints_from_region(&mut self,\n+                                   _generics: &ty::Generics<'tcx>,\n                                    region: ty::Region,\n                                    variance: VarianceTermPtr<'a>) {\n         match region {\n@@ -920,16 +939,17 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a mutability-type pair\n     /// appearing in a context with ambient variance `variance`\n     fn add_constraints_from_mt(&mut self,\n+                               generics: &ty::Generics<'tcx>,\n                                mt: &ty::mt<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         match mt.mutbl {\n             ast::MutMutable => {\n                 let invar = self.invariant(variance);\n-                self.add_constraints_from_ty(mt.ty, invar);\n+                self.add_constraints_from_ty(generics, mt.ty, invar);\n             }\n \n             ast::MutImmutable => {\n-                self.add_constraints_from_ty(mt.ty, variance);\n+                self.add_constraints_from_ty(generics, mt.ty, variance);\n             }\n         }\n     }"}, {"sha": "1fbfbe7eb1ab50f26123d1492feae6d6fac1f2c1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -34,8 +34,7 @@ use syntax::ast_util::PostExpansionMethod;\n use syntax::attr;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::codemap::{DUMMY_SP, Pos, Spanned};\n-use syntax::parse::token::InternedString;\n-use syntax::parse::token;\n+use syntax::parse::token::{mod, InternedString, special_idents};\n use syntax::ptr::P;\n \n use rustc_trans::back::link;\n@@ -500,13 +499,16 @@ impl Clean<TyParamBound> for ast::TyParamBound {\n     }\n }\n \n-impl Clean<Vec<TyParamBound>> for ty::ExistentialBounds {\n+impl<'tcx> Clean<Vec<TyParamBound>> for ty::ExistentialBounds<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Vec<TyParamBound> {\n         let mut vec = vec![];\n         self.region_bound.clean(cx).map(|b| vec.push(RegionBound(b)));\n         for bb in self.builtin_bounds.iter() {\n             vec.push(bb.clean(cx));\n         }\n+\n+        // FIXME(#20299) -- should do something with projection bounds\n+\n         vec\n     }\n }\n@@ -1199,11 +1201,9 @@ pub enum Type {\n     },\n     // I have no idea how to usefully use this.\n     TyParamBinder(ast::NodeId),\n-    /// For parameterized types, so the consumer of the JSON don't go looking\n-    /// for types which don't exist anywhere.\n-    Generic(ast::DefId),\n-    /// For references to self\n-    Self(ast::DefId),\n+    /// For parameterized types, so the consumer of the JSON don't go\n+    /// looking for types which don't exist anywhere.\n+    Generic(String),\n     /// Primitives are just the fixed-size numeric types (plus int/uint/float), and char.\n     Primitive(PrimitiveType),\n     Closure(Box<ClosureDecl>),\n@@ -1441,18 +1441,11 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 }\n             }\n             ty::ty_struct(did, substs) |\n-            ty::ty_enum(did, substs) |\n-            ty::ty_trait(box ty::TyTrait {\n-                principal: ty::Binder(ty::TraitRef { def_id: did, substs }),\n-                .. }) =>\n-            {\n+            ty::ty_enum(did, substs) => {\n                 let fqn = csearch::get_item_path(cx.tcx(), did);\n-                let fqn: Vec<String> = fqn.into_iter().map(|i| {\n-                    i.to_string()\n-                }).collect();\n+                let fqn: Vec<_> = fqn.into_iter().map(|i| i.to_string()).collect();\n                 let kind = match self.sty {\n                     ty::ty_struct(..) => TypeStruct,\n-                    ty::ty_trait(..) => TypeTrait,\n                     _ => TypeEnum,\n                 };\n                 let path = external_path(cx, fqn.last().unwrap().to_string().as_slice(),\n@@ -1464,16 +1457,35 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     did: did,\n                 }\n             }\n+            ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n+                let did = principal.def_id();\n+                let fqn = csearch::get_item_path(cx.tcx(), did);\n+                let fqn: Vec<_> = fqn.into_iter().map(|i| i.to_string()).collect();\n+                let path = external_path(cx, fqn.last().unwrap().to_string().as_slice(),\n+                                         Some(did), principal.substs());\n+                cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, TypeTrait));\n+                ResolvedPath {\n+                    path: path,\n+                    typarams: Some(bounds.clean(cx)),\n+                    did: did,\n+                }\n+            }\n             ty::ty_tup(ref t) => Tuple(t.clean(cx)),\n \n-            ty::ty_param(ref p) => {\n-                if p.space == subst::SelfSpace {\n-                    Self(p.def_id)\n-                } else {\n-                    Generic(p.def_id)\n+            ty::ty_projection(ref data) => {\n+                let trait_ref = match data.trait_ref.clean(cx) {\n+                    TyParamBound::TraitBound(t, _) => t.trait_,\n+                    TyParamBound::RegionBound(_) => panic!(\"cleaning a trait got a region??\"),\n+                };\n+                Type::QPath {\n+                    name: data.item_name.clean(cx),\n+                    self_type: box data.trait_ref.self_ty().clean(cx),\n+                    trait_: box trait_ref,\n                 }\n             }\n \n+            ty::ty_param(ref p) => Generic(token::get_name(p.name).to_string()),\n+\n             ty::ty_unboxed_closure(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n             ty::ty_infer(..) => panic!(\"ty_infer\"),\n@@ -2257,7 +2269,9 @@ fn resolve_type(cx: &DocContext,\n     };\n \n     match def {\n-        def::DefSelfTy(i) => return Self(ast_util::local_def(i)),\n+        def::DefSelfTy(..) => {\n+            return Generic(token::get_name(special_idents::type_self.name).to_string());\n+        }\n         def::DefPrimTy(p) => match p {\n             ast::TyStr => return Primitive(Str),\n             ast::TyBool => return Primitive(Bool),\n@@ -2275,7 +2289,7 @@ fn resolve_type(cx: &DocContext,\n             ast::TyFloat(ast::TyF32) => return Primitive(F32),\n             ast::TyFloat(ast::TyF64) => return Primitive(F64),\n         },\n-        def::DefTyParam(_, i, _) => return Generic(i),\n+        def::DefTyParam(_, _, _, n) => return Generic(token::get_name(n).to_string()),\n         def::DefTyParamBinder(i) => return TyParamBinder(i),\n         _ => {}\n     };"}, {"sha": "dc264a5b5aa05526c1edfbc6698c935e62b2598f", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -435,15 +435,14 @@ impl fmt::Show for clean::Type {\n             clean::TyParamBinder(id) => {\n                 f.write(cache().typarams[ast_util::local_def(id)].as_bytes())\n             }\n-            clean::Generic(did) => {\n-                f.write(cache().typarams[did].as_bytes())\n+            clean::Generic(ref name) => {\n+                f.write(name.as_bytes())\n             }\n             clean::ResolvedPath{ did, ref typarams, ref path } => {\n                 try!(resolved_path(f, did, path, false));\n                 tybounds(f, typarams)\n             }\n             clean::Infer => write!(f, \"_\"),\n-            clean::Self(..) => f.write(\"Self\".as_bytes()),\n             clean::Primitive(prim) => primitive_link(f, prim, prim.to_string()),\n             clean::Closure(ref decl) => {\n                 write!(f, \"{style}{lifetimes}|{args}|{bounds}{arrow}\","}, {"sha": "12432c8c78f2c109822ca57c41a1398cdf5904ba", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -764,7 +764,7 @@ pub enum Expr_ {\n pub struct QPath {\n     pub self_type: P<Ty>,\n     pub trait_ref: P<TraitRef>,\n-    pub item_name: Ident,\n+    pub item_name: Ident, // FIXME(#20301) -- should use Name\n }\n \n #[deriving(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]"}, {"sha": "40ca6354ca6d14d114378799746d40b2de55527c", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -133,6 +133,9 @@ pub trait Visitor<'v> {\n     fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'v PathParameters) {\n         walk_path_parameters(self, path_span, path_parameters)\n     }\n+    fn visit_assoc_type_binding(&mut self, type_binding: &'v TypeBinding) {\n+        walk_assoc_type_binding(self, type_binding)\n+    }\n     fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n }\n \n@@ -467,6 +470,9 @@ pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n             for lifetime in data.lifetimes.iter() {\n                 visitor.visit_lifetime_ref(lifetime);\n             }\n+            for binding in data.bindings.iter() {\n+                visitor.visit_assoc_type_binding(&**binding);\n+            }\n         }\n         ast::ParenthesizedParameters(ref data) => {\n             for typ in data.inputs.iter() {\n@@ -479,6 +485,12 @@ pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n     }\n }\n \n+pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                                   type_binding: &'v TypeBinding) {\n+    visitor.visit_ident(type_binding.span, type_binding.ident);\n+    visitor.visit_ty(&*type_binding.ty);\n+}\n+\n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     match pattern.node {\n         PatEnum(ref path, ref children) => {"}, {"sha": "17b2a0751fe297665062595ad17cdfcbf7286aa5", "filename": "src/test/auxiliary/associated-types-cc-lib.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fauxiliary%2Fassociated-types-cc-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fauxiliary%2Fassociated-types-cc-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fassociated-types-cc-lib.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Helper for test issue-18048, which tests associated types in a\n+// cross-crate scenario.\n+\n+#![crate_type=\"lib\"]\n+#![feature(associated_types)]\n+\n+pub trait Bar {\n+    type T;\n+\n+    fn get(x: Option<Self>) -> <Self as Bar>::T;\n+}\n+\n+impl Bar for int {\n+    type T = uint;\n+\n+    fn get(_: Option<int>) -> uint { 22 }\n+}"}, {"sha": "7981fe3182712609fc01df0e8dabbd5b7e3516af", "filename": "src/test/compile-fail/associated-types-bound-failure.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-bound-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-bound-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-bound-failure.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints on associated types in a where clause.\n+\n+#![feature(associated_types)]\n+\n+pub trait ToInt {\n+    fn to_int(&self) -> int;\n+}\n+\n+pub trait GetToInt\n+{\n+    type R;\n+\n+    fn get(&self) -> <Self as GetToInt>::R;\n+}\n+\n+fn foo<G>(g: G) -> int\n+    where G : GetToInt\n+{\n+    ToInt::to_int(&g.get()) //~ ERROR not implemented\n+}\n+\n+fn bar<G : GetToInt>(g: G) -> int\n+    where G::R : ToInt\n+{\n+    ToInt::to_int(&g.get()) // OK\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "e93d9db28cf4b18eb6e59168281a4e88cfe5f7df", "filename": "src/test/compile-fail/associated-types-eq-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-1.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "previous_filename": "src/test/compile-fail/assoc-eq-1.rs"}, {"sha": "b89cdd8c0eed7c233ca1efc07385c85fdf382694", "filename": "src/test/compile-fail/associated-types-eq-2.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-2.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -25,6 +25,7 @@ impl Foo for int {\n     fn boo(&self) -> uint { 42 }\n }\n \n-fn baz<I: Foo>(x: &<I as Foo<A=Bar>>::A) {} //~ERROR equality constraints are not allowed in this\n+fn baz<I: Foo>(x: &<I as Foo<A=Bar>>::A) {}\n+//~^ ERROR associated type bindings are not allowed here\n \n pub fn main() {}", "previous_filename": "src/test/compile-fail/assoc-eq-2.rs"}, {"sha": "e5974925d7370b6d813962e3cfa8858f6f08c6d6", "filename": "src/test/compile-fail/associated-types-eq-3.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -43,6 +43,6 @@ pub fn baz(x: &Foo<A=Bar>) {\n \n pub fn main() {\n     let a = 42i;\n-    foo1(a); //~ERROR the trait `Foo` is not implemented for the type `int`\n-    baz(&a); //~ERROR the trait `Foo` is not implemented for the type `int`\n+    foo1(a); //~ERROR expected uint, found struct Bar\n+    baz(&a); //~ERROR expected uint, found struct Bar\n }", "previous_filename": "src/test/compile-fail/assoc-eq-3.rs"}, {"sha": "1a96b0ca6812e357b507e1daea4e8ffd69b5f8b8", "filename": "src/test/compile-fail/associated-types-eq-expr-path.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "previous_filename": "src/test/compile-fail/assoc-eq-expr-path.rs"}, {"sha": "aad55745c25dfb9eceeeecff9073a1a860106f89", "filename": "src/test/compile-fail/associated-types-eq-hr.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-hr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-hr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-hr.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check testing of equality constraints in a higher-ranked context.\n+\n+#![feature(associated_types)]\n+\n+pub trait TheTrait<T> {\n+    type A;\n+\n+    fn get(&self, t: T) -> Self::A;\n+}\n+\n+struct IntStruct {\n+    x: int\n+}\n+\n+impl<'a> TheTrait<&'a int> for IntStruct {\n+    type A = &'a int;\n+\n+    fn get(&self, t: &'a int) -> &'a int {\n+        t\n+    }\n+}\n+\n+struct UintStruct {\n+    x: int\n+}\n+\n+impl<'a> TheTrait<&'a int> for UintStruct {\n+    type A = &'a uint;\n+\n+    fn get(&self, t: &'a int) -> &'a uint {\n+        panic!()\n+    }\n+}\n+\n+fn foo<T>()\n+    where T : for<'x> TheTrait<&'x int, A = &'x int>\n+{\n+    // ok for IntStruct, but not UintStruct\n+}\n+\n+fn bar<T>()\n+    where T : for<'x> TheTrait<&'x int, A = &'x uint>\n+{\n+    // ok for UintStruct, but not IntStruct\n+}\n+\n+fn baz<T>()\n+    where T : for<'x,'y> TheTrait<&'x int, A = &'y int>\n+{\n+    // not ok for either struct, due to the use of two lifetimes\n+}\n+\n+pub fn main() {\n+    foo::<IntStruct>();\n+    foo::<UintStruct>(); //~ ERROR type mismatch\n+\n+    bar::<IntStruct>(); //~ ERROR type mismatch\n+    bar::<UintStruct>();\n+\n+    baz::<IntStruct>(); //~ ERROR type mismatch\n+    baz::<UintStruct>(); //~ ERROR type mismatch\n+}"}, {"sha": "2c6ee502fca3ed115cb5bc34330825e3b5a18806", "filename": "src/test/compile-fail/associated-types-for-unimpl-trait.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-for-unimpl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-for-unimpl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-for-unimpl-trait.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Get {\n+    type Value;\n+    fn get(&self) -> <Self as Get>::Value;\n+}\n+\n+trait Other {\n+    fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n+    //~^ ERROR the trait `Get` is not implemented for the type `Self`\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "fcd3e4d1636468379318c1529e6d177801126726", "filename": "src/test/compile-fail/associated-types-in-ambiguous-context.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-ambiguous-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-ambiguous-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-ambiguous-context.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -18,16 +18,6 @@ trait Get {\n fn get<T:Get,U:Get>(x: T, y: U) -> Get::Value {}\n //~^ ERROR ambiguous associated type\n \n-trait Other {\n-    fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-    //~^ ERROR no suitable bound on `Self`\n-}\n-\n-impl<T:Get> Other for T {\n-    fn uhoh<U:Get>(&self, foo: U, bar: <(T, U) as Get>::Value) {}\n-    //~^ ERROR currently unsupported\n-}\n-\n trait Grab {\n     type Value;\n     fn grab(&self) -> Grab::Value;"}, {"sha": "7e4e1315110af5e29281044b22111db0f1fe08d2", "filename": "src/test/compile-fail/associated-types-incomplete-object.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-incomplete-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-incomplete-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-incomplete-object.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the user gets an errror if they omit a binding from an\n+// object type.\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo {\n+    type A;\n+    type B;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+struct Bar;\n+\n+impl Foo for int {\n+    type A = uint;\n+    type B = char;\n+    fn boo(&self) -> uint {\n+        42\n+    }\n+}\n+\n+pub fn main() {\n+    let a = &42i as &Foo<A=uint, B=char>;\n+\n+    let b = &42i as &Foo<A=uint>;\n+    //~^ ERROR the value of the associated type `B` (from the trait `Foo`) must be specified\n+\n+    let c = &42i as &Foo<B=char>;\n+    //~^ ERROR the value of the associated type `A` (from the trait `Foo`) must be specified\n+\n+    let d = &42i as &Foo;\n+    //~^ ERROR the value of the associated type `A` (from the trait `Foo`) must be specified\n+    //~| ERROR the value of the associated type `B` (from the trait `Foo`) must be specified\n+}"}, {"sha": "6b856204091516dd47b31839ae9d46fccad15ed6", "filename": "src/test/compile-fail/associated-types-no-suitable-bound.rs", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-bound.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -15,16 +15,13 @@ trait Get {\n     fn get(&self) -> <Self as Get>::Value;\n }\n \n-fn get(x: int) -> <int as Get>::Value {}\n-//~^ ERROR unsupported\n-\n struct Struct {\n     x: int,\n }\n \n impl Struct {\n     fn uhoh<T>(foo: <T as Get>::Value) {}\n-    //~^ ERROR no suitable bound on `T`\n+    //~^ ERROR the trait `Get` is not implemented for the type `T`\n }\n \n fn main() {", "previous_filename": "src/test/compile-fail/associated-types-in-wrong-context.rs"}, {"sha": "5a4ebeac41eef0f3f5d47165b033a180fbfdf9cd", "filename": "src/test/compile-fail/associated-types-no-suitable-supertrait.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-no-suitable-supertrait.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+// Check that we get an error when you use `<Self as Get>::Value` in\n+// the trait definition but `Self` does not, in fact, implement `Get`.\n+\n+trait Get {\n+    type Value;\n+}\n+\n+trait Other {\n+    fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n+    //~^ ERROR the trait `Get` is not implemented for the type `Self`\n+}\n+\n+impl<T:Get> Other for T {\n+    fn uhoh<U:Get>(&self, foo: U, bar: <(T, U) as Get>::Value) {}\n+    //~^ ERROR the trait `Get` is not implemented for the type `(T, U)`\n+    //~| ERROR the trait `Get` is not implemented for the type `(T, U)`\n+}\n+\n+fn main() { }"}, {"sha": "41f5bc17b561bb9ee378a3405ff3fc6f4c2fcb18", "filename": "src/test/compile-fail/associated-types-path-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-1.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "previous_filename": "src/test/compile-fail/assoc-path-1.rs"}, {"sha": "486d3d38c60af7ef845b81776476f2217d5c9780", "filename": "src/test/compile-fail/associated-types-path-2.rs", "status": "renamed", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -26,9 +26,10 @@ pub fn f2<T: Foo>(a: T) -> T::A {\n }\n \n pub fn main() {\n-    f1(2i, 4i); //~ERROR the trait `Foo` is not implemented\n-    f1(2u, 4u); //~ERROR the trait `Foo` is not implemented\n-    f1(2u, 4i); //~ERROR the trait `Foo` is not implemented\n+    f1(2i, 4i); //~ ERROR expected uint, found int\n+    f1(2i, 4u);\n+    f1(2u, 4u); //~ ERROR the trait `Foo` is not implemented\n+    f1(2u, 4i); //~ ERROR the trait `Foo` is not implemented\n \n-    let _: int = f2(2i); //~ERROR mismatched types: expected `int`, found `uint`\n+    let _: int = f2(2i); //~ERROR expected `int`, found `uint`\n }", "previous_filename": "src/test/compile-fail/assoc-path-2.rs"}, {"sha": "1f0f044a4c0c390797287276d8aa36613bdac1be", "filename": "src/test/compile-fail/associated-types-project-from-hrtb-explicit.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-explicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-explicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-explicit.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test you can't use a higher-ranked trait bound inside of a qualified\n+// path (just won't parse).\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo<T> {\n+    type A;\n+\n+    fn get(&self, t: T) -> Self::A;\n+}\n+\n+fn foo2<I>(x: <I as for<'x> Foo<&'x int>>::A)\n+    //~^ ERROR expected identifier, found keyword `for`\n+    //~| ERROR expected one of `::` or `>`\n+{\n+}\n+\n+pub fn main() {}"}, {"sha": "8cdca50d9b6bd077401d1098cd0dd3b50da51418", "filename": "src/test/compile-fail/associated-types-project-from-hrtb-in-fn-body.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-fn-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-fn-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-fn-body.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check projection of an associated type out of a higher-ranked\n+// trait-bound in the context of a function body.\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo<T> {\n+    type A;\n+\n+    fn get(&self, t: T) -> Self::A;\n+}\n+\n+fn foo<'a, I : for<'x> Foo<&'x int>>(\n+    x: <I as Foo<&'a int>>::A)\n+{\n+    let y: I::A = x;\n+}\n+\n+fn bar<'a, 'b, I : for<'x> Foo<&'x int>>(\n+    x: <I as Foo<&'a int>>::A,\n+    y: <I as Foo<&'b int>>::A,\n+    cond: bool)\n+{ //~ ERROR cannot infer\n+    // x and y here have two distinct lifetimes:\n+    let z: I::A = if cond { x } else { y };\n+}\n+\n+pub fn main() {}"}, {"sha": "0d5c69591423b8605414358a77a133aaa977b001", "filename": "src/test/compile-fail/associated-types-project-from-hrtb-in-fn.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-fn.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check projection of an associated type out of a higher-ranked trait-bound\n+// in the context of a function signature.\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo<T> {\n+    type A;\n+\n+    fn get(&self, t: T) -> Self::A;\n+}\n+\n+fn foo2<I : for<'x> Foo<&'x int>>(\n+    x: I::A)\n+    //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n+{\n+    // This case is illegal because we have to instantiate `'x`, and\n+    // we don't know what region to instantiate it with.\n+    //\n+    // This could perhaps be made equivalent to the examples below,\n+    // specifically for fn signatures.\n+}\n+\n+fn foo3<I : for<'x> Foo<&'x int>>(\n+    x: <I as Foo<&int>>::A)\n+{\n+    // OK, in this case we spelled out the precise regions involved, though we left one of\n+    // them anonymous.\n+}\n+\n+fn foo4<'a, I : for<'x> Foo<&'x int>>(\n+    x: <I as Foo<&'a int>>::A)\n+{\n+    // OK, in this case we spelled out the precise regions involved.\n+}\n+\n+\n+pub fn main() {}"}, {"sha": "5016c6448a50e7322eb2117526540e951c46900d", "filename": "src/test/compile-fail/associated-types-project-from-hrtb-in-struct.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-struct.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check projection of an associated type out of a higher-ranked trait-bound\n+// in the context of a struct definition.\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo<T> {\n+    type A;\n+\n+    fn get(&self, t: T) -> Self::A;\n+}\n+\n+struct SomeStruct<I : for<'x> Foo<&'x int>> {\n+    field: I::A\n+    //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n+}\n+\n+struct AnotherStruct<I : for<'x> Foo<&'x int>> {\n+    field: <I as Foo<&int>>::A\n+    //~^ ERROR missing lifetime specifier\n+}\n+\n+struct YetAnotherStruct<'a, I : for<'x> Foo<&'x int>> {\n+    field: <I as Foo<&'a int>>::A\n+}\n+\n+pub fn main() {}"}, {"sha": "a92d4ec04cb20ca6bef96d2f2455f88831e0b6e5", "filename": "src/test/compile-fail/associated-types-project-from-hrtb-in-trait-method.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-trait-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-trait-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-trait-method.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check projection of an associated type out of a higher-ranked trait-bound\n+// in the context of a method definition in a trait.\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo<T> {\n+    type A;\n+\n+    fn get(&self, t: T) -> Self::A;\n+}\n+\n+trait SomeTrait<I : for<'x> Foo<&'x int>> {\n+    fn some_method(&self, arg: I::A);\n+    //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n+}\n+\n+trait AnotherTrait<I : for<'x> Foo<&'x int>> {\n+    fn some_method(&self, arg: <I as Foo<&int>>::A);\n+}\n+\n+trait YetAnotherTrait<I : for<'x> Foo<&'x int>> {\n+    fn some_method<'a>(&self, arg: <I as Foo<&'a int>>::A);\n+}\n+\n+pub fn main() {}"}, {"sha": "78502efdec520f17d762af200a251fa09e36e0ee", "filename": "src/test/compile-fail/issue-12028.rs", "status": "renamed", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fissue-12028.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fissue-12028.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12028.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test an example where we fail to infer the type parameter H. This\n+// is because there is really nothing constraining it. At one time, we\n+// would infer based on the where clauses in scope, but that no longer\n+// works.\n+\n trait Hash<H> {\n     fn hash2(&self, hasher: &H) -> u64;\n }\n@@ -30,7 +35,7 @@ trait StreamHash<S: Stream, H: StreamHasher<S>>: Hash<H> {\n impl<S: Stream, H: StreamHasher<S>> Hash<H> for u8 {\n     fn hash2(&self, hasher: &H) -> u64 {\n         let mut stream = hasher.stream();\n-        self.input_stream(&mut stream);\n+        self.input_stream(&mut stream); //~ ERROR type annotations required\n         stream.result()\n     }\n }", "previous_filename": "src/test/run-pass/issue-12028.rs"}, {"sha": "08b896f387bbed5d13e5f2bd2ef0f01c7261b34c", "filename": "src/test/compile-fail/issue-15965.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fissue-15965.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fissue-15965.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15965.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -12,8 +12,6 @@ fn main() {\n     return\n         { return () }\n //~^ ERROR the type of this value must be known in this context\n-//~| ERROR this function takes 1 parameter\n-//~| ERROR mismatched types\n     ()\n     ;\n }"}, {"sha": "e93acb3f064af5c38b441e4d8d33e4e4fee808d7", "filename": "src/test/compile-fail/issue-18345.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fissue-18345.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fissue-18345.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18345.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -15,7 +15,6 @@ fn mapping<'f, R, T, U>(f: |T|: 'f -> U) -> &'f Transducer<'f, R, T, U> {\n     |step| |r, x|\n         step(r, f(x))\n         //~^ ERROR the type of this value must be known in this context\n-        //~| ERROR this function takes 1 parameter but 2 parameters were supplied\n }\n \n fn main() {}"}, {"sha": "9cf922ae99002cece4c190e728b073e601c0a9be", "filename": "src/test/compile-fail/issue-18532.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -17,5 +17,4 @@\n fn main() {\n     (return)((),());\n     //~^ ERROR the type of this value must be known\n-    //~| ERROR this function takes 1 parameter\n }"}, {"sha": "49eeccb2b0cf177177d45ed3339c040ba5bd4a9c", "filename": "src/test/compile-fail/issue-18611.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fissue-18611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fissue-18611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18611.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -10,10 +10,9 @@\n \n #![feature(associated_types)]\n \n-fn add_state(op:\n-    <int as HasState>::State\n-//~^ ERROR it is currently unsupported to access associated types except through a type parameter\n-) {}\n+fn add_state(op: <int as HasState>::State) {\n+//~^ ERROR the trait `HasState` is not implemented for the type `int`\n+}\n \n trait HasState {\n     type State;"}, {"sha": "c11b5d2287855d9e71fa7a4ee442f375afac07fe", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -41,14 +41,14 @@ enum Boo {\n     Quux(Bar<uint>),\n }\n \n-struct Badness<T> {\n+struct Badness<U> {\n //~^ ERROR not implemented\n-    b: Foo<T>,\n+    b: Foo<U>,\n }\n \n-enum MoreBadness<T> {\n+enum MoreBadness<V> {\n //~^ ERROR not implemented\n-    EvenMoreBadness(Bar<T>),\n+    EvenMoreBadness(Bar<V>),\n }\n \n trait PolyTrait<T> {"}, {"sha": "651f663fc991343fe35c2ec64877b5fba854f698", "filename": "src/test/compile-fail/trait-static-method-generic-inference.rs", "status": "renamed", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Ftrait-static-method-generic-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Ftrait-static-method-generic-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-static-method-generic-inference.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Issue #3902. We are (at least currently) unable to infer `Self`\n+// based on `T`, even though there is only a single impl, because of\n+// the possibility of associated types and other things (basically: no\n+// constraints on `Self` here at all).\n+\n mod base {\n     pub trait HasNew<T> {\n         fn new() -> T;\n@@ -22,19 +27,11 @@ mod base {\n             Foo { dummy: () }\n         }\n     }\n-\n-    pub struct Bar {\n-        dummy: (),\n-    }\n-\n-    impl HasNew<Bar> for Bar {\n-        fn new() -> Bar {\n-            Bar { dummy: () }\n-        }\n-    }\n }\n \n-pub fn main() {\n+pub fn foo() {\n     let _f: base::Foo = base::HasNew::new();\n-    let _b: base::Bar = base::HasNew::new();\n+    //~^ ERROR type annotations required\n }\n+\n+fn main() { }", "previous_filename": "src/test/run-pass/trait-static-method-generic-inference.rs"}, {"sha": "5c61212a7f5a56324b4c7388acc6dcdd03e09315", "filename": "src/test/compile-fail/transmute-different-sizes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -21,7 +21,7 @@ unsafe fn f() {\n \n unsafe fn g<T>(x: &T) {\n     let _: i8 = transmute(x);\n-    //~^ ERROR transmute called on types with different sizes\n+    //~^ ERROR transmute called on types with potentially different sizes\n }\n \n fn main() {}"}, {"sha": "5e81a4cec2284b915ad942b53294dfbc8ca9b0d2", "filename": "src/test/compile-fail/transmute-fat-pointers.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Ftransmute-fat-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Ftransmute-fat-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-fat-pointers.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that are conservative around thin/fat pointer mismatches.\n+\n+#![allow(dead_code)]\n+\n+use std::mem::transmute;\n+\n+fn a<T, Sized? U>(x: &[T]) -> &U {\n+    unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n+}\n+\n+fn b<Sized? T, Sized? U>(x: &T) -> &U {\n+    unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n+}\n+\n+fn c<T, U>(x: &T) -> &U {\n+    unsafe { transmute(x) }\n+}\n+\n+fn d<T, U>(x: &[T]) -> &[U] {\n+    unsafe { transmute(x) }\n+}\n+\n+fn e<Sized? T, U>(x: &T) -> &U {\n+    unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n+}\n+\n+fn f<T, Sized? U>(x: &T) -> &U {\n+    unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n+}\n+\n+fn main() { }"}, {"sha": "8b5a8c679b245b6392883f23c1cda222c5038fa5", "filename": "src/test/compile-fail/transmute-impl.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Ftransmute-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Ftransmute-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-impl.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that are conservative around thin/fat pointer mismatches.\n+\n+#![allow(dead_code)]\n+\n+use std::mem::transmute;\n+\n+struct Foo<Sized? T> {\n+    t: Box<T>\n+}\n+\n+impl<Sized? T> Foo<T> {\n+    fn m(x: &T) -> &int where T : Sized {\n+        // OK here, because T : Sized is in scope.\n+        unsafe { transmute(x) }\n+    }\n+\n+    fn n(x: &T) -> &int {\n+        // Not OK here, because T : Sized is not in scope.\n+        unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "2c8a2b361d596be0a6e15ade8dff5ea4d9f19143", "filename": "src/test/compile-fail/unsized-inherent-impl-self-type.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Funsized-inherent-impl-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Funsized-inherent-impl-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-inherent-impl-self-type.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test sized-ness checking in substitution in impls.\n+\n+// impl - struct\n+\n+struct S5<Y>;\n+\n+impl<Sized? X> S5<X> { //~ ERROR not implemented\n+}\n+\n+fn main() { }"}, {"sha": "0f0a97fab4d7580560e214803861d4d8b99f3953", "filename": "src/test/compile-fail/unsized-trait-impl-self-type.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-self-type.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test sized-ness checking in substitution in impls.\n+\n+// impl - struct\n+trait T3<Sized? Z> {\n+}\n+\n+struct S5<Y>;\n+\n+impl<Sized? X> T3<X> for S5<X> { //~ ERROR not implemented\n+}\n+\n+fn main() { }"}, {"sha": "bdb652b168a8c5fac1bd12379f53bb7d416b3c3c", "filename": "src/test/compile-fail/unsized-trait-impl-trait-arg.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-trait-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-trait-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-trait-arg.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test sized-ness checking in substitution in impls.\n+\n+// impl - unbounded\n+trait T2<Z> {\n+}\n+struct S4<Sized? Y>;\n+impl<Sized? X> T2<X> for S4<X> {\n+    //~^ ERROR `core::kinds::Sized` is not implemented for the type `X`\n+}\n+\n+fn main() { }"}, {"sha": "0537fc1f94ad77dfaef5aa2fa7389501da7773e0", "filename": "src/test/compile-fail/unsized4.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Funsized4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Funsized4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized4.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -11,8 +11,9 @@\n // Test that bounds are sized-compatible.\n \n trait T {}\n+\n fn f<Sized? Y: T>() {\n-//~^ERROR incompatible bounds on type parameter `Y`, bound `T` does not allow unsized type\n+//~^ERROR incompatible bounds on `Y`, bound `T` does not allow unsized type\n }\n \n pub fn main() {"}, {"sha": "c0e6ae1db92c4aacc0a8b914eb81a81fe14b8c38", "filename": "src/test/compile-fail/unsized7.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Funsized7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Funsized7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized7.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -21,23 +21,4 @@ impl<Sized? X: T> T1<X> for S3<X> {\n     //~^ ERROR `core::kinds::Sized` is not implemented for the type `X`\n }\n \n-// impl - unbounded\n-trait T2<Z> {\n-}\n-struct S4<Sized? Y>;\n-impl<Sized? X> T2<X> for S4<X> {\n-    //~^ ERROR `core::kinds::Sized` is not implemented for the type `X`\n-}\n-\n-// impl - struct\n-trait T3<Sized? Z> {\n-}\n-struct S5<Y>;\n-impl<Sized? X> T3<X> for S5<X> { //~ ERROR not implemented\n-}\n-\n-impl<Sized? X> S5<X> { //~ ERROR not implemented\n-}\n-\n-\n fn main() { }"}, {"sha": "fa38482b21c50eea054a66293810fa16c7fcc37c", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -14,7 +14,7 @@\n // Regions that just appear in normal spots are contravariant:\n \n #[rustc_variance]\n-struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[];[];[]]\n+struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[];[]]\n     x: &'a int,\n     y: &'b [int],\n     c: &'c str\n@@ -23,7 +23,7 @@ struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[];[];[]]\n // Those same annotations in function arguments become covariant:\n \n #[rustc_variance]\n-struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[];[];[]]\n+struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[];[]]\n     x: extern \"Rust\" fn(&'a int),\n     y: extern \"Rust\" fn(&'b [int]),\n     c: extern \"Rust\" fn(&'c str),\n@@ -32,15 +32,15 @@ struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[];[];[]]\n // Mutability induces invariance:\n \n #[rustc_variance]\n-struct Test4<'a, 'b:'a> { //~ ERROR regions=[[-, o];[];[];[]]\n+struct Test4<'a, 'b:'a> { //~ ERROR regions=[[-, o];[];[]]\n     x: &'a mut &'b int,\n }\n \n // Mutability induces invariance, even when in a\n // contravariant context:\n \n #[rustc_variance]\n-struct Test5<'a, 'b> { //~ ERROR regions=[[+, o];[];[];[]]\n+struct Test5<'a, 'b> { //~ ERROR regions=[[+, o];[];[]]\n     x: extern \"Rust\" fn(&'a mut &'b int),\n }\n \n@@ -50,21 +50,21 @@ struct Test5<'a, 'b> { //~ ERROR regions=[[+, o];[];[];[]]\n // argument list occurs in an invariant context.\n \n #[rustc_variance]\n-struct Test6<'a, 'b> { //~ ERROR regions=[[-, o];[];[];[]]\n+struct Test6<'a, 'b> { //~ ERROR regions=[[-, o];[];[]]\n     x: &'a mut extern \"Rust\" fn(&'b int),\n }\n \n // No uses at all is bivariant:\n \n #[rustc_variance]\n-struct Test7<'a> { //~ ERROR regions=[[*];[];[];[]]\n+struct Test7<'a> { //~ ERROR regions=[[*];[];[]]\n     x: int\n }\n \n // Try enums too.\n \n #[rustc_variance]\n-enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[];[]]\n+enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[]]\n     Test8A(extern \"Rust\" fn(&'a int)),\n     Test8B(&'b [int]),\n     Test8C(&'b mut &'c str),"}, {"sha": "c049fbc0fedbc758ca213476087b234949c06e72", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -13,29 +13,29 @@\n // Try enums too.\n \n #[rustc_variance]\n-enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[[+, -, o, *];[];[];[]]\n+enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[[+, -, o, *];[];[]]\n     Test8A(extern \"Rust\" fn(&'a int)),\n     Test8B(&'b [int]),\n     Test8C(&'b mut &'c str),\n }\n \n #[rustc_variance]\n-struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[[*, o, -, +];[];[];[]]\n+struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[[*, o, -, +];[];[]]\n     f: Base<'z, 'y, 'x, 'w>\n }\n \n #[rustc_variance] // Combine - and + to yield o\n-struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[[o, o, *];[];[];[]]\n+struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[[o, o, *];[];[]]\n     f: Base<'a, 'a, 'b, 'c>\n }\n \n #[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n-struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[[o, -, *];[];[];[]]\n+struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[[o, -, *];[];[]]\n     f: Base<'a, 'b, 'a, 'c>\n }\n \n #[rustc_variance] // Combine + and * to yield + (just pay attention to 'a here)\n-struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[];[]]\n+struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[]]\n     f: Base<'a, 'b, 'c, 'a>\n }\n "}, {"sha": "c61f2ff79c0192b5120796fd23e291c0acef6c92", "filename": "src/test/compile-fail/variance-trait-object-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -19,7 +19,7 @@ use std::mem;\n trait T { fn foo(); }\n \n #[rustc_variance]\n-struct TOption<'a> { //~ ERROR regions=[[-];[];[];[]]\n+struct TOption<'a> { //~ ERROR regions=[[-];[];[]]\n     v: Option<Box<T + 'a>>,\n }\n "}, {"sha": "fcfcce3ff1b78d879d9925ccf327e26907b7fc6c", "filename": "src/test/run-pass/associated-types-basic.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-basic.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Foo {\n+    type T;\n+}\n+\n+impl Foo for i32 {\n+    type T = int;\n+}\n+\n+fn main() {\n+    let x: <i32 as Foo>::T = 22;\n+    let y: int = 44;\n+    assert_eq!(x * 2, y);\n+}\n+"}, {"sha": "c3300c529357526e36d31763335eab41910ebee2", "filename": "src/test/run-pass/associated-types-binding-in-where-clause.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-binding-in-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-binding-in-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-binding-in-where-clause.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints on associated types in a where clause.\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo {\n+    type A;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+#[deriving(PartialEq)]\n+struct Bar;\n+\n+impl Foo for int {\n+    type A = uint;\n+    fn boo(&self) -> uint { 42 }\n+}\n+\n+impl Foo for char {\n+    type A = Bar;\n+    fn boo(&self) -> Bar { Bar }\n+}\n+\n+fn foo_bar<I: Foo<A=Bar>>(x: I) -> Bar {\n+    x.boo()\n+}\n+\n+fn foo_uint<I: Foo<A=uint>>(x: I) -> uint {\n+    x.boo()\n+}\n+\n+pub fn main() {\n+    let a = 42i;\n+    foo_uint(a);\n+\n+    let a = 'a';\n+    foo_bar(a);\n+}"}, {"sha": "db5119132cc3fe1574edbf82b44a0cdc3124c22c", "filename": "src/test/run-pass/associated-types-bound.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-bound.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints on associated types in a where clause.\n+\n+#![feature(associated_types)]\n+\n+pub trait ToInt {\n+    fn to_int(&self) -> int;\n+}\n+\n+impl ToInt for int {\n+    fn to_int(&self) -> int { *self }\n+}\n+\n+impl ToInt for uint {\n+    fn to_int(&self) -> int { *self as int }\n+}\n+\n+pub trait GetToInt\n+{\n+    type R : ToInt;\n+\n+    fn get(&self) -> <Self as GetToInt>::R;\n+}\n+\n+impl GetToInt for int {\n+    type R = int;\n+    fn get(&self) -> int { *self }\n+}\n+\n+impl GetToInt for uint {\n+    type R = uint;\n+    fn get(&self) -> uint { *self }\n+}\n+\n+fn foo<G>(g: G) -> int\n+    where G : GetToInt\n+{\n+    ToInt::to_int(&g.get())\n+}\n+\n+pub fn main() {\n+    assert_eq!(foo(22i), 22i);\n+    assert_eq!(foo(22u), 22i);\n+}"}, {"sha": "c0cf917aa41174dc8a07f44ea1013263c9a4f636", "filename": "src/test/run-pass/associated-types-cc.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-cc.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:associated-types-cc-lib.rs\n+\n+// Test that we are able to reference cross-crate traits that employ\n+// associated types.\n+\n+#![feature(associated_types)]\n+\n+extern crate \"associated-types-cc-lib\" as bar;\n+\n+use bar::Bar;\n+\n+fn foo<B:Bar>(b: B) -> <B as Bar>::T {\n+    Bar::get(None::<B>)\n+}\n+\n+fn main() {\n+    println!(\"{}\", foo(3i));\n+}"}, {"sha": "ea2cf84b757c3b84a867bfcba7476e72a31b02ca", "filename": "src/test/run-pass/associated-types-constant-type.rs", "status": "renamed", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-constant-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-constant-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-constant-type.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -8,25 +8,35 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that we correctly infer that `E` must be `()` here.  This is\n-// known because there is just one impl that could apply where\n-// `Self=()`.\n+#![feature(associated_types)]\n \n-pub trait FromError<E> {\n-    fn from_error(err: E) -> Self;\n+trait SignedUnsigned {\n+    type Opposite;\n+    fn convert(self) -> Self::Opposite;\n }\n \n-impl<E> FromError<E> for E {\n-    fn from_error(err: E) -> E {\n-        err\n+impl SignedUnsigned for int {\n+    type Opposite = uint;\n+\n+    fn convert(self) -> uint {\n+        self as uint\n+    }\n+}\n+\n+impl SignedUnsigned for uint {\n+    type Opposite = int;\n+\n+    fn convert(self) -> int {\n+        self as int\n     }\n }\n \n-fn test() -> Result<(), ()> {\n-    Err(FromError::from_error(()))\n+fn get(x: int) -> <int as SignedUnsigned>::Opposite {\n+    x.convert()\n }\n \n fn main() {\n-    let result = (|| Err(FromError::from_error(())))();\n-    let foo: () = result.unwrap_or(());\n+    let x = get(22);\n+    assert_eq!(22u, x);\n }\n+", "previous_filename": "src/test/run-pass/multidispatch-infer-from-single-impl.rs"}, {"sha": "f0343a743cb5025b1fb926e12f1619ff4cd891ee", "filename": "src/test/run-pass/associated-types-eq-obj.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-eq-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-eq-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-eq-obj.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints on associated types inside of an object type\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo {\n+    type A;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+struct Bar;\n+\n+impl Foo for char {\n+    type A = Bar;\n+    fn boo(&self) -> Bar { Bar }\n+}\n+\n+fn baz(x: &Foo<A=Bar>) -> Bar {\n+    x.boo()\n+}\n+\n+pub fn main() {\n+    let a = 'a';\n+    baz(&a);\n+}"}, {"sha": "f09c27029d7fa448e90bf77eeb89c87ce2d439c2", "filename": "src/test/run-pass/associated-types-normalize-in-bounds.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we normalize associated types that appear in bounds; if\n+// we didn't, the call to `self.split2()` fails to type check.\n+\n+#![feature(associated_types)]\n+\n+struct Splits<'a, T, P>;\n+struct SplitsN<I>;\n+\n+trait SliceExt2 for Sized? {\n+    type Item;\n+\n+    fn split2<'a, P>(&'a self, pred: P) -> Splits<'a, Self::Item, P>\n+        where P: FnMut(&Self::Item) -> bool;\n+    fn splitn2<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, Self::Item, P>>\n+        where P: FnMut(&Self::Item) -> bool;\n+}\n+\n+impl<T> SliceExt2 for [T] {\n+    type Item = T;\n+\n+    fn split2<P>(&self, pred: P) -> Splits<T, P> where P: FnMut(&T) -> bool {\n+        loop {}\n+    }\n+\n+    fn splitn2<P>(&self, n: uint, pred: P) -> SplitsN<Splits<T, P>> where P: FnMut(&T) -> bool {\n+        self.split2(pred);\n+        loop {}\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "d8e277510ed106867b25182ce80af0c38358c49d", "filename": "src/test/run-pass/associated-types-return.rs", "status": "renamed", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-return.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test equality constraints on associated types.\n+// Test equality constraints on associated types in a where clause.\n \n #![feature(associated_types)]\n \n@@ -17,16 +17,19 @@ pub trait Foo {\n     fn boo(&self) -> <Self as Foo>::A;\n }\n \n+#[deriving(PartialEq)]\n struct Bar;\n \n impl Foo for int {\n     type A = uint;\n     fn boo(&self) -> uint { 42 }\n }\n+\n impl Foo for Bar {\n     type A = int;\n     fn boo(&self) -> int { 43 }\n }\n+\n impl Foo for char {\n     type A = Bar;\n     fn boo(&self) -> Bar { Bar }\n@@ -35,12 +38,10 @@ impl Foo for char {\n fn foo1<I: Foo<A=Bar>>(x: I) -> Bar {\n     x.boo()\n }\n+\n fn foo2<I: Foo>(x: I) -> <I as Foo>::A {\n     x.boo()\n }\n-fn baz(x: &Foo<A=Bar>) -> Bar {\n-    x.boo()\n-}\n \n pub fn main() {\n     let a = 42i;\n@@ -51,5 +52,5 @@ pub fn main() {\n \n     let a = 'a';\n     foo1(a);\n-    baz(&a);\n+    assert!(foo2(a) == Bar);\n }", "previous_filename": "src/test/run-pass/assoc-eq.rs"}, {"sha": "28c06f51cebc25d2ba7075a8d5448f9dd896325e", "filename": "src/test/run-pass/associated-types-sugar-path.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-sugar-path.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "previous_filename": "src/test/run-pass/assoc-sugar-path.rs"}, {"sha": "57724ba91b02f317e9a3e05ef067d7596f4143be", "filename": "src/test/run-pass/issue-19081.rs", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fissue-19081.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fissue-19081.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19081.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -8,17 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty -- FIXME(#17362) pretty prints as `Hash<<Self as Hasher...` which fails to parse\n+\n #![feature(associated_types)]\n \n-pub trait Hasher{\n+pub trait Hasher {\n     type State;\n \n     fn hash<T: Hash<\n-        <Self as Hasher>::State //~ ERROR no suitable bound on `Self`\n+        <Self as Hasher>::State\n     >>(&self, value: &T) -> u64;\n }\n \n-trait Hash<S> {\n+pub trait Hash<S> {\n     fn hash(&self, state: &mut S);\n }\n ", "previous_filename": "src/test/compile-fail/issue-19081.rs"}, {"sha": "79afb856be26fce01c2f50d15ea59f236e296157", "filename": "src/test/run-pass/issue-19121.rs", "status": "renamed", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fissue-19121.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84f5ad8679c7fc454473ffbf389030f3e5fee379/src%2Ftest%2Frun-pass%2Fissue-19121.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19121.rs?ref=84f5ad8679c7fc454473ffbf389030f3e5fee379", "patch": "@@ -17,6 +17,8 @@ trait Foo {\n     type A;\n }\n \n-fn bar(x: &Foo) {} //~ERROR missing type for associated type `A`\n+fn bar(x: &Foo) {}\n+// FIXME(#19482) -- `Foo` should specify `A`, but this is not\n+// currently enforced except at object creation\n \n pub fn main() {}", "previous_filename": "src/test/compile-fail/issue-19121.rs"}]}