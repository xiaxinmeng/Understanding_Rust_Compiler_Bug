{"sha": "207c6e7fa74758a64104c2d77218e263d92cf1c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwN2M2ZTdmYTc0NzU4YTY0MTA0YzJkNzcyMThlMjYzZDkyY2YxYzY=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T04:13:33Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T21:26:36Z"}, "message": "Improve comments and code clarity.", "tree": {"sha": "ef1843ef0bb28eacd897cd295609dbfd2d940a0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef1843ef0bb28eacd897cd295609dbfd2d940a0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/207c6e7fa74758a64104c2d77218e263d92cf1c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/207c6e7fa74758a64104c2d77218e263d92cf1c6", "html_url": "https://github.com/rust-lang/rust/commit/207c6e7fa74758a64104c2d77218e263d92cf1c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/207c6e7fa74758a64104c2d77218e263d92cf1c6/comments", "author": null, "committer": null, "parents": [{"sha": "9ba3ef2a44118fb2692a65a04500cdef4f6036d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ba3ef2a44118fb2692a65a04500cdef4f6036d5", "html_url": "https://github.com/rust-lang/rust/commit/9ba3ef2a44118fb2692a65a04500cdef4f6036d5"}], "stats": {"total": 18, "additions": 11, "deletions": 7}, "files": [{"sha": "9dad302706c27722aad426b2e3cc748f4530065f", "filename": "src/shims/sync.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/207c6e7fa74758a64104c2d77218e263d92cf1c6/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/207c6e7fa74758a64104c2d77218e263d92cf1c6/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=207c6e7fa74758a64104c2d77218e263d92cf1c6", "patch": "@@ -80,7 +80,8 @@ fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n // bytes 8-11: when count > 0, id of the owner thread as a u32\n // bytes 12-15 or 16-19 (depending on platform): mutex kind, as an i32\n // (the kind has to be at its offset for compatibility with static initializer macros)\n-// bytes 20-23: when count > 0, id of the blockset in which the blocked threads are waiting.\n+// bytes 20-23: when count > 0, id of the blockset in which the blocked threads\n+// are waiting or 0 if blockset is not yet assigned.\n \n const PTHREAD_MUTEX_T_MIN_SIZE: u64 = 24;\n \n@@ -170,9 +171,9 @@ fn mutex_get_or_create_blockset<'mir, 'tcx: 'mir>(\n // bytes 4-7: reader count, as a u32\n // bytes 8-11: writer count, as a u32\n // bytes 12-15: when writer or reader count > 0, id of the blockset in which the\n-// blocked writers are waiting.\n+// blocked writers are waiting or 0 if blockset is not yet assigned.\n // bytes 16-20: when writer count > 0, id of the blockset in which the blocked\n-// readers are waiting.\n+// readers are waiting or 0 if blockset is not yet assigned.\n \n const PTHREAD_RWLOCK_T_MIN_SIZE: u64 = 20;\n \n@@ -342,8 +343,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Ok(0)\n         } else {\n             // The mutex is locked. Let's check by whom.\n-            let owner_thread: ThreadId =\n-                mutex_get_owner(this, mutex_op)?.not_undef()?.to_u32()?.into();\n+            let owner_thread: ThreadId = mutex_get_owner(this, mutex_op)?.to_u32()?.into();\n             if owner_thread != active_thread {\n                 // Block the active thread.\n                 let blockset = mutex_get_or_create_blockset(this, mutex_op)?;\n@@ -425,6 +425,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 mutex_set_owner(this, mutex_op, new_owner.to_u32_scalar())?;\n             } else {\n                 // No thread is waiting on this mutex.\n+                mutex_set_owner(this, mutex_op, Scalar::from_u32(0))?;\n                 mutex_set_locked_count(this, mutex_op, Scalar::from_u32(0))?;\n             }\n             Ok(0)\n@@ -550,10 +551,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Ok(0)\n         } else if writers != 0 {\n             let reader_blockset = rwlock_get_or_create_reader_blockset(this, rwlock_op)?;\n-            rwlock_set_writers(this, rwlock_op, Scalar::from_u32(0))?;\n+            // We are prioritizing writers here against the readers. As a\n+            // result, not only readers can starve writers, but also writers can\n+            // starve readers.\n             if let Some(_writer) = this.unblock_some_thread(writer_blockset)? {\n                 rwlock_set_writers(this, rwlock_op, Scalar::from_u32(1))?;\n             } else {\n+                rwlock_set_writers(this, rwlock_op, Scalar::from_u32(0))?;\n                 let mut readers = 0;\n                 while let Some(_reader) = this.unblock_some_thread(reader_blockset)? {\n                     readers += 1;"}, {"sha": "9408dbe56cd91eed1cbc00b7a94a73efe26ec782", "filename": "src/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/207c6e7fa74758a64104c2d77218e263d92cf1c6/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/207c6e7fa74758a64104c2d77218e263d92cf1c6/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=207c6e7fa74758a64104c2d77218e263d92cf1c6", "patch": "@@ -1,8 +1,8 @@\n //! Implements threads.\n \n-use std::convert::TryInto;\n use std::cell::RefCell;\n use std::convert::TryFrom;\n+use std::convert::TryInto;\n use std::num::NonZeroU32;\n \n use log::trace;"}]}