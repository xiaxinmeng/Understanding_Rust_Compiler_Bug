{"sha": "ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMmM0ZjZiZTYxMzA1YzhiYjQ4N2UwZjdjYWU3NjBmNTkxOGZlMDc=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-09-20T10:27:16Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-09-20T10:27:16Z"}, "message": "Merge pull request #290 from SiegeLord/tabs\n\nInitial implementation of hard tab indentation.", "tree": {"sha": "aa22ad53618ae4d5630a14734a32b527c1e7899d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa22ad53618ae4d5630a14734a32b527c1e7899d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "html_url": "https://github.com/rust-lang/rust/commit/ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e1fff8710d9ad67cdfac08dbd6ffcb0c6fc4bc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e1fff8710d9ad67cdfac08dbd6ffcb0c6fc4bc4", "html_url": "https://github.com/rust-lang/rust/commit/4e1fff8710d9ad67cdfac08dbd6ffcb0c6fc4bc4"}, {"sha": "01bdcd001443d7639fc0127e31c61e5ff4e98464", "url": "https://api.github.com/repos/rust-lang/rust/commits/01bdcd001443d7639fc0127e31c61e5ff4e98464", "html_url": "https://github.com/rust-lang/rust/commit/01bdcd001443d7639fc0127e31c61e5ff4e98464"}], "stats": {"total": 724, "additions": 514, "deletions": 210}, "files": [{"sha": "c59638d9e50e4b1815b6704ffb26a18929eba597", "filename": "src/chains.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -19,8 +19,9 @@\n // we put each subexpression on a separate, much like the (default) function\n // argument function argument strategy.\n \n+use Indent;\n use rewrite::{Rewrite, RewriteContext};\n-use utils::{first_line_width, make_indent};\n+use utils::first_line_width;\n use expr::rewrite_call;\n \n use syntax::{ast, ptr};\n@@ -30,7 +31,7 @@ use syntax::print::pprust;\n pub fn rewrite_chain(mut expr: &ast::Expr,\n                      context: &RewriteContext,\n                      width: usize,\n-                     offset: usize)\n+                     offset: Indent)\n                      -> Option<String> {\n     let total_span = expr.span;\n     let mut subexpr_list = vec![expr];\n@@ -116,7 +117,7 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n     let connector = if fits_single_line {\n         String::new()\n     } else {\n-        format!(\"\\n{}\", make_indent(indent))\n+        format!(\"\\n{}\", indent.to_string(context.config))\n     };\n \n     let first_connector = if extend {\n@@ -145,7 +146,7 @@ fn rewrite_chain_expr(expr: &ast::Expr,\n                       span: Span,\n                       context: &RewriteContext,\n                       width: usize,\n-                      offset: usize)\n+                      offset: Indent)\n                       -> Option<String> {\n     match expr.node {\n         ast::Expr_::ExprMethodCall(ref method_name, ref types, ref expressions) => {\n@@ -179,7 +180,7 @@ fn rewrite_method_call(method_name: ast::Ident,\n                        span: Span,\n                        context: &RewriteContext,\n                        width: usize,\n-                       offset: usize)\n+                       offset: Indent)\n                        -> Option<String> {\n     let type_str = if types.is_empty() {\n         String::new()"}, {"sha": "765d61cfa119baa2f6fe93bbf9ba5fa0fdc463d2", "filename": "src/comment.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -12,10 +12,16 @@\n \n use std::iter;\n \n+use Indent;\n+use config::Config;\n use string::{StringFormat, rewrite_string};\n-use utils::make_indent;\n \n-pub fn rewrite_comment(orig: &str, block_style: bool, width: usize, offset: usize) -> String {\n+pub fn rewrite_comment(orig: &str,\n+                       block_style: bool,\n+                       width: usize,\n+                       offset: Indent,\n+                       config: &Config)\n+                       -> String {\n     let s = orig.trim();\n \n     // Edge case: block comments. Let's not trim their lines (for now).\n@@ -33,11 +39,12 @@ pub fn rewrite_comment(orig: &str, block_style: bool, width: usize, offset: usiz\n         line_start: line_start,\n         line_end: \"\",\n         width: max_chars,\n-        offset: offset + opener.len() - line_start.len(),\n+        offset: offset + (opener.len() - line_start.len()),\n         trim_end: true,\n+        config: config,\n     };\n \n-    let indent_str = make_indent(offset);\n+    let indent_str = offset.to_string(config);\n     let line_breaks = s.chars().filter(|&c| c == '\\n').count();\n \n     let (_, mut s) = s.lines()\n@@ -288,27 +295,32 @@ impl<T> Iterator for CharClasses<T> where T: Iterator, T::Item: RichChar {\n mod test {\n     use super::{CharClasses, CodeCharKind, contains_comment, rewrite_comment, FindUncommented};\n \n-    // FIXME(#217): prevent string literal from going over the limit.\n+    use Indent;\n     #[test]\n     #[rustfmt_skip]\n     fn format_comments() {\n-        assert_eq!(\"/* test */\", rewrite_comment(\" //test\", true, 100, 100));\n-        assert_eq!(\"// comment\\n// on a\", rewrite_comment(\"// comment on a\", false, 10, 0));\n+        let config = Default::default();\n+        assert_eq!(\"/* test */\", rewrite_comment(\" //test\", true, 100, Indent::new(0, 100),\n+                                                 &config));\n+        assert_eq!(\"// comment\\n// on a\", rewrite_comment(\"// comment on a\", false, 10,\n+                                                          Indent::empty(), &config));\n \n         assert_eq!(\"//  A multi line comment\\n            // between args.\",\n                    rewrite_comment(\"//  A multi line comment\\n             // between args.\",\n                                    false,\n                                    60,\n-                                   12));\n+                                   Indent::new(0, 12),\n+                                   &config));\n \n         let input = \"// comment\";\n         let expected =\n             \"/* com\\n                                                                      \\\n              * men\\n                                                                      \\\n              * t */\";\n-        assert_eq!(expected, rewrite_comment(input, true, 9, 69));\n+        assert_eq!(expected, rewrite_comment(input, true, 9, Indent::new(0, 69), &config));\n \n-        assert_eq!(\"/* trimmed */\", rewrite_comment(\"/*   trimmed    */\", true, 100, 100));\n+        assert_eq!(\"/* trimmed */\", rewrite_comment(\"/*   trimmed    */\", true, 100,\n+                                                    Indent::new(0, 100), &config));\n     }\n \n     // This is probably intended to be a non-test fn, but it is not used. I'm"}, {"sha": "c5b777e1d81cd12ac230bfd059ea88deafa39e73", "filename": "src/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -246,6 +246,7 @@ create_config! {\n     format_strings: bool, \"Format string literals, or leave as is\",\n     chains_overflow_last: bool, \"Allow last call in method chain to break the line\",\n     take_source_hints: bool, \"Retain some formatting characteristics from the source code\",\n+    hard_tabs: bool, \"Use tab characters for indentation, spaces for alignment\",\n }\n \n impl Default for Config {\n@@ -279,6 +280,7 @@ impl Default for Config {\n             format_strings: true,\n             chains_overflow_last: true,\n             take_source_hints: true,\n+            hard_tabs: false,\n         }\n     }\n }"}, {"sha": "74d5522cc596be517c2622cb6b1d57bed522ad27", "filename": "src/expr.rs", "status": "modified", "additions": 76, "deletions": 59, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -11,11 +11,11 @@\n use std::cmp::Ordering;\n use std::borrow::Borrow;\n \n+use Indent;\n use rewrite::{Rewrite, RewriteContext};\n use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic};\n use string::{StringFormat, rewrite_string};\n-use utils::{span_after, make_indent, extra_offset, first_line_width, last_line_width, wrap_str,\n-            binary_search};\n+use utils::{span_after, extra_offset, first_line_width, last_line_width, wrap_str, binary_search};\n use visitor::FmtVisitor;\n use config::{StructLitStyle, MultilineStyle};\n use comment::{FindUncommented, rewrite_comment, contains_comment};\n@@ -29,7 +29,7 @@ use syntax::codemap::{CodeMap, Span, BytePos, mk_sp};\n use syntax::visit::Visitor;\n \n impl Rewrite for ast::Expr {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match self.node {\n             ast::Expr_::ExprVec(ref expr_vec) => {\n                 rewrite_array(expr_vec.iter().map(|e| &**e), self.span, context, width, offset)\n@@ -164,7 +164,7 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n                             span: Span,\n                             context: &RewriteContext,\n                             width: usize,\n-                            offset: usize)\n+                            offset: Indent)\n                             -> Option<String>\n     where I: Iterator<Item = &'a ast::Expr>\n {\n@@ -201,6 +201,7 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n         h_width: max_item_width,\n         v_width: max_item_width,\n         ends_with_newline: false,\n+        config: context.config,\n     };\n     let list_str = try_opt!(write_list(&items, &fmt));\n \n@@ -215,7 +216,7 @@ fn rewrite_closure(capture: ast::CaptureClause,\n                    span: Span,\n                    context: &RewriteContext,\n                    width: usize,\n-                   offset: usize)\n+                   offset: Indent)\n                    -> Option<String> {\n     let mover = if capture == ast::CaptureClause::CaptureByValue {\n         \"move \"\n@@ -258,14 +259,15 @@ fn rewrite_closure(capture: ast::CaptureClause,\n         h_width: horizontal_budget,\n         v_width: budget,\n         ends_with_newline: false,\n+        config: context.config,\n     };\n     let list_str = try_opt!(write_list(&arg_items.collect::<Vec<_>>(), &fmt));\n     let mut prefix = format!(\"{}|{}|\", mover, list_str);\n \n     if !ret_str.is_empty() {\n         if prefix.contains('\\n') {\n             prefix.push('\\n');\n-            prefix.push_str(&make_indent(argument_offset));\n+            prefix.push_str(&argument_offset.to_string(context.config));\n         } else {\n             prefix.push(' ');\n         }\n@@ -308,18 +310,18 @@ fn rewrite_closure(capture: ast::CaptureClause,\n                            .as_ref()\n                            .and_then(|body_expr| {\n                                if let ast::Expr_::ExprBlock(ref inner) = body_expr.node {\n-                                   Some(inner.rewrite(&context, 2, 0))\n+                                   Some(inner.rewrite(&context, 2, Indent::empty()))\n                                } else {\n                                    None\n                                }\n                            })\n-                           .unwrap_or_else(|| body.rewrite(&context, 2, 0));\n+                           .unwrap_or_else(|| body.rewrite(&context, 2, Indent::empty()));\n \n     Some(format!(\"{} {}\", prefix, try_opt!(body_rewrite)))\n }\n \n impl Rewrite for ast::Block {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         let user_str = context.snippet(self.span);\n         if user_str == \"{}\" && width >= 2 {\n             return Some(user_str);\n@@ -341,7 +343,8 @@ impl Rewrite for ast::Block {\n                 let prefix = if !trimmed.is_empty() {\n                     // 9 = \"unsafe  {\".len(), 7 = \"unsafe \".len()\n                     let budget = try_opt!(width.checked_sub(9));\n-                    format!(\"unsafe {} \", rewrite_comment(trimmed, true, budget, offset + 7))\n+                    format!(\"unsafe {} \",\n+                            rewrite_comment(trimmed, true, budget, offset + 7, context.config))\n                 } else {\n                     \"unsafe \".to_owned()\n                 };\n@@ -381,7 +384,7 @@ impl Rewrite for ast::Block {\n \n // FIXME(#18): implement pattern formatting\n impl Rewrite for ast::Pat {\n-    fn rewrite(&self, context: &RewriteContext, _: usize, _: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, _: usize, _: Indent) -> Option<String> {\n         Some(context.snippet(self.span))\n     }\n }\n@@ -447,7 +450,7 @@ impl<'a> Loop<'a> {\n }\n \n impl<'a> Rewrite for Loop<'a> {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         let label_string = rewrite_label(self.label);\n         // 2 = \" {\".len()\n         let inner_width = try_opt!(width.checked_sub(self.keyword.len() + 2 + label_string.len()));\n@@ -483,7 +486,7 @@ fn rewrite_range(context: &RewriteContext,\n                  left: Option<&ast::Expr>,\n                  right: Option<&ast::Expr>,\n                  width: usize,\n-                 offset: usize)\n+                 offset: Indent)\n                  -> Option<String> {\n     let left_string = match left {\n         Some(expr) => {\n@@ -513,7 +516,7 @@ fn rewrite_if_else(context: &RewriteContext,\n                    else_block_opt: Option<&ast::Expr>,\n                    pat: Option<&ast::Pat>,\n                    width: usize,\n-                   offset: usize,\n+                   offset: Indent,\n                    allow_single_line: bool)\n                    -> Option<String> {\n     // 3 = \"if \", 2 = \" {\"\n@@ -588,11 +591,11 @@ fn single_line_if_else(context: &RewriteContext,\n \n         let new_width = try_opt!(width.checked_sub(pat_expr_str.len() + fixed_cost));\n         let if_expr = if_node.expr.as_ref().unwrap();\n-        let if_str = try_opt!(if_expr.rewrite(context, new_width, 0));\n+        let if_str = try_opt!(if_expr.rewrite(context, new_width, Indent::empty()));\n \n         let new_width = try_opt!(new_width.checked_sub(if_str.len()));\n         let else_expr = else_node.expr.as_ref().unwrap();\n-        let else_str = try_opt!(else_expr.rewrite(context, new_width, 0));\n+        let else_str = try_opt!(else_expr.rewrite(context, new_width, Indent::empty()));\n \n         // FIXME: this check shouldn't be necessary. Rewrites should either fail\n         // or wrap to a newline when the object does not fit the width.\n@@ -621,7 +624,7 @@ fn rewrite_match(context: &RewriteContext,\n                  cond: &ast::Expr,\n                  arms: &[ast::Arm],\n                  width: usize,\n-                 offset: usize)\n+                 offset: Indent)\n                  -> Option<String> {\n     if arms.is_empty() {\n         return None;\n@@ -634,7 +637,7 @@ fn rewrite_match(context: &RewriteContext,\n \n     let nested_context = context.nested_context();\n     let arm_indent = nested_context.block_indent + context.overflow_indent;\n-    let arm_indent_str = make_indent(arm_indent);\n+    let arm_indent_str = arm_indent.to_string(context.config);\n \n     let open_brace_pos = span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])),\n                                     \"{\",\n@@ -669,7 +672,7 @@ fn rewrite_match(context: &RewriteContext,\n         result.push_str(&arm_indent_str);\n \n         let arm_str = arm.rewrite(&nested_context,\n-                                  context.config.max_width - arm_indent,\n+                                  context.config.max_width - arm_indent.width(),\n                                   arm_indent);\n         if let Some(ref arm_str) = arm_str {\n             result.push_str(arm_str);\n@@ -684,7 +687,7 @@ fn rewrite_match(context: &RewriteContext,\n     // match expression, but meh.\n \n     result.push('\\n');\n-    result.push_str(&make_indent(context.block_indent + context.overflow_indent));\n+    result.push_str(&(context.block_indent + context.overflow_indent).to_string(context.config));\n     result.push('}');\n     Some(result)\n }\n@@ -704,9 +707,9 @@ fn arm_end_pos(arm: &ast::Arm) -> BytePos {\n \n // Match arms.\n impl Rewrite for ast::Arm {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         let &ast::Arm { ref attrs, ref pats, ref guard, ref body } = self;\n-        let indent_str = make_indent(offset);\n+        let indent_str = offset.to_string(context.config);\n \n         // FIXME this is all a bit grotty, would be nice to abstract out the\n         // treatment of attributes.\n@@ -734,7 +737,7 @@ impl Rewrite for ast::Arm {\n                                     .map(|p| {\n                                         p.rewrite(context,\n                                                   pat_budget,\n-                                                  offset + context.config.tab_spaces)\n+                                                  offset.block_indent(context.config))\n                                     })\n                                     .collect::<Option<Vec<_>>>());\n \n@@ -775,7 +778,12 @@ impl Rewrite for ast::Arm {\n         // Where the next text can start.\n         let mut line_start = last_line_width(&pats_str);\n         if pats_str.find('\\n').is_none() {\n-            line_start += offset;\n+            line_start += offset.width();\n+        }\n+\n+        let mut line_indent = offset + pats_width;\n+        if vertical {\n+            line_indent = line_indent.block_indent(context.config);\n         }\n \n         let comma = if let ast::ExprBlock(_) = body.node {\n@@ -788,7 +796,7 @@ impl Rewrite for ast::Arm {\n         // 4 = ` => `.len()\n         if context.config.max_width > line_start + comma.len() + 4 {\n             let budget = context.config.max_width - line_start - comma.len() - 4;\n-            if let Some(ref body_str) = body.rewrite(context, budget, line_start + 4) {\n+            if let Some(ref body_str) = body.rewrite(context, budget, line_indent + 4) {\n                 if first_line_width(body_str) <= budget {\n                     return Some(format!(\"{}{} => {}{}\",\n                                         attr_str.trim_left(),\n@@ -810,7 +818,7 @@ impl Rewrite for ast::Arm {\n         Some(format!(\"{}{} =>\\n{}{},\",\n                      attr_str.trim_left(),\n                      pats_str,\n-                     make_indent(offset + context.config.tab_spaces),\n+                     offset.block_indent(context.config).to_string(context.config),\n                      body_str))\n     }\n }\n@@ -819,7 +827,7 @@ impl Rewrite for ast::Arm {\n fn rewrite_guard(context: &RewriteContext,\n                  guard: &Option<ptr::P<ast::Expr>>,\n                  width: usize,\n-                 offset: usize,\n+                 offset: Indent,\n                  // The amount of space used up on this line for the pattern in\n                  // the arm (excludes offset).\n                  pattern_width: usize)\n@@ -840,10 +848,10 @@ fn rewrite_guard(context: &RewriteContext,\n         if overhead < width {\n             let cond_str = guard.rewrite(context,\n                                          width - overhead,\n-                                         offset + context.config.tab_spaces);\n+                                         offset.block_indent(context.config));\n             if let Some(cond_str) = cond_str {\n                 return Some(format!(\"\\n{}if {}\",\n-                                    make_indent(offset + context.config.tab_spaces),\n+                                    offset.block_indent(context.config).to_string(context.config),\n                                     cond_str));\n             }\n         }\n@@ -862,7 +870,7 @@ fn rewrite_pat_expr(context: &RewriteContext,\n                     // *without* trailing space.\n                     connector: &str,\n                     width: usize,\n-                    offset: usize)\n+                    offset: Indent)\n                     -> Option<String> {\n     let pat_offset = offset + matcher.len();\n     let mut result = match pat {\n@@ -898,9 +906,11 @@ fn rewrite_pat_expr(context: &RewriteContext,\n \n     // The expression won't fit on the current line, jump to next.\n     result.push('\\n');\n-    result.push_str(&make_indent(pat_offset));\n+    result.push_str(&pat_offset.to_string(context.config));\n \n-    let expr_rewrite = expr.rewrite(context, context.config.max_width - pat_offset, pat_offset);\n+    let expr_rewrite = expr.rewrite(context,\n+                                    context.config.max_width - pat_offset.width(),\n+                                    pat_offset);\n     result.push_str(&&try_opt!(expr_rewrite));\n \n     Some(result)\n@@ -909,7 +919,7 @@ fn rewrite_pat_expr(context: &RewriteContext,\n fn rewrite_string_lit(context: &RewriteContext,\n                       span: Span,\n                       width: usize,\n-                      offset: usize)\n+                      offset: Indent)\n                       -> Option<String> {\n     if !context.config.format_strings {\n         return Some(context.snippet(span));\n@@ -923,6 +933,7 @@ fn rewrite_string_lit(context: &RewriteContext,\n         width: width,\n         offset: offset,\n         trim_end: false,\n+        config: context.config,\n     };\n \n     let string_lit = context.snippet(span);\n@@ -936,7 +947,7 @@ pub fn rewrite_call<R>(context: &RewriteContext,\n                        args: &[ptr::P<ast::Expr>],\n                        span: Span,\n                        width: usize,\n-                       offset: usize)\n+                       offset: Indent)\n                        -> Option<String>\n     where R: Rewrite\n {\n@@ -955,7 +966,7 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n                          args: &[ptr::P<ast::Expr>],\n                          span: Span,\n                          width: usize,\n-                         offset: usize)\n+                         offset: Indent)\n                          -> Result<String, Ordering>\n     where R: Rewrite\n {\n@@ -1003,7 +1014,7 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n                              span.lo,\n                              span.hi);\n \n-    let fmt = ListFormatting::for_fn(remaining_width, offset);\n+    let fmt = ListFormatting::for_fn(remaining_width, offset, context.config);\n     let list_str = match write_list(&items.collect::<Vec<_>>(), &fmt) {\n         Some(str) => str,\n         None => return Err(Ordering::Less),\n@@ -1015,9 +1026,9 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n fn rewrite_paren(context: &RewriteContext,\n                  subexpr: &ast::Expr,\n                  width: usize,\n-                 offset: usize)\n+                 offset: Indent)\n                  -> Option<String> {\n-    debug!(\"rewrite_paren, width: {}, offset: {}\", width, offset);\n+    debug!(\"rewrite_paren, width: {}, offset: {:?}\", width, offset);\n     // 1 is for opening paren, 2 is for opening+closing, we want to keep the closing\n     // paren on the same line as the subexpr.\n     let subexpr_str = subexpr.rewrite(context, try_opt!(width.checked_sub(2)), offset + 1);\n@@ -1031,9 +1042,9 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                           base: Option<&'a ast::Expr>,\n                           span: Span,\n                           width: usize,\n-                          offset: usize)\n+                          offset: Indent)\n                           -> Option<String> {\n-    debug!(\"rewrite_struct_lit: width {}, offset {}\", width, offset);\n+    debug!(\"rewrite_struct_lit: width {}, offset {:?}\", width, offset);\n     assert!(!fields.is_empty() || base.is_some());\n \n     enum StructLitField<'a> {\n@@ -1054,8 +1065,8 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         StructLitStyle::Block => {\n             // If we are all on one line, then we'll ignore the indent, and we\n             // have a smaller budget.\n-            let indent = context.block_indent + context.config.tab_spaces;\n-            let v_budget = context.config.max_width.checked_sub(indent).unwrap_or(0);\n+            let indent = context.block_indent.block_indent(context.config);\n+            let v_budget = context.config.max_width.checked_sub(indent.width()).unwrap_or(0);\n             (indent, v_budget)\n         }\n     };\n@@ -1121,12 +1132,15 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         h_width: h_budget,\n         v_width: v_budget,\n         ends_with_newline: false,\n+        config: context.config,\n     };\n     let fields_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n     let format_on_newline = || {\n-        let inner_indent = make_indent(context.block_indent + context.config.tab_spaces);\n-        let outer_indent = make_indent(context.block_indent);\n+        let inner_indent = context.block_indent\n+                                  .block_indent(context.config)\n+                                  .to_string(context.config);\n+        let outer_indent = context.block_indent.to_string(context.config);\n         Some(format!(\"{} {{\\n{}{}\\n{}}}\", path_str, inner_indent, fields_str, outer_indent))\n     };\n \n@@ -1143,7 +1157,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n fn rewrite_field(context: &RewriteContext,\n                  field: &ast::Field,\n                  width: usize,\n-                 offset: usize)\n+                 offset: Indent)\n                  -> Option<String> {\n     let name = &field.ident.node.to_string();\n     let overhead = name.len() + 2;\n@@ -1156,9 +1170,9 @@ fn rewrite_tuple_lit(context: &RewriteContext,\n                      items: &[ptr::P<ast::Expr>],\n                      span: Span,\n                      width: usize,\n-                     offset: usize)\n+                     offset: Indent)\n                      -> Option<String> {\n-    debug!(\"rewrite_tuple_lit: width: {}, offset: {}\", width, offset);\n+    debug!(\"rewrite_tuple_lit: width: {}, offset: {:?}\", width, offset);\n     let indent = offset + 1;\n     // In case of length 1, need a trailing comma\n     if items.len() == 1 {\n@@ -1173,15 +1187,15 @@ fn rewrite_tuple_lit(context: &RewriteContext,\n                              |item| item.span.lo,\n                              |item| item.span.hi,\n                              |item| {\n-                                 let inner_width = context.config.max_width - indent - 1;\n+                                 let inner_width = context.config.max_width - indent.width() - 1;\n                                  item.rewrite(context, inner_width, indent)\n                                      .unwrap_or(context.snippet(item.span))\n                              },\n                              span.lo + BytePos(1), // Remove parens\n                              span.hi - BytePos(1));\n \n     let budget = try_opt!(width.checked_sub(2));\n-    let fmt = ListFormatting::for_fn(budget, indent);\n+    let fmt = ListFormatting::for_fn(budget, indent, context.config);\n     let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n     Some(format!(\"({})\", list_str))\n@@ -1192,7 +1206,7 @@ fn rewrite_binary_op(context: &RewriteContext,\n                      lhs: &ast::Expr,\n                      rhs: &ast::Expr,\n                      width: usize,\n-                     offset: usize)\n+                     offset: Indent)\n                      -> Option<String> {\n     // FIXME: format comments between operands and operator\n \n@@ -1233,19 +1247,21 @@ fn rewrite_binary_op(context: &RewriteContext,\n     // We have to use multiple lines.\n \n     // Re-evaluate the lhs because we have more space now:\n-    let budget = try_opt!(context.config.max_width.checked_sub(offset + 1 + operator_str.len()));\n+    let budget = try_opt!(context.config\n+                                 .max_width\n+                                 .checked_sub(offset.width() + 1 + operator_str.len()));\n     Some(format!(\"{} {}\\n{}{}\",\n                  try_opt!(lhs.rewrite(context, budget, offset)),\n                  operator_str,\n-                 make_indent(offset),\n+                 offset.to_string(context.config),\n                  rhs_result))\n }\n \n fn rewrite_unary_op(context: &RewriteContext,\n                     op: &ast::UnOp,\n                     expr: &ast::Expr,\n                     width: usize,\n-                    offset: usize)\n+                    offset: Indent)\n                     -> Option<String> {\n     // For some reason, an UnOp is not spanned like BinOp!\n     let operator_str = match *op {\n@@ -1265,7 +1281,7 @@ fn rewrite_assignment(context: &RewriteContext,\n                       rhs: &ast::Expr,\n                       op: Option<&ast::BinOp>,\n                       width: usize,\n-                      offset: usize)\n+                      offset: Indent)\n                       -> Option<String> {\n     let operator_str = match op {\n         Some(op) => context.snippet(op.span),\n@@ -1285,7 +1301,7 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n                                            lhs: S,\n                                            ex: &ast::Expr,\n                                            width: usize,\n-                                           offset: usize)\n+                                           offset: Indent)\n                                            -> Option<String> {\n     let mut result = lhs.into();\n \n@@ -1301,13 +1317,14 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n         None => {\n             // Expression did not fit on the same line as the identifier. Retry\n             // on the next line.\n-            let new_offset = offset + context.config.tab_spaces;\n-            result.push_str(&format!(\"\\n{}\", make_indent(new_offset)));\n+            let new_offset = offset.block_indent(context.config);\n+            result.push_str(&format!(\"\\n{}\", new_offset.to_string(context.config)));\n \n             // FIXME: we probably should related max_width to width instead of config.max_width\n             // where is the 1 coming from anyway?\n-            let max_width = try_opt!(context.config.max_width.checked_sub(new_offset + 1));\n-            let overflow_context = context.overflow_context(context.config.tab_spaces);\n+            let max_width = try_opt!(context.config.max_width.checked_sub(new_offset.width() + 1));\n+            let rhs_indent = Indent::new(context.config.tab_spaces, 0);\n+            let overflow_context = context.overflow_context(rhs_indent);\n             let rhs = ex.rewrite(&overflow_context, max_width, new_offset);\n \n             result.push_str(&&try_opt!(rhs));"}, {"sha": "f5f81015efbd88ccbb972665ca6416f140351a9e", "filename": "src/imports.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use Indent;\n use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n use utils::span_after;\n use rewrite::{Rewrite, RewriteContext};\n@@ -20,7 +21,7 @@ use syntax::codemap::Span;\n \n impl Rewrite for ast::ViewPath {\n     // Returns an empty string when the ViewPath is empty (like foo::bar::{})\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match self.node {\n             ast::ViewPath_::ViewPathList(_, ref path_list) if path_list.is_empty() => {\n                 Some(String::new())\n@@ -68,7 +69,7 @@ fn rewrite_single_use_list(path_str: String, vpi: ast::PathListItem) -> String {\n // Pretty prints a multi-item import.\n // Assumes that path_list.len() > 0.\n pub fn rewrite_use_list(width: usize,\n-                        offset: usize,\n+                        offset: Indent,\n                         path: &ast::Path,\n                         path_list: &[ast::PathListItem],\n                         span: Span,\n@@ -105,6 +106,7 @@ pub fn rewrite_use_list(width: usize,\n         // (loose 1 column (\";\"))\n         v_width: remaining_width,\n         ends_with_newline: false,\n+        config: context.config,\n     };\n \n     let mut items = {"}, {"sha": "a61925798d322e63304b6ce935a3ae8d65dab4ac", "filename": "src/items.rs", "status": "modified", "additions": 70, "deletions": 60, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -10,8 +10,8 @@\n \n // Formatting top-level items - functions, structs, enums, traits, impls.\n \n-use utils::{format_mutability, format_visibility, make_indent, contains_skip, span_after,\n-            end_typaram, wrap_str};\n+use Indent;\n+use utils::{format_mutability, format_visibility, contains_skip, span_after, end_typaram, wrap_str};\n use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n use expr::rewrite_assign_rhs;\n use comment::FindUncommented;\n@@ -34,8 +34,7 @@ impl<'a> FmtVisitor<'a> {\n \n             if let Some(ref ty) = local.ty {\n                 infix.push_str(\": \");\n-                // FIXME: silly width, indent\n-                infix.push_str(&ty.rewrite(&self.get_context(), 1000, 0).unwrap());\n+                infix.push_str(&ty.rewrite(&self.get_context(), 1000, Indent::empty()).unwrap());\n             }\n \n             if local.init.is_some() {\n@@ -52,20 +51,22 @@ impl<'a> FmtVisitor<'a> {\n             let mut result = \"let \".to_owned();\n             let pattern_offset = self.block_indent + result.len() + infix.len();\n             // 1 = ;\n-            let pattern_width = match self.config.max_width.checked_sub(pattern_offset + 1) {\n+            let pattern_width = self.config.max_width.checked_sub(pattern_offset.width() + 1);\n+            let pattern_width = match pattern_width {\n                 Some(width) => width,\n                 None => return,\n             };\n \n-            match local.pat.rewrite(&context, pattern_offset, pattern_width) {\n+            match local.pat.rewrite(&context, pattern_width, pattern_offset) {\n                 Some(ref pat_string) => result.push_str(pat_string),\n                 None => return,\n             }\n \n             result.push_str(&infix);\n \n             if let Some(ref ex) = local.init {\n-                let max_width = match self.config.max_width.checked_sub(context.block_indent + 1) {\n+                let max_width = self.config.max_width.checked_sub(context.block_indent.width() + 1);\n+                let max_width = match max_width {\n                     Some(width) => width,\n                     None => return,\n                 };\n@@ -88,7 +89,7 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     pub fn rewrite_fn(&mut self,\n-                      indent: usize,\n+                      indent: Indent,\n                       ident: ast::Ident,\n                       fd: &ast::FnDecl,\n                       explicit_self: Option<&ast::ExplicitSelf>,\n@@ -124,7 +125,7 @@ impl<'a> FmtVisitor<'a> {\n         // this.\n         if newline_brace {\n             result.push('\\n');\n-            result.push_str(&make_indent(indent));\n+            result.push_str(&indent.to_string(self.config));\n         } else {\n             result.push(' ');\n         }\n@@ -133,7 +134,7 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     pub fn rewrite_required_fn(&mut self,\n-                               indent: usize,\n+                               indent: Indent,\n                                ident: ast::Ident,\n                                sig: &ast::MethodSig,\n                                span: Span)\n@@ -160,7 +161,7 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     fn rewrite_fn_base(&mut self,\n-                       indent: usize,\n+                       indent: Indent,\n                        ident: ast::Ident,\n                        fd: &ast::FnDecl,\n                        explicit_self: Option<&ast::ExplicitSelf>,\n@@ -207,13 +208,15 @@ impl<'a> FmtVisitor<'a> {\n         result.push_str(&generics_str);\n \n         let context = self.get_context();\n-        let ret_str = fd.output.rewrite(&context, self.config.max_width - indent, indent).unwrap();\n+        let ret_str = fd.output\n+                        .rewrite(&context, self.config.max_width - indent.width(), indent)\n+                        .unwrap();\n \n         // Args.\n         let (one_line_budget, multi_line_budget, mut arg_indent) =\n             self.compute_budgets_for_args(&result, indent, ret_str.len(), newline_brace);\n \n-        debug!(\"rewrite_fn: one_line_budget: {}, multi_line_budget: {}, arg_indent: {}\",\n+        debug!(\"rewrite_fn: one_line_budget: {}, multi_line_budget: {}, arg_indent: {:?}\",\n                one_line_budget,\n                multi_line_budget,\n                arg_indent);\n@@ -222,17 +225,17 @@ impl<'a> FmtVisitor<'a> {\n         if one_line_budget <= 0 {\n             if self.config.fn_args_paren_newline {\n                 result.push('\\n');\n-                result.push_str(&make_indent(arg_indent));\n+                result.push_str(&arg_indent.to_string(self.config));\n                 arg_indent = arg_indent + 1; // extra space for `(`\n                 result.push('(');\n             } else {\n                 result.push_str(\"(\\n\");\n-                result.push_str(&make_indent(arg_indent));\n+                result.push_str(&arg_indent.to_string(self.config));\n             }\n         } else if self.config.fn_args_layout == StructLitStyle::Block {\n-            arg_indent = indent + self.config.tab_spaces;\n+            arg_indent = indent.block_indent(self.config);\n             result.push_str(\"(\\n\");\n-            result.push_str(&make_indent(arg_indent));\n+            result.push_str(&arg_indent.to_string(self.config));\n         } else {\n             result.push('(');\n         }\n@@ -266,7 +269,7 @@ impl<'a> FmtVisitor<'a> {\n             // Unless we are formatting args like a block, in which case there\n             // should always be room for the return type.\n             if (result.contains(\"\\n\") ||\n-                result.len() + indent + ret_str.len() > self.config.max_width) &&\n+                result.len() + indent.width() + ret_str.len() > self.config.max_width) &&\n                self.config.fn_args_layout != StructLitStyle::Block {\n                 let indent = match self.config.fn_return_indent {\n                     ReturnIndent::WithWhereClause => indent + 4,\n@@ -277,7 +280,7 @@ impl<'a> FmtVisitor<'a> {\n                 };\n \n                 result.push('\\n');\n-                result.push_str(&make_indent(indent));\n+                result.push_str(&indent.to_string(self.config));\n             } else {\n                 result.push(' ');\n             }\n@@ -326,8 +329,8 @@ impl<'a> FmtVisitor<'a> {\n                     explicit_self: Option<&ast::ExplicitSelf>,\n                     one_line_budget: usize,\n                     multi_line_budget: usize,\n-                    indent: usize,\n-                    arg_indent: usize,\n+                    indent: Indent,\n+                    arg_indent: Indent,\n                     span: Span)\n                     -> Option<String> {\n         let context = self.get_context();\n@@ -386,7 +389,7 @@ impl<'a> FmtVisitor<'a> {\n \n         let indent = match self.config.fn_arg_indent {\n             BlockIndentStyle::Inherit => indent,\n-            BlockIndentStyle::Tabbed => indent + self.config.tab_spaces,\n+            BlockIndentStyle::Tabbed => indent.block_indent(self.config),\n             BlockIndentStyle::Visual => arg_indent,\n         };\n \n@@ -398,23 +401,24 @@ impl<'a> FmtVisitor<'a> {\n             h_width: one_line_budget,\n             v_width: multi_line_budget,\n             ends_with_newline: false,\n+            config: self.config,\n         };\n \n         write_list(&arg_items, &fmt)\n     }\n \n     fn compute_budgets_for_args(&self,\n                                 result: &str,\n-                                indent: usize,\n+                                indent: Indent,\n                                 ret_str_len: usize,\n                                 newline_brace: bool)\n-                                -> (usize, usize, usize) {\n+                                -> (usize, usize, Indent) {\n         let mut budgets = None;\n \n         // Try keeping everything on the same line\n         if !result.contains(\"\\n\") {\n             // 3 = `() `, space is before ret_string\n-            let mut used_space = indent + result.len() + ret_str_len + 3;\n+            let mut used_space = indent.width() + result.len() + ret_str_len + 3;\n             if !newline_brace {\n                 used_space += 2;\n             }\n@@ -425,7 +429,7 @@ impl<'a> FmtVisitor<'a> {\n             };\n \n             // 2 = `()`\n-            let used_space = indent + result.len() + 2;\n+            let used_space = indent.width() + result.len() + 2;\n             let max_space = self.config.ideal_width + self.config.leeway;\n             debug!(\"compute_budgets_for_args: used_space: {}, max_space: {}\",\n                    used_space,\n@@ -439,8 +443,8 @@ impl<'a> FmtVisitor<'a> {\n \n         // Didn't work. we must force vertical layout and put args on a newline.\n         if let None = budgets {\n-            let new_indent = indent + self.config.tab_spaces;\n-            let used_space = new_indent + 2; // account for `(` and `)`\n+            let new_indent = indent.block_indent(self.config);\n+            let used_space = new_indent.width() + 2; // account for `(` and `)`\n             let max_space = self.config.ideal_width + self.config.leeway;\n             if used_space > max_space {\n                 // Whoops! bankrupt.\n@@ -475,13 +479,13 @@ impl<'a> FmtVisitor<'a> {\n         let generics_str = self.format_generics(generics,\n                                                 \" {\",\n                                                 self.block_indent,\n-                                                self.block_indent + self.config.tab_spaces,\n+                                                self.block_indent.block_indent(self.config),\n                                                 codemap::mk_sp(span.lo, body_start))\n                                .unwrap();\n         self.buffer.push_str(&generics_str);\n \n         self.last_pos = body_start;\n-        self.block_indent += self.config.tab_spaces;\n+        self.block_indent = self.block_indent.block_indent(self.config);\n         for (i, f) in enum_def.variants.iter().enumerate() {\n             let next_span_start: BytePos = if i == enum_def.variants.len() - 1 {\n                 span.hi\n@@ -491,7 +495,7 @@ impl<'a> FmtVisitor<'a> {\n \n             self.visit_variant(f, i == enum_def.variants.len() - 1, next_span_start);\n         }\n-        self.block_indent -= self.config.tab_spaces;\n+        self.block_indent = self.block_indent.block_unindent(self.config);\n \n         self.format_missing_with_indent(span.lo + BytePos(enum_snippet.rfind('}').unwrap() as u32));\n         self.buffer.push_str(\"}\");\n@@ -521,7 +525,9 @@ impl<'a> FmtVisitor<'a> {\n                                              |arg| {\n                                                  // FIXME silly width, indent\n                                                  arg.ty\n-                                                    .rewrite(&self.get_context(), 1000, 0)\n+                                                    .rewrite(&self.get_context(),\n+                                                             1000,\n+                                                             Indent::empty())\n                                                     .unwrap()\n                                              },\n                                              span_after(field.span, \"(\", self.codemap),\n@@ -536,7 +542,7 @@ impl<'a> FmtVisitor<'a> {\n                     } else {\n                         0\n                     };\n-                    let budget = self.config.ideal_width - indent - comma_cost - 1; // 1 = )\n+                    let budget = self.config.ideal_width - indent.width() - comma_cost - 1; // 1 = )\n \n                     let fmt = ListFormatting {\n                         tactic: ListTactic::HorizontalVertical,\n@@ -546,6 +552,7 @@ impl<'a> FmtVisitor<'a> {\n                         h_width: budget,\n                         v_width: budget,\n                         ends_with_newline: true,\n+                        config: self.config,\n                     };\n                     let list_str = match write_list(&items.collect::<Vec<_>>(), &fmt) {\n                         Some(list_str) => list_str,\n@@ -601,7 +608,7 @@ impl<'a> FmtVisitor<'a> {\n                      struct_def: &ast::StructDef,\n                      generics: Option<&ast::Generics>,\n                      span: Span,\n-                     offset: usize)\n+                     offset: Indent)\n                      -> Option<String> {\n         let mut result = String::with_capacity(1024);\n \n@@ -654,15 +661,15 @@ impl<'a> FmtVisitor<'a> {\n                                  span.hi);\n \n         // 2 terminators and a semicolon\n-        let used_budget = offset + header_str.len() + generics_str.len() + 3;\n+        let used_budget = offset.width() + header_str.len() + generics_str.len() + 3;\n \n         // Conservative approximation\n         let single_line_cost = (span.hi - struct_def.fields[0].span.lo).0;\n         let break_line = !is_tuple || generics_str.contains('\\n') ||\n                          single_line_cost as usize + used_budget > self.config.max_width;\n \n         let tactic = if break_line {\n-            let indentation = make_indent(offset + self.config.tab_spaces);\n+            let indentation = offset.block_indent(self.config).to_string(self.config);\n             result.push('\\n');\n             result.push_str(&indentation);\n \n@@ -672,23 +679,24 @@ impl<'a> FmtVisitor<'a> {\n         };\n \n         // 1 = ,\n-        let budget = self.config.ideal_width - offset + self.config.tab_spaces - 1;\n+        let budget = self.config.ideal_width - offset.width() + self.config.tab_spaces - 1;\n         let fmt = ListFormatting {\n             tactic: tactic,\n             separator: \",\",\n             trailing_separator: self.config.struct_trailing_comma,\n-            indent: offset + self.config.tab_spaces,\n+            indent: offset.block_indent(self.config),\n             h_width: self.config.max_width,\n             v_width: budget,\n             ends_with_newline: true,\n+            config: self.config,\n         };\n         let list_str = write_list(&items.collect::<Vec<_>>(), &fmt).unwrap();\n \n         result.push_str(&list_str);\n \n         if break_line {\n             result.push('\\n');\n-            result.push_str(&make_indent(offset));\n+            result.push_str(&offset.to_string(self.config));\n         }\n \n         result.push_str(terminator);\n@@ -727,8 +735,8 @@ impl<'a> FmtVisitor<'a> {\n     fn format_generics(&self,\n                        generics: &ast::Generics,\n                        opener: &str,\n-                       offset: usize,\n-                       generics_offset: usize,\n+                       offset: Indent,\n+                       generics_offset: Indent,\n                        span: Span)\n                        -> Option<String> {\n         let mut result = try_opt!(self.rewrite_generics(generics, offset, generics_offset, span));\n@@ -740,7 +748,7 @@ impl<'a> FmtVisitor<'a> {\n                                                                       Density::Tall,\n                                                                       span.hi));\n             result.push_str(&where_clause_str);\n-            result.push_str(&make_indent(self.block_indent));\n+            result.push_str(&self.block_indent.to_string(self.config));\n             result.push('\\n');\n             result.push_str(opener.trim());\n         } else {\n@@ -765,18 +773,18 @@ impl<'a> FmtVisitor<'a> {\n             ast::StructFieldKind::UnnamedField(vis) => format_visibility(vis),\n         };\n         // FIXME silly width, indent\n-        let typ = field.node.ty.rewrite(&self.get_context(), 1000, 0).unwrap();\n+        let typ = field.node.ty.rewrite(&self.get_context(), 1000, Indent::empty()).unwrap();\n \n-        let indent = self.block_indent + self.config.tab_spaces;\n+        let indent = self.block_indent.block_indent(self.config);\n         let mut attr_str = field.node\n                                 .attrs\n                                 .rewrite(&self.get_context(),\n-                                         self.config.max_width - indent,\n+                                         self.config.max_width - indent.width(),\n                                          indent)\n                                 .unwrap();\n         if !attr_str.is_empty() {\n             attr_str.push('\\n');\n-            attr_str.push_str(&make_indent(indent));\n+            attr_str.push_str(&indent.to_string(self.config));\n         }\n \n         match name {\n@@ -787,8 +795,8 @@ impl<'a> FmtVisitor<'a> {\n \n     fn rewrite_generics(&self,\n                         generics: &ast::Generics,\n-                        offset: usize,\n-                        generics_offset: usize,\n+                        offset: Indent,\n+                        generics_offset: Indent,\n                         span: Span)\n                         -> Option<String> {\n         // FIXME: convert bounds to where clauses where they get too big or if\n@@ -801,12 +809,12 @@ impl<'a> FmtVisitor<'a> {\n \n         let offset = match self.config.generics_indent {\n             BlockIndentStyle::Inherit => offset,\n-            BlockIndentStyle::Tabbed => offset + self.config.tab_spaces,\n+            BlockIndentStyle::Tabbed => offset.block_indent(self.config),\n             // 1 = <\n             BlockIndentStyle::Visual => generics_offset + 1,\n         };\n \n-        let h_budget = self.config.max_width - generics_offset - 2;\n+        let h_budget = self.config.max_width - generics_offset.width() - 2;\n         // TODO: might need to insert a newline if the generics are really long.\n \n         // Strings for the generics.\n@@ -841,7 +849,7 @@ impl<'a> FmtVisitor<'a> {\n             item.item = ty;\n         }\n \n-        let fmt = ListFormatting::for_fn(h_budget, offset);\n+        let fmt = ListFormatting::for_fn(h_budget, offset, self.config);\n         let list_str = try_opt!(write_list(&items, &fmt));\n \n         Some(format!(\"<{}>\", list_str))\n@@ -850,7 +858,7 @@ impl<'a> FmtVisitor<'a> {\n     fn rewrite_where_clause(&self,\n                             where_clause: &ast::WhereClause,\n                             config: &Config,\n-                            indent: usize,\n+                            indent: Indent,\n                             density: Density,\n                             span_end: BytePos)\n                             -> Option<String> {\n@@ -859,22 +867,23 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         let extra_indent = match self.config.where_indent {\n-            BlockIndentStyle::Inherit => 0,\n-            BlockIndentStyle::Tabbed | BlockIndentStyle::Visual => config.tab_spaces,\n+            BlockIndentStyle::Inherit => Indent::empty(),\n+            BlockIndentStyle::Tabbed | BlockIndentStyle::Visual => Indent::new(config.tab_spaces,\n+                                                                               0),\n         };\n \n         let context = self.get_context();\n \n         let offset = match self.config.where_pred_indent {\n             BlockIndentStyle::Inherit => indent + extra_indent,\n-            BlockIndentStyle::Tabbed => indent + extra_indent + config.tab_spaces,\n+            BlockIndentStyle::Tabbed => indent + extra_indent.block_indent(config),\n             // 6 = \"where \".len()\n             BlockIndentStyle::Visual => indent + extra_indent + 6,\n         };\n         // FIXME: if where_pred_indent != Visual, then the budgets below might\n         // be out by a char or two.\n \n-        let budget = self.config.ideal_width + self.config.leeway - offset;\n+        let budget = self.config.ideal_width + self.config.leeway - offset.width();\n         let span_start = span_for_where_pred(&where_clause.predicates[0]).lo;\n         let items = itemize_list(self.codemap,\n                                  where_clause.predicates.iter(),\n@@ -896,21 +905,22 @@ impl<'a> FmtVisitor<'a> {\n             h_width: budget,\n             v_width: budget,\n             ends_with_newline: true,\n+            config: self.config,\n         };\n         let preds_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n         // 9 = \" where \".len() + \" {\".len()\n         if density == Density::Tall || preds_str.contains('\\n') ||\n-           indent + 9 + preds_str.len() > self.config.max_width {\n-            Some(format!(\"\\n{}where {}\", make_indent(indent + extra_indent), preds_str))\n+           indent.width() + 9 + preds_str.len() > self.config.max_width {\n+            Some(format!(\"\\n{}where {}\", (indent + extra_indent).to_string(self.config), preds_str))\n         } else {\n             Some(format!(\" where {}\", preds_str))\n         }\n     }\n }\n \n impl Rewrite for ast::FunctionRetTy {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match *self {\n             ast::FunctionRetTy::DefaultReturn(_) => Some(String::new()),\n             ast::FunctionRetTy::NoReturn(_) => {\n@@ -929,7 +939,7 @@ impl Rewrite for ast::FunctionRetTy {\n }\n \n impl Rewrite for ast::Arg {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         if is_named_arg(self) {\n             if let ast::Ty_::TyInfer = self.ty.node {\n                 wrap_str(pprust::pat_to_string(&self.pat), context.config.max_width, width, offset)"}, {"sha": "3015053730950fbfb9af77936b7e52467ab8ced1", "filename": "src/lib.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -44,6 +44,7 @@ use syntax::ast;\n use syntax::codemap::CodeMap;\n use syntax::diagnostics;\n \n+use std::ops::{Add, Sub};\n use std::path::PathBuf;\n use std::collections::HashMap;\n use std::fmt;\n@@ -80,6 +81,83 @@ const MIN_STRING: usize = 10;\n // When we get scoped annotations, we should have rustfmt::skip.\n const SKIP_ANNOTATION: &'static str = \"rustfmt_skip\";\n \n+#[derive(Copy, Clone, Debug)]\n+pub struct Indent {\n+    // Width of the block indent, in characters. Must be a multiple of\n+    // Config::tab_spaces.\n+    block_indent: usize,\n+    // Alignment in characters.\n+    alignment: usize,\n+}\n+\n+impl Indent {\n+    pub fn new(block_indent: usize, alignment: usize) -> Indent {\n+        Indent { block_indent: block_indent, alignment: alignment }\n+    }\n+\n+    pub fn empty() -> Indent {\n+        Indent::new(0, 0)\n+    }\n+\n+    pub fn block_indent(mut self, config: &Config) -> Indent {\n+        self.block_indent += config.tab_spaces;\n+        self\n+    }\n+\n+    pub fn block_unindent(mut self, config: &Config) -> Indent {\n+        self.block_indent -= config.tab_spaces;\n+        self\n+    }\n+\n+    pub fn width(&self) -> usize {\n+        self.block_indent + self.alignment\n+    }\n+\n+    pub fn to_string(&self, config: &Config) -> String {\n+        let (num_tabs, num_spaces) = if config.hard_tabs {\n+            (self.block_indent / config.tab_spaces, self.alignment)\n+        } else {\n+            (0, self.block_indent + self.alignment)\n+        };\n+        let num_chars = num_tabs + num_spaces;\n+        let mut indent = String::with_capacity(num_chars);\n+        for _ in 0..num_tabs {\n+            indent.push('\\t')\n+        }\n+        for _ in 0..num_spaces {\n+            indent.push(' ')\n+        }\n+        indent\n+    }\n+}\n+\n+impl Add for Indent {\n+    type Output = Indent;\n+\n+    fn add(self, rhs: Indent) -> Indent {\n+        Indent {\n+            block_indent: self.block_indent + rhs.block_indent,\n+            alignment: self.alignment + rhs.alignment,\n+        }\n+    }\n+}\n+\n+impl Sub for Indent {\n+    type Output = Indent;\n+\n+    fn sub(self, rhs: Indent) -> Indent {\n+        Indent::new(self.block_indent - rhs.block_indent, self.alignment - rhs.alignment)\n+    }\n+}\n+\n+impl Add<usize> for Indent {\n+    type Output = Indent;\n+\n+    fn add(self, rhs: usize) -> Indent {\n+        Indent::new(self.block_indent, self.alignment + rhs)\n+    }\n+}\n+\n #[derive(Copy, Clone)]\n pub enum WriteMode {\n     // Backups the original file and overwrites the orignal."}, {"sha": "e00e8b0ee375451a48648db6ef84809dcde4419d", "filename": "src/lists.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -13,8 +13,10 @@ use std::iter::Peekable;\n \n use syntax::codemap::{self, CodeMap, BytePos};\n \n-use utils::{round_up_to_power_of_two, make_indent, wrap_str};\n+use Indent;\n+use utils::{round_up_to_power_of_two, wrap_str};\n use comment::{FindUncommented, rewrite_comment, find_comment_end};\n+use config::Config;\n \n #[derive(Eq, PartialEq, Debug, Copy, Clone)]\n pub enum ListTactic {\n@@ -44,18 +46,19 @@ pub struct ListFormatting<'a> {\n     pub tactic: ListTactic,\n     pub separator: &'a str,\n     pub trailing_separator: SeparatorTactic,\n-    pub indent: usize,\n+    pub indent: Indent,\n     // Available width if we layout horizontally.\n     pub h_width: usize,\n     // Available width if we layout vertically\n     pub v_width: usize,\n     // Non-expressions, e.g. items, will have a new line at the end of the list.\n     // Important for comment styles.\n     pub ends_with_newline: bool,\n+    pub config: &'a Config,\n }\n \n impl<'a> ListFormatting<'a> {\n-    pub fn for_fn(width: usize, offset: usize) -> ListFormatting<'a> {\n+    pub fn for_fn(width: usize, offset: Indent, config: &'a Config) -> ListFormatting<'a> {\n         ListFormatting {\n             tactic: ListTactic::HorizontalVertical,\n             separator: \",\",\n@@ -64,6 +67,7 @@ impl<'a> ListFormatting<'a> {\n             h_width: width,\n             v_width: width,\n             ends_with_newline: false,\n+            config: config,\n         }\n     }\n }\n@@ -146,12 +150,12 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n     let alloc_width = if tactic == ListTactic::Horizontal {\n         total_width + total_sep_len\n     } else {\n-        total_width + items.len() * (formatting.indent + 1)\n+        total_width + items.len() * (formatting.indent.width() + 1)\n     };\n     let mut result = String::with_capacity(round_up_to_power_of_two(alloc_width));\n \n     let mut line_len = 0;\n-    let indent_str = &make_indent(formatting.indent);\n+    let indent_str = &formatting.indent.to_string(formatting.config);\n     for (i, item) in items.iter().enumerate() {\n         let first = i == 0;\n         let last = i == items.len() - 1;\n@@ -196,7 +200,8 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n             let block_mode = tactic != ListTactic::Vertical;\n             // Width restriction is only relevant in vertical mode.\n             let max_width = formatting.v_width;\n-            result.push_str(&rewrite_comment(comment, block_mode, max_width, formatting.indent));\n+            result.push_str(&rewrite_comment(comment, block_mode, max_width, formatting.indent,\n+                                             formatting.config));\n \n             if tactic == ListTactic::Vertical {\n                 result.push('\\n');\n@@ -206,14 +211,18 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n             }\n         }\n \n-        let max_width = formatting.indent + formatting.v_width;\n+        let max_width = formatting.indent.width() + formatting.v_width;\n         let item_str = wrap_str(&item.item[..], max_width, formatting.v_width, formatting.indent);\n         result.push_str(&&try_opt!(item_str));\n \n         // Post-comments\n         if tactic != ListTactic::Vertical && item.post_comment.is_some() {\n             let comment = item.post_comment.as_ref().unwrap();\n-            let formatted_comment = rewrite_comment(comment, true, formatting.v_width, 0);\n+            let formatted_comment = rewrite_comment(comment,\n+                                                    true,\n+                                                    formatting.v_width,\n+                                                    Indent::empty(),\n+                                                    formatting.config);\n \n             result.push(' ');\n             result.push_str(&formatted_comment);\n@@ -226,14 +235,19 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n         if tactic == ListTactic::Vertical && item.post_comment.is_some() {\n             // 1 = space between item and comment.\n             let width = formatting.v_width.checked_sub(item_width + 1).unwrap_or(1);\n-            let offset = formatting.indent + item_width + 1;\n+            let mut offset = formatting.indent;\n+            offset.alignment += item_width + 1;\n             let comment = item.post_comment.as_ref().unwrap();\n             // Use block-style only for the last item or multiline comments.\n             let block_style = !formatting.ends_with_newline && last ||\n                               comment.trim().contains('\\n') ||\n                               comment.trim().len() > width;\n \n-            let formatted_comment = rewrite_comment(comment, block_style, width, offset);\n+            let formatted_comment = rewrite_comment(comment,\n+                                                    block_style,\n+                                                    width,\n+                                                    offset,\n+                                                    formatting.config);\n \n             result.push(' ');\n             result.push_str(&formatted_comment);"}, {"sha": "8c38326ee8a49c0836c7b5b4de2a0fd6251cc77b", "filename": "src/macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -25,6 +25,7 @@ use syntax::ast;\n use syntax::parse::token::{Eof, Comma, Token};\n use syntax::parse::{ParseSess, tts_to_parser};\n \n+use Indent;\n use rewrite::RewriteContext;\n use expr::{rewrite_call, rewrite_array};\n use comment::FindUncommented;\n@@ -46,7 +47,7 @@ enum MacroStyle {\n pub fn rewrite_macro(mac: &ast::Mac,\n                      context: &RewriteContext,\n                      width: usize,\n-                     offset: usize)\n+                     offset: Indent)\n                      -> Option<String> {\n     let ast::Mac_::MacInvocTT(ref path, ref tt_vec, _) = mac.node;\n     let style = macro_style(mac, context);"}, {"sha": "db9599c170640fe53af91208e398c08cec0e616a", "filename": "src/missed_spans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use utils::make_indent;\n use visitor::FmtVisitor;\n \n use syntax::codemap::{self, BytePos};\n@@ -21,14 +20,15 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     pub fn format_missing_with_indent(&mut self, end: BytePos) {\n+        let config = self.config;\n         self.format_missing_inner(end,\n                                   |this, last_snippet, snippet| {\n                                       this.buffer.push_str(last_snippet.trim_right());\n                                       if last_snippet == snippet {\n-                // No new lines in the snippet.\n+                                          // No new lines in the snippet.\n                                           this.buffer.push_str(\"\\n\");\n                                       }\n-                                      let indent = make_indent(this.block_indent);\n+                                      let indent = this.block_indent.to_string(config);\n                                       this.buffer.push_str(&indent);\n                                   })\n     }"}, {"sha": "6517bbdf37b41cb38e65e076f530f07d2be24e2e", "filename": "src/rewrite.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -12,6 +12,7 @@\n \n use syntax::codemap::{CodeMap, Span};\n \n+use Indent;\n use config::Config;\n \n pub trait Rewrite {\n@@ -22,33 +23,33 @@ pub trait Rewrite {\n     /// `width` is the maximum number of characters on the last line\n     /// (excluding offset). The width of other lines is not limited by\n     /// `width`.\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String>;\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String>;\n }\n \n pub struct RewriteContext<'a> {\n     pub codemap: &'a CodeMap,\n     pub config: &'a Config,\n \n     // Indentation due to nesting of blocks.\n-    pub block_indent: usize,\n+    pub block_indent: Indent,\n     // *Extra* indentation due to overflowing to the next line, e.g.,\n     // let foo =\n     //     bar();\n     // The extra 4 spaces when formatting `bar()` is overflow_indent.\n-    pub overflow_indent: usize,\n+    pub overflow_indent: Indent,\n }\n \n impl<'a> RewriteContext<'a> {\n     pub fn nested_context(&self) -> RewriteContext<'a> {\n         RewriteContext {\n             codemap: self.codemap,\n             config: self.config,\n-            block_indent: self.block_indent + self.config.tab_spaces,\n+            block_indent: self.block_indent.block_indent(self.config),\n             overflow_indent: self.overflow_indent,\n         }\n     }\n \n-    pub fn overflow_context(&self, overflow: usize) -> RewriteContext<'a> {\n+    pub fn overflow_context(&self, overflow: Indent) -> RewriteContext<'a> {\n         RewriteContext {\n             codemap: self.codemap,\n             config: self.config,"}, {"sha": "4e40b8e9ede536569cf412a55bcfb57546283a92", "filename": "src/string.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -13,7 +13,9 @@\n use unicode_segmentation::UnicodeSegmentation;\n use regex::Regex;\n \n-use utils::{make_indent, round_up_to_power_of_two};\n+use Indent;\n+use config::Config;\n+use utils::round_up_to_power_of_two;\n \n use MIN_STRING;\n \n@@ -23,8 +25,9 @@ pub struct StringFormat<'a> {\n     pub line_start: &'a str,\n     pub line_end: &'a str,\n     pub width: usize,\n-    pub offset: usize,\n+    pub offset: Indent,\n     pub trim_end: bool,\n+    pub config: &'a Config,\n }\n \n // TODO: simplify this!\n@@ -36,7 +39,7 @@ pub fn rewrite_string<'a>(s: &str, fmt: &StringFormat<'a>) -> String {\n \n     let graphemes = UnicodeSegmentation::graphemes(&*stripped_str, false).collect::<Vec<&str>>();\n \n-    let indent = make_indent(fmt.offset);\n+    let indent = fmt.offset.to_string(fmt.config);\n     let indent = &indent;\n \n     let mut cur_start = 0;"}, {"sha": "9ba50a59cd92369c94b2a74d3ad1470905a938a9", "filename": "src/types.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -12,12 +12,13 @@ use syntax::ast;\n use syntax::print::pprust;\n use syntax::codemap::{self, Span, BytePos, CodeMap};\n \n+use Indent;\n use lists::{itemize_list, write_list, ListFormatting};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{extra_offset, span_after};\n \n impl Rewrite for ast::Path {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         rewrite_path(context, None, self, width, offset)\n     }\n }\n@@ -27,7 +28,7 @@ pub fn rewrite_path(context: &RewriteContext,\n                     qself: Option<&ast::QSelf>,\n                     path: &ast::Path,\n                     width: usize,\n-                    offset: usize)\n+                    offset: Indent)\n                     -> Option<String> {\n     let skip_count = qself.map(|x| x.position).unwrap_or(0);\n \n@@ -80,7 +81,7 @@ fn rewrite_path_segments<'a, I>(mut buffer: String,\n                                 span_hi: BytePos,\n                                 context: &RewriteContext,\n                                 width: usize,\n-                                offset: usize)\n+                                offset: Indent)\n                                 -> Option<String>\n     where I: Iterator<Item = &'a ast::PathSegment>\n {\n@@ -128,7 +129,7 @@ impl<'a> SegmentParam<'a> {\n \n impl<'a> Rewrite for SegmentParam<'a> {\n     // FIXME: doesn't always use width, offset.\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         Some(match *self {\n             SegmentParam::LifeTime(ref lt) => {\n                 pprust::lifetime_to_string(lt)\n@@ -186,7 +187,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n                    span_hi: BytePos,\n                    context: &RewriteContext,\n                    width: usize,\n-                   offset: usize)\n+                   offset: Indent)\n                    -> Option<String> {\n     let ident_len = segment.identifier.to_string().len();\n     let width = try_opt!(width.checked_sub(ident_len));\n@@ -229,7 +230,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n                                      list_lo,\n                                      span_hi);\n \n-            let fmt = ListFormatting::for_fn(list_width, offset + extra_offset);\n+            let fmt = ListFormatting::for_fn(list_width, offset + extra_offset, context.config);\n             let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n             // Update position of last bracket.\n@@ -257,7 +258,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n             let budget = try_opt!(width.checked_sub(output.len() + 2));\n \n             // 1 for (\n-            let fmt = ListFormatting::for_fn(budget, offset + 1);\n+            let fmt = ListFormatting::for_fn(budget, offset + 1, context.config);\n             let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n             format!(\"({}){}\", list_str, output)\n@@ -269,7 +270,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n }\n \n impl Rewrite for ast::WherePredicate {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         // TODO: dead spans?\n         // TODO: don't assume we'll always fit on one line...\n         Some(match *self {\n@@ -340,7 +341,7 @@ impl Rewrite for ast::WherePredicate {\n }\n \n impl Rewrite for ast::LifetimeDef {\n-    fn rewrite(&self, _: &RewriteContext, _: usize, _: usize) -> Option<String> {\n+    fn rewrite(&self, _: &RewriteContext, _: usize, _: Indent) -> Option<String> {\n         if self.bounds.is_empty() {\n             Some(pprust::lifetime_to_string(&self.lifetime))\n         } else {\n@@ -356,7 +357,7 @@ impl Rewrite for ast::LifetimeDef {\n }\n \n impl Rewrite for ast::TyParamBound {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match *self {\n             ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::None) => {\n                 tref.rewrite(context, width, offset)\n@@ -372,7 +373,7 @@ impl Rewrite for ast::TyParamBound {\n }\n \n impl Rewrite for ast::TyParamBounds {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         let strs: Vec<_> = self.iter()\n                                .map(|b| b.rewrite(context, width, offset).unwrap())\n                                .collect();\n@@ -382,7 +383,7 @@ impl Rewrite for ast::TyParamBounds {\n \n // FIXME: this assumes everything will fit on one line\n impl Rewrite for ast::TyParam {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         let mut result = String::with_capacity(128);\n         result.push_str(&self.ident.to_string());\n         if !self.bounds.is_empty() {\n@@ -407,7 +408,7 @@ impl Rewrite for ast::TyParam {\n \n // FIXME: this assumes everything will fit on one line\n impl Rewrite for ast::PolyTraitRef {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         if !self.bound_lifetimes.is_empty() {\n             let lifetime_str = self.bound_lifetimes\n                                    .iter()\n@@ -430,7 +431,7 @@ impl Rewrite for ast::PolyTraitRef {\n \n impl Rewrite for ast::Ty {\n     // FIXME doesn't always use width, offset\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match self.node {\n             ast::TyPath(None, ref p) => {\n                 p.rewrite(context, width, offset)"}, {"sha": "171572ccfbf6dd27043a85e0e498a6c0245e8020", "filename": "src/utils.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -13,17 +13,18 @@ use std::cmp::Ordering;\n use syntax::ast::{self, Visibility, Attribute, MetaItem, MetaItem_};\n use syntax::codemap::{CodeMap, Span, BytePos};\n \n+use Indent;\n use comment::FindUncommented;\n use rewrite::{Rewrite, RewriteContext};\n \n use SKIP_ANNOTATION;\n \n // Computes the length of a string's last line, minus offset.\n #[inline]\n-pub fn extra_offset(text: &str, offset: usize) -> usize {\n+pub fn extra_offset(text: &str, offset: Indent) -> usize {\n     match text.rfind('\\n') {\n         // 1 for newline character\n-        Some(idx) => text.len() - idx - 1 - offset,\n+        Some(idx) => text.len() - idx - 1 - offset.width(),\n         None => text.len(),\n     }\n }\n@@ -35,15 +36,6 @@ pub fn span_after(original: Span, needle: &str, codemap: &CodeMap) -> BytePos {\n     original.lo + BytePos(snippet.find_uncommented(needle).unwrap() as u32 + 1)\n }\n \n-#[inline]\n-pub fn make_indent(width: usize) -> String {\n-    let mut indent = String::with_capacity(width);\n-    for _ in 0..width {\n-        indent.push(' ')\n-    }\n-    indent\n-}\n-\n #[inline]\n pub fn format_visibility(vis: Visibility) -> &'static str {\n     match vis {\n@@ -186,7 +178,7 @@ macro_rules! try_opt {\n \n // Wraps string-like values in an Option. Returns Some when the string adheres\n // to the Rewrite constraints defined for the Rewrite trait and else otherwise.\n-pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: usize) -> Option<S> {\n+pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: Indent) -> Option<S> {\n     {\n         let snippet = s.as_ref();\n \n@@ -197,7 +189,7 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: usi\n \n             // The caller of this function has already placed `offset`\n             // characters on the first line.\n-            let first_line_max_len = try_opt!(max_width.checked_sub(offset));\n+            let first_line_max_len = try_opt!(max_width.checked_sub(offset.width()));\n             if lines.next().unwrap().len() > first_line_max_len {\n                 return None;\n             }\n@@ -211,7 +203,7 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: usi\n             // indentation.\n             // A special check for the last line, since the caller may\n             // place trailing characters on this line.\n-            if snippet.lines().rev().next().unwrap().len() > offset + width {\n+            if snippet.lines().rev().next().unwrap().len() > offset.width() + width {\n                 return None;\n             }\n         }\n@@ -221,7 +213,7 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: usi\n }\n \n impl Rewrite for String {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         wrap_str(self, context.config.max_width, width, offset).map(ToOwned::to_owned)\n     }\n }"}, {"sha": "762eda2013a2acc021a32779d215447e717faacc", "filename": "src/visitor.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -14,6 +14,7 @@ use syntax::visit;\n \n use strings::string_buffer::StringBuffer;\n \n+use Indent;\n use utils;\n use config::Config;\n use rewrite::{Rewrite, RewriteContext};\n@@ -25,7 +26,7 @@ pub struct FmtVisitor<'a> {\n     pub buffer: StringBuffer,\n     pub last_pos: BytePos,\n     // TODO: RAII util for indenting\n-    pub block_indent: usize,\n+    pub block_indent: Indent,\n     pub config: &'a Config,\n }\n \n@@ -38,8 +39,9 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                self.codemap.lookup_char_pos(ex.span.hi));\n         self.format_missing(ex.span.lo);\n \n-        let offset = self.buffer.cur_offset();\n-        let rewrite = ex.rewrite(&self.get_context(), self.config.max_width - offset, offset);\n+        let rewrite = ex.rewrite(&self.get_context(),\n+                                 self.config.max_width - self.block_indent.width(),\n+                                 self.block_indent);\n \n         if let Some(new_str) = rewrite {\n             self.buffer.push_str(&new_str);\n@@ -65,7 +67,8 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n \n                 // 1 = trailing semicolon;\n                 let rewrite = ex.rewrite(&self.get_context(),\n-                                         self.config.max_width - self.block_indent - suffix.len(),\n+                                         self.config.max_width - self.block_indent.width() -\n+                                         suffix.len(),\n                                          self.block_indent);\n \n                 if let Some(new_str) = rewrite {\n@@ -96,7 +99,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n         };\n \n         self.last_pos = self.last_pos + brace_compensation;\n-        self.block_indent += self.config.tab_spaces;\n+        self.block_indent = self.block_indent.block_indent(self.config);\n         self.buffer.push_str(\"{\");\n \n         for stmt in &b.stmts {\n@@ -111,8 +114,8 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             None => {}\n         }\n \n-        self.block_indent -= self.config.tab_spaces;\n-        // TODO: we should compress any newlines here to just one.\n+        self.block_indent = self.block_indent.block_unindent(self.config);\n+        // TODO: we should compress any newlines here to just one\n         self.format_missing_with_indent(b.span.hi - brace_compensation);\n         self.buffer.push_str(\"}\");\n         self.last_pos = b.span.hi;\n@@ -126,6 +129,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                 b: &'v ast::Block,\n                 s: Span,\n                 _: ast::NodeId) {\n+\n         let indent = self.block_indent;\n         let rewrite = match fk {\n             visit::FnKind::ItemFn(ident,\n@@ -191,9 +195,9 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             }\n             ast::Item_::ItemImpl(..) |\n             ast::Item_::ItemTrait(..) => {\n-                self.block_indent += self.config.tab_spaces;\n+                self.block_indent = self.block_indent.block_indent(self.config);\n                 visit::walk_item(self, item);\n-                self.block_indent -= self.config.tab_spaces;\n+                self.block_indent = self.block_indent.block_unindent(self.config);\n             }\n             ast::Item_::ItemExternCrate(_) => {\n                 self.format_missing_with_indent(item.span.lo);\n@@ -256,7 +260,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n \n     fn visit_mac(&mut self, mac: &'v ast::Mac) {\n         // 1 = ;\n-        let width = self.config.max_width - self.block_indent - 1;\n+        let width = self.config.max_width - self.block_indent.width() - 1;\n         let rewrite = rewrite_macro(mac, &self.get_context(), width, self.block_indent);\n \n         if let Some(res) = rewrite {\n@@ -272,7 +276,7 @@ impl<'a> FmtVisitor<'a> {\n             codemap: codemap,\n             buffer: StringBuffer::new(),\n             last_pos: BytePos(0),\n-            block_indent: 0,\n+            block_indent: Indent { block_indent: 0, alignment: 0 },\n             config: config,\n         }\n     }\n@@ -302,7 +306,7 @@ impl<'a> FmtVisitor<'a> {\n             true\n         } else {\n             let rewrite = attrs.rewrite(&self.get_context(),\n-                                        self.config.max_width - self.block_indent,\n+                                        self.config.max_width - self.block_indent.width(),\n                                         self.block_indent)\n                                .unwrap();\n             self.buffer.push_str(&rewrite);\n@@ -323,32 +327,33 @@ impl<'a> FmtVisitor<'a> {\n \n         if is_internal {\n             debug!(\"FmtVisitor::format_mod: internal mod\");\n-            self.block_indent += self.config.tab_spaces;\n+            self.block_indent = self.block_indent.block_indent(self.config);\n             visit::walk_mod(self, m);\n             debug!(\"... last_pos after: {:?}\", self.last_pos);\n-            self.block_indent -= self.config.tab_spaces;\n+            self.block_indent = self.block_indent.block_unindent(self.config);\n         }\n     }\n \n     pub fn format_separate_mod(&mut self, m: &ast::Mod, filename: &str) {\n         let filemap = self.codemap.get_filemap(filename);\n         self.last_pos = filemap.start_pos;\n-        self.block_indent = 0;\n+        self.block_indent = Indent::empty();\n         visit::walk_mod(self, m);\n         self.format_missing(filemap.end_pos);\n     }\n \n     fn format_import(&mut self, vis: ast::Visibility, vp: &ast::ViewPath, span: Span) {\n         let vis = utils::format_visibility(vis);\n-        let offset = self.block_indent + vis.len() + \"use \".len();\n+        let mut offset = self.block_indent;\n+        offset.alignment += vis.len() + \"use \".len();\n         let context = RewriteContext {\n             codemap: self.codemap,\n             config: self.config,\n             block_indent: self.block_indent,\n-            overflow_indent: 0,\n+            overflow_indent: Indent::empty(),\n         };\n         // 1 = \";\"\n-        match vp.rewrite(&context, self.config.max_width - offset - 1, offset) {\n+        match vp.rewrite(&context, self.config.max_width - offset.width() - 1, offset) {\n             Some(ref s) if s.is_empty() => {\n                 // Format up to last newline\n                 let prev_span = codemap::mk_sp(self.last_pos, span.lo);\n@@ -377,18 +382,18 @@ impl<'a> FmtVisitor<'a> {\n             codemap: self.codemap,\n             config: self.config,\n             block_indent: self.block_indent,\n-            overflow_indent: 0,\n+            overflow_indent: Indent::empty(),\n         }\n     }\n }\n \n impl<'a> Rewrite for [ast::Attribute] {\n-    fn rewrite(&self, context: &RewriteContext, _: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, _: usize, offset: Indent) -> Option<String> {\n         let mut result = String::new();\n         if self.is_empty() {\n             return Some(result);\n         }\n-        let indent = utils::make_indent(offset);\n+        let indent = offset.to_string(context.config);\n \n         for (i, a) in self.iter().enumerate() {\n             let a_str = context.snippet(a.span);\n@@ -403,8 +408,9 @@ impl<'a> Rewrite for [ast::Attribute] {\n                 if !comment.is_empty() {\n                     let comment = rewrite_comment(comment,\n                                                   false,\n-                                                  context.config.max_width - offset,\n-                                                  offset);\n+                                                  context.config.max_width - offset.width(),\n+                                                  offset,\n+                                                  context.config);\n                     result.push_str(&indent);\n                     result.push_str(&comment);\n                     result.push('\\n');"}, {"sha": "3fe38a5e42ad3c6163b2d1c65aceb968aef0cdcc", "filename": "tests/source/hard-tabs.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/tests%2Fsource%2Fhard-tabs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/tests%2Fsource%2Fhard-tabs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fhard-tabs.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -0,0 +1,69 @@\n+// rustfmt-hard_tabs: true\n+\n+fn main() {\n+let x = Bar;\n+\n+let y = Foo {a: x };\n+\n+Foo { a: foo() /* comment*/, /* comment*/ b: bar(), ..something };\n+\n+fn foo(a: i32, a: i32, a: i32, a: i32, a: i32, a: i32, a: i32, a: i32, a: i32, a: i32, a: i32) {}\n+\n+let str = \"AAAAAAAAAAAAAAaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAa\";\n+\n+if let (some_very_large, tuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuple) = 1\n++ 2 + 3 {\n+}\n+\n+    if cond() {\n+        something();\n+    } else  if different_cond() {\n+        something_else();\n+    } else {\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+    }\n+    \n+unsafe /* very looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong comment */ {}\n+\n+unsafe // So this is a very long comment.\n+   // Multi-line, too.\n+   // Will it still format correctly?\n+{\n+}\n+\n+let z = [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzzzz, q];\n+\n+fn generic<T>(arg: T) -> &SomeType\n+    where T: Fn(// First arg\n+        A,\n+        // Second argument\n+        B, C, D, /* pre comment */ E /* last comment */) -> &SomeType {\n+    arg(a, b, c, d, e)    \n+}\n+\n+    loong_func().quux(move || {\n+        if true {\n+            1\n+        } else {\n+            2\n+        }\n+    });\n+\n+    fffffffffffffffffffffffffffffffffff(a,\n+                                        {\n+                                            SCRIPT_TASK_ROOT\n+                                            .with(|root| {\n+                                                *root.borrow_mut()  =   Some(&script_task);\n+                                            });\n+                                        });\n+    a.b\n+     .c\n+     .d();\n+    \n+    x().y(|| {\n+        match cond() {\n+            true => (),\n+            false => (),\n+        }\n+    });\n+}"}, {"sha": "d8df0c2936a021b7eb47beb1a7c9baea7be0c12c", "filename": "tests/target/hard-tabs.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/tests%2Ftarget%2Fhard-tabs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce2c4f6be61305c8bb487e0f7cae760f5918fe07/tests%2Ftarget%2Fhard-tabs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fhard-tabs.rs?ref=ce2c4f6be61305c8bb487e0f7cae760f5918fe07", "patch": "@@ -0,0 +1,95 @@\n+// rustfmt-hard_tabs: true\n+\n+fn main() {\n+\tlet x = Bar;\n+\n+\tlet y = Foo { a: x };\n+\n+\tFoo {\n+\t\ta: foo(), // comment\n+\t\t// comment\n+\t\tb: bar(),\n+\t\t..something\n+\t};\n+\n+\tfn foo(a: i32,\n+\t       a: i32,\n+\t       a: i32,\n+\t       a: i32,\n+\t       a: i32,\n+\t       a: i32,\n+\t       a: i32,\n+\t       a: i32,\n+\t       a: i32,\n+\t       a: i32,\n+\t       a: i32) {\n+\t}\n+\n+\tlet str = \"AAAAAAAAAAAAAAaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAAAAAAAAAAAAAAAAAAAAA\\\n+\t           AAAAAAAAAAAAaAa\";\n+\n+\tif let (some_very_large, tuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuple) =\n+\t       1 + 2 + 3 {\n+\t}\n+\n+\tif cond() {\n+\t\tsomething();\n+\t} else if different_cond() {\n+\t\tsomething_else();\n+\t} else {\n+\t\taaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +\n+\t\taaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+\t}\n+\n+\tunsafe /* very looooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong\n+\t        * comment */ {\n+\t}\n+\n+\tunsafe /* So this is a very long comment.\n+\t        * Multi-line, too.\n+\t        * Will it still format correctly? */ {\n+\t}\n+\n+\tlet z = [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,\n+\t         yyyyyyyyyyyyyyyyyyyyyyyyyyy,\n+\t         zzzzzzzzzzzzzzzzzz,\n+\t         q];\n+\n+\tfn generic<T>(arg: T) -> &SomeType\n+\t\twhere T: Fn(// First arg\n+\t\t            A,\n+\t\t            // Second argument\n+\t\t            B,\n+\t\t            C,\n+\t\t            D,\n+\t\t            // pre comment\n+\t\t            E /* last comment */) -> &SomeType\n+\t{\n+\t\targ(a, b, c, d, e)\n+\t}\n+\n+\tloong_func().quux(move || {\n+\t\tif true {\n+\t\t\t1\n+\t\t} else {\n+\t\t\t2\n+\t\t}\n+\t});\n+\n+\tfffffffffffffffffffffffffffffffffff(a,\n+\t                                    {\n+\t\t                                    SCRIPT_TASK_ROOT.with(|root| {\n+\t\t\t                                    *root.borrow_mut() = Some(&script_task);\n+\t\t                                    });\n+\t                                    });\n+\ta.b\n+\t .c\n+\t .d();\n+\n+\tx().y(|| {\n+\t\tmatch cond() {\n+\t\t\ttrue => (),\n+\t\t\tfalse => (),\n+\t\t}\n+\t});\n+}"}]}