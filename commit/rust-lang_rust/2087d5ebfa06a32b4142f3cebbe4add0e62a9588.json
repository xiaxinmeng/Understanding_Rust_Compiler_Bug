{"sha": "2087d5ebfa06a32b4142f3cebbe4add0e62a9588", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwODdkNWViZmEwNmEzMmI0MTQyZjNjZWJiZTRhZGQwZTYyYTk1ODg=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-14T13:50:03Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-14T13:50:03Z"}, "message": "incr.comp.: Do some verification on data decoded from incr. comp. cache.", "tree": {"sha": "9a27755f9c38f7b017527ea8643ccb9e5d107745", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a27755f9c38f7b017527ea8643ccb9e5d107745"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2087d5ebfa06a32b4142f3cebbe4add0e62a9588", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2087d5ebfa06a32b4142f3cebbe4add0e62a9588", "html_url": "https://github.com/rust-lang/rust/commit/2087d5ebfa06a32b4142f3cebbe4add0e62a9588", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2087d5ebfa06a32b4142f3cebbe4add0e62a9588/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de0317e267812563e87cd0a03f9e5d486c0bdae8", "url": "https://api.github.com/repos/rust-lang/rust/commits/de0317e267812563e87cd0a03f9e5d486c0bdae8", "html_url": "https://github.com/rust-lang/rust/commit/de0317e267812563e87cd0a03f9e5d486c0bdae8"}], "stats": {"total": 68, "additions": 62, "deletions": 6}, "files": [{"sha": "121b81111f217bfeaec40b1786fb0f7846bea06e", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 62, "deletions": 6, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2087d5ebfa06a32b4142f3cebbe4add0e62a9588/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2087d5ebfa06a32b4142f3cebbe4add0e62a9588/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=2087d5ebfa06a32b4142f3cebbe4add0e62a9588", "patch": "@@ -34,6 +34,11 @@ use ty::codec::{self as ty_codec, TyDecoder};\n use ty::context::TyCtxt;\n use ty::subst::Substs;\n \n+// Some magic values used for verifying that encoding and decoding. These are\n+// basically random numbers.\n+const PREV_DIAGNOSTICS_TAG: u64 = 0x1234_5678_A1A1_A1A1;\n+const DEF_PATH_TABLE_TAG: u64 = 0x1234_5678_B2B2_B2B2;\n+\n /// `OnDiskCache` provides an interface to incr. comp. data cached from the\n /// previous compilation session. This data will eventually include the results\n /// of a few selected queries (like `typeck_tables_of` and `mir_optimized`) and\n@@ -91,15 +96,17 @@ impl<'sess> OnDiskCache<'sess> {\n \n             // Decode Diagnostics\n             let prev_diagnostics: FxHashMap<_, _> = {\n-                let diagnostics = EncodedPrevDiagnostics::decode(&mut decoder)\n-                    .expect(\"Error while trying to decode prev. diagnostics \\\n-                             from incr. comp. cache.\");\n+                let diagnostics: EncodedPrevDiagnostics =\n+                    decode_tagged(&mut decoder, PREV_DIAGNOSTICS_TAG)\n+                        .expect(\"Error while trying to decode previous session \\\n+                                 diagnostics from incr. comp. cache.\");\n+\n                 diagnostics.into_iter().collect()\n             };\n \n             // Decode DefPathTables\n             let prev_def_path_tables: Vec<DefPathTable> =\n-                Decodable::decode(&mut decoder)\n+                decode_tagged(&mut decoder, DEF_PATH_TABLE_TAG)\n                     .expect(\"Error while trying to decode cached DefPathTables\");\n \n             (prev_diagnostics, prev_def_path_tables)\n@@ -176,7 +183,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 .map(|(k, v)| (SerializedDepNodeIndex::new(k.index()), v.clone()))\n                 .collect();\n \n-        diagnostics.encode(&mut encoder)?;\n+        encoder.encode_tagged(PREV_DIAGNOSTICS_TAG, &diagnostics)?;\n \n \n         // Encode all DefPathTables\n@@ -192,7 +199,7 @@ impl<'sess> OnDiskCache<'sess> {\n             }\n         }).collect();\n \n-        def_path_tables.encode(&mut encoder)?;\n+        encoder.encode_tagged(DEF_PATH_TABLE_TAG, &def_path_tables)?;\n \n         return Ok(());\n \n@@ -342,6 +349,30 @@ impl<'a, 'tcx, 'x> Decoder for CacheDecoder<'a, 'tcx, 'x> {\n     }\n }\n \n+// Decode something that was encoded with encode_tagged() and verify that the\n+// tag matches and the correct amount of bytes was read.\n+fn decode_tagged<'a, 'tcx, D, T, V>(decoder: &mut D,\n+                                    expected_tag: T)\n+                                    -> Result<V, D::Error>\n+    where T: Decodable + Eq + ::std::fmt::Debug,\n+          V: Decodable,\n+          D: Decoder + ty_codec::TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    let start_pos = decoder.position();\n+\n+    let actual_tag = T::decode(decoder)?;\n+    assert_eq!(actual_tag, expected_tag);\n+    let value = V::decode(decoder)?;\n+    let end_pos = decoder.position();\n+\n+    let expected_len: u64 = Decodable::decode(decoder)?;\n+    assert_eq!((end_pos - start_pos) as u64, expected_len);\n+\n+    Ok(value)\n+}\n+\n+\n impl<'a, 'tcx: 'a, 'x> ty_codec::TyDecoder<'a, 'tcx> for CacheDecoder<'a, 'tcx, 'x> {\n \n     #[inline]\n@@ -565,6 +596,30 @@ struct CacheEncoder<'enc, 'tcx, E>\n     definitions: &'enc Definitions,\n }\n \n+impl<'enc, 'tcx, E> CacheEncoder<'enc, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    /// Encode something with additional information that allows to do some\n+    /// sanity checks when decoding the data again. This method will first\n+    /// encode the specified tag, then the given value, then the number of\n+    /// bytes taken up by tag and value. On decoding, we can then verify that\n+    /// we get the expected tag and read the expected number of bytes.\n+    fn encode_tagged<T: Encodable, V: Encodable>(&mut self,\n+                                                 tag: T,\n+                                                 value: &V)\n+                                                 -> Result<(), E::Error>\n+    {\n+        use ty::codec::TyEncoder;\n+        let start_pos = self.position();\n+\n+        tag.encode(self)?;\n+        value.encode(self)?;\n+\n+        let end_pos = self.position();\n+        ((end_pos - start_pos) as u64).encode(self)\n+    }\n+}\n+\n impl<'enc, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'enc, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {\n@@ -644,3 +699,4 @@ impl<'enc, 'tcx, E> Encoder for CacheEncoder<'enc, 'tcx, E>\n         emit_str(&str);\n     }\n }\n+"}]}