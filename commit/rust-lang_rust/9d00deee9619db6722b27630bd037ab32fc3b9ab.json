{"sha": "9d00deee9619db6722b27630bd037ab32fc3b9ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMDBkZWVlOTYxOWRiNjcyMmIyNzYzMGJkMDM3YWIzMmZjM2I5YWI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-18T12:52:13Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-23T20:42:52Z"}, "message": "add span/scope-id to terminator", "tree": {"sha": "1d225994e4806e99847c9c1d13c09f6f252f5889", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d225994e4806e99847c9c1d13c09f6f252f5889"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d00deee9619db6722b27630bd037ab32fc3b9ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d00deee9619db6722b27630bd037ab32fc3b9ab", "html_url": "https://github.com/rust-lang/rust/commit/9d00deee9619db6722b27630bd037ab32fc3b9ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d00deee9619db6722b27630bd037ab32fc3b9ab/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a16f57fbbd0930c10a5b467a5ab2109712c50f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a16f57fbbd0930c10a5b467a5ab2109712c50f1", "html_url": "https://github.com/rust-lang/rust/commit/3a16f57fbbd0930c10a5b467a5ab2109712c50f1"}], "stats": {"total": 245, "additions": 168, "deletions": 77}, "files": [{"sha": "cc95d5946a80123d449a389eacc02a617df2402e", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=9d00deee9619db6722b27630bd037ab32fc3b9ab", "patch": "@@ -230,6 +230,8 @@ pub struct BasicBlockData<'tcx> {\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Terminator<'tcx> {\n+    pub span: Span,\n+    pub scope: ScopeId,\n     pub kind: TerminatorKind<'tcx>\n }\n "}, {"sha": "ef48a408e79a79746cf7eb8be65a3a0e005cf3ab", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=9d00deee9619db6722b27630bd037ab32fc3b9ab", "patch": "@@ -44,9 +44,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     StmtKind::Expr { scope, expr } => {\n                         unpack!(block = this.in_scope(scope, block, |this, _| {\n                             let expr = this.hir.mirror(expr);\n+                            let expr_span = expr.span;\n                             let temp = this.temp(expr.ty.clone());\n                             unpack!(block = this.into(&temp, block, expr));\n-                            unpack!(block = this.build_drop(block, temp));\n+                            unpack!(block = this.build_drop(block, expr_span, temp));\n                             block.unit()\n                         }));\n                     }"}, {"sha": "4859257f291c9767f694b9d4171ddcfeaabb0805", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=9d00deee9619db6722b27630bd037ab32fc3b9ab", "patch": "@@ -83,11 +83,15 @@ impl<'tcx> CFG<'tcx> {\n \n     pub fn terminate(&mut self,\n                      block: BasicBlock,\n+                     scope: ScopeId,\n+                     span: Span,\n                      kind: TerminatorKind<'tcx>) {\n         debug_assert!(self.block_data(block).terminator.is_none(),\n                       \"terminate: block {:?} already has a terminator set\", block);\n         self.block_data_mut(block).terminator = Some(Terminator {\n-            kind: kind\n+            span: span,\n+            scope: scope,\n+            kind: kind,\n         });\n     }\n }"}, {"sha": "0c9323f4af3781ccacb2965cb57ab8e561370760", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=9d00deee9619db6722b27630bd037ab32fc3b9ab", "patch": "@@ -68,6 +68,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n                 let (success, failure) = (this.cfg.start_new_block(), this.cfg.start_new_block());\n                 this.cfg.terminate(block,\n+                                   scope_id,\n+                                   expr_span,\n                                    TerminatorKind::If {\n                                        cond: Operand::Consume(lt),\n                                        targets: (success, failure),"}, {"sha": "9992e904dea16f542c2b846d47df98f5ba2143ef", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=9d00deee9619db6722b27630bd037ab32fc3b9ab", "patch": "@@ -53,7 +53,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n                 let mut then_block = this.cfg.start_new_block();\n                 let mut else_block = this.cfg.start_new_block();\n-                this.cfg.terminate(block, TerminatorKind::If {\n+                this.cfg.terminate(block, scope_id, expr_span, TerminatorKind::If {\n                     cond: operand,\n                     targets: (then_block, else_block)\n                 });\n@@ -70,8 +70,14 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 };\n \n                 let join_block = this.cfg.start_new_block();\n-                this.cfg.terminate(then_block, TerminatorKind::Goto { target: join_block });\n-                this.cfg.terminate(else_block, TerminatorKind::Goto { target: join_block });\n+                this.cfg.terminate(then_block,\n+                                   scope_id,\n+                                   expr_span,\n+                                   TerminatorKind::Goto { target: join_block });\n+                this.cfg.terminate(else_block,\n+                                   scope_id,\n+                                   expr_span,\n+                                   TerminatorKind::Goto { target: join_block });\n \n                 join_block.unit()\n             }\n@@ -97,10 +103,13 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     LogicalOp::And => (else_block, false_block),\n                     LogicalOp::Or => (true_block, else_block),\n                 };\n-                this.cfg.terminate(block, TerminatorKind::If { cond: lhs, targets: blocks });\n+                this.cfg.terminate(block,\n+                                   scope_id,\n+                                   expr_span,\n+                                   TerminatorKind::If { cond: lhs, targets: blocks });\n \n                 let rhs = unpack!(else_block = this.as_operand(else_block, rhs));\n-                this.cfg.terminate(else_block, TerminatorKind::If {\n+                this.cfg.terminate(else_block, scope_id, expr_span, TerminatorKind::If {\n                     cond: rhs,\n                     targets: (true_block, false_block)\n                 });\n@@ -121,8 +130,14 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         literal: this.hir.false_literal(),\n                     });\n \n-                this.cfg.terminate(true_block, TerminatorKind::Goto { target: join_block });\n-                this.cfg.terminate(false_block, TerminatorKind::Goto { target: join_block });\n+                this.cfg.terminate(true_block,\n+                                   scope_id,\n+                                   expr_span,\n+                                   TerminatorKind::Goto { target: join_block });\n+                this.cfg.terminate(false_block,\n+                                   scope_id,\n+                                   expr_span,\n+                                   TerminatorKind::Goto { target: join_block });\n \n                 join_block.unit()\n             }\n@@ -146,7 +161,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let exit_block = this.cfg.start_new_block();\n \n                 // start the loop\n-                this.cfg.terminate(block, TerminatorKind::Goto { target: loop_block });\n+                this.cfg.terminate(block,\n+                                   scope_id,\n+                                   expr_span,\n+                                   TerminatorKind::Goto { target: loop_block });\n \n                 let might_break = this.in_loop_scope(loop_block, exit_block, move |this| {\n                     // conduct the test, if necessary\n@@ -159,6 +177,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         let cond = unpack!(loop_block_end = this.as_operand(loop_block, cond_expr));\n                         body_block = this.cfg.start_new_block();\n                         this.cfg.terminate(loop_block_end,\n+                                           scope_id,\n+                                           expr_span,\n                                            TerminatorKind::If {\n                                                cond: cond,\n                                                targets: (body_block, exit_block)\n@@ -175,7 +195,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     let tmp = this.get_unit_temp();\n                     // Execute the body, branching back to the test.\n                     let body_block_end = unpack!(this.into(&tmp, body_block, body));\n-                    this.cfg.terminate(body_block_end, TerminatorKind::Goto { target: loop_block });\n+                    this.cfg.terminate(body_block_end,\n+                                       scope_id,\n+                                       expr_span,\n+                                       TerminatorKind::Goto { target: loop_block });\n                 });\n                 // If the loop may reach its exit_block, we assign an empty tuple to the\n                 // destination to keep the MIR well-formed.\n@@ -188,9 +211,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 // Note: we evaluate assignments right-to-left. This\n                 // is better for borrowck interaction with overloaded\n                 // operators like x[j] = x[i].\n+                let lhs = this.hir.mirror(lhs);\n+                let lhs_span = lhs.span;\n                 let rhs = unpack!(block = this.as_operand(block, rhs));\n                 let lhs = unpack!(block = this.as_lvalue(block, lhs));\n-                unpack!(block = this.build_drop(block, lhs.clone()));\n+                unpack!(block = this.build_drop(block, lhs_span, lhs.clone()));\n                 this.cfg.push_assign(block, scope_id, expr_span, &lhs, Rvalue::Use(rhs));\n                 block.unit()\n             }\n@@ -254,7 +279,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n                 let success = this.cfg.start_new_block();\n                 let cleanup = this.diverge_cleanup();\n-                this.cfg.terminate(block, TerminatorKind::Call {\n+                this.cfg.terminate(block, scope_id, expr_span, TerminatorKind::Call {\n                     func: fun,\n                     args: args,\n                     cleanup: cleanup,"}, {"sha": "9414752fbd86468dc34e680cc40788c8fe1cb9e8", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=9d00deee9619db6722b27630bd037ab32fc3b9ab", "patch": "@@ -71,6 +71,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 })\n                 .map(|(arm_index, pattern, guard)| {\n                     Candidate {\n+                        span: pattern.span,\n                         match_pairs: vec![MatchPair::new(discriminant_lvalue.clone(), pattern)],\n                         bindings: vec![],\n                         guard: guard,\n@@ -87,7 +88,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // an empty vector to be returned here, but the algorithm is\n         // not entirely precise\n         if !otherwise.is_empty() {\n-            let join_block = self.join_otherwise_blocks(otherwise);\n+            let join_block = self.join_otherwise_blocks(span, otherwise);\n             self.panic(join_block, \"something about matches algorithm not being precise\", span);\n         }\n \n@@ -97,7 +98,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         for (arm_index, arm_body) in arm_bodies.into_iter().enumerate() {\n             let mut arm_block = arm_blocks.blocks[arm_index];\n             unpack!(arm_block = self.into(destination, arm_block, arm_body));\n-            self.cfg.terminate(arm_block, TerminatorKind::Goto { target: end_block });\n+            self.cfg.terminate(arm_block,\n+                               var_scope_id,\n+                               span,\n+                               TerminatorKind::Goto { target: end_block });\n         }\n \n         end_block.unit()\n@@ -146,6 +150,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n         // create a dummy candidate\n         let mut candidate = Candidate {\n+            span: irrefutable_pat.span,\n             match_pairs: vec![MatchPair::new(initializer.clone(), &irrefutable_pat)],\n             bindings: vec![],\n             guard: None,\n@@ -206,6 +211,9 @@ struct ArmBlocks {\n \n #[derive(Clone, Debug)]\n pub struct Candidate<'pat, 'tcx:'pat> {\n+    // span of the original pattern that gave rise to this candidate\n+    span: Span,\n+\n     // all of these must be satisfied...\n     match_pairs: Vec<MatchPair<'pat, 'tcx>>,\n \n@@ -370,20 +378,25 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }\n \n         // Otherwise, let's process those remaining candidates.\n-        let join_block = self.join_otherwise_blocks(otherwise);\n+        let join_block = self.join_otherwise_blocks(span, otherwise);\n         self.match_candidates(span, arm_blocks, untested_candidates, join_block)\n     }\n \n     fn join_otherwise_blocks(&mut self,\n+                             span: Span,\n                              otherwise: Vec<BasicBlock>)\n                              -> BasicBlock\n     {\n+        let scope_id = self.innermost_scope_id();\n         if otherwise.len() == 1 {\n             otherwise[0]\n         } else {\n             let join_block = self.cfg.start_new_block();\n             for block in otherwise {\n-                self.cfg.terminate(block, TerminatorKind::Goto { target: join_block });\n+                self.cfg.terminate(block,\n+                                   scope_id,\n+                                   span,\n+                                   TerminatorKind::Goto { target: join_block });\n             }\n             join_block\n         }\n@@ -550,16 +563,25 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n         let arm_block = arm_blocks.blocks[candidate.arm_index];\n \n+        let scope_id = self.innermost_scope_id();\n         if let Some(guard) = candidate.guard {\n             // the block to branch to if the guard fails; if there is no\n             // guard, this block is simply unreachable\n+            let guard = self.hir.mirror(guard);\n+            let guard_span = guard.span;\n             let cond = unpack!(block = self.as_operand(block, guard));\n             let otherwise = self.cfg.start_new_block();\n-            self.cfg.terminate(block, TerminatorKind::If { cond: cond,\n-                                                       targets: (arm_block, otherwise)});\n+            self.cfg.terminate(block,\n+                               scope_id,\n+                               guard_span,\n+                               TerminatorKind::If { cond: cond,\n+                                                    targets: (arm_block, otherwise)});\n             Some(otherwise)\n         } else {\n-            self.cfg.terminate(block, TerminatorKind::Goto { target: arm_block });\n+            self.cfg.terminate(block,\n+                               scope_id,\n+                               candidate.span,\n+                               TerminatorKind::Goto { target: arm_block });\n             None\n         }\n     }"}, {"sha": "3e374c07b46b1a507cb821c18c243fcab3021a3e", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=9d00deee9619db6722b27630bd037ab32fc3b9ab", "patch": "@@ -153,7 +153,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let target_blocks: Vec<_> =\n                     (0..num_enum_variants).map(|_| self.cfg.start_new_block())\n                                           .collect();\n-                self.cfg.terminate(block, TerminatorKind::Switch {\n+                self.cfg.terminate(block, scope_id, test.span, TerminatorKind::Switch {\n                     discr: lvalue.clone(),\n                     adt_def: adt_def,\n                     targets: target_blocks.clone()\n@@ -168,12 +168,15 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                            .map(|_| self.cfg.start_new_block())\n                            .chain(Some(otherwise))\n                            .collect();\n-                self.cfg.terminate(block, TerminatorKind::SwitchInt {\n-                    discr: lvalue.clone(),\n-                    switch_ty: switch_ty,\n-                    values: options.clone(),\n-                    targets: targets.clone(),\n-                });\n+                self.cfg.terminate(block,\n+                                   scope_id,\n+                                   test.span,\n+                                   TerminatorKind::SwitchInt {\n+                                       discr: lvalue.clone(),\n+                                       switch_ty: switch_ty,\n+                                       values: options.clone(),\n+                                       targets: targets.clone(),\n+                                   });\n                 targets\n             }\n \n@@ -226,7 +229,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     let eq_result = self.temp(bool_ty);\n                     let eq_block = self.cfg.start_new_block();\n                     let cleanup = self.diverge_cleanup();\n-                    self.cfg.terminate(block, Terminator::Call {\n+                    self.cfg.terminate(block, scope_id, test.span, TerminatorKind::Call {\n                         func: Operand::Constant(Constant {\n                             span: test.span,\n                             ty: mty,\n@@ -239,7 +242,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n                     // check the result\n                     let block = self.cfg.start_new_block();\n-                    self.cfg.terminate(eq_block, Terminator::If {\n+                    self.cfg.terminate(eq_block, scope_id, test.span, TerminatorKind::If {\n                         cond: Operand::Consume(eq_result),\n                         targets: (block, fail),\n                     });\n@@ -286,7 +289,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 // branch based on result\n                 let target_blocks: Vec<_> = vec![self.cfg.start_new_block(),\n                                                  self.cfg.start_new_block()];\n-                self.cfg.terminate(block, TerminatorKind::If {\n+                self.cfg.terminate(block, scope_id, test.span, TerminatorKind::If {\n                     cond: Operand::Consume(result),\n                     targets: (target_blocks[0], target_blocks[1])\n                 });\n@@ -313,7 +316,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n         // branch based on result\n         let target_block = self.cfg.start_new_block();\n-        self.cfg.terminate(block, TerminatorKind::If {\n+        self.cfg.terminate(block, scope_id, span, TerminatorKind::If {\n             cond: Operand::Consume(result),\n             targets: (target_block, fail_block)\n         });\n@@ -466,6 +469,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                  .map(|(_, mp)| mp.clone())\n                                  .collect();\n         Candidate {\n+            span: candidate.span,\n             match_pairs: other_match_pairs,\n             bindings: candidate.bindings.clone(),\n             guard: candidate.guard.clone(),\n@@ -507,6 +511,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let all_match_pairs = consequent_match_pairs.chain(other_match_pairs).collect();\n \n         Candidate {\n+            span: candidate.span,\n             match_pairs: all_match_pairs,\n             bindings: candidate.bindings.clone(),\n             guard: candidate.guard.clone(),"}, {"sha": "416c078f4a95a15d744c5a8b93381cd98cf30089", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=9d00deee9619db6722b27630bd037ab32fc3b9ab", "patch": "@@ -160,14 +160,17 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n     assert_eq!(builder.cfg.start_new_block(), END_BLOCK);\n \n     let mut block = START_BLOCK;\n-    let arg_decls = unpack!(block = builder.args_and_body(block,\n-                                                          implicit_arguments,\n-                                                          explicit_arguments,\n-                                                          argument_extent,\n-                                                          ast_block));\n-\n-    builder.cfg.terminate(block, TerminatorKind::Goto { target: END_BLOCK });\n-    builder.cfg.terminate(END_BLOCK, TerminatorKind::Return);\n+    let (arg_decls, arg_scope_id) =\n+        unpack!(block = builder.args_and_body(block,\n+                                              implicit_arguments,\n+                                              explicit_arguments,\n+                                              argument_extent,\n+                                              ast_block));\n+\n+    builder.cfg.terminate(block, arg_scope_id, span,\n+                          TerminatorKind::Goto { target: END_BLOCK });\n+    builder.cfg.terminate(END_BLOCK, arg_scope_id, span,\n+                          TerminatorKind::Return);\n \n     MirPlusPlus {\n         mir: Mir {\n@@ -190,7 +193,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                      explicit_arguments: Vec<(Ty<'tcx>, &'tcx hir::Pat)>,\n                      argument_extent: CodeExtent,\n                      ast_block: &'tcx hir::Block)\n-                     -> BlockAnd<Vec<ArgDecl<'tcx>>>\n+                     -> BlockAnd<(Vec<ArgDecl<'tcx>>, ScopeId)>\n     {\n         self.in_scope(argument_extent, block, |this, argument_scope_id| {\n             // to start, translate the argument patterns and collect the argument types.\n@@ -219,7 +222,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             // start the first basic block and translate the body\n             unpack!(block = this.ast_block(&Lvalue::ReturnPointer, block, ast_block));\n \n-            block.and(arg_decls)\n+            block.and((arg_decls, argument_scope_id))\n         })\n     }\n "}, {"sha": "e7066ff083e245ac03cf7a56146d5ee06025a84a", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 63, "deletions": 36, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d00deee9619db6722b27630bd037ab32fc3b9ab/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=9d00deee9619db6722b27630bd037ab32fc3b9ab", "patch": "@@ -116,6 +116,7 @@ pub struct Scope<'tcx> {\n }\n \n struct DropData<'tcx> {\n+    span: Span,\n     value: Lvalue<'tcx>,\n     // NB: per-drop \u201ccache\u201d is necessary for the build_scope_drops function below.\n     /// The cached block for the cleanups-on-diverge path. This block contains code to run the\n@@ -288,14 +289,19 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             if let Some(ref free_data) = scope.free {\n                 let next = self.cfg.start_new_block();\n                 let free = build_free(self.hir.tcx(), tmp.clone(), free_data, next);\n-                self.cfg.terminate(block, free);\n+                self.cfg.terminate(block, scope.id, span, free);\n                 block = next;\n             }\n             self.scope_auxiliary[scope.id.index()]\n                 .postdoms\n                 .push(self.cfg.current_location(block));\n         }\n-        self.cfg.terminate(block, TerminatorKind::Goto { target: target });\n+\n+        let scope_id = self.innermost_scope_id();\n+        self.cfg.terminate(block,\n+                           scope_id,\n+                           span,\n+                           TerminatorKind::Goto { target: target });\n     }\n \n     // Finding scopes\n@@ -351,6 +357,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 // No need to invalidate any caches here. The just-scheduled drop will branch into\n                 // the drop that comes before it in the vector.\n                 scope.drops.push(DropData {\n+                    span: span,\n                     value: lvalue.clone(),\n                     cached_block: None\n                 });\n@@ -429,14 +436,22 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     }\n \n     /// Utility function for *non*-scope code to build their own drops\n-    pub fn build_drop(&mut self, block: BasicBlock, value: Lvalue<'tcx>) -> BlockAnd<()> {\n+    pub fn build_drop(&mut self,\n+                      block: BasicBlock,\n+                      span: Span,\n+                      value: Lvalue<'tcx>)\n+                      -> BlockAnd<()> {\n+        let scope_id = self.innermost_scope_id();\n         let next_target = self.cfg.start_new_block();\n         let diverge_target = self.diverge_cleanup();\n-        self.cfg.terminate(block, TerminatorKind::Drop {\n-            value: value,\n-            target: next_target,\n-            unwind: diverge_target,\n-        });\n+        self.cfg.terminate(block,\n+                           scope_id,\n+                           span,\n+                           TerminatorKind::Drop {\n+                               value: value,\n+                               target: next_target,\n+                               unwind: diverge_target,\n+                           });\n         next_target.unit()\n     }\n \n@@ -445,10 +460,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     // =========\n     // FIXME: should be moved into their own module\n     pub fn panic_bounds_check(&mut self,\n-                             block: BasicBlock,\n-                             index: Operand<'tcx>,\n-                             len: Operand<'tcx>,\n-                             span: Span) {\n+                              block: BasicBlock,\n+                              index: Operand<'tcx>,\n+                              len: Operand<'tcx>,\n+                              span: Span) {\n         // fn(&(filename: &'static str, line: u32), index: usize, length: usize) -> !\n         let region = ty::ReStatic; // FIXME(mir-borrowck): use a better region?\n         let func = self.lang_function(lang_items::PanicBoundsCheckFnLangItem);\n@@ -474,7 +489,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         self.cfg.push_assign(block, scope_id, span, &tuple_ref, // tuple_ref = &tuple;\n                              Rvalue::Ref(region, BorrowKind::Shared, tuple));\n         let cleanup = self.diverge_cleanup();\n-        self.cfg.terminate(block, TerminatorKind::Call {\n+        self.cfg.terminate(block, scope_id, span, TerminatorKind::Call {\n             func: Operand::Constant(func),\n             args: vec![Operand::Consume(tuple_ref), index, len],\n             destination: None,\n@@ -516,7 +531,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         self.cfg.push_assign(block, scope_id, span, &tuple_ref, // tuple_ref = &tuple;\n                              Rvalue::Ref(region, BorrowKind::Shared, tuple));\n         let cleanup = self.diverge_cleanup();\n-        self.cfg.terminate(block, TerminatorKind::Call {\n+        self.cfg.terminate(block, scope_id, span, TerminatorKind::Call {\n             func: Operand::Constant(func),\n             args: vec![Operand::Consume(tuple_ref)],\n             cleanup: cleanup,\n@@ -575,7 +590,7 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n             earlier_scopes.iter().rev().flat_map(|s| s.cached_block()).next()\n         });\n         let next = cfg.start_new_block();\n-        cfg.terminate(block, TerminatorKind::Drop {\n+        cfg.terminate(block, scope.id, drop_data.span, TerminatorKind::Drop {\n             value: drop_data.value.clone(),\n             target: next,\n             unwind: on_diverge\n@@ -599,36 +614,42 @@ fn build_diverge_scope<'tcx>(tcx: &TyCtxt<'tcx>,\n     let mut last_drop_block = None;\n     for drop_data in scope.drops.iter_mut().rev() {\n         if let Some(cached_block) = drop_data.cached_block {\n-            if let Some((previous_block, previous_value)) = previous {\n-                cfg.terminate(previous_block, TerminatorKind::Drop {\n-                    value: previous_value,\n-                    target: cached_block,\n-                    unwind: None\n-                });\n+            if let Some((previous_block, previous_span, previous_value)) = previous {\n+                cfg.terminate(previous_block,\n+                              scope.id,\n+                              previous_span,\n+                              TerminatorKind::Drop {\n+                                  value: previous_value,\n+                                  target: cached_block,\n+                                  unwind: None\n+                              });\n                 return last_drop_block.unwrap();\n             } else {\n                 return cached_block;\n             }\n         } else {\n             let block = cfg.start_new_cleanup_block();\n             drop_data.cached_block = Some(block);\n-            if let Some((previous_block, previous_value)) = previous {\n-                cfg.terminate(previous_block, TerminatorKind::Drop {\n-                    value: previous_value,\n-                    target: block,\n-                    unwind: None\n-                });\n+            if let Some((previous_block, previous_span, previous_value)) = previous {\n+                cfg.terminate(previous_block,\n+                              scope.id,\n+                              previous_span,\n+                              TerminatorKind::Drop {\n+                                  value: previous_value,\n+                                  target: block,\n+                                  unwind: None\n+                              });\n             } else {\n                 last_drop_block = Some(block);\n             }\n-            previous = Some((block, drop_data.value.clone()));\n+            previous = Some((block, drop_data.span, drop_data.value.clone()));\n         }\n     }\n \n     // Prepare the end target for this chain.\n     let mut target = target.unwrap_or_else(||{\n         let b = cfg.start_new_cleanup_block();\n-        cfg.terminate(b, TerminatorKind::Resume);\n+        cfg.terminate(b, scope.id, DUMMY_SP, TerminatorKind::Resume); // TODO\n         b\n     });\n \n@@ -638,19 +659,25 @@ fn build_diverge_scope<'tcx>(tcx: &TyCtxt<'tcx>,\n             cached_block\n         } else {\n             let into = cfg.start_new_cleanup_block();\n-            cfg.terminate(into, build_free(tcx, unit_temp, free_data, target));\n+            cfg.terminate(into,\n+                          scope.id,\n+                          free_data.span,\n+                          build_free(tcx, unit_temp, free_data, target));\n             free_data.cached_block = Some(into);\n             into\n         }\n     };\n \n-    if let Some((previous_block, previous_value)) = previous {\n+    if let Some((previous_block, previous_span, previous_value)) = previous {\n         // Finally, branch into that just-built `target` from the `previous_block`.\n-        cfg.terminate(previous_block, TerminatorKind::Drop {\n-            value: previous_value,\n-            target: target,\n-            unwind: None\n-        });\n+        cfg.terminate(previous_block,\n+                      scope.id,\n+                      previous_span,\n+                      TerminatorKind::Drop {\n+                          value: previous_value,\n+                          target: target,\n+                          unwind: None\n+                      });\n         last_drop_block.unwrap()\n     } else {\n         // If `previous.is_none()`, there were no drops in this scope \u2013 we return the"}]}