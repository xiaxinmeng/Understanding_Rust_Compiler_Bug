{"sha": "78bc758c94ae9c99b8e4e82f7d18b6733c8eb949", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4YmM3NThjOTRhZTljOTliOGU0ZTgyZjdkMThiNjczM2M4ZWI5NDk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-15T03:47:24Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-16T18:41:26Z"}, "message": "compiletest: Remove all uses of `~str` from `compiletest`", "tree": {"sha": "f6d747176f2a08a0cd123adfadef4c3f215c6b4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6d747176f2a08a0cd123adfadef4c3f215c6b4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949", "html_url": "https://github.com/rust-lang/rust/commit/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbd034c3a6e0325da0cb743cab007d69a736557a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbd034c3a6e0325da0cb743cab007d69a736557a", "html_url": "https://github.com/rust-lang/rust/commit/bbd034c3a6e0325da0cb743cab007d69a736557a"}], "stats": {"total": 1124, "additions": 699, "deletions": 425}, "files": [{"sha": "a7f693da6cceceff6948bd85f6055cb14cce2ba2", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=78bc758c94ae9c99b8e4e82f7d18b6733c8eb949", "patch": "@@ -56,10 +56,10 @@ impl fmt::Show for Mode {\n #[deriving(Clone)]\n pub struct Config {\n     // The library paths required for running the compiler\n-    pub compile_lib_path: ~str,\n+    pub compile_lib_path: StrBuf,\n \n     // The library paths required for running compiled programs\n-    pub run_lib_path: ~str,\n+    pub run_lib_path: StrBuf,\n \n     // The rustc executable\n     pub rustc_path: Path,\n@@ -80,7 +80,7 @@ pub struct Config {\n     pub aux_base: Path,\n \n     // The name of the stage being built (stage1, etc)\n-    pub stage_id: ~str,\n+    pub stage_id: StrBuf,\n \n     // The test mode, compile-fail, run-fail, run-pass\n     pub mode: Mode,\n@@ -110,37 +110,37 @@ pub struct Config {\n \n     // A command line to prefix program execution with,\n     // for running under valgrind\n-    pub runtool: Option<~str>,\n+    pub runtool: Option<StrBuf>,\n \n     // Flags to pass to the compiler when building for the host\n-    pub host_rustcflags: Option<~str>,\n+    pub host_rustcflags: Option<StrBuf>,\n \n     // Flags to pass to the compiler when building for the target\n-    pub target_rustcflags: Option<~str>,\n+    pub target_rustcflags: Option<StrBuf>,\n \n     // Run tests using the JIT\n     pub jit: bool,\n \n     // Target system to be tested\n-    pub target: ~str,\n+    pub target: StrBuf,\n \n     // Host triple for the compiler being invoked\n-    pub host: ~str,\n+    pub host: StrBuf,\n \n     // Path to the android tools\n     pub android_cross_path: Path,\n \n     // Extra parameter to run adb on arm-linux-androideabi\n-    pub adb_path: ~str,\n+    pub adb_path: StrBuf,\n \n     // Extra parameter to run test sute on arm-linux-androideabi\n-    pub adb_test_dir: ~str,\n+    pub adb_test_dir: StrBuf,\n \n     // status whether android device available or not\n     pub adb_device_status: bool,\n \n     // the path containing LLDB's Python module\n-    pub lldb_python_dir: Option<~str>,\n+    pub lldb_python_dir: Option<StrBuf>,\n \n     // Explain what's going on\n     pub verbose: bool"}, {"sha": "feae84e7d87012f118a38da4c66a2299182d8682", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 84, "deletions": 56, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=78bc758c94ae9c99b8e4e82f7d18b6733c8eb949", "patch": "@@ -48,12 +48,14 @@ fn start(argc: int, argv: **u8) -> int {\n \n pub fn main() {\n     let args = os::args();\n-    let config = parse_config(args.move_iter().collect());\n+    let config = parse_config(args.move_iter()\n+                                  .map(|x| x.to_strbuf())\n+                                  .collect());\n     log_config(&config);\n     run_tests(&config);\n }\n \n-pub fn parse_config(args: Vec<~str> ) -> Config {\n+pub fn parse_config(args: Vec<StrBuf> ) -> Config {\n \n     let groups : Vec<getopts::OptGroup> =\n         vec!(reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\"),\n@@ -91,15 +93,19 @@ pub fn parse_config(args: Vec<~str> ) -> Config {\n     assert!(!args.is_empty());\n     let argv0 = (*args.get(0)).clone();\n     let args_ = args.tail();\n-    if *args.get(1) == \"-h\".to_owned() || *args.get(1) == \"--help\".to_owned() {\n+    if args.get(1).as_slice() == \"-h\" || args.get(1).as_slice() == \"--help\" {\n         let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n         println!(\"{}\", getopts::usage(message, groups.as_slice()));\n         println!(\"\");\n         fail!()\n     }\n \n     let matches =\n-        &match getopts::getopts(args_, groups.as_slice()) {\n+        &match getopts::getopts(args_.iter()\n+                                     .map(|x| x.to_owned())\n+                                     .collect::<Vec<_>>()\n+                                     .as_slice(),\n+                                groups.as_slice()) {\n           Ok(m) => m,\n           Err(f) => fail!(\"{}\", f.to_err_msg())\n         };\n@@ -129,15 +135,17 @@ pub fn parse_config(args: Vec<~str> ) -> Config {\n     };\n \n     Config {\n-        compile_lib_path: matches.opt_str(\"compile-lib-path\").unwrap(),\n-        run_lib_path: matches.opt_str(\"run-lib-path\").unwrap(),\n+        compile_lib_path: matches.opt_str(\"compile-lib-path\")\n+                                 .unwrap()\n+                                 .to_strbuf(),\n+        run_lib_path: matches.opt_str(\"run-lib-path\").unwrap().to_strbuf(),\n         rustc_path: opt_path(matches, \"rustc-path\"),\n         clang_path: matches.opt_str(\"clang-path\").map(|s| Path::new(s)),\n         llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map(|s| Path::new(s)),\n         src_base: opt_path(matches, \"src-base\"),\n         build_base: opt_path(matches, \"build-base\"),\n         aux_base: opt_path(matches, \"aux-base\"),\n-        stage_id: matches.opt_str(\"stage-id\").unwrap(),\n+        stage_id: matches.opt_str(\"stage-id\").unwrap().to_strbuf(),\n         mode: FromStr::from_str(matches.opt_str(\"mode\").unwrap()).expect(\"invalid mode\"),\n         run_ignored: matches.opt_present(\"ignored\"),\n         filter: filter,\n@@ -147,21 +155,30 @@ pub fn parse_config(args: Vec<~str> ) -> Config {\n             matches.opt_str(\"ratchet-metrics\").map(|s| Path::new(s)),\n         ratchet_noise_percent:\n             matches.opt_str(\"ratchet-noise-percent\").and_then(|s| from_str::<f64>(s)),\n-        runtool: matches.opt_str(\"runtool\"),\n-        host_rustcflags: matches.opt_str(\"host-rustcflags\"),\n-        target_rustcflags: matches.opt_str(\"target-rustcflags\"),\n+        runtool: matches.opt_str(\"runtool\").map(|x| x.to_strbuf()),\n+        host_rustcflags: matches.opt_str(\"host-rustcflags\")\n+                                .map(|x| x.to_strbuf()),\n+        target_rustcflags: matches.opt_str(\"target-rustcflags\")\n+                                  .map(|x| x.to_strbuf()),\n         jit: matches.opt_present(\"jit\"),\n-        target: opt_str2(matches.opt_str(\"target\")).to_str(),\n-        host: opt_str2(matches.opt_str(\"host\")).to_str(),\n+        target: opt_str2(matches.opt_str(\"target\").map(|x| x.to_strbuf())),\n+        host: opt_str2(matches.opt_str(\"host\").map(|x| x.to_strbuf())),\n         android_cross_path: opt_path(matches, \"android-cross-path\"),\n-        adb_path: opt_str2(matches.opt_str(\"adb-path\")).to_str(),\n-        adb_test_dir:\n-            opt_str2(matches.opt_str(\"adb-test-dir\")).to_str(),\n+        adb_path: opt_str2(matches.opt_str(\"adb-path\")\n+                                  .map(|x| x.to_strbuf())),\n+        adb_test_dir: opt_str2(matches.opt_str(\"adb-test-dir\")\n+                                      .map(|x| x.to_strbuf())),\n         adb_device_status:\n-            \"arm-linux-androideabi\" == opt_str2(matches.opt_str(\"target\")) &&\n-            \"(none)\" != opt_str2(matches.opt_str(\"adb-test-dir\")) &&\n-            !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n-        lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n+            \"arm-linux-androideabi\" ==\n+                opt_str2(matches.opt_str(\"target\")\n+                                .map(|x| x.to_strbuf())).as_slice() &&\n+            \"(none)\" !=\n+                opt_str2(matches.opt_str(\"adb-test-dir\")\n+                                .map(|x| x.to_strbuf())).as_slice() &&\n+            !opt_str2(matches.opt_str(\"adb-test-dir\")\n+                             .map(|x| x.to_strbuf())).is_empty(),\n+        lldb_python_dir: matches.opt_str(\"lldb-python-dir\")\n+                                .map(|x| x.to_strbuf()),\n         test_shard: test::opt_shard(matches.opt_str(\"test-shard\")\n                                            .map(|x| x.to_strbuf())),\n         verbose: matches.opt_present(\"verbose\")\n@@ -170,50 +187,59 @@ pub fn parse_config(args: Vec<~str> ) -> Config {\n \n pub fn log_config(config: &Config) {\n     let c = config;\n-    logv(c, format!(\"configuration:\"));\n-    logv(c, format!(\"compile_lib_path: {}\", config.compile_lib_path));\n-    logv(c, format!(\"run_lib_path: {}\", config.run_lib_path));\n-    logv(c, format!(\"rustc_path: {}\", config.rustc_path.display()));\n-    logv(c, format!(\"src_base: {}\", config.src_base.display()));\n-    logv(c, format!(\"build_base: {}\", config.build_base.display()));\n-    logv(c, format!(\"stage_id: {}\", config.stage_id));\n-    logv(c, format!(\"mode: {}\", config.mode));\n-    logv(c, format!(\"run_ignored: {}\", config.run_ignored));\n-    logv(c, format!(\"filter: {}\", opt_str(&config.filter.as_ref().map(|re| re.to_str()))));\n-    logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n-    logv(c, format!(\"host-rustcflags: {}\", opt_str(&config.host_rustcflags)));\n-    logv(c, format!(\"target-rustcflags: {}\", opt_str(&config.target_rustcflags)));\n-    logv(c, format!(\"jit: {}\", config.jit));\n-    logv(c, format!(\"target: {}\", config.target));\n-    logv(c, format!(\"host: {}\", config.host));\n-    logv(c, format!(\"android-cross-path: {}\", config.android_cross_path.display()));\n-    logv(c, format!(\"adb_path: {}\", config.adb_path));\n-    logv(c, format!(\"adb_test_dir: {}\", config.adb_test_dir));\n-    logv(c, format!(\"adb_device_status: {}\", config.adb_device_status));\n+    logv(c, format_strbuf!(\"configuration:\"));\n+    logv(c, format_strbuf!(\"compile_lib_path: {}\", config.compile_lib_path));\n+    logv(c, format_strbuf!(\"run_lib_path: {}\", config.run_lib_path));\n+    logv(c, format_strbuf!(\"rustc_path: {}\", config.rustc_path.display()));\n+    logv(c, format_strbuf!(\"src_base: {}\", config.src_base.display()));\n+    logv(c, format_strbuf!(\"build_base: {}\", config.build_base.display()));\n+    logv(c, format_strbuf!(\"stage_id: {}\", config.stage_id));\n+    logv(c, format_strbuf!(\"mode: {}\", config.mode));\n+    logv(c, format_strbuf!(\"run_ignored: {}\", config.run_ignored));\n+    logv(c, format_strbuf!(\"filter: {}\",\n+                           opt_str(&config.filter\n+                                          .as_ref()\n+                                          .map(|re| {\n+                                              re.to_str().into_strbuf()\n+                                          }))));\n+    logv(c, format_strbuf!(\"runtool: {}\", opt_str(&config.runtool)));\n+    logv(c, format_strbuf!(\"host-rustcflags: {}\",\n+                           opt_str(&config.host_rustcflags)));\n+    logv(c, format_strbuf!(\"target-rustcflags: {}\",\n+                           opt_str(&config.target_rustcflags)));\n+    logv(c, format_strbuf!(\"jit: {}\", config.jit));\n+    logv(c, format_strbuf!(\"target: {}\", config.target));\n+    logv(c, format_strbuf!(\"host: {}\", config.host));\n+    logv(c, format_strbuf!(\"android-cross-path: {}\",\n+                           config.android_cross_path.display()));\n+    logv(c, format_strbuf!(\"adb_path: {}\", config.adb_path));\n+    logv(c, format_strbuf!(\"adb_test_dir: {}\", config.adb_test_dir));\n+    logv(c, format_strbuf!(\"adb_device_status: {}\",\n+                           config.adb_device_status));\n     match config.test_shard {\n-        None => logv(c, \"test_shard: (all)\".to_owned()),\n-        Some((a,b)) => logv(c, format!(\"test_shard: {}.{}\", a, b))\n+        None => logv(c, \"test_shard: (all)\".to_strbuf()),\n+        Some((a,b)) => logv(c, format_strbuf!(\"test_shard: {}.{}\", a, b))\n     }\n-    logv(c, format!(\"verbose: {}\", config.verbose));\n-    logv(c, format!(\"\\n\"));\n+    logv(c, format_strbuf!(\"verbose: {}\", config.verbose));\n+    logv(c, format_strbuf!(\"\\n\"));\n }\n \n-pub fn opt_str<'a>(maybestr: &'a Option<~str>) -> &'a str {\n+pub fn opt_str<'a>(maybestr: &'a Option<StrBuf>) -> &'a str {\n     match *maybestr {\n         None => \"(none)\",\n-        Some(ref s) => {\n-            let s: &'a str = *s;\n-            s\n-        }\n+        Some(ref s) => s.as_slice(),\n     }\n }\n \n-pub fn opt_str2(maybestr: Option<~str>) -> ~str {\n-    match maybestr { None => \"(none)\".to_owned(), Some(s) => { s } }\n+pub fn opt_str2(maybestr: Option<StrBuf>) -> StrBuf {\n+    match maybestr {\n+        None => \"(none)\".to_strbuf(),\n+        Some(s) => s,\n+    }\n }\n \n pub fn run_tests(config: &Config) {\n-    if config.target == \"arm-linux-androideabi\".to_owned() {\n+    if config.target.as_slice() == \"arm-linux-androideabi\" {\n         match config.mode {\n             DebugInfoGdb => {\n                 println!(\"arm-linux-androideabi debug-info \\\n@@ -321,11 +347,11 @@ pub fn make_test(config: &Config, testfile: &Path, f: || -> test::TestFn)\n pub fn make_test_name(config: &Config, testfile: &Path) -> test::TestName {\n \n     // Try to elide redundant long paths\n-    fn shorten(path: &Path) -> ~str {\n+    fn shorten(path: &Path) -> StrBuf {\n         let filename = path.filename_str();\n         let p = path.dir_path();\n         let dir = p.filename_str();\n-        format!(\"{}/{}\", dir.unwrap_or(\"\"), filename.unwrap_or(\"\"))\n+        format_strbuf!(\"{}/{}\", dir.unwrap_or(\"\"), filename.unwrap_or(\"\"))\n     }\n \n     test::DynTestName(format_strbuf!(\"[{}] {}\",\n@@ -336,14 +362,16 @@ pub fn make_test_name(config: &Config, testfile: &Path) -> test::TestName {\n pub fn make_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n     let config = (*config).clone();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let testfile = testfile.as_str().unwrap().to_owned();\n-    test::DynTestFn(proc() { runtest::run(config, testfile) })\n+    let testfile = testfile.as_str().unwrap().to_strbuf();\n+    test::DynTestFn(proc() {\n+        runtest::run(config, testfile)\n+    })\n }\n \n pub fn make_metrics_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n     let config = (*config).clone();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let testfile = testfile.as_str().unwrap().to_owned();\n+    let testfile = testfile.as_str().unwrap().to_strbuf();\n     test::DynMetricFn(proc(mm) {\n         runtest::run_metrics(config, testfile, mm)\n     })"}, {"sha": "4e65115caa2bec6fcbeab9e8eee2cf9f563268a9", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=78bc758c94ae9c99b8e4e82f7d18b6733c8eb949", "patch": "@@ -12,8 +12,8 @@ use std::io::{BufferedReader, File};\n \n pub struct ExpectedError {\n     pub line: uint,\n-    pub kind: ~str,\n-    pub msg: ~str,\n+    pub kind: StrBuf,\n+    pub msg: StrBuf,\n }\n \n // Load any test directives embedded in the file\n@@ -23,17 +23,18 @@ pub fn load_errors(testfile: &Path) -> Vec<ExpectedError> {\n     let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n     let mut line_num = 1u;\n     for ln in rdr.lines() {\n-        error_patterns.push_all_move(parse_expected(line_num, ln.unwrap()));\n+        error_patterns.push_all_move(parse_expected(line_num,\n+                                                    ln.unwrap().to_strbuf()));\n         line_num += 1u;\n     }\n     return error_patterns;\n }\n \n-fn parse_expected(line_num: uint, line: ~str) -> Vec<ExpectedError> {\n-    let line = line.trim();\n-    let error_tag = \"//~\".to_owned();\n+fn parse_expected(line_num: uint, line: StrBuf) -> Vec<ExpectedError> {\n+    let line = line.as_slice().trim().to_strbuf();\n+    let error_tag = \"//~\".to_strbuf();\n     let mut idx;\n-    match line.find_str(error_tag) {\n+    match line.as_slice().find_str(error_tag.as_slice()) {\n       None => return Vec::new(),\n       Some(nn) => { idx = (nn as uint) + error_tag.len(); }\n     }\n@@ -42,25 +43,34 @@ fn parse_expected(line_num: uint, line: ~str) -> Vec<ExpectedError> {\n     // three lines above current line:\n     let mut adjust_line = 0u;\n     let len = line.len();\n-    while idx < len && line[idx] == ('^' as u8) {\n+    while idx < len && line.as_slice()[idx] == ('^' as u8) {\n         adjust_line += 1u;\n         idx += 1u;\n     }\n \n     // Extract kind:\n-    while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n+    while idx < len && line.as_slice()[idx] == (' ' as u8) {\n+        idx += 1u;\n+    }\n     let start_kind = idx;\n-    while idx < len && line[idx] != (' ' as u8) { idx += 1u; }\n+    while idx < len && line.as_slice()[idx] != (' ' as u8) {\n+        idx += 1u;\n+    }\n \n-    let kind = line.slice(start_kind, idx);\n-    let kind = kind.to_ascii().to_lower().into_str();\n+    let kind = line.as_slice().slice(start_kind, idx);\n+    let kind = kind.to_ascii().to_lower().into_str().to_strbuf();\n \n     // Extract msg:\n-    while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n-    let msg = line.slice(idx, len).to_owned();\n+    while idx < len && line.as_slice()[idx] == (' ' as u8) {\n+        idx += 1u;\n+    }\n+    let msg = line.as_slice().slice(idx, len).to_strbuf();\n \n     debug!(\"line={} kind={} msg={}\", line_num - adjust_line, kind, msg);\n \n-    return vec!(ExpectedError{line: line_num - adjust_line, kind: kind,\n-                           msg: msg});\n+    return vec!(ExpectedError{\n+        line: line_num - adjust_line,\n+        kind: kind,\n+        msg: msg,\n+    });\n }"}, {"sha": "5729a11d7ad7ef0862131a798607612d810f396a", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 50, "deletions": 39, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=78bc758c94ae9c99b8e4e82f7d18b6733c8eb949", "patch": "@@ -14,20 +14,20 @@ use util;\n \n pub struct TestProps {\n     // Lines that should be expected, in order, on standard out\n-    pub error_patterns: Vec<~str> ,\n+    pub error_patterns: Vec<StrBuf> ,\n     // Extra flags to pass to the compiler\n-    pub compile_flags: Option<~str>,\n+    pub compile_flags: Option<StrBuf>,\n     // Extra flags to pass when the compiled code is run (such as --bench)\n-    pub run_flags: Option<~str>,\n+    pub run_flags: Option<StrBuf>,\n     // If present, the name of a file that this test should match when\n     // pretty-printed\n     pub pp_exact: Option<Path>,\n     // Modules from aux directory that should be compiled\n-    pub aux_builds: Vec<~str> ,\n+    pub aux_builds: Vec<StrBuf> ,\n     // Environment settings to use during execution\n-    pub exec_env: Vec<(~str,~str)> ,\n+    pub exec_env: Vec<(StrBuf,StrBuf)> ,\n     // Lines to check if they appear in the expected debugger output\n-    pub check_lines: Vec<~str> ,\n+    pub check_lines: Vec<StrBuf> ,\n     // Flag to force a crate to be built with the host architecture\n     pub force_host: bool,\n     // Check stdout for error-pattern output as well as stderr\n@@ -119,22 +119,30 @@ pub fn load_props(testfile: &Path) -> TestProps {\n }\n \n pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n-    fn ignore_target(config: &Config) -> ~str {\n-        \"ignore-\".to_owned() + util::get_os(config.target)\n+    fn ignore_target(config: &Config) -> StrBuf {\n+        format_strbuf!(\"ignore-{}\", util::get_os(config.target.as_slice()))\n     }\n-    fn ignore_stage(config: &Config) -> ~str {\n-        \"ignore-\".to_owned() + config.stage_id.split('-').next().unwrap()\n+    fn ignore_stage(config: &Config) -> StrBuf {\n+        format_strbuf!(\"ignore-{}\",\n+                       config.stage_id.as_slice().split('-').next().unwrap())\n     }\n \n     let val = iter_header(testfile, |ln| {\n-        if parse_name_directive(ln, \"ignore-test\") { false }\n-        else if parse_name_directive(ln, ignore_target(config)) { false }\n-        else if parse_name_directive(ln, ignore_stage(config)) { false }\n-        else if config.mode == common::Pretty &&\n-            parse_name_directive(ln, \"ignore-pretty\") { false }\n-        else if config.target != config.host &&\n-            parse_name_directive(ln, \"ignore-cross-compile\") { false }\n-        else { true }\n+        if parse_name_directive(ln, \"ignore-test\") {\n+            false\n+        } else if parse_name_directive(ln, ignore_target(config).as_slice()) {\n+            false\n+        } else if parse_name_directive(ln, ignore_stage(config).as_slice()) {\n+            false\n+        } else if config.mode == common::Pretty &&\n+                parse_name_directive(ln, \"ignore-pretty\") {\n+            false\n+        } else if config.target != config.host &&\n+                parse_name_directive(ln, \"ignore-cross-compile\") {\n+            false\n+        } else {\n+            true\n+        }\n     });\n \n     !val\n@@ -156,24 +164,24 @@ fn iter_header(testfile: &Path, it: |&str| -> bool) -> bool {\n     return true;\n }\n \n-fn parse_error_pattern(line: &str) -> Option<~str> {\n-    parse_name_value_directive(line, \"error-pattern\".to_owned())\n+fn parse_error_pattern(line: &str) -> Option<StrBuf> {\n+    parse_name_value_directive(line, \"error-pattern\".to_strbuf())\n }\n \n-fn parse_aux_build(line: &str) -> Option<~str> {\n-    parse_name_value_directive(line, \"aux-build\".to_owned())\n+fn parse_aux_build(line: &str) -> Option<StrBuf> {\n+    parse_name_value_directive(line, \"aux-build\".to_strbuf())\n }\n \n-fn parse_compile_flags(line: &str) -> Option<~str> {\n-    parse_name_value_directive(line, \"compile-flags\".to_owned())\n+fn parse_compile_flags(line: &str) -> Option<StrBuf> {\n+    parse_name_value_directive(line, \"compile-flags\".to_strbuf())\n }\n \n-fn parse_run_flags(line: &str) -> Option<~str> {\n-    parse_name_value_directive(line, \"run-flags\".to_owned())\n+fn parse_run_flags(line: &str) -> Option<StrBuf> {\n+    parse_name_value_directive(line, \"run-flags\".to_strbuf())\n }\n \n-fn parse_check_line(line: &str) -> Option<~str> {\n-    parse_name_value_directive(line, \"check\".to_owned())\n+fn parse_check_line(line: &str) -> Option<StrBuf> {\n+    parse_name_value_directive(line, \"check\".to_strbuf())\n }\n \n fn parse_force_host(line: &str) -> bool {\n@@ -192,13 +200,16 @@ fn parse_no_pretty_expanded(line: &str) -> bool {\n     parse_name_directive(line, \"no-pretty-expanded\")\n }\n \n-fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n-    parse_name_value_directive(line, \"exec-env\".to_owned()).map(|nv| {\n+fn parse_exec_env(line: &str) -> Option<(StrBuf, StrBuf)> {\n+    parse_name_value_directive(line, \"exec-env\".to_strbuf()).map(|nv| {\n         // nv is either FOO or FOO=BAR\n-        let mut strs: Vec<~str> = nv.splitn('=', 1).map(|s| s.to_owned()).collect();\n+        let mut strs: Vec<StrBuf> = nv.as_slice()\n+                                      .splitn('=', 1)\n+                                      .map(|s| s.to_strbuf())\n+                                      .collect();\n \n         match strs.len() {\n-          1u => (strs.pop().unwrap(), \"\".to_owned()),\n+          1u => (strs.pop().unwrap(), \"\".to_strbuf()),\n           2u => {\n               let end = strs.pop().unwrap();\n               (strs.pop().unwrap(), end)\n@@ -209,7 +220,7 @@ fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n }\n \n fn parse_pp_exact(line: &str, testfile: &Path) -> Option<Path> {\n-    match parse_name_value_directive(line, \"pp-exact\".to_owned()) {\n+    match parse_name_value_directive(line, \"pp-exact\".to_strbuf()) {\n       Some(s) => Some(Path::new(s)),\n       None => {\n         if parse_name_directive(line, \"pp-exact\") {\n@@ -225,14 +236,14 @@ fn parse_name_directive(line: &str, directive: &str) -> bool {\n     line.contains(directive)\n }\n \n-pub fn parse_name_value_directive(line: &str,\n-                              directive: ~str) -> Option<~str> {\n-    let keycolon = directive + \":\";\n-    match line.find_str(keycolon) {\n+pub fn parse_name_value_directive(line: &str, directive: StrBuf)\n+                                  -> Option<StrBuf> {\n+    let keycolon = format_strbuf!(\"{}:\", directive);\n+    match line.find_str(keycolon.as_slice()) {\n         Some(colon) => {\n             let value = line.slice(colon + keycolon.len(),\n-                                   line.len()).to_owned();\n-            debug!(\"{}: {}\", directive,  value);\n+                                   line.len()).to_strbuf();\n+            debug!(\"{}: {}\", directive, value);\n             Some(value)\n         }\n         None => None"}, {"sha": "9f62fd7096c1a62e8980da95e6bbdecf80f6d31c", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=78bc758c94ae9c99b8e4e82f7d18b6733c8eb949", "patch": "@@ -13,7 +13,7 @@ use std::str;\n use std::io::process::{ProcessExit, Command, Process, ProcessOutput};\n \n #[cfg(target_os = \"win32\")]\n-fn target_env(lib_path: &str, prog: &str) -> Vec<(~str, ~str)> {\n+fn target_env(lib_path: &str, prog: &str) -> Vec<(StrBuf, StrBuf)> {\n     let env = os::env();\n \n     // Make sure we include the aux directory in the path\n@@ -22,50 +22,53 @@ fn target_env(lib_path: &str, prog: &str) -> Vec<(~str, ~str)> {\n \n     let mut new_env: Vec<_> = env.move_iter().map(|(k, v)| {\n         let new_v = if \"PATH\" == k {\n-            format!(\"{};{};{}\", v, lib_path, aux_path)\n+            format_strbuf!(\"{};{};{}\", v, lib_path, aux_path)\n         } else {\n-            v\n+            v.to_strbuf()\n         };\n-        (k, new_v)\n+        (k.to_strbuf(), new_v)\n     }).collect();\n     if prog.ends_with(\"rustc.exe\") {\n-        new_env.push((\"RUST_THREADS\".to_owned(), \"1\".to_owned()));\n+        new_env.push((\"RUST_THREADS\".to_strbuf(), \"1\".to_strbuf()));\n     }\n     return new_env;\n }\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn target_env(lib_path: &str, prog: &str) -> Vec<(~str,~str)> {\n+fn target_env(lib_path: &str, prog: &str) -> Vec<(StrBuf,StrBuf)> {\n     // Make sure we include the aux directory in the path\n     let aux_path = prog + \".libaux\";\n \n-    let mut env: Vec<(~str,~str)> = os::env().move_iter().collect();\n+    let mut env: Vec<(StrBuf,StrBuf)> =\n+        os::env().move_iter()\n+                 .map(|(ref k, ref v)| (k.to_strbuf(), v.to_strbuf()))\n+                 .collect();\n     let var = if cfg!(target_os = \"macos\") {\n         \"DYLD_LIBRARY_PATH\"\n     } else {\n         \"LD_LIBRARY_PATH\"\n     };\n     let prev = match env.iter().position(|&(ref k, _)| k.as_slice() == var) {\n         Some(i) => env.remove(i).unwrap().val1(),\n-        None => \"\".to_owned(),\n+        None => \"\".to_strbuf(),\n     };\n-    env.push((var.to_owned(), if prev.is_empty() {\n-        lib_path + \":\" + aux_path\n+    env.push((var.to_strbuf(), if prev.is_empty() {\n+        format_strbuf!(\"{}:{}\", lib_path, aux_path)\n     } else {\n-        lib_path + \":\" + aux_path + \":\" + prev\n+        format_strbuf!(\"{}:{}:{}\", lib_path, aux_path, prev)\n     }));\n     return env;\n }\n \n-pub struct Result {pub status: ProcessExit, pub out: ~str, pub err: ~str}\n+pub struct Result {pub status: ProcessExit, pub out: StrBuf, pub err: StrBuf}\n \n pub fn run(lib_path: &str,\n            prog: &str,\n-           args: &[~str],\n-           env: Vec<(~str, ~str)> ,\n-           input: Option<~str>) -> Option<Result> {\n+           args: &[StrBuf],\n+           env: Vec<(StrBuf, StrBuf)> ,\n+           input: Option<StrBuf>) -> Option<Result> {\n \n     let env = env.clone().append(target_env(lib_path, prog).as_slice());\n     match Command::new(prog).args(args).env(env.as_slice()).spawn() {\n@@ -78,8 +81,8 @@ pub fn run(lib_path: &str,\n \n             Some(Result {\n                 status: status,\n-                out: str::from_utf8(output.as_slice()).unwrap().to_owned(),\n-                err: str::from_utf8(error.as_slice()).unwrap().to_owned()\n+                out: str::from_utf8(output.as_slice()).unwrap().to_strbuf(),\n+                err: str::from_utf8(error.as_slice()).unwrap().to_strbuf()\n             })\n         },\n         Err(..) => None\n@@ -88,9 +91,9 @@ pub fn run(lib_path: &str,\n \n pub fn run_background(lib_path: &str,\n            prog: &str,\n-           args: &[~str],\n-           env: Vec<(~str, ~str)> ,\n-           input: Option<~str>) -> Option<Process> {\n+           args: &[StrBuf],\n+           env: Vec<(StrBuf, StrBuf)> ,\n+           input: Option<StrBuf>) -> Option<Process> {\n \n     let env = env.clone().append(target_env(lib_path, prog).as_slice());\n     match Command::new(prog).args(args).env(env.as_slice()).spawn() {"}, {"sha": "55c3b6a34e5a994381374a2563184549b4092c9a", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 498, "deletions": 276, "changes": 774, "blob_url": "https://github.com/rust-lang/rust/blob/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=78bc758c94ae9c99b8e4e82f7d18b6733c8eb949", "patch": "@@ -31,7 +31,7 @@ use std::strbuf::StrBuf;\n use std::task;\n use test::MetricMap;\n \n-pub fn run(config: Config, testfile: ~str) {\n+pub fn run(config: Config, testfile: StrBuf) {\n \n     match config.target.as_slice() {\n \n@@ -48,7 +48,7 @@ pub fn run(config: Config, testfile: ~str) {\n     run_metrics(config, testfile, &mut _mm);\n }\n \n-pub fn run_metrics(config: Config, testfile: ~str, mm: &mut MetricMap) {\n+pub fn run_metrics(config: Config, testfile: StrBuf, mm: &mut MetricMap) {\n     if config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n         print!(\"\\n\\n\");\n@@ -72,15 +72,17 @@ fn run_cfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n     let proc_res = compile_test(config, props, testfile);\n \n     if proc_res.status.success() {\n-        fatal_ProcRes(\"compile-fail test compiled successfully!\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"compile-fail test compiled successfully!\".to_strbuf(),\n+                      &proc_res);\n     }\n \n     check_correct_failure_status(&proc_res);\n \n     let expected_errors = errors::load_errors(testfile);\n     if !expected_errors.is_empty() {\n         if !props.error_patterns.is_empty() {\n-            fatal(\"both error pattern and expected errors specified\".to_owned());\n+            fatal(\"both error pattern and expected errors \\\n+                   specified\".to_strbuf());\n         }\n         check_expected_errors(expected_errors, testfile, &proc_res);\n     } else {\n@@ -94,7 +96,7 @@ fn run_rfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n         let proc_res = compile_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(\"compilation failed!\".to_owned(), &proc_res);\n+            fatal_ProcRes(\"compilation failed!\".to_strbuf(), &proc_res);\n         }\n \n         exec_compiled_test(config, props, testfile)\n@@ -105,7 +107,8 @@ fn run_rfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n     // The value our Makefile configures valgrind to return on failure\n     static VALGRIND_ERR: int = 100;\n     if proc_res.status.matches_exit_status(VALGRIND_ERR) {\n-        fatal_ProcRes(\"run-fail test isn't valgrind-clean!\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"run-fail test isn't valgrind-clean!\".to_strbuf(),\n+                      &proc_res);\n     }\n \n     check_correct_failure_status(&proc_res);\n@@ -117,7 +120,8 @@ fn check_correct_failure_status(proc_res: &ProcRes) {\n     static RUST_ERR: int = 101;\n     if !proc_res.status.matches_exit_status(RUST_ERR) {\n         fatal_ProcRes(\n-            format!(\"failure produced the wrong error: {}\", proc_res.status),\n+            format_strbuf!(\"failure produced the wrong error: {}\",\n+                           proc_res.status),\n             proc_res);\n     }\n }\n@@ -127,40 +131,49 @@ fn run_rpass_test(config: &Config, props: &TestProps, testfile: &Path) {\n         let mut proc_res = compile_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(\"compilation failed!\".to_owned(), &proc_res);\n+            fatal_ProcRes(\"compilation failed!\".to_strbuf(), &proc_res);\n         }\n \n         proc_res = exec_compiled_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(\"test run failed!\".to_owned(), &proc_res);\n+            fatal_ProcRes(\"test run failed!\".to_strbuf(), &proc_res);\n         }\n     } else {\n         let proc_res = jit_test(config, props, testfile);\n \n-        if !proc_res.status.success() { fatal_ProcRes(\"jit failed!\".to_owned(), &proc_res); }\n+        if !proc_res.status.success() {\n+            fatal_ProcRes(\"jit failed!\".to_strbuf(), &proc_res);\n+        }\n     }\n }\n \n fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n     if props.pp_exact.is_some() {\n-        logv(config, \"testing for exact pretty-printing\".to_owned());\n-    } else { logv(config, \"testing for converging pretty-printing\".to_owned()); }\n+        logv(config, \"testing for exact pretty-printing\".to_strbuf());\n+    } else {\n+        logv(config, \"testing for converging pretty-printing\".to_strbuf());\n+    }\n \n     let rounds =\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n     let src = File::open(testfile).read_to_end().unwrap();\n-    let src = str::from_utf8(src.as_slice()).unwrap().to_owned();\n+    let src = str::from_utf8(src.as_slice()).unwrap().to_strbuf();\n     let mut srcs = vec!(src);\n \n     let mut round = 0;\n     while round < rounds {\n-        logv(config, format!(\"pretty-printing round {}\", round));\n-        let proc_res = print_source(config, props, testfile, (*srcs.get(round)).clone(), \"normal\");\n+        logv(config, format_strbuf!(\"pretty-printing round {}\", round));\n+        let proc_res = print_source(config,\n+                                    props,\n+                                    testfile,\n+                                    (*srcs.get(round)).to_strbuf(),\n+                                    \"normal\");\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(format!(\"pretty-printing failed in round {}\", round),\n+            fatal_ProcRes(format_strbuf!(\"pretty-printing failed in round {}\",\n+                                         round),\n                           &proc_res);\n         }\n \n@@ -173,70 +186,87 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n         Some(ref file) => {\n             let filepath = testfile.dir_path().join(file);\n             let s = File::open(&filepath).read_to_end().unwrap();\n-            str::from_utf8(s.as_slice()).unwrap().to_owned()\n+            str::from_utf8(s.as_slice()).unwrap().to_strbuf()\n           }\n           None => { (*srcs.get(srcs.len() - 2u)).clone() }\n         };\n     let mut actual = (*srcs.get(srcs.len() - 1u)).clone();\n \n     if props.pp_exact.is_some() {\n         // Now we have to care about line endings\n-        let cr = \"\\r\".to_owned();\n-        actual = actual.replace(cr, \"\");\n-        expected = expected.replace(cr, \"\");\n+        let cr = \"\\r\".to_strbuf();\n+        actual = actual.replace(cr.as_slice(), \"\").to_strbuf();\n+        expected = expected.replace(cr.as_slice(), \"\").to_strbuf();\n     }\n \n-    compare_source(expected, actual);\n+    compare_source(expected.as_slice(), actual.as_slice());\n \n     // Finally, let's make sure it actually appears to remain valid code\n     let proc_res = typecheck_source(config, props, testfile, actual);\n \n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"pretty-printed source does not typecheck\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"pretty-printed source does not typecheck\".to_strbuf(),\n+                      &proc_res);\n     }\n     if props.no_pretty_expanded { return }\n \n     // additionally, run `--pretty expanded` and try to build it.\n     let proc_res = print_source(config, props, testfile, (*srcs.get(round)).clone(), \"expanded\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(format!(\"pretty-printing (expanded) failed\"), &proc_res);\n+        fatal_ProcRes(format_strbuf!(\"pretty-printing (expanded) failed\"),\n+                                     &proc_res);\n     }\n \n     let ProcRes{ stdout: expanded_src, .. } = proc_res;\n     let proc_res = typecheck_source(config, props, testfile, expanded_src);\n     if !proc_res.status.success() {\n-        fatal_ProcRes(format!(\"pretty-printed source (expanded) does not typecheck\"), &proc_res);\n+        fatal_ProcRes(format_strbuf!(\"pretty-printed source (expanded) does \\\n+                                      not typecheck\"),\n+                      &proc_res);\n     }\n \n     return;\n \n     fn print_source(config: &Config,\n                     props: &TestProps,\n                     testfile: &Path,\n-                    src: ~str,\n+                    src: StrBuf,\n                     pretty_type: &str) -> ProcRes {\n-        compose_and_run(config, testfile,\n-                        make_pp_args(config, props, testfile, pretty_type.to_owned()),\n-                        props.exec_env.clone(), config.compile_lib_path, Some(src))\n+        compose_and_run(config,\n+                        testfile,\n+                        make_pp_args(config,\n+                                     props,\n+                                     testfile,\n+                                     pretty_type.to_strbuf()),\n+                        props.exec_env.clone(),\n+                        config.compile_lib_path.as_slice(),\n+                        Some(src))\n     }\n \n     fn make_pp_args(config: &Config,\n                     props: &TestProps,\n                     testfile: &Path,\n-                    pretty_type: ~str) -> ProcArgs {\n+                    pretty_type: StrBuf) -> ProcArgs {\n         let aux_dir = aux_output_dir_name(config, testfile);\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec!(\"-\".to_owned(), \"--pretty\".to_owned(), pretty_type,\n-                            \"--target=\".to_owned() + config.target,\n-                            \"-L\".to_owned(), aux_dir.as_str().unwrap().to_owned());\n+        let mut args = vec!(\"-\".to_strbuf(),\n+                            \"--pretty\".to_strbuf(),\n+                            pretty_type,\n+                            format_strbuf!(\"--target={}\", config.target),\n+                            \"-L\".to_strbuf(),\n+                            aux_dir.as_str().unwrap().to_strbuf());\n         args.push_all_move(split_maybe_args(&config.target_rustcflags));\n         args.push_all_move(split_maybe_args(&props.compile_flags));\n-        return ProcArgs {prog: config.rustc_path.as_str().unwrap().to_owned(), args: args};\n+        return ProcArgs {\n+            prog: config.rustc_path.as_str().unwrap().to_strbuf(),\n+            args: args,\n+        };\n     }\n \n     fn compare_source(expected: &str, actual: &str) {\n         if expected != actual {\n-            error(\"pretty-printed source does not match expected source\".to_owned());\n+            error(\"pretty-printed source does not match expected \\\n+                   source\".to_strbuf());\n             println!(\"\\n\\\n expected:\\n\\\n ------------------------------------------\\n\\\n@@ -253,7 +283,7 @@ actual:\\n\\\n     }\n \n     fn typecheck_source(config: &Config, props: &TestProps,\n-                        testfile: &Path, src: ~str) -> ProcRes {\n+                        testfile: &Path, src: StrBuf) -> ProcRes {\n         let args = make_typecheck_args(config, props, testfile);\n         compose_and_run_compiler(config, props, testfile, args, Some(src))\n     }\n@@ -266,16 +296,21 @@ actual:\\n\\\n             config.target.as_slice()\n         };\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec!(\"-\".to_owned(),\n-                         \"--no-trans\".to_owned(), \"--crate-type=lib\".to_owned(),\n-                         \"--target=\".to_owned() + target,\n-                         \"-L\".to_owned(), config.build_base.as_str().unwrap().to_owned(),\n-                         \"-L\".to_owned(),\n-                         aux_dir.as_str().unwrap().to_owned());\n+        let mut args = vec!(\"-\".to_strbuf(),\n+                            \"--no-trans\".to_strbuf(),\n+                            \"--crate-type=lib\".to_strbuf(),\n+                            format_strbuf!(\"--target={}\", target),\n+                            \"-L\".to_strbuf(),\n+                            config.build_base.as_str().unwrap().to_strbuf(),\n+                            \"-L\".to_strbuf(),\n+                            aux_dir.as_str().unwrap().to_strbuf());\n         args.push_all_move(split_maybe_args(&config.target_rustcflags));\n         args.push_all_move(split_maybe_args(&props.compile_flags));\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        return ProcArgs {prog: config.rustc_path.as_str().unwrap().to_owned(), args: args};\n+        return ProcArgs {\n+            prog: config.rustc_path.as_str().unwrap().to_strbuf(),\n+            args: args,\n+        };\n     }\n }\n \n@@ -288,12 +323,12 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n     let config = &mut config;\n     let DebuggerCommands { commands, check_lines, .. } = parse_debugger_commands(testfile, \"gdb\");\n-    let mut cmds = commands.connect(\"\\n\");\n+    let mut cmds = commands.connect(\"\\n\").to_strbuf();\n \n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n     let compiler_run_result = compile_test(config, props, testfile);\n     if !compiler_run_result.status.success() {\n-        fatal_ProcRes(\"compilation failed!\".to_owned(), &compiler_run_result);\n+        fatal_ProcRes(\"compilation failed!\".to_strbuf(), &compiler_run_result);\n     }\n \n     let exe_file = make_exe_name(config, testfile);\n@@ -303,38 +338,64 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n     match config.target.as_slice() {\n         \"arm-linux-androideabi\" => {\n \n-            cmds = cmds.replace(\"run\",\"continue\");\n+            cmds = cmds.replace(\"run\", \"continue\").to_strbuf();\n \n             // write debugger script\n-            let script_str = [\"set charset UTF-8\".to_owned(),\n-                              format!(\"file {}\",exe_file.as_str().unwrap().to_owned()),\n-                              \"target remote :5039\".to_owned(),\n+            let script_str = [\"set charset UTF-8\".to_strbuf(),\n+                              format_strbuf!(\"file {}\",\n+                                             exe_file.as_str()\n+                                                     .unwrap()\n+                                                     .to_strbuf()),\n+                              \"target remote :5039\".to_strbuf(),\n                               cmds,\n-                              \"quit\".to_owned()].connect(\"\\n\");\n+                              \"quit\".to_strbuf()].connect(\"\\n\");\n             debug!(\"script_str = {}\", script_str);\n             dump_output_file(config, testfile, script_str, \"debugger.script\");\n \n \n-            procsrv::run(\"\", config.adb_path,\n-                         [\"push\".to_owned(), exe_file.as_str().unwrap().to_owned(),\n-                          config.adb_test_dir.clone()],\n-                         vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n-                .expect(format!(\"failed to exec `{}`\", config.adb_path));\n-\n-            procsrv::run(\"\", config.adb_path,\n-                         [\"forward\".to_owned(), \"tcp:5039\".to_owned(), \"tcp:5039\".to_owned()],\n-                         vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n-                .expect(format!(\"failed to exec `{}`\", config.adb_path));\n-\n-            let adb_arg = format!(\"export LD_LIBRARY_PATH={}; gdbserver :5039 {}/{}\",\n-                                  config.adb_test_dir.clone(), config.adb_test_dir.clone(),\n-                                  str::from_utf8(exe_file.filename().unwrap()).unwrap());\n-\n-            let mut process = procsrv::run_background(\"\", config.adb_path,\n-                                                      [\"shell\".to_owned(),adb_arg.clone()],\n-                                                      vec!((\"\".to_owned(),\"\".to_owned())),\n-                                                      Some(\"\".to_owned()))\n-                .expect(format!(\"failed to exec `{}`\", config.adb_path));\n+            procsrv::run(\"\",\n+                         config.adb_path.as_slice(),\n+                         [\n+                            \"push\".to_strbuf(),\n+                            exe_file.as_str().unwrap().to_strbuf(),\n+                            config.adb_test_dir.clone()\n+                         ],\n+                         vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n+                         Some(\"\".to_strbuf()))\n+                .expect(format_strbuf!(\"failed to exec `{}`\",\n+                                       config.adb_path));\n+\n+            procsrv::run(\"\",\n+                         config.adb_path.as_slice(),\n+                         [\n+                            \"forward\".to_strbuf(),\n+                            \"tcp:5039\".to_strbuf(),\n+                            \"tcp:5039\".to_strbuf()\n+                         ],\n+                         vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n+                         Some(\"\".to_strbuf()))\n+                .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n+\n+            let adb_arg = format_strbuf!(\"export LD_LIBRARY_PATH={}; \\\n+                                          gdbserver :5039 {}/{}\",\n+                                         config.adb_test_dir.clone(),\n+                                         config.adb_test_dir.clone(),\n+                                         str::from_utf8(\n+                                             exe_file.filename()\n+                                             .unwrap()).unwrap());\n+\n+            let mut process = procsrv::run_background(\"\",\n+                                                      config.adb_path\n+                                                            .as_slice(),\n+                                                      [\n+                                                        \"shell\".to_strbuf(),\n+                                                        adb_arg.clone()\n+                                                      ],\n+                                                      vec!((\"\".to_strbuf(),\n+                                                            \"\".to_strbuf())),\n+                                                      Some(\"\".to_strbuf()))\n+                .expect(format_strbuf!(\"failed to exec `{}`\",\n+                                       config.adb_path));\n             loop {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(1000);\n@@ -349,27 +410,34 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n             let tool_path = match config.android_cross_path.as_str() {\n                 Some(x) => x.to_strbuf(),\n-                None => fatal(\"cannot find android cross path\".to_owned())\n+                None => fatal(\"cannot find android cross path\".to_strbuf())\n             };\n \n             let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            let debugger_opts = vec!(\"-quiet\".to_owned(), \"-batch\".to_owned(), \"-nx\".to_owned(),\n-                                  \"-command=\" + debugger_script.as_str().unwrap().to_owned());\n+            let debugger_opts =\n+                vec!(\"-quiet\".to_strbuf(),\n+                     \"-batch\".to_strbuf(),\n+                     \"-nx\".to_strbuf(),\n+                     format_strbuf!(\"-command={}\",\n+                                    debugger_script.as_str().unwrap()));\n \n             let gdb_path = tool_path.append(\"/bin/arm-linux-androideabi-gdb\");\n-            let procsrv::Result{ out, err, status }=\n-                procsrv::run(\"\",\n+            let procsrv::Result {\n+                out,\n+                err,\n+                status\n+            } = procsrv::run(\"\",\n                              gdb_path.as_slice(),\n                              debugger_opts.as_slice(),\n-                             vec!((\"\".to_owned(),\"\".to_owned())),\n+                             vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n                              None)\n-                .expect(format!(\"failed to exec `{}`\", gdb_path));\n+                .expect(format_strbuf!(\"failed to exec `{}`\", gdb_path));\n             let cmdline = {\n                 let cmdline = make_cmdline(\"\",\n                                            \"arm-linux-androideabi-gdb\",\n                                            debugger_opts.as_slice());\n-                logv(config, format!(\"executing {}\", cmdline));\n+                logv(config, format_strbuf!(\"executing {}\", cmdline));\n                 cmdline\n             };\n \n@@ -384,25 +452,38 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n         _=> {\n             // write debugger script\n-            let script_str = [\"set charset UTF-8\".to_owned(),\n+            let script_str = [\n+                \"set charset UTF-8\".to_strbuf(),\n                 cmds,\n-                \"quit\\n\".to_owned()].connect(\"\\n\");\n+                \"quit\\n\".to_strbuf()\n+            ].connect(\"\\n\");\n             debug!(\"script_str = {}\", script_str);\n             dump_output_file(config, testfile, script_str, \"debugger.script\");\n \n             // run debugger script with gdb\n             #[cfg(windows)]\n-            fn debugger() -> ~str { \"gdb.exe\".to_owned() }\n+            fn debugger() -> StrBuf {\n+                \"gdb.exe\".to_strbuf()\n+            }\n             #[cfg(unix)]\n-            fn debugger() -> ~str { \"gdb\".to_owned() }\n+            fn debugger() -> StrBuf {\n+                \"gdb\".to_strbuf()\n+            }\n \n             let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n \n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            let debugger_opts = vec!(\"-quiet\".to_owned(), \"-batch\".to_owned(), \"-nx\".to_owned(),\n-                \"-command=\" + debugger_script.as_str().unwrap().to_owned(),\n-                exe_file.as_str().unwrap().to_owned());\n-            proc_args = ProcArgs {prog: debugger(), args: debugger_opts};\n+            let debugger_opts =\n+                vec!(\"-quiet\".to_strbuf(),\n+                     \"-batch\".to_strbuf(),\n+                     \"-nx\".to_strbuf(),\n+                     format_strbuf!(\"-command={}\",\n+                                    debugger_script.as_str().unwrap()),\n+                     exe_file.as_str().unwrap().to_strbuf());\n+            proc_args = ProcArgs {\n+                prog: debugger(),\n+                args: debugger_opts,\n+            };\n             debugger_run_result = compose_and_run(config,\n                                                   testfile,\n                                                   proc_args,\n@@ -413,7 +494,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n     }\n \n     if !debugger_run_result.status.success() {\n-        fatal(\"gdb failed to execute\".to_owned());\n+        fatal(\"gdb failed to execute\".to_strbuf());\n     }\n \n     check_debugger_output(&debugger_run_result, check_lines.as_slice());\n@@ -423,7 +504,8 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     use std::io::process::{Command, ProcessOutput};\n \n     if config.lldb_python_dir.is_none() {\n-        fatal(\"Can't run LLDB test because LLDB's python path is not set.\".to_owned());\n+        fatal(\"Can't run LLDB test because LLDB's python path is not \\\n+               set.\".to_strbuf());\n     }\n \n     let mut config = Config {\n@@ -437,7 +519,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n     let compile_result = compile_test(config, props, testfile);\n     if !compile_result.status.success() {\n-        fatal_ProcRes(\"compilation failed!\".to_owned(), &compile_result);\n+        fatal_ProcRes(\"compilation failed!\".to_strbuf(), &compile_result);\n     }\n \n     let exe_file = make_exe_name(config, testfile);\n@@ -476,7 +558,8 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     let debugger_run_result = run_lldb(config, &exe_file, &debugger_script);\n \n     if !debugger_run_result.status.success() {\n-        fatal_ProcRes(\"Error while running LLDB\".to_owned(), &debugger_run_result);\n+        fatal_ProcRes(\"Error while running LLDB\".to_strbuf(),\n+                      &debugger_run_result);\n     }\n \n     check_debugger_output(&debugger_run_result, check_lines.as_slice());\n@@ -495,32 +578,34 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n                     process.wait_with_output().unwrap();\n \n                 (status,\n-                 str::from_utf8(output.as_slice()).unwrap().to_owned(),\n-                 str::from_utf8(error.as_slice()).unwrap().to_owned())\n+                 str::from_utf8(output.as_slice()).unwrap().to_strbuf(),\n+                 str::from_utf8(error.as_slice()).unwrap().to_strbuf())\n             },\n             Err(e) => {\n-                fatal(format!(\"Failed to setup Python process for LLDB script: {}\", e))\n+                fatal(format_strbuf!(\"Failed to setup Python process for \\\n+                                      LLDB script: {}\",\n+                                     e))\n             }\n         };\n \n-        dump_output(config, test_executable, out, err);\n+        dump_output(config, test_executable, out.as_slice(), err.as_slice());\n         return ProcRes {\n             status: status,\n             stdout: out,\n             stderr: err,\n-            cmdline: format!(\"{}\", cmd)\n+            cmdline: format_strbuf!(\"{}\", cmd)\n         };\n     }\n }\n \n-struct DebuggerCommands\n-{\n-    commands: Vec<~str>,\n-    check_lines: Vec<~str>,\n-    breakpoint_lines: Vec<uint>\n+struct DebuggerCommands {\n+    commands: Vec<StrBuf>,\n+    check_lines: Vec<StrBuf>,\n+    breakpoint_lines: Vec<uint>,\n }\n \n-fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str) -> DebuggerCommands {\n+fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n+                           -> DebuggerCommands {\n     use std::io::{BufferedReader, File};\n \n     let command_directive = debugger_prefix + \"-command\";\n@@ -538,14 +623,22 @@ fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str) -> DebuggerC\n                     breakpoint_lines.push(counter);\n                 }\n \n-                header::parse_name_value_directive(line, command_directive.clone())\n-                    .map(|cmd| commands.push(cmd));\n+                header::parse_name_value_directive(\n+                        line,\n+                        command_directive.to_strbuf()).map(|cmd| {\n+                    commands.push(cmd)\n+                });\n \n-                header::parse_name_value_directive(line, check_directive.clone())\n-                    .map(|cmd| check_lines.push(cmd));\n+                header::parse_name_value_directive(\n+                        line,\n+                        check_directive.to_strbuf()).map(|cmd| {\n+                    check_lines.push(cmd)\n+                });\n             }\n             Err(e) => {\n-                fatal(format!(\"Error while parsing debugger commands: {}\", e))\n+                fatal(format_strbuf!(\"Error while parsing debugger commands: \\\n+                                      {}\",\n+                                     e))\n             }\n         }\n         counter += 1;\n@@ -558,41 +651,55 @@ fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str) -> DebuggerC\n     }\n }\n \n-fn cleanup_debug_info_options(options: &Option<~str>) -> Option<~str> {\n+fn cleanup_debug_info_options(options: &Option<StrBuf>) -> Option<StrBuf> {\n     if options.is_none() {\n         return None;\n     }\n \n     // Remove options that are either unwanted (-O) or may lead to duplicates due to RUSTFLAGS.\n-    let options_to_remove = [\"-O\".to_owned(), \"-g\".to_owned(), \"--debuginfo\".to_owned()];\n-    let new_options = split_maybe_args(options).move_iter()\n-                                               .filter(|x| !options_to_remove.contains(x))\n-                                               .collect::<Vec<~str>>()\n-                                               .connect(\" \");\n+    let options_to_remove = [\n+        \"-O\".to_strbuf(),\n+        \"-g\".to_strbuf(),\n+        \"--debuginfo\".to_strbuf()\n+    ];\n+    let new_options =\n+        split_maybe_args(options).move_iter()\n+                                 .filter(|x| !options_to_remove.contains(x))\n+                                 .collect::<Vec<StrBuf>>()\n+                                 .connect(\" \")\n+                                 .to_strbuf();\n     Some(new_options)\n }\n \n-fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[~str]) {\n+fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[StrBuf]) {\n     let num_check_lines = check_lines.len();\n     if num_check_lines > 0 {\n         // Allow check lines to leave parts unspecified (e.g., uninitialized\n         // bits in the wrong case of an enum) with the notation \"[...]\".\n-        let check_fragments: Vec<Vec<~str>> =\n+        let check_fragments: Vec<Vec<StrBuf>> =\n             check_lines.iter().map(|s| {\n-                s.trim().split_str(\"[...]\").map(|x| x.to_str()).collect()\n+                s.as_slice()\n+                 .trim()\n+                 .split_str(\"[...]\")\n+                 .map(|x| x.to_strbuf())\n+                 .collect()\n             }).collect();\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n         let mut i = 0u;\n-        for line in debugger_run_result.stdout.lines() {\n+        for line in debugger_run_result.stdout.as_slice().lines() {\n             let mut rest = line.trim();\n             let mut first = true;\n             let mut failed = false;\n             for frag in check_fragments.get(i).iter() {\n                 let found = if first {\n-                    if rest.starts_with(*frag) { Some(0) } else { None }\n+                    if rest.starts_with(frag.as_slice()) {\n+                        Some(0)\n+                    } else {\n+                        None\n+                    }\n                 } else {\n-                    rest.find_str(*frag)\n+                    rest.find_str(frag.as_slice())\n                 };\n                 match found {\n                     None => {\n@@ -614,8 +721,10 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[~str]) {\n             }\n         }\n         if i != num_check_lines {\n-            fatal_ProcRes(format!(\"line not found in debugger output: {}\",\n-                                  check_lines.get(i).unwrap()), debugger_run_result);\n+            fatal_ProcRes(format_strbuf!(\"line not found in debugger output: \\\n+                                          {}\",\n+                                         check_lines.get(i).unwrap()),\n+                          debugger_run_result);\n         }\n     }\n }\n@@ -624,24 +733,24 @@ fn check_error_patterns(props: &TestProps,\n                         testfile: &Path,\n                         proc_res: &ProcRes) {\n     if props.error_patterns.is_empty() {\n-        fatal(\"no error pattern specified in \".to_owned() +\n-              testfile.display().as_maybe_owned().as_slice());\n+        fatal(format_strbuf!(\"no error pattern specified in {}\",\n+                             testfile.display().as_maybe_owned().as_slice()));\n     }\n \n     if proc_res.status.success() {\n-        fatal(\"process did not return an error status\".to_owned());\n+        fatal(\"process did not return an error status\".to_strbuf());\n     }\n \n     let mut next_err_idx = 0u;\n     let mut next_err_pat = props.error_patterns.get(next_err_idx);\n     let mut done = false;\n     let output_to_check = if props.check_stdout {\n-        proc_res.stdout + proc_res.stderr\n+        format_strbuf!(\"{}{}\", proc_res.stdout, proc_res.stderr)\n     } else {\n         proc_res.stderr.clone()\n     };\n-    for line in output_to_check.lines() {\n-        if line.contains(*next_err_pat) {\n+    for line in output_to_check.as_slice().lines() {\n+        if line.contains(next_err_pat.as_slice()) {\n             debug!(\"found error pattern {}\", *next_err_pat);\n             next_err_idx += 1u;\n             if next_err_idx == props.error_patterns.len() {\n@@ -657,20 +766,22 @@ fn check_error_patterns(props: &TestProps,\n     let missing_patterns =\n         props.error_patterns.slice(next_err_idx, props.error_patterns.len());\n     if missing_patterns.len() == 1u {\n-        fatal_ProcRes(format!(\"error pattern '{}' not found!\",\n-                              missing_patterns[0]), proc_res);\n+        fatal_ProcRes(format_strbuf!(\"error pattern '{}' not found!\",\n+                                     missing_patterns[0]),\n+                      proc_res);\n     } else {\n         for pattern in missing_patterns.iter() {\n-            error(format!(\"error pattern '{}' not found!\", *pattern));\n+            error(format_strbuf!(\"error pattern '{}' not found!\", *pattern));\n         }\n-        fatal_ProcRes(\"multiple error patterns not found\".to_owned(), proc_res);\n+        fatal_ProcRes(\"multiple error patterns not found\".to_strbuf(),\n+                      proc_res);\n     }\n }\n \n fn check_no_compiler_crash(proc_res: &ProcRes) {\n-    for line in proc_res.stderr.lines() {\n+    for line in proc_res.stderr.as_slice().lines() {\n         if line.starts_with(\"error: internal compiler error:\") {\n-            fatal_ProcRes(\"compiler encountered internal error\".to_owned(),\n+            fatal_ProcRes(\"compiler encountered internal error\".to_strbuf(),\n                           proc_res);\n         }\n     }\n@@ -685,15 +796,15 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n         expected_errors.len(), false);\n \n     if proc_res.status.success() {\n-        fatal(\"process did not return an error status\".to_owned());\n+        fatal(\"process did not return an error status\".to_strbuf());\n     }\n \n     let prefixes = expected_errors.iter().map(|ee| {\n-        format!(\"{}:{}:\", testfile.display(), ee.line)\n-    }).collect::<Vec<~str> >();\n+        format_strbuf!(\"{}:{}:\", testfile.display(), ee.line)\n+    }).collect::<Vec<StrBuf> >();\n \n     #[cfg(target_os = \"win32\")]\n-    fn to_lower( s : &str ) -> ~str {\n+    fn to_lower( s : &str ) -> StrBuf {\n         let i = s.chars();\n         let c : Vec<char> = i.map( |c| {\n             if c.is_ascii() {\n@@ -702,12 +813,12 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n                 c\n             }\n         } ).collect();\n-        str::from_chars(c.as_slice())\n+        str::from_chars(c.as_slice()).to_strbuf()\n     }\n \n     #[cfg(target_os = \"win32\")]\n     fn prefix_matches( line : &str, prefix : &str ) -> bool {\n-        to_lower(line).starts_with( to_lower(prefix) )\n+        to_lower(line).as_slice().starts_with(to_lower(prefix).as_slice())\n     }\n \n     #[cfg(target_os = \"linux\")]\n@@ -723,15 +834,18 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    for line in proc_res.stderr.lines() {\n+    for line in proc_res.stderr.as_slice().lines() {\n         let mut was_expected = false;\n         for (i, ee) in expected_errors.iter().enumerate() {\n             if !*found_flags.get(i) {\n                 debug!(\"prefix={} ee.kind={} ee.msg={} line={}\",\n-                       *prefixes.get(i), ee.kind, ee.msg, line);\n-                if prefix_matches(line, *prefixes.get(i)) &&\n-                    line.contains(ee.kind) &&\n-                    line.contains(ee.msg) {\n+                       prefixes.get(i).as_slice(),\n+                       ee.kind,\n+                       ee.msg,\n+                       line);\n+                if prefix_matches(line, prefixes.get(i).as_slice()) &&\n+                    line.contains(ee.kind.as_slice()) &&\n+                    line.contains(ee.msg.as_slice()) {\n                     *found_flags.get_mut(i) = true;\n                     was_expected = true;\n                     break;\n@@ -745,17 +859,22 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n         }\n \n         if !was_expected && is_compiler_error_or_warning(line) {\n-            fatal_ProcRes(format!(\"unexpected compiler error or warning: '{}'\",\n-                               line),\n+            fatal_ProcRes(format_strbuf!(\"unexpected compiler error or \\\n+                                          warning: '{}'\",\n+                                         line),\n                           proc_res);\n         }\n     }\n \n     for (i, &flag) in found_flags.iter().enumerate() {\n         if !flag {\n             let ee = expected_errors.get(i);\n-            fatal_ProcRes(format!(\"expected {} on line {} not found: {}\",\n-                               ee.kind, ee.line, ee.msg), proc_res);\n+            fatal_ProcRes(format_strbuf!(\"expected {} on line {} not found: \\\n+                                          {}\",\n+                                         ee.kind,\n+                                         ee.line,\n+                                         ee.msg),\n+                          proc_res);\n         }\n     }\n }\n@@ -835,24 +954,33 @@ fn scan_string(haystack: &str, needle: &str, idx: &mut uint) -> bool {\n     return true;\n }\n \n-struct ProcArgs {prog: ~str, args: Vec<~str> }\n+struct ProcArgs {\n+    prog: StrBuf,\n+    args: Vec<StrBuf>,\n+}\n \n-struct ProcRes {status: ProcessExit, stdout: ~str, stderr: ~str, cmdline: ~str}\n+struct ProcRes {\n+    status: ProcessExit,\n+    stdout: StrBuf,\n+    stderr: StrBuf,\n+    cmdline: StrBuf,\n+}\n \n fn compile_test(config: &Config, props: &TestProps,\n                 testfile: &Path) -> ProcRes {\n     compile_test_(config, props, testfile, [])\n }\n \n fn jit_test(config: &Config, props: &TestProps, testfile: &Path) -> ProcRes {\n-    compile_test_(config, props, testfile, [\"--jit\".to_owned()])\n+    compile_test_(config, props, testfile, [\"--jit\".to_strbuf()])\n }\n \n fn compile_test_(config: &Config, props: &TestProps,\n-                 testfile: &Path, extra_args: &[~str]) -> ProcRes {\n+                 testfile: &Path, extra_args: &[StrBuf]) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let link_args = vec!(\"-L\".to_owned(), aux_dir.as_str().unwrap().to_owned());\n+    let link_args = vec!(\"-L\".to_strbuf(),\n+                         aux_dir.as_str().unwrap().to_strbuf());\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args.append(extra_args),\n@@ -872,10 +1000,12 @@ fn exec_compiled_test(config: &Config, props: &TestProps,\n         }\n \n         _=> {\n-            compose_and_run(config, testfile,\n+            compose_and_run(config,\n+                            testfile,\n                             make_run_args(config, props, testfile),\n                             env,\n-                            config.run_lib_path, None)\n+                            config.run_lib_path.as_slice(),\n+                            None)\n         }\n     }\n }\n@@ -885,7 +1015,7 @@ fn compose_and_run_compiler(\n     props: &TestProps,\n     testfile: &Path,\n     args: ProcArgs,\n-    input: Option<~str>) -> ProcRes {\n+    input: Option<StrBuf>) -> ProcRes {\n \n     if !props.aux_builds.is_empty() {\n         ensure_dir(&aux_output_dir_name(config, testfile));\n@@ -901,37 +1031,48 @@ fn compose_and_run_compiler(\n         let crate_type = if aux_props.no_prefer_dynamic {\n             Vec::new()\n         } else {\n-            vec!(\"--crate-type=dylib\".to_owned())\n+            vec!(\"--crate-type=dylib\".to_strbuf())\n         };\n         let aux_args =\n             make_compile_args(config,\n                               &aux_props,\n-                              crate_type.append(extra_link_args.as_slice()),\n+                              crate_type.append(\n+                                  extra_link_args.iter()\n+                                                 .map(|x| x.to_strbuf())\n+                                                 .collect::<Vec<_>>()\n+                                                 .as_slice()),\n                               |a,b| {\n                                   let f = make_lib_name(a, b, testfile);\n                                   ThisDirectory(f.dir_path())\n-                              }, &abs_ab);\n-        let auxres = compose_and_run(config, &abs_ab, aux_args, Vec::new(),\n-                                     config.compile_lib_path, None);\n+                              },\n+                              &abs_ab);\n+        let auxres = compose_and_run(config,\n+                                     &abs_ab,\n+                                     aux_args,\n+                                     Vec::new(),\n+                                     config.compile_lib_path.as_slice(),\n+                                     None);\n         if !auxres.status.success() {\n             fatal_ProcRes(\n-                format!(\"auxiliary build of {} failed to compile: \",\n-                     abs_ab.display()),\n+                format_strbuf!(\"auxiliary build of {} failed to compile: \",\n+                               abs_ab.display()),\n                 &auxres);\n         }\n \n         match config.target.as_slice() {\n-\n             \"arm-linux-androideabi\" => {\n                 _arm_push_aux_shared_library(config, testfile);\n             }\n-\n-            _=> { }\n+            _ => {}\n         }\n     }\n \n-    compose_and_run(config, testfile, args, Vec::new(),\n-                    config.compile_lib_path, input)\n+    compose_and_run(config,\n+                    testfile,\n+                    args,\n+                    Vec::new(),\n+                    config.compile_lib_path.as_slice(),\n+                    input)\n }\n \n fn ensure_dir(path: &Path) {\n@@ -941,9 +1082,9 @@ fn ensure_dir(path: &Path) {\n \n fn compose_and_run(config: &Config, testfile: &Path,\n                    ProcArgs{ args, prog }: ProcArgs,\n-                   procenv: Vec<(~str, ~str)> ,\n+                   procenv: Vec<(StrBuf, StrBuf)> ,\n                    lib_path: &str,\n-                   input: Option<~str>) -> ProcRes {\n+                   input: Option<StrBuf>) -> ProcRes {\n     return program_output(config, testfile, lib_path,\n                           prog, args, procenv, input);\n }\n@@ -955,7 +1096,7 @@ enum TargetLocation {\n \n fn make_compile_args(config: &Config,\n                      props: &TestProps,\n-                     extras: Vec<~str> ,\n+                     extras: Vec<StrBuf> ,\n                      xform: |&Config, &Path| -> TargetLocation,\n                      testfile: &Path)\n                      -> ProcArgs {\n@@ -966,26 +1107,36 @@ fn make_compile_args(config: &Config,\n         config.target.as_slice()\n     };\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let mut args = vec!(testfile.as_str().unwrap().to_owned(),\n-                     \"-L\".to_owned(), config.build_base.as_str().unwrap().to_owned(),\n-                     \"--target=\".to_owned() + target);\n+    let mut args = vec!(testfile.as_str().unwrap().to_strbuf(),\n+                        \"-L\".to_strbuf(),\n+                        config.build_base.as_str().unwrap().to_strbuf(),\n+                        format_strbuf!(\"--target={}\", target));\n     args.push_all(extras.as_slice());\n     if !props.no_prefer_dynamic {\n-        args.push(\"-C\".to_owned());\n-        args.push(\"prefer-dynamic\".to_owned());\n+        args.push(\"-C\".to_strbuf());\n+        args.push(\"prefer-dynamic\".to_strbuf());\n     }\n     let path = match xform_file {\n-        ThisFile(path) => { args.push(\"-o\".to_owned()); path }\n-        ThisDirectory(path) => { args.push(\"--out-dir\".to_owned()); path }\n+        ThisFile(path) => {\n+            args.push(\"-o\".to_strbuf());\n+            path\n+        }\n+        ThisDirectory(path) => {\n+            args.push(\"--out-dir\".to_strbuf());\n+            path\n+        }\n     };\n-    args.push(path.as_str().unwrap().to_owned());\n+    args.push(path.as_str().unwrap().to_strbuf());\n     if props.force_host {\n         args.push_all_move(split_maybe_args(&config.host_rustcflags));\n     } else {\n         args.push_all_move(split_maybe_args(&config.target_rustcflags));\n     }\n     args.push_all_move(split_maybe_args(&props.compile_flags));\n-    return ProcArgs {prog: config.rustc_path.as_str().unwrap().to_owned(), args: args};\n+    return ProcArgs {\n+        prog: config.rustc_path.as_str().unwrap().to_strbuf(),\n+        args: args,\n+    };\n }\n \n fn make_lib_name(config: &Config, auxfile: &Path, testfile: &Path) -> Path {\n@@ -1014,64 +1165,88 @@ fn make_run_args(config: &Config, props: &TestProps, testfile: &Path) ->\n     let exe_file = make_exe_name(config, testfile);\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    args.push(exe_file.as_str().unwrap().to_owned());\n+    args.push(exe_file.as_str().unwrap().to_strbuf());\n \n     // Add the arguments in the run_flags directive\n     args.push_all_move(split_maybe_args(&props.run_flags));\n \n     let prog = args.shift().unwrap();\n-    return ProcArgs {prog: prog, args: args};\n+    return ProcArgs {\n+        prog: prog,\n+        args: args,\n+    };\n }\n \n-fn split_maybe_args(argstr: &Option<~str>) -> Vec<~str> {\n+fn split_maybe_args(argstr: &Option<StrBuf>) -> Vec<StrBuf> {\n     match *argstr {\n         Some(ref s) => {\n-            s.split(' ')\n-                .filter_map(|s| if s.is_whitespace() {None} else {Some(s.to_owned())})\n-                .collect()\n+            s.as_slice()\n+             .split(' ')\n+             .filter_map(|s| {\n+                 if s.is_whitespace() {\n+                     None\n+                 } else {\n+                     Some(s.to_strbuf())\n+                 }\n+             }).collect()\n         }\n         None => Vec::new()\n     }\n }\n \n-fn program_output(config: &Config, testfile: &Path, lib_path: &str, prog: ~str,\n-                  args: Vec<~str> , env: Vec<(~str, ~str)> ,\n-                  input: Option<~str>) -> ProcRes {\n+fn program_output(config: &Config, testfile: &Path, lib_path: &str, prog: StrBuf,\n+                  args: Vec<StrBuf> , env: Vec<(StrBuf, StrBuf)> ,\n+                  input: Option<StrBuf>) -> ProcRes {\n     let cmdline =\n         {\n-            let cmdline = make_cmdline(lib_path, prog, args.as_slice());\n-            logv(config, format!(\"executing {}\", cmdline));\n+            let cmdline = make_cmdline(lib_path,\n+                                       prog.as_slice(),\n+                                       args.as_slice());\n+            logv(config, format_strbuf!(\"executing {}\", cmdline));\n             cmdline\n         };\n-    let procsrv::Result{ out, err, status } =\n-            procsrv::run(lib_path, prog, args.as_slice(), env, input)\n-            .expect(format!(\"failed to exec `{}`\", prog));\n-    dump_output(config, testfile, out, err);\n-    return ProcRes {status: status,\n-         stdout: out,\n-         stderr: err,\n-         cmdline: cmdline};\n+    let procsrv::Result {\n+        out,\n+        err,\n+        status\n+    } = procsrv::run(lib_path,\n+                     prog.as_slice(),\n+                     args.as_slice(),\n+                     env,\n+                     input).expect(format_strbuf!(\"failed to exec `{}`\",\n+                                                  prog));\n+    dump_output(config, testfile, out.as_slice(), err.as_slice());\n+    return ProcRes {\n+        status: status,\n+        stdout: out,\n+        stderr: err,\n+        cmdline: cmdline,\n+    };\n }\n \n // Linux and mac don't require adjusting the library search path\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn make_cmdline(_libpath: &str, prog: &str, args: &[~str]) -> ~str {\n-    format!(\"{} {}\", prog, args.connect(\" \"))\n+fn make_cmdline(_libpath: &str, prog: &str, args: &[StrBuf]) -> StrBuf {\n+    format_strbuf!(\"{} {}\", prog, args.connect(\" \"))\n }\n \n #[cfg(target_os = \"win32\")]\n-fn make_cmdline(libpath: &str, prog: &str, args: &[~str]) -> ~str {\n-    format!(\"{} {} {}\", lib_path_cmd_prefix(libpath), prog,\n-         args.connect(\" \"))\n+fn make_cmdline(libpath: &str, prog: &str, args: &[StrBuf]) -> StrBuf {\n+    format_strbuf!(\"{} {} {}\",\n+                   lib_path_cmd_prefix(libpath),\n+                   prog,\n+                   args.connect(\" \"))\n }\n \n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n // for diagnostic purposes\n #[cfg(target_os = \"win32\")]\n-fn lib_path_cmd_prefix(path: &str) -> ~str {\n-    format!(\"{}=\\\"{}\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n+fn lib_path_cmd_prefix(path: &str) -> StrBuf {\n+    format_strbuf!(\"{}=\\\"{}\\\"\",\n+                   util::lib_path_env_var(),\n+                   util::make_new_path(path))\n }\n \n fn dump_output(config: &Config, testfile: &Path, out: &str, err: &str) {\n@@ -1119,11 +1294,11 @@ fn maybe_dump_to_stdout(config: &Config, out: &str, err: &str) {\n     }\n }\n \n-fn error(err: ~str) { println!(\"\\nerror: {}\", err); }\n+fn error(err: StrBuf) { println!(\"\\nerror: {}\", err); }\n \n-fn fatal(err: ~str) -> ! { error(err); fail!(); }\n+fn fatal(err: StrBuf) -> ! { error(err); fail!(); }\n \n-fn fatal_ProcRes(err: ~str, proc_res: &ProcRes) -> ! {\n+fn fatal_ProcRes(err: StrBuf, proc_res: &ProcRes) -> ! {\n     print!(\"\\n\\\n error: {}\\n\\\n status: {}\\n\\\n@@ -1142,63 +1317,85 @@ stderr:\\n\\\n     fail!();\n }\n \n-fn _arm_exec_compiled_test(config: &Config, props: &TestProps,\n-                      testfile: &Path, env: Vec<(~str, ~str)> ) -> ProcRes {\n-\n+fn _arm_exec_compiled_test(config: &Config,\n+                           props: &TestProps,\n+                           testfile: &Path,\n+                           env: Vec<(StrBuf, StrBuf)>)\n+                           -> ProcRes {\n     let args = make_run_args(config, props, testfile);\n-    let cmdline = make_cmdline(\"\", args.prog, args.args.as_slice());\n+    let cmdline = make_cmdline(\"\",\n+                               args.prog.as_slice(),\n+                               args.args.as_slice());\n \n     // get bare program string\n-    let mut tvec: Vec<~str> = args.prog.split('/').map(|ts| ts.to_owned()).collect();\n+    let mut tvec: Vec<StrBuf> = args.prog\n+                                    .as_slice()\n+                                    .split('/')\n+                                    .map(|ts| ts.to_strbuf())\n+                                    .collect();\n     let prog_short = tvec.pop().unwrap();\n \n     // copy to target\n-    let copy_result = procsrv::run(\"\", config.adb_path,\n-        [\"push\".to_owned(), args.prog.clone(), config.adb_test_dir.clone()],\n-        vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n-        .expect(format!(\"failed to exec `{}`\", config.adb_path));\n+    let copy_result = procsrv::run(\"\",\n+                                   config.adb_path.as_slice(),\n+                                   [\n+                                    \"push\".to_strbuf(),\n+                                    args.prog.clone(),\n+                                    config.adb_test_dir.clone()\n+                                   ],\n+                                   vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n+                                   Some(\"\".to_strbuf()))\n+        .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n \n     if config.verbose {\n         println!(\"push ({}) {} {} {}\",\n-            config.target, args.prog,\n-            copy_result.out, copy_result.err);\n+                 config.target,\n+                 args.prog,\n+                 copy_result.out,\n+                 copy_result.err);\n     }\n \n-    logv(config, format!(\"executing ({}) {}\", config.target, cmdline));\n+    logv(config, format_strbuf!(\"executing ({}) {}\", config.target, cmdline));\n \n     let mut runargs = Vec::new();\n \n     // run test via adb_run_wrapper\n-    runargs.push(\"shell\".to_owned());\n+    runargs.push(\"shell\".to_strbuf());\n     for (key, val) in env.move_iter() {\n-        runargs.push(format!(\"{}={}\", key, val));\n+        runargs.push(format_strbuf!(\"{}={}\", key, val));\n     }\n-    runargs.push(format!(\"{}/adb_run_wrapper.sh\", config.adb_test_dir));\n-    runargs.push(format!(\"{}\", config.adb_test_dir));\n-    runargs.push(format!(\"{}\", prog_short));\n+    runargs.push(format_strbuf!(\"{}/adb_run_wrapper.sh\",\n+                                config.adb_test_dir));\n+    runargs.push(format_strbuf!(\"{}\", config.adb_test_dir));\n+    runargs.push(format_strbuf!(\"{}\", prog_short));\n \n     for tv in args.args.iter() {\n-        runargs.push(tv.to_owned());\n+        runargs.push(tv.to_strbuf());\n     }\n     procsrv::run(\"\",\n-                 config.adb_path,\n+                 config.adb_path.as_slice(),\n                  runargs.as_slice(),\n-                 vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n-        .expect(format!(\"failed to exec `{}`\", config.adb_path));\n+                 vec!((\"\".to_strbuf(), \"\".to_strbuf())), Some(\"\".to_strbuf()))\n+        .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n \n     // get exitcode of result\n     runargs = Vec::new();\n-    runargs.push(\"shell\".to_owned());\n-    runargs.push(\"cat\".to_owned());\n-    runargs.push(format!(\"{}/{}.exitcode\", config.adb_test_dir, prog_short));\n+    runargs.push(\"shell\".to_strbuf());\n+    runargs.push(\"cat\".to_strbuf());\n+    runargs.push(format_strbuf!(\"{}/{}.exitcode\",\n+                                config.adb_test_dir,\n+                                prog_short));\n \n     let procsrv::Result{ out: exitcode_out, err: _, status: _ } =\n-        procsrv::run(\"\", config.adb_path, runargs.as_slice(), vec!((\"\".to_owned(),\"\".to_owned())),\n-                     Some(\"\".to_owned()))\n-        .expect(format!(\"failed to exec `{}`\", config.adb_path));\n+        procsrv::run(\"\",\n+                     config.adb_path.as_slice(),\n+                     runargs.as_slice(),\n+                     vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n+                     Some(\"\".to_strbuf()))\n+        .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n \n-    let mut exitcode : int = 0;\n-    for c in exitcode_out.chars() {\n+    let mut exitcode: int = 0;\n+    for c in exitcode_out.as_slice().chars() {\n         if !c.is_digit() { break; }\n         exitcode = exitcode * 10 + match c {\n             '0' .. '9' => c as int - ('0' as int),\n@@ -1208,31 +1405,40 @@ fn _arm_exec_compiled_test(config: &Config, props: &TestProps,\n \n     // get stdout of result\n     runargs = Vec::new();\n-    runargs.push(\"shell\".to_owned());\n-    runargs.push(\"cat\".to_owned());\n-    runargs.push(format!(\"{}/{}.stdout\", config.adb_test_dir, prog_short));\n+    runargs.push(\"shell\".to_strbuf());\n+    runargs.push(\"cat\".to_strbuf());\n+    runargs.push(format_strbuf!(\"{}/{}.stdout\",\n+                                config.adb_test_dir,\n+                                prog_short));\n \n     let procsrv::Result{ out: stdout_out, err: _, status: _ } =\n         procsrv::run(\"\",\n-                     config.adb_path,\n+                     config.adb_path.as_slice(),\n                      runargs.as_slice(),\n-                     vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n-        .expect(format!(\"failed to exec `{}`\", config.adb_path));\n+                     vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n+                     Some(\"\".to_strbuf()))\n+        .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n \n     // get stderr of result\n     runargs = Vec::new();\n-    runargs.push(\"shell\".to_owned());\n-    runargs.push(\"cat\".to_owned());\n-    runargs.push(format!(\"{}/{}.stderr\", config.adb_test_dir, prog_short));\n+    runargs.push(\"shell\".to_strbuf());\n+    runargs.push(\"cat\".to_strbuf());\n+    runargs.push(format_strbuf!(\"{}/{}.stderr\",\n+                                config.adb_test_dir,\n+                                prog_short));\n \n     let procsrv::Result{ out: stderr_out, err: _, status: _ } =\n         procsrv::run(\"\",\n-                     config.adb_path,\n+                     config.adb_path.as_slice(),\n                      runargs.as_slice(),\n-                     vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n-        .expect(format!(\"failed to exec `{}`\", config.adb_path));\n+                     vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n+                     Some(\"\".to_strbuf()))\n+        .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n \n-    dump_output(config, testfile, stdout_out, stderr_out);\n+    dump_output(config,\n+                testfile,\n+                stdout_out.as_slice(),\n+                stderr_out.as_slice());\n \n     ProcRes {\n         status: process::ExitStatus(exitcode),\n@@ -1249,10 +1455,20 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n     for file in dirs.iter() {\n         if file.extension_str() == Some(\"so\") {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            let copy_result = procsrv::run(\"\", config.adb_path,\n-                [\"push\".to_owned(), file.as_str().unwrap().to_owned(), config.adb_test_dir.clone()],\n-                vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n-                .expect(format!(\"failed to exec `{}`\", config.adb_path));\n+            let copy_result = procsrv::run(\"\",\n+                                           config.adb_path.as_slice(),\n+                                           [\n+                                            \"push\".to_strbuf(),\n+                                            file.as_str()\n+                                                .unwrap()\n+                                                .to_strbuf(),\n+                                            config.adb_test_dir.to_strbuf()\n+                                           ],\n+                                           vec!((\"\".to_strbuf(),\n+                                                 \"\".to_strbuf())),\n+                                           Some(\"\".to_strbuf()))\n+                .expect(format_strbuf!(\"failed to exec `{}`\",\n+                                       config.adb_path));\n \n             if config.verbose {\n                 println!(\"push ({}) {} {} {}\",\n@@ -1282,9 +1498,12 @@ fn compile_test_and_save_bitcode(config: &Config, props: &TestProps,\n                                  testfile: &Path) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let link_args = vec!(\"-L\".to_owned(), aux_dir.as_str().unwrap().to_owned());\n-    let llvm_args = vec!(\"--emit=obj\".to_owned(), \"--crate-type=lib\".to_owned(),\n-                         \"-C\".to_owned(), \"save-temps\".to_owned());\n+    let link_args = vec!(\"-L\".to_strbuf(),\n+                         aux_dir.as_str().unwrap().to_strbuf());\n+    let llvm_args = vec!(\"--emit=obj\".to_strbuf(),\n+                         \"--crate-type=lib\".to_strbuf(),\n+                         \"-C\".to_strbuf(),\n+                         \"save-temps\".to_strbuf());\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args.append(llvm_args.as_slice()),\n@@ -1299,11 +1518,12 @@ fn compile_cc_with_clang_and_save_bitcode(config: &Config, _props: &TestProps,\n     let testcc = testfile.with_extension(\"cc\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prog: config.clang_path.get_ref().as_str().unwrap().to_owned(),\n-        args: vec!(\"-c\".to_owned(),\n-                \"-emit-llvm\".to_owned(),\n-                \"-o\".to_owned(), bitcodefile.as_str().unwrap().to_owned(),\n-                testcc.as_str().unwrap().to_owned() )\n+        prog: config.clang_path.get_ref().as_str().unwrap().to_strbuf(),\n+        args: vec!(\"-c\".to_strbuf(),\n+                   \"-emit-llvm\".to_strbuf(),\n+                   \"-o\".to_strbuf(),\n+                   bitcodefile.as_str().unwrap().to_strbuf(),\n+                   testcc.as_str().unwrap().to_strbuf())\n     };\n     compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n }\n@@ -1317,10 +1537,10 @@ fn extract_function_from_bitcode(config: &Config, _props: &TestProps,\n     let prog = config.llvm_bin_path.get_ref().join(\"llvm-extract\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prog: prog.as_str().unwrap().to_owned(),\n-        args: vec!(\"-func=\" + fname,\n-                \"-o=\" + extracted_bc.as_str().unwrap(),\n-                bitcodefile.as_str().unwrap().to_owned() )\n+        prog: prog.as_str().unwrap().to_strbuf(),\n+        args: vec!(format_strbuf!(\"-func={}\", fname),\n+                   format_strbuf!(\"-o={}\", extracted_bc.as_str().unwrap()),\n+                   bitcodefile.as_str().unwrap().to_strbuf())\n     };\n     compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n }\n@@ -1334,9 +1554,9 @@ fn disassemble_extract(config: &Config, _props: &TestProps,\n     let prog = config.llvm_bin_path.get_ref().join(\"llvm-dis\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prog: prog.as_str().unwrap().to_owned(),\n-        args: vec!(\"-o=\" + extracted_ll.as_str().unwrap(),\n-                extracted_bc.as_str().unwrap().to_owned() )\n+        prog: prog.as_str().unwrap().to_strbuf(),\n+        args: vec!(format_strbuf!(\"-o={}\", extracted_ll.as_str().unwrap()),\n+                   extracted_bc.as_str().unwrap().to_strbuf())\n     };\n     compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n }\n@@ -1353,42 +1573,44 @@ fn run_codegen_test(config: &Config, props: &TestProps,\n                     testfile: &Path, mm: &mut MetricMap) {\n \n     if config.llvm_bin_path.is_none() {\n-        fatal(\"missing --llvm-bin-path\".to_owned());\n+        fatal(\"missing --llvm-bin-path\".to_strbuf());\n     }\n \n     if config.clang_path.is_none() {\n-        fatal(\"missing --clang-path\".to_owned());\n+        fatal(\"missing --clang-path\".to_strbuf());\n     }\n \n     let mut proc_res = compile_test_and_save_bitcode(config, props, testfile);\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"compilation failed!\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"compilation failed!\".to_strbuf(), &proc_res);\n     }\n \n     proc_res = extract_function_from_bitcode(config, props, \"test\", testfile, \"\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"extracting 'test' function failed\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"extracting 'test' function failed\".to_strbuf(),\n+                      &proc_res);\n     }\n \n     proc_res = disassemble_extract(config, props, testfile, \"\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"disassembling extract failed\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"disassembling extract failed\".to_strbuf(), &proc_res);\n     }\n \n \n     let mut proc_res = compile_cc_with_clang_and_save_bitcode(config, props, testfile);\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"compilation failed!\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"compilation failed!\".to_strbuf(), &proc_res);\n     }\n \n     proc_res = extract_function_from_bitcode(config, props, \"test\", testfile, \"clang\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"extracting 'test' function failed\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"extracting 'test' function failed\".to_strbuf(),\n+                      &proc_res);\n     }\n \n     proc_res = disassemble_extract(config, props, testfile, \"clang\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"disassembling extract failed\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"disassembling extract failed\".to_strbuf(), &proc_res);\n     }\n \n     let base = output_base_name(config, testfile);"}, {"sha": "942541c79eee7661b8c927ef8e5c165c95a49e81", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bc758c94ae9c99b8e4e82f7d18b6733c8eb949/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=78bc758c94ae9c99b8e4e82f7d18b6733c8eb949", "patch": "@@ -33,25 +33,25 @@ pub fn get_os(triple: &str) -> &'static str {\n }\n \n #[cfg(target_os = \"win32\")]\n-pub fn make_new_path(path: &str) -> ~str {\n+pub fn make_new_path(path: &str) -> StrBuf {\n \n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n-    match getenv(lib_path_env_var()) {\n+    match getenv(lib_path_env_var().as_slice()) {\n       Some(curr) => {\n-        format!(\"{}{}{}\", path, path_div(), curr)\n+        format_strbuf!(\"{}{}{}\", path, path_div(), curr)\n       }\n-      None => path.to_str()\n+      None => path.to_str().to_strbuf()\n     }\n }\n \n #[cfg(target_os = \"win32\")]\n-pub fn lib_path_env_var() -> ~str { \"PATH\".to_owned() }\n+pub fn lib_path_env_var() -> StrBuf { \"PATH\".to_strbuf() }\n \n #[cfg(target_os = \"win32\")]\n-pub fn path_div() -> ~str { \";\".to_owned() }\n+pub fn path_div() -> StrBuf { \";\".to_strbuf() }\n \n-pub fn logv(config: &Config, s: ~str) {\n+pub fn logv(config: &Config, s: StrBuf) {\n     debug!(\"{}\", s);\n     if config.verbose { println!(\"{}\", s); }\n }"}]}