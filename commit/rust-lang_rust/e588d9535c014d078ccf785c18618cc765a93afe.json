{"sha": "e588d9535c014d078ccf785c18618cc765a93afe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ODhkOTUzNWMwMTRkMDc4Y2NmNzg1YzE4NjE4Y2M3NjVhOTNhZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-19T21:07:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-19T21:07:26Z"}, "message": "Auto merge of #693 - Aaron1011:feature/panic_unwind_final, r=oli-obk\n\nSupport unwinding after a panic\n\nFixes #658\n\nThis commit adds support for unwinding after a panic. It requires a\ncompanion rustc PR to be merged, in order for the necessary hooks to\nwork properly.\n\nCurrently implemented:\n* Selecting between unwind/abort mode based on the rustc Session\n* Properly popping off stack frames, unwinding back the caller\n* Running 'unwind' blocks in Mir terminators\n\nNot yet implemented:\n* 'Abort' terminators\n\nThis PR was getting fairly large, so I decided to open it for review without\nimplementing 'Abort' terminator support. This could either be added on\nto this PR, or merged separately.\n\nI've a test to exercise several different aspects of unwind panicking. Ideally, we would run Miri against the libstd panic tests, but I haven't yet figured out how to do that.\n\nThis depends on https://github.com/rust-lang/rust/pull/60026", "tree": {"sha": "8c95c3711eb171a8886f3ecb6a33400e13fe2c14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c95c3711eb171a8886f3ecb6a33400e13fe2c14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e588d9535c014d078ccf785c18618cc765a93afe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e588d9535c014d078ccf785c18618cc765a93afe", "html_url": "https://github.com/rust-lang/rust/commit/e588d9535c014d078ccf785c18618cc765a93afe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e588d9535c014d078ccf785c18618cc765a93afe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e13cba07beefefe7441ebdca6f454cca623b550", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e13cba07beefefe7441ebdca6f454cca623b550", "html_url": "https://github.com/rust-lang/rust/commit/9e13cba07beefefe7441ebdca6f454cca623b550"}, {"sha": "6fe89e45f44df216911de48958aed38965b0de1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fe89e45f44df216911de48958aed38965b0de1c", "html_url": "https://github.com/rust-lang/rust/commit/6fe89e45f44df216911de48958aed38965b0de1c"}], "stats": {"total": 557, "additions": 421, "deletions": 136}, "files": [{"sha": "093065aab2c0af6e4b2ec11c1c2320058fe2bfdd", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -1 +1 @@\n-8831d766ace89bc74714918a7d9fbd3ca5ec946a\n+3e525e3f6d9e85d54fa4c49b52df85aa0c990100"}, {"sha": "7203ba6bf1db95404d6de079850302a42c0c70a3", "filename": "src/eval.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -39,10 +39,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n         Evaluator::new(config.communicate),\n-        MemoryExtra::new(\n-            StdRng::seed_from_u64(config.seed.unwrap_or(0)),\n-            config.validate,\n-        ),\n+        MemoryExtra::new(StdRng::seed_from_u64(config.seed.unwrap_or(0)), config.validate),\n     );\n     // Complete initialization.\n     EnvVars::init(&mut ecx, config.excluded_env_vars);"}, {"sha": "20f21cfc255c70d8131d6e9070b5e52bee10d6d3", "filename": "src/helpers.rs", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -6,6 +6,7 @@ use rustc::mir;\n use rustc::ty::{\n     self,\n     List,\n+    TyCtxt,\n     layout::{self, LayoutOf, Size, TyLayout},\n };\n \n@@ -15,40 +16,46 @@ use crate::*;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n \n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    /// Gets an instance for a path.\n-    fn resolve_path(&self, path: &[&str]) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n-        let this = self.eval_context_ref();\n-        this.tcx\n-            .crates()\n-            .iter()\n-            .find(|&&krate| this.tcx.original_crate_name(krate).as_str() == path[0])\n-            .and_then(|krate| {\n-                let krate = DefId {\n-                    krate: *krate,\n-                    index: CRATE_DEF_INDEX,\n-                };\n-                let mut items = this.tcx.item_children(krate);\n-                let mut path_it = path.iter().skip(1).peekable();\n-\n-                while let Some(segment) = path_it.next() {\n-                    for item in mem::replace(&mut items, Default::default()).iter() {\n-                        if item.ident.name.as_str() == *segment {\n-                            if path_it.peek().is_none() {\n-                                return Some(ty::Instance::mono(this.tcx.tcx, item.res.def_id()));\n-                            }\n-\n-                            items = this.tcx.item_children(item.res.def_id());\n-                            break;\n+/// Gets an instance for a path.\n+fn resolve_did<'mir, 'tcx>(tcx: TyCtxt<'tcx>, path: &[&str]) -> InterpResult<'tcx, DefId> {\n+    tcx\n+        .crates()\n+        .iter()\n+        .find(|&&krate| tcx.original_crate_name(krate).as_str() == path[0])\n+        .and_then(|krate| {\n+            let krate = DefId {\n+                krate: *krate,\n+                index: CRATE_DEF_INDEX,\n+            };\n+            let mut items = tcx.item_children(krate);\n+            let mut path_it = path.iter().skip(1).peekable();\n+\n+            while let Some(segment) = path_it.next() {\n+                for item in mem::replace(&mut items, Default::default()).iter() {\n+                    if item.ident.name.as_str() == *segment {\n+                        if path_it.peek().is_none() {\n+                            return Some(item.res.def_id())\n                         }\n+\n+                        items = tcx.item_children(item.res.def_id());\n+                        break;\n                     }\n                 }\n-                None\n-            })\n-            .ok_or_else(|| {\n-                let path = path.iter().map(|&s| s.to_owned()).collect();\n-                err_unsup!(PathNotFound(path)).into()\n-            })\n+            }\n+            None\n+        })\n+        .ok_or_else(|| {\n+            let path = path.iter().map(|&s| s.to_owned()).collect();\n+            err_unsup!(PathNotFound(path)).into()\n+        })\n+}\n+\n+\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+\n+    /// Gets an instance for a path.\n+    fn resolve_path(&self, path: &[&str]) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n+        Ok(ty::Instance::mono(self.eval_context_ref().tcx.tcx, resolve_did(self.eval_context_ref().tcx.tcx, path)?))\n     }\n \n     /// Write a 0 of the appropriate size to `dest`."}, {"sha": "f29ec8f22bbaea993960dabde730410e4a5e052e", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -37,6 +37,7 @@ pub use crate::shims::time::{EvalContextExt as TimeEvalContextExt};\n pub use crate::shims::dlsym::{Dlsym, EvalContextExt as DlsymEvalContextExt};\n pub use crate::shims::env::{EnvVars, EvalContextExt as EnvEvalContextExt};\n pub use crate::shims::fs::{FileHandler, EvalContextExt as FileEvalContextExt};\n+pub use crate::shims::panic::{CatchUnwindData, EvalContextExt as PanicEvalContextExt};\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::helpers::{EvalContextExt as HelpersEvalContextExt};"}, {"sha": "cb658170357167566b24a59feabbff02a0e0a7fe", "filename": "src/machine.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -8,12 +8,8 @@ use std::rc::Rc;\n use rand::rngs::StdRng;\n \n use rustc::hir::def_id::DefId;\n+use rustc::ty::{self, layout::{Size, LayoutOf}, Ty, TyCtxt};\n use rustc::mir;\n-use rustc::ty::{\n-    self,\n-    layout::{LayoutOf, Size},\n-    Ty, TyCtxt,\n-};\n use syntax::{attr, source_map::Span, symbol::sym};\n \n use crate::*;\n@@ -24,6 +20,20 @@ pub const STACK_ADDR: u64 = 32 * PAGE_SIZE; // not really about the \"stack\", but\n pub const STACK_SIZE: u64 = 16 * PAGE_SIZE; // whatever\n pub const NUM_CPUS: u64 = 1;\n \n+/// Extra data stored with each stack frame\n+#[derive(Debug)]\n+pub struct FrameData<'tcx> {\n+    /// Extra data for Stacked Borrows.\n+    pub call_id: stacked_borrows::CallId,\n+\n+    /// If this is Some(), then this is a special \"catch unwind\" frame (the frame of the closure\n+    /// called by `__rustc_maybe_catch_panic`). When this frame is popped during unwinding a panic,\n+    /// we stop unwinding, use the `CatchUnwindData` to\n+    /// store the panic payload, and continue execution in the parent frame.\n+    pub catch_panic: Option<CatchUnwindData<'tcx>>,\n+}\n+\n+\n /// Extra memory kinds\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum MiriMemoryKind {\n@@ -101,6 +111,10 @@ pub struct Evaluator<'tcx> {\n     pub(crate) communicate: bool,\n \n     pub(crate) file_handler: FileHandler,\n+\n+    /// The temporary used for storing the argument of\n+    /// the call to `miri_start_panic` (the panic payload) when unwinding.\n+    pub(crate) panic_payload: Option<ImmTy<'tcx, Tag>>\n }\n \n impl<'tcx> Evaluator<'tcx> {\n@@ -116,6 +130,7 @@ impl<'tcx> Evaluator<'tcx> {\n             tls: TlsData::default(),\n             communicate,\n             file_handler: Default::default(),\n+            panic_payload: None\n         }\n     }\n }\n@@ -143,7 +158,7 @@ impl<'mir, 'tcx> MiriEvalContextExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx>\n impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     type MemoryKinds = MiriMemoryKind;\n \n-    type FrameExtra = stacked_borrows::CallId;\n+    type FrameExtra = FrameData<'tcx>;\n     type MemoryExtra = MemoryExtra;\n     type AllocExtra = AllocExtra;\n     type PointerTag = Tag;\n@@ -173,9 +188,9 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         args: &[OpTy<'tcx, Tag>],\n         dest: Option<PlaceTy<'tcx, Tag>>,\n         ret: Option<mir::BasicBlock>,\n-        _unwind: Option<mir::BasicBlock>,\n+        unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n-        ecx.find_fn(instance, args, dest, ret)\n+        ecx.find_fn(instance, args, dest, ret, unwind)\n     }\n \n     #[inline(always)]\n@@ -196,14 +211,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n         dest: Option<PlaceTy<'tcx, Tag>>,\n-        _ret: Option<mir::BasicBlock>,\n-        _unwind: Option<mir::BasicBlock>\n+        ret: Option<mir::BasicBlock>,\n+        unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n-        let dest = match dest {\n-            Some(dest) => dest,\n-            None => throw_ub!(Unreachable)\n-        };\n-        ecx.call_intrinsic(span, instance, args, dest)\n+        ecx.call_intrinsic(span, instance, args, dest, ret, unwind)\n     }\n \n     #[inline(always)]\n@@ -352,23 +363,20 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     #[inline(always)]\n     fn stack_push(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-    ) -> InterpResult<'tcx, stacked_borrows::CallId> {\n-        Ok(ecx.memory.extra.stacked_borrows.borrow_mut().new_call())\n+    ) -> InterpResult<'tcx, FrameData<'tcx>> {\n+        Ok(FrameData {\n+            call_id: ecx.memory.extra.stacked_borrows.borrow_mut().new_call(),\n+            catch_panic: None,\n+        })\n     }\n \n     #[inline(always)]\n     fn stack_pop(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        extra: stacked_borrows::CallId,\n-        _unwinding: bool\n+        extra: FrameData<'tcx>,\n+        unwinding: bool\n     ) -> InterpResult<'tcx, StackPopInfo> {\n-        ecx\n-            .memory\n-            .extra\n-            .stacked_borrows\n-            .borrow_mut()\n-            .end_call(extra);\n-        Ok(StackPopInfo::Normal)\n+        ecx.handle_stack_pop(extra, unwinding)\n     }\n \n     #[inline(always)]"}, {"sha": "48d98141b8ad3a3b63546b44849bcce8ae581595", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 28, "deletions": 47, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -1,9 +1,10 @@\n use std::{iter, convert::TryInto};\n \n-use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc::ty::layout::{Align, LayoutOf, Size};\n+use rustc::hir::def_id::DefId;\n use rustc_apfloat::Float;\n+use rustc::ty;\n use syntax::attr;\n use syntax::symbol::sym;\n \n@@ -105,13 +106,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     /// Emulates calling a foreign item, failing if the item is not supported.\n     /// This function will handle `goto_block` if needed.\n+    /// Returns Ok(None) if the foreign item was completely handled\n+    /// by this function.\n+    /// Returns Ok(Some(body)) if processing the foreign item\n+    /// is delegated to another function.\n     fn emulate_foreign_item(\n         &mut self,\n         def_id: DefId,\n         args: &[OpTy<'tcx, Tag>],\n         dest: Option<PlaceTy<'tcx, Tag>>,\n         ret: Option<mir::BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n+        _unwind: Option<mir::BasicBlock>\n+    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         let this = self.eval_context_mut();\n         let attrs = this.tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n@@ -124,9 +130,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // First: functions that diverge.\n         match link_name {\n-            \"__rust_start_panic\" | \"panic_impl\" => {\n-                throw_unsup_format!(\"the evaluated program panicked\");\n+            // Note that this matches calls to the *foreign* item `__rust_start_panic* -\n+            // that is, calls to `extern \"Rust\" { fn __rust_start_panic(...) }`.\n+            // We forward this to the underlying *implementation* in the panic runtime crate.\n+            // Normally, this will be either `libpanic_unwind` or `libpanic_abort`, but it could\n+            // also be a custom user-provided implementation via `#![feature(panic_runtime)]`\n+            \"__rust_start_panic\" => {\n+                let panic_runtime = tcx.crate_name(tcx.injected_panic_runtime().expect(\"No panic runtime found!\"));\n+                let start_panic_instance = this.resolve_path(&[&*panic_runtime.as_str(), \"__rust_start_panic\"])?;\n+                return Ok(Some(this.load_mir(start_panic_instance.def, None)?));\n+            }\n+            // Similarly, we forward calls to the `panic_impl` foreign item to its implementation.\n+            // The implementation is provided by the function with the `#[panic_handler]` attribute.\n+            \"panic_impl\" => {\n+                let panic_impl_id = this.tcx.lang_items().panic_impl().unwrap();\n+                let panic_impl_instance = ty::Instance::mono(*this.tcx, panic_impl_id);\n+                return Ok(Some(this.load_mir(panic_impl_instance.def, None)?));\n             }\n+\n             \"exit\" | \"ExitProcess\" => {\n                 // it's really u32 for ExitProcess, but we have to put it into the `Exit` error variant anyway\n                 let code = this.read_scalar(args[0])?.to_i32()?;\n@@ -310,48 +331,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"__rust_maybe_catch_panic\" => {\n-                // fn __rust_maybe_catch_panic(\n-                //     f: fn(*mut u8),\n-                //     data: *mut u8,\n-                //     data_ptr: *mut usize,\n-                //     vtable_ptr: *mut usize,\n-                // ) -> u32\n-                // We abort on panic, so not much is going on here, but we still have to call the closure.\n-                let f = this.read_scalar(args[0])?.not_undef()?;\n-                let data = this.read_scalar(args[1])?.not_undef()?;\n-                let f_instance = this.memory.get_fn(f)?.as_instance()?;\n-                this.write_null(dest)?;\n-                trace!(\"__rust_maybe_catch_panic: {:?}\", f_instance);\n-\n-                // Now we make a function call.\n-                // TODO: consider making this reusable? `InterpCx::step` does something similar\n-                // for the TLS destructors, and of course `eval_main`.\n-                let mir = this.load_mir(f_instance.def, None)?;\n-                let ret_place =\n-                    MPlaceTy::dangling(this.layout_of(tcx.mk_unit())?, this).into();\n-                this.push_stack_frame(\n-                    f_instance,\n-                    mir.span,\n-                    mir,\n-                    Some(ret_place),\n-                    // Directly return to caller.\n-                    StackPopCleanup::Goto { ret: Some(ret), unwind: None },\n-                )?;\n-                let mut args = this.frame().body.args_iter();\n-\n-                let arg_local = args\n-                    .next()\n-                    .expect(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\");\n-                let arg_dest = this.local_place(arg_local)?;\n-                this.write_scalar(data, arg_dest)?;\n-\n-                args.next().expect_none(\"__rust_maybe_catch_panic argument has more arguments than expected\");\n-\n-                // We ourselves will return `0`, eventually (because we will not return if we paniced).\n-                this.write_null(dest)?;\n-\n-                // Don't fall through, we do *not* want to `goto_block`!\n-                return Ok(());\n+                this.handle_catch_panic(args, dest, ret)?;\n+                return Ok(None)\n             }\n \n             \"memcmp\" => {\n@@ -943,7 +924,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.goto_block(Some(ret))?;\n         this.dump_place(*dest);\n-        Ok(())\n+        Ok(None)\n     }\n \n     /// Evaluates the scalar at the specified path. Returns Some(val)"}, {"sha": "5e1f3cff1c77cecaf358efb10221009eb2c227e1", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -7,10 +7,7 @@ use rustc::ty::layout::{self, LayoutOf, Size, Align};\n use rustc::ty;\n use syntax::source_map::Span;\n \n-use crate::{\n-    PlaceTy, OpTy, Immediate, Scalar, Tag,\n-    OperatorEvalContextExt\n-};\n+use crate::*;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n@@ -19,10 +16,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n-        dest: PlaceTy<'tcx, Tag>,\n+        dest: Option<PlaceTy<'tcx, Tag>>,\n+        _ret: Option<mir::BasicBlock>,\n+        unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        if this.emulate_intrinsic(span, instance, args, Some(dest))? {\n+        if this.emulate_intrinsic(span, instance, args, dest)? {\n             return Ok(());\n         }\n         let tcx = &{this.tcx.tcx};\n@@ -31,8 +30,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // All these intrinsics take raw pointers, so if we access memory directly\n         // (as opposed to through a place), we have to remember to erase any tag\n         // that might still hang around!\n-\n         let intrinsic_name = &*tcx.item_name(instance.def_id()).as_str();\n+\n+        // Handle diverging intrinsics\n+        match intrinsic_name {\n+            \"abort\" => {\n+                // FIXME: Add a better way of indicating 'abnormal' termination,\n+                // since this is not really an 'unsupported' behavior\n+                throw_unsup_format!(\"the evaluated program aborted!\");\n+            }\n+            \"miri_start_panic\" => return this.handle_miri_start_panic(args, unwind),\n+            _ => {}\n+        }\n+\n+        // Handle non-diverging intrinsics\n+        // The intrinsic itself cannot diverge (otherwise, we would have handled it above),\n+        // so if we got here without a return place that's UB (can happen e.g., for transmute returning `!`).\n+        let dest = match dest {\n+            Some(dest) => dest,\n+            None => throw_ub!(Unreachable)\n+        };\n+\n         match intrinsic_name {\n             \"arith_offset\" => {\n                 let offset = this.read_scalar(args[1])?.to_machine_isize(this)?;\n@@ -526,7 +544,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // However, this only affects direct calls of the intrinsic; calls to the stable\n                 // functions wrapping them do get their validation.\n                 // FIXME: should we check alignment for ZSTs?\n-                use crate::ScalarMaybeUndef;\n                 if !dest.layout.is_zst() {\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(..) => {"}, {"sha": "f554c19f11c2708dbfb7c5164844ed4d1043167b", "filename": "src/shims/mod.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -5,9 +5,9 @@ pub mod intrinsics;\n pub mod tls;\n pub mod fs;\n pub mod time;\n+pub mod panic;\n \n use rustc::{mir, ty};\n-\n use crate::*;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -18,6 +18,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         args: &[OpTy<'tcx, Tag>],\n         dest: Option<PlaceTy<'tcx, Tag>>,\n         ret: Option<mir::BasicBlock>,\n+        unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         let this = self.eval_context_mut();\n         trace!(\n@@ -26,11 +27,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             dest.map(|place| *place)\n         );\n \n-        // First, run the common hooks also supported by CTFE.\n-        if this.hook_panic_fn(instance, args, dest)? {\n-            this.goto_block(ret)?;\n-            return Ok(None);\n-        }\n         // There are some more lang items we want to hook that CTFE does not hook (yet).\n         if this.tcx.lang_items().align_offset_fn() == Some(instance.def.def_id()) {\n             let dest = dest.unwrap();\n@@ -44,11 +40,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Try to see if we can do something about foreign items.\n         if this.tcx.is_foreign_item(instance.def_id()) {\n-            // An external function that we cannot find MIR for, but we can still run enough\n-            // of them to make miri viable.\n-            this.emulate_foreign_item(instance.def_id(), args, dest, ret)?;\n-            // `goto_block` already handled.\n-            return Ok(None);\n+            // An external function call that does not have a MIR body. We either find MIR elsewhere\n+            // or emulate its effect.\n+            // This will be Ok(None) if we're emulating the intrinsic entirely within Miri (no need\n+            // to run extra MIR), and Ok(Some(body)) if we found MIR to run for the\n+            // foreign function\n+            // Any needed call to `goto_block` will be performed by `emulate_foreign_item`.\n+            return this.emulate_foreign_item(instance.def_id(), args, dest, ret, unwind);\n         }\n \n         // Otherwise, load the MIR."}, {"sha": "59ff1a870d105b3a671ec791b116b2a1a99b9c1f", "filename": "src/shims/panic.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -0,0 +1,173 @@\n+//! Panic runtime for Miri.\n+//!\n+//! The core pieces of the runtime are:\n+//! - An implementation of `__rust_maybe_catch_panic` that pushes the invoked stack frame with\n+//!   some extra metadata derived from the panic-catching arguments of `__rust_maybe_catch_panic`.\n+//! - A hack in `libpanic_unwind` that calls the `miri_start_panic` intrinsic instead of the\n+//!   target-native panic runtime. (This lives in the rustc repo.)\n+//! - An implementation of `miri_start_panic` that stores its argument (the panic payload), and then\n+//!   immediately returns, but on the *unwind* edge (not the normal return edge), thus initiating unwinding.\n+//! - A hook executed each time a frame is popped, such that if the frame pushed by `__rust_maybe_catch_panic`\n+//!   gets popped *during unwinding*, we take the panic payload and store it according to the extra\n+//!   metadata we remembered when pushing said frame.\n+\n+use rustc::mir;\n+use crate::*;\n+use super::machine::FrameData;\n+use rustc_target::spec::PanicStrategy;\n+use crate::rustc_target::abi::LayoutOf;\n+\n+/// Holds all of the relevant data for a call to\n+/// `__rust_maybe_catch_panic`.\n+///\n+/// If a panic occurs, we update this data with\n+/// the information from the panic site.\n+#[derive(Debug)]\n+pub struct CatchUnwindData<'tcx> {\n+    /// The dereferenced `data_ptr` argument passed to `__rust_maybe_catch_panic`.\n+    pub data_place: MPlaceTy<'tcx, Tag>,\n+    /// The dereferenced `vtable_ptr` argument passed to `__rust_maybe_catch_panic`.\n+    pub vtable_place: MPlaceTy<'tcx, Tag>,\n+    /// The `dest` from the original call to `__rust_maybe_catch_panic`.\n+    pub dest: PlaceTy<'tcx, Tag>,\n+}\n+\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+\n+    /// Handles the special \"miri_start_panic\" intrinsic, which is called\n+    /// by libpanic_unwind to delegate the actual unwinding process to Miri.\n+    #[inline(always)]\n+    fn handle_miri_start_panic(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        unwind: Option<mir::BasicBlock>\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        trace!(\"miri_start_panic: {:?}\", this.frame().span);\n+\n+        // Get the raw pointer stored in arg[0] (the panic payload).\n+        let scalar = this.read_immediate(args[0])?;\n+        assert!(this.machine.panic_payload.is_none(), \"the panic runtime should avoid double-panics\");\n+        this.machine.panic_payload = Some(scalar);\n+\n+        // Jump to the unwind block to begin unwinding.\n+        // We don't use `goto_block` as that is just meant for normal returns.\n+        let next_frame = this.frame_mut();\n+        next_frame.block = unwind;\n+        next_frame.stmt = 0;\n+        return Ok(())\n+    }\n+\n+    #[inline(always)]\n+    fn handle_catch_panic(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: PlaceTy<'tcx, Tag>,\n+        ret: mir::BasicBlock,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let tcx = &{this.tcx.tcx};\n+\n+        // fn __rust_maybe_catch_panic(\n+        //     f: fn(*mut u8),\n+        //     data: *mut u8,\n+        //     data_ptr: *mut usize,\n+        //     vtable_ptr: *mut usize,\n+        // ) -> u32\n+\n+        // Get all the arguments.\n+        let f = this.read_scalar(args[0])?.not_undef()?;\n+        let f_arg = this.read_scalar(args[1])?.not_undef()?;\n+        let data_place = this.deref_operand(args[2])?;\n+        let vtable_place = this.deref_operand(args[3])?;\n+\n+        // Now we make a function call, and pass `f_arg` as first and only argument.\n+        let f_instance = this.memory.get_fn(f)?.as_instance()?;\n+        trace!(\"__rust_maybe_catch_panic: {:?}\", f_instance);\n+        // TODO: consider making this reusable? `InterpCx::step` does something similar\n+        // for the TLS destructors, and of course `eval_main`.\n+        let mir = this.load_mir(f_instance.def, None)?;\n+        let ret_place =\n+            MPlaceTy::dangling(this.layout_of(tcx.mk_unit())?, this).into();\n+        this.push_stack_frame(\n+            f_instance,\n+            mir.span,\n+            mir,\n+            Some(ret_place),\n+            // Directly return to caller.\n+            StackPopCleanup::Goto { ret: Some(ret), unwind: None },\n+        )?;\n+\n+        let mut args = this.frame().body.args_iter();\n+        // First argument.\n+        let arg_local = args\n+            .next()\n+            .expect(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\");\n+        let arg_dest = this.local_place(arg_local)?;\n+        this.write_scalar(f_arg, arg_dest)?;\n+        // No more arguments.\n+        args.next().expect_none(\"__rust_maybe_catch_panic argument has more arguments than expected\");\n+\n+        // We ourselves will return `0`, eventually (will be overwritten if we catch a panic).\n+        this.write_null(dest)?;\n+\n+        // In unwind mode, we tag this frame with some extra data.\n+        // This lets `handle_stack_pop` (below) know that we should stop unwinding\n+        // when we pop this frame.\n+        if this.tcx.tcx.sess.panic_strategy() == PanicStrategy::Unwind {\n+            this.frame_mut().extra.catch_panic = Some(CatchUnwindData {\n+                data_place,\n+                vtable_place,\n+                dest,\n+            })\n+        }\n+\n+        return Ok(());\n+    }\n+\n+    #[inline(always)]\n+    fn handle_stack_pop(\n+        &mut self,\n+        mut extra: FrameData<'tcx>,\n+        unwinding: bool\n+    ) -> InterpResult<'tcx, StackPopInfo> {\n+        let this = self.eval_context_mut();\n+\n+        trace!(\"handle_stack_pop(extra = {:?}, unwinding = {})\", extra, unwinding);\n+\n+        // We only care about `catch_panic` if we're unwinding - if we're doing a normal\n+        // return, then we don't need to do anything special.\n+        let res = if let (true, Some(unwind_data)) = (unwinding, extra.catch_panic.take()) {\n+            // We've just popped a frame that was pushed by `__rust_maybe_catch_panic`,\n+            // and we are unwinding, so we should catch that.\n+            trace!(\"unwinding: found catch_panic frame during unwinding: {:?}\", this.frame().span);\n+\n+            // `panic_payload` now holds a `*mut (dyn Any + Send)`,\n+            // provided by the `miri_start_panic` intrinsic.\n+            // We want to split this into its consituient parts -\n+            // the data and vtable pointers - and store them according to\n+            // `unwind_data`, i.e., we store them where `__rust_maybe_catch_panic`\n+            // was told to put them.\n+            let payload = this.machine.panic_payload.take().unwrap();\n+            let payload = this.ref_to_mplace(payload)?;\n+            let payload_data_place = payload.ptr;\n+            let payload_vtable_place = payload.meta.expect(\"Expected fat pointer\");\n+\n+            this.write_scalar(payload_data_place, unwind_data.data_place.into())?;\n+            this.write_scalar(payload_vtable_place, unwind_data.vtable_place.into())?;\n+\n+            // We set the return value of `__rust_maybe_catch_panic` to 1,\n+            // since there was a panic.\n+            let dest = unwind_data.dest;\n+            this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n+\n+            StackPopInfo::StopUnwinding\n+        } else {\n+            StackPopInfo::Normal\n+        };\n+        this.memory.extra.stacked_borrows.borrow_mut().end_call(extra.call_id);\n+        Ok(res)\n+    }\n+}"}, {"sha": "3b821c7155a6f0c0d4ea78fd4afc8839595b4123", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -532,7 +532,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         protect: bool,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let protector = if protect { Some(this.frame().extra) } else { None };\n+        let protector = if protect { Some(this.frame().extra.call_id) } else { None };\n         let ptr = place.ptr.to_ptr().expect(\"we should have a proper pointer\");\n         trace!(\"reborrow: {} reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n             kind, new_tag, ptr.tag, place.layout.ty, ptr.erase_tag(), size.bytes());"}, {"sha": "827e2f93237bc861f0d1120d0bfa452db3e5a75b", "filename": "test-cargo-miri/test.stdout.ref", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/test-cargo-miri%2Ftest.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/test-cargo-miri%2Ftest.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stdout.ref?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -5,11 +5,12 @@ test test::rng ... ok\n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n \n \n-running 4 tests\n+running 5 tests\n+test do_panic ... ok\n test entropy_rng ... ok\n test num_cpus ... ok\n test simple1 ... ok\n test simple2 ... ok\n \n-test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n "}, {"sha": "e070941c36ec8dc4af1cc1480297a4039ea48641", "filename": "test-cargo-miri/test.stdout.ref2", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/test-cargo-miri%2Ftest.stdout.ref2", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/test-cargo-miri%2Ftest.stdout.ref2", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stdout.ref2?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -7,5 +7,5 @@ test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out\n running 1 test\n test simple1 ... ok\n \n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 3 filtered out\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 4 filtered out\n "}, {"sha": "a4a1a7812aea86832eaa4d0143b7466f4e2dc391", "filename": "test-cargo-miri/test.stdout.ref3", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/test-cargo-miri%2Ftest.stdout.ref3", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/test-cargo-miri%2Ftest.stdout.ref3", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stdout.ref3?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -7,5 +7,5 @@ test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out\n running 1 test\n test num_cpus ... ok\n \n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 3 filtered out\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 4 filtered out\n "}, {"sha": "5d1beaec9806ff1ff421ecff7abe2267b0f07103", "filename": "test-cargo-miri/tests/test.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/test-cargo-miri%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/test-cargo-miri%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftests%2Ftest.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -41,3 +41,14 @@ fn entropy_rng() {\n fn num_cpus() {\n     assert_eq!(num_cpus::get(), 1);\n }\n+\n+\n+// FIXME: Remove this `cfg` once we fix https://github.com/rust-lang/miri/issues/1059\n+// We cfg-gate the `should_panic` attribute and the `panic!` itself, so that the test\n+// stdout does not depend on the platform\n+#[test]\n+#[cfg_attr(not(windows), should_panic)]\n+fn do_panic() { // In large, friendly letters :)\n+    #[cfg(not(windows))]\n+    panic!(\"Explicit panic from test!\");\n+}"}, {"sha": "950d865c2a5624712e68ed6bc6ea683b00c28b96", "filename": "tests/compile-fail/double_panic.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Fcompile-fail%2Fdouble_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Fcompile-fail%2Fdouble_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdouble_panic.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -0,0 +1,11 @@\n+ //error-pattern: the evaluated program aborted\n+struct Foo;\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        panic!(\"second\");\n+    }\n+}\n+fn main() {\n+    let _foo = Foo;\n+    panic!(\"first\"); \n+}"}, {"sha": "4a1bb11483ca77e62ae76ff5d5fe2ac9958ee9d3", "filename": "tests/compile-fail/panic1.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Fcompile-fail%2Fpanic1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Fcompile-fail%2Fpanic1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic1.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -1,5 +1,6 @@\n-//error-pattern: the evaluated program panicked\n-\n+// ignore-test: Abort panics are not yet supported\n+// error-pattern: the evaluated program panicked\n+// compile-flags: -C panic=abort\n fn main() {\n     std::panic!(\"panicking from libstd\");\n }"}, {"sha": "ce4471c0effc2e14970af24c934425d0b9c19e64", "filename": "tests/compile-fail/panic2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Fcompile-fail%2Fpanic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Fcompile-fail%2Fpanic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic2.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -1,4 +1,6 @@\n-//error-pattern: the evaluated program panicked\n+// ignore-test: Abort panics are not yet supported\n+// error-pattern: the evaluated program panicked\n+// compile-flags: -C panic=abort\n \n fn main() {\n     std::panic!(\"{}-panicking from libstd\", 42);"}, {"sha": "842a0f5435b7442f979d2d2bfd84ea03bc80822a", "filename": "tests/compile-fail/panic3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Fcompile-fail%2Fpanic3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Fcompile-fail%2Fpanic3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic3.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -1,4 +1,6 @@\n+// ignore-test: Abort panics are not yet supported\n //error-pattern: the evaluated program panicked\n+// compile-flags: -C panic=abort\n \n fn main() {\n     core::panic!(\"panicking from libcore\");"}, {"sha": "816cc90cfabd8583df55086b0c06e96631ff4435", "filename": "tests/compile-fail/panic4.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Fcompile-fail%2Fpanic4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Fcompile-fail%2Fpanic4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic4.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -1,4 +1,6 @@\n+// ignore-test: Abort panics are not yet supported\n //error-pattern: the evaluated program panicked\n+// compile-flags: -C panic=abort\n \n fn main() {\n     core::panic!(\"{}-panicking from libcore\", 42);"}, {"sha": "228317e893695505dd95293ce5fa475d004cd08e", "filename": "tests/run-pass/catch_panic.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Frun-pass%2Fcatch_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Frun-pass%2Fcatch_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcatch_panic.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -0,0 +1,62 @@\n+// ignore-windows: Unwind panicking does not currently work on Windows\n+use std::panic::catch_unwind;\n+use std::cell::Cell;\n+\n+thread_local! {\n+    static MY_COUNTER: Cell<usize> = Cell::new(0);\n+    static DROPPED: Cell<bool> = Cell::new(false);\n+    static HOOK_CALLED: Cell<bool> = Cell::new(false);\n+}\n+\n+struct DropTester;\n+\n+impl Drop for DropTester {\n+    fn drop(&mut self) {\n+        DROPPED.with(|c| {\n+            c.set(true);\n+        });\n+    }\n+}\n+\n+fn do_panic_counter() {\n+    // If this gets leaked, it will be easy to spot\n+    // in Miri's leak report\n+    let _string = \"LEAKED FROM do_panic_counter\".to_string();\n+\n+    // When we panic, this should get dropped during unwinding\n+    let _drop_tester = DropTester;\n+\n+    // Check for bugs in Miri's panic implementation.\n+    // If do_panic_counter() somehow gets called more than once,\n+    // we'll generate a different panic message\n+    let old_val = MY_COUNTER.with(|c| {\n+        let val = c.get();\n+        c.set(val + 1);\n+        val\n+    });\n+    panic!(format!(\"Hello from panic: {:?}\", old_val));\n+}\n+\n+fn main() {\n+    std::panic::set_hook(Box::new(|_panic_info| {\n+        HOOK_CALLED.with(|h| h.set(true));\n+    }));\n+    let res = catch_unwind(|| {\n+        let _string = \"LEAKED FROM CLOSURE\".to_string();\n+        do_panic_counter()\n+    });\n+    let expected: Box<String> = Box::new(\"Hello from panic: 0\".to_string());\n+    let actual = res.expect_err(\"do_panic() did not panic!\")\n+        .downcast::<String>().expect(\"Failed to cast to string!\");\n+        \n+    assert_eq!(expected, actual);\n+    DROPPED.with(|c| {\n+        // This should have been set to 'true' by DropTester\n+        assert!(c.get());\n+    });\n+\n+    HOOK_CALLED.with(|h| {\n+        assert!(h.get());\n+    });\n+}\n+"}, {"sha": "261db018d6da065c25b024adb9d8dfcb37b99c1a", "filename": "tests/run-pass/panic1.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Frun-pass%2Fpanic1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Frun-pass%2Fpanic1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic1.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -0,0 +1,4 @@\n+// ignore-windows: Unwind panicking does not currently work on Windows\n+fn main() {\n+    panic!(\"Miri panic!\");\n+}"}, {"sha": "b1607dd864fb856d40d89a1d833f335c54e3d3c3", "filename": "tests/run-pass/panic1.stderr", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Frun-pass%2Fpanic1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Frun-pass%2Fpanic1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic1.stderr?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -0,0 +1 @@\n+thread 'main' panicked at 'Miri panic!', $DIR/panic1.rs:3:5"}, {"sha": "deaf606d9a2e0d04343e4219dbf845dc1a568475", "filename": "tests/run-pass/panic2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Frun-pass%2Fpanic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Frun-pass%2Fpanic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic2.rs?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -0,0 +1,5 @@\n+// ignore-windows: Unwind panicking does not currently work on Windows\n+fn main() {\n+    let val = \"Value\".to_string();\n+    panic!(\"Miri panic with value: {}\", val);\n+}"}, {"sha": "bc5df83ec0f076cee623baa7a625253641ea3206", "filename": "tests/run-pass/panic2.stderr", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Frun-pass%2Fpanic2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e588d9535c014d078ccf785c18618cc765a93afe/tests%2Frun-pass%2Fpanic2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic2.stderr?ref=e588d9535c014d078ccf785c18618cc765a93afe", "patch": "@@ -0,0 +1 @@\n+thread 'main' panicked at 'Miri panic with value: Value', $DIR/panic2.rs:4:5"}]}