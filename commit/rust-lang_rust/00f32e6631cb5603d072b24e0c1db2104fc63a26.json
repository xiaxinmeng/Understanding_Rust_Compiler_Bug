{"sha": "00f32e6631cb5603d072b24e0c1db2104fc63a26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwZjMyZTY2MzFjYjU2MDNkMDcyYjI0ZTBjMWRiMjEwNGZjNjNhMjY=", "commit": {"author": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2020-11-01T18:24:22Z"}, "committer": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2020-11-01T18:57:45Z"}, "message": "Add fetch_update methods to AtomicBool and AtomicPtr\n\nThese methods were stabilized for the integer atomics in #71843, but the methods\nwere not added for the non-integer atomics `AtomicBool` and `AtomicPtr`.", "tree": {"sha": "ccd2550d4f7dbdd8c169026b865e0ac00652bdce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccd2550d4f7dbdd8c169026b865e0ac00652bdce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00f32e6631cb5603d072b24e0c1db2104fc63a26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00f32e6631cb5603d072b24e0c1db2104fc63a26", "html_url": "https://github.com/rust-lang/rust/commit/00f32e6631cb5603d072b24e0c1db2104fc63a26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00f32e6631cb5603d072b24e0c1db2104fc63a26/comments", "author": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1899c489d4c30b2640d30b77ac04f0a548834d81", "url": "https://api.github.com/repos/rust-lang/rust/commits/1899c489d4c30b2640d30b77ac04f0a548834d81", "html_url": "https://github.com/rust-lang/rust/commit/1899c489d4c30b2640d30b77ac04f0a548834d81"}], "stats": {"total": 125, "additions": 125, "deletions": 0}, "files": [{"sha": "0c53b6ed54a849e8fb2c85088e661c57990127cc", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/00f32e6631cb5603d072b24e0c1db2104fc63a26/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00f32e6631cb5603d072b24e0c1db2104fc63a26/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=00f32e6631cb5603d072b24e0c1db2104fc63a26", "patch": "@@ -801,6 +801,64 @@ impl AtomicBool {\n     pub fn as_mut_ptr(&self) -> *mut bool {\n         self.v.get() as *mut bool\n     }\n+\n+    /// Fetches the value, and applies a function to it that returns an optional\n+    /// new value. Returns a `Result` of `Ok(previous_value)` if the function\n+    /// returned `Some(_)`, else `Err(previous_value)`.\n+    ///\n+    /// Note: This may call the function multiple times if the value has been\n+    /// changed from other threads in the meantime, as long as the function\n+    /// returns `Some(_)`, but the function will have been applied only once to\n+    /// the stored value.\n+    ///\n+    /// `fetch_update` takes two [`Ordering`] arguments to describe the memory\n+    /// ordering of this operation. The first describes the required ordering for\n+    /// when the operation finally succeeds while the second describes the\n+    /// required ordering for loads. These correspond to the success and failure\n+    /// orderings of [`AtomicBool::compare_exchange`] respectively.\n+    ///\n+    /// Using [`Acquire`] as success ordering makes the store part of this\n+    /// operation [`Relaxed`], and using [`Release`] makes the final successful\n+    /// load [`Relaxed`]. The (failed) load ordering can only be [`SeqCst`],\n+    /// [`Acquire`] or [`Relaxed`] and must be equivalent to or weaker than the\n+    /// success ordering.\n+    ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on `u8`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(atomic_fetch_update)]\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let x = AtomicBool::new(false);\n+    /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(false));\n+    /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(!x)), Ok(false));\n+    /// assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(!x)), Ok(true));\n+    /// assert_eq!(x.load(Ordering::SeqCst), false);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"atomic_fetch_update\", reason = \"recently added\", issue = \"78639\")]\n+    #[cfg(target_has_atomic = \"8\")]\n+    pub fn fetch_update<F>(\n+        &self,\n+        set_order: Ordering,\n+        fetch_order: Ordering,\n+        mut f: F,\n+    ) -> Result<bool, bool>\n+    where\n+        F: FnMut(bool) -> Option<bool>,\n+    {\n+        let mut prev = self.load(fetch_order);\n+        while let Some(next) = f(prev) {\n+            match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n+                x @ Ok(_) => return x,\n+                Err(next_prev) => prev = next_prev,\n+            }\n+        }\n+        Err(prev)\n+    }\n }\n \n #[cfg(target_has_atomic_load_store = \"ptr\")]\n@@ -1123,6 +1181,73 @@ impl<T> AtomicPtr<T> {\n             }\n         }\n     }\n+\n+    /// Fetches the value, and applies a function to it that returns an optional\n+    /// new value. Returns a `Result` of `Ok(previous_value)` if the function\n+    /// returned `Some(_)`, else `Err(previous_value)`.\n+    ///\n+    /// Note: This may call the function multiple times if the value has been\n+    /// changed from other threads in the meantime, as long as the function\n+    /// returns `Some(_)`, but the function will have been applied only once to\n+    /// the stored value.\n+    ///\n+    /// `fetch_update` takes two [`Ordering`] arguments to describe the memory\n+    /// ordering of this operation. The first describes the required ordering for\n+    /// when the operation finally succeeds while the second describes the\n+    /// required ordering for loads. These correspond to the success and failure\n+    /// orderings of [`AtomicPtr::compare_exchange`] respectively.\n+    ///\n+    /// Using [`Acquire`] as success ordering makes the store part of this\n+    /// operation [`Relaxed`], and using [`Release`] makes the final successful\n+    /// load [`Relaxed`]. The (failed) load ordering can only be [`SeqCst`],\n+    /// [`Acquire`] or [`Relaxed`] and must be equivalent to or weaker than the\n+    /// success ordering.\n+    ///\n+    /// **Note:** This method is only available on platforms that support atomic\n+    /// operations on pointers.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(atomic_fetch_update)]\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let ptr: *mut _ = &mut 5;\n+    /// let some_ptr = AtomicPtr::new(ptr);\n+    ///\n+    /// let new: *mut _ = &mut 10;\n+    /// assert_eq!(some_ptr.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(ptr));\n+    /// let result = some_ptr.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| {\n+    ///     if x == ptr {\n+    ///         Some(new)\n+    ///     } else {\n+    ///         None\n+    ///     }\n+    /// });\n+    /// assert_eq!(result, Ok(ptr));\n+    /// assert_eq!(some_ptr.load(Ordering::SeqCst), new);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"atomic_fetch_update\", reason = \"recently added\", issue = \"78639\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n+    pub fn fetch_update<F>(\n+        &self,\n+        set_order: Ordering,\n+        fetch_order: Ordering,\n+        mut f: F,\n+    ) -> Result<*mut T, *mut T>\n+    where\n+        F: FnMut(*mut T) -> Option<*mut T>,\n+    {\n+        let mut prev = self.load(fetch_order);\n+        while let Some(next) = f(prev) {\n+            match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n+                x @ Ok(_) => return x,\n+                Err(next_prev) => prev = next_prev,\n+            }\n+        }\n+        Err(prev)\n+    }\n }\n \n #[cfg(target_has_atomic_load_store = \"8\")]"}]}