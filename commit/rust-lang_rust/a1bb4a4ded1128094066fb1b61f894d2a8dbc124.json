{"sha": "a1bb4a4ded1128094066fb1b61f894d2a8dbc124", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYmI0YTRkZWQxMTI4MDk0MDY2ZmIxYjYxZjg5NGQyYThkYmMxMjQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-14T01:10:33Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-14T01:21:22Z"}, "message": "Refactor some typestate-related data structures", "tree": {"sha": "f3305c674abd90de8f9289d90793e580251cd964", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3305c674abd90de8f9289d90793e580251cd964"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1bb4a4ded1128094066fb1b61f894d2a8dbc124", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1bb4a4ded1128094066fb1b61f894d2a8dbc124", "html_url": "https://github.com/rust-lang/rust/commit/a1bb4a4ded1128094066fb1b61f894d2a8dbc124", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1bb4a4ded1128094066fb1b61f894d2a8dbc124/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1857d30fc05f29fb82231336b229e50948a8336", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1857d30fc05f29fb82231336b229e50948a8336", "html_url": "https://github.com/rust-lang/rust/commit/d1857d30fc05f29fb82231336b229e50948a8336"}], "stats": {"total": 285, "additions": 142, "deletions": 143}, "files": [{"sha": "9b5c44bc6ad125770ab2cbd3d15605782652a902", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 58, "deletions": 53, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/a1bb4a4ded1128094066fb1b61f894d2a8dbc124/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bb4a4ded1128094066fb1b61f894d2a8dbc124/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=a1bb4a4ded1128094066fb1b61f894d2a8dbc124", "patch": "@@ -76,12 +76,12 @@ fn comma_str(vec[@constr_arg_use] args) -> str {\n     ret res;\n }\n \n-fn constraint_to_str(ty::ctxt tcx, constr c) -> str {\n-    alt (c.node) {\n-        case (ninit(?i, _)) {\n+fn constraint_to_str(&ty::ctxt tcx, &constr c) -> str {\n+    alt (c.node.c) {\n+        case (ninit(?i)) {\n             ret \"init(\" + i + \" [\" + tcx.sess.span_str(c.span) + \"])\";\n         }\n-        case (npred(?p, _, ?args)) {\n+        case (npred(?p, ?args)) {\n             ret path_to_str(p) + \"(\" + comma_str(args) + \")\"\n                 + \"[\" + tcx.sess.span_str(c.span) + \"]\";\n         }\n@@ -101,7 +101,7 @@ fn bitv_to_str(fn_ctxt fcx, bitv::t v) -> str {\n   ret s;\n }\n \n-fn log_bitv(fn_ctxt fcx, bitv::t v) {\n+fn log_bitv(&fn_ctxt fcx, &bitv::t v) {\n     log(bitv_to_str(fcx, v));\n }\n \n@@ -208,43 +208,50 @@ fn print_idents(vec[ident] idents) -> () {\n /* data structures */\n \n /**********************************************************************/\n-/* mapping from def_id to bit number and other data\n-   (ident/path/span are there for error-logging purposes) */\n+/* Two different data structures represent constraints in different\n+ contexts: constraint and norm_constraint.\n \n-/* FIXME very confused about why we have all these different types. */\n+constraint gets used to record constraints in a table keyed by def_ids.\n+cinit constraints represent a single constraint, for the initialization\n+state of a variable; a cpred constraint, with a single operator and a\n+list of possible argument lists, could represent several constraints at\n+once.\n+\n+norm_constraint, in contrast, gets used when handling an instance\n+of a constraint rather than a definition of a constraint. It can\n+also be init or pred (ninit or npred), but the npred case just has\n+a single argument list. \n+\n+The representation of constraints, where multiple instances of the\n+same predicate are collapsed into one entry in the table, makes it\n+easier to look up a specific instance.\n+\n+Both types are in constrast with the constraint type defined in\n+front::ast, which is for predicate constraints only, and is what\n+gets generated by the parser. aux and ast share the same type\n+to represent predicate *arguments* however. This type\n+(constr_arg_general) is parameterized (see comments in front::ast).\n+\n+Both types store an ident and span, for error-logging purposes.\n+*/\n \n type pred_desc_ = rec(vec[@constr_arg_use] args,\n                       uint bit_num);\n type pred_desc = spanned[pred_desc_];\n tag constraint {\n-    cinit(uint, span, def_id, ident);\n-    cpred(path, def_id, @mutable vec[pred_desc]);\n+    cinit(uint, span, ident);\n+    cpred(path, @mutable vec[pred_desc]);\n }\n-tag constr_ {\n-    ninit(ident, def_id);\n-    npred(path, def_id, vec[@constr_arg_use]);\n+tag constr__ {\n+    ninit(ident);\n+    npred(path, vec[@constr_arg_use]);\n }\n+type constr_ = rec(def_id id, constr__ c);\n type constr = spanned[constr_];\n type norm_constraint = rec(uint bit_num,\n                            constr c);\n-/* \"constraint occurrence\" to disambiguate\n-   between constraints. either \"this is an\n-   init constraint\", or the list of args for\n-   a pred. */\n-tag constr_occ {\n-    occ_init;\n-    occ_args(vec[@constr_arg_use]);\n-}\n-   \n type constr_map = @std::map::hashmap[def_id, constraint];\n \n-fn constr_id(&constr c) -> def_id {\n-    ret (alt (c.node) {\n-            case (ninit(_, ?i))    { i }\n-            case (npred(_, ?i, _)) { i }\n-        })\n-}\n-\n type fn_info  = rec(constr_map constrs, uint num_constraints, controlflow cf);\n \n /* mapping from node ID to typestate annotation */\n@@ -529,16 +536,16 @@ fn ann_to_def(&crate_ctxt ccx, &ann a) -> option::t[def] {\n     ret ccx.tcx.def_map.find(a.id);\n }\n \n-fn norm_a_constraint(&constraint c) -> vec[norm_constraint] {\n+fn norm_a_constraint(&def_id id, &constraint c) -> vec[norm_constraint] {\n     alt (c) {\n-        case (cinit(?n, ?sp, ?id, ?i)) {\n-            ret [rec(bit_num=n, c=respan(sp, ninit(i, id)))];\n+        case (cinit(?n, ?sp, ?i)) {\n+            ret [rec(bit_num=n, c=respan(sp, rec(id=id, c=ninit(i))))];\n         }\n-        case (cpred(?p, ?id, ?descs)) {\n+        case (cpred(?p, ?descs)) {\n             let vec[norm_constraint] res = [];\n             for (pred_desc pd in *descs) {\n                 vec::push(res, rec(bit_num=pd.node.bit_num,\n-                  c=respan(pd.span, npred(p, id, pd.node.args))));\n+                  c=respan(pd.span, rec(id=id, c=npred(p, pd.node.args)))));\n             }\n             ret res;\n         }\n@@ -551,7 +558,7 @@ fn constraints(&fn_ctxt fcx) -> vec[norm_constraint] {\n     let vec[norm_constraint] res = [];\n     for each (@tup(def_id, constraint) p in\n               fcx.enclosing.constrs.items()) {\n-        res += norm_a_constraint(p._1);\n+        res += norm_a_constraint(p._0, p._1);\n     }\n     ret res;\n }\n@@ -572,13 +579,6 @@ fn match_args(&fn_ctxt fcx, vec[pred_desc] occs,\n     fcx.ccx.tcx.sess.bug(\"match_args: no match for occurring args\");  \n }\n \n-fn constr_to_constr_occ(&ty::ctxt tcx, &constr_ c) -> constr_occ {\n-    alt (c) {\n-        case (ninit(_, _)) { ret occ_init; }\n-        case (npred(_, _, ?args)) { ret occ_args(args); }\n-    }\n-}\n-\n fn def_id_for_constr(ty::ctxt tcx, uint t) -> def_id {\n     alt (tcx.def_map.find(t)) {\n         case (none) {\n@@ -627,8 +627,9 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n             alt (operator.node) {\n                 case (expr_path(?p, ?a)) {\n                     ret respan(e.span,\n-                               npred(p, def_id_for_constr(tcx, a.id),\n-                                     exprs_to_constr_args(tcx, args))); \n+                          rec(id=def_id_for_constr(tcx, a.id),\n+                              c=npred(p, \n+                                      exprs_to_constr_args(tcx, args)))); \n                 }\n                 case (_) {\n                     tcx.sess.span_err(operator.span, \"Internal error: \" +\n@@ -648,20 +649,14 @@ fn pred_desc_to_str(&pred_desc p) -> str {\n          pretty::ppaux::constr_args_to_str_1(p.node.args) + \">\");\n }\n \n-fn substitute_constr_args_(&ty::ctxt cx,\n+fn substitute_constr_args(&ty::ctxt cx,\n                           &vec[@expr] actuals, &@ast::constr c)\n-    -> vec[@constr_arg_use] {\n+    -> constr__ {\n     let vec[@constr_arg_use] res = [];\n     for (@constr_arg a in c.node.args) {\n         res += [substitute_arg(cx, actuals, a)];\n     }\n-    ret res;\n-\n-}\n-\n-fn substitute_constr_args(&ty::ctxt cx,\n-      &vec[@expr] actuals, &@ast::constr c) -> constr_occ {\n-    ret occ_args(substitute_constr_args_(cx, actuals, c));\n+    ret npred(c.node.path, res);\n }\n \n type subst = vec[tup(arg, @expr)];\n@@ -683,6 +678,16 @@ fn substitute_arg(&ty::ctxt cx, &vec[@expr] actuals, @ast::constr_arg a)\n     }\n }\n \n+fn path_to_ident(&ty::ctxt cx, &path p) -> ident {\n+    alt (vec::last(p.node.idents)) {\n+        case (none) {\n+            cx.sess.span_err(p.span, \"Malformed path\");\n+        }\n+        case (some(?i)) {\n+            ret i;\n+        }\n+    }\n+}\n //\n // Local Variables:\n // mode: rust"}, {"sha": "52bde20f89ce369e22fef2d48d748011b2e94c8a", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a1bb4a4ded1128094066fb1b61f894d2a8dbc124/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bb4a4ded1128094066fb1b61f894d2a8dbc124/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=a1bb4a4ded1128094066fb1b61f894d2a8dbc124", "patch": "@@ -9,13 +9,13 @@ import aux::fn_ctxt;\n import aux::fn_info;\n import aux::log_bitv;\n import aux::num_constraints;\n-import aux::constr_occ;\n-import aux::occ_init;\n-import aux::occ_args;\n import aux::cinit;\n import aux::cpred;\n+import aux::ninit;\n+import aux::npred;\n import aux::pred_desc;\n import aux::match_args;\n+import aux::constr_;\n \n import tstate::aux::ann_to_ts_ann;\n import tstate::ann::pre_and_post;\n@@ -35,13 +35,13 @@ import tstate::ann::set_in_postcond;\n import tstate::ann::set_in_poststate;\n import tstate::ann::clear_in_poststate;\n            \n-fn bit_num(&fn_ctxt fcx, &def_id v, &constr_occ o) -> uint {\n-    assert (fcx.enclosing.constrs.contains_key(v));\n-    auto res = fcx.enclosing.constrs.get(v);\n-    alt (o) {\n-        case (occ_init) {\n+fn bit_num(&fn_ctxt fcx, &constr_ c) -> uint {\n+    assert (fcx.enclosing.constrs.contains_key(c.id));\n+    auto res = fcx.enclosing.constrs.get(c.id);\n+    alt (c.c) {\n+        case (ninit(_)) {\n             alt (res) {\n-                case (cinit(?n,_,_,_)) {\n+                case (cinit(?n,_,_)) {\n                     ret n;\n                 }\n                 case (_) {\n@@ -50,9 +50,9 @@ fn bit_num(&fn_ctxt fcx, &def_id v, &constr_occ o) -> uint {\n                 }\n             }\n         }\n-        case (occ_args(?args)) {\n+        case (npred(_, ?args)) {\n             alt (res) {\n-                case (cpred(_, _, ?descs)) {\n+                case (cpred(_, ?descs)) {\n                     ret match_args(fcx, *descs, args);\n                 }\n                 case (_) {\n@@ -64,8 +64,8 @@ fn bit_num(&fn_ctxt fcx, &def_id v, &constr_occ o) -> uint {\n     }\n }\n \n-fn promises(&fn_ctxt fcx, &poststate p, &def_id v, &constr_occ o) -> bool {\n-    ret bitv::get(p, bit_num(fcx, v, o));\n+fn promises(&fn_ctxt fcx, &poststate p, &constr_ c) -> bool {\n+    ret bitv::get(p, bit_num(fcx, c));\n }\n \n // Given a list of pres and posts for exprs e0 ... en,\n@@ -143,27 +143,26 @@ fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n   ret intersect_postconds_go(bitv::clone(pcs.(0)), pcs);\n }\n \n-fn gen(&fn_ctxt fcx, &ann a, &def_id id, &constr_occ o) -> bool {\n-  ret set_in_postcond(bit_num(fcx, id, o),\n+fn gen(&fn_ctxt fcx, &ann a, &constr_ c) -> bool {\n+  ret set_in_postcond(bit_num(fcx, c),\n                       (ann_to_ts_ann(fcx.ccx, a)).conditions);\n }\n \n-fn declare_var(&fn_ctxt fcx, def_id id, prestate pre)\n-   -> prestate {\n+fn declare_var(&fn_ctxt fcx, &constr_ c, prestate pre) -> prestate {\n     auto res = clone(pre);\n-    relax_prestate(bit_num(fcx, id, occ_init), res);\n+    relax_prestate(bit_num(fcx, c), res);\n     ret res;\n }\n \n-fn gen_poststate(&fn_ctxt fcx, &ann a, &def_id id, &constr_occ o) -> bool {\n+fn gen_poststate(&fn_ctxt fcx, &ann a, &constr_ c) -> bool {\n   log \"gen_poststate\";\n-  ret set_in_poststate(bit_num(fcx, id, o),\n+  ret set_in_poststate(bit_num(fcx, c),\n                        (ann_to_ts_ann(fcx.ccx, a)).states);\n }\n \n-fn kill_poststate(&fn_ctxt fcx, &ann a, def_id id, &constr_occ o) -> bool {\n+fn kill_poststate(&fn_ctxt fcx, &ann a, &constr_ c) -> bool {\n   log \"kill_poststate\";\n-  ret clear_in_poststate(bit_num(fcx, id, o),\n+  ret clear_in_poststate(bit_num(fcx, c),\n                          (ann_to_ts_ann(fcx.ccx, a)).states);\n }\n "}, {"sha": "27e885e66d8acdc3a8469bb9af0f7faf431b11c6", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1bb4a4ded1128094066fb1b61f894d2a8dbc124/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bb4a4ded1128094066fb1b61f894d2a8dbc124/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=a1bb4a4ded1128094066fb1b61f894d2a8dbc124", "patch": "@@ -133,8 +133,9 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) -> () {\n   \n     auto cf = fcx.enclosing.cf;\n     /* Finally, check that the return value is initialized */\n+    let aux::constr_ ret_c = rec(id=fcx.id, c=aux::ninit(fcx.name));\n     if (f.proto == ast::proto_fn\n-        && ! promises(fcx, *post, fcx.id, aux::occ_init)\n+        && ! promises(fcx, *post, ret_c)\n         && ! type_is_nil(fcx.ccx.tcx,\n                          ret_ty_of_fn(fcx.ccx.tcx, a))\n         && cf == return) {\n@@ -148,7 +149,7 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) -> () {\n         // check that this really always fails\n         // the fcx.id bit means \"returns\" for a returning fn,\n         // \"diverges\" for a non-returning fn\n-        if (! promises(fcx, *post, fcx.id, aux::occ_init)) {\n+        if (! promises(fcx, *post, ret_c)) {\n             fcx.ccx.tcx.sess.span_err(f.body.span,\n               \"In non-returning function \" + fcx.name +\n               \", some control paths may return to the caller\");"}, {"sha": "e6691fce48f2a15b81b8eb39108a7dbff6dcbde5", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a1bb4a4ded1128094066fb1b61f894d2a8dbc124/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bb4a4ded1128094066fb1b61f894d2a8dbc124/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=a1bb4a4ded1128094066fb1b61f894d2a8dbc124", "patch": "@@ -13,7 +13,6 @@ import aux::cinit;\n import aux::ninit;\n import aux::npred;\n import aux::cpred;\n-import aux::constr;\n import aux::constraint;\n import aux::fn_info;\n import aux::crate_ctxt;\n@@ -28,19 +27,19 @@ import util::common::uistr;\n import util::common::span;\n import util::common::respan;\n \n-type ctxt = rec(@mutable vec[constr] cs,\n-                ty::ctxt tcx);\n+type ctxt = rec(@mutable vec[aux::constr] cs, ty::ctxt tcx);\n \n fn collect_local(&ctxt cx, &@local loc) -> () {\n     log(\"collect_local: pushing \" + loc.node.ident);\n-    vec::push[constr](*cx.cs, respan(loc.span,\n-                                     ninit(loc.node.ident, loc.node.id)));\n+    vec::push(*cx.cs, respan(loc.span,\n+                             rec(id=loc.node.id,\n+                                 c=ninit(loc.node.ident))));\n }\n \n fn collect_pred(&ctxt cx, &@expr e) -> () {\n     alt (e.node) {\n         case (expr_check(?e, _)) {\n-            vec::push[constr](*cx.cs, expr_to_constr(cx.tcx, e));\n+            vec::push(*cx.cs, expr_to_constr(cx.tcx, e));\n         }\n         // If it's a call, generate appropriate instances of the\n         // call's constraints.\n@@ -49,12 +48,10 @@ fn collect_pred(&ctxt cx, &@expr e) -> () {\n                 auto d_id = ann_to_def_strict(cx.tcx, c.node.ann);\n                 alt (d_id) {\n                     case (def_fn(?an_id)) {\n-                        let constr an_occ = respan(c.span,\n-                              npred(c.node.path, an_id, \n-                                    aux::substitute_constr_args_(cx.tcx,\n-                                                                 operands,\n-                                                                 c)));\n-                        vec::push[constr](*cx.cs, an_occ);\n+                        let aux::constr ct = respan(c.span,\n+                          rec(id=an_id, c=aux::substitute_constr_args(cx.tcx,\n+                                            operands, c)));\n+                        vec::push(*cx.cs, ct);\n                     }\n                     case (_) {\n                         cx.tcx.sess.span_err(c.span,\n@@ -70,7 +67,7 @@ fn collect_pred(&ctxt cx, &@expr e) -> () {\n \n fn find_locals(&ty::ctxt tcx, &_fn f, &span sp, &ident i, &def_id d, &ann a)\n     -> ctxt {\n-    let ctxt cx = rec(cs=@mutable vec::alloc[constr](0u), tcx=tcx);\n+    let ctxt cx = rec(cs=@mutable vec::alloc(0u), tcx=tcx);\n     auto visitor = walk::default_visitor();\n     visitor = rec(visit_local_pre=bind collect_local(cx,_),\n                   visit_expr_pre=bind collect_pred(cx,_)\n@@ -79,34 +76,32 @@ fn find_locals(&ty::ctxt tcx, &_fn f, &span sp, &ident i, &def_id d, &ann a)\n     ret cx;\n }\n \n-fn add_constraint(&ty::ctxt tcx, constr c, uint next, constr_map tbl)\n+fn add_constraint(&ty::ctxt tcx, aux::constr c, uint next, constr_map tbl)\n     -> uint {\n     log(aux::constraint_to_str(tcx, c) + \" |-> \"\n         + util::common::uistr(next));\n-    alt (c.node) {\n-        case (ninit(?i, ?id)) {\n-            tbl.insert(id, cinit(next, c.span, id, i));\n+    alt (c.node.c) {\n+        case (ninit(?i)) {\n+            tbl.insert(c.node.id, cinit(next, c.span, i));\n         }\n-        case (npred(?p, ?id, ?args)) {\n-            alt (tbl.find(id)) {\n-                case (some[constraint](?ct)) {\n+        case (npred(?p, ?args)) {\n+            alt (tbl.find(c.node.id)) {\n+                case (some(?ct)) {\n                     alt (ct) {\n-                        case (cinit(_,_,_,_)) {\n+                        case (cinit(_,_,_)) {\n                             tcx.sess.bug(\"add_constraint: same def_id used\"\n                                          + \" as a variable and a pred\");\n                         }\n-                        case (cpred(_, _, ?pds)) {\n+                        case (cpred(_, ?pds)) {\n                              vec::push(*pds, respan(c.span,\n-                              rec(args=args, bit_num=next)));\n+                               rec(args=args, bit_num=next)));\n                         }\n                     }\n                 }\n-                // FIXME: this suggests a cpred shouldn't really have a\n-                // def_id as a field...\n-                case (none[constraint]) {\n-                    tbl.insert(id, cpred(p, id,\n+                case (none) {\n+                    tbl.insert(c.node.id, cpred(p,\n                       @mutable [respan(c.span, rec(args=args,\n-                                                    bit_num=next))]));\n+                                                   bit_num=next))]));\n                 }\n             }\n         }\n@@ -130,12 +125,13 @@ fn mk_fn_info(&crate_ctxt ccx, &_fn f, &span f_sp,\n     /* now we have to add bit nums for both the constraints\n        and the variables... */\n \n-    for (constr c in {*cx.cs}) {\n+    for (aux::constr c in {*cx.cs}) {\n         next = add_constraint(cx.tcx, c, next, res_map);\n     }\n     /* add a pseudo-entry for the function's return value\n        we can safely use the function's name itself for this purpose */\n-    add_constraint(cx.tcx, respan(f_sp, ninit(f_name, f_id)), next, res_map);\n+    add_constraint(cx.tcx, respan(f_sp, rec(id=f_id, c=ninit(f_name))), next,\n+                   res_map);\n     \n     auto res = rec(constrs=res_map,\n                             num_constraints=vec::len(*cx.cs) + 1u,"}, {"sha": "5eafeb8a1a52b5f1644cf8de0b43aa515688b6f6", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a1bb4a4ded1128094066fb1b61f894d2a8dbc124/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bb4a4ded1128094066fb1b61f894d2a8dbc124/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=a1bb4a4ded1128094066fb1b61f894d2a8dbc124", "patch": "@@ -22,10 +22,8 @@ import tstate::ann::set_precondition;\n import tstate::ann::set_postcondition;\n import aux::crate_ctxt;\n import aux::fn_ctxt;\n-import aux::occ_init;\n import aux::num_constraints;\n import aux::constraint;\n-import aux::constr_occ;\n import aux::expr_pp;\n import aux::stmt_pp;\n import aux::block_pp;\n@@ -46,10 +44,12 @@ import aux::ann_to_ts_ann;\n import aux::set_postcond_false;\n import aux::controlflow_expr;\n import aux::expr_to_constr;\n-import aux::constr_to_constr_occ;\n+//import aux::constr_to_constr_occ;\n import aux::constraints_expr;\n import aux::substitute_constr_args;\n-import aux::constr_id;\n+import aux::ninit;\n+import aux::npred;\n+import aux::path_to_ident;\n \n import bitvectors::seq_preconds;\n import bitvectors::union_postconds;\n@@ -174,15 +174,16 @@ fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index,\n       &block body, &ann a) -> () {\n     find_pre_post_expr(fcx, index);\n     find_pre_post_block(fcx, body);\n-    auto loop_precond = declare_var(fcx, l.node.id,\n+    auto loop_precond = declare_var(fcx, rec(id=l.node.id,\n+                                             c=ninit(l.node.ident)),\n       seq_preconds(fcx, [expr_pp(fcx.ccx, index), block_pp(fcx.ccx, body)]));\n     auto loop_postcond = intersect_postconds\n         ([expr_postcond(fcx.ccx, index), block_postcond(fcx.ccx, body)]);\n     set_pre_and_post(fcx.ccx, a, loop_precond, loop_postcond);\n }\n \n fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs,\n-                &ann larger_ann, &ann new_var) -> () {\n+                &ann larger_ann, &ann new_var, &path pth) -> () {\n   alt (ann_to_def(fcx.ccx, new_var)) {\n       case (some(?d)) {\n           alt (d) {\n@@ -191,7 +192,8 @@ fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs,\n                   auto p = expr_pp(fcx.ccx, rhs);\n                   set_pre_and_post(fcx.ccx, larger_ann,\n                                    p.precondition, p.postcondition);\n-                  gen(fcx, larger_ann, d_id, aux::occ_init);\n+                  gen(fcx, larger_ann, rec(id=d_id,\n+                        c=ninit(path_to_ident(fcx.ccx.tcx, pth))));\n               }\n               case (_) { find_pre_post_exprs(fcx, [lhs, rhs], larger_ann); }\n           }\n@@ -230,8 +232,9 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n                 auto id = ann_to_def(fcx.ccx, c.node.ann);\n                 alt (id) {\n                     case (some(def_fn(?d_id))) {\n-                        auto i = bit_num(fcx, d_id,\n-                          substitute_constr_args(fcx.ccx.tcx, operands, c));\n+                        auto i = bit_num(fcx, rec(id=d_id,\n+                                    c=substitute_constr_args(fcx.ccx.tcx,\n+                                                             operands, c)));\n                         require(i, pp);\n                     }\n                     case (_) {\n@@ -269,7 +272,8 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             auto df = ann_to_def_strict(fcx.ccx.tcx, a);\n             alt (df) {\n                 case (def_local(?d_id)) {\n-                    auto i = bit_num(fcx, d_id, occ_init);\n+                    auto i = bit_num(fcx, rec(id=d_id,\n+                                c=ninit(path_to_ident(fcx.ccx.tcx, p))));\n                     require_and_preserve(i, res);\n                 }\n                 case (_) { /* nothing to check */ }\n@@ -311,7 +315,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             // FIXME: this needs to deinitialize the rhs\n             alt (lhs.node) {\n                 case (expr_path(?p, ?a_lhs)) {\n-                  gen_if_local(fcx, lhs, rhs, a, a_lhs);\n+                    gen_if_local(fcx, lhs, rhs, a, a_lhs, p);\n                 }\n                 case (_) {\n                     find_pre_post_exprs(fcx, [lhs, rhs], a);\n@@ -321,7 +325,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n         case (expr_assign(?lhs, ?rhs, ?a)) {\n             alt (lhs.node) {\n                 case (expr_path(?p, ?a_lhs)) {\n-                  gen_if_local(fcx, lhs, rhs, a, a_lhs);\n+                    gen_if_local(fcx, lhs, rhs, a, a_lhs, p);\n                 }\n                 case (_) {\n                     find_pre_post_exprs(fcx, [lhs, rhs], a);\n@@ -331,7 +335,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n         case (expr_recv(?lhs, ?rhs, ?a)) {\n             alt (lhs.node) {\n                 case (expr_path(?p, ?a_lhs)) {\n-                  gen_if_local(fcx, lhs, rhs, a, a_lhs);\n+                    gen_if_local(fcx, lhs, rhs, a, a_lhs, p);\n                 }\n                 case (_) {\n                     // doesn't check that lhs is an lval, but\n@@ -510,8 +514,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             copy_pre_post(fcx.ccx, a, p);\n             /* predicate p holds after this expression executes */\n             let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n-            let constr_occ o = constr_to_constr_occ(fcx.ccx.tcx, c.node);\n-            gen(fcx, a, constr_id(c), o);\n+            gen(fcx, a, c.node);\n         }\n         case(expr_bind(?operator, ?maybe_args, ?a)) {\n             auto args = vec::cat_options[@expr](maybe_args);\n@@ -565,13 +568,8 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s)\n                             /* Inherit ann from initializer, and add var being\n                                initialized to the postcondition */\n                             copy_pre_post(fcx.ccx, a, an_init.expr);\n-                            /*  log(\"gen (decl):\");\n-                                log_stmt(s); */\n-                            gen(fcx, a, alocal.id, occ_init); \n-                            /*  log_err(\"for stmt\");\n-                                log_stmt(s);\n-                                log_err(\"pp = \");\n-                                log_pp(stmt_pp(s)); */\n+                            gen(fcx, a, rec(id=alocal.id,\n+                                            c=ninit(alocal.ident)));\n                         }\n                         case(none) {\n                             clear_pp(ann_to_ts_ann(fcx.ccx,"}, {"sha": "e89fd1a6a838c266143fb5a8de424ab52e478dd4", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a1bb4a4ded1128094066fb1b61f894d2a8dbc124/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bb4a4ded1128094066fb1b61f894d2a8dbc124/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=a1bb4a4ded1128094066fb1b61f894d2a8dbc124", "patch": "@@ -48,11 +48,10 @@ import aux::log_states;\n import aux::block_states;\n import aux::controlflow_expr;\n import aux::ann_to_def;\n-import aux::occ_init;\n import aux::expr_to_constr;\n-import aux::constr_to_constr_occ;\n-import aux::constr_occ;\n-import aux::constr_id;\n+import aux::ninit;\n+import aux::npred;\n+import aux::path_to_ident;\n \n import bitvectors::seq_preconds;\n import bitvectors::union_postconds;\n@@ -123,10 +122,11 @@ fn find_pre_post_state_loop(&fn_ctxt fcx, prestate pres, &@local l,\n     ret changed;\n }\n \n-fn gen_if_local(&fn_ctxt fcx, &ann a_new_var, &ann a) -> bool {\n+fn gen_if_local(&fn_ctxt fcx, &ann a_new_var, &ann a, &path p) -> bool {\n   alt (ann_to_def(fcx.ccx, a_new_var)) {\n       case (some(def_local(?loc))) {\n-          ret gen_poststate(fcx, a, loc, occ_init);\n+          ret gen_poststate(fcx, a, rec(id=loc,\n+                c=ninit(path_to_ident(fcx.ccx.tcx, p))));\n       }\n       case (_) { ret false; }\n   }\n@@ -257,7 +257,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                     || changed;\n                 changed = extend_poststate_ann(fcx.ccx, a,\n                             expr_poststate(fcx.ccx, rhs)) || changed;\n-                changed = gen_if_local(fcx, a_lhs, a)|| changed;\n+                changed = gen_if_local(fcx, a_lhs, a, p)|| changed;\n             }\n             case (_) {\n                 // assignment to something that must already have been init'd\n@@ -282,7 +282,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                     || changed;\n                 changed = extend_poststate_ann(fcx.ccx, a,\n                             expr_poststate(fcx.ccx, rhs)) || changed;\n-                changed = gen_if_local(fcx, a_lhs, a)|| changed;\n+                changed = gen_if_local(fcx, a_lhs, a, p)|| changed;\n             }\n             case (_) {\n                 // assignment to something that must already have been init'd\n@@ -307,7 +307,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                     || changed;\n                 changed = extend_poststate_ann(fcx.ccx, a,\n                             expr_poststate(fcx.ccx, rhs)) || changed;\n-                changed = gen_if_local(fcx, a_lhs, a) || changed;\n+                changed = gen_if_local(fcx, a_lhs, a, p) || changed;\n             }\n             case (_) {\n                 // receive to something that must already have been init'd\n@@ -331,7 +331,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         /* return from an always-failing function clears the return bit */\n         alt (fcx.enclosing.cf) {\n             case (noreturn) {\n-                kill_poststate(fcx, a, fcx.id, occ_init);\n+                kill_poststate(fcx, a, rec(id=fcx.id, c=ninit(fcx.name)));\n             }\n             case (_) {}\n         }\n@@ -529,8 +529,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         changed = extend_poststate_ann(fcx.ccx, a, pres) || changed;\n         /* predicate p holds after this expression executes */\n         let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n-        let constr_occ o = constr_to_constr_occ(fcx.ccx.tcx, c.node);\n-        changed = gen_poststate(fcx, a, constr_id(c), o) || changed;\n+        changed = gen_poststate(fcx, a, c.node) || changed;\n         ret changed;\n     }\n     case (expr_break(?a)) {\n@@ -590,7 +589,7 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n                                  expr_poststate(fcx.ccx, an_init.expr))\n                                 || changed;\n                             changed = gen_poststate(fcx, a,\n-                                                    alocal.id, occ_init)\n+                              rec(id=alocal.id, c=ninit(alocal.ident)))\n                                 || changed;\n                             log(\"Summary: stmt = \");\n                             log_stmt(*s);\n@@ -727,7 +726,8 @@ fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n                                   false_postcond(num_local_vars));\n                 alt (fcx.enclosing.cf) {\n                     case (noreturn) {\n-                        kill_poststate(fcx, tailann, fcx.id, occ_init);\n+                        kill_poststate(fcx, tailann,\n+                                       rec(id=fcx.id, c=ninit(fcx.name)));\n                     }\n                     case (_) { }\n                 }"}]}