{"sha": "46b8e7488eae116722196e8390c1bd2ea2e396cf", "node_id": "C_kwDOAAsO6NoAKDQ2YjhlNzQ4OGVhZTExNjcyMjE5NmU4MzkwYzFiZDJlYTJlMzk2Y2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-07T20:04:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-07T20:04:54Z"}, "message": "Auto merge of #90668 - matthiaskrgr:clippy_nov7, r=jyn514\n\nmore clippy fixes", "tree": {"sha": "4d9b19012744e2bcb59dd6d2c61be9ebcebc12b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d9b19012744e2bcb59dd6d2c61be9ebcebc12b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46b8e7488eae116722196e8390c1bd2ea2e396cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46b8e7488eae116722196e8390c1bd2ea2e396cf", "html_url": "https://github.com/rust-lang/rust/commit/46b8e7488eae116722196e8390c1bd2ea2e396cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46b8e7488eae116722196e8390c1bd2ea2e396cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68568dcb8ff49a3d70f4cc2d9215b5753d088738", "url": "https://api.github.com/repos/rust-lang/rust/commits/68568dcb8ff49a3d70f4cc2d9215b5753d088738", "html_url": "https://github.com/rust-lang/rust/commit/68568dcb8ff49a3d70f4cc2d9215b5753d088738"}, {"sha": "5c454551dae45563e7a33da7142377cf7d8dbcbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c454551dae45563e7a33da7142377cf7d8dbcbf", "html_url": "https://github.com/rust-lang/rust/commit/5c454551dae45563e7a33da7142377cf7d8dbcbf"}], "stats": {"total": 320, "additions": 138, "deletions": 182}, "files": [{"sha": "f45a79f026fb53521ab83117144b2c91a9003a2f", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -539,15 +539,13 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ExprKind::TryBlock(_) => {\n                 gate_feature_post!(&self, try_blocks, e.span, \"`try` expression is experimental\");\n             }\n-            ast::ExprKind::Block(_, opt_label) => {\n-                if let Some(label) = opt_label {\n-                    gate_feature_post!(\n-                        &self,\n-                        label_break_value,\n-                        label.ident.span,\n-                        \"labels on blocks are unstable\"\n-                    );\n-                }\n+            ast::ExprKind::Block(_, Some(label)) => {\n+                gate_feature_post!(\n+                    &self,\n+                    label_break_value,\n+                    label.ident.span,\n+                    \"labels on blocks are unstable\"\n+                );\n             }\n             _ => {}\n         }"}, {"sha": "b59e49926add91d9d2a1c6fdb13c17e00c8ddcb1", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -1438,11 +1438,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_record_struct_body(\n-        &mut self,\n-        fields: &Vec<ast::FieldDef>,\n-        span: rustc_span::Span,\n-    ) {\n+    crate fn print_record_struct_body(&mut self, fields: &[ast::FieldDef], span: rustc_span::Span) {\n         self.nbsp();\n         self.bopen();\n         self.hardbreak_if_not_bol();"}, {"sha": "06e34bdce3f8678284b5c5abf55706eef0737ea7", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -655,7 +655,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             // If the region is live at at least one location in the promoted MIR,\n             // then add a liveness constraint to the main MIR for this region\n             // at the location provided as an argument to this method\n-            if let Some(_) = liveness_constraints.get_elements(region).next() {\n+            if liveness_constraints.get_elements(region).next().is_some() {\n                 self.cx\n                     .borrowck_context\n                     .constraints"}, {"sha": "50127b5b15ce8fc6a87b1f38995b59a69beef96f", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -547,7 +547,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n                 if let Some(snippet) = &template_snippet {\n                     if let Some(pos) = snippet.find(needle) {\n                         let end = pos\n-                            + &snippet[pos..]\n+                            + snippet[pos..]\n                                 .find(|c| matches!(c, '\\n' | ';' | '\\\\' | '\"'))\n                                 .unwrap_or(snippet[pos..].len() - 1);\n                         let inner = InnerSpan::new(pos, end);"}, {"sha": "6c02543bd7cc4fc49c04e6b83c638bcff386546a", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -1095,10 +1095,10 @@ fn add_sanitizer_libraries(sess: &Session, crate_type: CrateType, linker: &mut d\n }\n \n fn link_sanitizer_runtime(sess: &Session, linker: &mut dyn Linker, name: &str) {\n-    fn find_sanitizer_runtime(sess: &Session, filename: &String) -> PathBuf {\n+    fn find_sanitizer_runtime(sess: &Session, filename: &str) -> PathBuf {\n         let session_tlib =\n             filesearch::make_target_lib_path(&sess.sysroot, sess.opts.target_triple.triple());\n-        let path = session_tlib.join(&filename);\n+        let path = session_tlib.join(filename);\n         if path.exists() {\n             return session_tlib;\n         } else {"}, {"sha": "a3ece6550473cce4ce080bbdc5e28f15b69e1cc2", "filename": "compiler/rustc_data_structures/src/steal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_data_structures%2Fsrc%2Fsteal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_data_structures%2Fsrc%2Fsteal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsteal.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -34,7 +34,7 @@ impl<T> Steal<T> {\n     #[track_caller]\n     pub fn borrow(&self) -> MappedReadGuard<'_, T> {\n         let borrow = self.value.borrow();\n-        if let None = &*borrow {\n+        if borrow.is_none() {\n             panic!(\"attempted to read from stolen value: {}\", std::any::type_name::<T>());\n         }\n         ReadGuard::map(borrow, |opt| opt.as_ref().unwrap())"}, {"sha": "8849d623b2dad2b7273e2d2525fc4f4973f14e5c", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -1466,7 +1466,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let mut returned_async_output_error = false;\n                     for &sp in values {\n                         if sp.is_desugaring(DesugaringKind::Async) && !returned_async_output_error {\n-                            if &[sp] != err.span.primary_spans() {\n+                            if [sp] != err.span.primary_spans() {\n                                 let mut span: MultiSpan = sp.into();\n                                 span.push_span_label(\n                                     sp,"}, {"sha": "3f6e879e6e44b778ef2576debe9424308d4be975", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -47,7 +47,7 @@ use std::ffi::OsString;\n use std::io::{self, BufWriter, Write};\n use std::lazy::SyncLazy;\n use std::marker::PhantomPinned;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::pin::Pin;\n use std::rc::Rc;\n use std::{env, fs, iter};\n@@ -536,7 +536,7 @@ where\n     None\n }\n \n-fn output_contains_path(output_paths: &[PathBuf], input_path: &PathBuf) -> bool {\n+fn output_contains_path(output_paths: &[PathBuf], input_path: &Path) -> bool {\n     let input_path = input_path.canonicalize().ok();\n     if input_path.is_none() {\n         return false;\n@@ -552,7 +552,7 @@ fn output_conflicts_with_dir(output_paths: &[PathBuf]) -> Option<PathBuf> {\n     check_output(output_paths, check)\n }\n \n-fn escape_dep_filename(filename: &String) -> String {\n+fn escape_dep_filename(filename: &str) -> String {\n     // Apparently clang and gcc *only* escape spaces:\n     // https://llvm.org/klaus/clang/commit/9d50634cfc268ecc9a7250226dd5ca0e945240d4\n     filename.replace(\" \", \"\\\\ \")"}, {"sha": "6548cdc0fdc52686e510fdd6b773371ab3377677", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -3130,18 +3130,13 @@ impl<'tcx> LateLintPass<'tcx> for DerefNullPtr {\n             false\n         }\n \n-        if let rustc_hir::ExprKind::Unary(ref un_op, ref expr_deref) = expr.kind {\n-            if let rustc_hir::UnOp::Deref = un_op {\n-                if is_null_ptr(cx, expr_deref) {\n-                    cx.struct_span_lint(DEREF_NULLPTR, expr.span, |lint| {\n-                        let mut err = lint.build(\"dereferencing a null pointer\");\n-                        err.span_label(\n-                            expr.span,\n-                            \"this code causes undefined behavior when executed\",\n-                        );\n-                        err.emit();\n-                    });\n-                }\n+        if let rustc_hir::ExprKind::Unary(rustc_hir::UnOp::Deref, expr_deref) = expr.kind {\n+            if is_null_ptr(cx, expr_deref) {\n+                cx.struct_span_lint(DEREF_NULLPTR, expr.span, |lint| {\n+                    let mut err = lint.build(\"dereferencing a null pointer\");\n+                    err.span_label(expr.span, \"this code causes undefined behavior when executed\");\n+                    err.emit();\n+                });\n             }\n         }\n     }\n@@ -3196,7 +3191,7 @@ impl<'tcx> LateLintPass<'tcx> for NamedAsmLabels {\n                         let snippet = template_snippet.as_str();\n                         if let Some(pos) = snippet.find(needle) {\n                             let end = pos\n-                                + &snippet[pos..]\n+                                + snippet[pos..]\n                                     .find(|c| c == ':')\n                                     .unwrap_or(snippet[pos..].len() - 1);\n                             let inner = InnerSpan::new(pos, end);"}, {"sha": "c64a67b6b9f1b5c38dbc774948c62c0078930ed7", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 45, "deletions": 54, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -101,33 +101,31 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n \n     fn check_ty(&mut self, cx: &LateContext<'_>, ty: &'tcx Ty<'tcx>) {\n         match &ty.kind {\n-            TyKind::Path(qpath) => {\n-                if let QPath::Resolved(_, path) = qpath {\n-                    if let Some(last) = path.segments.iter().last() {\n-                        if lint_ty_kind_usage(cx, last) {\n-                            cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, |lint| {\n-                                lint.build(\"usage of `ty::TyKind`\")\n-                                    .help(\"try using `Ty` instead\")\n-                                    .emit();\n-                            })\n-                        } else {\n-                            if ty.span.from_expansion() {\n-                                return;\n-                            }\n-                            if let Some(t) = is_ty_or_ty_ctxt(cx, ty) {\n-                                if path.segments.len() > 1 {\n-                                    cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, |lint| {\n-                                        lint.build(&format!(\"usage of qualified `ty::{}`\", t))\n-                                            .span_suggestion(\n-                                                path.span,\n-                                                \"try using it unqualified\",\n-                                                t,\n-                                                // The import probably needs to be changed\n-                                                Applicability::MaybeIncorrect,\n-                                            )\n-                                            .emit();\n-                                    })\n-                                }\n+            TyKind::Path(QPath::Resolved(_, path)) => {\n+                if let Some(last) = path.segments.iter().last() {\n+                    if lint_ty_kind_usage(cx, last) {\n+                        cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, |lint| {\n+                            lint.build(\"usage of `ty::TyKind`\")\n+                                .help(\"try using `Ty` instead\")\n+                                .emit();\n+                        })\n+                    } else {\n+                        if ty.span.from_expansion() {\n+                            return;\n+                        }\n+                        if let Some(t) = is_ty_or_ty_ctxt(cx, ty) {\n+                            if path.segments.len() > 1 {\n+                                cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, |lint| {\n+                                    lint.build(&format!(\"usage of qualified `ty::{}`\", t))\n+                                        .span_suggestion(\n+                                            path.span,\n+                                            \"try using it unqualified\",\n+                                            t,\n+                                            // The import probably needs to be changed\n+                                            Applicability::MaybeIncorrect,\n+                                        )\n+                                        .emit();\n+                                })\n                             }\n                         }\n                     }\n@@ -169,37 +167,30 @@ fn lint_ty_kind_usage(cx: &LateContext<'_>, segment: &PathSegment<'_>) -> bool {\n }\n \n fn is_ty_or_ty_ctxt(cx: &LateContext<'_>, ty: &Ty<'_>) -> Option<String> {\n-    if let TyKind::Path(qpath) = &ty.kind {\n-        if let QPath::Resolved(_, path) = qpath {\n-            match path.res {\n-                Res::Def(_, def_id) => {\n-                    if let Some(name @ (sym::Ty | sym::TyCtxt)) = cx.tcx.get_diagnostic_name(def_id)\n-                    {\n-                        return Some(format!(\n-                            \"{}{}\",\n-                            name,\n-                            gen_args(path.segments.last().unwrap())\n-                        ));\n-                    }\n+    if let TyKind::Path(QPath::Resolved(_, path)) = &ty.kind {\n+        match path.res {\n+            Res::Def(_, def_id) => {\n+                if let Some(name @ (sym::Ty | sym::TyCtxt)) = cx.tcx.get_diagnostic_name(def_id) {\n+                    return Some(format!(\"{}{}\", name, gen_args(path.segments.last().unwrap())));\n                 }\n-                // Only lint on `&Ty` and `&TyCtxt` if it is used outside of a trait.\n-                Res::SelfTy(None, Some((did, _))) => {\n-                    if let ty::Adt(adt, substs) = cx.tcx.type_of(did).kind() {\n-                        if let Some(name @ (sym::Ty | sym::TyCtxt)) =\n-                            cx.tcx.get_diagnostic_name(adt.did)\n-                        {\n-                            // NOTE: This path is currently unreachable as `Ty<'tcx>` is\n-                            // defined as a type alias meaning that `impl<'tcx> Ty<'tcx>`\n-                            // is not actually allowed.\n-                            //\n-                            // I(@lcnr) still kept this branch in so we don't miss this\n-                            // if we ever change it in the future.\n-                            return Some(format!(\"{}<{}>\", name, substs[0]));\n-                        }\n+            }\n+            // Only lint on `&Ty` and `&TyCtxt` if it is used outside of a trait.\n+            Res::SelfTy(None, Some((did, _))) => {\n+                if let ty::Adt(adt, substs) = cx.tcx.type_of(did).kind() {\n+                    if let Some(name @ (sym::Ty | sym::TyCtxt)) =\n+                        cx.tcx.get_diagnostic_name(adt.did)\n+                    {\n+                        // NOTE: This path is currently unreachable as `Ty<'tcx>` is\n+                        // defined as a type alias meaning that `impl<'tcx> Ty<'tcx>`\n+                        // is not actually allowed.\n+                        //\n+                        // I(@lcnr) still kept this branch in so we don't miss this\n+                        // if we ever change it in the future.\n+                        return Some(format!(\"{}<{}>\", name, substs[0]));\n                     }\n                 }\n-                _ => (),\n             }\n+            _ => (),\n         }\n     }\n "}, {"sha": "63bdcea87f8170a97df6b45df4f8bc8d8032e910", "filename": "compiler/rustc_macros/src/hash_stable.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_macros%2Fsrc%2Fhash_stable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_macros%2Fsrc%2Fhash_stable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fhash_stable.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -24,11 +24,9 @@ fn parse_attributes(field: &syn::Field) -> Attributes {\n                         }\n                         if meta.path().is_ident(\"project\") {\n                             if let Meta::List(list) = meta {\n-                                if let Some(nested) = list.nested.iter().next() {\n-                                    if let NestedMeta::Meta(meta) = nested {\n-                                        attrs.project = meta.path().get_ident().cloned();\n-                                        any_attr = true;\n-                                    }\n+                                if let Some(NestedMeta::Meta(meta)) = list.nested.iter().next() {\n+                                    attrs.project = meta.path().get_ident().cloned();\n+                                    any_attr = true;\n                                 }\n                             }\n                         }"}, {"sha": "bd5cda15b91abcfc18b6a6cc8ac089d25e7c5389", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -309,7 +309,7 @@ impl Collector<'tcx> {\n                     .libs\n                     .iter()\n                     .filter_map(|lib| lib.name.as_ref())\n-                    .any(|n| &n.as_str() == &lib.name);\n+                    .any(|n| n.as_str() == lib.name);\n                 if new_name.is_empty() {\n                     self.tcx.sess.err(&format!(\n                         \"an empty renaming target was specified for library `{}`\","}, {"sha": "82486a6a5f2e277a75b639edd84c5127e1af0750", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -210,10 +210,10 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n             required_gates.iter().copied().filter(|&g| !features.enabled(g)).collect();\n \n         match missing_gates.as_slice() {\n-            &[] => struct_span_err!(tcx.sess, span, E0744, \"{}\", msg).emit(),\n+            [] => struct_span_err!(tcx.sess, span, E0744, \"{}\", msg).emit(),\n \n-            &[missing_primary, ref missing_secondary @ ..] => {\n-                let mut err = feature_err(&tcx.sess.parse_sess, missing_primary, span, &msg);\n+            [missing_primary, ref missing_secondary @ ..] => {\n+                let mut err = feature_err(&tcx.sess.parse_sess, *missing_primary, span, &msg);\n \n                 // If multiple feature gates would be required to enable this expression, include\n                 // them as help messages. Don't emit a separate error for each missing feature gate."}, {"sha": "4acbb11b13f76295a290e49519088776416e605b", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -1344,12 +1344,10 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         } else {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n-            if let PathResult::Module(module) =\n+            if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n                 self.resolve_path(mod_path, Some(TypeNS), false, span, CrateLint::No)\n             {\n-                if let ModuleOrUniformRoot::Module(module) = module {\n-                    self.r.add_module_candidates(module, &mut names, &filter_fn);\n-                }\n+                self.r.add_module_candidates(module, &mut names, &filter_fn);\n             }\n         }\n "}, {"sha": "55931d29f6db0ceb5e8ccfd3d548f0db04f3c19b", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -1931,20 +1931,18 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             break;\n                         }\n                     }\n-                    hir::TyKind::Path(ref qpath) => {\n-                        if let QPath::Resolved(_, path) = qpath {\n-                            let last_segment = &path.segments[path.segments.len() - 1];\n-                            let generics = last_segment.args();\n-                            for arg in generics.args.iter() {\n-                                if let GenericArg::Lifetime(lt) = arg {\n-                                    if lt.name.ident() == name {\n-                                        elide_use = Some(lt.span);\n-                                        break;\n-                                    }\n+                    hir::TyKind::Path(QPath::Resolved(_, path)) => {\n+                        let last_segment = &path.segments[path.segments.len() - 1];\n+                        let generics = last_segment.args();\n+                        for arg in generics.args.iter() {\n+                            if let GenericArg::Lifetime(lt) = arg {\n+                                if lt.name.ident() == name {\n+                                    elide_use = Some(lt.span);\n+                                    break;\n                                 }\n                             }\n-                            break;\n                         }\n+                        break;\n                     }\n                     _ => {}\n                 }"}, {"sha": "8a9e8739d037cef48304a5cbd443cbd38918b37f", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -914,7 +914,7 @@ pub fn build_configuration(sess: &Session, mut user_cfg: CrateConfig) -> CrateCo\n pub(super) fn build_target_config(\n     opts: &Options,\n     target_override: Option<Target>,\n-    sysroot: &PathBuf,\n+    sysroot: &Path,\n ) -> Target {\n     let target_result = target_override.map_or_else(\n         || Target::search(&opts.target_triple, sysroot),"}, {"sha": "71464ad97145bafe9e4266ee91ec8284be129c24", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -881,7 +881,7 @@ mod parse {\n         match v {\n             Some(s) => {\n                 if !slot.is_empty() {\n-                    slot.push_str(\",\");\n+                    slot.push(',');\n                 }\n                 slot.push_str(s);\n                 true"}, {"sha": "dfc64f37e4c46b84c7e1ee9a02ee1282a6feba67", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -194,10 +194,8 @@ impl<S: Encoder> Encodable<S> for RealFileName {\n         encoder.emit_enum(|encoder| match *self {\n             RealFileName::LocalPath(ref local_path) => {\n                 encoder.emit_enum_variant(\"LocalPath\", 0, 1, |encoder| {\n-                    Ok({\n-                        encoder\n-                            .emit_enum_variant_arg(true, |encoder| local_path.encode(encoder))?;\n-                    })\n+                    encoder.emit_enum_variant_arg(true, |encoder| local_path.encode(encoder))?;\n+                    Ok(())\n                 })\n             }\n \n@@ -206,12 +204,9 @@ impl<S: Encoder> Encodable<S> for RealFileName {\n                     // For privacy and build reproducibility, we must not embed host-dependant path in artifacts\n                     // if they have been remapped by --remap-path-prefix\n                     assert!(local_path.is_none());\n-                    Ok({\n-                        encoder\n-                            .emit_enum_variant_arg(true, |encoder| local_path.encode(encoder))?;\n-                        encoder\n-                            .emit_enum_variant_arg(false, |encoder| virtual_name.encode(encoder))?;\n-                    })\n+                    encoder.emit_enum_variant_arg(true, |encoder| local_path.encode(encoder))?;\n+                    encoder.emit_enum_variant_arg(false, |encoder| virtual_name.encode(encoder))?;\n+                    Ok(())\n                 }),\n         })\n     }"}, {"sha": "69b90bf10fe6a131d3c96e6da2b27d1db190ffe1", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -2071,7 +2071,7 @@ impl Target {\n     /// JSON decoding.\n     pub fn search(\n         target_triple: &TargetTriple,\n-        sysroot: &PathBuf,\n+        sysroot: &Path,\n     ) -> Result<(Target, TargetWarnings), String> {\n         use rustc_serialize::json;\n         use std::env;"}, {"sha": "0b88eb7572ad0fd3f240113bc9171fd3aa87c599", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -2000,19 +2000,14 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let sized_trait = self.tcx.lang_items().sized_trait();\n         debug!(\"maybe_suggest_unsized_generics: generics.params={:?}\", generics.params);\n         debug!(\"maybe_suggest_unsized_generics: generics.where_clause={:?}\", generics.where_clause);\n-        let param = generics\n-            .params\n-            .iter()\n-            .filter(|param| param.span == span)\n-            .filter(|param| {\n-                // Check that none of the explicit trait bounds is `Sized`. Assume that an explicit\n-                // `Sized` bound is there intentionally and we don't need to suggest relaxing it.\n-                param\n-                    .bounds\n-                    .iter()\n-                    .all(|bound| bound.trait_ref().and_then(|tr| tr.trait_def_id()) != sized_trait)\n-            })\n-            .next();\n+        let param = generics.params.iter().filter(|param| param.span == span).find(|param| {\n+            // Check that none of the explicit trait bounds is `Sized`. Assume that an explicit\n+            // `Sized` bound is there intentionally and we don't need to suggest relaxing it.\n+            param\n+                .bounds\n+                .iter()\n+                .all(|bound| bound.trait_ref().and_then(|tr| tr.trait_def_id()) != sized_trait)\n+        });\n         let param = match param {\n             Some(param) => param,\n             _ => return,"}, {"sha": "9bbe52591472885655471958f9bf7632c42385b4", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -446,7 +446,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (&ty::Str, &ty::Array(arr, _) | &ty::Slice(arr)) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprKind::Lit(_) = expr.kind {\n                         if let Ok(src) = sm.span_to_snippet(sp) {\n-                            if let Some(_) = replace_prefix(&src, \"b\\\"\", \"\\\"\") {\n+                            if replace_prefix(&src, \"b\\\"\", \"\\\"\").is_some() {\n                                 let pos = sp.lo() + BytePos(1);\n                                 return Some((\n                                     sp.with_hi(pos),\n@@ -462,7 +462,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (&ty::Array(arr, _) | &ty::Slice(arr), &ty::Str) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprKind::Lit(_) = expr.kind {\n                         if let Ok(src) = sm.span_to_snippet(sp) {\n-                            if let Some(_) = replace_prefix(&src, \"\\\"\", \"b\\\"\") {\n+                            if replace_prefix(&src, \"\\\"\", \"b\\\"\").is_some() {\n                                 return Some((\n                                     sp.shrink_to_lo(),\n                                     \"consider adding a leading `b`\","}, {"sha": "3cba7991ccaf308f5657233e1b00426d52700c11", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -2058,8 +2058,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Option<(&Vec<ty::FieldDef>, SubstsRef<'tcx>)> {\n         debug!(\"get_field_candidates(span: {:?}, base_t: {:?}\", span, base_t);\n \n-        let mut autoderef = self.autoderef(span, base_t);\n-        while let Some((base_t, _)) = autoderef.next() {\n+        for (base_t, _) in self.autoderef(span, base_t) {\n             match base_t.kind() {\n                 ty::Adt(base_def, substs) if !base_def.is_enum() => {\n                     let fields = &base_def.non_enum_variant().fields;"}, {"sha": "e5da33d113e7c48e95ab6e626d4e0dc8ff0711f8", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -176,7 +176,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             .type_var_origin(ty)\n             .map(|origin| origin.span)\n             .unwrap_or(rustc_span::DUMMY_SP);\n-        let oty = self.inner.borrow().opaque_types_vars.get(ty).map(|v| *v);\n+        let oty = self.inner.borrow().opaque_types_vars.get(ty).copied();\n         if let Some(opaque_ty) = oty {\n             debug!(\n                 \"fallback_opaque_type_vars(ty={:?}): falling back to opaque type {:?}\","}, {"sha": "7d9483201f6a547c5e3ae407e473a8ad19f7e729", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -1045,34 +1045,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         call_expr: &'tcx hir::Expr<'tcx>,\n     ) {\n         if let hir::ExprKind::Call(path, _) = &call_expr.kind {\n-            if let hir::ExprKind::Path(qpath) = &path.kind {\n-                if let hir::QPath::Resolved(_, path) = &qpath {\n-                    for error in errors {\n-                        if let ty::PredicateKind::Trait(predicate) =\n-                            error.obligation.predicate.kind().skip_binder()\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = &path.kind {\n+                for error in errors {\n+                    if let ty::PredicateKind::Trait(predicate) =\n+                        error.obligation.predicate.kind().skip_binder()\n+                    {\n+                        // If any of the type arguments in this path segment caused the\n+                        // `FulfillmentError`, point at its span (#61860).\n+                        for arg in path\n+                            .segments\n+                            .iter()\n+                            .filter_map(|seg| seg.args.as_ref())\n+                            .flat_map(|a| a.args.iter())\n                         {\n-                            // If any of the type arguments in this path segment caused the\n-                            // `FulfillmentError`, point at its span (#61860).\n-                            for arg in path\n-                                .segments\n-                                .iter()\n-                                .filter_map(|seg| seg.args.as_ref())\n-                                .flat_map(|a| a.args.iter())\n-                            {\n-                                if let hir::GenericArg::Type(hir_ty) = &arg {\n-                                    if let hir::TyKind::Path(hir::QPath::TypeRelative(..)) =\n-                                        &hir_ty.kind\n-                                    {\n-                                        // Avoid ICE with associated types. As this is best\n-                                        // effort only, it's ok to ignore the case. It\n-                                        // would trigger in `is_send::<T::AssocType>();`\n-                                        // from `typeck-default-trait-impl-assoc-type.rs`.\n-                                    } else {\n-                                        let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, hir_ty);\n-                                        let ty = self.resolve_vars_if_possible(ty);\n-                                        if ty == predicate.self_ty() {\n-                                            error.obligation.cause.make_mut().span = hir_ty.span;\n-                                        }\n+                            if let hir::GenericArg::Type(hir_ty) = &arg {\n+                                if let hir::TyKind::Path(hir::QPath::TypeRelative(..)) =\n+                                    &hir_ty.kind\n+                                {\n+                                    // Avoid ICE with associated types. As this is best\n+                                    // effort only, it's ok to ignore the case. It\n+                                    // would trigger in `is_send::<T::AssocType>();`\n+                                    // from `typeck-default-trait-impl-assoc-type.rs`.\n+                                } else {\n+                                    let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, hir_ty);\n+                                    let ty = self.resolve_vars_if_possible(ty);\n+                                    if ty == predicate.self_ty() {\n+                                        error.obligation.cause.make_mut().span = hir_ty.span;\n                                     }\n                                 }\n                             }"}, {"sha": "13f475cd9e02681073e542c3e961e3f373e5e6f5", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -1208,7 +1208,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let edition_fix = candidates\n                 .iter()\n                 .find(|did| self.tcx.is_diagnostic_item(sym::TryInto, **did))\n-                .map(|&d| d);\n+                .copied();\n \n             err.help(\"items from traits can only be used if the trait is in scope\");\n             let msg = format!("}, {"sha": "dd09474533119d90e12108dfc05bfb3f44702a77", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -399,12 +399,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 };\n                 if let Ref(_, rty, _) = lhs_ty.kind() {\n-                    if {\n-                        self.infcx.type_is_copy_modulo_regions(self.param_env, rty, lhs_expr.span)\n-                            && self\n-                                .lookup_op_method(rty, &[rhs_ty], Op::Binary(op, is_assign))\n-                                .is_ok()\n-                    } {\n+                    if self.infcx.type_is_copy_modulo_regions(self.param_env, rty, lhs_expr.span)\n+                        && self.lookup_op_method(rty, &[rhs_ty], Op::Binary(op, is_assign)).is_ok()\n+                    {\n                         if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n                             let msg = &format!(\n                                 \"`{}{}` can be used on `{}`, you can dereference `{}`\","}, {"sha": "c1adc2894ccfcd365541de28932c886fb71ae4f5", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46b8e7488eae116722196e8390c1bd2ea2e396cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=46b8e7488eae116722196e8390c1bd2ea2e396cf", "patch": "@@ -435,9 +435,7 @@ fn check_gat_where_clauses(\n         let written_predicates: ty::GenericPredicates<'_> =\n             tcx.explicit_predicates_of(trait_item.def_id);\n         let mut clauses: Vec<_> = clauses\n-            .drain_filter(|clause| {\n-                written_predicates.predicates.iter().find(|p| &p.0 == clause).is_none()\n-            })\n+            .drain_filter(|clause| !written_predicates.predicates.iter().any(|p| &p.0 == clause))\n             .map(|clause| format!(\"{}\", clause))\n             .collect();\n         // We sort so that order is predictable"}]}