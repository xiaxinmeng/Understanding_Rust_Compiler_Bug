{"sha": "deb90c33ccee849821de5f3a8e26d8d9a2e774e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlYjkwYzMzY2NlZTg0OTgyMWRlNWYzYThlMjZkOGQ5YTJlNzc0ZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-25T14:10:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-25T14:10:10Z"}, "message": "Auto merge of #42052 - kennytm:fix-42007-ice-on-decode-lint-id, r=nikomatsakis\n\nRefactor: Move the mutable parts out of LintStore. Fix #42007.\n\n* #42007 happens because the `Session` `LintStore` is emptied when linting.\n* The `Session` `LintStore` is emptied because the checker (`Early`/`LateContext`) wants ownership.\n* The checker wants ownership because it wants to mutate the pass objects and lint levels.\n\nThe ownership of the whole store is not essential, only the lint levels and pass objects need to be owned. Therefore, these parts are extracted out of the `LintStore` into a separate structure `LintSession`. The \"check crates\" methods can operate on `&mut LintSession` instead of `&mut LintStore`.\n\nThis is a minor *breaking change* for lint writers since the `LintContext` trait is changed: the `mut_lints` and `level_stack` methods are removed. But no one outside of `librustc/lint/context.rs` is using these functions, so it should be safe.", "tree": {"sha": "24190dd924e9141b80e25fa0e4ed644bc98f9226", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24190dd924e9141b80e25fa0e4ed644bc98f9226"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/deb90c33ccee849821de5f3a8e26d8d9a2e774e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/deb90c33ccee849821de5f3a8e26d8d9a2e774e5", "html_url": "https://github.com/rust-lang/rust/commit/deb90c33ccee849821de5f3a8e26d8d9a2e774e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/deb90c33ccee849821de5f3a8e26d8d9a2e774e5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d86d134c381af68daf7604a03cb7ea38284da44d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d86d134c381af68daf7604a03cb7ea38284da44d", "html_url": "https://github.com/rust-lang/rust/commit/d86d134c381af68daf7604a03cb7ea38284da44d"}, {"sha": "b384b18d5d2417616d043602fd023ee48fd4b934", "url": "https://api.github.com/repos/rust-lang/rust/commits/b384b18d5d2417616d043602fd023ee48fd4b934", "html_url": "https://github.com/rust-lang/rust/commit/b384b18d5d2417616d043602fd023ee48fd4b934"}], "stats": {"total": 284, "additions": 198, "deletions": 86}, "files": [{"sha": "e7c8d3285c8fe50c9c76d97b49486e0ce4cffcbb", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 165, "deletions": 86, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/deb90c33ccee849821de5f3a8e26d8d9a2e774e5/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deb90c33ccee849821de5f3a8e26d8d9a2e774e5/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=deb90c33ccee849821de5f3a8e26d8d9a2e774e5", "patch": "@@ -40,6 +40,7 @@ use std::cmp;\n use std::default::Default as StdDefault;\n use std::mem;\n use std::fmt;\n+use std::cell::{Ref, RefCell};\n use syntax::attr;\n use syntax::ast;\n use syntax::symbol::Symbol;\n@@ -61,16 +62,16 @@ pub struct LintStore {\n     lints: Vec<(&'static Lint, bool)>,\n \n     /// Trait objects for each lint pass.\n-    /// This is only `None` while iterating over the objects. See the definition\n-    /// of run_lints.\n+    /// This is only `None` while performing a lint pass. See the definition\n+    /// of `LintSession::new`.\n     early_passes: Option<Vec<EarlyLintPassObject>>,\n     late_passes: Option<Vec<LateLintPassObject>>,\n \n     /// Lints indexed by name.\n     by_name: FxHashMap<String, TargetLint>,\n \n     /// Current levels of each lint, and where they were set.\n-    levels: FxHashMap<LintId, LevelSource>,\n+    levels: LintLevels,\n \n     /// Map of registered lint groups to what lints they expand to. The bool\n     /// is true if the lint group was added by a plugin.\n@@ -79,11 +80,36 @@ pub struct LintStore {\n     /// Extra info for future incompatibility lints, descibing the\n     /// issue or RFC that caused the incompatibility.\n     future_incompatible: FxHashMap<LintId, FutureIncompatibleInfo>,\n+}\n+\n+\n+#[derive(Default)]\n+struct LintLevels {\n+    /// Current levels of each lint, and where they were set.\n+    levels: FxHashMap<LintId, LevelSource>,\n \n     /// Maximum level a lint can be\n     lint_cap: Option<Level>,\n }\n \n+\n+pub struct LintSession<'a, PassObject> {\n+    /// Reference to the store of registered lints.\n+    lints: Ref<'a, LintStore>,\n+\n+    /// The current lint levels.\n+    levels: LintLevels,\n+\n+    /// When recursing into an attributed node of the ast which modifies lint\n+    /// levels, this stack keeps track of the previous lint levels of whatever\n+    /// was modified.\n+    stack: Vec<(LintId, LevelSource)>,\n+\n+    /// Trait objects for each lint pass.\n+    passes: Option<Vec<PassObject>>,\n+}\n+\n+\n /// When you call `add_lint` on the session, you wind up storing one\n /// of these, which records a \"potential lint\" at a particular point.\n #[derive(PartialEq, RustcEncodable, RustcDecodable)]\n@@ -157,34 +183,15 @@ enum FindLintError {\n }\n \n impl LintStore {\n-    fn get_level_source(&self, lint: LintId) -> LevelSource {\n-        match self.levels.get(&lint) {\n-            Some(&s) => s,\n-            None => (Allow, Default),\n-        }\n-    }\n-\n-    fn set_level(&mut self, lint: LintId, mut lvlsrc: LevelSource) {\n-        if let Some(cap) = self.lint_cap {\n-            lvlsrc.0 = cmp::min(lvlsrc.0, cap);\n-        }\n-        if lvlsrc.0 == Allow {\n-            self.levels.remove(&lint);\n-        } else {\n-            self.levels.insert(lint, lvlsrc);\n-        }\n-    }\n-\n     pub fn new() -> LintStore {\n         LintStore {\n             lints: vec![],\n             early_passes: Some(vec![]),\n             late_passes: Some(vec![]),\n             by_name: FxHashMap(),\n-            levels: FxHashMap(),\n+            levels: LintLevels::default(),\n             future_incompatible: FxHashMap(),\n             lint_groups: FxHashMap(),\n-            lint_cap: None,\n         }\n     }\n \n@@ -236,9 +243,7 @@ impl LintStore {\n                 }\n             }\n \n-            if lint.default_level != Allow {\n-                self.levels.insert(id, (lint.default_level, Default));\n-            }\n+            self.levels.set(id, (lint.default_level, Default));\n         }\n     }\n \n@@ -310,18 +315,17 @@ impl LintStore {\n \n             let lint_flag_val = Symbol::intern(&lint_name);\n             match self.find_lint(&lint_name[..], sess, None) {\n-                Ok(lint_id) => self.set_level(lint_id, (level, CommandLine(lint_flag_val))),\n+                Ok(lint_id) => self.levels.set(lint_id, (level, CommandLine(lint_flag_val))),\n                 Err(FindLintError::Removed) => { }\n                 Err(_) => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.0.clone()))\n                                                  .collect::<FxHashMap<&'static str,\n                                                                       Vec<LintId>>>()\n                                                  .get(&lint_name[..]) {\n                         Some(v) => {\n-                            v.iter()\n-                             .map(|lint_id: &LintId|\n-                                     self.set_level(*lint_id, (level, CommandLine(lint_flag_val))))\n-                             .collect::<Vec<()>>();\n+                            for lint_id in v {\n+                                self.levels.set(*lint_id, (level, CommandLine(lint_flag_val)));\n+                            }\n                         }\n                         None => {\n                             // The lint or lint group doesn't exist.\n@@ -333,15 +337,73 @@ impl LintStore {\n             }\n         }\n \n-        self.lint_cap = sess.opts.lint_cap;\n+        self.levels.set_lint_cap(sess.opts.lint_cap);\n+    }\n+}\n+\n+\n+impl LintLevels {\n+    fn get_source(&self, lint: LintId) -> LevelSource {\n+        match self.levels.get(&lint) {\n+            Some(&s) => s,\n+            None => (Allow, Default),\n+        }\n+    }\n+\n+    fn set(&mut self, lint: LintId, mut lvlsrc: LevelSource) {\n         if let Some(cap) = self.lint_cap {\n-            for level in self.levels.iter_mut().map(|p| &mut (p.1).0) {\n-                *level = cmp::min(*level, cap);\n+            lvlsrc.0 = cmp::min(lvlsrc.0, cap);\n+        }\n+        if lvlsrc.0 == Allow {\n+            self.levels.remove(&lint);\n+        } else {\n+            self.levels.insert(lint, lvlsrc);\n+        }\n+    }\n+\n+    fn set_lint_cap(&mut self, lint_cap: Option<Level>) {\n+        self.lint_cap = lint_cap;\n+        if let Some(cap) = lint_cap {\n+            for (_, level) in &mut self.levels {\n+                level.0 = cmp::min(level.0, cap);\n             }\n         }\n     }\n }\n \n+\n+impl<'a, PassObject: LintPassObject> LintSession<'a, PassObject> {\n+    /// Creates a new `LintSession`, by moving out the `LintStore`'s initial\n+    /// lint levels and pass objects. These can be restored using the `restore`\n+    /// method.\n+    fn new(store: &'a RefCell<LintStore>) -> LintSession<'a, PassObject> {\n+        let mut s = store.borrow_mut();\n+        let levels = mem::replace(&mut s.levels, LintLevels::default());\n+        let passes = PassObject::take_passes(&mut *s);\n+        drop(s);\n+        LintSession {\n+            lints: store.borrow(),\n+            stack: Vec::new(),\n+            levels,\n+            passes,\n+        }\n+    }\n+\n+    /// Restores the levels back to the original lint store.\n+    fn restore(self, store: &RefCell<LintStore>) {\n+        drop(self.lints);\n+        let mut s = store.borrow_mut();\n+        s.levels = self.levels;\n+        PassObject::restore_passes(&mut *s, self.passes);\n+    }\n+\n+    fn get_source(&self, lint_id: LintId) -> LevelSource {\n+        self.levels.get_source(lint_id)\n+    }\n+}\n+\n+\n+\n /// Context for lint checking after type checking.\n pub struct LateContext<'a, 'tcx: 'a> {\n     /// Type context we're checking in.\n@@ -356,13 +418,8 @@ pub struct LateContext<'a, 'tcx: 'a> {\n     /// Items accessible from the crate being checked.\n     pub access_levels: &'a AccessLevels,\n \n-    /// The store of registered lints.\n-    lints: LintStore,\n-\n-    /// When recursing into an attributed node of the ast which modifies lint\n-    /// levels, this stack keeps track of the previous lint levels of whatever\n-    /// was modified.\n-    level_stack: Vec<(LintId, LevelSource)>,\n+    /// The store of registered lints and the lint levels.\n+    lint_sess: LintSession<'tcx, LateLintPassObject>,\n }\n \n /// Context for lint checking of the AST, after expansion, before lowering to\n@@ -374,24 +431,19 @@ pub struct EarlyContext<'a> {\n     /// The crate being checked.\n     pub krate: &'a ast::Crate,\n \n-    /// The store of registered lints.\n-    lints: LintStore,\n-\n-    /// When recursing into an attributed node of the ast which modifies lint\n-    /// levels, this stack keeps track of the previous lint levels of whatever\n-    /// was modified.\n-    level_stack: Vec<(LintId, LevelSource)>,\n+    /// The store of registered lints and the lint levels.\n+    lint_sess: LintSession<'a, EarlyLintPassObject>,\n }\n \n /// Convenience macro for calling a `LintPass` method on every pass in the context.\n macro_rules! run_lints { ($cx:expr, $f:ident, $ps:ident, $($args:expr),*) => ({\n     // Move the vector of passes out of `$cx` so that we can\n     // iterate over it mutably while passing `$cx` to the methods.\n-    let mut passes = $cx.mut_lints().$ps.take().unwrap();\n+    let mut passes = $cx.lint_sess_mut().passes.take().unwrap();\n     for obj in &mut passes {\n         obj.$f($cx, $($args),*);\n     }\n-    $cx.mut_lints().$ps = Some(passes);\n+    $cx.lint_sess_mut().passes = Some(passes);\n }) }\n \n /// Parse the lint attributes into a vector, with `Err`s for malformed lint\n@@ -522,25 +574,55 @@ pub fn raw_struct_lint<'a, S>(sess: &'a Session,\n     err\n }\n \n+\n+pub trait LintPassObject: Sized {\n+    fn take_passes(store: &mut LintStore) -> Option<Vec<Self>>;\n+    fn restore_passes(store: &mut LintStore, passes: Option<Vec<Self>>);\n+}\n+\n+impl LintPassObject for EarlyLintPassObject {\n+    fn take_passes(store: &mut LintStore) -> Option<Vec<Self>> {\n+        store.early_passes.take()\n+    }\n+\n+    fn restore_passes(store: &mut LintStore, passes: Option<Vec<Self>>) {\n+        store.early_passes = passes;\n+    }\n+}\n+\n+impl LintPassObject for LateLintPassObject {\n+    fn take_passes(store: &mut LintStore) -> Option<Vec<Self>> {\n+        store.late_passes.take()\n+    }\n+\n+    fn restore_passes(store: &mut LintStore, passes: Option<Vec<Self>>) {\n+        store.late_passes = passes;\n+    }\n+}\n+\n+\n pub trait LintContext<'tcx>: Sized {\n+    type PassObject: LintPassObject;\n+\n     fn sess(&self) -> &Session;\n     fn lints(&self) -> &LintStore;\n-    fn mut_lints(&mut self) -> &mut LintStore;\n-    fn level_stack(&mut self) -> &mut Vec<(LintId, LevelSource)>;\n+    fn lint_sess(&self) -> &LintSession<'tcx, Self::PassObject>;\n+    fn lint_sess_mut(&mut self) -> &mut LintSession<'tcx, Self::PassObject>;\n     fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]);\n     fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]);\n \n     /// Get the level of `lint` at the current position of the lint\n     /// traversal.\n     fn current_level(&self, lint: &'static Lint) -> Level {\n-        self.lints().levels.get(&LintId::of(lint)).map_or(Allow, |&(lvl, _)| lvl)\n+        self.lint_sess().get_source(LintId::of(lint)).0\n     }\n \n     fn level_src(&self, lint: &'static Lint) -> Option<LevelSource> {\n-        self.lints().levels.get(&LintId::of(lint)).map(|ls| match ls {\n+        let ref levels = self.lint_sess().levels;\n+        levels.levels.get(&LintId::of(lint)).map(|ls| match ls {\n             &(Warn, _) => {\n                 let lint_id = LintId::of(builtin::WARNINGS);\n-                let warn_src = self.lints().get_level_source(lint_id);\n+                let warn_src = levels.get_source(lint_id);\n                 if warn_src.0 != Warn {\n                     warn_src\n                 } else {\n@@ -674,7 +756,7 @@ pub trait LintContext<'tcx>: Sized {\n             let lint_attr_name = result.expect(\"lint attribute should be well-formed\").0;\n \n             for (lint_id, level, span) in v {\n-                let (now, now_source) = self.lints().get_level_source(lint_id);\n+                let (now, now_source) = self.lint_sess().get_source(lint_id);\n                 if now == Forbid && level != Forbid {\n                     let lint_name = lint_id.to_string();\n                     let mut diag_builder = struct_span_err!(self.sess(), span, E0453,\n@@ -693,10 +775,10 @@ pub trait LintContext<'tcx>: Sized {\n                         }\n                     }.emit()\n                 } else if now != level {\n-                    let src = self.lints().get_level_source(lint_id).1;\n-                    self.level_stack().push((lint_id, (now, src)));\n+                    let cx = self.lint_sess_mut();\n+                    cx.stack.push((lint_id, (now, now_source)));\n                     pushed += 1;\n-                    self.mut_lints().set_level(lint_id, (level, Node(lint_attr_name, span)));\n+                    cx.levels.set(lint_id, (level, Node(lint_attr_name, span)));\n                 }\n             }\n         }\n@@ -706,9 +788,10 @@ pub trait LintContext<'tcx>: Sized {\n         self.exit_attrs(attrs);\n \n         // rollback\n+        let cx = self.lint_sess_mut();\n         for _ in 0..pushed {\n-            let (lint, lvlsrc) = self.level_stack().pop().unwrap();\n-            self.mut_lints().set_level(lint, lvlsrc);\n+            let (lint, lvlsrc) = cx.stack.pop().unwrap();\n+            cx.levels.set(lint, lvlsrc);\n         }\n     }\n }\n@@ -717,35 +800,32 @@ pub trait LintContext<'tcx>: Sized {\n impl<'a> EarlyContext<'a> {\n     fn new(sess: &'a Session,\n            krate: &'a ast::Crate) -> EarlyContext<'a> {\n-        // We want to own the lint store, so move it out of the session. Remember\n-        // to put it back later...\n-        let lint_store = mem::replace(&mut *sess.lint_store.borrow_mut(),\n-                                      LintStore::new());\n         EarlyContext {\n             sess: sess,\n             krate: krate,\n-            lints: lint_store,\n-            level_stack: vec![],\n+            lint_sess: LintSession::new(&sess.lint_store),\n         }\n     }\n }\n \n impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n+    type PassObject = LateLintPassObject;\n+\n     /// Get the overall compiler `Session` object.\n     fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }\n \n     fn lints(&self) -> &LintStore {\n-        &self.lints\n+        &*self.lint_sess.lints\n     }\n \n-    fn mut_lints(&mut self) -> &mut LintStore {\n-        &mut self.lints\n+    fn lint_sess(&self) -> &LintSession<'tcx, Self::PassObject> {\n+        &self.lint_sess\n     }\n \n-    fn level_stack(&mut self) -> &mut Vec<(LintId, LevelSource)> {\n-        &mut self.level_stack\n+    fn lint_sess_mut(&mut self) -> &mut LintSession<'tcx, Self::PassObject> {\n+        &mut self.lint_sess\n     }\n \n     fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n@@ -760,21 +840,23 @@ impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n }\n \n impl<'a> LintContext<'a> for EarlyContext<'a> {\n+    type PassObject = EarlyLintPassObject;\n+\n     /// Get the overall compiler `Session` object.\n     fn sess(&self) -> &Session {\n         &self.sess\n     }\n \n     fn lints(&self) -> &LintStore {\n-        &self.lints\n+        &*self.lint_sess.lints\n     }\n \n-    fn mut_lints(&mut self) -> &mut LintStore {\n-        &mut self.lints\n+    fn lint_sess(&self) -> &LintSession<'a, Self::PassObject> {\n+        &self.lint_sess\n     }\n \n-    fn level_stack(&mut self) -> &mut Vec<(LintId, LevelSource)> {\n-        &mut self.level_stack\n+    fn lint_sess_mut(&mut self) -> &mut LintSession<'a, Self::PassObject> {\n+        &mut self.lint_sess\n     }\n \n     fn enter_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n@@ -1191,7 +1273,7 @@ fn check_lint_name_attribute(cx: &LateContext, attr: &ast::Attribute) {\n                 continue;\n             }\n             Ok((lint_name, _, span)) => {\n-                match check_lint_name(&cx.lints, &lint_name.as_str()) {\n+                match check_lint_name(&cx.lint_sess.lints, &lint_name.as_str()) {\n                     CheckLintNameResult::Ok => (),\n                     CheckLintNameResult::Warning(ref msg) => {\n                         cx.span_lint(builtin::RENAMED_AND_REMOVED_LINTS,\n@@ -1246,15 +1328,12 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     let krate = tcx.hir.krate();\n \n-    // We want to own the lint store, so move it out of the session.\n-    let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(), LintStore::new());\n     let mut cx = LateContext {\n         tcx: tcx,\n         tables: &ty::TypeckTables::empty(),\n         krate: krate,\n         access_levels: access_levels,\n-        lints: lint_store,\n-        level_stack: vec![],\n+        lint_sess: LintSession::new(&tcx.sess.lint_store),\n     };\n \n     // Visit the whole crate.\n@@ -1278,8 +1357,8 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         }\n     }\n \n-    // Put the lint store back in the session.\n-    mem::replace(&mut *tcx.sess.lint_store.borrow_mut(), cx.lints);\n+    // Put the lint store levels and passes back in the session.\n+    cx.lint_sess.restore(&tcx.sess.lint_store);\n }\n \n pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n@@ -1302,8 +1381,8 @@ pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n         run_lints!(cx, check_crate_post, early_passes, krate);\n     });\n \n-    // Put the lint store back in the session.\n-    mem::replace(&mut *sess.lint_store.borrow_mut(), cx.lints);\n+    // Put the lint store levels and passes back in the session.\n+    cx.lint_sess.restore(&sess.lint_store);\n \n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code."}, {"sha": "b965e916f98f0e8f6c5e5e3c8b03abd1f96a2a23", "filename": "src/test/run-pass/auxiliary/issue_42007_s.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/deb90c33ccee849821de5f3a8e26d8d9a2e774e5/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue_42007_s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deb90c33ccee849821de5f3a8e26d8d9a2e774e5/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue_42007_s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue_42007_s.rs?ref=deb90c33ccee849821de5f3a8e26d8d9a2e774e5", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[repr(u8)]\n+pub enum E {\n+    B = 1 as u8,\n+}\n\\ No newline at end of file"}, {"sha": "cc7e3bc372cc6303121c94ea572b8c7c654c441a", "filename": "src/test/run-pass/issue-42007.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/deb90c33ccee849821de5f3a8e26d8d9a2e774e5/src%2Ftest%2Frun-pass%2Fissue-42007.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deb90c33ccee849821de5f3a8e26d8d9a2e774e5/src%2Ftest%2Frun-pass%2Fissue-42007.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-42007.rs?ref=deb90c33ccee849821de5f3a8e26d8d9a2e774e5", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue_42007_s.rs\n+\n+extern crate issue_42007_s;\n+\n+enum I {\n+    E(issue_42007_s::E),\n+}\n+\n+fn main() {}"}]}