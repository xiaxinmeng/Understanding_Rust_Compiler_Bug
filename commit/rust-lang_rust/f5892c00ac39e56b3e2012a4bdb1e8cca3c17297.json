{"sha": "f5892c00ac39e56b3e2012a4bdb1e8cca3c17297", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1ODkyYzAwYWMzOWU1NmIzZTIwMTJhNGJkYjFlOGNjYTNjMTcyOTc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-04-01T01:00:52Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-04-02T08:39:41Z"}, "message": "Translate the virtual `/rustc/$hash` prefix back to a real directory.", "tree": {"sha": "0082431be211e51790c1671e383a80876a3abb40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0082431be211e51790c1671e383a80876a3abb40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5892c00ac39e56b3e2012a4bdb1e8cca3c17297", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5892c00ac39e56b3e2012a4bdb1e8cca3c17297", "html_url": "https://github.com/rust-lang/rust/commit/f5892c00ac39e56b3e2012a4bdb1e8cca3c17297", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5892c00ac39e56b3e2012a4bdb1e8cca3c17297/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b793f403bdfbcc0ff3e15ed8177a81d79ba4a29b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b793f403bdfbcc0ff3e15ed8177a81d79ba4a29b", "html_url": "https://github.com/rust-lang/rust/commit/b793f403bdfbcc0ff3e15ed8177a81d79ba4a29b"}], "stats": {"total": 139, "additions": 121, "deletions": 18}, "files": [{"sha": "b14352d7f4ba0ddd25e4232d3e32f7aa2d3f1f51", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f5892c00ac39e56b3e2012a4bdb1e8cca3c17297/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5892c00ac39e56b3e2012a4bdb1e8cca3c17297/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=f5892c00ac39e56b3e2012a4bdb1e8cca3c17297", "patch": "@@ -1022,8 +1022,13 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_HOST_CRT_STATIC\", x.to_string());\n         }\n \n-        if let Some(map) = self.build.debuginfo_map(GitRepo::Rustc) {\n+        if let Some(map_to) = self.build.debuginfo_map_to(GitRepo::Rustc) {\n+            let map = format!(\"{}={}\", self.build.src.display(), map_to);\n             cargo.env(\"RUSTC_DEBUGINFO_MAP\", map);\n+\n+            // `rustc` needs to know the virtual `/rustc/$hash` we're mapping to,\n+            // in order to opportunistically reverse it later.\n+            cargo.env(\"CFG_VIRTUAL_RUST_SOURCE_BASE_DIR\", map_to);\n         }\n \n         // Enable usage of unstable features"}, {"sha": "e6a1814c4f7e7fcfb998898364d07bf459055c8c", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f5892c00ac39e56b3e2012a4bdb1e8cca3c17297/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5892c00ac39e56b3e2012a4bdb1e8cca3c17297/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=f5892c00ac39e56b3e2012a4bdb1e8cca3c17297", "patch": "@@ -22,7 +22,7 @@ use serde::Deserialize;\n use crate::builder::Cargo;\n use crate::dist;\n use crate::native;\n-use crate::util::{exe, is_dylib};\n+use crate::util::{exe, is_dylib, symlink_dir};\n use crate::{Compiler, GitRepo, Mode};\n \n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n@@ -633,6 +633,30 @@ impl Step for Sysroot {\n         };\n         let _ = fs::remove_dir_all(&sysroot);\n         t!(fs::create_dir_all(&sysroot));\n+\n+        // Symlink the source root into the same location inside the sysroot,\n+        // where `rust-src` component would go (`$sysroot/lib/rustlib/src/rust`),\n+        // so that any tools relying on `rust-src` also work for local builds,\n+        // and also for translating the virtual `/rustc/$hash` back to the real\n+        // directory (for running tests with `rust.remap-debuginfo = true`).\n+        let sysroot_lib_rustlib_src = sysroot.join(\"lib/rustlib/src\");\n+        t!(fs::create_dir_all(&sysroot_lib_rustlib_src));\n+        let sysroot_lib_rustlib_src_rust = sysroot_lib_rustlib_src.join(\"rust\");\n+        if let Err(e) = symlink_dir(&builder.config, &builder.src, &sysroot_lib_rustlib_src_rust) {\n+            eprintln!(\n+                \"warning: creating symbolic link `{}` to `{}` failed with {}\",\n+                sysroot_lib_rustlib_src_rust.display(),\n+                builder.src.display(),\n+                e,\n+            );\n+            if builder.config.rust_remap_debuginfo {\n+                eprintln!(\n+                    \"warning: some `src/test/ui` tests will fail when lacking `{}`\",\n+                    sysroot_lib_rustlib_src_rust.display(),\n+                );\n+            }\n+        }\n+\n         INTERNER.intern_path(sysroot)\n     }\n }"}, {"sha": "31bbd92cd620511e5bc06819f791856be534f416", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f5892c00ac39e56b3e2012a4bdb1e8cca3c17297/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5892c00ac39e56b3e2012a4bdb1e8cca3c17297/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=f5892c00ac39e56b3e2012a4bdb1e8cca3c17297", "patch": "@@ -740,19 +740,18 @@ impl Build {\n         self.config.jobs.unwrap_or_else(|| num_cpus::get() as u32)\n     }\n \n-    fn debuginfo_map(&self, which: GitRepo) -> Option<String> {\n+    fn debuginfo_map_to(&self, which: GitRepo) -> Option<String> {\n         if !self.config.rust_remap_debuginfo {\n             return None;\n         }\n \n-        let path = match which {\n+        match which {\n             GitRepo::Rustc => {\n                 let sha = self.rust_sha().unwrap_or(channel::CFG_RELEASE_NUM);\n-                format!(\"/rustc/{}\", sha)\n+                Some(format!(\"/rustc/{}\", sha))\n             }\n-            GitRepo::Llvm => String::from(\"/rustc/llvm\"),\n-        };\n-        Some(format!(\"{}={}\", self.src.display(), path))\n+            GitRepo::Llvm => Some(String::from(\"/rustc/llvm\")),\n+        }\n     }\n \n     /// Returns the path to the C compiler for the target specified.\n@@ -787,7 +786,8 @@ impl Build {\n             base.push(\"-fno-omit-frame-pointer\".into());\n         }\n \n-        if let Some(map) = self.debuginfo_map(which) {\n+        if let Some(map_to) = self.debuginfo_map_to(which) {\n+            let map = format!(\"{}={}\", self.src.display(), map_to);\n             let cc = self.cc(target);\n             if cc.ends_with(\"clang\") || cc.ends_with(\"gcc\") {\n                 base.push(format!(\"-fdebug-prefix-map={}\", map));"}, {"sha": "7d5c58ecea2a135c1c076d2d8f04bb562468670f", "filename": "src/librustc_metadata/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5892c00ac39e56b3e2012a4bdb1e8cca3c17297/src%2Flibrustc_metadata%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5892c00ac39e56b3e2012a4bdb1e8cca3c17297/src%2Flibrustc_metadata%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fbuild.rs?ref=f5892c00ac39e56b3e2012a4bdb1e8cca3c17297", "patch": "@@ -1,4 +1,5 @@\n fn main() {\n     println!(\"cargo:rerun-if-changed=build.rs\");\n     println!(\"cargo:rerun-if-env-changed=CFG_VERSION\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_VIRTUAL_RUST_SOURCE_BASE_DIR\");\n }"}, {"sha": "7ccec830a305b118041e3f26fba61d1d6629d8d2", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f5892c00ac39e56b3e2012a4bdb1e8cca3c17297/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5892c00ac39e56b3e2012a4bdb1e8cca3c17297/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=f5892c00ac39e56b3e2012a4bdb1e8cca3c17297", "patch": "@@ -32,7 +32,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::util::common::record_time;\n use rustc_serialize::{opaque, Decodable, Decoder, SpecializedDecoder};\n use rustc_session::Session;\n-use rustc_span::source_map::{self, respan, Spanned};\n+use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{self, hygiene::MacroKind, BytePos, Pos, Span, DUMMY_SP};\n \n@@ -41,6 +41,7 @@ use proc_macro::bridge::client::ProcMacro;\n use std::io;\n use std::mem;\n use std::num::NonZeroUsize;\n+use std::path::Path;\n use std::u32;\n \n pub use cstore_impl::{provide, provide_extern};\n@@ -427,7 +428,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         // we can call `imported_source_files` for the proper crate, and binary search\n         // through the returned slice using our span.\n         let imported_source_files = if tag == TAG_VALID_SPAN_LOCAL {\n-            self.cdata().imported_source_files(sess.source_map())\n+            self.cdata().imported_source_files(sess)\n         } else {\n             // FIXME: We don't decode dependencies of proc-macros.\n             // Remove this once #69976 is merged\n@@ -457,7 +458,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             self.last_source_file_index = 0;\n \n             let foreign_data = self.cdata().cstore.get_crate_data(cnum);\n-            foreign_data.imported_source_files(sess.source_map())\n+            foreign_data.imported_source_files(sess)\n         };\n \n         let source_file = {\n@@ -1460,10 +1461,45 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     ///\n     /// Proc macro crates don't currently export spans, so this function does not have\n     /// to work for them.\n-    fn imported_source_files(\n-        &self,\n-        local_source_map: &source_map::SourceMap,\n-    ) -> &'a [ImportedSourceFile] {\n+    fn imported_source_files(&self, sess: &Session) -> &'a [ImportedSourceFile] {\n+        // Translate the virtual `/rustc/$hash` prefix back to a real directory\n+        // that should hold actual sources, where possible.\n+        let virtual_rust_source_base_dir = option_env!(\"CFG_VIRTUAL_RUST_SOURCE_BASE_DIR\")\n+            .map(Path::new)\n+            .filter(|_| {\n+                // Only spend time on further checks if we have what to translate *to*.\n+                sess.real_rust_source_base_dir.is_some()\n+            })\n+            .filter(|virtual_dir| {\n+                // Don't translate away `/rustc/$hash` if we're still remapping to it,\n+                // since that means we're still building `std`/`rustc` that need it,\n+                // and we don't want the real path to leak into codegen/debuginfo.\n+                !sess.opts.remap_path_prefix.iter().any(|(_from, to)| to == virtual_dir)\n+            });\n+        let try_to_translate_virtual_to_real = |name: &mut rustc_span::FileName| {\n+            debug!(\n+                \"try_to_translate_virtual_to_real(name={:?}): \\\n+                 virtual_rust_source_base_dir={:?}, real_rust_source_base_dir={:?}\",\n+                name, virtual_rust_source_base_dir, sess.real_rust_source_base_dir,\n+            );\n+\n+            if let Some(virtual_dir) = virtual_rust_source_base_dir {\n+                if let Some(real_dir) = &sess.real_rust_source_base_dir {\n+                    if let rustc_span::FileName::Real(path) = name {\n+                        if let Ok(rest) = path.strip_prefix(virtual_dir) {\n+                            let new_path = real_dir.join(rest);\n+                            debug!(\n+                                \"try_to_translate_virtual_to_real: `{}` -> `{}`\",\n+                                path.display(),\n+                                new_path.display(),\n+                            );\n+                            *path = new_path;\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+\n         self.cdata.source_map_import_info.init_locking(|| {\n             let external_source_map = self.root.source_map.decode(self);\n \n@@ -1472,7 +1508,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                     // We can't reuse an existing SourceFile, so allocate a new one\n                     // containing the information we need.\n                     let rustc_span::SourceFile {\n-                        name,\n+                        mut name,\n                         name_was_remapped,\n                         src_hash,\n                         start_pos,\n@@ -1485,6 +1521,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                         ..\n                     } = source_file_to_import;\n \n+                    // If this file's path has been remapped to `/rustc/$hash`,\n+                    // we might be able to reverse that (also see comments above,\n+                    // on `try_to_translate_virtual_to_real`).\n+                    // FIXME(eddyb) we could check `name_was_remapped` here,\n+                    // but in practice it seems to be always `false`.\n+                    try_to_translate_virtual_to_real(&mut name);\n+\n                     let source_length = (end_pos - start_pos).to_usize();\n \n                     // Translate line-start positions and multibyte character\n@@ -1505,7 +1548,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                         np.pos = np.pos - start_pos;\n                     }\n \n-                    let local_version = local_source_map.new_imported_source_file(\n+                    let local_version = sess.source_map().new_imported_source_file(\n                         name,\n                         name_was_remapped,\n                         src_hash,"}, {"sha": "b16681c72e7d13509121578a648b43c60b664d90", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f5892c00ac39e56b3e2012a4bdb1e8cca3c17297/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5892c00ac39e56b3e2012a4bdb1e8cca3c17297/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=f5892c00ac39e56b3e2012a4bdb1e8cca3c17297", "patch": "@@ -140,6 +140,15 @@ pub struct Session {\n     /// Options range from returning the error without a backtrace to returning an error\n     /// and immediately printing the backtrace to stderr.\n     pub ctfe_backtrace: Lock<CtfeBacktrace>,\n+\n+    /// Base directory containing the `src/` for the Rust standard library, and\n+    /// potentially `rustc` as well, if we can can find it. Right now it's always\n+    /// `$sysroot/lib/rustlib/src/rust` (i.e. the `rustup` `rust-src` component).\n+    ///\n+    /// This directory is what the virtual `/rustc/$hash` is translated back to,\n+    /// if Rust was built with path remapping to `/rustc/$hash` enabled\n+    /// (the `rust.remap-debuginfo` option in `config.toml`).\n+    pub real_rust_source_base_dir: Option<PathBuf>,\n }\n \n pub struct PerfStats {\n@@ -1056,6 +1065,26 @@ fn build_session_(\n         _ => CtfeBacktrace::Disabled,\n     });\n \n+    // Try to find a directory containing the Rust `src`, for more details see\n+    // the doc comment on the `real_rust_source_base_dir` field.\n+    let real_rust_source_base_dir = {\n+        // This is the location used by the `rust-src` `rustup` component.\n+        let mut candidate = sysroot.join(\"lib/rustlib/src/rust\");\n+        if let Ok(metadata) = candidate.symlink_metadata() {\n+            // Replace the symlink rustbuild creates, with its destination.\n+            // We could try to use `fs::canonicalize` instead, but that might\n+            // produce unnecessarily verbose path.\n+            if metadata.file_type().is_symlink() {\n+                if let Ok(symlink_dest) = std::fs::read_link(&candidate) {\n+                    candidate = symlink_dest;\n+                }\n+            }\n+        }\n+\n+        // Only use this directory if it has a file we can expect to always find.\n+        if candidate.join(\"src/libstd/lib.rs\").is_file() { Some(candidate) } else { None }\n+    };\n+\n     let sess = Session {\n         target: target_cfg,\n         host,\n@@ -1094,6 +1123,7 @@ fn build_session_(\n         confused_type_with_std_module: Lock::new(Default::default()),\n         system_library_path: OneThread::new(RefCell::new(Default::default())),\n         ctfe_backtrace,\n+        real_rust_source_base_dir,\n     };\n \n     validate_commandline_args_with_session_available(&sess);"}]}