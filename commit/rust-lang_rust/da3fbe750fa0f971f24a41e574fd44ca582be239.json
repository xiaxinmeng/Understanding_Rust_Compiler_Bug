{"sha": "da3fbe750fa0f971f24a41e574fd44ca582be239", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhM2ZiZTc1MGZhMGY5NzFmMjRhNDFlNTc0ZmQ0NGNhNTgyYmUyMzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-08T22:27:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-08T22:27:06Z"}, "message": "Auto merge of #45867 - michaelwoerister:check-ich-stability, r=nikomatsakis\n\nincr.comp.: Verify stability of incr. comp. hashes and clean up various other things.\n\nThe main contribution of this PR is that it adds the `-Z incremental-verify-ich` functionality. Normally, when the red-green tracking system determines that a certain query result has not changed, it does not re-compute the incr. comp. hash (ICH) for that query result because that hash is already known. `-Z incremental-verify-ich` tells the compiler to re-hash the query result and compare the new hash against the cached hash. This is a rather thorough way of\n- testing hashing implementation stability,\n- finding missing `[input]` annotations on `DepNodes`, and\n- finding missing read-edges,\n\nsince both a missed read and a missing `[input]` annotation can lead to something being marked as green instead of red and thus will have a different hash than it should have.\n\nCase in point, implementing this verification logic and activating it for all `src/test/incremental` tests has revealed several such oversights, all of which are fixed in this PR.\n\nr? @nikomatsakis", "tree": {"sha": "111002871878f519abc8135ac7846827aad49727", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/111002871878f519abc8135ac7846827aad49727"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da3fbe750fa0f971f24a41e574fd44ca582be239", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da3fbe750fa0f971f24a41e574fd44ca582be239", "html_url": "https://github.com/rust-lang/rust/commit/da3fbe750fa0f971f24a41e574fd44ca582be239", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da3fbe750fa0f971f24a41e574fd44ca582be239/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02004ef78383cb174a41df7735a552823fa10b90", "url": "https://api.github.com/repos/rust-lang/rust/commits/02004ef78383cb174a41df7735a552823fa10b90", "html_url": "https://github.com/rust-lang/rust/commit/02004ef78383cb174a41df7735a552823fa10b90"}, {"sha": "d01b89b94827f7d818397d8b4654e93306219ec0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d01b89b94827f7d818397d8b4654e93306219ec0", "html_url": "https://github.com/rust-lang/rust/commit/d01b89b94827f7d818397d8b4654e93306219ec0"}], "stats": {"total": 577, "additions": 330, "deletions": 247}, "files": [{"sha": "89ce4bf928ad859e8ecc4424ef55cc9dd6595a56", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 26, "deletions": 56, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -459,10 +459,6 @@ define_dep_nodes!( <'tcx>\n     // Represents metadata from an extern crate.\n     [input] CrateMetadata(CrateNum),\n \n-    // Represents some artifact that we save to disk. Note that these\n-    // do not have a def-id as part of their identifier.\n-    [] WorkProduct(WorkProductId),\n-\n     // Represents different phases in the compiler.\n     [] RegionScopeTree(DefId),\n     [eval_always] Coherence,\n@@ -537,38 +533,19 @@ define_dep_nodes!( <'tcx>\n     // The set of impls for a given trait.\n     [] TraitImpls(DefId),\n \n-    [] AllLocalTraitImpls,\n-\n-    // Trait selection cache is a little funny. Given a trait\n-    // reference like `Foo: SomeTrait<Bar>`, there could be\n-    // arbitrarily many def-ids to map on in there (e.g., `Foo`,\n-    // `SomeTrait`, `Bar`). We could have a vector of them, but it\n-    // requires heap-allocation, and trait sel in general can be a\n-    // surprisingly hot path. So instead we pick two def-ids: the\n-    // trait def-id, and the first def-id in the input types. If there\n-    // is no def-id in the input types, then we use the trait def-id\n-    // again. So for example:\n-    //\n-    // - `i32: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n-    // - `u32: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n-    // - `Clone: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n-    // - `Vec<i32>: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Vec }`\n-    // - `String: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: String }`\n-    // - `Foo: Trait<Bar>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n-    // - `Foo: Trait<i32>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n-    // - `(Foo, Bar): Trait` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n-    // - `i32: Trait<Foo>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n-    //\n-    // You can see that we map many trait refs to the same\n-    // trait-select node.  This is not a problem, it just means\n-    // imprecision in our dep-graph tracking.  The important thing is\n-    // that for any given trait-ref, we always map to the **same**\n-    // trait-select node.\n+    [input] AllLocalTraitImpls,\n+\n     [anon] TraitSelect,\n \n     [] ParamEnv(DefId),\n     [] DescribeDef(DefId),\n-    [] DefSpan(DefId),\n+\n+    // FIXME(mw): DefSpans are not really inputs since they are derived from\n+    // HIR. But at the moment HIR hashing still contains some hacks that allow\n+    // to make type debuginfo to be source location independent. Declaring\n+    // DefSpan an input makes sure that changes to these are always detected\n+    // regardless of HIR hashing.\n+    [input] DefSpan(DefId),\n     [] LookupStability(DefId),\n     [] LookupDeprecationEntry(DefId),\n     [] ItemBodyNestedBodies(DefId),\n@@ -588,7 +565,7 @@ define_dep_nodes!( <'tcx>\n     [eval_always] LintLevels,\n     [] Specializes { impl1: DefId, impl2: DefId },\n     [input] InScopeTraits(DefIndex),\n-    [] ModuleExports(DefId),\n+    [input] ModuleExports(DefId),\n     [] IsSanitizerRuntime(CrateNum),\n     [] IsProfilerRuntime(CrateNum),\n     [] GetPanicStrategy(CrateNum),\n@@ -598,37 +575,37 @@ define_dep_nodes!( <'tcx>\n     [] NativeLibraries(CrateNum),\n     [] PluginRegistrarFn(CrateNum),\n     [] DeriveRegistrarFn(CrateNum),\n-    [] CrateDisambiguator(CrateNum),\n-    [] CrateHash(CrateNum),\n-    [] OriginalCrateName(CrateNum),\n+    [input] CrateDisambiguator(CrateNum),\n+    [input] CrateHash(CrateNum),\n+    [input] OriginalCrateName(CrateNum),\n \n     [] ImplementationsOfTrait { krate: CrateNum, trait_id: DefId },\n     [] AllTraitImplementations(CrateNum),\n \n     [] IsDllimportForeignItem(DefId),\n     [] IsStaticallyIncludedForeignItem(DefId),\n     [] NativeLibraryKind(DefId),\n-    [] LinkArgs,\n+    [input] LinkArgs,\n \n-    [] NamedRegion(DefIndex),\n-    [] IsLateBound(DefIndex),\n-    [] ObjectLifetimeDefaults(DefIndex),\n+    [input] NamedRegion(DefIndex),\n+    [input] IsLateBound(DefIndex),\n+    [input] ObjectLifetimeDefaults(DefIndex),\n \n     [] Visibility(DefId),\n     [] DepKind(CrateNum),\n-    [] CrateName(CrateNum),\n+    [input] CrateName(CrateNum),\n     [] ItemChildren(DefId),\n     [] ExternModStmtCnum(DefId),\n-    [] GetLangItems,\n+    [input] GetLangItems,\n     [] DefinedLangItems(CrateNum),\n     [] MissingLangItems(CrateNum),\n     [] ExternConstBody(DefId),\n     [] VisibleParentMap,\n     [] MissingExternCrateItem(CrateNum),\n     [] UsedCrateSource(CrateNum),\n-    [] PostorderCnums,\n-    [] HasCloneClosures(CrateNum),\n-    [] HasCopyClosures(CrateNum),\n+    [input] PostorderCnums,\n+    [input] HasCloneClosures(CrateNum),\n+    [input] HasCopyClosures(CrateNum),\n \n     // This query is not expected to have inputs -- as a result, it's\n     // not a good candidate for \"replay\" because it's essentially a\n@@ -638,19 +615,19 @@ define_dep_nodes!( <'tcx>\n     // may save a bit of time.\n     [anon] EraseRegionsTy { ty: Ty<'tcx> },\n \n-    [] Freevars(DefId),\n-    [] MaybeUnusedTraitImport(DefId),\n+    [input] Freevars(DefId),\n+    [input] MaybeUnusedTraitImport(DefId),\n     [] MaybeUnusedExternCrates,\n     [] StabilityIndex,\n-    [] AllCrateNums,\n+    [input] AllCrateNums,\n     [] ExportedSymbols(CrateNum),\n     [eval_always] CollectAndPartitionTranslationItems,\n     [] ExportName(DefId),\n     [] ContainsExternIndicator(DefId),\n     [] IsTranslatedFunction(DefId),\n     [] CodegenUnit(InternedString),\n     [] CompileCodegenUnit(InternedString),\n-    [] OutputFilenames,\n+    [input] OutputFilenames,\n     [anon] NormalizeTy,\n     // We use this for most things when incr. comp. is turned off.\n     [] Null,\n@@ -800,13 +777,6 @@ impl WorkProductId {\n             hash: fingerprint\n         }\n     }\n-\n-    pub fn to_dep_node(self) -> DepNode {\n-        DepNode {\n-            kind: DepKind::WorkProduct,\n-            hash: self.hash,\n-        }\n-    }\n }\n \n impl_stable_hash_for!(struct ::dep_graph::WorkProductId {"}, {"sha": "1433fa81f333e711523d8e4209276eec32c24c76", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 83, "deletions": 51, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -511,60 +511,67 @@ impl DepGraph {\n                     return None\n                 }\n                 None => {\n-                    if dep_dep_node.kind.is_input() {\n-                        // This input does not exist anymore.\n-                        debug_assert!(dep_dep_node.extract_def_id(tcx).is_none(),\n-                                      \"Encountered input {:?} without color\",\n-                                      dep_dep_node);\n-                        debug!(\"try_mark_green({:?}) - END - dependency {:?} \\\n-                                was deleted input\", dep_node, dep_dep_node);\n-                        return None;\n+                    // We don't know the state of this dependency. If it isn't\n+                    // an input node, let's try to mark it green recursively.\n+                    if !dep_dep_node.kind.is_input() {\n+                         debug!(\"try_mark_green({:?}) --- state of dependency {:?} \\\n+                                 is unknown, trying to mark it green\", dep_node,\n+                                 dep_dep_node);\n+\n+                        if let Some(node_index) = self.try_mark_green(tcx, dep_dep_node) {\n+                            debug!(\"try_mark_green({:?}) --- managed to MARK \\\n+                                    dependency {:?} as green\", dep_node, dep_dep_node);\n+                            current_deps.push(node_index);\n+                            continue;\n+                        }\n+                    } else if cfg!(debug_assertions) {\n+                        match dep_dep_node.kind {\n+                            DepKind::Hir |\n+                            DepKind::HirBody |\n+                            DepKind::CrateMetadata => {\n+                                assert!(dep_dep_node.extract_def_id(tcx).is_none(),\n+                                    \"Input {:?} should have been pre-allocated but wasn't.\",\n+                                    dep_dep_node);\n+                            }\n+                            _ => {\n+                                // For other kinds of inputs it's OK to be\n+                                // forced.\n+                            }\n+                        }\n                     }\n \n-                    debug!(\"try_mark_green({:?}) --- state of dependency {:?} \\\n-                            is unknown, trying to mark it green\", dep_node,\n-                            dep_dep_node);\n-\n-                    // We don't know the state of this dependency. Let's try to\n-                    // mark it green.\n-                    if let Some(node_index) = self.try_mark_green(tcx, dep_dep_node) {\n-                        debug!(\"try_mark_green({:?}) --- managed to MARK \\\n-                                dependency {:?} as green\", dep_node, dep_dep_node);\n-                        current_deps.push(node_index);\n-                    } else {\n-                        // We failed to mark it green, so we try to force the query.\n-                        debug!(\"try_mark_green({:?}) --- trying to force \\\n-                                dependency {:?}\", dep_node, dep_dep_node);\n-                        if ::ty::maps::force_from_dep_node(tcx, dep_dep_node) {\n-                            let dep_dep_node_color = data.colors\n-                                                         .borrow()\n-                                                         .get(dep_dep_node)\n-                                                         .cloned();\n-                            match dep_dep_node_color {\n-                                Some(DepNodeColor::Green(node_index)) => {\n-                                    debug!(\"try_mark_green({:?}) --- managed to \\\n-                                            FORCE dependency {:?} to green\",\n-                                            dep_node, dep_dep_node);\n-                                    current_deps.push(node_index);\n-                                }\n-                                Some(DepNodeColor::Red) => {\n-                                    debug!(\"try_mark_green({:?}) - END - \\\n-                                            dependency {:?} was red after forcing\",\n-                                           dep_node,\n-                                           dep_dep_node);\n-                                    return None\n-                                }\n-                                None => {\n-                                    bug!(\"try_mark_green() - Forcing the DepNode \\\n-                                          should have set its color\")\n-                                }\n+                    // We failed to mark it green, so we try to force the query.\n+                    debug!(\"try_mark_green({:?}) --- trying to force \\\n+                            dependency {:?}\", dep_node, dep_dep_node);\n+                    if ::ty::maps::force_from_dep_node(tcx, dep_dep_node) {\n+                        let dep_dep_node_color = data.colors\n+                                                     .borrow()\n+                                                     .get(dep_dep_node)\n+                                                     .cloned();\n+                        match dep_dep_node_color {\n+                            Some(DepNodeColor::Green(node_index)) => {\n+                                debug!(\"try_mark_green({:?}) --- managed to \\\n+                                        FORCE dependency {:?} to green\",\n+                                        dep_node, dep_dep_node);\n+                                current_deps.push(node_index);\n+                            }\n+                            Some(DepNodeColor::Red) => {\n+                                debug!(\"try_mark_green({:?}) - END - \\\n+                                        dependency {:?} was red after forcing\",\n+                                       dep_node,\n+                                       dep_dep_node);\n+                                return None\n+                            }\n+                            None => {\n+                                bug!(\"try_mark_green() - Forcing the DepNode \\\n+                                      should have set its color\")\n                             }\n-                        } else {\n-                            // The DepNode could not be forced.\n-                            debug!(\"try_mark_green({:?}) - END - dependency {:?} \\\n-                                    could not be forced\", dep_node, dep_dep_node);\n-                            return None\n                         }\n+                    } else {\n+                        // The DepNode could not be forced.\n+                        debug!(\"try_mark_green({:?}) - END - dependency {:?} \\\n+                                could not be forced\", dep_node, dep_dep_node);\n+                        return None\n                     }\n                 }\n             }\n@@ -777,7 +784,30 @@ impl CurrentDepGraph {\n             read_set: _,\n             reads\n         } = popped_node {\n-            debug_assert_eq!(node, key);\n+            assert_eq!(node, key);\n+\n+            // If this is an input node, we expect that it either has no\n+            // dependencies, or that it just depends on DepKind::CrateMetadata\n+            // or DepKind::Krate. This happens for some \"thin wrapper queries\"\n+            // like `crate_disambiguator` which sometimes have zero deps (for\n+            // when called for LOCAL_CRATE) or they depend on a CrateMetadata\n+            // node.\n+            if cfg!(debug_assertions) {\n+                if node.kind.is_input() && reads.len() > 0 &&\n+                   // FIXME(mw): Special case for DefSpan until Spans are handled\n+                   //            better in general.\n+                   node.kind != DepKind::DefSpan &&\n+                    reads.iter().any(|&i| {\n+                        !(self.nodes[i].kind == DepKind::CrateMetadata ||\n+                          self.nodes[i].kind == DepKind::Krate)\n+                    })\n+                {\n+                    bug!(\"Input node {:?} with unexpected reads: {:?}\",\n+                        node,\n+                        reads.iter().map(|&i| self.nodes[i]).collect::<Vec<_>>())\n+                }\n+            }\n+\n             self.alloc_node(node, reads)\n         } else {\n             bug!(\"pop_task() - Expected regular task to be popped\")\n@@ -798,6 +828,8 @@ impl CurrentDepGraph {\n             read_set: _,\n             reads\n         } = popped_node {\n+            debug_assert!(!kind.is_input());\n+\n             let mut fingerprint = self.anon_id_seed;\n             let mut hasher = StableHasher::new();\n "}, {"sha": "ba89961adc68739c561f664da02a6eec0eaed4a0", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -838,7 +838,10 @@ impl<'a> LoweringContext<'a> {\n                         return n;\n                     }\n                     assert!(!def_id.is_local());\n-                    let n = self.cstore.item_generics_cloned_untracked(def_id).regions.len();\n+                    let n = self.cstore\n+                                .item_generics_cloned_untracked(def_id, self.sess)\n+                                .regions\n+                                .len();\n                     self.type_def_lifetime_params.insert(def_id, n);\n                     n\n                 });"}, {"sha": "453d30dde7595382b86e744d499d6f2651a9fda1", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -416,6 +416,12 @@ impl<'hir> Map<'hir> {\n     /// if the node is a body owner, otherwise returns `None`.\n     pub fn maybe_body_owned_by(&self, id: NodeId) -> Option<BodyId> {\n         if let Some(entry) = self.find_entry(id) {\n+            if self.dep_graph.is_fully_enabled() {\n+                let hir_id_owner = self.node_to_hir_id(id).owner;\n+                let def_path_hash = self.definitions.def_path_hash(hir_id_owner);\n+                self.dep_graph.read(def_path_hash.to_dep_node(DepKind::HirBody));\n+            }\n+\n             if let Some(body_id) = entry.associated_body() {\n                 // For item-like things and closures, the associated\n                 // body has its own distinct id, and that is returned\n@@ -530,6 +536,12 @@ impl<'hir> Map<'hir> {\n     /// from a node to the root of the ast (unless you get the same id back here\n     /// that can happen if the id is not in the map itself or is just weird).\n     pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n+        if self.dep_graph.is_fully_enabled() {\n+            let hir_id_owner = self.node_to_hir_id(id).owner;\n+            let def_path_hash = self.definitions.def_path_hash(hir_id_owner);\n+            self.dep_graph.read(def_path_hash.to_dep_node(DepKind::HirBody));\n+        }\n+\n         self.find_entry(id).and_then(|x| x.parent_node()).unwrap_or(id)\n     }\n "}, {"sha": "f204d352842bfe41fc01b0e30bfe668bb6eebe3e", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -227,6 +227,8 @@ impl<'gcx> StableHashingContext<'gcx> {\n         match binop {\n             hir::BiAdd |\n             hir::BiSub |\n+            hir::BiShl |\n+            hir::BiShr |\n             hir::BiMul => self.overflow_checks_enabled,\n \n             hir::BiDiv |\n@@ -237,8 +239,6 @@ impl<'gcx> StableHashingContext<'gcx> {\n             hir::BiBitXor |\n             hir::BiBitAnd |\n             hir::BiBitOr |\n-            hir::BiShl |\n-            hir::BiShr |\n             hir::BiEq |\n             hir::BiLt |\n             hir::BiLe |"}, {"sha": "6b78cd473be8ffc1df38886526e845aeda358474", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -356,33 +356,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Block {\n             targeted_by_break,\n         } = *self;\n \n-        let non_item_stmts = || stmts.iter().filter(|stmt| {\n-            match stmt.node {\n-                hir::StmtDecl(ref decl, _) => {\n-                    match decl.node {\n-                        // If this is a declaration of a nested item, we don't\n-                        // want to leave any trace of it in the hash value, not\n-                        // even that it exists. Otherwise changing the position\n-                        // of nested items would invalidate the containing item\n-                        // even though that does not constitute a semantic\n-                        // change.\n-                        hir::DeclItem(_) => false,\n-                        hir::DeclLocal(_) => true\n-                    }\n-                }\n-                hir::StmtExpr(..) |\n-                hir::StmtSemi(..) => true\n-            }\n-        });\n-\n-        let count = non_item_stmts().count();\n-\n-        count.hash_stable(hcx, hasher);\n-\n-        for stmt in non_item_stmts() {\n-            stmt.hash_stable(hcx, hasher);\n-        }\n-\n+        stmts.hash_stable(hcx, hasher);\n         expr.hash_stable(hcx, hasher);\n         rules.hash_stable(hcx, hasher);\n         span.hash_stable(hcx, hasher);"}, {"sha": "628538b41c5d8ab9812e401ea2badf3475882717", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -273,7 +273,7 @@ pub trait CrateStore {\n     fn item_children_untracked(&self, did: DefId, sess: &Session) -> Vec<def::Export>;\n     fn load_macro_untracked(&self, did: DefId, sess: &Session) -> LoadedMacro;\n     fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n-    fn item_generics_cloned_untracked(&self, def: DefId) -> ty::Generics;\n+    fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics;\n     fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssociatedItem;\n     fn postorder_cnums_untracked(&self) -> Vec<CrateNum>;\n \n@@ -327,7 +327,7 @@ impl CrateStore for DummyCrateStore {\n         { bug!(\"crate_data_as_rc_any\") }\n     // item info\n     fn visibility_untracked(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n-    fn item_generics_cloned_untracked(&self, def: DefId) -> ty::Generics\n+    fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics\n         { bug!(\"item_generics_cloned\") }\n \n     // trait/impl-item info"}, {"sha": "ffd06ee8a2e3abad7da087c578e789bbe5423790", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -1001,8 +1001,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 &map.object_lifetime_defaults[&id]\n             } else {\n                 let cstore = self.cstore;\n+                let sess = self.sess;\n                 self.xcrate_object_lifetime_defaults.entry(def_id).or_insert_with(|| {\n-                    cstore.item_generics_cloned_untracked(def_id).types.into_iter().map(|def| {\n+                    cstore.item_generics_cloned_untracked(def_id, sess)\n+                          .types\n+                          .into_iter()\n+                          .map(|def| {\n                         def.object_lifetime_default\n                     }).collect()\n                 })"}, {"sha": "ffb8144e07e5cb6c03475026d4f3d4f80b8469f4", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -1046,6 +1046,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"print high-level information about incremental reuse (or the lack thereof)\"),\n     incremental_dump_hash: bool = (false, parse_bool, [UNTRACKED],\n         \"dump hash information in textual format to stdout\"),\n+    incremental_verify_ich: bool = (false, parse_bool, [UNTRACKED],\n+        \"verify incr. comp. hashes of green query instances\"),\n     dump_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n           \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n     query_dep_graph: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "24148bcc83f37a76924c5ae0e1e87df89c496615", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -327,7 +327,8 @@ macro_rules! define_maps {\n                         return Self::load_from_disk_and_cache_in_memory(tcx,\n                                                                         key,\n                                                                         span,\n-                                                                        dep_node_index)\n+                                                                        dep_node_index,\n+                                                                        &dep_node)\n                     }\n                 }\n \n@@ -372,7 +373,8 @@ macro_rules! define_maps {\n             fn load_from_disk_and_cache_in_memory(tcx: TyCtxt<'a, $tcx, 'lcx>,\n                                                   key: $K,\n                                                   span: Span,\n-                                                  dep_node_index: DepNodeIndex)\n+                                                  dep_node_index: DepNodeIndex,\n+                                                  dep_node: &DepNode)\n                                                   -> Result<$V, CycleError<'a, $tcx>>\n             {\n                 debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n@@ -390,6 +392,32 @@ macro_rules! define_maps {\n                     })\n                 })?;\n \n+                // If -Zincremental-verify-ich is specified, re-hash results from\n+                // the cache and make sure that they have the expected fingerprint.\n+                if tcx.sess.opts.debugging_opts.incremental_verify_ich {\n+                    use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n+                    use ich::Fingerprint;\n+\n+                    assert!(Some(tcx.dep_graph.fingerprint_of(dep_node)) ==\n+                            tcx.dep_graph.prev_fingerprint_of(dep_node),\n+                            \"Fingerprint for green query instance not loaded \\\n+                             from cache: {:?}\", dep_node);\n+\n+                    debug!(\"BEGIN verify_ich({:?})\", dep_node);\n+                    let mut hcx = tcx.create_stable_hashing_context();\n+                    let mut hasher = StableHasher::new();\n+\n+                    result.hash_stable(&mut hcx, &mut hasher);\n+\n+                    let new_hash: Fingerprint = hasher.finish();\n+                    debug!(\"END verify_ich({:?})\", dep_node);\n+\n+                    let old_hash = tcx.dep_graph.fingerprint_of(dep_node);\n+\n+                    assert!(new_hash == old_hash, \"Found unstable fingerprints \\\n+                        for {:?}\", dep_node);\n+                }\n+\n                 if tcx.sess.opts.debugging_opts.query_dep_graph {\n                     tcx.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n                 }\n@@ -693,9 +721,8 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::EraseRegionsTy |\n         DepKind::NormalizeTy |\n \n-        // These are just odd\n-        DepKind::Null |\n-        DepKind::WorkProduct => {\n+        // This one should never occur in this context\n+        DepKind::Null => {\n             bug!(\"force_from_dep_node() - Encountered {:?}\", dep_node.kind)\n         }\n "}, {"sha": "155097cdbe26c5e452e915afe17bef36c4cfde4d", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -258,14 +258,15 @@ impl<'a> CrateLoader<'a> {\n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n         let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n-            crate_root.def_path_table.decode(&metadata)\n+            crate_root.def_path_table.decode((&metadata, self.sess))\n         });\n \n-        let exported_symbols = crate_root.exported_symbols.decode(&metadata).collect();\n-\n+        let exported_symbols = crate_root.exported_symbols\n+                                         .decode((&metadata, self.sess))\n+                                         .collect();\n         let trait_impls = crate_root\n             .impls\n-            .decode(&metadata)\n+            .decode((&metadata, self.sess))\n             .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n             .collect();\n \n@@ -298,7 +299,7 @@ impl<'a> CrateLoader<'a> {\n         let dllimports: FxHashSet<_> = cmeta\n             .root\n             .native_libraries\n-            .decode(&cmeta)\n+            .decode((&cmeta, self.sess))\n             .filter(|lib| relevant_lib(self.sess, lib) &&\n                           lib.kind == cstore::NativeLibraryKind::NativeUnknown)\n             .flat_map(|lib| {\n@@ -685,14 +686,15 @@ impl<'a> CrateLoader<'a> {\n         let mut needs_panic_runtime = attr::contains_name(&krate.attrs,\n                                                           \"needs_panic_runtime\");\n \n+        let sess = self.sess;\n         self.cstore.iter_crate_data(|cnum, data| {\n             needs_panic_runtime = needs_panic_runtime ||\n-                                  data.needs_panic_runtime();\n-            if data.is_panic_runtime() {\n+                                  data.needs_panic_runtime(sess);\n+            if data.is_panic_runtime(sess) {\n                 // Inject a dependency from all #![needs_panic_runtime] to this\n                 // #![panic_runtime] crate.\n                 self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                          &|data| data.needs_panic_runtime());\n+                                          &|data| data.needs_panic_runtime(sess));\n                 runtime_found = runtime_found || data.dep_kind.get() == DepKind::Explicit;\n             }\n         });\n@@ -728,7 +730,7 @@ impl<'a> CrateLoader<'a> {\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n-        if !data.is_panic_runtime() {\n+        if !data.is_panic_runtime(self.sess) {\n             self.sess.err(&format!(\"the crate `{}` is not a panic runtime\",\n                                    name));\n         }\n@@ -740,7 +742,7 @@ impl<'a> CrateLoader<'a> {\n \n         self.sess.injected_panic_runtime.set(Some(cnum));\n         self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                  &|data| data.needs_panic_runtime());\n+                                  &|data| data.needs_panic_runtime(self.sess));\n     }\n \n     fn inject_sanitizer_runtime(&mut self) {\n@@ -835,7 +837,7 @@ impl<'a> CrateLoader<'a> {\n                                        PathKind::Crate, dep_kind);\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n-                if !data.is_sanitizer_runtime() {\n+                if !data.is_sanitizer_runtime(self.sess) {\n                     self.sess.err(&format!(\"the crate `{}` is not a sanitizer runtime\",\n                                            name));\n                 }\n@@ -856,7 +858,7 @@ impl<'a> CrateLoader<'a> {\n                                    PathKind::Crate, dep_kind);\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n-            if !data.is_profiler_runtime() {\n+            if !data.is_profiler_runtime(self.sess) {\n                 self.sess.err(&format!(\"the crate `profiler_builtins` is not \\\n                                         a profiler runtime\"));\n             }\n@@ -875,7 +877,7 @@ impl<'a> CrateLoader<'a> {\n         let mut needs_allocator = attr::contains_name(&krate.attrs,\n                                                       \"needs_allocator\");\n         self.cstore.iter_crate_data(|_, data| {\n-            needs_allocator = needs_allocator || data.needs_allocator();\n+            needs_allocator = needs_allocator || data.needs_allocator(self.sess);\n         });\n         if !needs_allocator {\n             return\n@@ -997,7 +999,7 @@ impl<'a> CrateLoader<'a> {\n             Some(data) => {\n                 // We have an allocator. We detect separately what kind it is, to allow for some\n                 // flexibility in misconfiguration.\n-                let attrs = data.get_item_attrs(CRATE_DEF_INDEX);\n+                let attrs = data.get_item_attrs(CRATE_DEF_INDEX, self.sess);\n                 let kind_interned = attr::first_attr_value_str_by_name(&attrs, \"rustc_alloc_kind\")\n                     .map(Symbol::as_str);\n                 let kind_str = kind_interned"}, {"sha": "a86b55e269d418720b77f572feb29993b885327e", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefIndex};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n-use rustc::session::CrateDisambiguator;\n+use rustc::session::{Session, CrateDisambiguator};\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n@@ -176,8 +176,8 @@ impl CrateMetadata {\n         self.root.disambiguator\n     }\n \n-    pub fn needs_allocator(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn needs_allocator(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_name(&attrs, \"needs_allocator\")\n     }\n \n@@ -189,43 +189,43 @@ impl CrateMetadata {\n         self.root.has_default_lib_allocator.clone()\n     }\n \n-    pub fn is_panic_runtime(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_panic_runtime(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_name(&attrs, \"panic_runtime\")\n     }\n \n-    pub fn needs_panic_runtime(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn needs_panic_runtime(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_name(&attrs, \"needs_panic_runtime\")\n     }\n \n-    pub fn is_compiler_builtins(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_compiler_builtins(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_name(&attrs, \"compiler_builtins\")\n     }\n \n-    pub fn is_sanitizer_runtime(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_sanitizer_runtime(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_name(&attrs, \"sanitizer_runtime\")\n     }\n \n-    pub fn is_profiler_runtime(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_profiler_runtime(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_name(&attrs, \"profiler_runtime\")\n     }\n \n-    pub fn is_no_builtins(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_no_builtins(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_name(&attrs, \"no_builtins\")\n     }\n \n-     pub fn has_copy_closures(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+     pub fn has_copy_closures(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_feature_attr(&attrs, \"copy_closures\")\n     }\n \n-    pub fn has_clone_closures(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn has_clone_closures(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_feature_attr(&attrs, \"clone_closures\")\n     }\n "}, {"sha": "8dcfb4c34b5b247a7eed442a948bacc17530716e", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -99,11 +99,13 @@ impl IntoArgs for (CrateNum, DefId) {\n \n provide! { <'tcx> tcx, def_id, other, cdata,\n     type_of => { cdata.get_type(def_id.index, tcx) }\n-    generics_of => { tcx.alloc_generics(cdata.get_generics(def_id.index)) }\n+    generics_of => {\n+        tcx.alloc_generics(cdata.get_generics(def_id.index, tcx.sess))\n+    }\n     predicates_of => { cdata.get_predicates(def_id.index, tcx) }\n     super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n     trait_def => {\n-        tcx.alloc_trait_def(cdata.get_trait_def(def_id.index))\n+        tcx.alloc_trait_def(cdata.get_trait_def(def_id.index, tcx.sess))\n     }\n     adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n     adt_destructor => {\n@@ -153,7 +155,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     lookup_deprecation_entry => {\n         cdata.get_deprecation(def_id.index).map(DeprecationEntry::external)\n     }\n-    item_attrs => { cdata.get_item_attrs(def_id.index) }\n+    item_attrs => { cdata.get_item_attrs(def_id.index, tcx.sess) }\n     // FIXME(#38501) We've skipped a `read` on the `HirBody` of\n     // a `fn` when encoding, so the dep-tracking wouldn't work.\n     // This is only used by rustdoc anyway, which shouldn't have\n@@ -171,17 +173,17 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n \n     dylib_dependency_formats => { Rc::new(cdata.get_dylib_dependency_formats()) }\n-    is_panic_runtime => { cdata.is_panic_runtime() }\n-    is_compiler_builtins => { cdata.is_compiler_builtins() }\n+    is_panic_runtime => { cdata.is_panic_runtime(tcx.sess) }\n+    is_compiler_builtins => { cdata.is_compiler_builtins(tcx.sess) }\n     has_global_allocator => { cdata.has_global_allocator() }\n-    is_sanitizer_runtime => { cdata.is_sanitizer_runtime() }\n-    is_profiler_runtime => { cdata.is_profiler_runtime() }\n+    is_sanitizer_runtime => { cdata.is_sanitizer_runtime(tcx.sess) }\n+    is_profiler_runtime => { cdata.is_profiler_runtime(tcx.sess) }\n     panic_strategy => { cdata.panic_strategy() }\n     extern_crate => { Rc::new(cdata.extern_crate.get()) }\n-    is_no_builtins => { cdata.is_no_builtins() }\n+    is_no_builtins => { cdata.is_no_builtins(tcx.sess) }\n     impl_defaultness => { cdata.get_impl_defaultness(def_id.index) }\n     exported_symbol_ids => { Rc::new(cdata.get_exported_symbols()) }\n-    native_libraries => { Rc::new(cdata.get_native_libraries()) }\n+    native_libraries => { Rc::new(cdata.get_native_libraries(tcx.sess)) }\n     plugin_registrar_fn => {\n         cdata.root.plugin_registrar_fn.map(|index| {\n             DefId { krate: def_id.krate, index }\n@@ -237,8 +239,8 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n \n     used_crate_source => { Rc::new(cdata.source.clone()) }\n \n-    has_copy_closures => { cdata.has_copy_closures() }\n-    has_clone_closures => { cdata.has_clone_closures() }\n+    has_copy_closures => { cdata.has_copy_closures(tcx.sess) }\n+    has_clone_closures => { cdata.has_clone_closures(tcx.sess) }\n }\n \n pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {\n@@ -358,8 +360,8 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(def.krate).get_visibility(def.index)\n     }\n \n-    fn item_generics_cloned_untracked(&self, def: DefId) -> ty::Generics {\n-        self.get_crate_data(def.krate).get_generics(def.index)\n+    fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics {\n+        self.get_crate_data(def.krate).get_generics(def.index, sess)\n     }\n \n     fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssociatedItem\n@@ -454,7 +456,7 @@ impl CrateStore for cstore::CStore {\n         let body = filemap_to_stream(&sess.parse_sess, filemap, None);\n \n         // Mark the attrs as used\n-        let attrs = data.get_item_attrs(id.index);\n+        let attrs = data.get_item_attrs(id.index, sess);\n         for attr in attrs.iter() {\n             attr::mark_used(attr);\n         }"}, {"sha": "e63037f4da1efbe8f06ec441f839611fdc15aeda", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -87,6 +87,20 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a MetadataBlob {\n     }\n }\n \n+\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a MetadataBlob, &'a Session) {\n+    fn raw_bytes(self) -> &'a [u8] {\n+        let (blob, _) = self;\n+        &blob.0\n+    }\n+\n+    fn sess(self) -> Option<&'a Session> {\n+        let (_, sess) = self;\n+        Some(sess)\n+    }\n+}\n+\n+\n impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a CrateMetadata {\n     fn raw_bytes(self) -> &'a [u8] {\n         self.blob.raw_bytes()\n@@ -291,7 +305,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let sess = if let Some(sess) = self.sess {\n             sess\n         } else {\n-            return Ok(Span::new(lo, hi, NO_EXPANSION));\n+            bug!(\"Cannot decode Span without Session.\")\n         };\n \n         let (lo, hi) = if lo > hi {\n@@ -313,7 +327,8 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             // originate from the same filemap.\n             let last_filemap = &imported_filemaps[self.last_filemap_index];\n \n-            if lo >= last_filemap.original_start_pos && lo <= last_filemap.original_end_pos &&\n+            if lo >= last_filemap.original_start_pos &&\n+               lo <= last_filemap.original_end_pos &&\n                hi >= last_filemap.original_start_pos &&\n                hi <= last_filemap.original_end_pos {\n                 last_filemap\n@@ -335,8 +350,8 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             }\n         };\n \n-        let lo = (lo - filemap.original_start_pos) + filemap.translated_filemap.start_pos;\n-        let hi = (hi - filemap.original_start_pos) + filemap.translated_filemap.start_pos;\n+        let lo = (lo + filemap.translated_filemap.start_pos) - filemap.original_start_pos;\n+        let hi = (hi + filemap.translated_filemap.start_pos) - filemap.original_start_pos;\n \n         Ok(Span::new(lo, hi, NO_EXPANSION))\n     }\n@@ -521,9 +536,9 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_trait_def(&self, item_id: DefIndex) -> ty::TraitDef {\n+    pub fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n         let data = match self.entry(item_id).kind {\n-            EntryKind::Trait(data) => data.decode(self),\n+            EntryKind::Trait(data) => data.decode((self, sess)),\n             _ => bug!(),\n         };\n \n@@ -607,8 +622,11 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_generics(&self, item_id: DefIndex) -> ty::Generics {\n-        self.entry(item_id).generics.unwrap().decode(self)\n+    pub fn get_generics(&self,\n+                        item_id: DefIndex,\n+                        sess: &Session)\n+                        -> ty::Generics {\n+        self.entry(item_id).generics.unwrap().decode((self, sess))\n     }\n \n     pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n@@ -908,7 +926,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_item_attrs(&self, node_id: DefIndex) -> Rc<[ast::Attribute]> {\n+    pub fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Rc<[ast::Attribute]> {\n         let (node_as, node_index) =\n             (node_id.address_space().index(), node_id.as_array_index());\n         if self.is_proc_macro(node_id) {\n@@ -928,7 +946,7 @@ impl<'a, 'tcx> CrateMetadata {\n         if def_key.disambiguated_data.data == DefPathData::StructCtor {\n             item = self.entry(def_key.parent.unwrap());\n         }\n-        let result: Rc<[ast::Attribute]> = Rc::from(self.get_attributes(&item));\n+        let result: Rc<[ast::Attribute]> = Rc::from(self.get_attributes(&item, sess));\n         let vec_ = &mut self.attribute_cache.borrow_mut()[node_as];\n         if vec_.len() < node_index + 1 {\n             vec_.resize(node_index + 1, None);\n@@ -945,9 +963,9 @@ impl<'a, 'tcx> CrateMetadata {\n             .collect()\n     }\n \n-    fn get_attributes(&self, item: &Entry<'tcx>) -> Vec<ast::Attribute> {\n+    fn get_attributes(&self, item: &Entry<'tcx>, sess: &Session) -> Vec<ast::Attribute> {\n         item.attributes\n-            .decode(self)\n+            .decode((self, sess))\n             .map(|mut attr| {\n                 // Need new unique IDs: old thread-local IDs won't map to new threads.\n                 attr.id = attr::mk_attr_id();\n@@ -1013,8 +1031,8 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n \n-    pub fn get_native_libraries(&self) -> Vec<NativeLibrary> {\n-        self.root.native_libraries.decode(self).collect()\n+    pub fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n+        self.root.native_libraries.decode((self, sess)).collect()\n     }\n \n     pub fn get_dylib_dependency_formats(&self) -> Vec<(CrateNum, LinkagePreference)> {"}, {"sha": "23890905718a85cb8d7cf42c1d1fef05bab182ce", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -125,6 +125,12 @@ pub fn provide_local(providers: &mut Providers) {\n                               None,\n                               SymbolExportLevel::Rust));\n         }\n+\n+        // Sort so we get a stable incr. comp. hash.\n+        local_crate.sort_unstable_by(|&(ref name1, ..), &(ref name2, ..)| {\n+            name1.cmp(name2)\n+        });\n+\n         Arc::new(local_crate)\n     };\n }\n@@ -148,7 +154,7 @@ pub fn provide_extern(providers: &mut Providers) {\n         let special_runtime_crate =\n             tcx.is_panic_runtime(cnum) || tcx.is_compiler_builtins(cnum);\n \n-        let crate_exports = tcx\n+        let mut crate_exports: Vec<_> = tcx\n             .exported_symbol_ids(cnum)\n             .iter()\n             .map(|&def_id| {\n@@ -176,6 +182,11 @@ pub fn provide_extern(providers: &mut Providers) {\n             })\n             .collect();\n \n+        // Sort so we get a stable incr. comp. hash.\n+        crate_exports.sort_unstable_by(|&(ref name1, ..), &(ref name2, ..)| {\n+            name1.cmp(name2)\n+        });\n+\n         Arc::new(crate_exports)\n     };\n }"}, {"sha": "03c0f13e2f5f7b7e1dbd2526ac66b94d9a6911b7", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -104,7 +104,7 @@\n \n use collector::InliningMap;\n use common;\n-use rustc::dep_graph::{DepNode, WorkProductId};\n+use rustc::dep_graph::WorkProductId;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::middle::trans::{Linkage, Visibility};\n@@ -147,10 +147,6 @@ pub trait CodegenUnitExt<'tcx> {\n         WorkProductId::from_cgu_name(self.name())\n     }\n \n-    fn work_product_dep_node(&self) -> DepNode {\n-        self.work_product_id().to_dep_node()\n-    }\n-\n     fn items_in_deterministic_order<'a>(&self,\n                                         tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                         -> Vec<(TransItem<'tcx>,\n@@ -253,14 +249,6 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         cgu1.name().cmp(cgu2.name())\n     });\n \n-    if tcx.sess.opts.enable_dep_node_debug_strs() {\n-        for cgu in &result {\n-            let dep_node = cgu.work_product_dep_node();\n-            tcx.dep_graph.register_dep_node_debug_str(dep_node,\n-                                                            || cgu.name().to_string());\n-        }\n-    }\n-\n     result\n }\n "}, {"sha": "4a3e4bc49ce6f0602fef53be9213eca869e80ffd", "filename": "src/test/incremental/hashes/panic_exprs.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -152,13 +152,48 @@ pub fn mod_by_zero(val: i32) -> i32 {\n }\n \n \n+// shift left ------------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn shift_left(val: i32, shift: usize) -> i32 {\n+    val << shift\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn shift_left(val: i32, shift: usize) -> i32 {\n+    val << shift\n+}\n+\n+\n+// shift right ------------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub fn shift_right(val: i32, shift: usize) -> i32 {\n+    val >> shift\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub fn shift_right(val: i32, shift: usize) -> i32 {\n+    val >> shift\n+}\n+\n \n // THE FOLLOWING ITEMS SHOULD NOT BE INFLUENCED BY THEIR SOURCE LOCATION\n \n // bitwise ---------------------------------------------------------------------\n #[cfg(cfail1)]\n pub fn bitwise(val: i32) -> i32 {\n-    !val & 0x101010101 | 0x45689 ^ 0x2372382 << 1 >> 1\n+    !val & 0x101010101 | 0x45689 ^ 0x2372382\n }\n \n #[cfg(not(cfail1))]\n@@ -169,7 +204,7 @@ pub fn bitwise(val: i32) -> i32 {\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub fn bitwise(val: i32) -> i32 {\n-    !val & 0x101010101 | 0x45689 ^ 0x2372382 << 1 >> 1\n+    !val & 0x101010101 | 0x45689 ^ 0x2372382\n }\n \n "}, {"sha": "2e0f0ba083783c34ff7c694a5941c126b41f393b", "filename": "src/test/incremental/ich_nested_items.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Ftest%2Fincremental%2Fich_nested_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Ftest%2Fincremental%2Fich_nested_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fich_nested_items.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -11,29 +11,29 @@\n // Check that the hash of `foo` doesn't change just because we ordered\n // the nested items (or even added new ones).\n \n-// revisions: rpass1 rpass2\n+// revisions: cfail1 cfail2\n+// must-compile-successfully\n \n+#![crate_type = \"rlib\"]\n #![feature(rustc_attrs)]\n \n-#[cfg(rpass1)]\n-fn foo() {\n-    fn bar() { }\n-    fn baz() { }\n+#[cfg(cfail1)]\n+pub fn foo() {\n+    pub fn bar() { }\n+    pub fn baz() { }\n }\n \n-#[cfg(rpass2)]\n-#[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n-fn foo() {\n-    #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n-    fn baz() { } // order is different...\n+#[cfg(cfail2)]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+pub fn foo() {\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail2\")]\n+    pub fn baz() { } // order is different...\n \n-    #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n-    #[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n-    fn bar() { } // but that doesn't matter.\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"cfail2\")]\n+    pub fn bar() { } // but that doesn't matter.\n \n-    fn bap() { } // neither does adding a new item\n+    pub fn bap() { } // neither does adding a new item\n }\n-\n-fn main() { }"}, {"sha": "3ae26c6aa4517bfca78720248abf8a045acc9754", "filename": "src/test/incremental/remove_source_file/main.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Ftest%2Fincremental%2Fremove_source_file%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Ftest%2Fincremental%2Fremove_source_file%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremove_source_file%2Fmain.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -11,21 +11,24 @@\n // This test case makes sure that the compiler doesn't crash due to a failing\n // table lookup when a source file is removed.\n \n-// revisions:rpass1 rpass2\n+// revisions:cfail1 cfail2\n \n // Note that we specify -g so that the FileMaps actually get referenced by the\n // incr. comp. cache:\n // compile-flags: -Z query-dep-graph -g\n+// must-compile-successfully\n \n-#[cfg(rpass1)]\n+#![crate_type= \"rlib\"]\n+\n+#[cfg(cfail1)]\n mod auxiliary;\n \n-#[cfg(rpass1)]\n-fn main() {\n+#[cfg(cfail1)]\n+pub fn foo() {\n     auxiliary::print_hello();\n }\n \n-#[cfg(rpass2)]\n-fn main() {\n+#[cfg(cfail2)]\n+pub fn foo() {\n     println!(\"hello\");\n }"}, {"sha": "e1369d92c5ccb4d9b18886d12f1e27e0f4f9c475", "filename": "src/test/incremental/spans_in_type_debuginfo.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Ftest%2Fincremental%2Fspans_in_type_debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Ftest%2Fincremental%2Fspans_in_type_debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspans_in_type_debuginfo.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -14,7 +14,6 @@\n // revisions:rpass1 rpass2\n // compile-flags: -Z query-dep-graph -g\n \n-#![rustc_partition_reused(module=\"spans_in_type_debuginfo\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"spans_in_type_debuginfo-structs\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"spans_in_type_debuginfo-enums\", cfg=\"rpass2\")]\n "}, {"sha": "f02525c118a8910b7efc9482b895bcbb901f9e3e", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3fbe750fa0f971f24a41e574fd44ca582be239/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=da3fbe750fa0f971f24a41e574fd44ca582be239", "patch": "@@ -1384,6 +1384,7 @@ actual:\\n\\\n \n         if let Some(ref incremental_dir) = self.props.incremental_dir {\n             rustc.args(&[\"-Z\", &format!(\"incremental={}\", incremental_dir.display())]);\n+            rustc.args(&[\"-Z\", \"incremental-verify-ich\"]);\n         }\n \n         match self.config.mode {"}]}