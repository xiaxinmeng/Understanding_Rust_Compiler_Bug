{"sha": "bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlYTcxMTNlYjhiM2NlNjNiOTVhOWM2YTRmOGQzOWM3ZjkxMmQ5ZTE=", "commit": {"author": {"name": "Samrat Man Singh", "email": "samratmansingh@gmail.com", "date": "2020-08-01T11:38:28Z"}, "committer": {"name": "Samrat Man Singh", "email": "samratmansingh@gmail.com", "date": "2020-08-03T19:44:52Z"}, "message": "Add `impl FileDescriptor` for stdin, stdout, stderr\n\n- Use `FileDescriptor::read` for stdin reads\n- Use `FileDescriptor::write` for stdout/err writes\n- Handle stdout/err reads in `FileDescriptor::read`", "tree": {"sha": "7515cc0277c0b2d87c165e5ed94a988954652128", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7515cc0277c0b2d87c165e5ed94a988954652128"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1", "html_url": "https://github.com/rust-lang/rust/commit/bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1/comments", "author": {"login": "samrat", "id": 480806, "node_id": "MDQ6VXNlcjQ4MDgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/480806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/samrat", "html_url": "https://github.com/samrat", "followers_url": "https://api.github.com/users/samrat/followers", "following_url": "https://api.github.com/users/samrat/following{/other_user}", "gists_url": "https://api.github.com/users/samrat/gists{/gist_id}", "starred_url": "https://api.github.com/users/samrat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/samrat/subscriptions", "organizations_url": "https://api.github.com/users/samrat/orgs", "repos_url": "https://api.github.com/users/samrat/repos", "events_url": "https://api.github.com/users/samrat/events{/privacy}", "received_events_url": "https://api.github.com/users/samrat/received_events", "type": "User", "site_admin": false}, "committer": {"login": "samrat", "id": 480806, "node_id": "MDQ6VXNlcjQ4MDgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/480806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/samrat", "html_url": "https://github.com/samrat", "followers_url": "https://api.github.com/users/samrat/followers", "following_url": "https://api.github.com/users/samrat/following{/other_user}", "gists_url": "https://api.github.com/users/samrat/gists{/gist_id}", "starred_url": "https://api.github.com/users/samrat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/samrat/subscriptions", "organizations_url": "https://api.github.com/users/samrat/orgs", "repos_url": "https://api.github.com/users/samrat/repos", "events_url": "https://api.github.com/users/samrat/events{/privacy}", "received_events_url": "https://api.github.com/users/samrat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446", "url": "https://api.github.com/repos/rust-lang/rust/commits/69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446", "html_url": "https://github.com/rust-lang/rust/commit/69d050fb6b2a6d8ec0c01a44ccfaf79409c4b446"}], "stats": {"total": 176, "additions": 104, "deletions": 72}, "files": [{"sha": "594f58d26461f9cddb9c51004b2787cc9727e5ee", "filename": "src/shims/posix/foreign_items.rs", "status": "modified", "additions": 6, "deletions": 68, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1/src%2Fshims%2Fposix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1/src%2Fshims%2Fposix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fforeign_items.rs?ref=bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1", "patch": "@@ -1,5 +1,4 @@\n-use std::convert::TryFrom;\n-use std::io::{self, Read, Write};\n+use std::io::{self, Write};\n \n use log::trace;\n \n@@ -67,43 +66,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_scalar(buf)?.check_init()?;\n                 let count = this.read_scalar(count)?.to_machine_usize(this)?;\n-                let result = if fd == 0 {\n-\n-                    this.check_no_isolation(\"read\")?;\n-\n-                    // We cap the number of read bytes to the largest\n-                    // value that we are able to fit in both the\n-                    // host's and target's `isize`. This saves us from\n-                    // having to handle overflows later.\n-                    let count = count.min(this.machine_isize_max() as u64).min(isize::MAX as u64);\n-\n-                    // We want to read at most `count` bytes. We are\n-                    // sure that `count` is not negative because it\n-                    // was a target's `usize`. Also we are sure that\n-                    // its smaller than `usize::MAX` because it is a\n-                    // host's `isize`.\n-                    let mut buffer = vec![0; count as usize];\n-                    let res = io::stdin()\n-                        .read(&mut buffer)\n-                        // `Stdin::read` never returns a value larger\n-                        // than `count`, so this cannot fail.\n-                        .map(|c| i64::try_from(c).unwrap());\n-\n-                    match res {\n-                        Ok(bytes) => {\n-                            this.memory.write_bytes(buf, buffer)?;\n-                            i64::try_from(bytes).unwrap()\n-                        },\n-                        Err(e) => {\n-                            this.set_last_error_from_io_error(e)?;\n-                            -1\n-                        },\n-                    }\n-                } else if fd == 1 || fd == 2 {\n-                    throw_unsup_format!(\"cannot read from stdout/stderr\")\n-                } else {\n-                    this.read(fd, buf, count)?\n-                };\n+                let result = this.read(fd, buf, count)?;\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"write\" => {\n@@ -112,35 +75,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let buf = this.read_scalar(buf)?.check_init()?;\n                 let count = this.read_scalar(n)?.to_machine_usize(this)?;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, count);\n-                let result = if fd == 0 {\n-                    throw_unsup_format!(\"cannot write to stdin\")\n-                } else if fd == 1 || fd == 2 {\n-                    // stdout/stderr\n-\n-                    let buf_cont = this.memory.read_bytes(buf, Size::from_bytes(count))?;\n-                    // We need to flush to make sure this actually appears on the screen\n-                    let res = if fd == 1 {\n-                        // Stdout is buffered, flush to make sure it appears on the screen.\n-                        // This is the write() syscall of the interpreted program, we want it\n-                        // to correspond to a write() syscall on the host -- there is no good\n-                        // in adding extra buffering here.\n-                        let res = io::stdout().write(buf_cont);\n-                        io::stdout().flush().unwrap();\n-                        res\n-                    } else {\n-                        // No need to flush, stderr is not buffered.\n-                        io::stderr().write(buf_cont)\n-                    };\n-                    match res {\n-                        Ok(n) => i64::try_from(n).unwrap(),\n-                        Err(e) => {\n-                            this.set_last_error_from_io_error(e)?;\n-                            -1\n-                        }\n-                    }\n-                } else {\n-                    this.write(fd, buf, count)?\n-                };\n+                let result = this.write(fd, buf, count)?;\n+                if fd == 1 {\n+                    io::stdout().flush().unwrap();\n+                }\n                 // Now, `result` is the value we return back to the program.\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }"}, {"sha": "65d50aa504d3d6b0f3d5c444c496e93144998194", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 70, "deletions": 4, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1", "patch": "@@ -48,11 +48,77 @@ impl<'tcx> FileDescriptor<'tcx> for FileHandle {\n     }\n }\n \n-#[derive(Debug, Default)]\n+impl<'tcx> FileDescriptor<'tcx> for io::Stdin {\n+    fn as_file_handle(&self) -> InterpResult<'tcx, &FileHandle> {\n+        throw_unsup_format!(\"stdin cannot be used as FileHandle\");\n+    }\n+\n+    fn read(&mut self, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        Ok(Read::read(self, bytes))\n+    }\n+\n+    fn write(&mut self, _bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        throw_unsup_format!(\"cannot write to stdin\");\n+    }\n+\n+    fn seek(&mut self, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+        throw_unsup_format!(\"cannot seek on stdin\");\n+    }\n+}\n+\n+impl<'tcx> FileDescriptor<'tcx> for io::Stdout {\n+    fn as_file_handle(&self) -> InterpResult<'tcx, &FileHandle> {\n+        throw_unsup_format!(\"stdout cannot be used as FileHandle\");\n+    }\n+\n+    fn read(&mut self, _bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        throw_unsup_format!(\"cannot read from stdout\");\n+    }\n+\n+    fn write(&mut self, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        Ok(Write::write(self, bytes))\n+    }\n+\n+    fn seek(&mut self, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+        throw_unsup_format!(\"cannot seek on stdout\");\n+    }\n+}\n+\n+impl<'tcx> FileDescriptor<'tcx> for io::Stderr {\n+    fn as_file_handle(&self) -> InterpResult<'tcx, &FileHandle> {\n+        throw_unsup_format!(\"stdout cannot be used as FileHandle\");\n+    }\n+\n+    fn read(&mut self, _bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        throw_unsup_format!(\"cannot read from stderr\");\n+    }\n+\n+    fn write(&mut self, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        Ok(Write::write(self, bytes))\n+    }\n+\n+    fn seek(&mut self, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+        throw_unsup_format!(\"cannot seek on stderr\");\n+    }\n+}\n+\n+#[derive(Debug)]\n pub struct FileHandler<'tcx> {\n     handles: BTreeMap<i32, Box<dyn FileDescriptor<'tcx>>>,\n }\n \n+impl<'tcx> Default for FileHandler<'tcx> {\n+    fn default() -> Self {\n+        let mut handles = BTreeMap::new();\n+        handles.insert(0i32, Box::new(io::stdin()) as Box<dyn FileDescriptor<'_>>);\n+        handles.insert(1i32, Box::new(io::stdout()) as Box<dyn FileDescriptor<'_>>);\n+        handles.insert(2i32, Box::new(io::stderr()) as Box<dyn FileDescriptor<'_>>);\n+        FileHandler {\n+            handles\n+        }\n+    }\n+}\n+\n \n // fd numbers 0, 1, and 2 are reserved for stdin, stdout, and stderr\n const MIN_NORMAL_FILE_FD: i32 = 3;\n@@ -485,7 +551,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         this.check_no_isolation(\"read\")?;\n-        assert!(fd >= 3);\n \n         trace!(\"Reading from FD {}, size {}\", fd, count);\n \n@@ -537,8 +602,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"write\")?;\n-        assert!(fd >= 3);\n+        if fd >= 3 {\n+            this.check_no_isolation(\"write\")?;\n+        }\n \n         // Check that the *entire* buffer is actually valid memory.\n         this.memory.check_ptr_access("}, {"sha": "17f1735f6aded51894c1babcf2fa9ffb33fbef2b", "filename": "tests/compile-fail/fs/read_from_stdout.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1/tests%2Fcompile-fail%2Ffs%2Fread_from_stdout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1/tests%2Fcompile-fail%2Ffs%2Fread_from_stdout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffs%2Fread_from_stdout.rs?ref=bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: -Zmiri-disable-isolation\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() -> std::io::Result<()> {\n+    let mut bytes = [0u8; 512];\n+    unsafe {\n+        libc::read(1, bytes.as_mut_ptr() as *mut libc::c_void, 512); //~ ERROR cannot read from stdout\n+    }\n+    Ok(())\n+}"}, {"sha": "30d24b5dc4443e60e1f258c5a9f521d18911328b", "filename": "tests/compile-fail/fs/write_to_stdin.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1/tests%2Fcompile-fail%2Ffs%2Fwrite_to_stdin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1/tests%2Fcompile-fail%2Ffs%2Fwrite_to_stdin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffs%2Fwrite_to_stdin.rs?ref=bea7113eb8b3ce63b95a9c6a4f8d39c7f912d9e1", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: -Zmiri-disable-isolation\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() -> std::io::Result<()> {\n+    let bytes = b\"hello\";\n+    unsafe {\n+        libc::write(0, bytes.as_ptr() as *const libc::c_void, 5); //~ ERROR cannot write to stdin\n+    }\n+    Ok(())\n+}"}]}