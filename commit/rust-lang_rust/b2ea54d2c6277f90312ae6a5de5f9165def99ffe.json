{"sha": "b2ea54d2c6277f90312ae6a5de5f9165def99ffe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZWE1NGQyYzYyNzdmOTAzMTJhZTZhNWRlNWY5MTY1ZGVmOTlmZmU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-05T18:14:41Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-09T20:17:00Z"}, "message": "trans: Split LocalCrateContext ownership out of SharedCrateContext.", "tree": {"sha": "24624333cfae378ac6271dbf5f89e0e4bfc23ba3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24624333cfae378ac6271dbf5f89e0e4bfc23ba3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2ea54d2c6277f90312ae6a5de5f9165def99ffe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2ea54d2c6277f90312ae6a5de5f9165def99ffe", "html_url": "https://github.com/rust-lang/rust/commit/b2ea54d2c6277f90312ae6a5de5f9165def99ffe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2ea54d2c6277f90312ae6a5de5f9165def99ffe/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faca79fc332f62b339aee5bd994b00e52d9ac051", "url": "https://api.github.com/repos/rust-lang/rust/commits/faca79fc332f62b339aee5bd994b00e52d9ac051", "html_url": "https://github.com/rust-lang/rust/commit/faca79fc332f62b339aee5bd994b00e52d9ac051"}], "stats": {"total": 285, "additions": 151, "deletions": 134}, "files": [{"sha": "98a84205930f8cd5efaf3f048b87653ac9b1b252", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2ea54d2c6277f90312ae6a5de5f9165def99ffe/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ea54d2c6277f90312ae6a5de5f9165def99ffe/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=b2ea54d2c6277f90312ae6a5de5f9165def99ffe", "patch": "@@ -68,7 +68,7 @@ use common::{node_id_type, fulfill_obligation};\n use common::{type_is_immediate, type_is_zero_size, val_ty};\n use common;\n use consts;\n-use context::SharedCrateContext;\n+use context::{SharedCrateContext, CrateContextList};\n use controlflow;\n use datum;\n use debuginfo::{self, DebugLoc, ToDebugLoc};\n@@ -2522,7 +2522,7 @@ pub fn write_metadata<'a, 'tcx>(cx: &SharedCrateContext<'a, 'tcx>,\n \n /// Find any symbols that are defined in one compilation unit, but not declared\n /// in any other compilation unit.  Give these symbols internal linkage.\n-fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<&str>) {\n+fn internalize_symbols(cx: &CrateContextList, reachable: &HashSet<&str>) {\n     unsafe {\n         let mut declared = HashSet::new();\n \n@@ -2577,12 +2577,12 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<&str>) {\n // when using MSVC linker.  We do this only for data, as linker can fix up\n // code references on its own.\n // See #26591, #27438\n-fn create_imps(cx: &SharedCrateContext) {\n+fn create_imps(cx: &CrateContextList) {\n     // The x86 ABI seems to require that leading underscores are added to symbol\n     // names, so we need an extra underscore on 32-bit. There's also a leading\n     // '\\x01' here which disables LLVM's symbol mangling (e.g. no extra\n     // underscores added in front).\n-    let prefix = if cx.sess().target.target.target_pointer_width == \"32\" {\n+    let prefix = if cx.shared().sess().target.target.target_pointer_width == \"32\" {\n         \"\\x01__imp__\"\n     } else {\n         \"\\x01__imp_\"\n@@ -2714,10 +2714,7 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n \n     let link_meta = link::build_link_meta(&tcx, name);\n \n-    let codegen_units = tcx.sess.opts.cg.codegen_units;\n-    let shared_ccx = SharedCrateContext::new(&link_meta.crate_name,\n-                                             codegen_units,\n-                                             tcx,\n+    let shared_ccx = SharedCrateContext::new(tcx,\n                                              &mir_map,\n                                              export_map,\n                                              Sha256::new(),\n@@ -2726,8 +2723,11 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n                                              check_overflow,\n                                              check_dropflag);\n \n+    let codegen_units = tcx.sess.opts.cg.codegen_units;\n+    let crate_context_list = CrateContextList::new(&shared_ccx, codegen_units);\n+\n     {\n-        let ccx = shared_ccx.get_ccx(0);\n+        let ccx = crate_context_list.get_ccx(0);\n         collect_translation_items(&ccx);\n \n         // Translate all items. See `TransModVisitor` for\n@@ -2743,7 +2743,7 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n         symbol_names_test::report_symbol_names(&ccx);\n     }\n \n-    for ccx in shared_ccx.iter() {\n+    for ccx in crate_context_list.iter() {\n         if ccx.sess().opts.debuginfo != NoDebugInfo {\n             debuginfo::finalize(&ccx);\n         }\n@@ -2792,7 +2792,7 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n     }\n \n-    let modules = shared_ccx.iter()\n+    let modules = crate_context_list.iter()\n         .map(|ccx| ModuleTranslation { llcx: ccx.llcx(), llmod: ccx.llmod() })\n         .collect();\n \n@@ -2819,13 +2819,13 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n     }\n \n     if codegen_units > 1 {\n-        internalize_symbols(&shared_ccx,\n+        internalize_symbols(&crate_context_list,\n                             &reachable_symbols.iter().map(|x| &x[..]).collect());\n     }\n \n     if sess.target.target.options.is_like_msvc &&\n        sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n-        create_imps(&shared_ccx);\n+        create_imps(&crate_context_list);\n     }\n \n     let metadata_module = ModuleTranslation {"}, {"sha": "7db42bb00ee1b4d787ea79a22824202bd46bdabf", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 138, "deletions": 121, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/b2ea54d2c6277f90312ae6a5de5f9165def99ffe/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ea54d2c6277f90312ae6a5de5f9165def99ffe/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=b2ea54d2c6277f90312ae6a5de5f9165def99ffe", "patch": "@@ -64,8 +64,6 @@ pub struct Stats {\n /// crate, so it must not contain references to any LLVM data structures\n /// (aside from metadata-related ones).\n pub struct SharedCrateContext<'a, 'tcx: 'a> {\n-    local_ccxs: Vec<LocalCrateContext<'tcx>>,\n-\n     metadata_llmod: ModuleRef,\n     metadata_llcx: ContextRef,\n \n@@ -95,7 +93,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n pub struct LocalCrateContext<'tcx> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n-    tn: TypeNames,\n+    tn: TypeNames, // FIXME: This seems to be largely unused.\n     needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n     fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n     drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, ValueRef>>,\n@@ -191,24 +189,73 @@ impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n     }\n }\n \n+pub struct CrateContextList<'a, 'tcx: 'a> {\n+    shared: &'a SharedCrateContext<'a, 'tcx>,\n+    local_ccxs: Vec<LocalCrateContext<'tcx>>,\n+}\n+\n+impl<'a, 'tcx: 'a> CrateContextList<'a, 'tcx> {\n+\n+    pub fn new(shared_ccx: &'a SharedCrateContext<'a, 'tcx>,\n+               local_count: usize)\n+               -> CrateContextList<'a, 'tcx> {\n+        CrateContextList {\n+            shared: shared_ccx,\n+            local_ccxs: (0..local_count).map(|index| {\n+                // Append \".rs\" to crate name as LLVM module identifier.\n+                //\n+                // LLVM code generator emits a \".file filename\" directive\n+                // for ELF backends. Value of the \"filename\" is set as the\n+                // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n+                // crashes if the module identifier is same as other symbols\n+                // such as a function name in the module.\n+                // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n+                let llmod_id = format!(\"{}.{}.rs\", shared_ccx.link_meta.crate_name, index);\n+                LocalCrateContext::new(shared_ccx, &llmod_id[..])\n+            }).collect()\n+        }\n+    }\n+\n+    pub fn iter<'b>(&'b self) -> CrateContextIterator<'b, 'tcx> {\n+        CrateContextIterator {\n+            shared: self.shared,\n+            index: 0,\n+            local_ccxs: &self.local_ccxs[..]\n+        }\n+    }\n+\n+    pub fn get_ccx<'b>(&'b self, index: usize) -> CrateContext<'b, 'tcx> {\n+        CrateContext {\n+            shared: self.shared,\n+            index: index,\n+            local_ccxs: &self.local_ccxs[..],\n+        }\n+    }\n+\n+    pub fn shared(&self) -> &'a SharedCrateContext<'a, 'tcx> {\n+        self.shared\n+    }\n+}\n+\n pub struct CrateContext<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'a, 'tcx>,\n-    local: &'a LocalCrateContext<'tcx>,\n-    /// The index of `local` in `shared.local_ccxs`.  This is used in\n+    local_ccxs: &'a [LocalCrateContext<'tcx>],\n+    /// The index of `local` in `local_ccxs`.  This is used in\n     /// `maybe_iter(true)` to identify the original `LocalCrateContext`.\n     index: usize,\n }\n \n pub struct CrateContextIterator<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'a, 'tcx>,\n+    local_ccxs: &'a [LocalCrateContext<'tcx>],\n     index: usize,\n }\n \n impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n     type Item = CrateContext<'a, 'tcx>;\n \n     fn next(&mut self) -> Option<CrateContext<'a, 'tcx>> {\n-        if self.index >= self.shared.local_ccxs.len() {\n+        if self.index >= self.local_ccxs.len() {\n             return None;\n         }\n \n@@ -217,15 +264,16 @@ impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n \n         Some(CrateContext {\n             shared: self.shared,\n-            local: &self.shared.local_ccxs[index],\n             index: index,\n+            local_ccxs: self.local_ccxs,\n         })\n     }\n }\n \n /// The iterator produced by `CrateContext::maybe_iter`.\n pub struct CrateContextMaybeIterator<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'a, 'tcx>,\n+    local_ccxs: &'a [LocalCrateContext<'tcx>],\n     index: usize,\n     single: bool,\n     origin: usize,\n@@ -235,20 +283,20 @@ impl<'a, 'tcx> Iterator for CrateContextMaybeIterator<'a, 'tcx> {\n     type Item = (CrateContext<'a, 'tcx>, bool);\n \n     fn next(&mut self) -> Option<(CrateContext<'a, 'tcx>, bool)> {\n-        if self.index >= self.shared.local_ccxs.len() {\n+        if self.index >= self.local_ccxs.len() {\n             return None;\n         }\n \n         let index = self.index;\n         self.index += 1;\n         if self.single {\n-            self.index = self.shared.local_ccxs.len();\n+            self.index = self.local_ccxs.len();\n         }\n \n         let ccx = CrateContext {\n             shared: self.shared,\n-            local: &self.shared.local_ccxs[index],\n             index: index,\n+            local_ccxs: self.local_ccxs\n         };\n         Some((ccx, index == self.origin))\n     }\n@@ -288,9 +336,7 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n }\n \n impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n-    pub fn new(crate_name: &str,\n-               local_count: usize,\n-               tcx: &'b TyCtxt<'tcx>,\n+    pub fn new(tcx: &'b TyCtxt<'tcx>,\n                mir_map: &'b MirMap<'tcx>,\n                export_map: ExportMap,\n                symbol_hasher: Sha256,\n@@ -348,8 +394,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         // start) and then strongly recommending static linkage on MSVC!\n         let use_dll_storage_attrs = tcx.sess.target.target.options.is_like_msvc;\n \n-        let mut shared_ccx = SharedCrateContext {\n-            local_ccxs: Vec::with_capacity(local_count),\n+        SharedCrateContext {\n             metadata_llmod: metadata_llmod,\n             metadata_llcx: metadata_llcx,\n             export_map: export_map,\n@@ -378,55 +423,9 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             available_drop_glues: RefCell::new(FnvHashMap()),\n             use_dll_storage_attrs: use_dll_storage_attrs,\n             translation_items: RefCell::new(FnvHashMap()),\n-        };\n-\n-        for i in 0..local_count {\n-            // Append \".rs\" to crate name as LLVM module identifier.\n-            //\n-            // LLVM code generator emits a \".file filename\" directive\n-            // for ELF backends. Value of the \"filename\" is set as the\n-            // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n-            // crashes if the module identifier is same as other symbols\n-            // such as a function name in the module.\n-            // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-            let llmod_id = format!(\"{}.{}.rs\", crate_name, i);\n-            let local_ccx = LocalCrateContext::new(&shared_ccx, &llmod_id[..]);\n-            shared_ccx.local_ccxs.push(local_ccx);\n         }\n-\n-        shared_ccx\n     }\n \n-    pub fn iter<'a>(&'a self) -> CrateContextIterator<'a, 'tcx> {\n-        CrateContextIterator {\n-            shared: self,\n-            index: 0,\n-        }\n-    }\n-\n-    pub fn get_ccx<'a>(&'a self, index: usize) -> CrateContext<'a, 'tcx> {\n-        CrateContext {\n-            shared: self,\n-            local: &self.local_ccxs[index],\n-            index: index,\n-        }\n-    }\n-\n-    fn get_smallest_ccx<'a>(&'a self) -> CrateContext<'a, 'tcx> {\n-        let (local_ccx, index) =\n-            self.local_ccxs\n-                .iter()\n-                .zip(0..self.local_ccxs.len())\n-                .min_by_key(|&(local_ccx, _idx)| local_ccx.n_llvm_insns.get())\n-                .unwrap();\n-        CrateContext {\n-            shared: self,\n-            local: local_ccx,\n-            index: index,\n-        }\n-    }\n-\n-\n     pub fn metadata_llmod(&self) -> ModuleRef {\n         self.metadata_llmod\n     }\n@@ -481,7 +480,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 None\n             };\n \n-            let mut local_ccx = LocalCrateContext {\n+            let local_ccx = LocalCrateContext {\n                 llmod: llmod,\n                 llcx: llcx,\n                 tn: TypeNames::new(),\n@@ -522,21 +521,28 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                                                                     .clone())),\n             };\n \n-            local_ccx.int_type = Type::int(&local_ccx.dummy_ccx(shared));\n-            local_ccx.opaque_vec_type = Type::opaque_vec(&local_ccx.dummy_ccx(shared));\n-\n-            // Done mutating local_ccx directly.  (The rest of the\n-            // initialization goes through RefCell.)\n-            {\n-                let ccx = local_ccx.dummy_ccx(shared);\n+            let (int_type, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n+                // Do a little dance to create a dummy CrateContext, so we can\n+                // create some things in the LLVM module of this codegen unit\n+                let mut local_ccxs = vec![local_ccx];\n+                let (int_type, opaque_vec_type, str_slice_ty) = {\n+                    let dummy_ccx = LocalCrateContext::dummy_ccx(shared,\n+                                                                 local_ccxs.as_mut_slice());\n+                    let mut str_slice_ty = Type::named_struct(&dummy_ccx, \"str_slice\");\n+                    str_slice_ty.set_struct_body(&[Type::i8p(&dummy_ccx),\n+                                                   Type::int(&dummy_ccx)],\n+                                                 false);\n+                    (Type::int(&dummy_ccx), Type::opaque_vec(&dummy_ccx), str_slice_ty)\n+                };\n+                (int_type, opaque_vec_type, str_slice_ty, local_ccxs.pop().unwrap())\n+            };\n \n-                let mut str_slice_ty = Type::named_struct(&ccx, \"str_slice\");\n-                str_slice_ty.set_struct_body(&[Type::i8p(&ccx), ccx.int_type()], false);\n-                ccx.tn().associate_type(\"str_slice\", &str_slice_ty);\n+            local_ccx.int_type = int_type;\n+            local_ccx.opaque_vec_type = opaque_vec_type;\n+            local_ccx.tn.associate_type(\"str_slice\", &str_slice_ty);\n \n-                if ccx.sess().count_llvm_insns() {\n-                    base::init_insn_ctxt()\n-                }\n+            if shared.tcx.sess.count_llvm_insns() {\n+                base::init_insn_ctxt()\n             }\n \n             local_ccx\n@@ -545,18 +551,19 @@ impl<'tcx> LocalCrateContext<'tcx> {\n \n     /// Create a dummy `CrateContext` from `self` and  the provided\n     /// `SharedCrateContext`.  This is somewhat dangerous because `self` may\n-    /// not actually be an element of `shared.local_ccxs`, which can cause some\n-    /// operations to panic unexpectedly.\n+    /// not be fully initialized.\n     ///\n     /// This is used in the `LocalCrateContext` constructor to allow calling\n     /// functions that expect a complete `CrateContext`, even before the local\n     /// portion is fully initialized and attached to the `SharedCrateContext`.\n-    fn dummy_ccx<'a>(&'a self, shared: &'a SharedCrateContext<'a, 'tcx>)\n+    fn dummy_ccx<'a>(shared: &'a SharedCrateContext<'a, 'tcx>,\n+                     local_ccxs: &'a [LocalCrateContext<'tcx>])\n                      -> CrateContext<'a, 'tcx> {\n+        assert!(local_ccxs.len() == 1);\n         CrateContext {\n             shared: shared,\n-            local: self,\n-            index: !0 as usize,\n+            index: 0,\n+            local_ccxs: local_ccxs\n         }\n     }\n }\n@@ -567,13 +574,23 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn local(&self) -> &'b LocalCrateContext<'tcx> {\n-        self.local\n+        &self.local_ccxs[self.index]\n     }\n \n     /// Get a (possibly) different `CrateContext` from the same\n     /// `SharedCrateContext`.\n-    pub fn rotate(&self) -> CrateContext<'b, 'tcx> {\n-        self.shared.get_smallest_ccx()\n+    pub fn rotate(&'b self) -> CrateContext<'b, 'tcx> {\n+        let (_, index) =\n+            self.local_ccxs\n+                .iter()\n+                .zip(0..self.local_ccxs.len())\n+                .min_by_key(|&(local_ccx, _idx)| local_ccx.n_llvm_insns.get())\n+                .unwrap();\n+        CrateContext {\n+            shared: self.shared,\n+            index: index,\n+            local_ccxs: &self.local_ccxs[..],\n+        }\n     }\n \n     /// Either iterate over only `self`, or iterate over all `CrateContext`s in\n@@ -588,10 +605,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n             index: if iter_all { 0 } else { self.index },\n             single: !iter_all,\n             origin: self.index,\n+            local_ccxs: self.local_ccxs,\n         }\n     }\n \n-\n     pub fn tcx<'a>(&'a self) -> &'a TyCtxt<'tcx> {\n         self.shared.tcx\n     }\n@@ -605,7 +622,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn raw_builder<'a>(&'a self) -> BuilderRef {\n-        self.local.builder.b\n+        self.local().builder.b\n     }\n \n     pub fn get_intrinsic(&self, key: &str) -> ValueRef {\n@@ -619,19 +636,19 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn llmod(&self) -> ModuleRef {\n-        self.local.llmod\n+        self.local().llmod\n     }\n \n     pub fn llcx(&self) -> ContextRef {\n-        self.local.llcx\n+        self.local().llcx\n     }\n \n     pub fn td(&self) -> llvm::TargetDataRef {\n         unsafe { llvm::LLVMRustGetModuleDataLayout(self.llmod()) }\n     }\n \n     pub fn tn<'a>(&'a self) -> &'a TypeNames {\n-        &self.local.tn\n+        &self.local().tn\n     }\n \n     pub fn export_map<'a>(&'a self) -> &'a ExportMap {\n@@ -651,56 +668,56 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn needs_unwind_cleanup_cache(&self) -> &RefCell<FnvHashMap<Ty<'tcx>, bool>> {\n-        &self.local.needs_unwind_cleanup_cache\n+        &self.local().needs_unwind_cleanup_cache\n     }\n \n     pub fn fn_pointer_shims(&self) -> &RefCell<FnvHashMap<Ty<'tcx>, ValueRef>> {\n-        &self.local.fn_pointer_shims\n+        &self.local().fn_pointer_shims\n     }\n \n     pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<DropGlueKind<'tcx>, ValueRef>> {\n-        &self.local.drop_glues\n+        &self.local().drop_glues\n     }\n \n     pub fn external<'a>(&'a self) -> &'a RefCell<DefIdMap<Option<ast::NodeId>>> {\n-        &self.local.external\n+        &self.local().external\n     }\n \n     pub fn external_srcs<'a>(&'a self) -> &'a RefCell<NodeMap<DefId>> {\n-        &self.local.external_srcs\n+        &self.local().external_srcs\n     }\n \n     pub fn instances<'a>(&'a self) -> &'a RefCell<FnvHashMap<Instance<'tcx>, ValueRef>> {\n-        &self.local.instances\n+        &self.local().instances\n     }\n \n     pub fn monomorphizing<'a>(&'a self) -> &'a RefCell<DefIdMap<usize>> {\n-        &self.local.monomorphizing\n+        &self.local().monomorphizing\n     }\n \n     pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>> {\n-        &self.local.vtables\n+        &self.local().vtables\n     }\n \n     pub fn const_cstr_cache<'a>(&'a self) -> &'a RefCell<FnvHashMap<InternedString, ValueRef>> {\n-        &self.local.const_cstr_cache\n+        &self.local().const_cstr_cache\n     }\n \n     pub fn const_unsized<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n-        &self.local.const_unsized\n+        &self.local().const_unsized\n     }\n \n     pub fn const_globals<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n-        &self.local.const_globals\n+        &self.local().const_globals\n     }\n \n     pub fn const_values<'a>(&'a self) -> &'a RefCell<FnvHashMap<(ast::NodeId, &'tcx Substs<'tcx>),\n                                                                 ValueRef>> {\n-        &self.local.const_values\n+        &self.local().const_values\n     }\n \n     pub fn extern_const_values<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n-        &self.local.extern_const_values\n+        &self.local().extern_const_values\n     }\n \n     pub fn statics<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, DefId>> {\n@@ -709,35 +726,35 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n \n     pub fn impl_method_cache<'a>(&'a self)\n             -> &'a RefCell<FnvHashMap<(DefId, ast::Name), DefId>> {\n-        &self.local.impl_method_cache\n+        &self.local().impl_method_cache\n     }\n \n     pub fn closure_bare_wrapper_cache<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n-        &self.local.closure_bare_wrapper_cache\n+        &self.local().closure_bare_wrapper_cache\n     }\n \n     pub fn statics_to_rauw<'a>(&'a self) -> &'a RefCell<Vec<(ValueRef, ValueRef)>> {\n-        &self.local.statics_to_rauw\n+        &self.local().statics_to_rauw\n     }\n \n     pub fn lltypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Type>> {\n-        &self.local.lltypes\n+        &self.local().lltypes\n     }\n \n     pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Type>> {\n-        &self.local.llsizingtypes\n+        &self.local().llsizingtypes\n     }\n \n     pub fn adt_reprs<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Rc<adt::Repr<'tcx>>>> {\n-        &self.local.adt_reprs\n+        &self.local().adt_reprs\n     }\n \n     pub fn symbol_hasher<'a>(&'a self) -> &'a RefCell<Sha256> {\n         &self.shared.symbol_hasher\n     }\n \n     pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, String>> {\n-        &self.local.type_hashcodes\n+        &self.local().type_hashcodes\n     }\n \n     pub fn stats<'a>(&'a self) -> &'a Stats {\n@@ -753,43 +770,43 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn int_type(&self) -> Type {\n-        self.local.int_type\n+        self.local().int_type\n     }\n \n     pub fn opaque_vec_type(&self) -> Type {\n-        self.local.opaque_vec_type\n+        self.local().opaque_vec_type\n     }\n \n     pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<Instance<'tcx>, ValueRef>> {\n-        &self.local.closure_vals\n+        &self.local().closure_vals\n     }\n \n     pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext<'tcx>> {\n-        &self.local.dbg_cx\n+        &self.local().dbg_cx\n     }\n \n     pub fn eh_personality<'a>(&'a self) -> &'a Cell<Option<ValueRef>> {\n-        &self.local.eh_personality\n+        &self.local().eh_personality\n     }\n \n     pub fn eh_unwind_resume<'a>(&'a self) -> &'a Cell<Option<ValueRef>> {\n-        &self.local.eh_unwind_resume\n+        &self.local().eh_unwind_resume\n     }\n \n     pub fn rust_try_fn<'a>(&'a self) -> &'a Cell<Option<ValueRef>> {\n-        &self.local.rust_try_fn\n+        &self.local().rust_try_fn\n     }\n \n     fn intrinsics<'a>(&'a self) -> &'a RefCell<FnvHashMap<&'static str, ValueRef>> {\n-        &self.local.intrinsics\n+        &self.local().intrinsics\n     }\n \n     pub fn count_llvm_insn(&self) {\n-        self.local.n_llvm_insns.set(self.local.n_llvm_insns.get() + 1);\n+        self.local().n_llvm_insns.set(self.local().n_llvm_insns.get() + 1);\n     }\n \n     pub fn trait_cache(&self) -> &RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>> {\n-        &self.local.trait_cache\n+        &self.local().trait_cache\n     }\n \n     pub fn obj_size_bound(&self) -> u64 {\n@@ -803,14 +820,14 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn enter_type_of(&self, ty: Ty<'tcx>) -> TypeOfDepthLock<'b, 'tcx> {\n-        let current_depth = self.local.type_of_depth.get();\n+        let current_depth = self.local().type_of_depth.get();\n         debug!(\"enter_type_of({:?}) at depth {:?}\", ty, current_depth);\n         if current_depth > self.sess().recursion_limit.get() {\n             self.sess().fatal(\n                 &format!(\"overflow representing the type `{}`\", ty))\n         }\n-        self.local.type_of_depth.set(current_depth + 1);\n-        TypeOfDepthLock(self.local)\n+        self.local().type_of_depth.set(current_depth + 1);\n+        TypeOfDepthLock(self.local())\n     }\n \n     pub fn check_overflow(&self) -> bool {"}]}