{"sha": "01833de7ea4c3d73351277b52f841d42d7d2dbb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxODMzZGU3ZWE0YzNkNzMzNTEyNzdiNTJmODQxZDQyZDdkMmRiYjg=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-06T21:06:30Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-06T21:06:30Z"}, "message": "remove extra::rope\n\nIt's broken/unmaintained and needs to be rewritten to avoid managed\npointers and needless copies. A full rewrite is necessary and the API\nwill need to be redone so it's not worth keeping this around.\n\nCloses #2236, #2744", "tree": {"sha": "68d707f10ec0d76e62d7f2e379d0f6d73830f1b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68d707f10ec0d76e62d7f2e379d0f6d73830f1b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01833de7ea4c3d73351277b52f841d42d7d2dbb8", "comment_count": 10, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01833de7ea4c3d73351277b52f841d42d7d2dbb8", "html_url": "https://github.com/rust-lang/rust/commit/01833de7ea4c3d73351277b52f841d42d7d2dbb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01833de7ea4c3d73351277b52f841d42d7d2dbb8/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e933b199c69e1b6c32ecb65bb8f06127cfb8312", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e933b199c69e1b6c32ecb65bb8f06127cfb8312", "html_url": "https://github.com/rust-lang/rust/commit/3e933b199c69e1b6c32ecb65bb8f06127cfb8312"}], "stats": {"total": 1446, "additions": 1, "deletions": 1445}, "files": [{"sha": "c4f72d10a8ae590e42f22a5ca302b2f58b3b7179", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01833de7ea4c3d73351277b52f841d42d7d2dbb8/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01833de7ea4c3d73351277b52f841d42d7d2dbb8/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=01833de7ea4c3d73351277b52f841d42d7d2dbb8", "patch": "@@ -74,7 +74,6 @@ pub mod deque;\n pub mod fun_treemap;\n pub mod list;\n pub mod priority_queue;\n-pub mod rope;\n pub mod smallintmap;\n \n pub mod sort;"}, {"sha": "dd3f08917fd4854658b2931b604c537b9c29b895", "filename": "src/libextra/rope.rs", "status": "removed", "additions": 0, "deletions": 1442, "changes": 1442, "blob_url": "https://github.com/rust-lang/rust/blob/3e933b199c69e1b6c32ecb65bb8f06127cfb8312/src%2Flibextra%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e933b199c69e1b6c32ecb65bb8f06127cfb8312/src%2Flibextra%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frope.rs?ref=3e933b199c69e1b6c32ecb65bb8f06127cfb8312", "patch": "@@ -1,1442 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * High-level text containers.\n- *\n- * Ropes are a high-level representation of text that offers\n- * much better performance than strings for common operations,\n- * and generally reduce memory allocations and copies, while only\n- * entailing a small degradation of less common operations.\n- *\n- * More precisely, where a string is represented as a memory buffer,\n- * a rope is a tree structure whose leaves are slices of immutable\n- * strings. Therefore, concatenation, appending, prepending, substrings,\n- * etc. are operations that require only trivial tree manipulation,\n- * generally without having to copy memory. In addition, the tree\n- * structure of ropes makes them suitable as a form of index to speed-up\n- * access to Unicode characters by index in long chunks of text.\n- *\n- * The following operations are algorithmically faster in ropes:\n- *\n- * * extracting a subrope is logarithmic (linear in strings);\n- * * appending/prepending is near-constant time (linear in strings);\n- * * concatenation is near-constant time (linear in strings);\n- * * char length is constant-time (linear in strings);\n- * * access to a character by index is logarithmic (linear in strings);\n- */\n-\n-#[allow(missing_doc)];\n-\n-\n-use std::uint;\n-use std::vec;\n-use std::str;\n-\n-/// The type of ropes.\n-pub type Rope = node::Root;\n-\n-/*\n- Section: Creating a rope\n- */\n-\n-/// Create an empty rope\n-pub fn empty() -> Rope {\n-   return node::Empty;\n-}\n-\n-/**\n- * Adopt a string as a rope.\n- *\n- * # Arguments\n- *\n- * * str - A valid string.\n- *\n- * # Return value\n- *\n- * A rope representing the same string as `str`. Depending of the length\n- * of `str`, this rope may be empty, flat or complex.\n- *\n- * # Performance notes\n- *\n- * * this operation does not copy the string;\n- * * the function runs in linear time.\n- */\n-pub fn of_str(str: @~str) -> Rope {\n-    return of_substr(str, 0u, str.len());\n-}\n-\n-/**\n- * As `of_str` but for a substring.\n- *\n- * # Arguments\n- * * byte_offset - The offset of `str` at which the rope starts.\n- * * byte_len - The number of bytes of `str` to use.\n- *\n- * # Return value\n- *\n- * A rope representing the same string as `str.slice(byte_offset,\n- * byte_offset + byte_len)`.  Depending on `byte_len`, this rope may\n- * be empty, flat or complex.\n- *\n- * # Performance note\n- *\n- * This operation does not copy the substring.\n- *\n- * # Safety notes\n- *\n- * * this function does _not_ check the validity of the substring;\n- * * this function fails if `byte_offset` or `byte_len` do not match `str`.\n- */\n-pub fn of_substr(str: @~str, byte_offset: uint, byte_len: uint) -> Rope {\n-    if byte_len == 0u { return node::Empty; }\n-    if byte_offset + byte_len  > str.len() { fail!(); }\n-    return node::Content(node::of_substr(str, byte_offset, byte_len));\n-}\n-\n-/*\n-Section: Adding things to a rope\n- */\n-\n-/**\n- * Add one char to the end of the rope\n- *\n- * # Performance note\n- *\n- * * this function executes in near-constant time\n- */\n-pub fn append_char(rope: Rope, char: char) -> Rope {\n-    return append_str(rope, @str::from_chars([char]));\n-}\n-\n-/**\n- * Add one string to the end of the rope\n- *\n- * # Performance note\n- *\n- * * this function executes in near-linear time\n- */\n-pub fn append_str(rope: Rope, str: @~str) -> Rope {\n-    return append_rope(rope, of_str(str))\n-}\n-\n-/**\n- * Add one char to the beginning of the rope\n- *\n- * # Performance note\n- * * this function executes in near-constant time\n- */\n-pub fn prepend_char(rope: Rope, char: char) -> Rope {\n-    return prepend_str(rope, @str::from_chars([char]));\n-}\n-\n-/**\n- * Add one string to the beginning of the rope\n- *\n- * # Performance note\n- * * this function executes in near-linear time\n- */\n-pub fn prepend_str(rope: Rope, str: @~str) -> Rope {\n-    return append_rope(of_str(str), rope)\n-}\n-\n-/// Concatenate two ropes\n-pub fn append_rope(left: Rope, right: Rope) -> Rope {\n-   match (left) {\n-     node::Empty => return right,\n-     node::Content(left_content) => {\n-       match (right) {\n-         node::Empty => return left,\n-         node::Content(right_content) => {\n-           return node::Content(node::concat2(left_content, right_content));\n-         }\n-       }\n-     }\n-   }\n-}\n-\n-/**\n- * Concatenate many ropes.\n- *\n- * If the ropes are balanced initially and have the same height, the resulting\n- * rope remains balanced. However, this function does not take any further\n- * measure to ensure that the result is balanced.\n- */\n-pub fn concat(v: ~[Rope]) -> Rope {\n-    //Copy `v` into a mut vector\n-    let mut len = v.len();\n-    if len == 0u { return node::Empty; }\n-    let mut ropes = vec::from_elem(len, v[0]);\n-    for uint::range(1u, len) |i| {\n-       ropes[i] = v[i];\n-    }\n-\n-    //Merge progresively\n-    while len > 1u {\n-        for uint::range(0u, len/2u) |i| {\n-            ropes[i] = append_rope(ropes[2u*i], ropes[2u*i+1u]);\n-        }\n-        if len%2u != 0u {\n-            ropes[len/2u] = ropes[len - 1u];\n-            len = len/2u + 1u;\n-        } else {\n-            len = len/2u;\n-        }\n-    }\n-\n-    //Return final rope\n-    return ropes[0];\n-}\n-\n-\n-/*\n-Section: Keeping ropes healthy\n- */\n-\n-\n-/**\n- * Balance a rope.\n- *\n- * # Return value\n- *\n- * A copy of the rope in which small nodes have been grouped in memory,\n- * and with a reduced height.\n- *\n- * If you perform numerous rope concatenations, it is generally a good idea\n- * to rebalance your rope at some point, before using it for other purposes.\n- */\n-pub fn bal(rope:Rope) -> Rope {\n-    match (rope) {\n-      node::Empty => return rope,\n-      node::Content(x) => match (node::bal(x)) {\n-        None    => rope,\n-        Some(y) => node::Content(y)\n-      }\n-    }\n-}\n-\n-/*\n-Section: Transforming ropes\n- */\n-\n-\n-/**\n- * Extract a subrope from a rope.\n- *\n- * # Performance note\n- *\n- * * on a balanced rope, this operation takes algorithmic time;\n- * * this operation does not involve any copying\n- *\n- * # Safety note\n- *\n- * * this function fails if char_offset/char_len do not represent\n- *   valid positions in rope\n- */\n-pub fn sub_chars(rope: Rope, char_offset: uint, char_len: uint) -> Rope {\n-    if char_len == 0u { return node::Empty; }\n-    match (rope) {\n-      node::Empty => fail!(),\n-      node::Content(node) => if char_len > node::char_len(node) {\n-        fail!()\n-      } else {\n-        return node::Content(node::sub_chars(node, char_offset, char_len))\n-      }\n-    }\n-}\n-\n-/**\n- * Extract a subrope from a rope.\n- *\n- * # Performance note\n- *\n- * * on a balanced rope, this operation takes algorithmic time;\n- * * this operation does not involve any copying\n- *\n- * # Safety note\n- *\n- * * this function fails if byte_offset/byte_len do not represent\n- *   valid positions in rope\n- */\n-pub fn sub_bytes(rope: Rope, byte_offset: uint, byte_len: uint) -> Rope {\n-    if byte_len == 0u { return node::Empty; }\n-    match (rope) {\n-      node::Empty => fail!(),\n-      node::Content(node) =>if byte_len > node::byte_len(node) {\n-        fail!()\n-      } else {\n-        return node::Content(node::sub_bytes(node, byte_offset, byte_len))\n-      }\n-    }\n-}\n-\n-/*\n-Section: Comparing ropes\n- */\n-\n-/**\n- * Compare two ropes by Unicode lexicographical order.\n- *\n- * This function compares only the contents of the rope, not their structure.\n- *\n- * # Return value\n- *\n- * A negative value if `left < right`, 0 if eq(left, right) or a positive\n- * value if `left > right`\n- */\n-pub fn cmp(left: Rope, right: Rope) -> int {\n-    match ((left, right)) {\n-      (node::Empty, node::Empty) => return 0,\n-      (node::Empty, _)     => return -1,\n-      (_, node::Empty)     => return  1,\n-      (node::Content(a), node::Content(b)) => {\n-        return node::cmp(a, b);\n-      }\n-    }\n-}\n-\n-/**\n- * Returns `true` if both ropes have the same content (regardless of\n- * their structure), `false` otherwise\n- */\n-pub fn eq(left: Rope, right: Rope) -> bool {\n-    return cmp(left, right) == 0;\n-}\n-\n-/**\n- * # Arguments\n- *\n- * * left - an arbitrary rope\n- * * right - an arbitrary rope\n- *\n- * # Return value\n- *\n- * `true` if `left <= right` in lexicographical order (regardless of their\n- * structure), `false` otherwise\n- */\n-pub fn le(left: Rope, right: Rope) -> bool {\n-    return cmp(left, right) <= 0;\n-}\n-\n-/**\n- * # Arguments\n- *\n- * * left - an arbitrary rope\n- * * right - an arbitrary rope\n- *\n- * # Return value\n- *\n- * `true` if `left < right` in lexicographical order (regardless of their\n- * structure), `false` otherwise\n- */\n-pub fn lt(left: Rope, right: Rope) -> bool {\n-    return cmp(left, right) < 0;\n-}\n-\n-/**\n- * # Arguments\n- *\n- * * left - an arbitrary rope\n- * * right - an arbitrary rope\n- *\n- * # Return value\n- *\n- *  `true` if `left >= right` in lexicographical order (regardless of their\n- * structure), `false` otherwise\n- */\n-pub fn ge(left: Rope, right: Rope) -> bool {\n-    return cmp(left, right) >= 0;\n-}\n-\n-/**\n- * # Arguments\n- *\n- * * left - an arbitrary rope\n- * * right - an arbitrary rope\n- *\n- * # Return value\n- *\n- * `true` if `left > right` in lexicographical order (regardless of their\n- * structure), `false` otherwise\n- */\n-pub fn gt(left: Rope, right: Rope) -> bool {\n-    return cmp(left, right) > 0;\n-}\n-\n-/*\n-Section: Iterating\n- */\n-\n-/**\n- * Loop through a rope, char by char\n- *\n- * While other mechanisms are available, this is generally the best manner\n- * of looping through the contents of a rope char by char. If you prefer a\n- * loop that iterates through the contents string by string (e.g. to print\n- * the contents of the rope or output it to the system), however,\n- * you should rather use `traverse_components`.\n- *\n- * # Arguments\n- *\n- * * rope - A rope to traverse. It may be empty.\n- * * it - A block to execute with each consecutive character of the rope.\n- *        Return `true` to continue, `false` to stop.\n- *\n- * # Return value\n- *\n- * `true` If execution proceeded correctly, `false` if it was interrupted,\n- * that is if `it` returned `false` at any point.\n- */\n-pub fn loop_chars(rope: Rope, it: &fn(c: char) -> bool) -> bool {\n-   match (rope) {\n-      node::Empty => return true,\n-      node::Content(x) => return node::loop_chars(x, it)\n-   }\n-}\n-\n-/**\n- * Loop through a rope, char by char, until the end.\n- *\n- * # Arguments\n- * * rope - A rope to traverse. It may be empty\n- * * it - A block to execute with each consecutive character of the rope.\n- */\n-pub fn iter_chars(rope: Rope, it: &fn(char)) {\n-    do loop_chars(rope) |x| {\n-        it(x);\n-        true\n-    };\n-}\n-\n-/**\n- * Loop through a rope, string by string\n- *\n- * While other mechanisms are available, this is generally the best manner of\n- * looping through the contents of a rope string by string, which may be\n- * useful e.g. to print strings as you see them (without having to copy their\n- * contents into a new string), to send them to then network, to write them to\n- * a file, etc.. If you prefer a loop that iterates through the contents\n- * char by char (e.g. to search for a char), however, you should rather\n- * use `traverse`.\n- *\n- * # Arguments\n- *\n- * * rope - A rope to traverse. It may be empty\n- * * it - A block to execute with each consecutive string component of the\n- *        rope. Return `true` to continue, `false` to stop\n- *\n- * # Return value\n- *\n- * `true` If execution proceeded correctly, `false` if it was interrupted,\n- * that is if `it` returned `false` at any point.\n- */\n-pub fn loop_leaves(rope: Rope, it: &fn(node::Leaf) -> bool) -> bool{\n-   match (rope) {\n-      node::Empty => return true,\n-      node::Content(x) => return node::loop_leaves(x, it)\n-   }\n-}\n-\n-pub mod iterator {\n-    pub mod leaf {\n-\n-        use rope::{Rope, node};\n-\n-        pub fn start(rope: Rope) -> node::leaf_iterator::T {\n-            match (rope) {\n-              node::Empty      => return node::leaf_iterator::empty(),\n-              node::Content(x) => return node::leaf_iterator::start(x)\n-            }\n-        }\n-        pub fn next(it: &mut node::leaf_iterator::T) -> Option<node::Leaf> {\n-            return node::leaf_iterator::next(it);\n-        }\n-    }\n-    pub mod char {\n-\n-        use rope::{Rope, node};\n-\n-        pub fn start(rope: Rope) -> node::char_iterator::T {\n-            match (rope) {\n-              node::Empty      => return node::char_iterator::empty(),\n-              node::Content(x) => return node::char_iterator::start(x)\n-            }\n-        }\n-        pub fn next(it: &mut node::char_iterator::T) -> Option<char> {\n-            return node::char_iterator::next(it)\n-        }\n-    }\n-}\n-\n-/*\n- Section: Rope properties\n- */\n-\n-/**\n- * Returns the height of the rope.\n- *\n- * The height of the rope is a bound on the number of operations which\n- * must be performed during a character access before finding the leaf in\n- * which a character is contained.\n- *\n- * # Performance note\n- *\n- * Constant time.\n- */\n-pub fn height(rope: Rope) -> uint {\n-   match (rope) {\n-      node::Empty      => return 0u,\n-      node::Content(x) => return node::height(x)\n-   }\n-}\n-\n-\n-\n-/**\n- * The number of character in the rope\n- *\n- * # Performance note\n- *\n- * Constant time.\n- */\n-pub fn char_len(rope: Rope) -> uint {\n-   match (rope) {\n-     node::Empty            => return 0u,\n-     node::Content(x)       => return node::char_len(x)\n-   }\n-}\n-\n-/**\n- * The number of bytes in the rope\n- *\n- * # Performance note\n- *\n- * Constant time.\n- */\n-pub fn byte_len(rope: Rope) -> uint {\n-   match (rope) {\n-     node::Empty            => return 0u,\n-     node::Content(x)       => return node::byte_len(x)\n-   }\n-}\n-\n-/**\n- * The character at position `pos`\n- *\n- * # Arguments\n- *\n- * * pos - A position in the rope\n- *\n- * # Safety notes\n- *\n- * The function will fail if `pos` is not a valid position in the rope.\n- *\n- * # Performance note\n- *\n- * This function executes in a time proportional to the height of the\n- * rope + the (bounded) length of the largest leaf.\n- */\n-pub fn char_at(rope: Rope, pos: uint) -> char {\n-   match (rope) {\n-      node::Empty => fail!(),\n-      node::Content(x) => return node::char_at(x, pos)\n-   }\n-}\n-\n-\n-/*\n- Section: Implementation\n-*/\n-pub mod node {\n-\n-    use rope::node;\n-\n-    use std::cast;\n-    use std::uint;\n-    use std::vec;\n-\n-    /// Implementation of type `rope`\n-    pub enum Root {\n-        /// An empty rope\n-        Empty,\n-        /// A non-empty rope\n-        Content(@Node),\n-    }\n-\n-    /**\n-     * A text component in a rope.\n-     *\n-     * This is actually a slice in a rope, so as to ensure maximal sharing.\n-     *\n-     * # Fields\n-     *\n-     * * byte_offset = The number of bytes skipped in `content`\n-     * * byte_len - The number of bytes of `content` to use\n-     * * char_len - The number of chars in the leaf.\n-     * * content - Contents of the leaf.\n-     *\n-     *     Note that we can have `char_len < content.char_len()`, if\n-     *     this leaf is only a subset of the string. Also note that the\n-     *     string can be shared between several ropes, e.g. for indexing\n-     *     purposes.\n-     */\n-    pub struct Leaf {\n-        byte_offset: uint,\n-        byte_len: uint,\n-        char_len: uint,\n-        content: @~str,\n-    }\n-\n-    /**\n-     * A node obtained from the concatenation of two other nodes\n-     *\n-     * # Fields\n-     *\n-     * * left - The node containing the beginning of the text.\n-     * * right - The node containing the end of the text.\n-     * * char_len - The number of chars contained in all leaves of this node.\n-     * * byte_len - The number of bytes in the subrope.\n-     *\n-     *     Used to pre-allocate the correct amount of storage for\n-     *     serialization.\n-     *\n-     * * height - Height of the subrope.\n-     *\n-     *     Used for rebalancing and to allocate stacks for traversals.\n-     */\n-    pub struct Concat {\n-        //FIXME (#2744): Perhaps a `vec` instead of `left`/`right`\n-        left: @Node,\n-        right: @Node,\n-        char_len: uint,\n-        byte_len: uint,\n-        height: uint,\n-    }\n-\n-    pub enum Node {\n-        /// A leaf consisting in a `str`\n-        Leaf(Leaf),\n-        /// The concatenation of two ropes\n-        Concat(Concat),\n-    }\n-\n-    /**\n-     * The maximal number of chars that _should_ be permitted in a single node\n-     *\n-     * This is not a strict value\n-     */\n-    pub static HINT_MAX_LEAF_CHAR_LEN: uint = 256u;\n-\n-    /**\n-     * The maximal height that _should_ be permitted in a tree.\n-     *\n-     * This is not a strict value\n-     */\n-    pub static HINT_MAX_NODE_HEIGHT:   uint = 16u;\n-\n-    /**\n-     * Adopt a string as a node.\n-     *\n-     * If the string is longer than `max_leaf_char_len`, it is\n-     * logically split between as many leaves as necessary. Regardless,\n-     * the string itself is not copied.\n-     *\n-     * Performance note: The complexity of this function is linear in\n-     * the length of `str`.\n-     */\n-    pub fn of_str(str: @~str) -> @Node {\n-        return of_substr(str, 0u, str.len());\n-    }\n-\n-    /**\n-     * Adopt a slice of a string as a node.\n-     *\n-     * If the slice is longer than `max_leaf_char_len`, it is logically split\n-     * between as many leaves as necessary. Regardless, the string itself\n-     * is not copied\n-     *\n-     * # Arguments\n-     *\n-     * * byte_start - The byte offset where the slice of `str` starts.\n-     * * byte_len   - The number of bytes from `str` to use.\n-     *\n-     * # Safety note\n-     *\n-     * Behavior is undefined if `byte_start` or `byte_len` do not represent\n-     * valid positions in `str`\n-     */\n-    pub fn of_substr(str: @~str, byte_start: uint, byte_len: uint) -> @Node {\n-        return of_substr_unsafer(str, byte_start, byte_len,\n-                                 str.slice(byte_start, byte_start + byte_len).char_len());\n-    }\n-\n-    /**\n-     * Adopt a slice of a string as a node.\n-     *\n-     * If the slice is longer than `max_leaf_char_len`, it is logically split\n-     * between as many leaves as necessary. Regardless, the string itself\n-     * is not copied\n-     *\n-     * # Arguments\n-     *\n-     * * byte_start - The byte offset where the slice of `str` starts.\n-     * * byte_len - The number of bytes from `str` to use.\n-     * * char_len - The number of chars in `str` in the interval\n-     *              [byte_start, byte_start+byte_len)\n-     *\n-     * # Safety notes\n-     *\n-     * * Behavior is undefined if `byte_start` or `byte_len` do not represent\n-     *   valid positions in `str`\n-     * * Behavior is undefined if `char_len` does not accurately represent the\n-     *   number of chars between byte_start and byte_start+byte_len\n-     */\n-    pub fn of_substr_unsafer(str: @~str, byte_start: uint, byte_len: uint,\n-                             char_len: uint) -> @Node {\n-        assert!((byte_start + byte_len <= str.len()));\n-        let candidate = @Leaf(Leaf {\n-            byte_offset: byte_start,\n-            byte_len: byte_len,\n-            char_len: char_len,\n-            content: str,\n-        });\n-        if char_len <= HINT_MAX_LEAF_CHAR_LEN {\n-            return candidate;\n-        } else {\n-            //Firstly, split `str` in slices of HINT_MAX_LEAF_CHAR_LEN\n-            let mut leaves = uint::div_ceil(char_len, HINT_MAX_LEAF_CHAR_LEN);\n-            //Number of leaves\n-            let mut nodes  = vec::from_elem(leaves, candidate);\n-\n-            let mut i = 0u;\n-            let mut offset = byte_start;\n-            let first_leaf_char_len =\n-                if char_len%HINT_MAX_LEAF_CHAR_LEN == 0u {\n-                  HINT_MAX_LEAF_CHAR_LEN\n-                } else {\n-                char_len%HINT_MAX_LEAF_CHAR_LEN\n-               };\n-            while i < leaves {\n-                let chunk_char_len: uint =\n-                    if i == 0u  { first_leaf_char_len }\n-                    else { HINT_MAX_LEAF_CHAR_LEN };\n-                let chunk_byte_len =\n-                    str.slice_from(offset).slice_chars(0, chunk_char_len).len();\n-                nodes[i] = @Leaf(Leaf {\n-                    byte_offset: offset,\n-                    byte_len: chunk_byte_len,\n-                    char_len: chunk_char_len,\n-                    content: str,\n-                });\n-\n-                offset += chunk_byte_len;\n-                i      += 1u;\n-            }\n-\n-            //Then, build a tree from these slices by collapsing them\n-            while leaves > 1u {\n-                i = 0u;\n-                while i < leaves - 1u {//Concat nodes 0 with 1, 2 with 3 etc.\n-                    nodes[i/2u] = concat2(nodes[i], nodes[i + 1u]);\n-                    i += 2u;\n-                }\n-                if i == leaves - 1u {\n-                    //And don't forget the last node if it is in even position\n-                    nodes[i/2u] = nodes[i];\n-                }\n-                leaves = uint::div_ceil(leaves, 2u);\n-            }\n-            return nodes[0u];\n-        }\n-    }\n-\n-    pub fn byte_len(node: @Node) -> uint {\n-        //FIXME (#2744): Could we do this without the pattern-matching?\n-        match (*node) {\n-          Leaf(y) => y.byte_len,\n-          Concat(ref y) => y.byte_len\n-        }\n-    }\n-\n-    pub fn char_len(node: @Node) -> uint {\n-        match (*node) {\n-          Leaf(y) => y.char_len,\n-          Concat(ref y) => y.char_len\n-        }\n-    }\n-\n-    /**\n-     * Concatenate a forest of nodes into one tree.\n-     *\n-     * # Arguments\n-     *\n-     * * forest - The forest. This vector is progressively rewritten during\n-     *            execution and should be discarded as meaningless afterwards.\n-     */\n-    pub fn tree_from_forest_destructive(forest: &mut [@Node]) -> @Node {\n-        let mut i;\n-        let mut len = forest.len();\n-        while len > 1u {\n-            i = 0u;\n-            while i < len - 1u {//Concat nodes 0 with 1, 2 with 3 etc.\n-                let mut left  = forest[i];\n-                let mut right = forest[i+1u];\n-                let left_len = char_len(left);\n-                let right_len= char_len(right);\n-                let mut left_height= height(left);\n-                let mut right_height=height(right);\n-                if left_len + right_len > HINT_MAX_LEAF_CHAR_LEN {\n-                    if left_len <= HINT_MAX_LEAF_CHAR_LEN {\n-                        left = flatten(left);\n-                        left_height = height(left);\n-                    }\n-                    if right_len <= HINT_MAX_LEAF_CHAR_LEN {\n-                        right = flatten(right);\n-                        right_height = height(right);\n-                    }\n-                }\n-                if left_height >= HINT_MAX_NODE_HEIGHT {\n-                    left = of_substr_unsafer(@serialize_node(left),\n-                                             0u,byte_len(left),\n-                                             left_len);\n-                }\n-                if right_height >= HINT_MAX_NODE_HEIGHT {\n-                    right = of_substr_unsafer(@serialize_node(right),\n-                                             0u,byte_len(right),\n-                                             right_len);\n-                }\n-                forest[i/2u] = concat2(left, right);\n-                i += 2u;\n-            }\n-            if i == len - 1u {\n-                //And don't forget the last node if it is in even position\n-                forest[i/2u] = forest[i];\n-            }\n-            len = uint::div_ceil(len, 2u);\n-        }\n-        return forest[0];\n-    }\n-\n-    pub fn serialize_node(node: @Node) -> ~str {\n-        unsafe {\n-            let mut buf = vec::from_elem(byte_len(node), 0);\n-            let mut offset = 0u;//Current position in the buffer\n-            let mut it = leaf_iterator::start(node);\n-            loop {\n-                match leaf_iterator::next(&mut it) {\n-                  None => break,\n-                  Some(x) => {\n-                    //FIXME (#2744): Replace with memcpy or something similar\n-                    let local_buf: ~[u8] = cast::transmute(copy *x.content);\n-                    let mut i = x.byte_offset;\n-                    while i < x.byte_len {\n-                        buf[offset] = local_buf[i];\n-                        offset += 1u;\n-                        i      += 1u;\n-                    }\n-                    cast::forget(local_buf);\n-                  }\n-                }\n-            }\n-            return cast::transmute(buf);\n-        }\n-    }\n-\n-    /**\n-     * Replace a subtree by a single leaf with the same contents.\n-     *\n-     * * Performance note\n-     *\n-     * This function executes in linear time.\n-     */\n-    pub fn flatten(node: @Node) -> @Node {\n-        match (*node) {\n-            Leaf(_) => node,\n-            Concat(ref x) => {\n-                @Leaf(Leaf {\n-                    byte_offset: 0u,\n-                    byte_len: x.byte_len,\n-                    char_len: x.char_len,\n-                    content: @serialize_node(node),\n-                })\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Balance a node.\n-     *\n-     * # Algorithm\n-     *\n-     * * if the node height is smaller than `HINT_MAX_NODE_HEIGHT`, do nothing\n-     * * otherwise, gather all leaves as a forest, rebuild a balanced node,\n-     *   concatenating small leaves along the way\n-     *\n-     * # Return value\n-     *\n-     * * `None` if no transformation happened\n-     * * `Some(x)` otherwise, in which case `x` has the same contents\n-     *    as `node` bot lower height and/or fragmentation.\n-     */\n-    pub fn bal(node: @Node) -> Option<@Node> {\n-        if height(node) < HINT_MAX_NODE_HEIGHT { return None; }\n-        //1. Gather all leaves as a forest\n-        let mut forest = ~[];\n-        let mut it = leaf_iterator::start(node);\n-        loop {\n-            match leaf_iterator::next(&mut it) {\n-              None    => break,\n-              Some(x) => forest.push(@Leaf(x))\n-            }\n-        }\n-        //2. Rebuild tree from forest\n-        let root = @*tree_from_forest_destructive(forest);\n-        return Some(root);\n-\n-    }\n-\n-    /**\n-     * Compute the subnode of a node.\n-     *\n-     * # Arguments\n-     *\n-     * * node        - A node\n-     * * byte_offset - A byte offset in `node`\n-     * * byte_len    - The number of bytes to return\n-     *\n-     * # Performance notes\n-     *\n-     * * this function performs no copying;\n-     * * this function executes in a time proportional to the height of `node`\n-     *\n-     * # Safety notes\n-     *\n-     * This function fails if `byte_offset` or `byte_len` do not represent\n-     * valid positions in `node`.\n-     */\n-    pub fn sub_bytes(node: @Node, byte_offset: uint,\n-                     byte_len: uint) -> @Node {\n-        let mut node        = node;\n-        let mut byte_offset = byte_offset;\n-        loop {\n-            if byte_offset == 0u && byte_len == node::byte_len(node) {\n-                return node;\n-            }\n-            match (*node) {\n-              node::Leaf(x) => {\n-                let char_len =\n-                    x.content.slice(byte_offset, byte_offset + byte_len).char_len();\n-                return @Leaf(Leaf {\n-                    byte_offset: byte_offset,\n-                    byte_len: byte_len,\n-                    char_len: char_len,\n-                    content: x.content,\n-                });\n-              }\n-              node::Concat(ref x) => {\n-                let left_len: uint = node::byte_len(x.left);\n-                if byte_offset <= left_len {\n-                    if byte_offset + byte_len <= left_len {\n-                        //Case 1: Everything fits in x.left, tail-call\n-                        node = x.left;\n-                    } else {\n-                        //Case 2: A (non-empty, possibly full) suffix\n-                        //of x.left and a (non-empty, possibly full) prefix\n-                        //of x.right\n-                        let left_result  =\n-                            sub_bytes(x.left, byte_offset, left_len);\n-                        let right_result =\n-                            sub_bytes(x.right, 0u, left_len - byte_offset);\n-                        return concat2(left_result, right_result);\n-                    }\n-                } else {\n-                    //Case 3: Everything fits in x.right\n-                    byte_offset -= left_len;\n-                    node = x.right;\n-                }\n-              }\n-            }\n-        };\n-    }\n-\n-    /**\n-     * Compute the subnode of a node.\n-     *\n-     * # Arguments\n-     *\n-     * * node        - A node\n-     * * char_offset - A char offset in `node`\n-     * * char_len    - The number of chars to return\n-     *\n-     * # Performance notes\n-     *\n-     * * this function performs no copying;\n-     * * this function executes in a time proportional to the height of `node`\n-     *\n-     * # Safety notes\n-     *\n-     * This function fails if `char_offset` or `char_len` do not represent\n-     * valid positions in `node`.\n-     */\n-    pub fn sub_chars(node: @Node, char_offset: uint,\n-                     char_len: uint) -> @Node {\n-        let mut node        = node;\n-        let mut char_offset = char_offset;\n-        loop {\n-            match (*node) {\n-              node::Leaf(x) => {\n-                if char_offset == 0u && char_len == x.char_len {\n-                    return node;\n-                }\n-                let byte_offset =\n-                    x.content.slice_chars(0, char_offset).len();\n-                let byte_len    =\n-                    x.content.slice_from(byte_offset).slice_chars(0, char_len).len();\n-                return @Leaf(Leaf {\n-                    byte_offset: byte_offset,\n-                    byte_len: byte_len,\n-                    char_len: char_len,\n-                    content: x.content,\n-                });\n-              }\n-              node::Concat(ref x) => {\n-                if char_offset == 0u && char_len == x.char_len {return node;}\n-                let left_len : uint = node::char_len(x.left);\n-                if char_offset <= left_len {\n-                    if char_offset + char_len <= left_len {\n-                        //Case 1: Everything fits in x.left, tail call\n-                        node        = x.left;\n-                    } else {\n-                        //Case 2: A (non-empty, possibly full) suffix\n-                        //of x.left and a (non-empty, possibly full) prefix\n-                        //of x.right\n-                        let left_result  =\n-                            sub_chars(x.left, char_offset, left_len);\n-                        let right_result =\n-                            sub_chars(x.right, 0u, left_len - char_offset);\n-                        return concat2(left_result, right_result);\n-                    }\n-                } else {\n-                    //Case 3: Everything fits in x.right, tail call\n-                    node = x.right;\n-                    char_offset -= left_len;\n-                }\n-              }\n-            }\n-        };\n-    }\n-\n-    pub fn concat2(left: @Node, right: @Node) -> @Node {\n-        @Concat(Concat {\n-            left: left,\n-            right: right,\n-            char_len: char_len(left) + char_len(right),\n-            byte_len: byte_len(left) + byte_len(right),\n-            height: uint::max(height(left), height(right)) + 1u,\n-        })\n-    }\n-\n-    pub fn height(node: @Node) -> uint {\n-        match (*node) {\n-          Leaf(_) => 0u,\n-          Concat(ref x) => x.height,\n-        }\n-    }\n-\n-    pub fn cmp(a: @Node, b: @Node) -> int {\n-        let mut ita = char_iterator::start(a);\n-        let mut itb = char_iterator::start(b);\n-        let mut result = 0;\n-        while result == 0 {\n-            match (char_iterator::next(&mut ita), char_iterator::next(&mut itb))\n-            {\n-              (None, None) => break,\n-              (Some(chara), Some(charb)) => {\n-                result = chara.cmp(&charb) as int;\n-              }\n-              (Some(_), _) => {\n-                result = 1;\n-              }\n-              (_, Some(_)) => {\n-                result = -1;\n-              }\n-            }\n-        }\n-        return result;\n-    }\n-\n-    pub fn loop_chars(node: @Node, it: &fn(c: char) -> bool) -> bool {\n-        return loop_leaves(node,|leaf| {\n-            leaf.content.slice(leaf.byte_offset, leaf.byte_len).iter().all(|c| it(c))\n-        });\n-    }\n-\n-    /**\n-     * Loop through a node, leaf by leaf\n-     *\n-     * # Arguments\n-     *\n-     * * rope - A node to traverse.\n-     * * it - A block to execute with each consecutive leaf of the node.\n-     *        Return `true` to continue, `false` to stop\n-     *\n-     * # Arguments\n-     *\n-     * `true` If execution proceeded correctly, `false` if it was interrupted,\n-     * that is if `it` returned `false` at any point.\n-     */\n-    pub fn loop_leaves(node: @Node, it: &fn(Leaf) -> bool) -> bool{\n-        let mut current = node;\n-        loop {\n-            match (*current) {\n-              Leaf(x) => return it(x),\n-              Concat(ref x) => if loop_leaves(x.left, |l| it(l)) { //non tail call\n-                current = x.right;       //tail call\n-              } else {\n-                return false;\n-              }\n-            }\n-        };\n-    }\n-\n-    /**\n-     * # Arguments\n-     *\n-     * * pos - A position in the rope\n-     *\n-     * # Return value\n-     *\n-     * The character at position `pos`\n-     *\n-     * # Safety notes\n-     *\n-     * The function will fail if `pos` is not a valid position in the rope.\n-     *\n-     * Performance note: This function executes in a time\n-     * proportional to the height of the rope + the (bounded)\n-     * length of the largest leaf.\n-     */\n-    pub fn char_at(mut node: @Node, mut pos: uint) -> char {\n-        loop {\n-            match *node {\n-              Leaf(x) => return x.content.char_at(pos),\n-              Concat(Concat {left, right, _}) => {\n-                let left_len = char_len(left);\n-                node = if left_len > pos { left }\n-                       else { pos -= left_len; right };\n-              }\n-            }\n-        };\n-    }\n-\n-    pub mod leaf_iterator {\n-\n-        use rope::node::{Concat, Leaf, Node, height};\n-\n-        use std::vec;\n-\n-        pub struct T {\n-            stack: ~[@Node],\n-            stackpos: int,\n-        }\n-\n-        pub fn empty() -> T {\n-            let stack : ~[@Node] = ~[];\n-            T { stack: stack, stackpos: -1 }\n-        }\n-\n-        pub fn start(node: @Node) -> T {\n-            let stack = vec::from_elem(height(node)+1u, node);\n-            T {\n-                stack: stack,\n-                stackpos:  0,\n-            }\n-        }\n-\n-        pub fn next(it: &mut T) -> Option<Leaf> {\n-            if it.stackpos < 0 { return None; }\n-            loop {\n-                let current = it.stack[it.stackpos];\n-                it.stackpos -= 1;\n-                match (*current) {\n-                  Concat(ref x) => {\n-                    it.stackpos += 1;\n-                    it.stack[it.stackpos] = x.right;\n-                    it.stackpos += 1;\n-                    it.stack[it.stackpos] = x.left;\n-                  }\n-                  Leaf(x) => return Some(x)\n-                }\n-            };\n-        }\n-    }\n-\n-    pub mod char_iterator {\n-\n-        use rope::node::{Leaf, Node};\n-        use rope::node::leaf_iterator;\n-\n-        pub struct T {\n-            leaf_iterator: leaf_iterator::T,\n-            leaf:  Option<Leaf>,\n-            leaf_byte_pos: uint,\n-        }\n-\n-        pub fn start(node: @Node) -> T {\n-            T {\n-                leaf_iterator: leaf_iterator::start(node),\n-                leaf: None,\n-                leaf_byte_pos: 0u,\n-            }\n-        }\n-\n-        pub fn empty() -> T {\n-            T {\n-                leaf_iterator: leaf_iterator::empty(),\n-                leaf: None,\n-                leaf_byte_pos: 0u,\n-            }\n-        }\n-\n-        pub fn next(it: &mut T) -> Option<char> {\n-            loop {\n-                match get_current_or_next_leaf(it) {\n-                  None => return None,\n-                  Some(_) => {\n-                    let next_char = get_next_char_in_leaf(it);\n-                    match next_char {\n-                      None => loop,\n-                      Some(_) => return next_char\n-                    }\n-                  }\n-                }\n-            };\n-        }\n-\n-        pub fn get_current_or_next_leaf(it: &mut T) -> Option<Leaf> {\n-            match it.leaf {\n-              Some(_) => return it.leaf,\n-              None => {\n-                let next = leaf_iterator::next(&mut it.leaf_iterator);\n-                match next {\n-                  None => return None,\n-                  Some(_) => {\n-                    it.leaf          = next;\n-                    it.leaf_byte_pos = 0u;\n-                    return next;\n-                  }\n-                }\n-              }\n-            }\n-        }\n-\n-        pub fn get_next_char_in_leaf(it: &mut T) -> Option<char> {\n-            match copy it.leaf {\n-              None => return None,\n-              Some(aleaf) => {\n-                if it.leaf_byte_pos >= aleaf.byte_len {\n-                    //We are actually past the end of the leaf\n-                    it.leaf = None;\n-                    return None\n-                } else {\n-                    let range =\n-                        aleaf.content.char_range_at((*it).leaf_byte_pos + aleaf.byte_offset);\n-                    let ch = range.ch;\n-                    let next = range.next;\n-                    (*it).leaf_byte_pos = next - aleaf.byte_offset;\n-                    return Some(ch)\n-                }\n-              }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-\n-    use rope::*;\n-\n-    use std::uint;\n-    use std::vec;\n-\n-    //Utility function, used for sanity check\n-    fn rope_to_string(r: Rope) -> ~str {\n-        match (r) {\n-          node::Empty => return ~\"\",\n-          node::Content(x) => {\n-            let mut str = ~\"\";\n-            fn aux(str: &mut ~str, node: @node::Node) {\n-                match (*node) {\n-                    node::Leaf(x) => {\n-                        str.push_str(x.content.slice(x.byte_offset, x.byte_offset + x.byte_len));\n-                    }\n-                    node::Concat(ref x) => {\n-                        aux(str, x.left);\n-                        aux(str, x.right);\n-                    }\n-                }\n-            }\n-            aux(&mut str, x);\n-            return str\n-          }\n-        }\n-    }\n-\n-\n-    #[test]\n-    fn trivial() {\n-        assert_eq!(char_len(empty()), 0u);\n-        assert_eq!(byte_len(empty()), 0u);\n-    }\n-\n-    #[test]\n-    fn of_string1() {\n-        let sample = @~\"0123456789ABCDE\";\n-        let r      = of_str(sample);\n-\n-        assert_eq!(char_len(r), sample.char_len());\n-        assert!(rope_to_string(r) == *sample);\n-    }\n-\n-    #[test]\n-    fn of_string2() {\n-        let buf = @ mut ~\"1234567890\";\n-        let mut i = 0;\n-        while i < 10 {\n-            let a = copy *buf;\n-            let b = copy *buf;\n-            *buf = a + b;\n-            i+=1;\n-        }\n-        let sample = @copy *buf;\n-        let r      = of_str(sample);\n-        assert_eq!(char_len(r), sample.char_len());\n-        assert!(rope_to_string(r) == *sample);\n-\n-        let mut string_iter = 0u;\n-        let string_len = sample.len();\n-        let mut rope_iter = iterator::char::start(r);\n-        let mut equal = true;\n-        while equal {\n-            match (node::char_iterator::next(&mut rope_iter)) {\n-              None => {\n-                if string_iter < string_len {\n-                    equal = false;\n-                } break; }\n-              Some(c) => {\n-                let range = sample.char_range_at(string_iter);\n-                string_iter = range.next;\n-                if range.ch != c { equal = false; break; }\n-              }\n-            }\n-        }\n-\n-        assert!(equal);\n-    }\n-\n-    #[test]\n-    fn iter1() {\n-        let buf = @ mut ~\"1234567890\";\n-        let mut i = 0;\n-        while i < 10 {\n-            let a = copy *buf;\n-            let b = copy *buf;\n-            *buf = a + b;\n-            i+=1;\n-        }\n-        let sample = @copy *buf;\n-        let r      = of_str(sample);\n-\n-        let mut len = 0u;\n-        let mut it  = iterator::char::start(r);\n-        loop {\n-            match (node::char_iterator::next(&mut it)) {\n-              None => break,\n-              Some(_) => len += 1u\n-            }\n-        }\n-\n-        assert_eq!(len, sample.char_len());\n-    }\n-\n-    #[test]\n-    fn bal1() {\n-        let init = @~\"1234567890\";\n-        let buf  = @mut copy *init;\n-        let mut i = 0;\n-        while i < 8 {\n-            let a = copy *buf;\n-            let b = copy *buf;\n-            *buf = a + b;\n-            i+=1;\n-        }\n-        let sample = @copy *buf;\n-        let r1     = of_str(sample);\n-        let mut r2 = of_str(init);\n-        i = 0;\n-        while i < 8 { r2 = append_rope(r2, r2); i+= 1;}\n-\n-\n-        assert!(eq(r1, r2));\n-        let r3 = bal(r2);\n-        assert_eq!(char_len(r1), char_len(r3));\n-\n-        assert!(eq(r1, r3));\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    fn char_at1() {\n-        //Generate a large rope\n-        let mut r = of_str(@~\"123456789\");\n-        for uint::range(0u, 10u) |_i| {\n-            r = append_rope(r, r);\n-        }\n-\n-        //Copy it in the slowest possible way\n-        let mut r2 = empty();\n-        for uint::range(0u, char_len(r)) |i| {\n-            r2 = append_char(r2, char_at(r, i));\n-        }\n-        assert!(eq(r, r2));\n-\n-        let mut r3 = empty();\n-        for uint::range(0u, char_len(r)) |i| {\n-            r3 = prepend_char(r3, char_at(r, char_len(r) - i - 1u));\n-        }\n-        assert!(eq(r, r3));\n-\n-        //Additional sanity checks\n-        let balr = bal(r);\n-        let bal2 = bal(r2);\n-        let bal3 = bal(r3);\n-        assert!(eq(r, balr));\n-        assert!(eq(r, bal2));\n-        assert!(eq(r, bal3));\n-        assert!(eq(r2, r3));\n-        assert!(eq(bal2, bal3));\n-    }\n-\n-    #[test]\n-    fn concat1() {\n-        //Generate a reasonable rope\n-        let chunk = of_str(@~\"123456789\");\n-        let mut r = empty();\n-        for uint::range(0u, 10u) |_i| {\n-            r = append_rope(r, chunk);\n-        }\n-\n-        //Same rope, obtained with rope::concat\n-        let r2 = concat(vec::from_elem(10u, chunk));\n-\n-        assert!(eq(r, r2));\n-    }\n-}"}, {"sha": "748d5f05aae0f9120f8d9a306153208cf15fc067", "filename": "src/libstd/str.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01833de7ea4c3d73351277b52f841d42d7d2dbb8/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01833de7ea4c3d73351277b52f841d42d7d2dbb8/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=01833de7ea4c3d73351277b52f841d42d7d2dbb8", "patch": "@@ -13,8 +13,7 @@\n  *\n  * Strings are a packed UTF-8 representation of text, stored as null\n  * terminated buffers of u8 bytes.  Strings should be indexed in bytes,\n- * for efficiency, but UTF-8 unsafe operations should be avoided.  For\n- * some heavy-duty uses, try extra::rope.\n+ * for efficiency, but UTF-8 unsafe operations should be avoided.\n  */\n \n use at_vec;"}]}