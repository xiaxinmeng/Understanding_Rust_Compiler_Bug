{"sha": "408368a82c2c394b65524cb995e01ecfc3c1867c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwODM2OGE4MmMyYzM5NGI2NTUyNGNiOTk1ZTAxZWNmYzNjMTg2N2M=", "commit": {"author": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-02-08T19:47:35Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T09:13:32Z"}, "message": "Refactor check_for_loop_arg; rename manual_flatten's lint back to check_manual_flatten", "tree": {"sha": "8736219302542607c3c1832f309ccb22585948a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8736219302542607c3c1832f309ccb22585948a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/408368a82c2c394b65524cb995e01ecfc3c1867c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/408368a82c2c394b65524cb995e01ecfc3c1867c", "html_url": "https://github.com/rust-lang/rust/commit/408368a82c2c394b65524cb995e01ecfc3c1867c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/408368a82c2c394b65524cb995e01ecfc3c1867c/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0", "html_url": "https://github.com/rust-lang/rust/commit/62ac4bd1b2b94cb97f61d7f42fdd4fcd8794d2b0"}], "stats": {"total": 298, "additions": 154, "deletions": 144}, "files": [{"sha": "b33e7183984dabef2e861a96435d0425d6219e46", "filename": "clippy_lints/src/loops/for_loop_arg.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/408368a82c2c394b65524cb995e01ecfc3c1867c/clippy_lints%2Fsrc%2Floops%2Ffor_loop_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/408368a82c2c394b65524cb995e01ecfc3c1867c/clippy_lints%2Fsrc%2Floops%2Ffor_loop_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Ffor_loop_arg.rs?ref=408368a82c2c394b65524cb995e01ecfc3c1867c", "patch": "@@ -0,0 +1,149 @@\n+use crate::utils::{\n+    is_type_diagnostic_item, match_trait_method, match_type, paths, snippet, snippet_with_applicability, span_lint,\n+    span_lint_and_help, span_lint_and_sugg,\n+};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, Mutability, Pat};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_span::symbol::sym;\n+\n+pub(super) fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr: &Expr<'_>) {\n+    let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n+    if let ExprKind::MethodCall(ref method, _, ref args, _) = arg.kind {\n+        // just the receiver, no arguments\n+        if args.len() == 1 {\n+            let method_name = &*method.ident.as_str();\n+            // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n+            if method_name == \"iter\" || method_name == \"iter_mut\" {\n+                if is_ref_iterable_type(cx, &args[0]) {\n+                    lint_iter_method(cx, args, arg, method_name);\n+                }\n+            } else if method_name == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n+                let receiver_ty = cx.typeck_results().expr_ty(&args[0]);\n+                let receiver_ty_adjusted = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+                if TyS::same_type(receiver_ty, receiver_ty_adjusted) {\n+                    let mut applicability = Applicability::MachineApplicable;\n+                    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n+                    span_lint_and_sugg(\n+                        cx,\n+                        super::EXPLICIT_INTO_ITER_LOOP,\n+                        arg.span,\n+                        \"it is more concise to loop over containers instead of using explicit \\\n+                         iteration methods\",\n+                        \"to write this more concisely, try\",\n+                        object.to_string(),\n+                        applicability,\n+                    );\n+                } else {\n+                    let ref_receiver_ty = cx.tcx.mk_ref(\n+                        cx.tcx.lifetimes.re_erased,\n+                        ty::TypeAndMut {\n+                            ty: receiver_ty,\n+                            mutbl: Mutability::Not,\n+                        },\n+                    );\n+                    if TyS::same_type(receiver_ty_adjusted, ref_receiver_ty) {\n+                        lint_iter_method(cx, args, arg, method_name)\n+                    }\n+                }\n+            } else if method_name == \"next\" && match_trait_method(cx, arg, &paths::ITERATOR) {\n+                span_lint(\n+                    cx,\n+                    super::ITER_NEXT_LOOP,\n+                    expr.span,\n+                    \"you are iterating over `Iterator::next()` which is an Option; this will compile but is \\\n+                    probably not what you want\",\n+                );\n+                next_loop_linted = true;\n+            }\n+        }\n+    }\n+    if !next_loop_linted {\n+        check_arg_type(cx, pat, arg);\n+    }\n+}\n+\n+/// Checks for `for` loops over `Option`s and `Result`s.\n+fn check_arg_type(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n+    let ty = cx.typeck_results().expr_ty(arg);\n+    if is_type_diagnostic_item(cx, ty, sym::option_type) {\n+        span_lint_and_help(\n+            cx,\n+            super::FOR_LOOPS_OVER_FALLIBLES,\n+            arg.span,\n+            &format!(\n+                \"for loop over `{0}`, which is an `Option`. This is more readably written as an \\\n+                `if let` statement\",\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+            None,\n+            &format!(\n+                \"consider replacing `for {0} in {1}` with `if let Some({0}) = {1}`\",\n+                snippet(cx, pat.span, \"_\"),\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+        );\n+    } else if is_type_diagnostic_item(cx, ty, sym::result_type) {\n+        span_lint_and_help(\n+            cx,\n+            super::FOR_LOOPS_OVER_FALLIBLES,\n+            arg.span,\n+            &format!(\n+                \"for loop over `{0}`, which is a `Result`. This is more readably written as an \\\n+                `if let` statement\",\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+            None,\n+            &format!(\n+                \"consider replacing `for {0} in {1}` with `if let Ok({0}) = {1}`\",\n+                snippet(cx, pat.span, \"_\"),\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+        );\n+    }\n+}\n+\n+fn lint_iter_method(cx: &LateContext<'_>, args: &[Expr<'_>], arg: &Expr<'_>, method_name: &str) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n+    let muta = if method_name == \"iter_mut\" { \"mut \" } else { \"\" };\n+    span_lint_and_sugg(\n+        cx,\n+        super::EXPLICIT_ITER_LOOP,\n+        arg.span,\n+        \"it is more concise to loop over references to containers instead of using explicit \\\n+         iteration methods\",\n+        \"to write this more concisely, try\",\n+        format!(\"&{}{}\", muta, object),\n+        applicability,\n+    )\n+}\n+\n+/// Returns `true` if the type of expr is one that provides `IntoIterator` impls\n+/// for `&T` and `&mut T`, such as `Vec`.\n+#[rustfmt::skip]\n+fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n+    // will allow further borrows afterwards\n+    let ty = cx.typeck_results().expr_ty(e);\n+    is_iterable_array(ty, cx) ||\n+    is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n+    match_type(cx, ty, &paths::LINKED_LIST) ||\n+    is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) ||\n+    is_type_diagnostic_item(cx, ty, sym!(hashset_type)) ||\n+    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+    match_type(cx, ty, &paths::BINARY_HEAP) ||\n+    match_type(cx, ty, &paths::BTREEMAP) ||\n+    match_type(cx, ty, &paths::BTREESET)\n+}\n+\n+fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n+    // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n+    match ty.kind() {\n+        ty::Array(_, n) => n\n+            .try_eval_usize(cx.tcx, cx.param_env)\n+            .map_or(false, |val| (0..=32).contains(&val)),\n+        _ => false,\n+    }\n+}"}, {"sha": "db90d2c0468fcf6ed69c843a530cea984b550896", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/408368a82c2c394b65524cb995e01ecfc3c1867c/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/408368a82c2c394b65524cb995e01ecfc3c1867c/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=408368a82c2c394b65524cb995e01ecfc3c1867c", "patch": "@@ -8,7 +8,7 @@ use rustc_span::source_map::Span;\n \n /// Check for unnecessary `if let` usage in a for loop where only the `Some` or `Ok` variant of the\n /// iterator element is used.\n-pub(super) fn lint<'tcx>(\n+pub(super) fn check_manual_flatten<'tcx>(\n     cx: &LateContext<'tcx>,\n     pat: &'tcx Pat<'_>,\n     arg: &'tcx Expr<'_>,"}, {"sha": "63eeb3607b699c7d72f3174ecb4497aaa6f1e7d3", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 4, "deletions": 143, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/408368a82c2c394b65524cb995e01ecfc3c1867c/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/408368a82c2c394b65524cb995e01ecfc3c1867c/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=408368a82c2c394b65524cb995e01ecfc3c1867c", "patch": "@@ -1,3 +1,4 @@\n+mod for_loop_arg;\n mod manual_flatten;\n mod utils;\n \n@@ -27,7 +28,7 @@ use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::middle::region;\n-use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -861,12 +862,12 @@ fn check_for_loop<'tcx>(\n         check_for_loop_range(cx, pat, arg, body, expr);\n         check_for_loop_explicit_counter(cx, pat, arg, body, expr);\n     }\n-    check_for_loop_arg(cx, pat, arg, expr);\n+    for_loop_arg::check_for_loop_arg(cx, pat, arg, expr);\n     check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n     check_for_mut_range_bound(cx, arg, body);\n     check_for_single_element_loop(cx, pat, arg, body, expr);\n     detect_same_item_push(cx, pat, arg, body, expr);\n-    manual_flatten::lint(cx, pat, arg, body, span);\n+    manual_flatten::check_manual_flatten(cx, pat, arg, body, span);\n }\n \n // this function assumes the given expression is a `for` loop.\n@@ -1682,118 +1683,6 @@ fn is_end_eq_array_len<'tcx>(\n     false\n }\n \n-fn lint_iter_method(cx: &LateContext<'_>, args: &[Expr<'_>], arg: &Expr<'_>, method_name: &str) {\n-    let mut applicability = Applicability::MachineApplicable;\n-    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n-    let muta = if method_name == \"iter_mut\" { \"mut \" } else { \"\" };\n-    span_lint_and_sugg(\n-        cx,\n-        EXPLICIT_ITER_LOOP,\n-        arg.span,\n-        \"it is more concise to loop over references to containers instead of using explicit \\\n-         iteration methods\",\n-        \"to write this more concisely, try\",\n-        format!(\"&{}{}\", muta, object),\n-        applicability,\n-    )\n-}\n-\n-fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr: &Expr<'_>) {\n-    let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n-    if let ExprKind::MethodCall(ref method, _, ref args, _) = arg.kind {\n-        // just the receiver, no arguments\n-        if args.len() == 1 {\n-            let method_name = &*method.ident.as_str();\n-            // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n-            if method_name == \"iter\" || method_name == \"iter_mut\" {\n-                if is_ref_iterable_type(cx, &args[0]) {\n-                    lint_iter_method(cx, args, arg, method_name);\n-                }\n-            } else if method_name == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n-                let receiver_ty = cx.typeck_results().expr_ty(&args[0]);\n-                let receiver_ty_adjusted = cx.typeck_results().expr_ty_adjusted(&args[0]);\n-                if TyS::same_type(receiver_ty, receiver_ty_adjusted) {\n-                    let mut applicability = Applicability::MachineApplicable;\n-                    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n-                    span_lint_and_sugg(\n-                        cx,\n-                        EXPLICIT_INTO_ITER_LOOP,\n-                        arg.span,\n-                        \"it is more concise to loop over containers instead of using explicit \\\n-                         iteration methods\",\n-                        \"to write this more concisely, try\",\n-                        object.to_string(),\n-                        applicability,\n-                    );\n-                } else {\n-                    let ref_receiver_ty = cx.tcx.mk_ref(\n-                        cx.tcx.lifetimes.re_erased,\n-                        ty::TypeAndMut {\n-                            ty: receiver_ty,\n-                            mutbl: Mutability::Not,\n-                        },\n-                    );\n-                    if TyS::same_type(receiver_ty_adjusted, ref_receiver_ty) {\n-                        lint_iter_method(cx, args, arg, method_name)\n-                    }\n-                }\n-            } else if method_name == \"next\" && match_trait_method(cx, arg, &paths::ITERATOR) {\n-                span_lint(\n-                    cx,\n-                    ITER_NEXT_LOOP,\n-                    expr.span,\n-                    \"you are iterating over `Iterator::next()` which is an Option; this will compile but is \\\n-                    probably not what you want\",\n-                );\n-                next_loop_linted = true;\n-            }\n-        }\n-    }\n-    if !next_loop_linted {\n-        check_arg_type(cx, pat, arg);\n-    }\n-}\n-\n-/// Checks for `for` loops over `Option`s and `Result`s.\n-fn check_arg_type(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n-    let ty = cx.typeck_results().expr_ty(arg);\n-    if is_type_diagnostic_item(cx, ty, sym::option_type) {\n-        span_lint_and_help(\n-            cx,\n-            FOR_LOOPS_OVER_FALLIBLES,\n-            arg.span,\n-            &format!(\n-                \"for loop over `{0}`, which is an `Option`. This is more readably written as an \\\n-                `if let` statement\",\n-                snippet(cx, arg.span, \"_\")\n-            ),\n-            None,\n-            &format!(\n-                \"consider replacing `for {0} in {1}` with `if let Some({0}) = {1}`\",\n-                snippet(cx, pat.span, \"_\"),\n-                snippet(cx, arg.span, \"_\")\n-            ),\n-        );\n-    } else if is_type_diagnostic_item(cx, ty, sym::result_type) {\n-        span_lint_and_help(\n-            cx,\n-            FOR_LOOPS_OVER_FALLIBLES,\n-            arg.span,\n-            &format!(\n-                \"for loop over `{0}`, which is a `Result`. This is more readably written as an \\\n-                `if let` statement\",\n-                snippet(cx, arg.span, \"_\")\n-            ),\n-            None,\n-            &format!(\n-                \"consider replacing `for {0} in {1}` with `if let Ok({0}) = {1}`\",\n-                snippet(cx, pat.span, \"_\"),\n-                snippet(cx, arg.span, \"_\")\n-            ),\n-        );\n-    }\n-}\n-\n // To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n // incremented exactly once in the loop body, and initialized to zero\n // at the start of the loop.\n@@ -2270,34 +2159,6 @@ impl<'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor {\n     }\n }\n \n-/// Returns `true` if the type of expr is one that provides `IntoIterator` impls\n-/// for `&T` and `&mut T`, such as `Vec`.\n-#[rustfmt::skip]\n-fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n-    // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n-    // will allow further borrows afterwards\n-    let ty = cx.typeck_results().expr_ty(e);\n-    is_iterable_array(ty, cx) ||\n-    is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n-    match_type(cx, ty, &paths::LINKED_LIST) ||\n-    is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) ||\n-    is_type_diagnostic_item(cx, ty, sym!(hashset_type)) ||\n-    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n-    match_type(cx, ty, &paths::BINARY_HEAP) ||\n-    match_type(cx, ty, &paths::BTREEMAP) ||\n-    match_type(cx, ty, &paths::BTREESET)\n-}\n-\n-fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n-    // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n-    match ty.kind() {\n-        ty::Array(_, n) => n\n-            .try_eval_usize(cx.tcx, cx.param_env)\n-            .map_or(false, |val| (0..=32).contains(&val)),\n-        _ => false,\n-    }\n-}\n-\n /// If a block begins with a statement (possibly a `let` binding) and has an\n /// expression, return it.\n fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {"}]}