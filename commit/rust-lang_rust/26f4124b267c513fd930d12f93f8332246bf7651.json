{"sha": "26f4124b267c513fd930d12f93f8332246bf7651", "node_id": "C_kwDOAAsO6NoAKDI2ZjQxMjRiMjY3YzUxM2ZkOTMwZDEyZjkzZjgzMzIyNDZiZjc2NTE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-09T12:30:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-09T12:30:27Z"}, "message": "Merge #10494\n\n10494: Macro expansion tests r=matklad a=matklad\n\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "b4c215db60eb278462f65d623f62cf7271ee3fcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4c215db60eb278462f65d623f62cf7271ee3fcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26f4124b267c513fd930d12f93f8332246bf7651", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhYYtkCRBK7hj4Ov3rIwAAxBwIABsJO5BIM9InSX/Kcca+lA6u\n03LbLokHal82vJiXveEScu9B6iT1a2uu17xm++/GH3Gi/C4Vf9oAPRP/kt/PrBiz\n/kRkfdPa5fJWKitF03S1nuek4dnp3Ks24lRrZPKXhxUvjnob75jd/3vHu+DWVhkL\nmUyJojVds9Y7b8XYCIjNJIcITj3G/MSEQ77fCd+8rNTpzUnZGlTd4kXOBhAOcIrR\nrCX/Z0GjwRb6T+s41LqYdGy3io7yrFOm7tCAMknNRlQYiUPxgXKzMK2nvSDU43kq\nN1bBppSJcsba5j8+silt7Gm07LGi5HBWlCgO+WFELFD10VENxQT3bb0mGhJABJk=\n=h+lV\n-----END PGP SIGNATURE-----\n", "payload": "tree b4c215db60eb278462f65d623f62cf7271ee3fcc\nparent 545b068a7720374a13e04db24e0bef6237822f2a\nparent 84d182c7a2002cd6e511db341ddddcd8ba473105\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1633782627 +0000\ncommitter GitHub <noreply@github.com> 1633782627 +0000\n\nMerge #10494\n\n10494: Macro expansion tests r=matklad a=matklad\n\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26f4124b267c513fd930d12f93f8332246bf7651", "html_url": "https://github.com/rust-lang/rust/commit/26f4124b267c513fd930d12f93f8332246bf7651", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26f4124b267c513fd930d12f93f8332246bf7651/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "545b068a7720374a13e04db24e0bef6237822f2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/545b068a7720374a13e04db24e0bef6237822f2a", "html_url": "https://github.com/rust-lang/rust/commit/545b068a7720374a13e04db24e0bef6237822f2a"}, {"sha": "84d182c7a2002cd6e511db341ddddcd8ba473105", "url": "https://api.github.com/repos/rust-lang/rust/commits/84d182c7a2002cd6e511db341ddddcd8ba473105", "html_url": "https://github.com/rust-lang/rust/commit/84d182c7a2002cd6e511db341ddddcd8ba473105"}], "stats": {"total": 691, "additions": 401, "deletions": 290}, "files": [{"sha": "7d5f63afd047260bd6677bff9a09d5af5773b57a", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=26f4124b267c513fd930d12f93f8332246bf7651", "patch": "@@ -49,6 +49,8 @@ pub mod import_map;\n \n #[cfg(test)]\n mod test_db;\n+#[cfg(test)]\n+mod macro_expansion_tests;\n \n use std::{\n     hash::{Hash, Hasher},"}, {"sha": "76bd0299fb4b239f8e5bb4d82b844d39ab4c6f1c", "filename": "crates/hir_def/src/macro_expansion_tests.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs?ref=26f4124b267c513fd930d12f93f8332246bf7651", "patch": "@@ -0,0 +1,117 @@\n+//! This module contains tests for macro expansion. Effectively, it covers `tt`,\n+//! `mbe`, `proc_macro_api` and `hir_expand` crates. This might seem like a\n+//! wrong architecture at the first glance, but is intentional.\n+//!\n+//! Physically, macro expansion process is intertwined with name resolution. You\n+//! can not expand *just* the syntax. So, to be able to write integration tests\n+//! of the \"expand this code please\" form, we have to do it after name\n+//! resolution. That is, in this crate. We *could* fake some dependencies and\n+//! write unit-tests (in fact, we used to do that), but that makes tests brittle\n+//! and harder to understand.\n+\n+mod mbe;\n+\n+use std::{iter, ops::Range};\n+\n+use base_db::{fixture::WithFixture, SourceDatabase};\n+use expect_test::Expect;\n+use hir_expand::{db::AstDatabase, InFile, MacroFile};\n+use stdx::format_to;\n+use syntax::{\n+    ast::{self, edit::IndentLevel},\n+    AstNode,\n+    SyntaxKind::{self, IDENT},\n+    SyntaxNode, T,\n+};\n+\n+use crate::{\n+    db::DefDatabase, nameres::ModuleSource, resolver::HasResolver, test_db::TestDB, AsMacroCall,\n+};\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let db = TestDB::with_files(ra_fixture);\n+    let krate = db.crate_graph().iter().next().unwrap();\n+    let def_map = db.crate_def_map(krate);\n+    let local_id = def_map.root();\n+    let module = def_map.module_id(local_id);\n+    let resolver = module.resolver(&db);\n+    let source = def_map[local_id].definition_source(&db);\n+    let source_file = match source.value {\n+        ModuleSource::SourceFile(it) => it,\n+        ModuleSource::Module(_) | ModuleSource::BlockExpr(_) => panic!(),\n+    };\n+\n+    let mut expansions = Vec::new();\n+    for macro_call in source_file.syntax().descendants().filter_map(ast::MacroCall::cast) {\n+        let macro_call = InFile::new(source.file_id, &macro_call);\n+        let macro_call_id = macro_call\n+            .as_call_id_with_errors(\n+                &db,\n+                krate,\n+                |path| resolver.resolve_path_as_macro(&db, &path),\n+                &mut |err| panic!(\"{}\", err),\n+            )\n+            .unwrap()\n+            .unwrap();\n+        let macro_file = MacroFile { macro_call_id };\n+        let expansion_result = db.parse_macro_expansion(macro_file);\n+        expansions.push((macro_call.value.clone(), expansion_result));\n+    }\n+\n+    let mut expanded_text = source_file.to_string();\n+    for (call, exp) in expansions.into_iter().rev() {\n+        let mut expn_text = String::new();\n+        if let Some(err) = exp.err {\n+            format_to!(expn_text, \"/* error: {} */\", err);\n+        }\n+        if let Some((parse, _token_map)) = exp.value {\n+            let pp = pretty_print_macro_expansion(parse.syntax_node());\n+            let indent = IndentLevel::from_node(call.syntax());\n+            let pp = reindent(indent, pp);\n+            format_to!(expn_text, \"{}\", pp);\n+        }\n+        let range = call.syntax().text_range();\n+        let range: Range<usize> = range.into();\n+        expanded_text.replace_range(range, &expn_text)\n+    }\n+\n+    expect.assert_eq(&expanded_text);\n+}\n+\n+fn reindent(indent: IndentLevel, pp: String) -> String {\n+    if !pp.contains('\\n') {\n+        return pp;\n+    }\n+    let mut lines = pp.split_inclusive('\\n');\n+    let mut res = lines.next().unwrap().to_string();\n+    for line in lines {\n+        if line.trim().is_empty() {\n+            res.push_str(&line)\n+        } else {\n+            format_to!(res, \"{}{}\", indent, line)\n+        }\n+    }\n+    res\n+}\n+\n+fn pretty_print_macro_expansion(expn: SyntaxNode) -> String {\n+    let mut res = String::new();\n+    let mut prev_kind = SyntaxKind::EOF;\n+    for token in iter::successors(expn.first_token(), |t| t.next_token()) {\n+        let curr_kind = token.kind();\n+        let space = match (prev_kind, curr_kind) {\n+            _ if prev_kind.is_trivia() || curr_kind.is_trivia() => \"\",\n+            (T![=], _) | (_, T![=]) => \" \",\n+            (T![;], _) => \"\\n\",\n+            (IDENT, IDENT) => \" \",\n+            (IDENT, _) if curr_kind.is_keyword() => \" \",\n+            (_, IDENT) if prev_kind.is_keyword() => \" \",\n+            _ => \"\",\n+        };\n+\n+        res.push_str(space);\n+        prev_kind = curr_kind;\n+        format_to!(res, \"{}\", token)\n+    }\n+    res\n+}"}, {"sha": "cc6551f8aa6e45c0bac4f67d7a5824fc12c0e86d", "filename": "crates/hir_def/src/macro_expansion_tests/mbe.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=26f4124b267c513fd930d12f93f8332246bf7651", "patch": "@@ -0,0 +1,48 @@\n+//! Tests specific to declarative macros, aka macros by example. This covers\n+//! both stable `macro_rules!` macros as well as unstable `macro` macros.\n+\n+mod tt_conversion;\n+mod matching;\n+mod meta_syntax;\n+\n+use expect_test::expect;\n+\n+use crate::macro_expansion_tests::check;\n+\n+#[test]\n+fn expansion_does_not_parse_as_expression() {\n+    check(\n+        r#\"\n+macro_rules! stmts {\n+    () => { let _ = 0; }\n+}\n+\n+fn f() { let _ = stmts!(); }\n+\"#,\n+        expect![[r#\"\n+macro_rules! stmts {\n+    () => { let _ = 0; }\n+}\n+\n+fn f() { let _ = /* error: could not convert tokens */; }\n+\"#]],\n+    )\n+}\n+\n+#[test]\n+fn wrong_nesting_level() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($($i:ident);*) => ($i)\n+}\n+m!{a}\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($($i:ident);*) => ($i)\n+}\n+/* error: expected simple binding, found nested binding `i` */\n+\"#]],\n+    );\n+}"}, {"sha": "11317cfa9d5b40014185283bee17fa170f4783cc", "filename": "crates/hir_def/src/macro_expansion_tests/mbe/matching.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs?ref=26f4124b267c513fd930d12f93f8332246bf7651", "patch": "@@ -0,0 +1,25 @@\n+//! Test that `$var:expr` captures function correctly.\n+\n+use expect_test::expect;\n+\n+use crate::macro_expansion_tests::check;\n+\n+#[test]\n+fn unary_minus_is_a_literal() {\n+    check(\n+        r#\"\n+macro_rules! m { ($x:literal) => (literal!()); ($x:tt) => (not_a_literal!()); }\n+m!(92);\n+m!(-92);\n+m!(-9.2);\n+m!(--92);\n+\"#,\n+        expect![[r#\"\n+macro_rules! m { ($x:literal) => (literal!()); ($x:tt) => (not_a_literal!()); }\n+literal!()\n+literal!()\n+literal!()\n+/* error: leftover tokens */not_a_literal!()\n+\"#]],\n+    )\n+}"}, {"sha": "4249c2507e9a1e7461833fa325c38101a7591276", "filename": "crates/hir_def/src/macro_expansion_tests/mbe/meta_syntax.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmeta_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmeta_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmeta_syntax.rs?ref=26f4124b267c513fd930d12f93f8332246bf7651", "patch": "@@ -0,0 +1,79 @@\n+//! Test for the syntax of macros themselves.\n+\n+use expect_test::expect;\n+\n+use crate::macro_expansion_tests::check;\n+\n+#[test]\n+fn well_formed_macro_rules() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    ($i:ident) => ();\n+    ($(x),*) => ();\n+    ($(x)_*) => ();\n+    ($(x)i*) => ();\n+    ($($i:ident)*) => ($_);\n+    ($($true:ident)*) => ($true);\n+    ($($false:ident)*) => ($false);\n+    ($) => ($);\n+}\n+m!($);\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    ($i:ident) => ();\n+    ($(x),*) => ();\n+    ($(x)_*) => ();\n+    ($(x)i*) => ();\n+    ($($i:ident)*) => ($_);\n+    ($($true:ident)*) => ($true);\n+    ($($false:ident)*) => ($false);\n+    ($) => ($);\n+}\n+$\n+\"#]],\n+    )\n+}\n+\n+#[test]\n+fn malformed_macro_rules() {\n+    check(\n+        r#\"\n+macro_rules! i1 { invalid }\n+i1!();\n+\n+macro_rules! e1 { $i:ident => () }\n+e1!();\n+macro_rules! e2 { ($i:ident) () }\n+e2!();\n+macro_rules! e3 { ($(i:ident)_) => () }\n+e3!();\n+\n+macro_rules! f1 { ($i) => ($i) }\n+f1!();\n+macro_rules! f2 { ($i:) => ($i) }\n+f2!();\n+macro_rules! f3 { ($i:_) => () }\n+f3!();\n+\"#,\n+        expect![[r#\"\n+macro_rules! i1 { invalid }\n+/* error: invalid macro definition: expected subtree */\n+\n+macro_rules! e1 { $i:ident => () }\n+/* error: invalid macro definition: expected subtree */\n+macro_rules! e2 { ($i:ident) () }\n+/* error: invalid macro definition: expected `=` */\n+macro_rules! e3 { ($(i:ident)_) => () }\n+/* error: invalid macro definition: invalid repeat */\n+\n+macro_rules! f1 { ($i) => ($i) }\n+/* error: invalid macro definition: bad fragment specifier 1 */\n+macro_rules! f2 { ($i:) => ($i) }\n+/* error: invalid macro definition: bad fragment specifier 1 */\n+macro_rules! f3 { ($i:_) => () }\n+/* error: invalid macro definition: bad fragment specifier 1 */\n+\"#]],\n+    )\n+}"}, {"sha": "a24fe9bee2c74ce40ba7ee8fa955874e97392b66", "filename": "crates/hir_def/src/macro_expansion_tests/mbe/tt_conversion.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs?ref=26f4124b267c513fd930d12f93f8332246bf7651", "patch": "@@ -0,0 +1,84 @@\n+//! Unlike rustc, rust-analyzer's syntax tree are not \"made of\" token trees.\n+//! Rather, token trees are an explicit bridge between the parser and\n+//! (procedural or declarative) macros.\n+//!\n+//! This module tests tt <-> syntax tree conversion specifically\n+use expect_test::expect;\n+\n+use crate::macro_expansion_tests::check;\n+\n+#[test]\n+fn round_trips_compound_tokens() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    () => { type qual: ::T = qual::T; }\n+}\n+m!();\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    () => { type qual: ::T = qual::T; }\n+}\n+type qual: ::T = qual::T;\n+\"#]],\n+    )\n+}\n+\n+#[test]\n+fn round_trips_literals() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    () => {\n+        let _ = 'c';\n+        let _ = 1000;\n+        let _ = 12E+99_f64;\n+        let _ = \"rust1\";\n+        let _ = -92;\n+    }\n+}\n+fn f() {\n+    m!()\n+}\n+\"#,\n+        expect![[r#\"\n+macro_rules! m {\n+    () => {\n+        let _ = 'c';\n+        let _ = 1000;\n+        let _ = 12E+99_f64;\n+        let _ = \"rust1\";\n+        let _ = -92;\n+    }\n+}\n+fn f() {\n+    let_ = 'c';\n+    let_ = 1000;\n+    let_ = 12E+99_f64;\n+    let_ = \"rust1\";\n+    let_ = -92;\n+}\n+\"#]],\n+    );\n+}\n+\n+#[test]\n+fn broken_parenthesis_sequence() {\n+    check(\n+        r#\"\n+macro_rules! m1 { ($x:ident) => { ($x } }\n+macro_rules! m2 { ($x:ident) => {} }\n+\n+m1!();\n+m2!(x\n+\"#,\n+        expect![[r#\"\n+macro_rules! m1 { ($x:ident) => { ($x } }\n+macro_rules! m2 { ($x:ident) => {} }\n+\n+/* error: invalid macro definition: expected subtree */\n+/* error: Failed to lower macro args to token tree */\n+\"#]],\n+    )\n+}"}, {"sha": "08ad9ffd948d210de639de4d48f5570f120e66df", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=26f4124b267c513fd930d12f93f8332246bf7651", "patch": "@@ -8,7 +8,7 @@ use mbe::{syntax_node_to_token_tree, ExpandError, ExpandResult};\n use rustc_hash::FxHashSet;\n use syntax::{\n     algo::diff,\n-    ast::{self, HasAttrs, HasName},\n+    ast::{self, HasAttrs},\n     AstNode, GreenNode, Parse, SyntaxNode, SyntaxToken, T,\n };\n \n@@ -119,7 +119,7 @@ pub trait AstDatabase: SourceDatabase {\n     fn macro_arg_text(&self, id: MacroCallId) -> Option<GreenNode>;\n     /// Gets the expander for this macro. This compiles declarative macros, and\n     /// just fetches procedural ones.\n-    fn macro_def(&self, id: MacroDefId) -> Option<Arc<TokenExpander>>;\n+    fn macro_def(&self, id: MacroDefId) -> Result<Arc<TokenExpander>, mbe::ParseError>;\n \n     /// Expand macro call to a token tree. This query is LRUed (we keep 128 or so results in memory)\n     fn macro_expand(&self, macro_call: MacroCallId) -> ExpandResult<Option<Arc<tt::Subtree>>>;\n@@ -145,7 +145,7 @@ pub fn expand_speculative(\n     token_to_map: SyntaxToken,\n ) -> Option<(SyntaxNode, SyntaxToken)> {\n     let loc = db.lookup_intern_macro(actual_macro_call);\n-    let macro_def = db.macro_def(loc.def)?;\n+    let macro_def = db.macro_def(loc.def).ok()?;\n     let token_range = token_to_map.text_range();\n \n     // Build the subtree and token mapping for the speculative args\n@@ -360,45 +360,39 @@ fn macro_arg_text(db: &dyn AstDatabase, id: MacroCallId) -> Option<GreenNode> {\n     Some(arg.green().into())\n }\n \n-fn macro_def(db: &dyn AstDatabase, id: MacroDefId) -> Option<Arc<TokenExpander>> {\n+fn macro_def(db: &dyn AstDatabase, id: MacroDefId) -> Result<Arc<TokenExpander>, mbe::ParseError> {\n     match id.kind {\n         MacroDefKind::Declarative(ast_id) => match ast_id.to_node(db) {\n             ast::Macro::MacroRules(macro_rules) => {\n-                let arg = macro_rules.token_tree()?;\n+                let arg = macro_rules\n+                    .token_tree()\n+                    .ok_or_else(|| mbe::ParseError::Expected(\"expected a token tree\".into()))?;\n                 let (tt, def_site_token_map) = mbe::syntax_node_to_token_tree(arg.syntax());\n-                let mac = match mbe::MacroRules::parse(&tt) {\n-                    Ok(it) => it,\n-                    Err(err) => {\n-                        let name = macro_rules.name().map(|n| n.to_string()).unwrap_or_default();\n-                        tracing::warn!(\"fail on macro_def parse ({}): {:?} {:#?}\", name, err, tt);\n-                        return None;\n-                    }\n-                };\n-                Some(Arc::new(TokenExpander::MacroRules { mac, def_site_token_map }))\n+                let mac = mbe::MacroRules::parse(&tt)?;\n+                Ok(Arc::new(TokenExpander::MacroRules { mac, def_site_token_map }))\n             }\n             ast::Macro::MacroDef(macro_def) => {\n-                let arg = macro_def.body()?;\n+                let arg = macro_def\n+                    .body()\n+                    .ok_or_else(|| mbe::ParseError::Expected(\"expected a token tree\".into()))?;\n                 let (tt, def_site_token_map) = mbe::syntax_node_to_token_tree(arg.syntax());\n-                let mac = match mbe::MacroDef::parse(&tt) {\n-                    Ok(it) => it,\n-                    Err(err) => {\n-                        let name = macro_def.name().map(|n| n.to_string()).unwrap_or_default();\n-                        tracing::warn!(\"fail on macro_def parse ({}): {:?} {:#?}\", name, err, tt);\n-                        return None;\n-                    }\n-                };\n-                Some(Arc::new(TokenExpander::MacroDef { mac, def_site_token_map }))\n+                let mac = mbe::MacroDef::parse(&tt)?;\n+                Ok(Arc::new(TokenExpander::MacroDef { mac, def_site_token_map }))\n             }\n         },\n-        MacroDefKind::BuiltIn(expander, _) => Some(Arc::new(TokenExpander::Builtin(expander))),\n+        MacroDefKind::BuiltIn(expander, _) => Ok(Arc::new(TokenExpander::Builtin(expander))),\n         MacroDefKind::BuiltInAttr(expander, _) => {\n-            Some(Arc::new(TokenExpander::BuiltinAttr(expander)))\n+            Ok(Arc::new(TokenExpander::BuiltinAttr(expander)))\n         }\n         MacroDefKind::BuiltInDerive(expander, _) => {\n-            Some(Arc::new(TokenExpander::BuiltinDerive(expander)))\n+            Ok(Arc::new(TokenExpander::BuiltinDerive(expander)))\n         }\n-        MacroDefKind::BuiltInEager(..) => None,\n-        MacroDefKind::ProcMacro(expander, ..) => Some(Arc::new(TokenExpander::ProcMacro(expander))),\n+        MacroDefKind::BuiltInEager(..) => {\n+            // FIXME: Return a random error here just to make the types align.\n+            // This obviously should do something real instead.\n+            Err(mbe::ParseError::UnexpectedToken(\"unexpected eager macro\".to_string()))\n+        }\n+        MacroDefKind::ProcMacro(expander, ..) => Ok(Arc::new(TokenExpander::ProcMacro(expander))),\n     }\n }\n \n@@ -419,8 +413,11 @@ fn macro_expand(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<Option<Ar\n     };\n \n     let expander = match db.macro_def(loc.def) {\n-        Some(it) => it,\n-        None => return ExpandResult::str_err(\"Failed to find macro definition\".into()),\n+        Ok(it) => it,\n+        // FIXME: This is weird -- we effectively report macro *definition*\n+        // errors lazily, when we try to expand the macro. Instead, they should\n+        // be reported at the definition site (when we construct a def map).\n+        Err(err) => return ExpandResult::str_err(format!(\"invalid macro definition: {}\", err)),\n     };\n     let ExpandResult { value: tt, err } = expander.expand(db, id, &macro_arg.0);\n     // Set a hard limit for the expanded tt"}, {"sha": "b2879e37c35148a5949727a3cf6e2f0142667604", "filename": "crates/hir_expand/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs?ref=26f4124b267c513fd930d12f93f8332246bf7651", "patch": "@@ -195,7 +195,7 @@ fn make_hygiene_info(\n         _ => None,\n     });\n \n-    let macro_def = db.macro_def(loc.def)?;\n+    let macro_def = db.macro_def(loc.def).ok()?;\n     let (_, exp_map) = db.parse_macro_expansion(macro_file).value?;\n     let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n "}, {"sha": "ad6b84dd17e95fe9771fff055751ac55ce18a5f8", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=26f4124b267c513fd930d12f93f8332246bf7651", "patch": "@@ -143,7 +143,7 @@ impl HirFileId {\n                     _ => None,\n                 });\n \n-                let macro_def = db.macro_def(loc.def)?;\n+                let macro_def = db.macro_def(loc.def).ok()?;\n                 let (parse, exp_map) = db.parse_macro_expansion(macro_file).value?;\n                 let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n \n@@ -204,7 +204,7 @@ impl HirFileId {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct MacroFile {\n-    macro_call_id: MacroCallId,\n+    pub macro_call_id: MacroCallId,\n }\n \n /// `MacroCallId` identifies a particular macro invocation, like"}, {"sha": "7244d2116101c5dc8da6b60e339954f9f69aea21", "filename": "crates/mbe/src/expander.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fmbe%2Fsrc%2Fexpander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fmbe%2Fsrc%2Fexpander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander.rs?ref=26f4124b267c513fd930d12f93f8332246bf7651", "patch": "@@ -114,64 +114,3 @@ enum Fragment {\n     /// like `$i * 2` where `$i = 1 + 1` work as expectd.\n     Ast(tt::TokenTree),\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use syntax::{ast, AstNode};\n-\n-    use super::*;\n-    use crate::syntax_node_to_token_tree;\n-\n-    #[test]\n-    fn test_expand_rule() {\n-        assert_err(\n-            \"($($i:ident);*) => ($i)\",\n-            \"foo!{a}\",\n-            ExpandError::BindingError(String::from(\n-                \"expected simple binding, found nested binding `i`\",\n-            )),\n-        );\n-\n-        // FIXME:\n-        // Add an err test case for ($($i:ident)) => ($())\n-    }\n-\n-    fn assert_err(macro_body: &str, invocation: &str, err: ExpandError) {\n-        assert_eq!(\n-            expand_first(&create_rules(&format_macro(macro_body)), invocation).err,\n-            Some(err)\n-        );\n-    }\n-\n-    fn format_macro(macro_body: &str) -> String {\n-        format!(\n-            \"\n-        macro_rules! foo {{\n-            {}\n-        }}\n-\",\n-            macro_body\n-        )\n-    }\n-\n-    fn create_rules(macro_definition: &str) -> crate::MacroRules {\n-        let source_file = ast::SourceFile::parse(macro_definition).ok().unwrap();\n-        let macro_definition =\n-            source_file.syntax().descendants().find_map(ast::MacroRules::cast).unwrap();\n-\n-        let (definition_tt, _) =\n-            syntax_node_to_token_tree(macro_definition.token_tree().unwrap().syntax());\n-        crate::MacroRules::parse(&definition_tt).unwrap()\n-    }\n-\n-    fn expand_first(rules: &crate::MacroRules, invocation: &str) -> ExpandResult<tt::Subtree> {\n-        let source_file = ast::SourceFile::parse(invocation).ok().unwrap();\n-        let macro_invocation =\n-            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-\n-        let (invocation_tt, _) =\n-            syntax_node_to_token_tree(macro_invocation.token_tree().unwrap().syntax());\n-\n-        expand_rules(&rules.rules, &invocation_tt)\n-    }\n-}"}, {"sha": "61e032e0afa57bd187b87762c01c30d85bb68fdc", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=26f4124b267c513fd930d12f93f8332246bf7651", "patch": "@@ -2,6 +2,9 @@\n //! `macro_rules` macros. It uses `TokenTree` (from `tt` package) as the\n //! interface, although it contains some code to bridge `SyntaxNode`s and\n //! `TokenTree`s as well!\n+//!\n+//! The tes for this functionality live in another crate:\n+//! `hir_def::macro_expansion_tests::mbe`.\n \n mod parser;\n mod expander;\n@@ -27,14 +30,25 @@ use crate::{\n pub use ::parser::ParserEntryPoint;\n pub use tt::{Delimiter, DelimiterKind, Punct};\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq, Clone)]\n pub enum ParseError {\n     UnexpectedToken(String),\n     Expected(String),\n     InvalidRepeat,\n     RepetitionEmptyTokenTree,\n }\n \n+impl fmt::Display for ParseError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            ParseError::UnexpectedToken(it) => f.write_str(it),\n+            ParseError::Expected(it) => f.write_str(it),\n+            ParseError::InvalidRepeat => f.write_str(\"invalid repeat\"),\n+            ParseError::RepetitionEmptyTokenTree => f.write_str(\"empty token tree in repetition\"),\n+        }\n+    }\n+}\n+\n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum ExpandError {\n     NoMatchingRule,"}, {"sha": "247616aa1b6543c4bf376ce3c81fcb613904da73", "filename": "crates/mbe/src/subtree_source.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs?ref=26f4124b267c513fd930d12f93f8332246bf7651", "patch": "@@ -17,17 +17,6 @@ pub(crate) struct SubtreeTokenSource {\n     curr: (Token, usize),\n }\n \n-impl<'a> SubtreeTokenSource {\n-    // Helper function used in test\n-    #[cfg(test)]\n-    pub(crate) fn text(&self) -> SmolStr {\n-        match self.cached.get(self.curr.1) {\n-            Some(tt) => tt.text.clone(),\n-            _ => SmolStr::new(\"\"),\n-        }\n-    }\n-}\n-\n impl<'a> SubtreeTokenSource {\n     pub(crate) fn new(buffer: &TokenBuffer) -> SubtreeTokenSource {\n         let mut current = buffer.begin();\n@@ -181,24 +170,3 @@ fn convert_leaf(leaf: &tt::Leaf) -> TtToken {\n         tt::Leaf::Punct(punct) => convert_punct(*punct),\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::{convert_literal, TtToken};\n-    use parser::Token;\n-    use syntax::{SmolStr, SyntaxKind};\n-\n-    #[test]\n-    fn test_negative_literal() {\n-        assert_eq!(\n-            convert_literal(&tt::Literal {\n-                id: tt::TokenId::unspecified(),\n-                text: SmolStr::new(\"-42.0\")\n-            }),\n-            TtToken {\n-                tt: Token { kind: SyntaxKind::FLOAT_NUMBER, is_jointed_to_next: false },\n-                text: SmolStr::new(\"-42.0\")\n-            }\n-        );\n-    }\n-}"}, {"sha": "f3c9af1ccb4b693398a6b09fc5b07c68f6446624", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=26f4124b267c513fd930d12f93f8332246bf7651", "patch": "@@ -743,116 +743,3 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n         self.inner.error(error, self.text_pos)\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use crate::tests::parse_macro;\n-    use parser::TokenSource;\n-    use syntax::{\n-        ast::{make, AstNode},\n-        ted,\n-    };\n-    use test_utils::assert_eq_text;\n-\n-    #[test]\n-    fn convert_tt_token_source() {\n-        let expansion = parse_macro(\n-            r#\"\n-            macro_rules! literals {\n-                ($i:ident) => {\n-                    {\n-                        let a = 'c';\n-                        let c = 1000;\n-                        let f = 12E+99_f64;\n-                        let s = \"rust1\";\n-                    }\n-                }\n-            }\n-            \"#,\n-        )\n-        .expand_tt(\"literals!(foo);\");\n-        let tts = &[expansion.into()];\n-        let buffer = tt::buffer::TokenBuffer::from_tokens(tts);\n-        let mut tt_src = SubtreeTokenSource::new(&buffer);\n-        let mut tokens = vec![];\n-        while tt_src.current().kind != EOF {\n-            tokens.push((tt_src.current().kind, tt_src.text()));\n-            tt_src.bump();\n-        }\n-\n-        // [${]\n-        // [let] [a] [=] ['c'] [;]\n-        assert_eq!(tokens[2 + 3].1, \"'c'\");\n-        assert_eq!(tokens[2 + 3].0, CHAR);\n-        // [let] [c] [=] [1000] [;]\n-        assert_eq!(tokens[2 + 5 + 3].1, \"1000\");\n-        assert_eq!(tokens[2 + 5 + 3].0, INT_NUMBER);\n-        // [let] [f] [=] [12E+99_f64] [;]\n-        assert_eq!(tokens[2 + 10 + 3].1, \"12E+99_f64\");\n-        assert_eq!(tokens[2 + 10 + 3].0, FLOAT_NUMBER);\n-\n-        // [let] [s] [=] [\"rust1\"] [;]\n-        assert_eq!(tokens[2 + 15 + 3].1, \"\\\"rust1\\\"\");\n-        assert_eq!(tokens[2 + 15 + 3].0, STRING);\n-    }\n-\n-    #[test]\n-    fn stmts_token_trees_to_expr_is_err() {\n-        let expansion = parse_macro(\n-            r#\"\n-            macro_rules! stmts {\n-                () => {\n-                    let a = 0;\n-                    let b = 0;\n-                    let c = 0;\n-                    let d = 0;\n-                }\n-            }\n-            \"#,\n-        )\n-        .expand_tt(\"stmts!();\");\n-        assert!(token_tree_to_syntax_node(&expansion, ParserEntryPoint::Expr).is_err());\n-    }\n-\n-    #[test]\n-    fn test_token_tree_last_child_is_white_space() {\n-        let source_file = ast::SourceFile::parse(\"f!{}\").ok().unwrap();\n-        let macro_call = source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-        let token_tree = macro_call.token_tree().unwrap();\n-\n-        // Token Tree now is :\n-        // TokenTree\n-        // - TokenTree\n-        //   - T!['{']\n-        //   - T!['}']\n-\n-        let token_tree = token_tree.clone_for_update();\n-        ted::append_child(token_tree.syntax(), make::tokens::single_space());\n-        let token_tree = token_tree.clone_subtree();\n-        // Token Tree now is :\n-        // TokenTree\n-        // - T!['{']\n-        // - T!['}']\n-        // - WHITE_SPACE\n-\n-        let tt = syntax_node_to_token_tree(token_tree.syntax()).0;\n-        assert_eq!(tt.delimiter_kind(), Some(tt::DelimiterKind::Brace));\n-    }\n-\n-    #[test]\n-    fn test_token_tree_multi_char_punct() {\n-        let source_file = ast::SourceFile::parse(\"struct Foo { a: x::Y }\").ok().unwrap();\n-        let struct_def = source_file.syntax().descendants().find_map(ast::Struct::cast).unwrap();\n-        let tt = syntax_node_to_token_tree(struct_def.syntax()).0;\n-        token_tree_to_syntax_node(&tt, ParserEntryPoint::Item).unwrap();\n-    }\n-\n-    #[test]\n-    fn test_missing_closing_delim() {\n-        let source_file = ast::SourceFile::parse(\"m!(x\").tree();\n-        let node = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n-        let tt = syntax_node_to_token_tree(node.syntax()).0.to_string();\n-        assert_eq_text!(&*tt, \"( x\");\n-    }\n-}"}, {"sha": "ad5ae3a32c2bd036d628b33a551ebdec851751d1", "filename": "crates/mbe/src/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fmbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26f4124b267c513fd930d12f93f8332246bf7651/crates%2Fmbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests.rs?ref=26f4124b267c513fd930d12f93f8332246bf7651", "patch": "@@ -1,5 +1,4 @@\n mod expand;\n-mod rule;\n \n use std::{fmt::Write, iter};\n "}, {"sha": "691e359e4d7a02060d75bd0bfde0521533e169cd", "filename": "crates/mbe/src/tests/rule.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/545b068a7720374a13e04db24e0bef6237822f2a/crates%2Fmbe%2Fsrc%2Ftests%2Frule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/545b068a7720374a13e04db24e0bef6237822f2a/crates%2Fmbe%2Fsrc%2Ftests%2Frule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests%2Frule.rs?ref=545b068a7720374a13e04db24e0bef6237822f2a", "patch": "@@ -1,48 +0,0 @@\n-use syntax::{ast, AstNode};\n-\n-use super::*;\n-\n-#[test]\n-fn test_valid_arms() {\n-    fn check(macro_body: &str) {\n-        let m = parse_macro_arm(macro_body);\n-        m.unwrap();\n-    }\n-\n-    check(\"($i:ident) => ()\");\n-    check(\"($(x),*) => ()\");\n-    check(\"($(x)_*) => ()\");\n-    check(\"($(x)i*) => ()\");\n-    check(\"($($i:ident)*) => ($_)\");\n-    check(\"($($true:ident)*) => ($true)\");\n-    check(\"($($false:ident)*) => ($false)\");\n-    check(\"($) => ($)\");\n-}\n-\n-#[test]\n-fn test_invalid_arms() {\n-    fn check(macro_body: &str, err: ParseError) {\n-        let m = parse_macro_arm(macro_body);\n-        assert_eq!(m, Err(err));\n-    }\n-    check(\"invalid\", ParseError::Expected(\"expected subtree\".into()));\n-\n-    check(\"$i:ident => ()\", ParseError::Expected(\"expected subtree\".into()));\n-    check(\"($i:ident) ()\", ParseError::Expected(\"expected `=`\".into()));\n-    check(\"($($i:ident)_) => ()\", ParseError::InvalidRepeat);\n-\n-    check(\"($i) => ($i)\", ParseError::UnexpectedToken(\"bad fragment specifier 1\".into()));\n-    check(\"($i:) => ($i)\", ParseError::UnexpectedToken(\"bad fragment specifier 1\".into()));\n-    check(\"($i:_) => ()\", ParseError::UnexpectedToken(\"bad fragment specifier 1\".into()));\n-}\n-\n-fn parse_macro_arm(arm_definition: &str) -> Result<crate::MacroRules, ParseError> {\n-    let macro_definition = format!(\" macro_rules! m {{ {} }} \", arm_definition);\n-    let source_file = ast::SourceFile::parse(&macro_definition).ok().unwrap();\n-    let macro_definition =\n-        source_file.syntax().descendants().find_map(ast::MacroRules::cast).unwrap();\n-\n-    let (definition_tt, _) =\n-        syntax_node_to_token_tree(macro_definition.token_tree().unwrap().syntax());\n-    crate::MacroRules::parse(&definition_tt)\n-}"}]}