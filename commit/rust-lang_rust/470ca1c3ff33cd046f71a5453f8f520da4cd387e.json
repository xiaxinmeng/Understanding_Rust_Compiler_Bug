{"sha": "470ca1c3ff33cd046f71a5453f8f520da4cd387e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3MGNhMWMzZmYzM2NkMDQ2ZjcxYTU0NTNmOGY1MjBkYTRjZDM4N2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-07T14:54:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-07T14:54:39Z"}, "message": "Auto merge of #32794 - Manishearth:rollup, r=Manishearth\n\nRollup of 7 pull requests\n\n- Successful merges: #32674, #32699, #32711, #32745, #32748, #32757, #32789\n- Failed merges:", "tree": {"sha": "a3a7cefb1a62d0a01f28d08409007b2cbdd72990", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3a7cefb1a62d0a01f28d08409007b2cbdd72990"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/470ca1c3ff33cd046f71a5453f8f520da4cd387e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/470ca1c3ff33cd046f71a5453f8f520da4cd387e", "html_url": "https://github.com/rust-lang/rust/commit/470ca1c3ff33cd046f71a5453f8f520da4cd387e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/470ca1c3ff33cd046f71a5453f8f520da4cd387e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "444a118a8932c99b902548cb7ca8c249222c053a", "url": "https://api.github.com/repos/rust-lang/rust/commits/444a118a8932c99b902548cb7ca8c249222c053a", "html_url": "https://github.com/rust-lang/rust/commit/444a118a8932c99b902548cb7ca8c249222c053a"}, {"sha": "b0f81a3595febee93c853d561beca12eb917df8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0f81a3595febee93c853d561beca12eb917df8d", "html_url": "https://github.com/rust-lang/rust/commit/b0f81a3595febee93c853d561beca12eb917df8d"}], "stats": {"total": 1336, "additions": 815, "deletions": 521}, "files": [{"sha": "e1f698cb484c1ef3cd2604e5c4112b04cee226be", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -263,6 +263,7 @@ impl<T: ?Sized> Arc<T> {\n         loop {\n             // check if the weak counter is currently \"locked\"; if so, spin.\n             if cur == usize::MAX {\n+                cur = this.inner().weak.load(Relaxed);\n                 continue;\n             }\n "}, {"sha": "236c151891d11880d0d2da424ac29bc8247c7531", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -574,18 +574,48 @@ fn test_slice_2() {\n     assert_eq!(v[1], 3);\n }\n \n+macro_rules! assert_order {\n+    (Greater, $a:expr, $b:expr) => {\n+        assert_eq!($a.cmp($b), Greater);\n+        assert!($a > $b);\n+    };\n+    (Less, $a:expr, $b:expr) => {\n+        assert_eq!($a.cmp($b), Less);\n+        assert!($a < $b);\n+    };\n+    (Equal, $a:expr, $b:expr) => {\n+        assert_eq!($a.cmp($b), Equal);\n+        assert_eq!($a, $b);\n+    }\n+}\n+\n+#[test]\n+fn test_total_ord_u8() {\n+    let c = &[1u8, 2, 3];\n+    assert_order!(Greater, &[1u8, 2, 3, 4][..], &c[..]);\n+    let c = &[1u8, 2, 3, 4];\n+    assert_order!(Less, &[1u8, 2, 3][..], &c[..]);\n+    let c = &[1u8, 2, 3, 6];\n+    assert_order!(Equal, &[1u8, 2, 3, 6][..], &c[..]);\n+    let c = &[1u8, 2, 3, 4, 5, 6];\n+    assert_order!(Less, &[1u8, 2, 3, 4, 5, 5, 5, 5][..], &c[..]);\n+    let c = &[1u8, 2, 3, 4];\n+    assert_order!(Greater, &[2u8, 2][..], &c[..]);\n+}\n+\n+\n #[test]\n-fn test_total_ord() {\n+fn test_total_ord_i32() {\n     let c = &[1, 2, 3];\n-    [1, 2, 3, 4][..].cmp(c) == Greater;\n+    assert_order!(Greater, &[1, 2, 3, 4][..], &c[..]);\n     let c = &[1, 2, 3, 4];\n-    [1, 2, 3][..].cmp(c) == Less;\n+    assert_order!(Less, &[1, 2, 3][..], &c[..]);\n     let c = &[1, 2, 3, 6];\n-    [1, 2, 3, 4][..].cmp(c) == Equal;\n+    assert_order!(Equal, &[1, 2, 3, 6][..], &c[..]);\n     let c = &[1, 2, 3, 4, 5, 6];\n-    [1, 2, 3, 4, 5, 5, 5, 5][..].cmp(c) == Less;\n+    assert_order!(Less, &[1, 2, 3, 4, 5, 5, 5, 5][..], &c[..]);\n     let c = &[1, 2, 3, 4];\n-    [2, 2][..].cmp(c) == Greater;\n+    assert_order!(Greater, &[2, 2][..], &c[..]);\n }\n \n #[test]"}, {"sha": "fa5e90562d80e1b28721b0b3baea998f569262ca", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -75,6 +75,7 @@\n #![feature(unwind_attributes)]\n #![feature(repr_simd, platform_intrinsics)]\n #![feature(rustc_attrs)]\n+#![feature(specialization)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(question_mark)]"}, {"sha": "25082eed2fe6f4b7843eb06064110157f8366f00", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 139, "deletions": 16, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -1630,12 +1630,60 @@ pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n }\n \n //\n-// Boilerplate traits\n+// Comparison traits\n //\n \n+extern {\n+    /// Call implementation provided memcmp\n+    ///\n+    /// Interprets the data as u8.\n+    ///\n+    /// Return 0 for equal, < 0 for less than and > 0 for greater\n+    /// than.\n+    // FIXME(#32610): Return type should be c_int\n+    fn memcmp(s1: *const u8, s2: *const u8, n: usize) -> i32;\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     fn eq(&self, other: &[B]) -> bool {\n+        SlicePartialEq::equal(self, other)\n+    }\n+\n+    fn ne(&self, other: &[B]) -> bool {\n+        SlicePartialEq::not_equal(self, other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Eq> Eq for [T] {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Ord> Ord for [T] {\n+    fn cmp(&self, other: &[T]) -> Ordering {\n+        SliceOrd::compare(self, other)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: PartialOrd> PartialOrd for [T] {\n+    fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n+        SlicePartialOrd::partial_compare(self, other)\n+    }\n+}\n+\n+#[doc(hidden)]\n+// intermediate trait for specialization of slice's PartialEq\n+trait SlicePartialEq<B> {\n+    fn equal(&self, other: &[B]) -> bool;\n+    fn not_equal(&self, other: &[B]) -> bool;\n+}\n+\n+// Generic slice equality\n+impl<A, B> SlicePartialEq<B> for [A]\n+    where A: PartialEq<B>\n+{\n+    default fn equal(&self, other: &[B]) -> bool {\n         if self.len() != other.len() {\n             return false;\n         }\n@@ -1648,7 +1696,8 @@ impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n \n         true\n     }\n-    fn ne(&self, other: &[B]) -> bool {\n+\n+    default fn not_equal(&self, other: &[B]) -> bool {\n         if self.len() != other.len() {\n             return true;\n         }\n@@ -1663,12 +1712,36 @@ impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Eq> Eq for [T] {}\n+// Use memcmp for bytewise equality when the types allow\n+impl<A> SlicePartialEq<A> for [A]\n+    where A: PartialEq<A> + BytewiseEquality\n+{\n+    fn equal(&self, other: &[A]) -> bool {\n+        if self.len() != other.len() {\n+            return false;\n+        }\n+        unsafe {\n+            let size = mem::size_of_val(self);\n+            memcmp(self.as_ptr() as *const u8,\n+                   other.as_ptr() as *const u8, size) == 0\n+        }\n+    }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord> Ord for [T] {\n-    fn cmp(&self, other: &[T]) -> Ordering {\n+    fn not_equal(&self, other: &[A]) -> bool {\n+        !self.equal(other)\n+    }\n+}\n+\n+#[doc(hidden)]\n+// intermediate trait for specialization of slice's PartialOrd\n+trait SlicePartialOrd<B> {\n+    fn partial_compare(&self, other: &[B]) -> Option<Ordering>;\n+}\n+\n+impl<A> SlicePartialOrd<A> for [A]\n+    where A: PartialOrd\n+{\n+    default fn partial_compare(&self, other: &[A]) -> Option<Ordering> {\n         let l = cmp::min(self.len(), other.len());\n \n         // Slice to the loop iteration range to enable bound check\n@@ -1677,19 +1750,33 @@ impl<T: Ord> Ord for [T] {\n         let rhs = &other[..l];\n \n         for i in 0..l {\n-            match lhs[i].cmp(&rhs[i]) {\n-                Ordering::Equal => (),\n+            match lhs[i].partial_cmp(&rhs[i]) {\n+                Some(Ordering::Equal) => (),\n                 non_eq => return non_eq,\n             }\n         }\n \n-        self.len().cmp(&other.len())\n+        self.len().partial_cmp(&other.len())\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialOrd> PartialOrd for [T] {\n-    fn partial_cmp(&self, other: &[T]) -> Option<Ordering> {\n+impl SlicePartialOrd<u8> for [u8] {\n+    #[inline]\n+    fn partial_compare(&self, other: &[u8]) -> Option<Ordering> {\n+        Some(SliceOrd::compare(self, other))\n+    }\n+}\n+\n+#[doc(hidden)]\n+// intermediate trait for specialization of slice's Ord\n+trait SliceOrd<B> {\n+    fn compare(&self, other: &[B]) -> Ordering;\n+}\n+\n+impl<A> SliceOrd<A> for [A]\n+    where A: Ord\n+{\n+    default fn compare(&self, other: &[A]) -> Ordering {\n         let l = cmp::min(self.len(), other.len());\n \n         // Slice to the loop iteration range to enable bound check\n@@ -1698,12 +1785,48 @@ impl<T: PartialOrd> PartialOrd for [T] {\n         let rhs = &other[..l];\n \n         for i in 0..l {\n-            match lhs[i].partial_cmp(&rhs[i]) {\n-                Some(Ordering::Equal) => (),\n+            match lhs[i].cmp(&rhs[i]) {\n+                Ordering::Equal => (),\n                 non_eq => return non_eq,\n             }\n         }\n \n-        self.len().partial_cmp(&other.len())\n+        self.len().cmp(&other.len())\n     }\n }\n+\n+// memcmp compares a sequence of unsigned bytes lexicographically.\n+// this matches the order we want for [u8], but no others (not even [i8]).\n+impl SliceOrd<u8> for [u8] {\n+    #[inline]\n+    fn compare(&self, other: &[u8]) -> Ordering {\n+        let order = unsafe {\n+            memcmp(self.as_ptr(), other.as_ptr(),\n+                   cmp::min(self.len(), other.len()))\n+        };\n+        if order == 0 {\n+            self.len().cmp(&other.len())\n+        } else if order < 0 {\n+            Less\n+        } else {\n+            Greater\n+        }\n+    }\n+}\n+\n+#[doc(hidden)]\n+/// Trait implemented for types that can be compared for equality using\n+/// their bytewise representation\n+trait BytewiseEquality { }\n+\n+macro_rules! impl_marker_for {\n+    ($traitname:ident, $($ty:ty)*) => {\n+        $(\n+            impl $traitname for $ty { }\n+        )*\n+    }\n+}\n+\n+impl_marker_for!(BytewiseEquality,\n+                 u8 i8 u16 i16 u32 i32 u64 i64 usize isize char bool);\n+"}, {"sha": "305546df5be2da171140dd5aaad372dae1ea6ba2", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -1150,16 +1150,7 @@ Section: Comparing strings\n #[lang = \"str_eq\"]\n #[inline]\n fn eq_slice(a: &str, b: &str) -> bool {\n-    a.len() == b.len() && unsafe { cmp_slice(a, b, a.len()) == 0 }\n-}\n-\n-/// Bytewise slice comparison.\n-/// NOTE: This uses the system's memcmp, which is currently dramatically\n-/// faster than comparing each byte in a loop.\n-#[inline]\n-unsafe fn cmp_slice(a: &str, b: &str, len: usize) -> i32 {\n-    extern { fn memcmp(s1: *const i8, s2: *const i8, n: usize) -> i32; }\n-    memcmp(a.as_ptr() as *const i8, b.as_ptr() as *const i8, len)\n+    a.as_bytes() == b.as_bytes()\n }\n \n /*\n@@ -1328,8 +1319,7 @@ Section: Trait implementations\n */\n \n mod traits {\n-    use cmp::{self, Ordering, Ord, PartialEq, PartialOrd, Eq};\n-    use cmp::Ordering::{Less, Greater};\n+    use cmp::{Ord, Ordering, PartialEq, PartialOrd, Eq};\n     use iter::Iterator;\n     use option::Option;\n     use option::Option::Some;\n@@ -1340,16 +1330,7 @@ mod traits {\n     impl Ord for str {\n         #[inline]\n         fn cmp(&self, other: &str) -> Ordering {\n-            let cmp = unsafe {\n-                super::cmp_slice(self, other, cmp::min(self.len(), other.len()))\n-            };\n-            if cmp == 0 {\n-                self.len().cmp(&other.len())\n-            } else if cmp < 0 {\n-                Less\n-            } else {\n-                Greater\n-            }\n+            self.as_bytes().cmp(other.as_bytes())\n         }\n     }\n "}, {"sha": "483c3822df6ca345532f352ff99e358897dd8c6a", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -327,7 +327,7 @@ impl AtomicBool {\n     /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n     /// operation. The first describes the required ordering if the operation succeeds while the\n     /// second describes the required ordering when the operation fails. The failure ordering can't\n-    /// be `Acquire` or `AcqRel` and must be equivalent or weaker than the success ordering.\n+    /// be `Release` or `AcqRel` and must be equivalent or weaker than the success ordering.\n     ///\n     /// # Examples\n     ///\n@@ -376,7 +376,7 @@ impl AtomicBool {\n     /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the operation\n     /// succeeds while the second describes the required ordering when the operation fails. The\n-    /// failure ordering can't be `Acquire` or `AcqRel` and must be equivalent or weaker than the\n+    /// failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker than the\n     /// success ordering.\n     ///\n     /// # Examples\n@@ -663,7 +663,7 @@ impl AtomicIsize {\n     /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n     /// operation. The first describes the required ordering if the operation succeeds while the\n     /// second describes the required ordering when the operation fails. The failure ordering can't\n-    /// be `Acquire` or `AcqRel` and must be equivalent or weaker than the success ordering.\n+    /// be `Release` or `AcqRel` and must be equivalent or weaker than the success ordering.\n     ///\n     /// # Examples\n     ///\n@@ -705,7 +705,7 @@ impl AtomicIsize {\n     /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the operation\n     /// succeeds while the second describes the required ordering when the operation fails. The\n-    /// failure ordering can't be `Acquire` or `AcqRel` and must be equivalent or weaker than the\n+    /// failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker than the\n     /// success ordering.\n     ///\n     /// # Examples\n@@ -939,7 +939,7 @@ impl AtomicUsize {\n     /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n     /// operation. The first describes the required ordering if the operation succeeds while the\n     /// second describes the required ordering when the operation fails. The failure ordering can't\n-    /// be `Acquire` or `AcqRel` and must be equivalent or weaker than the success ordering.\n+    /// be `Release` or `AcqRel` and must be equivalent or weaker than the success ordering.\n     ///\n     /// # Examples\n     ///\n@@ -981,7 +981,7 @@ impl AtomicUsize {\n     /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the operation\n     /// succeeds while the second describes the required ordering when the operation fails. The\n-    /// failure ordering can't be `Acquire` or `AcqRel` and must be equivalent or weaker than the\n+    /// failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker than the\n     /// success ordering.\n     ///\n     /// # Examples\n@@ -1223,7 +1223,7 @@ impl<T> AtomicPtr<T> {\n     /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n     /// operation. The first describes the required ordering if the operation succeeds while the\n     /// second describes the required ordering when the operation fails. The failure ordering can't\n-    /// be `Acquire` or `AcqRel` and must be equivalent or weaker than the success ordering.\n+    /// be `Release` or `AcqRel` and must be equivalent or weaker than the success ordering.\n     ///\n     /// # Examples\n     ///\n@@ -1270,7 +1270,7 @@ impl<T> AtomicPtr<T> {\n     /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the operation\n     /// succeeds while the second describes the required ordering when the operation fails. The\n-    /// failure ordering can't be `Acquire` or `AcqRel` and must be equivalent or weaker than the\n+    /// failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker than the\n     /// success ordering.\n     ///\n     /// # Examples\n@@ -1396,8 +1396,8 @@ unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n         (AcqRel, Relaxed)  => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n         (SeqCst, Relaxed)  => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n         (SeqCst, Acquire)  => intrinsics::atomic_cxchg_failacq(dst, old, new),\n-        (_, Release) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n-        (_, AcqRel) => panic!(\"there is no such thing as a release failure ordering\"),\n+        (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n+        (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n         _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n     };\n     if ok {\n@@ -1446,8 +1446,8 @@ unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n         (AcqRel, Relaxed)  => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n         (SeqCst, Relaxed)  => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n         (SeqCst, Acquire)  => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n-        (_, Release) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n-        (_, AcqRel) => panic!(\"there is no such thing as a release failure ordering\"),\n+        (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n+        (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n         _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n     };\n     if ok {"}, {"sha": "55fd58da86635b61ee7eb7e619b70e2bb70e7b4f", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -37,10 +37,10 @@ use std::u32;\n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n     /// fn foo() or extern \"Abi\" fn foo()\n-    ItemFn(Name, &'a Generics, Unsafety, Constness, Abi, Visibility, &'a [Attribute]),\n+    ItemFn(Name, &'a Generics, Unsafety, Constness, Abi, &'a Visibility, &'a [Attribute]),\n \n     /// fn foo(&self)\n-    Method(Name, &'a MethodSig, Option<Visibility>, &'a [Attribute]),\n+    Method(Name, &'a MethodSig, Option<&'a Visibility>, &'a [Attribute]),\n \n     /// |x, y| {}\n     Closure(&'a [Attribute]),\n@@ -324,7 +324,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                                             unsafety,\n                                             constness,\n                                             abi,\n-                                            item.vis,\n+                                            &item.vis,\n                                             &item.attrs),\n                              declaration,\n                              body,\n@@ -672,7 +672,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n         ImplItemKind::Method(ref sig, ref body) => {\n             visitor.visit_fn(FnKind::Method(impl_item.name,\n                                             sig,\n-                                            Some(impl_item.vis),\n+                                            Some(&impl_item.vis),\n                                             &impl_item.attrs),\n                              &sig.decl,\n                              body,"}, {"sha": "8c626226bd3c3588842f2a093863faa5cafa157d", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -113,7 +113,7 @@ struct ItemFnParts<'a> {\n     unsafety: ast::Unsafety,\n     constness: ast::Constness,\n     abi:      abi::Abi,\n-    vis:      ast::Visibility,\n+    vis:      &'a ast::Visibility,\n     generics: &'a ast::Generics,\n     body:     &'a Block,\n     id:       NodeId,\n@@ -208,7 +208,7 @@ impl<'a> FnLikeNode<'a> {\n         M: FnOnce(NodeId,\n                   Name,\n                   &'a ast::MethodSig,\n-                  Option<ast::Visibility>,\n+                  Option<&'a ast::Visibility>,\n                   &'a ast::Block,\n                   Span,\n                   &'a [Attribute])\n@@ -226,7 +226,7 @@ impl<'a> FnLikeNode<'a> {\n                         body: &block,\n                         generics: generics,\n                         abi: abi,\n-                        vis: i.vis,\n+                        vis: &i.vis,\n                         constness: constness,\n                         span: i.span,\n                         attrs: &i.attrs,\n@@ -242,7 +242,7 @@ impl<'a> FnLikeNode<'a> {\n             map::NodeImplItem(ii) => {\n                 match ii.node {\n                     ast::ImplItemKind::Method(ref sig, ref body) => {\n-                        method(ii.id, ii.name, sig, Some(ii.vis), body, ii.span, &ii.attrs)\n+                        method(ii.id, ii.name, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n                     }\n                     _ => {\n                         bug!(\"impl method FnLikeNode that is not fn-like\")"}, {"sha": "fc1c4aeb226012b09c0d33ad314e00497eb38822", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -430,7 +430,7 @@ impl<'ast> Map<'ast> {\n \n     /// Returns the NodeId of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n-    fn get_module_parent(&self, id: NodeId) -> NodeId {\n+    pub fn get_module_parent(&self, id: NodeId) -> NodeId {\n         match self.walk_parent_nodes(id, |node| match *node {\n             NodeItem(&Item { node: Item_::ItemMod(_), .. }) => true,\n             _ => false,\n@@ -440,18 +440,6 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn private_item_is_visible_from(&self, item: NodeId, block: NodeId) -> bool {\n-        // A private item is visible from everything in its nearest module parent.\n-        let visibility = self.get_module_parent(item);\n-        let mut block_ancestor = self.get_module_parent(block);\n-        loop {\n-            if block_ancestor == visibility { return true }\n-            let block_ancestor_parent = self.get_module_parent(block_ancestor);\n-            if block_ancestor_parent == block_ancestor { return false }\n-            block_ancestor = block_ancestor_parent;\n-        }\n-    }\n-\n     /// Returns the nearest enclosing scope. A scope is an item or block.\n     /// FIXME it is not clear to me that all items qualify as scopes - statics\n     /// and associated types probably shouldn't, for example. Behaviour in this"}, {"sha": "8e748875b93f1b4be226f8e73b65acc0348d7436", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -1431,21 +1431,12 @@ pub struct PolyTraitRef {\n     pub span: Span,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Visibility {\n     Public,\n     Inherited,\n }\n \n-impl Visibility {\n-    pub fn inherit_from(&self, parent_visibility: Visibility) -> Visibility {\n-        match self {\n-            &Inherited => parent_visibility,\n-            &Public => *self,\n-        }\n-    }\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct StructField {\n     pub span: Span,"}, {"sha": "7affb129313c886015b53931c07bbd570bd21acc", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -294,7 +294,7 @@ pub fn fun_to_string(decl: &hir::FnDecl,\n                    Some(name),\n                    generics,\n                    opt_explicit_self,\n-                   hir::Inherited)?;\n+                   &hir::Inherited)?;\n         s.end()?; // Close the head box\n         s.end() // Close the outer box\n     })\n@@ -322,8 +322,8 @@ pub fn arg_to_string(arg: &hir::Arg) -> String {\n     to_string(|s| s.print_arg(arg, false))\n }\n \n-pub fn visibility_qualified(vis: hir::Visibility, s: &str) -> String {\n-    match vis {\n+pub fn visibility_qualified(vis: &hir::Visibility, s: &str) -> String {\n+    match *vis {\n         hir::Public => format!(\"pub {}\", s),\n         hir::Inherited => s.to_string(),\n     }\n@@ -573,13 +573,13 @@ impl<'a> State<'a> {\n                               Some(item.name),\n                               generics,\n                               None,\n-                              item.vis)?;\n+                              &item.vis)?;\n                 self.end()?; // end head-ibox\n                 word(&mut self.s, \";\")?;\n                 self.end() // end the outer fn box\n             }\n             hir::ForeignItemStatic(ref t, m) => {\n-                self.head(&visibility_qualified(item.vis, \"static\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"static\"))?;\n                 if m {\n                     self.word_space(\"mut\")?;\n                 }\n@@ -597,7 +597,7 @@ impl<'a> State<'a> {\n                               name: ast::Name,\n                               ty: &hir::Ty,\n                               default: Option<&hir::Expr>,\n-                              vis: hir::Visibility)\n+                              vis: &hir::Visibility)\n                               -> io::Result<()> {\n         word(&mut self.s, &visibility_qualified(vis, \"\"))?;\n         self.word_space(\"const\")?;\n@@ -648,7 +648,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, NodeItem(item))?;\n         match item.node {\n             hir::ItemExternCrate(ref optional_path) => {\n-                self.head(&visibility_qualified(item.vis, \"extern crate\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"extern crate\"))?;\n                 if let Some(p) = *optional_path {\n                     let val = p.as_str();\n                     if val.contains(\"-\") {\n@@ -666,14 +666,14 @@ impl<'a> State<'a> {\n                 self.end()?; // end outer head-block\n             }\n             hir::ItemUse(ref vp) => {\n-                self.head(&visibility_qualified(item.vis, \"use\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"use\"))?;\n                 self.print_view_path(&vp)?;\n                 word(&mut self.s, \";\")?;\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n             hir::ItemStatic(ref ty, m, ref expr) => {\n-                self.head(&visibility_qualified(item.vis, \"static\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"static\"))?;\n                 if m == hir::MutMutable {\n                     self.word_space(\"mut\")?;\n                 }\n@@ -689,7 +689,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end the outer cbox\n             }\n             hir::ItemConst(ref ty, ref expr) => {\n-                self.head(&visibility_qualified(item.vis, \"const\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"const\"))?;\n                 self.print_name(item.name)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n@@ -710,12 +710,12 @@ impl<'a> State<'a> {\n                               Some(item.name),\n                               typarams,\n                               None,\n-                              item.vis)?;\n+                              &item.vis)?;\n                 word(&mut self.s, \" \")?;\n                 self.print_block_with_attrs(&body, &item.attrs)?;\n             }\n             hir::ItemMod(ref _mod) => {\n-                self.head(&visibility_qualified(item.vis, \"mod\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n                 self.print_name(item.name)?;\n                 self.nbsp()?;\n                 self.bopen()?;\n@@ -732,7 +732,7 @@ impl<'a> State<'a> {\n             hir::ItemTy(ref ty, ref params) => {\n                 self.ibox(indent_unit)?;\n                 self.ibox(0)?;\n-                self.word_nbsp(&visibility_qualified(item.vis, \"type\"))?;\n+                self.word_nbsp(&visibility_qualified(&item.vis, \"type\"))?;\n                 self.print_name(item.name)?;\n                 self.print_generics(params)?;\n                 self.end()?; // end the inner ibox\n@@ -745,16 +745,16 @@ impl<'a> State<'a> {\n                 self.end()?; // end the outer ibox\n             }\n             hir::ItemEnum(ref enum_definition, ref params) => {\n-                self.print_enum_def(enum_definition, params, item.name, item.span, item.vis)?;\n+                self.print_enum_def(enum_definition, params, item.name, item.span, &item.vis)?;\n             }\n             hir::ItemStruct(ref struct_def, ref generics) => {\n-                self.head(&visibility_qualified(item.vis, \"struct\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"struct\"))?;\n                 self.print_struct(struct_def, generics, item.name, item.span, true)?;\n             }\n \n             hir::ItemDefaultImpl(unsafety, ref trait_ref) => {\n                 self.head(\"\")?;\n-                self.print_visibility(item.vis)?;\n+                self.print_visibility(&item.vis)?;\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"impl\")?;\n                 self.print_trait_ref(trait_ref)?;\n@@ -771,7 +771,7 @@ impl<'a> State<'a> {\n                           ref ty,\n                           ref impl_items) => {\n                 self.head(\"\")?;\n-                self.print_visibility(item.vis)?;\n+                self.print_visibility(&item.vis)?;\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"impl\")?;\n \n@@ -809,7 +809,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemTrait(unsafety, ref generics, ref bounds, ref trait_items) => {\n                 self.head(\"\")?;\n-                self.print_visibility(item.vis)?;\n+                self.print_visibility(&item.vis)?;\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"trait\")?;\n                 self.print_name(item.name)?;\n@@ -867,7 +867,7 @@ impl<'a> State<'a> {\n                           generics: &hir::Generics,\n                           name: ast::Name,\n                           span: codemap::Span,\n-                          visibility: hir::Visibility)\n+                          visibility: &hir::Visibility)\n                           -> io::Result<()> {\n         self.head(&visibility_qualified(visibility, \"enum\"))?;\n         self.print_name(name)?;\n@@ -895,8 +895,8 @@ impl<'a> State<'a> {\n         self.bclose(span)\n     }\n \n-    pub fn print_visibility(&mut self, vis: hir::Visibility) -> io::Result<()> {\n-        match vis {\n+    pub fn print_visibility(&mut self, vis: &hir::Visibility) -> io::Result<()> {\n+        match *vis {\n             hir::Public => self.word_nbsp(\"pub\"),\n             hir::Inherited => Ok(()),\n         }\n@@ -915,7 +915,7 @@ impl<'a> State<'a> {\n             if struct_def.is_tuple() {\n                 self.popen()?;\n                 self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n-                    s.print_visibility(field.vis)?;\n+                    s.print_visibility(&field.vis)?;\n                     s.maybe_print_comment(field.span.lo)?;\n                     s.print_type(&field.ty)\n                 })?;\n@@ -937,7 +937,7 @@ impl<'a> State<'a> {\n                 self.hardbreak_if_not_bol()?;\n                 self.maybe_print_comment(field.span.lo)?;\n                 self.print_outer_attributes(&field.attrs)?;\n-                self.print_visibility(field.vis)?;\n+                self.print_visibility(&field.vis)?;\n                 self.print_name(field.name)?;\n                 self.word_nbsp(\":\")?;\n                 self.print_type(&field.ty)?;\n@@ -964,7 +964,7 @@ impl<'a> State<'a> {\n     pub fn print_method_sig(&mut self,\n                             name: ast::Name,\n                             m: &hir::MethodSig,\n-                            vis: hir::Visibility)\n+                            vis: &hir::Visibility)\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n                       m.unsafety,\n@@ -986,13 +986,13 @@ impl<'a> State<'a> {\n                 self.print_associated_const(ti.name,\n                                             &ty,\n                                             default.as_ref().map(|expr| &**expr),\n-                                            hir::Inherited)?;\n+                                            &hir::Inherited)?;\n             }\n             hir::MethodTraitItem(ref sig, ref body) => {\n                 if body.is_some() {\n                     self.head(\"\")?;\n                 }\n-                self.print_method_sig(ti.name, sig, hir::Inherited)?;\n+                self.print_method_sig(ti.name, sig, &hir::Inherited)?;\n                 if let Some(ref body) = *body {\n                     self.nbsp()?;\n                     self.print_block_with_attrs(body, &ti.attrs)?;\n@@ -1021,11 +1021,11 @@ impl<'a> State<'a> {\n \n         match ii.node {\n             hir::ImplItemKind::Const(ref ty, ref expr) => {\n-                self.print_associated_const(ii.name, &ty, Some(&expr), ii.vis)?;\n+                self.print_associated_const(ii.name, &ty, Some(&expr), &ii.vis)?;\n             }\n             hir::ImplItemKind::Method(ref sig, ref body) => {\n                 self.head(\"\")?;\n-                self.print_method_sig(ii.name, sig, ii.vis)?;\n+                self.print_method_sig(ii.name, sig, &ii.vis)?;\n                 self.nbsp()?;\n                 self.print_block_with_attrs(body, &ii.attrs)?;\n             }\n@@ -1910,7 +1910,7 @@ impl<'a> State<'a> {\n                     name: Option<ast::Name>,\n                     generics: &hir::Generics,\n                     opt_explicit_self: Option<&hir::ExplicitSelf_>,\n-                    vis: hir::Visibility)\n+                    vis: &hir::Visibility)\n                     -> io::Result<()> {\n         self.print_fn_header_info(unsafety, constness, abi, vis)?;\n \n@@ -2267,7 +2267,7 @@ impl<'a> State<'a> {\n                       name,\n                       &generics,\n                       opt_explicit_self,\n-                      hir::Inherited)?;\n+                      &hir::Inherited)?;\n         self.end()\n     }\n \n@@ -2347,7 +2347,7 @@ impl<'a> State<'a> {\n                                 unsafety: hir::Unsafety,\n                                 constness: hir::Constness,\n                                 abi: Abi,\n-                                vis: hir::Visibility)\n+                                vis: &hir::Visibility)\n                                 -> io::Result<()> {\n         word(&mut self.s, &visibility_qualified(vis, \"\"))?;\n         self.print_unsafety(unsafety)?;"}, {"sha": "d3db0804c24229abf30cdc23bbe44d66529518ac", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -116,7 +116,7 @@ pub const LOCAL_CRATE: ast::CrateNum = 0;\n pub struct ChildItem {\n     pub def: DefLike,\n     pub name: ast::Name,\n-    pub vis: hir::Visibility\n+    pub vis: ty::Visibility,\n }\n \n pub enum FoundAst<'ast> {\n@@ -157,7 +157,7 @@ pub trait CrateStore<'tcx> : Any {\n     // item info\n     fn stability(&self, def: DefId) -> Option<attr::Stability>;\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n-    fn visibility(&self, def: DefId) -> hir::Visibility;\n+    fn visibility(&self, def: DefId) -> ty::Visibility;\n     fn closure_kind(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n                     -> ty::ClosureKind;\n     fn closure_ty(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n@@ -334,7 +334,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // item info\n     fn stability(&self, def: DefId) -> Option<attr::Stability> { bug!(\"stability\") }\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { bug!(\"deprecation\") }\n-    fn visibility(&self, def: DefId) -> hir::Visibility { bug!(\"visibility\") }\n+    fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n     fn closure_kind(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n                     -> ty::ClosureKind  { bug!(\"closure_kind\") }\n     fn closure_ty(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)"}, {"sha": "3c65e368db5facd4853f3d90ae5678eda53963fe", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 149, "deletions": 56, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -18,8 +18,9 @@ use hir::def_id::DefId;\n use infer;\n use traits::{self, ProjectionMode};\n use ty::{self, TyCtxt, ImplOrTraitItem, TraitDef, TypeFoldable};\n+use ty::fast_reject::{self, SimplifiedType};\n use syntax::ast::Name;\n-use util::nodemap::DefIdMap;\n+use util::nodemap::{DefIdMap, FnvHashMap};\n \n /// A per-trait graph of impls in specialization order. At the moment, this\n /// graph forms a tree rooted with the trait itself, with all other nodes\n@@ -42,7 +43,124 @@ pub struct Graph {\n     parent: DefIdMap<DefId>,\n \n     // the \"root\" impls are found by looking up the trait's def_id.\n-    children: DefIdMap<Vec<DefId>>,\n+    children: DefIdMap<Children>,\n+}\n+\n+/// Children of a given impl, grouped into blanket/non-blanket varieties as is\n+/// done in `TraitDef`.\n+struct Children {\n+    // Impls of a trait (or specializations of a given impl). To allow for\n+    // quicker lookup, the impls are indexed by a simplified version of their\n+    // `Self` type: impls with a simplifiable `Self` are stored in\n+    // `nonblanket_impls` keyed by it, while all other impls are stored in\n+    // `blanket_impls`.\n+    //\n+    // A similar division is used within `TraitDef`, but the lists there collect\n+    // together *all* the impls for a trait, and are populated prior to building\n+    // the specialization graph.\n+\n+    /// Impls of the trait.\n+    nonblanket_impls: FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n+\n+    /// Blanket impls associated with the trait.\n+    blanket_impls: Vec<DefId>,\n+}\n+\n+/// The result of attempting to insert an impl into a group of children.\n+enum InsertResult<'a, 'tcx: 'a> {\n+    /// The impl was inserted as a new child in this group of children.\n+    BecameNewSibling,\n+\n+    /// The impl replaced an existing impl that specializes it.\n+    Replaced(DefId),\n+\n+    /// The impl is a specialization of an existing child.\n+    ShouldRecurseOn(DefId),\n+\n+    /// The impl has an unresolvable overlap with an existing child (neither\n+    /// specializes the other).\n+    Overlapped(Overlap<'a, 'tcx>),\n+}\n+\n+impl Children {\n+    fn new() -> Children {\n+        Children {\n+            nonblanket_impls: FnvHashMap(),\n+            blanket_impls: vec![],\n+        }\n+    }\n+\n+    /// Insert an impl into this set of children without comparing to any existing impls\n+    fn insert_blindly(&mut self, tcx: &TyCtxt, impl_def_id: DefId) {\n+        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+        if let Some(sty) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n+            self.nonblanket_impls.entry(sty).or_insert(vec![]).push(impl_def_id)\n+        } else {\n+            self.blanket_impls.push(impl_def_id)\n+        }\n+    }\n+\n+    /// Attempt to insert an impl into this set of children, while comparing for\n+    /// specialiation relationships.\n+    fn insert<'a, 'tcx>(&mut self,\n+                        tcx: &'a TyCtxt<'tcx>,\n+                        impl_def_id: DefId,\n+                        simplified_self: Option<SimplifiedType>)\n+                        -> InsertResult<'a, 'tcx>\n+    {\n+        for slot in match simplified_self {\n+            Some(sty) => self.filtered_mut(sty),\n+            None => self.iter_mut(),\n+        } {\n+            let possible_sibling = *slot;\n+\n+            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::Topmost);\n+            let overlap = traits::overlapping_impls(&infcx, possible_sibling, impl_def_id);\n+\n+            if let Some(impl_header) = overlap {\n+                let le = specializes(tcx, impl_def_id, possible_sibling);\n+                let ge = specializes(tcx, possible_sibling, impl_def_id);\n+\n+                if le && !ge {\n+                    debug!(\"descending as child of TraitRef {:?}\",\n+                           tcx.impl_trait_ref(possible_sibling).unwrap());\n+\n+                    // the impl specializes possible_sibling\n+                    return InsertResult::ShouldRecurseOn(possible_sibling);\n+                } else if ge && !le {\n+                    debug!(\"placing as parent of TraitRef {:?}\",\n+                           tcx.impl_trait_ref(possible_sibling).unwrap());\n+\n+                    // possible_sibling specializes the impl\n+                    *slot = impl_def_id;\n+                    return InsertResult::Replaced(possible_sibling);\n+                } else {\n+                    // overlap, but no specialization; error out\n+                    return InsertResult::Overlapped(Overlap {\n+                        with_impl: possible_sibling,\n+                        on_trait_ref: impl_header.trait_ref.unwrap(),\n+                        in_context: infcx,\n+                    });\n+                }\n+            }\n+        }\n+\n+        // no overlap with any potential siblings, so add as a new sibling\n+        debug!(\"placing as new sibling\");\n+        self.insert_blindly(tcx, impl_def_id);\n+        InsertResult::BecameNewSibling\n+    }\n+\n+    fn iter_mut<'a>(&'a mut self) -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n+        let nonblanket = self.nonblanket_impls.iter_mut().flat_map(|(_, v)| v.iter_mut());\n+        Box::new(self.blanket_impls.iter_mut().chain(nonblanket))\n+    }\n+\n+    fn filtered_mut<'a>(&'a mut self, sty: SimplifiedType)\n+                        -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n+        let nonblanket = self.nonblanket_impls.entry(sty).or_insert(vec![]).iter_mut();\n+        Box::new(self.blanket_impls.iter_mut().chain(nonblanket))\n+    }\n }\n \n impl Graph {\n@@ -78,78 +196,53 @@ impl Graph {\n                    trait_ref, impl_def_id, trait_def_id);\n \n             self.parent.insert(impl_def_id, trait_def_id);\n-            self.children.entry(trait_def_id).or_insert(vec![]).push(impl_def_id);\n+            self.children.entry(trait_def_id).or_insert(Children::new())\n+                .insert_blindly(tcx, impl_def_id);\n             return Ok(());\n         }\n \n         let mut parent = trait_def_id;\n+        let simplified = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false);\n \n-        // Ugly hack around borrowck limitations. Assigned only in the case\n-        // where we bump downward an existing node in the graph.\n-        let child_to_insert;\n-\n-        'descend: loop {\n-            let mut possible_siblings = self.children.entry(parent).or_insert(vec![]);\n-\n-            for slot in possible_siblings.iter_mut() {\n-                let possible_sibling = *slot;\n-\n-                let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::Topmost);\n-                let overlap = traits::overlapping_impls(&infcx, possible_sibling, impl_def_id);\n-\n-                if let Some(impl_header) = overlap {\n-                    let le = specializes(tcx, impl_def_id, possible_sibling);\n-                    let ge = specializes(tcx, possible_sibling, impl_def_id);\n-\n-                    if le && !ge {\n-                        debug!(\"descending as child of TraitRef {:?}\",\n-                               tcx.impl_trait_ref(possible_sibling).unwrap());\n-\n-                        // the impl specializes possible_sibling\n-                        parent = possible_sibling;\n-                        continue 'descend;\n-                    } else if ge && !le {\n-                        debug!(\"placing as parent of TraitRef {:?}\",\n-                               tcx.impl_trait_ref(possible_sibling).unwrap());\n-\n-                        // possible_sibling specializes the impl\n-                        *slot = impl_def_id;\n-                        self.parent.insert(impl_def_id, parent);\n-                        self.parent.insert(possible_sibling, impl_def_id);\n-                        // we have to defer the insertion, because we can't\n-                        // relinquish the borrow of `self.children`\n-                        child_to_insert = possible_sibling;\n-                        break 'descend;\n-                    } else {\n-                        // overlap, but no specialization; error out\n-                        return Err(Overlap {\n-                            with_impl: possible_sibling,\n-                            on_trait_ref: impl_header.trait_ref.unwrap(),\n-                            in_context: infcx,\n-                        });\n-                    }\n+        // Descend the specialization tree, where `parent` is the current parent node\n+        loop {\n+            use self::InsertResult::*;\n+\n+            let insert_result = self.children.entry(parent).or_insert(Children::new())\n+                .insert(tcx, impl_def_id, simplified);\n+\n+            match insert_result {\n+                BecameNewSibling => {\n+                    break;\n+                }\n+                Replaced(new_child) => {\n+                    self.parent.insert(new_child, impl_def_id);\n+                    let mut new_children = Children::new();\n+                    new_children.insert_blindly(tcx, new_child);\n+                    self.children.insert(impl_def_id, new_children);\n+                    break;\n+                }\n+                ShouldRecurseOn(new_parent) => {\n+                    parent = new_parent;\n+                }\n+                Overlapped(error) => {\n+                    return Err(error);\n                 }\n             }\n-\n-            // no overlap with any potential siblings, so add as a new sibling\n-            debug!(\"placing as new sibling\");\n-            self.parent.insert(impl_def_id, parent);\n-            possible_siblings.push(impl_def_id);\n-            return Ok(());\n         }\n \n-        self.children.insert(impl_def_id, vec![child_to_insert]);\n+        self.parent.insert(impl_def_id, parent);\n         Ok(())\n     }\n \n     /// Insert cached metadata mapping from a child impl back to its parent.\n-    pub fn record_impl_from_cstore(&mut self, parent: DefId, child: DefId) {\n+    pub fn record_impl_from_cstore(&mut self, tcx: &TyCtxt, parent: DefId, child: DefId) {\n         if self.parent.insert(child, parent).is_some() {\n             bug!(\"When recording an impl from the crate store, information about its parent \\\n                   was already present.\");\n         }\n \n-        self.children.entry(parent).or_insert(vec![]).push(child);\n+        self.children.entry(parent).or_insert(Children::new()).insert_blindly(tcx, child);\n     }\n \n     /// The parent of a given impl, which is the def id of the trait when the"}, {"sha": "47e8f91b48c61bc22ad2aaa76d892c69c641b841", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 57, "deletions": 7, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -232,7 +232,7 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n         }\n     }\n \n-    pub fn vis(&self) -> hir::Visibility {\n+    pub fn vis(&self) -> Visibility {\n         match *self {\n             ConstTraitItem(ref associated_const) => associated_const.vis,\n             MethodTraitItem(ref method) => method.vis,\n@@ -273,14 +273,64 @@ impl ImplOrTraitItemId {\n     }\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq, Copy)]\n+pub enum Visibility {\n+    /// Visible everywhere (including in other crates).\n+    Public,\n+    /// Visible only in the given crate-local module.\n+    Restricted(NodeId),\n+    /// Not visible anywhere in the local crate. This is the visibility of private external items.\n+    PrivateExternal,\n+}\n+\n+impl Visibility {\n+    pub fn from_hir(visibility: &hir::Visibility, id: NodeId, tcx: &TyCtxt) -> Self {\n+        match *visibility {\n+            hir::Public => Visibility::Public,\n+            hir::Inherited => Visibility::Restricted(tcx.map.get_module_parent(id)),\n+        }\n+    }\n+\n+    /// Returns true if an item with this visibility is accessible from the given block.\n+    pub fn is_accessible_from(self, block: NodeId, map: &ast_map::Map) -> bool {\n+        let restriction = match self {\n+            // Public items are visible everywhere.\n+            Visibility::Public => return true,\n+            // Private items from other crates are visible nowhere.\n+            Visibility::PrivateExternal => return false,\n+            // Restricted items are visible in an arbitrary local module.\n+            Visibility::Restricted(module) => module,\n+        };\n+\n+        let mut block_ancestor = block;\n+        loop {\n+            if block_ancestor == restriction { return true }\n+            let block_ancestor_parent = map.get_module_parent(block_ancestor);\n+            if block_ancestor_parent == block_ancestor { return false }\n+            block_ancestor = block_ancestor_parent;\n+        }\n+    }\n+\n+    /// Returns true if this visibility is at least as accessible as the given visibility\n+    pub fn is_at_least(self, vis: Visibility, map: &ast_map::Map) -> bool {\n+        let vis_restriction = match vis {\n+            Visibility::Public => return self == Visibility::Public,\n+            Visibility::PrivateExternal => return true,\n+            Visibility::Restricted(module) => module,\n+        };\n+\n+        self.is_accessible_from(vis_restriction, map)\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n pub struct Method<'tcx> {\n     pub name: Name,\n     pub generics: Generics<'tcx>,\n     pub predicates: GenericPredicates<'tcx>,\n     pub fty: BareFnTy<'tcx>,\n     pub explicit_self: ExplicitSelfCategory,\n-    pub vis: hir::Visibility,\n+    pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n@@ -292,7 +342,7 @@ impl<'tcx> Method<'tcx> {\n                predicates: GenericPredicates<'tcx>,\n                fty: BareFnTy<'tcx>,\n                explicit_self: ExplicitSelfCategory,\n-               vis: hir::Visibility,\n+               vis: Visibility,\n                defaultness: hir::Defaultness,\n                def_id: DefId,\n                container: ImplOrTraitItemContainer)\n@@ -336,7 +386,7 @@ impl<'tcx> Hash for Method<'tcx> {\n pub struct AssociatedConst<'tcx> {\n     pub name: Name,\n     pub ty: Ty<'tcx>,\n-    pub vis: hir::Visibility,\n+    pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n@@ -347,7 +397,7 @@ pub struct AssociatedConst<'tcx> {\n pub struct AssociatedType<'tcx> {\n     pub name: Name,\n     pub ty: Option<Ty<'tcx>>,\n-    pub vis: hir::Visibility,\n+    pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n@@ -1419,7 +1469,7 @@ pub struct FieldDefData<'tcx, 'container: 'tcx> {\n     /// are not real items, and don't have entries in tcache etc.\n     pub did: DefId,\n     pub name: Name,\n-    pub vis: hir::Visibility,\n+    pub vis: Visibility,\n     /// TyIVar is used here to allow for variance (see the doc at\n     /// AdtDefData).\n     ///\n@@ -1704,7 +1754,7 @@ impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n impl<'tcx, 'container> FieldDefData<'tcx, 'container> {\n     pub fn new(did: DefId,\n                name: Name,\n-               vis: hir::Visibility) -> Self {\n+               vis: Visibility) -> Self {\n         FieldDefData {\n             did: did,\n             name: name,"}, {"sha": "39a3837ae7f35ad0110933838c42a6cf1d4937ca", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -15,7 +15,7 @@ use ty;\n use ty::fast_reject;\n use ty::{Ty, TyCtxt, TraitRef};\n use std::borrow::{Borrow};\n-use std::cell::{Cell, Ref, RefCell};\n+use std::cell::{Cell, RefCell};\n use syntax::ast::Name;\n use hir;\n use util::nodemap::FnvHashMap;\n@@ -43,10 +43,17 @@ pub struct TraitDef<'tcx> {\n     /// for resolving `X::Foo` type markers.\n     pub associated_type_names: Vec<Name>,\n \n-    // Impls of this trait. To allow for quicker lookup, the impls are indexed\n-    // by a simplified version of their Self type: impls with a simplifiable\n-    // Self are stored in nonblanket_impls keyed by it, while all other impls\n-    // are stored in blanket_impls.\n+    // Impls of a trait. To allow for quicker lookup, the impls are indexed by a\n+    // simplified version of their `Self` type: impls with a simplifiable `Self`\n+    // are stored in `nonblanket_impls` keyed by it, while all other impls are\n+    // stored in `blanket_impls`.\n+    //\n+    // A similar division is used within `specialization_graph`, but the ones\n+    // here are (1) stored as a flat list for the trait and (2) populated prior\n+    // to -- and used while -- determining specialization order.\n+    //\n+    // FIXME: solve the reentrancy issues and remove these lists in favor of the\n+    // ones in `specialization_graph`.\n     //\n     // These lists are tracked by `DepNode::TraitImpls`; we don't use\n     // a DepTrackingMap but instead have the `TraitDef` insert the\n@@ -184,7 +191,7 @@ impl<'tcx> TraitDef<'tcx> {\n             // if the impl is non-local, it's placed directly into the\n             // specialization graph using parent information drawn from metadata.\n             self.specialization_graph.borrow_mut()\n-                .record_impl_from_cstore(parent_impl, impl_def_id)\n+                .record_impl_from_cstore(tcx, parent_impl, impl_def_id)\n         }\n     }\n \n@@ -261,14 +268,6 @@ impl<'tcx> TraitDef<'tcx> {\n             }\n         }\n     }\n-\n-    pub fn borrow_impl_lists<'s>(&'s self, tcx: &TyCtxt<'tcx>)\n-                                 -> (Ref<'s, Vec<DefId>>,\n-                                     Ref<'s, FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>>) {\n-        self.read_trait_impls(tcx);\n-        (self.blanket_impls.borrow(), self.nonblanket_impls.borrow())\n-    }\n-\n }\n \n bitflags! {"}, {"sha": "8e7be0e3a0f5e0d3fd5682de643f90a854c801af", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_deprecation(&cdata, def.index)\n     }\n \n-    fn visibility(&self, def: DefId) -> hir::Visibility {\n+    fn visibility(&self, def: DefId) -> ty::Visibility {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_visibility(&cdata, def.index)\n     }\n@@ -536,7 +536,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         let mut visible_parent_map = self.visible_parent_map.borrow_mut();\n         if !visible_parent_map.is_empty() { return visible_parent_map; }\n \n-        use rustc::hir;\n         use rustc::middle::cstore::{CrateStore, ChildItem};\n         use std::collections::vec_deque::VecDeque;\n         use std::collections::hash_map::Entry;\n@@ -552,7 +551,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n             let mut bfs_queue = &mut VecDeque::new();\n             let mut add_child = |bfs_queue: &mut VecDeque<_>, child: ChildItem, parent: DefId| {\n                 let child = match child.def {\n-                    DefLike::DlDef(def) if child.vis == hir::Public => def.def_id(),\n+                    DefLike::DlDef(def) if child.vis == ty::Visibility::Public => def.def_id(),\n                     _ => return,\n                 };\n "}, {"sha": "a0881f1153e39eec45eb4037852eb2115436b3cf", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -140,13 +140,13 @@ fn item_family(item: rbml::Doc) -> Family {\n     }\n }\n \n-fn item_visibility(item: rbml::Doc) -> hir::Visibility {\n+fn item_visibility(item: rbml::Doc) -> ty::Visibility {\n     match reader::maybe_get_doc(item, tag_items_data_item_visibility) {\n-        None => hir::Public,\n+        None => ty::Visibility::Public,\n         Some(visibility_doc) => {\n             match reader::doc_as_u8(visibility_doc) as char {\n-                'y' => hir::Public,\n-                'i' => hir::Inherited,\n+                'y' => ty::Visibility::Public,\n+                'i' => ty::Visibility::PrivateExternal,\n                 _ => bug!(\"unknown visibility character\")\n             }\n         }\n@@ -541,7 +541,7 @@ pub fn get_deprecation(cdata: Cmd, id: DefIndex) -> Option<attr::Deprecation> {\n     })\n }\n \n-pub fn get_visibility(cdata: Cmd, id: DefIndex) -> hir::Visibility {\n+pub fn get_visibility(cdata: Cmd, id: DefIndex) -> ty::Visibility {\n     item_visibility(cdata.lookup_item(id))\n }\n \n@@ -639,7 +639,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n                                      item_doc: rbml::Doc,\n                                      mut get_crate_data: G,\n                                      mut callback: F) where\n-    F: FnMut(DefLike, ast::Name, hir::Visibility),\n+    F: FnMut(DefLike, ast::Name, ty::Visibility),\n     G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     // Iterate over all children.\n@@ -723,7 +723,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n             let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n             // These items have a public visibility because they're part of\n             // a public re-export.\n-            callback(def_like, token::intern(name), hir::Public);\n+            callback(def_like, token::intern(name), ty::Visibility::Public);\n         }\n     }\n }\n@@ -734,7 +734,7 @@ pub fn each_child_of_item<F, G>(intr: Rc<IdentInterner>,\n                                id: DefIndex,\n                                get_crate_data: G,\n                                callback: F) where\n-    F: FnMut(DefLike, ast::Name, hir::Visibility),\n+    F: FnMut(DefLike, ast::Name, ty::Visibility),\n     G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     // Find the item.\n@@ -755,7 +755,7 @@ pub fn each_top_level_item_of_crate<F, G>(intr: Rc<IdentInterner>,\n                                           cdata: Cmd,\n                                           get_crate_data: G,\n                                           callback: F) where\n-    F: FnMut(DefLike, ast::Name, hir::Visibility),\n+    F: FnMut(DefLike, ast::Name, ty::Visibility),\n     G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     let root_doc = rbml::Doc::new(cdata.data());\n@@ -1138,11 +1138,11 @@ pub fn get_struct_field_attrs(cdata: Cmd) -> FnvHashMap<DefId, Vec<ast::Attribut\n     }).collect()\n }\n \n-fn struct_field_family_to_visibility(family: Family) -> hir::Visibility {\n+fn struct_field_family_to_visibility(family: Family) -> ty::Visibility {\n     match family {\n-      PublicField => hir::Public,\n-      InheritedField => hir::Inherited,\n-      _ => bug!()\n+        PublicField => ty::Visibility::Public,\n+        InheritedField => ty::Visibility::PrivateExternal,\n+        _ => bug!()\n     }\n }\n "}, {"sha": "69f61cf97c0b271387ce18fac7eef9d84f23e2c0", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -249,7 +249,7 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                       rbml_w: &mut Encoder,\n                                       did: DefId,\n-                                      vis: hir::Visibility,\n+                                      vis: &hir::Visibility,\n                                       index: &mut CrateIndex<'tcx>) {\n     debug!(\"encode_enum_variant_info(did={:?})\", did);\n     let repr_hints = ecx.tcx.lookup_repr_hints(did);\n@@ -355,7 +355,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                        attrs: &[ast::Attribute],\n                        id: NodeId,\n                        name: Name,\n-                       vis: hir::Visibility) {\n+                       vis: &hir::Visibility) {\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id_and_key(ecx, rbml_w, ecx.tcx.map.local_def_id(id));\n     encode_family(rbml_w, 'm');\n@@ -383,7 +383,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     encode_deprecation(rbml_w, depr);\n \n     // Encode the reexports of this module, if this module is public.\n-    if vis == hir::Public {\n+    if *vis == hir::Public {\n         debug!(\"(encoding info for module) encoding reexports for {}\", id);\n         encode_reexports(ecx, rbml_w, id);\n     }\n@@ -393,21 +393,31 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n }\n \n fn encode_struct_field_family(rbml_w: &mut Encoder,\n-                              visibility: hir::Visibility) {\n-    encode_family(rbml_w, match visibility {\n-        hir::Public => 'g',\n-        hir::Inherited => 'N'\n-    });\n+                              visibility: ty::Visibility) {\n+    encode_family(rbml_w, if visibility.is_public() { 'g' } else { 'N' });\n }\n \n-fn encode_visibility(rbml_w: &mut Encoder, visibility: hir::Visibility) {\n-    let ch = match visibility {\n-        hir::Public => 'y',\n-        hir::Inherited => 'i',\n-    };\n+fn encode_visibility<T: HasVisibility>(rbml_w: &mut Encoder, visibility: T) {\n+    let ch = if visibility.is_public() { 'y' } else { 'i' };\n     rbml_w.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n }\n \n+trait HasVisibility: Sized {\n+    fn is_public(self) -> bool;\n+}\n+\n+impl<'a> HasVisibility for &'a hir::Visibility {\n+    fn is_public(self) -> bool {\n+        *self == hir::Public\n+    }\n+}\n+\n+impl HasVisibility for ty::Visibility {\n+    fn is_public(self) -> bool {\n+        self == ty::Visibility::Public\n+    }\n+}\n+\n fn encode_constness(rbml_w: &mut Encoder, constness: hir::Constness) {\n     rbml_w.start_tag(tag_items_data_item_constness);\n     let ch = match constness {\n@@ -861,7 +871,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     debug!(\"encoding info for item at {}\",\n            tcx.sess.codemap().span_to_string(item.span));\n \n-    let vis = item.vis;\n+    let vis = &item.vis;\n     let def_id = ecx.tcx.map.local_def_id(item.id);\n     let stab = stability::lookup_stability(tcx, ecx.tcx.map.local_def_id(item.id));\n     let depr = stability::lookup_deprecation(tcx, ecx.tcx.map.local_def_id(item.id));\n@@ -932,7 +942,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                             &item.attrs,\n                             item.id,\n                             item.name,\n-                            item.vis);\n+                            &item.vis);\n       }\n       hir::ItemForeignMod(ref fm) => {\n         index.record(def_id, rbml_w);\n@@ -1336,7 +1346,7 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     index.record(def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id_and_key(ecx, rbml_w, def_id);\n-    encode_visibility(rbml_w, nitem.vis);\n+    encode_visibility(rbml_w, &nitem.vis);\n     match nitem.node {\n       hir::ForeignItemFn(ref fndecl, _) => {\n         encode_family(rbml_w, FN_FAMILY);\n@@ -1443,7 +1453,7 @@ fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                         &[],\n                         CRATE_NODE_ID,\n                         syntax::parse::token::intern(&ecx.link_meta.crate_name),\n-                        hir::Public);\n+                        &hir::Public);\n \n     krate.visit_all_items(&mut EncodeVisitor {\n         index: &mut index,"}, {"sha": "a6ce4cc3ee41a443997e7cf8bf2e3823d63bf351", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 119, "deletions": 114, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -382,26 +382,18 @@ struct PrivacyVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n-    fn item_is_visible(&self, did: DefId) -> bool {\n-        let visibility = match self.tcx.map.as_local_node_id(did) {\n-            Some(node_id) => self.tcx.map.expect_item(node_id).vis,\n-            None => self.tcx.sess.cstore.visibility(did),\n-        };\n-        visibility == hir::Public || self.private_accessible(did)\n-    }\n-\n-    /// True if `did` is private-accessible\n-    fn private_accessible(&self, did: DefId) -> bool {\n+    fn item_is_accessible(&self, did: DefId) -> bool {\n         match self.tcx.map.as_local_node_id(did) {\n-            Some(node_id) => self.tcx.map.private_item_is_visible_from(node_id, self.curitem),\n-            None => false,\n-        }\n+            Some(node_id) =>\n+                ty::Visibility::from_hir(&self.tcx.map.expect_item(node_id).vis, node_id, self.tcx),\n+            None => self.tcx.sess.cstore.visibility(did),\n+        }.is_accessible_from(self.curitem, &self.tcx.map)\n     }\n \n     // Checks that a field is in scope.\n     fn check_field(&mut self, span: Span, def: ty::AdtDef<'tcx>, field: ty::FieldDef<'tcx>) {\n         if def.adt_kind() == ty::AdtKind::Struct &&\n-                field.vis != hir::Public && !self.private_accessible(def.did) {\n+           !field.vis.is_accessible_from(self.curitem, &self.tcx.map) {\n             span_err!(self.tcx.sess, span, E0451, \"field `{}` of struct `{}` is private\",\n                       field.name, self.tcx.item_path_str(def.did));\n         }\n@@ -412,7 +404,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         match self.tcx.impl_or_trait_item(method_def_id).container() {\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n-            ty::TraitContainer(trait_def_id) if !self.item_is_visible(trait_def_id) => {\n+            ty::TraitContainer(trait_def_id) if !self.item_is_accessible(trait_def_id) => {\n                 let msg = format!(\"source trait `{}` is private\",\n                                   self.tcx.item_path_str(trait_def_id));\n                 self.tcx.sess.span_err(span, &msg);\n@@ -464,7 +456,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         _ => expr_ty\n                     }.ty_adt_def().unwrap();\n                     let any_priv = def.struct_variant().fields.iter().any(|f| {\n-                        f.vis != hir::Public && !self.private_accessible(def.did)\n+                        !f.vis.is_accessible_from(self.curitem, &self.tcx.map)\n                     });\n                     if any_priv {\n                         span_err!(self.tcx.sess, expr.span, E0450,\n@@ -548,8 +540,8 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n     /// Such qualifiers can be set by syntax extensions even if the parser doesn't allow them,\n     /// so we check things like variant fields too.\n     fn check_sane_privacy(&self, item: &hir::Item) {\n-        let check_inherited = |sp, vis, note: &str| {\n-            if vis != hir::Inherited {\n+        let check_inherited = |sp, vis: &hir::Visibility, note: &str| {\n+            if *vis != hir::Inherited {\n                 let mut err = struct_span_err!(self.tcx.sess, sp, E0449,\n                                                \"unnecessary visibility qualifier\");\n                 if !note.is_empty() {\n@@ -561,29 +553,29 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n \n         match item.node {\n             hir::ItemImpl(_, _, _, Some(..), _, ref impl_items) => {\n-                check_inherited(item.span, item.vis,\n+                check_inherited(item.span, &item.vis,\n                                 \"visibility qualifiers have no effect on trait impls\");\n                 for impl_item in impl_items {\n-                    check_inherited(impl_item.span, impl_item.vis,\n+                    check_inherited(impl_item.span, &impl_item.vis,\n                                     \"visibility qualifiers have no effect on trait impl items\");\n                 }\n             }\n             hir::ItemImpl(_, _, _, None, _, _) => {\n-                check_inherited(item.span, item.vis,\n+                check_inherited(item.span, &item.vis,\n                                 \"place qualifiers on individual methods instead\");\n             }\n             hir::ItemDefaultImpl(..) => {\n-                check_inherited(item.span, item.vis,\n+                check_inherited(item.span, &item.vis,\n                                 \"visibility qualifiers have no effect on trait impls\");\n             }\n             hir::ItemForeignMod(..) => {\n-                check_inherited(item.span, item.vis,\n+                check_inherited(item.span, &item.vis,\n                                 \"place qualifiers on individual functions instead\");\n             }\n             hir::ItemEnum(ref def, _) => {\n                 for variant in &def.variants {\n                     for field in variant.node.data.fields() {\n-                        check_inherited(field.span, field.vis,\n+                        check_inherited(field.span, &field.vis,\n                                         \"visibility qualifiers have no effect on variant fields\");\n                     }\n                 }\n@@ -659,8 +651,8 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn item_is_public(&self, id: &ast::NodeId, vis: hir::Visibility) -> bool {\n-        self.access_levels.is_reachable(*id) || vis == hir::Public\n+    fn item_is_public(&self, id: &ast::NodeId, vis: &hir::Visibility) -> bool {\n+        self.access_levels.is_reachable(*id) || *vis == hir::Public\n     }\n }\n \n@@ -789,7 +781,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                                 match impl_item.node {\n                                     hir::ImplItemKind::Const(..) |\n                                     hir::ImplItemKind::Method(..)\n-                                        if self.item_is_public(&impl_item.id, impl_item.vis) =>\n+                                        if self.item_is_public(&impl_item.id, &impl_item.vis) =>\n                                     {\n                                         intravisit::walk_impl_item(self, impl_item)\n                                     }\n@@ -831,14 +823,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                     for impl_item in impl_items {\n                         match impl_item.node {\n                             hir::ImplItemKind::Const(..) => {\n-                                if self.item_is_public(&impl_item.id, impl_item.vis) {\n+                                if self.item_is_public(&impl_item.id, &impl_item.vis) {\n                                     found_pub_static = true;\n                                     intravisit::walk_impl_item(self, impl_item);\n                                 }\n                             }\n                             hir::ImplItemKind::Method(ref sig, _) => {\n                                 if sig.explicit_self.node == hir::SelfStatic &&\n-                                      self.item_is_public(&impl_item.id, impl_item.vis) {\n+                                      self.item_is_public(&impl_item.id, &impl_item.vis) {\n                                     found_pub_static = true;\n                                     intravisit::walk_impl_item(self, impl_item);\n                                 }\n@@ -858,7 +850,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n             hir::ItemTy(..) => return,\n \n             // not at all public, so we don't care\n-            _ if !self.item_is_public(&item.id, item.vis) => {\n+            _ if !self.item_is_public(&item.id, &item.vis) => {\n                 return;\n             }\n \n@@ -944,27 +936,41 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n \n struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n     tcx: &'a TyCtxt<'tcx>,\n-    // Do not report an error when a private type is found\n-    is_quiet: bool,\n-    // Is private component found?\n-    is_public: bool,\n+    /// The visitor checks that each component type is at least this visible\n+    required_visibility: ty::Visibility,\n+    /// The visibility of the least visible component that has been visited\n+    min_visibility: ty::Visibility,\n     old_error_set: &'a NodeSet,\n }\n \n impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n-    // Check if the type alias contain private types when substituted\n-    fn is_public_type_alias(&self, item: &hir::Item, path: &hir::Path) -> bool {\n+    fn new(tcx: &'a TyCtxt<'tcx>, old_error_set: &'a NodeSet) -> Self {\n+        SearchInterfaceForPrivateItemsVisitor {\n+            tcx: tcx,\n+            min_visibility: ty::Visibility::Public,\n+            required_visibility: ty::Visibility::PrivateExternal,\n+            old_error_set: old_error_set,\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n+    // Return the visibility of the type alias's least visible component type when substituted\n+    fn substituted_alias_visibility(&self, item: &hir::Item, path: &hir::Path)\n+                                    -> Option<ty::Visibility> {\n         // We substitute type aliases only when determining impl publicity\n         // FIXME: This will probably change and all type aliases will be substituted,\n         // requires an amendment to RFC 136.\n-        if !self.is_quiet {\n-            return false\n+        if self.required_visibility != ty::Visibility::PrivateExternal {\n+            return None;\n         }\n         // Type alias is considered public if the aliased type is\n         // public, even if the type alias itself is private. So, something\n         // like `type A = u8; pub fn f() -> A {...}` doesn't cause an error.\n         if let hir::ItemTy(ref ty, ref generics) = item.node {\n-            let mut check = SearchInterfaceForPrivateItemsVisitor { is_public: true, ..*self };\n+            let mut check = SearchInterfaceForPrivateItemsVisitor {\n+                min_visibility: ty::Visibility::Public, ..*self\n+            };\n             check.visit_ty(ty);\n             // If a private type alias with default type parameters is used in public\n             // interface we must ensure, that the defaults are public if they are actually used.\n@@ -978,26 +984,23 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n                     check.visit_ty(default_ty);\n                 }\n             }\n-            check.is_public\n+            Some(check.min_visibility)\n         } else {\n-            false\n+            None\n         }\n     }\n }\n \n impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n-        if self.is_quiet && !self.is_public {\n-            // We are in quiet mode and a private type is already found, no need to proceed\n-            return\n-        }\n         if let hir::TyPath(_, ref path) = ty.node {\n             let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n             match def {\n                 Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n                     // Public\n                 }\n-                Def::AssociatedTy(..) if self.is_quiet => {\n+                Def::AssociatedTy(..)\n+                    if self.required_visibility == ty::Visibility::PrivateExternal => {\n                     // Conservatively approximate the whole type alias as public without\n                     // recursing into its components when determining impl publicity.\n                     // For example, `impl <Type as Trait>::Alias {...}` may be a public impl\n@@ -1011,21 +1014,24 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n                     // Non-local means public (private items can't leave their crate, modulo bugs)\n                     if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n                         let item = self.tcx.map.expect_item(node_id);\n-                        if item.vis != hir::Public && !self.is_public_type_alias(item, path) {\n-                            if !self.is_quiet {\n-                                if self.old_error_set.contains(&ty.id) {\n-                                    span_err!(self.tcx.sess, ty.span, E0446,\n-                                              \"private type in public interface\");\n-                                } else {\n-                                    self.tcx.sess.add_lint (\n-                                        lint::builtin::PRIVATE_IN_PUBLIC,\n-                                        node_id,\n-                                        ty.span,\n-                                        format!(\"private type in public interface\"),\n-                                    );\n-                                }\n+                        let vis = match self.substituted_alias_visibility(item, path) {\n+                            Some(vis) => vis,\n+                            None => ty::Visibility::from_hir(&item.vis, node_id, &self.tcx),\n+                        };\n+\n+                        if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n+                            self.min_visibility = vis;\n+                        }\n+                        if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n+                            if self.old_error_set.contains(&ty.id) {\n+                                span_err!(self.tcx.sess, ty.span, E0446,\n+                                          \"private type in public interface\");\n+                            } else {\n+                                self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                                       node_id,\n+                                                       ty.span,\n+                                                       format!(\"private type in public interface\"));\n                             }\n-                            self.is_public = false;\n                         }\n                     }\n                 }\n@@ -1037,28 +1043,26 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n     }\n \n     fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n-        if self.is_quiet && !self.is_public {\n-            // We are in quiet mode and a private type is already found, no need to proceed\n-            return\n-        }\n         // Non-local means public (private items can't leave their crate, modulo bugs)\n         let def_id = self.tcx.trait_ref_to_def_id(trait_ref);\n         if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n             let item = self.tcx.map.expect_item(node_id);\n-            if item.vis != hir::Public {\n-                if !self.is_quiet {\n-                    if self.old_error_set.contains(&trait_ref.ref_id) {\n-                        span_err!(self.tcx.sess, trait_ref.path.span, E0445,\n-                                  \"private trait in public interface\");\n-                    } else {\n-                        self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                               node_id,\n-                                               trait_ref.path.span,\n-                                               \"private trait in public interface (error E0445)\"\n-                                                    .to_string());\n-                    }\n+            let vis = ty::Visibility::from_hir(&item.vis, node_id, &self.tcx);\n+\n+            if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n+                self.min_visibility = vis;\n+            }\n+            if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n+                if self.old_error_set.contains(&trait_ref.ref_id) {\n+                    span_err!(self.tcx.sess, trait_ref.path.span, E0445,\n+                              \"private trait in public interface\");\n+                } else {\n+                    self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                           node_id,\n+                                           trait_ref.path.span,\n+                                           \"private trait in public interface (error E0445)\"\n+                                                .to_string());\n                 }\n-                self.is_public = false;\n             }\n         }\n \n@@ -1080,29 +1084,29 @@ struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     // A type is considered public if it doesn't contain any private components\n-    fn is_public_ty(&self, ty: &hir::Ty) -> bool {\n-        let mut check = SearchInterfaceForPrivateItemsVisitor {\n-            tcx: self.tcx, is_quiet: true, is_public: true, old_error_set: self.old_error_set\n-        };\n+    fn ty_visibility(&self, ty: &hir::Ty) -> ty::Visibility {\n+        let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n         check.visit_ty(ty);\n-        check.is_public\n+        check.min_visibility\n     }\n \n     // A trait reference is considered public if it doesn't contain any private components\n-    fn is_public_trait_ref(&self, trait_ref: &hir::TraitRef) -> bool {\n-        let mut check = SearchInterfaceForPrivateItemsVisitor {\n-            tcx: self.tcx, is_quiet: true, is_public: true, old_error_set: self.old_error_set\n-        };\n+    fn trait_ref_visibility(&self, trait_ref: &hir::TraitRef) -> ty::Visibility {\n+        let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n         check.visit_trait_ref(trait_ref);\n-        check.is_public\n+        check.min_visibility\n     }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let mut check = SearchInterfaceForPrivateItemsVisitor {\n-            tcx: self.tcx, is_quiet: false, is_public: true, old_error_set: self.old_error_set\n+        let min = |vis1: ty::Visibility, vis2| {\n+            if vis1.is_at_least(vis2, &self.tcx.map) { vis2 } else { vis1 }\n         };\n+\n+        let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n+        let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, &self.tcx);\n+\n         match item.node {\n             // Crates are always public\n             hir::ItemExternCrate(..) => {}\n@@ -1113,51 +1117,52 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n             // Subitems of these items have inherited publicity\n             hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n             hir::ItemEnum(..) | hir::ItemTrait(..) | hir::ItemTy(..) => {\n-                if item.vis == hir::Public {\n-                    check.visit_item(item);\n-                }\n+                check.required_visibility = item_visibility;\n+                check.visit_item(item);\n             }\n             // Subitems of foreign modules have their own publicity\n             hir::ItemForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n-                    if foreign_item.vis == hir::Public {\n-                        check.visit_foreign_item(foreign_item);\n-                    }\n+                    check.required_visibility =\n+                        ty::Visibility::from_hir(&foreign_item.vis, item.id, &self.tcx);\n+                    check.visit_foreign_item(foreign_item);\n                 }\n             }\n             // Subitems of structs have their own publicity\n             hir::ItemStruct(ref struct_def, ref generics) => {\n-                if item.vis == hir::Public {\n-                    check.visit_generics(generics);\n-                    for field in struct_def.fields() {\n-                        if field.vis == hir::Public {\n-                            check.visit_struct_field(field);\n-                        }\n-                    }\n+                check.required_visibility = item_visibility;\n+                check.visit_generics(generics);\n+\n+                for field in struct_def.fields() {\n+                    let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, &self.tcx);\n+                    check.required_visibility = min(item_visibility, field_visibility);\n+                    check.visit_struct_field(field);\n                 }\n             }\n             // The interface is empty\n             hir::ItemDefaultImpl(..) => {}\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity\n             hir::ItemImpl(_, _, ref generics, None, ref ty, ref impl_items) => {\n-                if self.is_public_ty(ty) {\n-                    check.visit_generics(generics);\n-                    for impl_item in impl_items {\n-                        if impl_item.vis == hir::Public {\n-                            check.visit_impl_item(impl_item);\n-                        }\n-                    }\n+                let ty_vis = self.ty_visibility(ty);\n+                check.required_visibility = ty_vis;\n+                check.visit_generics(generics);\n+\n+                for impl_item in impl_items {\n+                    let impl_item_vis =\n+                        ty::Visibility::from_hir(&impl_item.vis, item.id, &self.tcx);\n+                    check.required_visibility = min(impl_item_vis, ty_vis);\n+                    check.visit_impl_item(impl_item);\n                 }\n             }\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity\n             hir::ItemImpl(_, _, ref generics, Some(ref trait_ref), ref ty, ref impl_items) => {\n-                if self.is_public_ty(ty) && self.is_public_trait_ref(trait_ref) {\n-                    check.visit_generics(generics);\n-                    for impl_item in impl_items {\n-                        check.visit_impl_item(impl_item);\n-                    }\n+                let vis = min(self.ty_visibility(ty), self.trait_ref_visibility(trait_ref));\n+                check.required_visibility = vis;\n+                check.visit_generics(generics);\n+                for impl_item in impl_items {\n+                    check.visit_impl_item(impl_item);\n                 }\n             }\n         }"}, {"sha": "003450cd6fd7984b81d3e1add6f333175828b371", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -26,7 +26,7 @@ use rustc::middle::cstore::{CrateStore, ChildItem, DlDef};\n use rustc::lint;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::ty::VariantKind;\n+use rustc::ty::{self, VariantKind};\n \n use syntax::ast::Name;\n use syntax::attr::AttrMetaMethods;\n@@ -434,7 +434,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         }\n \n         let name = xcdef.name;\n-        let is_public = xcdef.vis == hir::Public || parent.is_trait();\n+        let is_public = xcdef.vis == ty::Visibility::Public || parent.is_trait();\n \n         let mut modifiers = DefModifiers::empty();\n         if is_public {"}, {"sha": "5f4244caa629c508e619beee9ee3ad4dedddd95c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 69, "deletions": 66, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -1714,9 +1714,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             match self.resolve_crate_relative_path(prefix.span,\n                                                                    &prefix.segments,\n                                                                    TypeNS) {\n-                                Some(def) =>\n+                                Ok(def) =>\n                                     self.record_def(item.id, PathResolution::new(def, 0)),\n-                                None => {\n+                                Err(true) => self.record_def(item.id, err_path_resolution()),\n+                                Err(false) => {\n                                     resolve_error(self,\n                                                   prefix.span,\n                                                   ResolutionError::FailedToResolve(\n@@ -1835,7 +1836,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                trait_path: &Path,\n                                path_depth: usize)\n                                -> Result<PathResolution, ()> {\n-        if let Some(path_res) = self.resolve_path(id, trait_path, path_depth, TypeNS) {\n+        self.resolve_path(id, trait_path, path_depth, TypeNS).and_then(|path_res| {\n             if let Def::Trait(_) = path_res.base_def {\n                 debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n                 Ok(path_res)\n@@ -1855,9 +1856,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n                 err.emit();\n-                Err(())\n+                Err(true)\n             }\n-        } else {\n+        }).map_err(|error_reported| {\n+            if error_reported { return }\n \n             // find possible candidates\n             let trait_name = trait_path.segments.last().unwrap().identifier.name;\n@@ -1880,8 +1882,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 );\n \n             resolve_error(self, trait_path.span, error);\n-            Err(())\n-        }\n+        })\n     }\n \n     fn resolve_generics(&mut self, generics: &Generics) {\n@@ -1890,15 +1891,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 &hir::WherePredicate::BoundPredicate(_) |\n                 &hir::WherePredicate::RegionPredicate(_) => {}\n                 &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n-                    let path_res = self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS);\n-                    if let Some(PathResolution { base_def: Def::TyParam(..), .. }) = path_res {\n-                        self.record_def(eq_pred.id, path_res.unwrap());\n-                    } else {\n-                        resolve_error(self,\n-                                      eq_pred.span,\n-                                      ResolutionError::UndeclaredAssociatedType);\n+                    self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS).and_then(|path_res| {\n+                        if let PathResolution { base_def: Def::TyParam(..), .. } = path_res {\n+                            Ok(self.record_def(eq_pred.id, path_res))\n+                        } else {\n+                            Err(false)\n+                        }\n+                    }).map_err(|error_reported| {\n                         self.record_def(eq_pred.id, err_path_resolution());\n-                    }\n+                        if error_reported { return }\n+                        let error_variant = ResolutionError::UndeclaredAssociatedType;\n+                        resolve_error(self, eq_pred.span, error_variant);\n+                    }).unwrap_or(());\n                 }\n             }\n         }\n@@ -2168,21 +2172,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 // This is a path in the type namespace. Walk through scopes\n                 // looking for it.\n-                match resolution {\n-                    Some(def) => {\n-                        // Write the result into the def map.\n-                        debug!(\"(resolving type) writing resolution for `{}` (id {}) = {:?}\",\n-                               path_names_to_string(path, 0),\n-                               ty.id,\n-                               def);\n-                        self.record_def(ty.id, def);\n-                    }\n-                    None => {\n-                        self.record_def(ty.id, err_path_resolution());\n-\n-                        // Keep reporting some errors even if they're ignored above.\n-                        self.resolve_path(ty.id, path, 0, TypeNS);\n+                if let Some(def) = resolution {\n+                    // Write the result into the def map.\n+                    debug!(\"(resolving type) writing resolution for `{}` (id {}) = {:?}\",\n+                           path_names_to_string(path, 0), ty.id, def);\n+                    self.record_def(ty.id, def);\n+                } else {\n+                    self.record_def(ty.id, err_path_resolution());\n \n+                    // Keep reporting some errors even if they're ignored above.\n+                    if let Err(true) = self.resolve_path(ty.id, path, 0, TypeNS) {\n+                        // `resolve_path` already reported the error\n+                    } else {\n                         let kind = if maybe_qself.is_some() {\n                             \"associated type\"\n                         } else {\n@@ -2481,11 +2482,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 PatKind::Struct(ref path, _, _) => {\n                     match self.resolve_path(pat_id, path, 0, TypeNS) {\n-                        Some(definition) => {\n+                        Ok(definition) => {\n                             self.record_def(pattern.id, definition);\n                         }\n-                        result => {\n-                            debug!(\"(resolving pattern) didn't find struct def: {:?}\", result);\n+                        Err(true) => self.record_def(pattern.id, err_path_resolution()),\n+                        Err(false) => {\n                             resolve_error(\n                                 self,\n                                 path.span,\n@@ -2552,14 +2553,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let mut resolution = self.with_no_errors(|this| {\n-            this.resolve_path(id, path, 0, namespace)\n+            this.resolve_path(id, path, 0, namespace).ok()\n         });\n         for depth in 1..max_assoc_types {\n             if resolution.is_some() {\n                 break;\n             }\n             self.with_no_errors(|this| {\n-                resolution = this.resolve_path(id, path, depth, TypeNS);\n+                resolution = this.resolve_path(id, path, depth, TypeNS).ok();\n             });\n         }\n         if let Some(Def::Mod(_)) = resolution.map(|r| r.base_def) {\n@@ -2572,7 +2573,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Skips `path_depth` trailing segments, which is also reflected in the\n     /// returned value. See `hir::def::PathResolution` for more info.\n     fn resolve_path(&mut self, id: NodeId, path: &Path, path_depth: usize, namespace: Namespace)\n-                    -> Option<PathResolution> {\n+                    -> Result<PathResolution, bool /* true if an error was reported */ > {\n         let span = path.span;\n         let segments = &path.segments[..path.segments.len() - path_depth];\n \n@@ -2611,14 +2612,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             //\n             // Such behavior is required for backward compatibility.\n             // The same fallback is used when `a` resolves to nothing.\n-            let unqualified_def = resolve_identifier_with_fallback(self, true);\n-            return unqualified_def.and_then(|def| self.adjust_local_def(def, span)).map(mk_res);\n+            let def = resolve_identifier_with_fallback(self, true).ok_or(false);\n+            return def.and_then(|def| self.adjust_local_def(def, span).ok_or(true)).map(mk_res);\n         }\n \n         let unqualified_def = resolve_identifier_with_fallback(self, false);\n         let def = self.resolve_module_relative_path(span, segments, namespace);\n         match (def, unqualified_def) {\n-            (Some(d), Some(ref ud)) if d == ud.def => {\n+            (Ok(d), Some(ref ud)) if d == ud.def => {\n                 self.session\n                     .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n                               id,\n@@ -2739,7 +2740,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     span: Span,\n                                     segments: &[hir::PathSegment],\n                                     namespace: Namespace)\n-                                    -> Option<Def> {\n+                                    -> Result<Def, bool /* true if an error was reported */> {\n         let module_path = segments.split_last()\n                                   .unwrap()\n                                   .1\n@@ -2760,9 +2761,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n-                return None;\n+                return Err(true);\n             }\n-            Indeterminate => return None,\n+            Indeterminate => return Err(false),\n             Success(resulting_module) => {\n                 containing_module = resulting_module;\n             }\n@@ -2773,7 +2774,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         result.success().map(|binding| {\n             self.check_privacy(containing_module, name, binding, span);\n             binding.def().unwrap()\n-        })\n+        }).ok_or(false)\n     }\n \n     /// Invariant: This must be called only during main resolution, not during\n@@ -2782,7 +2783,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                    span: Span,\n                                    segments: &[hir::PathSegment],\n                                    namespace: Namespace)\n-                                   -> Option<Def> {\n+                                   -> Result<Def, bool /* true if an error was reported */> {\n         let module_path = segments.split_last()\n                                   .unwrap()\n                                   .1\n@@ -2808,10 +2809,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n-                return None;\n+                return Err(true);\n             }\n \n-            Indeterminate => return None,\n+            Indeterminate => return Err(false),\n \n             Success(resulting_module) => {\n                 containing_module = resulting_module;\n@@ -2823,7 +2824,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         result.success().map(|binding| {\n             self.check_privacy(containing_module, name, binding, span);\n             binding.def().unwrap()\n-        })\n+        }).ok_or(false)\n     }\n \n     fn with_no_errors<T, F>(&mut self, f: F) -> T\n@@ -3038,25 +3039,26 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     });\n \n                     self.record_def(expr.id, err_path_resolution());\n-                    match type_res.map(|r| r.base_def) {\n-                        Some(Def::Struct(..)) => {\n-                            let mut err = resolve_struct_error(self,\n-                                expr.span,\n-                                ResolutionError::StructVariantUsedAsFunction(&path_name));\n-\n-                            let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n-                                              path_name);\n-                            if self.emit_errors {\n-                                err.fileline_help(expr.span, &msg);\n-                            } else {\n-                                err.span_help(expr.span, &msg);\n-                            }\n-                            err.emit();\n-                        }\n-                        _ => {\n-                            // Keep reporting some errors even if they're ignored above.\n-                            self.resolve_path(expr.id, path, 0, ValueNS);\n \n+                    if let Ok(Def::Struct(..)) = type_res.map(|r| r.base_def) {\n+                        let error_variant =\n+                            ResolutionError::StructVariantUsedAsFunction(&path_name);\n+                        let mut err = resolve_struct_error(self, expr.span, error_variant);\n+\n+                        let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n+                                          path_name);\n+\n+                        if self.emit_errors {\n+                            err.fileline_help(expr.span, &msg);\n+                        } else {\n+                            err.span_help(expr.span, &msg);\n+                        }\n+                        err.emit();\n+                    } else {\n+                        // Keep reporting some errors even if they're ignored above.\n+                        if let Err(true) = self.resolve_path(expr.id, path, 0, ValueNS) {\n+                            // `resolve_path` already reported the error\n+                        } else {\n                             let mut method_scope = false;\n                             self.value_ribs.iter().rev().all(|rib| {\n                                 method_scope = match rib.kind {\n@@ -3130,8 +3132,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // check to ensure that the path is actually a structure; that\n                 // is checked later during typeck.\n                 match self.resolve_path(expr.id, path, 0, TypeNS) {\n-                    Some(definition) => self.record_def(expr.id, definition),\n-                    None => {\n+                    Ok(definition) => self.record_def(expr.id, definition),\n+                    Err(true) => self.record_def(expr.id, err_path_resolution()),\n+                    Err(false) => {\n                         debug!(\"(resolving expression) didn't find struct def\",);\n \n                         resolve_error(self,"}, {"sha": "31d95af4fbb9c4b416b25d031f4b9cf58fcc35cf", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -343,7 +343,7 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let def = pick.item.def();\n \n     if let probe::InherentImplPick = pick.kind {\n-        if pick.item.vis() != hir::Public && !fcx.private_item_is_visible(def.def_id()) {\n+        if !pick.item.vis().is_accessible_from(fcx.body_id, &fcx.tcx().map) {\n             let msg = format!(\"{} `{}` is private\", def.kind_name(), &method_name.as_str());\n             fcx.tcx().sess.span_err(span, &msg);\n         }"}, {"sha": "0ffbbfea84ef0c5c946e18ce335bf3b26212926e", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -412,7 +412,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             return self.record_static_candidate(ImplSource(impl_def_id));\n         }\n \n-        if item.vis() != hir::Public && !self.fcx.private_item_is_visible(item.def_id()) {\n+        if !item.vis().is_accessible_from(self.fcx.body_id, &self.tcx().map) {\n             self.private_candidate = Some(item.def());\n             return\n         }"}, {"sha": "45877d7099bbf70de70ed88ecbb0b4c3bc973ddb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -95,7 +95,7 @@ use rustc::traits::{self, report_fulfillment_errors, ProjectionMode};\n use rustc::ty::{GenericPredicates, TypeScheme};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n-use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt};\n+use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, Visibility};\n use rustc::ty::{MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::error::TypeError;\n@@ -125,8 +125,7 @@ use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use rustc::hir::intravisit::{self, Visitor};\n-use rustc::hir;\n-use rustc::hir::{Visibility, PatKind};\n+use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n use rustc_back::slice;\n use rustc_const_eval::eval_repeat_count;\n@@ -2055,13 +2054,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n         }\n     }\n-\n-    fn private_item_is_visible(&self, def_id: DefId) -> bool {\n-        match self.tcx().map.as_local_node_id(def_id) {\n-            Some(node_id) => self.tcx().map.private_item_is_visible_from(node_id, self.body_id),\n-            None => false, // Private items from other crates are never visible\n-        }\n-    }\n }\n \n impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n@@ -2967,7 +2959,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     debug!(\"struct named {:?}\",  base_t);\n                     if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n                         let field_ty = fcx.field_ty(expr.span, field, substs);\n-                        if field.vis == hir::Public || fcx.private_item_is_visible(base_def.did) {\n+                        if field.vis.is_accessible_from(fcx.body_id, &fcx.tcx().map) {\n                             return Some(field_ty);\n                         }\n                         private_candidate = Some((base_def.did, field_ty));\n@@ -3079,7 +3071,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 debug!(\"tuple struct named {:?}\",  base_t);\n                 if let Some(field) = base_def.struct_variant().fields.get(idx.node) {\n                     let field_ty = fcx.field_ty(expr.span, field, substs);\n-                    if field.vis == hir::Public || fcx.private_item_is_visible(base_def.did) {\n+                    if field.vis.is_accessible_from(fcx.body_id, &fcx.tcx().map) {\n                         return Some(field_ty);\n                     }\n                     private_candidate = Some((base_def.did, field_ty));"}, {"sha": "2e1a684684375714582094cfcf31023371eb8e6b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -532,7 +532,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             container: ImplOrTraitItemContainer,\n                             name: ast::Name,\n                             id: ast::NodeId,\n-                            vis: hir::Visibility,\n+                            vis: &hir::Visibility,\n                             sig: &hir::MethodSig,\n                             defaultness: hir::Defaultness,\n                             untransformed_rcvr_ty: Ty<'tcx>,\n@@ -555,7 +555,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     ty_generic_predicates,\n                                     fty,\n                                     explicit_self_category,\n-                                    vis,\n+                                    ty::Visibility::from_hir(vis, id, ccx.tcx),\n                                     defaultness,\n                                     def_id,\n                                     container);\n@@ -602,7 +602,7 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                       container: ImplOrTraitItemContainer,\n                                       name: ast::Name,\n                                       id: ast::NodeId,\n-                                      vis: hir::Visibility,\n+                                      vis: &hir::Visibility,\n                                       defaultness: hir::Defaultness,\n                                       ty: ty::Ty<'tcx>,\n                                       has_value: bool)\n@@ -614,7 +614,7 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let associated_const = Rc::new(ty::AssociatedConst {\n         name: name,\n-        vis: vis,\n+        vis: ty::Visibility::from_hir(vis, id, ccx.tcx),\n         defaultness: defaultness,\n         def_id: ccx.tcx.map.local_def_id(id),\n         container: container,\n@@ -629,13 +629,13 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      container: ImplOrTraitItemContainer,\n                                      name: ast::Name,\n                                      id: ast::NodeId,\n-                                     vis: hir::Visibility,\n+                                     vis: &hir::Visibility,\n                                      defaultness: hir::Defaultness,\n                                      ty: Option<Ty<'tcx>>)\n {\n     let associated_type = Rc::new(ty::AssociatedType {\n         name: name,\n-        vis: vis,\n+        vis: ty::Visibility::from_hir(vis, id, ccx.tcx),\n         defaultness: defaultness,\n         ty: ty,\n         def_id: ccx.tcx.map.local_def_id(id),\n@@ -738,17 +738,6 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             tcx.predicates.borrow_mut().insert(def_id, ty_predicates.clone());\n \n \n-            // If there is a trait reference, treat the methods as always public.\n-            // This is to work around some incorrect behavior in privacy checking:\n-            // when the method belongs to a trait, it should acquire the privacy\n-            // from the trait, not the impl. Forcing the visibility to be public\n-            // makes things sorta work.\n-            let parent_visibility = if opt_trait_ref.is_some() {\n-                hir::Public\n-            } else {\n-                it.vis\n-            };\n-\n             // Convert all the associated consts.\n             // Also, check if there are any duplicate associated items\n             let mut seen_type_items = FnvHashSet();\n@@ -771,9 +760,12 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                                generics: ty_generics.clone(),\n                                                ty: ty,\n                                            });\n+                    // Trait-associated constants are always public.\n+                    let public = &hir::Public;\n+                    let visibility = if opt_trait_ref.is_some() { public } else { &impl_item.vis };\n                     convert_associated_const(ccx, ImplContainer(def_id),\n                                              impl_item.name, impl_item.id,\n-                                             impl_item.vis.inherit_from(parent_visibility),\n+                                             visibility,\n                                              impl_item.defaultness,\n                                              ty, true /* has_value */);\n                 }\n@@ -790,18 +782,16 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n \n                     convert_associated_type(ccx, ImplContainer(def_id),\n-                                            impl_item.name, impl_item.id, impl_item.vis,\n+                                            impl_item.name, impl_item.id, &impl_item.vis,\n                                             impl_item.defaultness, Some(typ));\n                 }\n             }\n \n             for impl_item in impl_items {\n                 if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n-                    // if the method specifies a visibility, use that, otherwise\n-                    // inherit the visibility from the impl (so `foo` in `pub impl\n-                    // { fn foo(); }` is public, but private in `impl { fn\n-                    // foo(); }`).\n-                    let method_vis = impl_item.vis.inherit_from(parent_visibility);\n+                    // Trait methods are always public.\n+                    let public = &hir::Public;\n+                    let method_vis = if opt_trait_ref.is_some() { public } else { &impl_item.vis };\n \n                     convert_method(ccx, ImplContainer(def_id),\n                                    impl_item.name, impl_item.id, method_vis,\n@@ -839,7 +829,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                              container,\n                                              trait_item.name,\n                                              trait_item.id,\n-                                             hir::Public,\n+                                             &hir::Public,\n                                              hir::Defaultness::Default,\n                                              ty,\n                                              default.is_some())\n@@ -857,7 +847,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                             container,\n                                             trait_item.name,\n                                             trait_item.id,\n-                                            hir::Public,\n+                                            &hir::Public,\n                                             hir::Defaultness::Default,\n                                             typ);\n                 }\n@@ -870,7 +860,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                    container,\n                                    trait_item.name,\n                                    trait_item.id,\n-                                   hir::Inherited,\n+                                   &hir::Inherited,\n                                    sig,\n                                    hir::Defaultness::Default,\n                                    tcx.mk_self_type(),\n@@ -987,6 +977,7 @@ fn convert_struct_variant<'tcx>(tcx: &TyCtxt<'tcx>,\n                                 disr_val: ty::Disr,\n                                 def: &hir::VariantData) -> ty::VariantDefData<'tcx, 'tcx> {\n     let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n+    let node_id = tcx.map.as_local_node_id(did).unwrap();\n     let fields = def.fields().iter().map(|f| {\n         let fid = tcx.map.local_def_id(f.id);\n         let dup_span = seen_fields.get(&f.name).cloned();\n@@ -1000,7 +991,7 @@ fn convert_struct_variant<'tcx>(tcx: &TyCtxt<'tcx>,\n             seen_fields.insert(f.name, f.span);\n         }\n \n-        ty::FieldDefData::new(fid, f.name, f.vis)\n+        ty::FieldDefData::new(fid, f.name, ty::Visibility::from_hir(&f.vis, node_id, tcx))\n     }).collect();\n     ty::VariantDefData {\n         did: did,"}, {"sha": "850975498269bc4a31382f06455a15ed547f138c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -361,7 +361,7 @@ pub fn build_impl(cx: &DocContext,\n                 })\n             }\n             ty::MethodTraitItem(method) => {\n-                if method.vis != hir::Public && associated_trait.is_none() {\n+                if method.vis != ty::Visibility::Public && associated_trait.is_none() {\n                     return None\n                 }\n                 let mut item = method.clean(cx);\n@@ -471,7 +471,7 @@ fn build_module(cx: &DocContext, tcx: &TyCtxt,\n                 cstore::DlDef(Def::ForeignMod(did)) => {\n                     fill_in(cx, tcx, did, items);\n                 }\n-                cstore::DlDef(def) if item.vis == hir::Public => {\n+                cstore::DlDef(def) if item.vis == ty::Visibility::Public => {\n                     if !visited.insert(def) { continue }\n                     if let Some(i) = try_inline_def(cx, tcx, def) {\n                         items.extend(i)"}, {"sha": "673aa17ecd1455b89c4ae2f2851ef26727447e9a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -1754,7 +1754,7 @@ impl Clean<Item> for hir::StructField {\n             name: Some(self.name).clean(cx),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            visibility: Some(self.vis),\n+            visibility: self.vis.clean(cx),\n             stability: get_stability(cx, cx.map.local_def_id(self.id)),\n             deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n             def_id: cx.map.local_def_id(self.id),\n@@ -1771,7 +1771,7 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n             name: Some(self.name).clean(cx),\n             attrs: attr_map.get(&self.did).unwrap_or(&Vec::new()).clean(cx),\n             source: Span::empty(),\n-            visibility: Some(self.vis),\n+            visibility: self.vis.clean(cx),\n             stability: get_stability(cx, self.did),\n             deprecation: get_deprecation(cx, self.did),\n             def_id: self.did,\n@@ -1784,7 +1784,13 @@ pub type Visibility = hir::Visibility;\n \n impl Clean<Option<Visibility>> for hir::Visibility {\n     fn clean(&self, _: &DocContext) -> Option<Visibility> {\n-        Some(*self)\n+        Some(self.clone())\n+    }\n+}\n+\n+impl Clean<Option<Visibility>> for ty::Visibility {\n+    fn clean(&self, _: &DocContext) -> Option<Visibility> {\n+        Some(if *self == ty::Visibility::Public { hir::Public } else { hir::Inherited })\n     }\n }\n \n@@ -1902,7 +1908,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n                             source: Span::empty(),\n                             name: Some(field.name.clean(cx)),\n                             attrs: cx.tcx().get_attrs(field.did).clean(cx),\n-                            visibility: Some(field.vis),\n+                            visibility: field.vis.clean(cx),\n                             def_id: field.did,\n                             stability: get_stability(cx, field.did),\n                             deprecation: get_deprecation(cx, field.did),"}, {"sha": "ce20ad05acb0e05cc730d1b4d644227bd1f31f0c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -31,7 +31,7 @@ use html::render::{cache, CURRENT_LOCATION_KEY};\n /// Helper to render an optional visibility with a space after it (if the\n /// visibility is preset)\n #[derive(Copy, Clone)]\n-pub struct VisSpace(pub Option<hir::Visibility>);\n+pub struct VisSpace<'a>(pub &'a Option<hir::Visibility>);\n /// Similarly to VisSpace, this structure is used to render a function style with a\n /// space after it.\n #[derive(Copy, Clone)]\n@@ -56,9 +56,9 @@ pub struct TyParamBounds<'a>(pub &'a [clean::TyParamBound]);\n pub struct CommaSep<'a, T: 'a>(pub &'a [T]);\n pub struct AbiSpace(pub Abi);\n \n-impl VisSpace {\n-    pub fn get(&self) -> Option<hir::Visibility> {\n-        let VisSpace(v) = *self; v\n+impl<'a> VisSpace<'a> {\n+    pub fn get(self) -> &'a Option<hir::Visibility> {\n+        let VisSpace(v) = self; v\n     }\n }\n \n@@ -636,9 +636,9 @@ impl<'a> fmt::Display for Method<'a> {\n     }\n }\n \n-impl fmt::Display for VisSpace {\n+impl<'a> fmt::Display for VisSpace<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.get() {\n+        match *self.get() {\n             Some(hir::Public) => write!(f, \"pub \"),\n             Some(hir::Inherited) | None => Ok(())\n         }"}, {"sha": "c5850089578cd059a051adde3a952496837b84d7", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -1714,21 +1714,21 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 match *src {\n                     Some(ref src) => {\n                         write!(w, \"<tr><td><code>{}extern crate {} as {};\",\n-                               VisSpace(myitem.visibility),\n+                               VisSpace(&myitem.visibility),\n                                src,\n                                name)?\n                     }\n                     None => {\n                         write!(w, \"<tr><td><code>{}extern crate {};\",\n-                               VisSpace(myitem.visibility), name)?\n+                               VisSpace(&myitem.visibility), name)?\n                     }\n                 }\n                 write!(w, \"</code></td></tr>\")?;\n             }\n \n             clean::ImportItem(ref import) => {\n                 write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n-                       VisSpace(myitem.visibility), *import)?;\n+                       VisSpace(&myitem.visibility), *import)?;\n             }\n \n             _ => {\n@@ -1831,7 +1831,7 @@ fn item_constant(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                  c: &clean::Constant) -> fmt::Result {\n     write!(w, \"<pre class='rust const'>{vis}const \\\n                {name}: {typ}{init}</pre>\",\n-           vis = VisSpace(it.visibility),\n+           vis = VisSpace(&it.visibility),\n            name = it.name.as_ref().unwrap(),\n            typ = c.type_,\n            init = Initializer(&c.expr))?;\n@@ -1842,7 +1842,7 @@ fn item_static(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                s: &clean::Static) -> fmt::Result {\n     write!(w, \"<pre class='rust static'>{vis}static {mutability}\\\n                {name}: {typ}{init}</pre>\",\n-           vis = VisSpace(it.visibility),\n+           vis = VisSpace(&it.visibility),\n            mutability = MutableSpace(s.mutability),\n            name = it.name.as_ref().unwrap(),\n            typ = s.type_,\n@@ -1859,7 +1859,7 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     };\n     write!(w, \"<pre class='rust fn'>{vis}{constness}{unsafety}{abi}fn \\\n                {name}{generics}{decl}{where_clause}</pre>\",\n-           vis = VisSpace(it.visibility),\n+           vis = VisSpace(&it.visibility),\n            constness = ConstnessSpace(vis_constness),\n            unsafety = UnsafetySpace(f.unsafety),\n            abi = AbiSpace(f.abi),\n@@ -1887,7 +1887,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n     // Output the trait definition\n     write!(w, \"<pre class='rust trait'>{}{}trait {}{}{}{} \",\n-           VisSpace(it.visibility),\n+           VisSpace(&it.visibility),\n            UnsafetySpace(t.unsafety),\n            it.name.as_ref().unwrap(),\n            t.generics,\n@@ -2214,7 +2214,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     write!(w, \"<pre class='rust enum'>\")?;\n     render_attributes(w, it)?;\n     write!(w, \"{}enum {}{}{}\",\n-           VisSpace(it.visibility),\n+           VisSpace(&it.visibility),\n            it.name.as_ref().unwrap(),\n            e.generics,\n            WhereClause(&e.generics))?;\n@@ -2326,7 +2326,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                  tab: &str,\n                  structhead: bool) -> fmt::Result {\n     write!(w, \"{}{}{}\",\n-           VisSpace(it.visibility),\n+           VisSpace(&it.visibility),\n            if structhead {\"struct \"} else {\"\"},\n            it.name.as_ref().unwrap())?;\n     if let Some(g) = g {\n@@ -2338,7 +2338,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n             for field in fields {\n                 if let clean::StructFieldItem(ref ty) = field.inner {\n                     write!(w, \"    {}{}: {},\\n{}\",\n-                           VisSpace(field.visibility),\n+                           VisSpace(&field.visibility),\n                            field.name.as_ref().unwrap(),\n                            *ty,\n                            tab)?;\n@@ -2361,7 +2361,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                         write!(w, \"_\")?\n                     }\n                     clean::StructFieldItem(ref ty) => {\n-                        write!(w, \"{}{}\", VisSpace(field.visibility), *ty)?\n+                        write!(w, \"{}{}\", VisSpace(&field.visibility), *ty)?\n                     }\n                     _ => unreachable!()\n                 }"}, {"sha": "5c36c38abc5872f626cd7b04b0f9664055c9ce25", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             id: item.id,\n             struct_type: struct_type,\n             name: name,\n-            vis: item.vis,\n+            vis: item.vis.clone(),\n             stab: self.stability(item.id),\n             depr: self.deprecation(item.id),\n             attrs: item.attrs.clone(),\n@@ -125,7 +125,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 def: v.node.data.clone(),\n                 whence: v.span,\n             }).collect(),\n-            vis: it.vis,\n+            vis: it.vis.clone(),\n             stab: self.stability(it.id),\n             depr: self.deprecation(it.id),\n             generics: params.clone(),\n@@ -144,7 +144,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         debug!(\"Visiting fn\");\n         Function {\n             id: item.id,\n-            vis: item.vis,\n+            vis: item.vis.clone(),\n             stab: self.stability(item.id),\n             depr: self.deprecation(item.id),\n             attrs: item.attrs.clone(),\n@@ -166,7 +166,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om.where_outer = span;\n         om.where_inner = m.inner;\n         om.attrs = attrs;\n-        om.vis = vis;\n+        om.vis = vis.clone();\n         om.stab = self.stability(id);\n         om.depr = self.deprecation(id);\n         om.id = id;\n@@ -299,7 +299,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.extern_crates.push(ExternCrate {\n                     name: name,\n                     path: p.map(|x|x.to_string()),\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n                 })\n@@ -324,7 +324,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n                 om.imports.push(Import {\n                     id: item.id,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     attrs: item.attrs.clone(),\n                     node: node,\n                     whence: item.span,\n@@ -333,7 +333,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             hir::ItemMod(ref m) => {\n                 om.mods.push(self.visit_mod_contents(item.span,\n                                                      item.attrs.clone(),\n-                                                     item.vis,\n+                                                     item.vis.clone(),\n                                                      item.id,\n                                                      m,\n                                                      Some(name)));\n@@ -353,7 +353,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     id: item.id,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     stab: self.stability(item.id),\n                     depr: self.deprecation(item.id),\n                 };\n@@ -368,7 +368,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     name: name,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     stab: self.stability(item.id),\n                     depr: self.deprecation(item.id),\n                 };\n@@ -382,7 +382,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     name: name,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     stab: self.stability(item.id),\n                     depr: self.deprecation(item.id),\n                 };\n@@ -398,7 +398,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     id: item.id,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     stab: self.stability(item.id),\n                     depr: self.deprecation(item.id),\n                 };\n@@ -415,7 +415,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     attrs: item.attrs.clone(),\n                     id: item.id,\n                     whence: item.span,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     stab: self.stability(item.id),\n                     depr: self.deprecation(item.id),\n                 };"}, {"sha": "1fbde00a3dfdecf2b7377ad415cbd78d29a64bf0", "filename": "src/test/compile-fail-fulldeps/macro-crate-doesnt-resolve.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-doesnt-resolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-doesnt-resolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-doesnt-resolve.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -16,5 +16,4 @@ extern crate macro_crate_test;\n fn main() {\n     macro_crate_test::foo();\n     //~^ ERROR failed to resolve. Use of undeclared type or module `macro_crate_test`\n-    //~^^ ERROR unresolved name `macro_crate_test::foo`\n }"}, {"sha": "0cd3a8853185fade135c0916d475447724a754d7", "filename": "src/test/compile-fail/bad-module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fbad-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fbad-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-module.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: unresolved name\n+// error-pattern: failed to resolve. Use of undeclared type or module `thing`\n \n fn main() { let foo = thing::len(Vec::new()); }"}, {"sha": "c1547dd82b3b2e5a83c6904a2d68a2a836b33abb", "filename": "src/test/compile-fail/bad-type-env-capture.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fbad-type-env-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fbad-type-env-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-type-env-capture.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -10,6 +10,5 @@\n \n fn foo<T>() {\n     fn bar(b: T) { } //~ ERROR can't use type parameters from outer\n-    //~^ ERROR type name `T` is undefined or not in scope\n }\n fn main() { }"}, {"sha": "166ef7ab87fcd1d2297dc0eda5e21f4c16424c48", "filename": "src/test/compile-fail/export-fully-qualified.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fexport-fully-qualified.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fexport-fully-qualified.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-fully-qualified.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: unresolved name\n+// error-pattern: failed to resolve. Use of undeclared type or module `foo`\n \n // In this test baz isn't resolved when called as foo.baz even though\n // it's called from inside foo. This is somewhat surprising and may"}, {"sha": "f7b1400aa45acf87e7c8a60bea566b0d75527013", "filename": "src/test/compile-fail/export2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fexport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fexport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport2.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: unresolved name\n+// error-pattern: failed to resolve. Use of undeclared type or module `bar`\n \n mod foo {\n     pub fn x() { bar::x(); }"}, {"sha": "a6a331984583675c99a942ea23f96347bc95f091", "filename": "src/test/compile-fail/inner-static-type-parameter.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finner-static-type-parameter.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -15,7 +15,6 @@ enum Bar<T> { What } //~ ERROR parameter `T` is never used\n fn foo<T>() {\n     static a: Bar<T> = Bar::What;\n     //~^ ERROR cannot use an outer type parameter in this context\n-    //~| ERROR type name `T` is undefined or not in scope\n }\n \n fn main() {"}, {"sha": "0c3c82a99f28f4f38a6ba45caea71226fadad3de", "filename": "src/test/compile-fail/issue-12796.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-12796.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-12796.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12796.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -12,7 +12,6 @@ trait Trait {\n     fn outer(&self) {\n         fn inner(_: &Self) {\n             //~^ ERROR can't use type parameters from outer function\n-            //~^^ ERROR use of `Self` outside of an impl or trait\n         }\n     }\n }"}, {"sha": "a8db01b82da945dbf23dd745c8588db8ce4ea7c9", "filename": "src/test/compile-fail/issue-30079.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-30079.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-30079.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30079.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+struct SemiPriv;\n+\n+mod m1 {\n+    struct Priv;\n+    impl ::SemiPriv {\n+        pub fn f(_: Priv) {} //~ WARN private type in public interface\n+        //~^ WARNING hard error\n+    }\n+\n+    impl Priv {\n+        pub fn f(_: Priv) {} // ok\n+    }\n+}\n+\n+mod m2 {\n+    struct Priv;\n+    impl ::std::ops::Deref for ::SemiPriv {\n+        type Target = Priv; //~ WARN private type in public interface\n+        //~^ WARNING hard error\n+        fn deref(&self) -> &Self::Target { unimplemented!() }\n+    }\n+\n+    impl ::std::ops::Deref for Priv {\n+        type Target = Priv; // ok\n+        fn deref(&self) -> &Self::Target { unimplemented!() }\n+    }\n+}\n+\n+trait SemiPrivTrait {\n+    type Assoc;\n+}\n+\n+mod m3 {\n+    struct Priv;\n+    impl ::SemiPrivTrait for () {\n+        type Assoc = Priv; //~ WARN private type in public interface\n+        //~^ WARNING hard error\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "2b0a24cfdb35f9e3bbabf3baaa3a5f7a0904f21a", "filename": "src/test/compile-fail/issue-3021-b.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3021-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3021-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021-b.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -17,7 +17,6 @@ fn siphash(k0 : u64) {\n     impl siphash {\n         pub fn reset(&mut self) {\n            self.v0 = k0 ^ 0x736f6d6570736575; //~ ERROR can't capture dynamic environment\n-           //~^ ERROR unresolved name `k0`\n         }\n     }\n }"}, {"sha": "635006a3b4dad62af9afe2611bd533bf5578580c", "filename": "src/test/compile-fail/issue-3021-c.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3021-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3021-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021-c.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -13,8 +13,6 @@ fn siphash<T>() {\n     trait t {\n         fn g(&self, x: T) -> T;  //~ ERROR can't use type parameters from outer function; try using\n         //~^ ERROR can't use type parameters from outer function; try using\n-        //~^^ ERROR type name `T` is undefined or not in scope\n-        //~^^^ ERROR type name `T` is undefined or not in scope\n     }\n }\n "}, {"sha": "c23e12e713aad797157fa2fc7e897aeef6997ff4", "filename": "src/test/compile-fail/issue-3021-d.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021-d.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -29,9 +29,7 @@ fn siphash(k0 : u64, k1 : u64) {\n    impl siphash for SipState {\n         fn reset(&self) {\n             self.v0 = k0 ^ 0x736f6d6570736575; //~ ERROR can't capture dynamic environment\n-            //~^ ERROR unresolved name `k0`\n             self.v1 = k1 ^ 0x646f72616e646f6d; //~ ERROR can't capture dynamic environment\n-            //~^ ERROR unresolved name `k1`\n         }\n         fn result(&self) -> u64 { return mk_result(self); }\n     }"}, {"sha": "f93a333d2aea7b8f37ed1b5f37915bbb641f6d89", "filename": "src/test/compile-fail/issue-3021.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3021.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -20,7 +20,6 @@ fn siphash(k0 : u64) {\n     impl SipHash for SipState {\n         fn reset(&self) {\n            self.v0 = k0 ^ 0x736f6d6570736575; //~ ERROR can't capture dynamic environment\n-           //~^ ERROR unresolved name `k0`\n         }\n     }\n     panic!();"}, {"sha": "d3b932fbc53efa5710b0a0843e25809f91148f4a", "filename": "src/test/compile-fail/issue-3214.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -11,7 +11,6 @@\n fn foo<T>() {\n     struct foo {\n         x: T, //~ ERROR can't use type parameters from outer function;\n-        //~^ ERROR type name `T` is undefined or not in scope\n     }\n \n     impl<T> Drop for foo<T> {"}, {"sha": "6cd2c02c417ea8ed5f8aacfd19367259ed7b72b5", "filename": "src/test/compile-fail/issue-3521-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3521-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3521-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521-2.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -13,7 +13,6 @@ fn main() {\n \n     static y: isize = foo + 1;\n     //~^ ERROR attempt to use a non-constant value in a constant\n-    //~| ERROR unresolved name `foo`\n \n     println!(\"{}\", y);\n }"}, {"sha": "52375ef281ace24513c5f70d46257acd5512d401", "filename": "src/test/compile-fail/issue-3521.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -15,8 +15,7 @@ fn main() {\n     enum Stuff {\n         Bar = foo\n         //~^ ERROR attempt to use a non-constant value in a constant\n-        //~| ERROR unresolved name `foo`\n-        //~^^^ ERROR constant evaluation error: non-constant path in constant expression\n+        //~^^ ERROR constant evaluation error: non-constant path in constant expression\n     }\n \n     println!(\"{}\", Stuff::Bar);"}, {"sha": "16fb2f68133f291f9519dcb591330338e28684d8", "filename": "src/test/compile-fail/issue-3668-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3668-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3668-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3668-2.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -11,7 +11,6 @@\n fn f(x:isize) {\n     static child: isize = x + 1;\n     //~^ ERROR attempt to use a non-constant value in a constant\n-    //~| ERROR unresolved name `x`\n }\n \n fn main() {}"}, {"sha": "9c31dc1e38ef8ff312193b105a73e9346e9d0153", "filename": "src/test/compile-fail/issue-3668.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -17,7 +17,6 @@ impl PTrait for P {\n    fn getChildOption(&self) -> Option<Box<P>> {\n        static childVal: Box<P> = self.child.get();\n        //~^ ERROR attempt to use a non-constant value in a constant\n-       //~| ERROR unresolved name `self`\n        panic!();\n    }\n }"}, {"sha": "463fdaa106926a898579d7335aba455180227b17", "filename": "src/test/compile-fail/issue-5997-enum.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-5997-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-5997-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5997-enum.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -11,7 +11,6 @@\n fn f<Z>() -> bool {\n     enum E { V(Z) }\n     //~^ ERROR can't use type parameters from outer function\n-    //~^^ ERROR type name `Z` is undefined or not in scope\n     true\n }\n "}, {"sha": "e9cfafc98df0ef47fffdfe2768cd6353e7071555", "filename": "src/test/compile-fail/issue-5997-struct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-5997-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-5997-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5997-struct.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n fn f<T>() -> bool {\n-    struct S(T); //~ ERROR type name `T` is undefined or not in scope\n-    //~^ ERROR can't use type parameters from outer function; try using\n+    struct S(T); //~ ERROR can't use type parameters from outer function; try using\n \n     true\n }"}, {"sha": "1fe10ba7a27bba10bc7d762c6671b85a4452cb03", "filename": "src/test/compile-fail/issue-6642.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-6642.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fissue-6642.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6642.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -13,7 +13,6 @@ impl A {\n     fn m(&self) {\n         fn x() {\n             self.m() //~ ERROR can't capture dynamic environment in a fn item\n-            //~^ ERROR unresolved name `self`\n         }\n     }\n }"}, {"sha": "1111b21d4550c14c3ef2fbae02ae702a562dd9ed", "filename": "src/test/compile-fail/macro-inner-attributes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -26,6 +26,5 @@ test!(b,\n fn main() {\n     a::bar();\n     //~^ ERROR failed to resolve. Use of undeclared type or module `a`\n-    //~^^ ERROR unresolved name `a::bar`\n     b::bar();\n }"}, {"sha": "957b6cda55311b79c927ee3ec5de589e5085cc92", "filename": "src/test/compile-fail/no-link.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fno-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fno-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-link.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -14,6 +14,5 @@ extern crate libc;\n fn main() {\n     unsafe {\n         libc::abs(0);  //~ ERROR Use of undeclared type or module `libc`\n-                      //~^ ERROR unresolved name `libc::abs`\n     }\n }"}, {"sha": "30ff1ed0e26f7a2a637a253e7512c7ac73a62048", "filename": "src/test/compile-fail/resolve-type-param-in-item-in-trait.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fresolve-type-param-in-item-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470ca1c3ff33cd046f71a5453f8f520da4cd387e/src%2Ftest%2Fcompile-fail%2Fresolve-type-param-in-item-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-type-param-in-item-in-trait.rs?ref=470ca1c3ff33cd046f71a5453f8f520da4cd387e", "patch": "@@ -18,7 +18,6 @@ trait TraitA<A> {\n             //~^ ERROR parameter `B` is never used\n             Variance(A)\n                 //~^ ERROR can't use type parameters from outer function\n-                //~^^ ERROR type name `A` is undefined or not in scope\n         }\n     }\n }\n@@ -27,25 +26,22 @@ trait TraitB<A> {\n     fn outer(self) {\n         struct Foo<B>(A);\n                 //~^ ERROR can't use type parameters from outer function\n-                //~^^ ERROR type name `A` is undefined or not in scope\n-                //~^^^ ERROR parameter `B` is never used\n+                //~^^ ERROR parameter `B` is never used\n     }\n }\n \n trait TraitC<A> {\n     fn outer(self) {\n         struct Foo<B> { a: A }\n                 //~^ ERROR can't use type parameters from outer function\n-                //~^^ ERROR type name `A` is undefined or not in scope\n-                //~^^^ ERROR parameter `B` is never used\n+                //~^^ ERROR parameter `B` is never used\n     }\n }\n \n trait TraitD<A> {\n     fn outer(self) {\n         fn foo<B>(a: A) { }\n                 //~^ ERROR can't use type parameters from outer function\n-                //~^^ ERROR type name `A` is undefined or not in scope\n     }\n }\n "}]}