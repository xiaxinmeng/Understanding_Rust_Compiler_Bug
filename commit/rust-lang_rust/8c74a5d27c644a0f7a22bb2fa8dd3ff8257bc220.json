{"sha": "8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "node_id": "C_kwDOAAsO6NoAKDhjNzRhNWQyN2M2NDRhMGY3YTIyYmIyZmE4ZGQzZmY4MjU3YmMyMjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-14T20:20:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-14T20:20:40Z"}, "message": "Auto merge of #112625 - matthiaskrgr:rollup-jcobj3g, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #112584 (loongarch64-none*: Remove environment component from llvm target)\n - #112600 (Introduce a `Stable` trait to translate MIR to SMIR)\n - #112605 (Improve docs/clean up negative overlap functions)\n - #112611 (Error on unconstrained lifetime in RPITIT)\n - #112612 (Fix explicit-outlives-requirements lint span)\n - #112613 (Fix rustdoc-gui tests on Windows)\n - #112620 (Fix small typo)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "757e21f059fc4174cf233a2fcaea26576700e065", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/757e21f059fc4174cf233a2fcaea26576700e065"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "html_url": "https://github.com/rust-lang/rust/commit/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b475c705f36fb3b0a63994b92f2bbd2f5865b07", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b475c705f36fb3b0a63994b92f2bbd2f5865b07", "html_url": "https://github.com/rust-lang/rust/commit/0b475c705f36fb3b0a63994b92f2bbd2f5865b07"}, {"sha": "36163881396b218a98c38598c239a0b32515533f", "url": "https://api.github.com/repos/rust-lang/rust/commits/36163881396b218a98c38598c239a0b32515533f", "html_url": "https://github.com/rust-lang/rust/commit/36163881396b218a98c38598c239a0b32515533f"}], "stats": {"total": 939, "additions": 532, "deletions": 407}, "files": [{"sha": "4fbe68b8b6c542ce3e908229eefdf2663a688c4d", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 38, "deletions": 21, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -45,12 +45,7 @@ pub(super) fn compare_impl_method<'tcx>(\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\", impl_trait_ref);\n \n     let _: Result<_, ErrorGuaranteed> = try {\n-        compare_self_type(tcx, impl_m, trait_m, impl_trait_ref)?;\n-        compare_number_of_generics(tcx, impl_m, trait_m, false)?;\n-        compare_generic_param_kinds(tcx, impl_m, trait_m, false)?;\n-        compare_number_of_method_arguments(tcx, impl_m, trait_m)?;\n-        compare_synthetic_generics(tcx, impl_m, trait_m)?;\n-        compare_asyncness(tcx, impl_m, trait_m)?;\n+        check_method_is_structurally_compatible(tcx, impl_m, trait_m, impl_trait_ref, false)?;\n         compare_method_predicate_entailment(\n             tcx,\n             impl_m,\n@@ -61,6 +56,26 @@ pub(super) fn compare_impl_method<'tcx>(\n     };\n }\n \n+/// Checks a bunch of different properties of the impl/trait methods for\n+/// compatibility, such as asyncness, number of argument, self receiver kind,\n+/// and number of early- and late-bound generics.\n+fn check_method_is_structurally_compatible<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl_m: ty::AssocItem,\n+    trait_m: ty::AssocItem,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+    delay: bool,\n+) -> Result<(), ErrorGuaranteed> {\n+    compare_self_type(tcx, impl_m, trait_m, impl_trait_ref, delay)?;\n+    compare_number_of_generics(tcx, impl_m, trait_m, delay)?;\n+    compare_generic_param_kinds(tcx, impl_m, trait_m, delay)?;\n+    compare_number_of_method_arguments(tcx, impl_m, trait_m, delay)?;\n+    compare_synthetic_generics(tcx, impl_m, trait_m, delay)?;\n+    compare_asyncness(tcx, impl_m, trait_m, delay)?;\n+    check_region_bounds_on_impl_item(tcx, impl_m, trait_m, delay)?;\n+    Ok(())\n+}\n+\n /// This function is best explained by example. Consider a trait with it's implementation:\n ///\n /// ```rust\n@@ -177,9 +192,6 @@ fn compare_method_predicate_entailment<'tcx>(\n     let impl_m_predicates = tcx.predicates_of(impl_m.def_id);\n     let trait_m_predicates = tcx.predicates_of(trait_m.def_id);\n \n-    // Check region bounds.\n-    check_region_bounds_on_impl_item(tcx, impl_m, trait_m, false)?;\n-\n     // Create obligations for each predicate declared by the impl\n     // definition in the context of the trait's parameter\n     // environment. We can't just use `impl_env.caller_bounds`,\n@@ -534,6 +546,7 @@ fn compare_asyncness<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: ty::AssocItem,\n     trait_m: ty::AssocItem,\n+    delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     if tcx.asyncness(trait_m.def_id) == hir::IsAsync::Async {\n         match tcx.fn_sig(impl_m.def_id).skip_binder().skip_binder().output().kind() {\n@@ -544,11 +557,14 @@ fn compare_asyncness<'tcx>(\n                 // We don't know if it's ok, but at least it's already an error.\n             }\n             _ => {\n-                return Err(tcx.sess.emit_err(crate::errors::AsyncTraitImplShouldBeAsync {\n-                    span: tcx.def_span(impl_m.def_id),\n-                    method_name: trait_m.name,\n-                    trait_item_span: tcx.hir().span_if_local(trait_m.def_id),\n-                }));\n+                return Err(tcx\n+                    .sess\n+                    .create_err(crate::errors::AsyncTraitImplShouldBeAsync {\n+                        span: tcx.def_span(impl_m.def_id),\n+                        method_name: trait_m.name,\n+                        trait_item_span: tcx.hir().span_if_local(trait_m.def_id),\n+                    })\n+                    .emit_unless(delay));\n             }\n         };\n     }\n@@ -602,9 +618,7 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n \n     // First, check a few of the same things as `compare_impl_method`,\n     // just so we don't ICE during substitution later.\n-    compare_number_of_generics(tcx, impl_m, trait_m, true)?;\n-    compare_generic_param_kinds(tcx, impl_m, trait_m, true)?;\n-    check_region_bounds_on_impl_item(tcx, impl_m, trait_m, true)?;\n+    check_method_is_structurally_compatible(tcx, impl_m, trait_m, impl_trait_ref, true)?;\n \n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n@@ -1097,6 +1111,7 @@ fn compare_self_type<'tcx>(\n     impl_m: ty::AssocItem,\n     trait_m: ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n+    delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     // Try to give more informative error messages about self typing\n     // mismatches. Note that any mismatch will also be detected\n@@ -1145,7 +1160,7 @@ fn compare_self_type<'tcx>(\n             } else {\n                 err.note_trait_signature(trait_m.name, trait_m.signature(tcx));\n             }\n-            return Err(err.emit());\n+            return Err(err.emit_unless(delay));\n         }\n \n         (true, false) => {\n@@ -1166,7 +1181,7 @@ fn compare_self_type<'tcx>(\n                 err.note_trait_signature(trait_m.name, trait_m.signature(tcx));\n             }\n \n-            return Err(err.emit());\n+            return Err(err.emit_unless(delay));\n         }\n     }\n \n@@ -1352,6 +1367,7 @@ fn compare_number_of_method_arguments<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: ty::AssocItem,\n     trait_m: ty::AssocItem,\n+    delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     let impl_m_fty = tcx.fn_sig(impl_m.def_id);\n     let trait_m_fty = tcx.fn_sig(trait_m.def_id);\n@@ -1422,7 +1438,7 @@ fn compare_number_of_method_arguments<'tcx>(\n             ),\n         );\n \n-        return Err(err.emit());\n+        return Err(err.emit_unless(delay));\n     }\n \n     Ok(())\n@@ -1432,6 +1448,7 @@ fn compare_synthetic_generics<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: ty::AssocItem,\n     trait_m: ty::AssocItem,\n+    delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     // FIXME(chrisvittal) Clean up this function, list of FIXME items:\n     //     1. Better messages for the span labels\n@@ -1551,7 +1568,7 @@ fn compare_synthetic_generics<'tcx>(\n                 }\n                 _ => unreachable!(),\n             }\n-            error_found = Some(err.emit());\n+            error_found = Some(err.emit_unless(delay));\n         }\n     }\n     if let Some(reported) = error_found { Err(reported) } else { Ok(()) }"}, {"sha": "5526dd4b007dd32d33b1fbad417629d3084e540b", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -106,10 +106,23 @@ fn enforce_impl_params_are_constrained(tcx: TyCtxt<'_>, impl_def_id: LocalDefId)\n                     if item.defaultness(tcx).has_value() {\n                         cgp::parameters_for(&tcx.type_of(def_id).subst_identity(), true)\n                     } else {\n-                        Vec::new()\n+                        vec![]\n                     }\n                 }\n-                ty::AssocKind::Fn | ty::AssocKind::Const => Vec::new(),\n+                ty::AssocKind::Fn => {\n+                    if !tcx.lower_impl_trait_in_trait_to_assoc_ty()\n+                        && item.defaultness(tcx).has_value()\n+                        && tcx.impl_method_has_trait_impl_trait_tys(item.def_id)\n+                        && let Ok(table) = tcx.collect_return_position_impl_trait_in_trait_tys(def_id)\n+                    {\n+                        table.values().copied().flat_map(|ty| {\n+                            cgp::parameters_for(&ty.subst_identity(), true)\n+                        }).collect()\n+                    } else {\n+                        vec![]\n+                    }\n+                }\n+                ty::AssocKind::Const => vec![],\n             }\n         })\n         .collect();"}, {"sha": "7b05bff515148342b8c700db54c0e8d599cb46b3", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -2124,12 +2124,16 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n             }\n \n             let ty_generics = cx.tcx.generics_of(def_id);\n+            let num_where_predicates = hir_generics\n+                .predicates\n+                .iter()\n+                .filter(|predicate| predicate.in_where_clause())\n+                .count();\n \n             let mut bound_count = 0;\n             let mut lint_spans = Vec::new();\n             let mut where_lint_spans = Vec::new();\n-            let mut dropped_predicate_count = 0;\n-            let num_predicates = hir_generics.predicates.len();\n+            let mut dropped_where_predicate_count = 0;\n             for (i, where_predicate) in hir_generics.predicates.iter().enumerate() {\n                 let (relevant_lifetimes, bounds, predicate_span, in_where_clause) =\n                     match where_predicate {\n@@ -2186,8 +2190,8 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                 bound_count += bound_spans.len();\n \n                 let drop_predicate = bound_spans.len() == bounds.len();\n-                if drop_predicate {\n-                    dropped_predicate_count += 1;\n+                if drop_predicate && in_where_clause {\n+                    dropped_where_predicate_count += 1;\n                 }\n \n                 if drop_predicate {\n@@ -2196,7 +2200,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                     } else if predicate_span.from_expansion() {\n                         // Don't try to extend the span if it comes from a macro expansion.\n                         where_lint_spans.push(predicate_span);\n-                    } else if i + 1 < num_predicates {\n+                    } else if i + 1 < num_where_predicates {\n                         // If all the bounds on a predicate were inferable and there are\n                         // further predicates, we want to eat the trailing comma.\n                         let next_predicate_span = hir_generics.predicates[i + 1].span();\n@@ -2224,9 +2228,10 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                 }\n             }\n \n-            // If all predicates are inferable, drop the entire clause\n+            // If all predicates in where clause are inferable, drop the entire clause\n             // (including the `where`)\n-            if hir_generics.has_where_clause_predicates && dropped_predicate_count == num_predicates\n+            if hir_generics.has_where_clause_predicates\n+                && dropped_where_predicate_count == num_where_predicates\n             {\n                 let where_span = hir_generics.where_clause_span;\n                 // Extend the where clause back to the closing `>` of the"}, {"sha": "6bd030b13d1ce861c7b8ec5ca6c4c1fc6f1ea0e8", "filename": "compiler/rustc_smir/src/rustc_smir/mod.rs", "status": "modified", "additions": 203, "deletions": 194, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -8,6 +8,7 @@\n //! For now, we are developing everything inside `rustc`, thus, we keep this module private.\n \n use crate::stable_mir::{self, ty::TyKind, Context};\n+use rustc_middle::mir;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use tracing::debug;\n@@ -42,8 +43,8 @@ impl<'tcx> Context for Tables<'tcx> {\n                 .basic_blocks\n                 .iter()\n                 .map(|block| stable_mir::mir::BasicBlock {\n-                    terminator: rustc_terminator_to_terminator(block.terminator()),\n-                    statements: block.statements.iter().map(rustc_statement_to_statement).collect(),\n+                    terminator: block.terminator().stable(),\n+                    statements: block.statements.iter().map(mir::Statement::stable).collect(),\n                 })\n                 .collect(),\n             locals: mir.local_decls.iter().map(|decl| self.intern_ty(decl.ty)).collect(),\n@@ -118,82 +119,95 @@ fn smir_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> stable_mir::Crate {\n     stable_mir::Crate { id: crate_num.into(), name: crate_name, is_local }\n }\n \n-fn rustc_statement_to_statement(\n-    s: &rustc_middle::mir::Statement<'_>,\n-) -> stable_mir::mir::Statement {\n-    use rustc_middle::mir::StatementKind::*;\n-    match &s.kind {\n-        Assign(assign) => stable_mir::mir::Statement::Assign(\n-            rustc_place_to_place(&assign.0),\n-            rustc_rvalue_to_rvalue(&assign.1),\n-        ),\n-        FakeRead(_) => todo!(),\n-        SetDiscriminant { .. } => todo!(),\n-        Deinit(_) => todo!(),\n-        StorageLive(_) => todo!(),\n-        StorageDead(_) => todo!(),\n-        Retag(_, _) => todo!(),\n-        PlaceMention(_) => todo!(),\n-        AscribeUserType(_, _) => todo!(),\n-        Coverage(_) => todo!(),\n-        Intrinsic(_) => todo!(),\n-        ConstEvalCounter => todo!(),\n-        Nop => stable_mir::mir::Statement::Nop,\n+pub trait Stable {\n+    type T;\n+    fn stable(&self) -> Self::T;\n+}\n+\n+impl<'tcx> Stable for mir::Statement<'tcx> {\n+    type T = stable_mir::mir::Statement;\n+    fn stable(&self) -> Self::T {\n+        use rustc_middle::mir::StatementKind::*;\n+        match &self.kind {\n+            Assign(assign) => {\n+                stable_mir::mir::Statement::Assign(assign.0.stable(), assign.1.stable())\n+            }\n+            FakeRead(_) => todo!(),\n+            SetDiscriminant { .. } => todo!(),\n+            Deinit(_) => todo!(),\n+            StorageLive(_) => todo!(),\n+            StorageDead(_) => todo!(),\n+            Retag(_, _) => todo!(),\n+            PlaceMention(_) => todo!(),\n+            AscribeUserType(_, _) => todo!(),\n+            Coverage(_) => todo!(),\n+            Intrinsic(_) => todo!(),\n+            ConstEvalCounter => todo!(),\n+            Nop => stable_mir::mir::Statement::Nop,\n+        }\n     }\n }\n \n-fn rustc_rvalue_to_rvalue(rvalue: &rustc_middle::mir::Rvalue<'_>) -> stable_mir::mir::Rvalue {\n-    use rustc_middle::mir::Rvalue::*;\n-    match rvalue {\n-        Use(op) => stable_mir::mir::Rvalue::Use(rustc_op_to_op(op)),\n-        Repeat(_, _) => todo!(),\n-        Ref(_, _, _) => todo!(),\n-        ThreadLocalRef(_) => todo!(),\n-        AddressOf(_, _) => todo!(),\n-        Len(_) => todo!(),\n-        Cast(_, _, _) => todo!(),\n-        BinaryOp(_, _) => todo!(),\n-        CheckedBinaryOp(bin_op, ops) => stable_mir::mir::Rvalue::CheckedBinaryOp(\n-            rustc_bin_op_to_bin_op(bin_op),\n-            rustc_op_to_op(&ops.0),\n-            rustc_op_to_op(&ops.1),\n-        ),\n-        NullaryOp(_, _) => todo!(),\n-        UnaryOp(un_op, op) => {\n-            stable_mir::mir::Rvalue::UnaryOp(rustc_un_op_to_un_op(un_op), rustc_op_to_op(op))\n+impl<'tcx> Stable for mir::Rvalue<'tcx> {\n+    type T = stable_mir::mir::Rvalue;\n+    fn stable(&self) -> Self::T {\n+        use mir::Rvalue::*;\n+        match self {\n+            Use(op) => stable_mir::mir::Rvalue::Use(op.stable()),\n+            Repeat(_, _) => todo!(),\n+            Ref(_, _, _) => todo!(),\n+            ThreadLocalRef(_) => todo!(),\n+            AddressOf(_, _) => todo!(),\n+            Len(_) => todo!(),\n+            Cast(_, _, _) => todo!(),\n+            BinaryOp(_, _) => todo!(),\n+            CheckedBinaryOp(bin_op, ops) => stable_mir::mir::Rvalue::CheckedBinaryOp(\n+                bin_op.stable(),\n+                ops.0.stable(),\n+                ops.1.stable(),\n+            ),\n+            NullaryOp(_, _) => todo!(),\n+            UnaryOp(un_op, op) => stable_mir::mir::Rvalue::UnaryOp(un_op.stable(), op.stable()),\n+            Discriminant(_) => todo!(),\n+            Aggregate(_, _) => todo!(),\n+            ShallowInitBox(_, _) => todo!(),\n+            CopyForDeref(_) => todo!(),\n         }\n-        Discriminant(_) => todo!(),\n-        Aggregate(_, _) => todo!(),\n-        ShallowInitBox(_, _) => todo!(),\n-        CopyForDeref(_) => todo!(),\n     }\n }\n \n-fn rustc_op_to_op(op: &rustc_middle::mir::Operand<'_>) -> stable_mir::mir::Operand {\n-    use rustc_middle::mir::Operand::*;\n-    match op {\n-        Copy(place) => stable_mir::mir::Operand::Copy(rustc_place_to_place(place)),\n-        Move(place) => stable_mir::mir::Operand::Move(rustc_place_to_place(place)),\n-        Constant(c) => stable_mir::mir::Operand::Constant(c.to_string()),\n+impl<'tcx> Stable for mir::Operand<'tcx> {\n+    type T = stable_mir::mir::Operand;\n+    fn stable(&self) -> Self::T {\n+        use mir::Operand::*;\n+        match self {\n+            Copy(place) => stable_mir::mir::Operand::Copy(place.stable()),\n+            Move(place) => stable_mir::mir::Operand::Move(place.stable()),\n+            Constant(c) => stable_mir::mir::Operand::Constant(c.to_string()),\n+        }\n     }\n }\n \n-fn rustc_place_to_place(place: &rustc_middle::mir::Place<'_>) -> stable_mir::mir::Place {\n-    stable_mir::mir::Place {\n-        local: place.local.as_usize(),\n-        projection: format!(\"{:?}\", place.projection),\n+impl<'tcx> Stable for mir::Place<'tcx> {\n+    type T = stable_mir::mir::Place;\n+    fn stable(&self) -> Self::T {\n+        stable_mir::mir::Place {\n+            local: self.local.as_usize(),\n+            projection: format!(\"{:?}\", self.projection),\n+        }\n     }\n }\n \n-fn rustc_unwind_to_unwind(\n-    unwind: &rustc_middle::mir::UnwindAction,\n-) -> stable_mir::mir::UnwindAction {\n-    use rustc_middle::mir::UnwindAction;\n-    match unwind {\n-        UnwindAction::Continue => stable_mir::mir::UnwindAction::Continue,\n-        UnwindAction::Unreachable => stable_mir::mir::UnwindAction::Unreachable,\n-        UnwindAction::Terminate => stable_mir::mir::UnwindAction::Terminate,\n-        UnwindAction::Cleanup(bb) => stable_mir::mir::UnwindAction::Cleanup(bb.as_usize()),\n+impl Stable for mir::UnwindAction {\n+    type T = stable_mir::mir::UnwindAction;\n+    fn stable(&self) -> Self::T {\n+        use rustc_middle::mir::UnwindAction;\n+        match self {\n+            UnwindAction::Continue => stable_mir::mir::UnwindAction::Continue,\n+            UnwindAction::Unreachable => stable_mir::mir::UnwindAction::Unreachable,\n+            UnwindAction::Terminate => stable_mir::mir::UnwindAction::Terminate,\n+            UnwindAction::Cleanup(bb) => stable_mir::mir::UnwindAction::Cleanup(bb.as_usize()),\n+        }\n     }\n }\n \n@@ -202,168 +216,163 @@ fn rustc_assert_msg_to_msg<'tcx>(\n ) -> stable_mir::mir::AssertMessage {\n     use rustc_middle::mir::AssertKind;\n     match assert_message {\n-        AssertKind::BoundsCheck { len, index } => stable_mir::mir::AssertMessage::BoundsCheck {\n-            len: rustc_op_to_op(len),\n-            index: rustc_op_to_op(index),\n-        },\n-        AssertKind::Overflow(bin_op, op1, op2) => stable_mir::mir::AssertMessage::Overflow(\n-            rustc_bin_op_to_bin_op(bin_op),\n-            rustc_op_to_op(op1),\n-            rustc_op_to_op(op2),\n-        ),\n-        AssertKind::OverflowNeg(op) => {\n-            stable_mir::mir::AssertMessage::OverflowNeg(rustc_op_to_op(op))\n+        AssertKind::BoundsCheck { len, index } => {\n+            stable_mir::mir::AssertMessage::BoundsCheck { len: len.stable(), index: index.stable() }\n+        }\n+        AssertKind::Overflow(bin_op, op1, op2) => {\n+            stable_mir::mir::AssertMessage::Overflow(bin_op.stable(), op1.stable(), op2.stable())\n         }\n+        AssertKind::OverflowNeg(op) => stable_mir::mir::AssertMessage::OverflowNeg(op.stable()),\n         AssertKind::DivisionByZero(op) => {\n-            stable_mir::mir::AssertMessage::DivisionByZero(rustc_op_to_op(op))\n+            stable_mir::mir::AssertMessage::DivisionByZero(op.stable())\n         }\n         AssertKind::RemainderByZero(op) => {\n-            stable_mir::mir::AssertMessage::RemainderByZero(rustc_op_to_op(op))\n+            stable_mir::mir::AssertMessage::RemainderByZero(op.stable())\n         }\n         AssertKind::ResumedAfterReturn(generator) => {\n-            stable_mir::mir::AssertMessage::ResumedAfterReturn(rustc_generator_to_generator(\n-                generator,\n-            ))\n+            stable_mir::mir::AssertMessage::ResumedAfterReturn(generator.stable())\n         }\n         AssertKind::ResumedAfterPanic(generator) => {\n-            stable_mir::mir::AssertMessage::ResumedAfterPanic(rustc_generator_to_generator(\n-                generator,\n-            ))\n+            stable_mir::mir::AssertMessage::ResumedAfterPanic(generator.stable())\n         }\n         AssertKind::MisalignedPointerDereference { required, found } => {\n             stable_mir::mir::AssertMessage::MisalignedPointerDereference {\n-                required: rustc_op_to_op(required),\n-                found: rustc_op_to_op(found),\n+                required: required.stable(),\n+                found: found.stable(),\n             }\n         }\n     }\n }\n \n-fn rustc_bin_op_to_bin_op(bin_op: &rustc_middle::mir::BinOp) -> stable_mir::mir::BinOp {\n-    use rustc_middle::mir::BinOp;\n-    match bin_op {\n-        BinOp::Add => stable_mir::mir::BinOp::Add,\n-        BinOp::Sub => stable_mir::mir::BinOp::Sub,\n-        BinOp::Mul => stable_mir::mir::BinOp::Mul,\n-        BinOp::Div => stable_mir::mir::BinOp::Div,\n-        BinOp::Rem => stable_mir::mir::BinOp::Rem,\n-        BinOp::BitXor => stable_mir::mir::BinOp::BitXor,\n-        BinOp::BitAnd => stable_mir::mir::BinOp::BitAnd,\n-        BinOp::BitOr => stable_mir::mir::BinOp::BitOr,\n-        BinOp::Shl => stable_mir::mir::BinOp::Shl,\n-        BinOp::Shr => stable_mir::mir::BinOp::Shr,\n-        BinOp::Eq => stable_mir::mir::BinOp::Eq,\n-        BinOp::Lt => stable_mir::mir::BinOp::Lt,\n-        BinOp::Le => stable_mir::mir::BinOp::Le,\n-        BinOp::Ne => stable_mir::mir::BinOp::Ne,\n-        BinOp::Ge => stable_mir::mir::BinOp::Ge,\n-        BinOp::Gt => stable_mir::mir::BinOp::Gt,\n-        BinOp::Offset => stable_mir::mir::BinOp::Offset,\n+impl Stable for mir::BinOp {\n+    type T = stable_mir::mir::BinOp;\n+    fn stable(&self) -> Self::T {\n+        use mir::BinOp;\n+        match self {\n+            BinOp::Add => stable_mir::mir::BinOp::Add,\n+            BinOp::Sub => stable_mir::mir::BinOp::Sub,\n+            BinOp::Mul => stable_mir::mir::BinOp::Mul,\n+            BinOp::Div => stable_mir::mir::BinOp::Div,\n+            BinOp::Rem => stable_mir::mir::BinOp::Rem,\n+            BinOp::BitXor => stable_mir::mir::BinOp::BitXor,\n+            BinOp::BitAnd => stable_mir::mir::BinOp::BitAnd,\n+            BinOp::BitOr => stable_mir::mir::BinOp::BitOr,\n+            BinOp::Shl => stable_mir::mir::BinOp::Shl,\n+            BinOp::Shr => stable_mir::mir::BinOp::Shr,\n+            BinOp::Eq => stable_mir::mir::BinOp::Eq,\n+            BinOp::Lt => stable_mir::mir::BinOp::Lt,\n+            BinOp::Le => stable_mir::mir::BinOp::Le,\n+            BinOp::Ne => stable_mir::mir::BinOp::Ne,\n+            BinOp::Ge => stable_mir::mir::BinOp::Ge,\n+            BinOp::Gt => stable_mir::mir::BinOp::Gt,\n+            BinOp::Offset => stable_mir::mir::BinOp::Offset,\n+        }\n     }\n }\n \n-fn rustc_un_op_to_un_op(unary_op: &rustc_middle::mir::UnOp) -> stable_mir::mir::UnOp {\n-    use rustc_middle::mir::UnOp;\n-    match unary_op {\n-        UnOp::Not => stable_mir::mir::UnOp::Not,\n-        UnOp::Neg => stable_mir::mir::UnOp::Neg,\n+impl Stable for mir::UnOp {\n+    type T = stable_mir::mir::UnOp;\n+    fn stable(&self) -> Self::T {\n+        use mir::UnOp;\n+        match self {\n+            UnOp::Not => stable_mir::mir::UnOp::Not,\n+            UnOp::Neg => stable_mir::mir::UnOp::Neg,\n+        }\n     }\n }\n \n-fn rustc_generator_to_generator(\n-    generator: &rustc_hir::GeneratorKind,\n-) -> stable_mir::mir::GeneratorKind {\n-    use rustc_hir::{AsyncGeneratorKind, GeneratorKind};\n-    match generator {\n-        GeneratorKind::Async(async_gen) => {\n-            let async_gen = match async_gen {\n-                AsyncGeneratorKind::Block => stable_mir::mir::AsyncGeneratorKind::Block,\n-                AsyncGeneratorKind::Closure => stable_mir::mir::AsyncGeneratorKind::Closure,\n-                AsyncGeneratorKind::Fn => stable_mir::mir::AsyncGeneratorKind::Fn,\n-            };\n-            stable_mir::mir::GeneratorKind::Async(async_gen)\n+impl Stable for rustc_hir::GeneratorKind {\n+    type T = stable_mir::mir::GeneratorKind;\n+    fn stable(&self) -> Self::T {\n+        use rustc_hir::{AsyncGeneratorKind, GeneratorKind};\n+        match self {\n+            GeneratorKind::Async(async_gen) => {\n+                let async_gen = match async_gen {\n+                    AsyncGeneratorKind::Block => stable_mir::mir::AsyncGeneratorKind::Block,\n+                    AsyncGeneratorKind::Closure => stable_mir::mir::AsyncGeneratorKind::Closure,\n+                    AsyncGeneratorKind::Fn => stable_mir::mir::AsyncGeneratorKind::Fn,\n+                };\n+                stable_mir::mir::GeneratorKind::Async(async_gen)\n+            }\n+            GeneratorKind::Gen => stable_mir::mir::GeneratorKind::Gen,\n         }\n-        GeneratorKind::Gen => stable_mir::mir::GeneratorKind::Gen,\n     }\n }\n \n-fn rustc_inline_asm_operand_to_inline_asm_operand(\n-    operand: &rustc_middle::mir::InlineAsmOperand<'_>,\n-) -> stable_mir::mir::InlineAsmOperand {\n-    use rustc_middle::mir::InlineAsmOperand;\n+impl<'tcx> Stable for mir::InlineAsmOperand<'tcx> {\n+    type T = stable_mir::mir::InlineAsmOperand;\n+    fn stable(&self) -> Self::T {\n+        use rustc_middle::mir::InlineAsmOperand;\n \n-    let (in_value, out_place) = match operand {\n-        InlineAsmOperand::In { value, .. } => (Some(rustc_op_to_op(value)), None),\n-        InlineAsmOperand::Out { place, .. } => {\n-            (None, place.map(|place| rustc_place_to_place(&place)))\n-        }\n-        InlineAsmOperand::InOut { in_value, out_place, .. } => {\n-            (Some(rustc_op_to_op(in_value)), out_place.map(|place| rustc_place_to_place(&place)))\n-        }\n-        InlineAsmOperand::Const { .. }\n-        | InlineAsmOperand::SymFn { .. }\n-        | InlineAsmOperand::SymStatic { .. } => (None, None),\n-    };\n+        let (in_value, out_place) = match self {\n+            InlineAsmOperand::In { value, .. } => (Some(value.stable()), None),\n+            InlineAsmOperand::Out { place, .. } => (None, place.map(|place| place.stable())),\n+            InlineAsmOperand::InOut { in_value, out_place, .. } => {\n+                (Some(in_value.stable()), out_place.map(|place| place.stable()))\n+            }\n+            InlineAsmOperand::Const { .. }\n+            | InlineAsmOperand::SymFn { .. }\n+            | InlineAsmOperand::SymStatic { .. } => (None, None),\n+        };\n \n-    stable_mir::mir::InlineAsmOperand { in_value, out_place, raw_rpr: format!(\"{:?}\", operand) }\n+        stable_mir::mir::InlineAsmOperand { in_value, out_place, raw_rpr: format!(\"{:?}\", self) }\n+    }\n }\n \n-fn rustc_terminator_to_terminator(\n-    terminator: &rustc_middle::mir::Terminator<'_>,\n-) -> stable_mir::mir::Terminator {\n-    use rustc_middle::mir::TerminatorKind::*;\n-    use stable_mir::mir::Terminator;\n-    match &terminator.kind {\n-        Goto { target } => Terminator::Goto { target: target.as_usize() },\n-        SwitchInt { discr, targets } => Terminator::SwitchInt {\n-            discr: rustc_op_to_op(discr),\n-            targets: targets\n-                .iter()\n-                .map(|(value, target)| stable_mir::mir::SwitchTarget {\n-                    value,\n-                    target: target.as_usize(),\n-                })\n-                .collect(),\n-            otherwise: targets.otherwise().as_usize(),\n-        },\n-        Resume => Terminator::Resume,\n-        Terminate => Terminator::Abort,\n-        Return => Terminator::Return,\n-        Unreachable => Terminator::Unreachable,\n-        Drop { place, target, unwind, replace: _ } => Terminator::Drop {\n-            place: rustc_place_to_place(place),\n-            target: target.as_usize(),\n-            unwind: rustc_unwind_to_unwind(unwind),\n-        },\n-        Call { func, args, destination, target, unwind, from_hir_call: _, fn_span: _ } => {\n-            Terminator::Call {\n-                func: rustc_op_to_op(func),\n-                args: args.iter().map(|arg| rustc_op_to_op(arg)).collect(),\n-                destination: rustc_place_to_place(destination),\n-                target: target.map(|t| t.as_usize()),\n-                unwind: rustc_unwind_to_unwind(unwind),\n-            }\n-        }\n-        Assert { cond, expected, msg, target, unwind } => Terminator::Assert {\n-            cond: rustc_op_to_op(cond),\n-            expected: *expected,\n-            msg: rustc_assert_msg_to_msg(msg),\n-            target: target.as_usize(),\n-            unwind: rustc_unwind_to_unwind(unwind),\n-        },\n-        InlineAsm { template, operands, options, line_spans, destination, unwind } => {\n-            Terminator::InlineAsm {\n-                template: format!(\"{:?}\", template),\n-                operands: operands\n+impl<'tcx> Stable for mir::Terminator<'tcx> {\n+    type T = stable_mir::mir::Terminator;\n+    fn stable(&self) -> Self::T {\n+        use rustc_middle::mir::TerminatorKind::*;\n+        use stable_mir::mir::Terminator;\n+        match &self.kind {\n+            Goto { target } => Terminator::Goto { target: target.as_usize() },\n+            SwitchInt { discr, targets } => Terminator::SwitchInt {\n+                discr: discr.stable(),\n+                targets: targets\n                     .iter()\n-                    .map(|operand| rustc_inline_asm_operand_to_inline_asm_operand(operand))\n+                    .map(|(value, target)| stable_mir::mir::SwitchTarget {\n+                        value,\n+                        target: target.as_usize(),\n+                    })\n                     .collect(),\n-                options: format!(\"{:?}\", options),\n-                line_spans: format!(\"{:?}\", line_spans),\n-                destination: destination.map(|d| d.as_usize()),\n-                unwind: rustc_unwind_to_unwind(unwind),\n+                otherwise: targets.otherwise().as_usize(),\n+            },\n+            Resume => Terminator::Resume,\n+            Terminate => Terminator::Abort,\n+            Return => Terminator::Return,\n+            Unreachable => Terminator::Unreachable,\n+            Drop { place, target, unwind, replace: _ } => Terminator::Drop {\n+                place: place.stable(),\n+                target: target.as_usize(),\n+                unwind: unwind.stable(),\n+            },\n+            Call { func, args, destination, target, unwind, from_hir_call: _, fn_span: _ } => {\n+                Terminator::Call {\n+                    func: func.stable(),\n+                    args: args.iter().map(|arg| arg.stable()).collect(),\n+                    destination: destination.stable(),\n+                    target: target.map(|t| t.as_usize()),\n+                    unwind: unwind.stable(),\n+                }\n+            }\n+            Assert { cond, expected, msg, target, unwind } => Terminator::Assert {\n+                cond: cond.stable(),\n+                expected: *expected,\n+                msg: rustc_assert_msg_to_msg(msg),\n+                target: target.as_usize(),\n+                unwind: unwind.stable(),\n+            },\n+            InlineAsm { template, operands, options, line_spans, destination, unwind } => {\n+                Terminator::InlineAsm {\n+                    template: format!(\"{:?}\", template),\n+                    operands: operands.iter().map(|operand| operand.stable()).collect(),\n+                    options: format!(\"{:?}\", options),\n+                    line_spans: format!(\"{:?}\", line_spans),\n+                    destination: destination.map(|d| d.as_usize()),\n+                    unwind: unwind.stable(),\n+                }\n             }\n+            Yield { .. } | GeneratorDrop | FalseEdge { .. } | FalseUnwind { .. } => unreachable!(),\n         }\n-        Yield { .. } | GeneratorDrop | FalseEdge { .. } | FalseUnwind { .. } => unreachable!(),\n     }\n }"}, {"sha": "f444a7f24bb722d80a84d82923f09d8496101326", "filename": "compiler/rustc_target/src/spec/loongarch64_unknown_none_softfloat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/compiler%2Frustc_target%2Fsrc%2Fspec%2Floongarch64_unknown_none_softfloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/compiler%2Frustc_target%2Fsrc%2Fspec%2Floongarch64_unknown_none_softfloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Floongarch64_unknown_none_softfloat.rs?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -3,7 +3,7 @@ use super::{Target, TargetOptions};\n \n pub fn target() -> Target {\n     Target {\n-        llvm_target: \"loongarch64-unknown-none-softfloat\".into(),\n+        llvm_target: \"loongarch64-unknown-none\".into(),\n         pointer_width: 64,\n         data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n64-S128\".into(),\n         arch: \"loongarch64\".into(),"}, {"sha": "190a78f6a8ecd55cea0e3a1a516d07a1c394c01a", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -23,7 +23,7 @@ use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::visit::{TypeVisitable, TypeVisitableExt};\n-use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt, TypeVisitor};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitor};\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n use std::fmt::Debug;\n@@ -170,8 +170,8 @@ fn overlap<'tcx>(\n     overlap_mode: OverlapMode,\n ) -> Option<OverlapResult<'tcx>> {\n     if overlap_mode.use_negative_impl() {\n-        if negative_impl(tcx, impl1_def_id, impl2_def_id)\n-            || negative_impl(tcx, impl2_def_id, impl1_def_id)\n+        if impl_intersection_has_negative_obligation(tcx, impl1_def_id, impl2_def_id)\n+            || impl_intersection_has_negative_obligation(tcx, impl2_def_id, impl1_def_id)\n         {\n             return None;\n         }\n@@ -198,13 +198,21 @@ fn overlap<'tcx>(\n     let impl1_header = with_fresh_ty_vars(selcx, param_env, impl1_def_id);\n     let impl2_header = with_fresh_ty_vars(selcx, param_env, impl2_def_id);\n \n-    let obligations = equate_impl_headers(selcx.infcx, &impl1_header, &impl2_header)?;\n+    // Equate the headers to find their intersection (the general type, with infer vars,\n+    // that may apply both impls).\n+    let equate_obligations = equate_impl_headers(selcx.infcx, &impl1_header, &impl2_header)?;\n     debug!(\"overlap: unification check succeeded\");\n \n-    if overlap_mode.use_implicit_negative() {\n-        if implicit_negative(selcx, param_env, &impl1_header, impl2_header, obligations) {\n-            return None;\n-        }\n+    if overlap_mode.use_implicit_negative()\n+        && impl_intersection_has_impossible_obligation(\n+            selcx,\n+            param_env,\n+            &impl1_header,\n+            impl2_header,\n+            equate_obligations,\n+        )\n+    {\n+        return None;\n     }\n \n     // We toggle the `leak_check` by using `skip_leak_check` when constructing the\n@@ -250,52 +258,38 @@ fn equate_impl_headers<'tcx>(\n     result.map(|infer_ok| infer_ok.obligations).ok()\n }\n \n-/// Given impl1 and impl2 check if both impls can be satisfied by a common type (including\n-/// where-clauses) If so, return false, otherwise return true, they are disjoint.\n-fn implicit_negative<'cx, 'tcx>(\n+/// Check if both impls can be satisfied by a common type by considering whether\n+/// any of either impl's obligations is not known to hold.\n+///\n+/// For example, given these two impls:\n+///     `impl From<MyLocalType> for Box<dyn Error>` (in my crate)\n+///     `impl<E> From<E> for Box<dyn Error> where E: Error` (in libstd)\n+///\n+/// After replacing both impl headers with inference vars (which happens before\n+/// this function is called), we get:\n+///     `Box<dyn Error>: From<MyLocalType>`\n+///     `Box<dyn Error>: From<?E>`\n+///\n+/// This gives us `?E = MyLocalType`. We then certainly know that `MyLocalType: Error`\n+/// never holds in intercrate mode since a local impl does not exist, and a\n+/// downstream impl cannot be added -- therefore can consider the intersection\n+/// of the two impls above to be empty.\n+///\n+/// Importantly, this works even if there isn't a `impl !Error for MyLocalType`.\n+fn impl_intersection_has_impossible_obligation<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     impl1_header: &ty::ImplHeader<'tcx>,\n     impl2_header: ty::ImplHeader<'tcx>,\n     obligations: PredicateObligations<'tcx>,\n ) -> bool {\n-    // There's no overlap if obligations are unsatisfiable or if the obligation negated is\n-    // satisfied.\n-    //\n-    // For example, given these two impl headers:\n-    //\n-    // `impl<'a> From<&'a str> for Box<dyn Error>`\n-    // `impl<E> From<E> for Box<dyn Error> where E: Error`\n-    //\n-    // So we have:\n-    //\n-    // `Box<dyn Error>: From<&'?a str>`\n-    // `Box<dyn Error>: From<?E>`\n-    //\n-    // After equating the two headers:\n-    //\n-    // `Box<dyn Error> = Box<dyn Error>`\n-    // So, `?E = &'?a str` and then given the where clause `&'?a str: Error`.\n-    //\n-    // If the obligation `&'?a str: Error` holds, it means that there's overlap. If that doesn't\n-    // hold we need to check if `&'?a str: !Error` holds, if doesn't hold there's overlap because\n-    // at some point an impl for `&'?a str: Error` could be added.\n-    debug!(\n-        \"implicit_negative(impl1_header={:?}, impl2_header={:?}, obligations={:?})\",\n-        impl1_header, impl2_header, obligations\n-    );\n     let infcx = selcx.infcx;\n-    let opt_failing_obligation = impl1_header\n-        .predicates\n-        .iter()\n-        .copied()\n-        .chain(impl2_header.predicates)\n-        .map(|p| infcx.resolve_vars_if_possible(p))\n-        .map(|p| Obligation {\n-            cause: ObligationCause::dummy(),\n-            param_env,\n-            recursion_depth: 0,\n-            predicate: p,\n+\n+    let opt_failing_obligation = [&impl1_header.predicates, &impl2_header.predicates]\n+        .into_iter()\n+        .flatten()\n+        .map(|&predicate| {\n+            Obligation::new(infcx.tcx, ObligationCause::dummy(), param_env, predicate)\n         })\n         .chain(obligations)\n         .find(|o| !selcx.predicate_may_hold_fatal(o));\n@@ -308,9 +302,27 @@ fn implicit_negative<'cx, 'tcx>(\n     }\n }\n \n-/// Given impl1 and impl2 check if both impls are never satisfied by a common type (including\n-/// where-clauses) If so, return true, they are disjoint and false otherwise.\n-fn negative_impl(tcx: TyCtxt<'_>, impl1_def_id: DefId, impl2_def_id: DefId) -> bool {\n+/// Check if both impls can be satisfied by a common type by considering whether\n+/// any of first impl's obligations is known not to hold *via a negative predicate*.\n+///\n+/// For example, given these two impls:\n+///     `struct MyCustomBox<T: ?Sized>(Box<T>);`\n+///     `impl From<&str> for MyCustomBox<dyn Error>` (in my crate)\n+///     `impl<E> From<E> for MyCustomBox<dyn Error> where E: Error` (in my crate)\n+///\n+/// After replacing the second impl's header with inference vars, we get:\n+///     `MyCustomBox<dyn Error>: From<&str>`\n+///     `MyCustomBox<dyn Error>: From<?E>`\n+///\n+/// This gives us `?E = &str`. We then try to prove the first impl's predicates\n+/// after negating, giving us `&str: !Error`. This is a negative impl provided by\n+/// libstd, and therefore we can guarantee for certain that libstd will never add\n+/// a positive impl for `&str: Error` (without it being a breaking change).\n+fn impl_intersection_has_negative_obligation(\n+    tcx: TyCtxt<'_>,\n+    impl1_def_id: DefId,\n+    impl2_def_id: DefId,\n+) -> bool {\n     debug!(\"negative_impl(impl1_def_id={:?}, impl2_def_id={:?})\", impl1_def_id, impl2_def_id);\n \n     // Create an infcx, taking the predicates of impl1 as assumptions:\n@@ -336,57 +348,45 @@ fn negative_impl(tcx: TyCtxt<'_>, impl1_def_id: DefId, impl2_def_id: DefId) -> b\n     // Attempt to prove that impl2 applies, given all of the above.\n     let selcx = &mut SelectionContext::new(&infcx);\n     let impl2_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl2_def_id);\n-    let (subject2, obligations) =\n+    let (subject2, normalization_obligations) =\n         impl_subject_and_oblig(selcx, impl_env, impl2_def_id, impl2_substs, |_, _| {\n             ObligationCause::dummy()\n         });\n \n-    !equate(&infcx, impl_env, subject1, subject2, obligations, impl1_def_id)\n-}\n-\n-fn equate<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-    impl_env: ty::ParamEnv<'tcx>,\n-    subject1: ImplSubject<'tcx>,\n-    subject2: ImplSubject<'tcx>,\n-    obligations: impl Iterator<Item = PredicateObligation<'tcx>>,\n-    body_def_id: DefId,\n-) -> bool {\n-    // do the impls unify? If not, not disjoint.\n-    let Ok(InferOk { obligations: more_obligations, .. }) =\n+    // do the impls unify? If not, then it's not currently possible to prove any\n+    // obligations about their intersection.\n+    let Ok(InferOk { obligations: equate_obligations, .. }) =\n         infcx.at(&ObligationCause::dummy(), impl_env).eq(DefineOpaqueTypes::No,subject1, subject2)\n     else {\n         debug!(\"explicit_disjoint: {:?} does not unify with {:?}\", subject1, subject2);\n-        return true;\n+        return false;\n     };\n \n-    let opt_failing_obligation = obligations\n-        .into_iter()\n-        .chain(more_obligations)\n-        .find(|o| negative_impl_exists(infcx, o, body_def_id));\n-\n-    if let Some(failing_obligation) = opt_failing_obligation {\n-        debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n-        false\n-    } else {\n-        true\n+    for obligation in normalization_obligations.into_iter().chain(equate_obligations) {\n+        if negative_impl_exists(&infcx, &obligation, impl1_def_id) {\n+            debug!(\"overlap: obligation unsatisfiable {:?}\", obligation);\n+            return true;\n+        }\n     }\n+\n+    false\n }\n \n-/// Try to prove that a negative impl exist for the given obligation and its super predicates.\n+/// Try to prove that a negative impl exist for the obligation or its supertraits.\n+///\n+/// If such a negative impl exists, then the obligation definitely must not hold\n+/// due to coherence, even if it's not necessarily \"knowable\" in this crate. Any\n+/// valid impl downstream would not be able to exist due to the overlapping\n+/// negative impl.\n #[instrument(level = \"debug\", skip(infcx))]\n fn negative_impl_exists<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     o: &PredicateObligation<'tcx>,\n     body_def_id: DefId,\n ) -> bool {\n-    if resolve_negative_obligation(infcx.fork(), o, body_def_id) {\n-        return true;\n-    }\n-\n     // Try to prove a negative obligation exists for super predicates\n     for pred in util::elaborate(infcx.tcx, iter::once(o.predicate)) {\n-        if resolve_negative_obligation(infcx.fork(), &o.with(infcx.tcx, pred), body_def_id) {\n+        if prove_negated_obligation(infcx.fork(), &o.with(infcx.tcx, pred), body_def_id) {\n             return true;\n         }\n     }\n@@ -395,7 +395,7 @@ fn negative_impl_exists<'tcx>(\n }\n \n #[instrument(level = \"debug\", skip(infcx))]\n-fn resolve_negative_obligation<'tcx>(\n+fn prove_negated_obligation<'tcx>(\n     infcx: InferCtxt<'tcx>,\n     o: &PredicateObligation<'tcx>,\n     body_def_id: DefId,"}, {"sha": "5acd7b573dd9a0169cbca56e353638d48c297fd2", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -365,7 +365,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n \n                     if !candidate_set.ambiguous && no_candidates_apply {\n-                        let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                        let trait_ref = self.infcx.resolve_vars_if_possible(\n+                            stack.obligation.predicate.skip_binder().trait_ref,\n+                        );\n                         if !trait_ref.references_error() {\n                             let self_ty = trait_ref.self_ty();\n                             let (trait_desc, self_desc) = with_no_trimmed_paths!({"}, {"sha": "6a6cbe905e464a35523542fe5f5b6fc5df21fe57", "filename": "library/core/src/iter/sources/successors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fsuccessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fsuccessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fsuccessors.rs?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -22,7 +22,7 @@ where\n     Successors { next: first, succ }\n }\n \n-/// An new iterator where each successive item is computed based on the preceding one.\n+/// A new iterator where each successive item is computed based on the preceding one.\n ///\n /// This `struct` is created by the [`iter::successors()`] function.\n /// See its documentation for more."}, {"sha": "75aa0c2b2a275a4afb2b96cfe8819daa9f724ddf", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/browser-ui-test.version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -1 +1 @@\n-0.16.6\n\\ No newline at end of file\n+0.16.7\n\\ No newline at end of file"}, {"sha": "af1bc05ddb248f1dbccb6aa1fd7c9e0fcbcc298a", "filename": "src/tools/rustdoc-gui/tester.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/src%2Ftools%2Frustdoc-gui%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/src%2Ftools%2Frustdoc-gui%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-gui%2Ftester.js?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -201,8 +201,8 @@ async function main(argv) {\n     try {\n         // This is more convenient that setting fields one by one.\n         const args = [\n-            \"--variable\", \"DOC_PATH\", opts[\"doc_folder\"], \"--enable-fail-on-js-error\",\n-            \"--allow-file-access-from-files\",\n+            \"--variable\", \"DOC_PATH\", opts[\"doc_folder\"].split(\"\\\\\").join(\"/\"),\n+            \"--enable-fail-on-js-error\", \"--allow-file-access-from-files\",\n         ];\n         if (opts[\"debug\"]) {\n             debug = true;"}, {"sha": "2c61ee5428b8605b2e7eb720bd6c7aa117e41ec2", "filename": "tests/rustdoc-gui/shortcuts.goml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Frustdoc-gui%2Fshortcuts.goml", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Frustdoc-gui%2Fshortcuts.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fshortcuts.goml?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -13,7 +13,7 @@ press-key: \"Escape\"\n assert-css: (\"#help-button .popover\", {\"display\": \"none\"})\n // Checking doc collapse and expand.\n // It should be displaying a \"-\":\n-assert-text: (\"#toggle-all-docs\", \"[\\u2212]\")\n+assert-text: (\"#toggle-all-docs\", \"[\u2212]\")\n press-key: \"-\"\n wait-for-text: (\"#toggle-all-docs\", \"[+]\")\n assert-attribute: (\"#toggle-all-docs\", {\"class\": \"will-expand\"})\n@@ -23,9 +23,9 @@ assert-text: (\"#toggle-all-docs\", \"[+]\")\n assert-attribute: (\"#toggle-all-docs\", {\"class\": \"will-expand\"})\n // Expanding now.\n press-key: \"+\"\n-wait-for-text: (\"#toggle-all-docs\", \"[\\u2212]\")\n+wait-for-text: (\"#toggle-all-docs\", \"[\u2212]\")\n assert-attribute: (\"#toggle-all-docs\", {\"class\": \"\"})\n // Pressing it again shouldn't do anything.\n press-key: \"+\"\n-assert-text: (\"#toggle-all-docs\", \"[\\u2212]\")\n+assert-text: (\"#toggle-all-docs\", \"[\u2212]\")\n assert-attribute: (\"#toggle-all-docs\", {\"class\": \"\"})"}, {"sha": "f8f73398d9b99294e88311b1dbb6be6d04cc0351", "filename": "tests/rustdoc-gui/source-code-page.goml", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Frustdoc-gui%2Fsource-code-page.goml", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Frustdoc-gui%2Fsource-code-page.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsource-code-page.goml?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -64,23 +64,23 @@ call-function: (\"check-colors\", {\n compare-elements-position: (\"//*[@id='1']\", \".rust > code > span\", (\"y\"))\n // Check the `href` property so that users can treat anchors as links.\n assert-property: (\".src-line-numbers > a:nth-child(1)\", {\n-    \"href\": \"file://\" + |DOC_PATH| + \"/src/test_docs/lib.rs.html#1\"\n-})\n+    \"href\": |DOC_PATH| + \"/src/test_docs/lib.rs.html#1\"\n+}, ENDS_WITH)\n assert-property: (\".src-line-numbers > a:nth-child(2)\", {\n-    \"href\": \"file://\" + |DOC_PATH| + \"/src/test_docs/lib.rs.html#2\"\n-})\n+    \"href\": |DOC_PATH| + \"/src/test_docs/lib.rs.html#2\"\n+}, ENDS_WITH)\n assert-property: (\".src-line-numbers > a:nth-child(3)\", {\n-    \"href\": \"file://\" + |DOC_PATH| + \"/src/test_docs/lib.rs.html#3\"\n-})\n+    \"href\": |DOC_PATH| + \"/src/test_docs/lib.rs.html#3\"\n+}, ENDS_WITH)\n assert-property: (\".src-line-numbers > a:nth-child(4)\", {\n-    \"href\": \"file://\" + |DOC_PATH| + \"/src/test_docs/lib.rs.html#4\"\n-})\n+    \"href\": |DOC_PATH| + \"/src/test_docs/lib.rs.html#4\"\n+}, ENDS_WITH)\n assert-property: (\".src-line-numbers > a:nth-child(5)\", {\n-    \"href\": \"file://\" + |DOC_PATH| + \"/src/test_docs/lib.rs.html#5\"\n-})\n+    \"href\": |DOC_PATH| + \"/src/test_docs/lib.rs.html#5\"\n+}, ENDS_WITH)\n assert-property: (\".src-line-numbers > a:nth-child(6)\", {\n-    \"href\": \"file://\" + |DOC_PATH| + \"/src/test_docs/lib.rs.html#6\"\n-})\n+    \"href\": |DOC_PATH| + \"/src/test_docs/lib.rs.html#6\"\n+}, ENDS_WITH)\n \n // Assert that the line numbers text is aligned to the right.\n assert-css: (\".src-line-numbers\", {\"text-align\": \"right\"})"}, {"sha": "f604ada6ac760b1757983d5f625abf83bc210649", "filename": "tests/ui/impl-trait/in-trait/method-signature-matches.lt.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.lt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.lt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.lt.stderr?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -0,0 +1,21 @@\n+error[E0053]: method `early` has an incompatible type for trait\n+  --> $DIR/method-signature-matches.rs:58:27\n+   |\n+LL |     fn early<'late, T>(_: &'late ()) {}\n+   |                     -     ^^^^^^^^^\n+   |                     |     |\n+   |                     |     expected type parameter `T`, found `()`\n+   |                     |     help: change the parameter type to match the trait: `&'early T`\n+   |                     this type parameter\n+   |\n+note: type in trait\n+  --> $DIR/method-signature-matches.rs:53:28\n+   |\n+LL |     fn early<'early, T>(x: &'early T) -> impl Sized;\n+   |                            ^^^^^^^^^\n+   = note: expected signature `fn(&'early T)`\n+              found signature `fn(&())`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0053`."}, {"sha": "d3183b92e8400acc7f6d949ac3a88f3357cba14f", "filename": "tests/ui/impl-trait/in-trait/method-signature-matches.mismatch.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.mismatch.stderr?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -0,0 +1,20 @@\n+error[E0053]: method `owo` has an incompatible type for trait\n+  --> $DIR/method-signature-matches.rs:14:15\n+   |\n+LL |     fn owo(_: u8) {}\n+   |               ^^\n+   |               |\n+   |               expected `()`, found `u8`\n+   |               help: change the parameter type to match the trait: `()`\n+   |\n+note: type in trait\n+  --> $DIR/method-signature-matches.rs:9:15\n+   |\n+LL |     fn owo(x: ()) -> impl Sized;\n+   |               ^^\n+   = note: expected signature `fn(())`\n+              found signature `fn(u8)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0053`."}, {"sha": "80fda1c9fe14e4f1f6e4d510e39d5ea75b74c022", "filename": "tests/ui/impl-trait/in-trait/method-signature-matches.mismatch_async.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.mismatch_async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.mismatch_async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.mismatch_async.stderr?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -0,0 +1,20 @@\n+error[E0053]: method `owo` has an incompatible type for trait\n+  --> $DIR/method-signature-matches.rs:25:21\n+   |\n+LL |     async fn owo(_: u8) {}\n+   |                     ^^\n+   |                     |\n+   |                     expected `()`, found `u8`\n+   |                     help: change the parameter type to match the trait: `()`\n+   |\n+note: type in trait\n+  --> $DIR/method-signature-matches.rs:20:21\n+   |\n+LL |     async fn owo(x: ()) {}\n+   |                     ^^\n+   = note: expected signature `fn(()) -> _`\n+              found signature `fn(u8) -> _`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0053`."}, {"sha": "294f93b30d0eed722dd6ebcaac46f783b7a14473", "filename": "tests/ui/impl-trait/in-trait/method-signature-matches.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.rs?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -1,51 +1,62 @@\n // edition: 2021\n+// revisions: mismatch mismatch_async too_many too_few lt\n \n #![feature(return_position_impl_trait_in_trait, async_fn_in_trait)]\n #![allow(incomplete_features)]\n \n+#[cfg(mismatch)]\n trait Uwu {\n     fn owo(x: ()) -> impl Sized;\n }\n \n+#[cfg(mismatch)]\n impl Uwu for () {\n     fn owo(_: u8) {}\n-    //~^ ERROR method `owo` has an incompatible type for trait\n+    //[mismatch]~^ ERROR method `owo` has an incompatible type for trait\n }\n \n+#[cfg(mismatch_async)]\n trait AsyncUwu {\n     async fn owo(x: ()) {}\n }\n \n+#[cfg(mismatch_async)]\n impl AsyncUwu for () {\n     async fn owo(_: u8) {}\n-    //~^ ERROR method `owo` has an incompatible type for trait\n+    //[mismatch_async]~^ ERROR method `owo` has an incompatible type for trait\n }\n \n+#[cfg(too_many)]\n trait TooMuch {\n     fn calm_down_please() -> impl Sized;\n }\n \n+#[cfg(too_many)]\n impl TooMuch for () {\n     fn calm_down_please(_: (), _: (), _: ()) {}\n-    //~^ ERROR method `calm_down_please` has 3 parameters but the declaration in trait `TooMuch::calm_down_please` has 0\n+    //[too_many]~^ ERROR method `calm_down_please` has 3 parameters but the declaration in trait `TooMuch::calm_down_please` has 0\n }\n \n+#[cfg(too_few)]\n trait TooLittle {\n     fn come_on_a_little_more_effort(_: (), _: (), _: ()) -> impl Sized;\n }\n \n+#[cfg(too_few)]\n impl TooLittle for () {\n     fn come_on_a_little_more_effort() {}\n-    //~^ ERROR method `come_on_a_little_more_effort` has 0 parameters but the declaration in trait `TooLittle::come_on_a_little_more_effort` has 3\n+    //[too_few]~^ ERROR method `come_on_a_little_more_effort` has 0 parameters but the declaration in trait `TooLittle::come_on_a_little_more_effort` has 3\n }\n \n+#[cfg(lt)]\n trait Lifetimes {\n     fn early<'early, T>(x: &'early T) -> impl Sized;\n }\n \n+#[cfg(lt)]\n impl Lifetimes for () {\n     fn early<'late, T>(_: &'late ()) {}\n-    //~^ ERROR method `early` has an incompatible type for trait\n+    //[lt]~^ ERROR method `early` has an incompatible type for trait\n }\n \n fn main() {}"}, {"sha": "3ec62020e6c89c41077a681f599a9856cc2cb05a", "filename": "tests/ui/impl-trait/in-trait/method-signature-matches.stderr", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0b475c705f36fb3b0a63994b92f2bbd2f5865b07/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b475c705f36fb3b0a63994b92f2bbd2f5865b07/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.stderr?ref=0b475c705f36fb3b0a63994b92f2bbd2f5865b07", "patch": "@@ -1,74 +0,0 @@\n-error[E0053]: method `owo` has an incompatible type for trait\n-  --> $DIR/method-signature-matches.rs:11:15\n-   |\n-LL |     fn owo(_: u8) {}\n-   |               ^^\n-   |               |\n-   |               expected `()`, found `u8`\n-   |               help: change the parameter type to match the trait: `()`\n-   |\n-note: type in trait\n-  --> $DIR/method-signature-matches.rs:7:15\n-   |\n-LL |     fn owo(x: ()) -> impl Sized;\n-   |               ^^\n-   = note: expected signature `fn(())`\n-              found signature `fn(u8)`\n-\n-error[E0053]: method `owo` has an incompatible type for trait\n-  --> $DIR/method-signature-matches.rs:20:21\n-   |\n-LL |     async fn owo(_: u8) {}\n-   |                     ^^\n-   |                     |\n-   |                     expected `()`, found `u8`\n-   |                     help: change the parameter type to match the trait: `()`\n-   |\n-note: type in trait\n-  --> $DIR/method-signature-matches.rs:16:21\n-   |\n-LL |     async fn owo(x: ()) {}\n-   |                     ^^\n-   = note: expected signature `fn(()) -> _`\n-              found signature `fn(u8) -> _`\n-\n-error[E0050]: method `calm_down_please` has 3 parameters but the declaration in trait `TooMuch::calm_down_please` has 0\n-  --> $DIR/method-signature-matches.rs:29:28\n-   |\n-LL |     fn calm_down_please() -> impl Sized;\n-   |     ------------------------------------ trait requires 0 parameters\n-...\n-LL |     fn calm_down_please(_: (), _: (), _: ()) {}\n-   |                            ^^^^^^^^^^^^^^^^ expected 0 parameters, found 3\n-\n-error[E0050]: method `come_on_a_little_more_effort` has 0 parameters but the declaration in trait `TooLittle::come_on_a_little_more_effort` has 3\n-  --> $DIR/method-signature-matches.rs:38:5\n-   |\n-LL |     fn come_on_a_little_more_effort(_: (), _: (), _: ()) -> impl Sized;\n-   |                                        ---------------- trait requires 3 parameters\n-...\n-LL |     fn come_on_a_little_more_effort() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 3 parameters, found 0\n-\n-error[E0053]: method `early` has an incompatible type for trait\n-  --> $DIR/method-signature-matches.rs:47:27\n-   |\n-LL |     fn early<'late, T>(_: &'late ()) {}\n-   |                     -     ^^^^^^^^^\n-   |                     |     |\n-   |                     |     expected type parameter `T`, found `()`\n-   |                     |     help: change the parameter type to match the trait: `&'early T`\n-   |                     this type parameter\n-   |\n-note: type in trait\n-  --> $DIR/method-signature-matches.rs:43:28\n-   |\n-LL |     fn early<'early, T>(x: &'early T) -> impl Sized;\n-   |                            ^^^^^^^^^\n-   = note: expected signature `fn(&'early T)`\n-              found signature `fn(&())`\n-\n-error: aborting due to 5 previous errors\n-\n-Some errors have detailed explanations: E0050, E0053.\n-For more information about an error, try `rustc --explain E0050`."}, {"sha": "24bcfeb748fd0b58a2c8ef7a7e1ffc23779a91ea", "filename": "tests/ui/impl-trait/in-trait/method-signature-matches.too_few.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.too_few.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.too_few.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.too_few.stderr?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -0,0 +1,12 @@\n+error[E0050]: method `come_on_a_little_more_effort` has 0 parameters but the declaration in trait `TooLittle::come_on_a_little_more_effort` has 3\n+  --> $DIR/method-signature-matches.rs:47:5\n+   |\n+LL |     fn come_on_a_little_more_effort(_: (), _: (), _: ()) -> impl Sized;\n+   |                                        ---------------- trait requires 3 parameters\n+...\n+LL |     fn come_on_a_little_more_effort() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 3 parameters, found 0\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0050`."}, {"sha": "616cbd2905c794ac17a8e0181f6618008f003f95", "filename": "tests/ui/impl-trait/in-trait/method-signature-matches.too_many.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.too_many.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.too_many.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.too_many.stderr?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -0,0 +1,12 @@\n+error[E0050]: method `calm_down_please` has 3 parameters but the declaration in trait `TooMuch::calm_down_please` has 0\n+  --> $DIR/method-signature-matches.rs:36:28\n+   |\n+LL |     fn calm_down_please() -> impl Sized;\n+   |     ------------------------------------ trait requires 0 parameters\n+...\n+LL |     fn calm_down_please(_: (), _: (), _: ()) {}\n+   |                            ^^^^^^^^^^^^^^^^ expected 0 parameters, found 3\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0050`."}, {"sha": "bf088ae8b25ccb48f8b68bfcba469e499fb441c5", "filename": "tests/ui/impl-trait/in-trait/unconstrained-lt.current.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Funconstrained-lt.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Funconstrained-lt.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Funconstrained-lt.current.stderr?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -0,0 +1,9 @@\n+error[E0207]: the lifetime parameter `'a` is not constrained by the impl trait, self type, or predicates\n+  --> $DIR/unconstrained-lt.rs:10:6\n+   |\n+LL | impl<'a, T> Foo for T {\n+   |      ^^ unconstrained lifetime parameter\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0207`."}, {"sha": "bf088ae8b25ccb48f8b68bfcba469e499fb441c5", "filename": "tests/ui/impl-trait/in-trait/unconstrained-lt.next.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Funconstrained-lt.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Funconstrained-lt.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Funconstrained-lt.next.stderr?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -0,0 +1,9 @@\n+error[E0207]: the lifetime parameter `'a` is not constrained by the impl trait, self type, or predicates\n+  --> $DIR/unconstrained-lt.rs:10:6\n+   |\n+LL | impl<'a, T> Foo for T {\n+   |      ^^ unconstrained lifetime parameter\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0207`."}, {"sha": "f966be43a6ef8977c744ee97873dcc0a380e208d", "filename": "tests/ui/impl-trait/in-trait/unconstrained-lt.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Funconstrained-lt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Fimpl-trait%2Fin-trait%2Funconstrained-lt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Funconstrained-lt.rs?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -0,0 +1,16 @@\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n+\n+#![feature(return_position_impl_trait_in_trait)]\n+\n+trait Foo {\n+    fn test() -> impl Sized;\n+}\n+\n+impl<'a, T> Foo for T {\n+    //~^ ERROR the lifetime parameter `'a` is not constrained by the impl trait, self type, or predicates\n+\n+    fn test() -> &'a () { &() }\n+}\n+\n+fn main() {}"}, {"sha": "5058d61b5880230867044a0406284c09b9ada637", "filename": "tests/ui/rust-2018/edition-lint-infer-outlives.fixed", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.fixed?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -801,4 +801,10 @@ where\n     yoo: &'a U\n }\n \n+// https://github.com/rust-lang/rust/issues/105150\n+struct InferredWhereBoundWithInlineBound<'a, T: ?Sized>\n+{\n+    data: &'a T,\n+}\n+\n fn main() {}"}, {"sha": "3f63cb8e90030a0087926def2e175f4cfc595994", "filename": "tests/ui/rust-2018/edition-lint-infer-outlives.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.rs?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -801,4 +801,12 @@ where\n     yoo: &'a U\n }\n \n+// https://github.com/rust-lang/rust/issues/105150\n+struct InferredWhereBoundWithInlineBound<'a, T: ?Sized>\n+//~^ ERROR outlives requirements can be inferred\n+    where T: 'a,\n+{\n+    data: &'a T,\n+}\n+\n fn main() {}"}, {"sha": "dbf301fd8a1b7b873b9092b55fc3b8d089613abd", "filename": "tests/ui/rust-2018/edition-lint-infer-outlives.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220/tests%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frust-2018%2Fedition-lint-infer-outlives.stderr?ref=8c74a5d27c644a0f7a22bb2fa8dd3ff8257bc220", "patch": "@@ -10,6 +10,15 @@ note: the lint level is defined here\n LL | #![deny(explicit_outlives_requirements)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives.rs:805:56\n+   |\n+LL |   struct InferredWhereBoundWithInlineBound<'a, T: ?Sized>\n+   |  ________________________________________________________^\n+LL | |\n+LL | |     where T: 'a,\n+   | |________________^ help: remove this bound\n+\n error: outlives requirements can be inferred\n   --> $DIR/edition-lint-infer-outlives.rs:26:31\n    |\n@@ -922,5 +931,5 @@ error: outlives requirements can be inferred\n LL |     union BeeWhereOutlivesAyTeeWhereDebug<'a, 'b, T> where 'b: 'a, T: Debug {\n    |                                                            ^^^^^^^^ help: remove this bound\n \n-error: aborting due to 153 previous errors\n+error: aborting due to 154 previous errors\n "}]}