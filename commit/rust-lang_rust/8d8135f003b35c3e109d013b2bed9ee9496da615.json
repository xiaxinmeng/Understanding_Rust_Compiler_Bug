{"sha": "8d8135f003b35c3e109d013b2bed9ee9496da615", "node_id": "C_kwDOAAsO6NoAKDhkODEzNWYwMDNiMzVjM2UxMDlkMDEzYjJiZWQ5ZWU5NDk2ZGE2MTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-24T12:50:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-24T12:50:00Z"}, "message": "Auto merge of #94876 - b-naber:thir-abstract-const-changes, r=lcnr\n\nChange Thir to lazily create constants\n\nTo allow `AbstractConst`s to work with the previous thir changes we made and those we want to make, i.e. to avoid problems due to `ValTree` and `ConstValue` conversions, we instead switch to a thir representation for constants that allows us to lazily create constants.\n\nr? `@oli-obk`", "tree": {"sha": "85610c6ffbd311c19f153e058ab6f67ca2c06ddc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85610c6ffbd311c19f153e058ab6f67ca2c06ddc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d8135f003b35c3e109d013b2bed9ee9496da615", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d8135f003b35c3e109d013b2bed9ee9496da615", "html_url": "https://github.com/rust-lang/rust/commit/8d8135f003b35c3e109d013b2bed9ee9496da615", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d8135f003b35c3e109d013b2bed9ee9496da615/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2df372bca13bb60979c909660e69f2451630e81", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2df372bca13bb60979c909660e69f2451630e81", "html_url": "https://github.com/rust-lang/rust/commit/d2df372bca13bb60979c909660e69f2451630e81"}, {"sha": "19041d995de9e3b2e4f6be46b2d77c0f19c607f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/19041d995de9e3b2e4f6be46b2d77c0f19c607f7", "html_url": "https://github.com/rust-lang/rust/commit/19041d995de9e3b2e4f6be46b2d77c0f19c607f7"}], "stats": {"total": 501, "additions": 346, "deletions": 155}, "files": [{"sha": "87af90d059b54b2eacd675d75eba2ea1994aedf6", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -955,6 +955,7 @@ rustc_queries! {\n         desc { \"get a &core::panic::Location referring to a span\" }\n     }\n \n+    // FIXME get rid of this with valtrees\n     query lit_to_const(\n         key: LitToConstInput<'tcx>\n     ) -> Result<ty::Const<'tcx>, LitToConstError> {"}, {"sha": "170a49124c65673ad8491d2b80958f78ce0f5c11", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -369,7 +369,8 @@ pub enum ExprKind<'tcx> {\n     },\n     /// An inline `const` block, e.g. `const {}`.\n     ConstBlock {\n-        value: Const<'tcx>,\n+        did: DefId,\n+        substs: SubstsRef<'tcx>,\n     },\n     /// An array literal constructed from one repeated element, e.g. `[1; 5]`.\n     Repeat {\n@@ -408,13 +409,25 @@ pub enum ExprKind<'tcx> {\n     },\n     /// A literal.\n     Literal {\n-        literal: Const<'tcx>,\n+        lit: &'tcx hir::Lit,\n+        neg: bool,\n+    },\n+    /// For literals that don't correspond to anything in the HIR\n+    NonHirLiteral {\n+        lit: ty::ScalarInt,\n+        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n+    },\n+    /// Associated constants and named constants\n+    NamedConst {\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n-        /// The `DefId` of the `const` item this literal\n-        /// was produced from, if this is not a user-written\n-        /// literal value.\n-        const_id: Option<DefId>,\n     },\n+    ConstParam {\n+        param: ty::ParamConst,\n+        def_id: DefId,\n+    },\n+    // FIXME improve docs for `StaticRef` by distinguishing it from `NamedConst`\n     /// A literal containing the address of a `static`.\n     ///\n     /// This is only distinguished from `Literal` so that we can register some\n@@ -439,6 +452,12 @@ pub enum ExprKind<'tcx> {\n     },\n }\n \n+impl<'tcx> ExprKind<'tcx> {\n+    pub fn zero_sized_literal(user_ty: Option<Canonical<'tcx, UserType<'tcx>>>) -> Self {\n+        ExprKind::NonHirLiteral { lit: ty::ScalarInt::ZST, user_ty }\n+    }\n+}\n+\n /// Represents the association of a field identifier and an expression.\n ///\n /// This is used in struct constructors."}, {"sha": "451fa4663877128b9889e467ad331acb33f06ab6", "filename": "compiler/rustc_middle/src/thir/visit.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -1,7 +1,6 @@\n use super::{\n     Arm, Block, Expr, ExprKind, Guard, InlineAsmOperand, Pat, PatKind, Stmt, StmtKind, Thir,\n };\n-use rustc_middle::ty::Const;\n \n pub trait Visitor<'a, 'tcx: 'a>: Sized {\n     fn thir(&self) -> &'a Thir<'tcx>;\n@@ -25,8 +24,6 @@ pub trait Visitor<'a, 'tcx: 'a>: Sized {\n     fn visit_pat(&mut self, pat: &Pat<'tcx>) {\n         walk_pat(self, pat);\n     }\n-\n-    fn visit_const(&mut self, _cnst: Const<'tcx>) {}\n }\n \n pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Expr<'tcx>) {\n@@ -93,10 +90,9 @@ pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Exp\n                 visitor.visit_expr(&visitor.thir()[value])\n             }\n         }\n-        ConstBlock { value } => visitor.visit_const(value),\n-        Repeat { value, count } => {\n+        ConstBlock { did: _, substs: _ } => {}\n+        Repeat { value, count: _ } => {\n             visitor.visit_expr(&visitor.thir()[value]);\n-            visitor.visit_const(count);\n         }\n         Array { ref fields } | Tuple { ref fields } => {\n             for &field in &**fields {\n@@ -122,7 +118,10 @@ pub fn walk_expr<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, expr: &Exp\n             visitor.visit_expr(&visitor.thir()[source])\n         }\n         Closure { closure_id: _, substs: _, upvars: _, movability: _, fake_reads: _ } => {}\n-        Literal { literal, user_ty: _, const_id: _ } => visitor.visit_const(literal),\n+        Literal { lit: _, neg: _ } => {}\n+        NonHirLiteral { lit: _, user_ty: _ } => {}\n+        NamedConst { def_id: _, substs: _, user_ty: _ } => {}\n+        ConstParam { param: _, def_id: _ } => {}\n         StaticRef { alloc_id: _, ty: _, def_id: _ } => {}\n         InlineAsm { ref operands, template: _, options: _, line_spans: _ } => {\n             for op in &**operands {\n@@ -209,11 +208,8 @@ pub fn walk_pat<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, pat: &Pat<'\n                 visitor.visit_pat(&subpattern.pattern);\n             }\n         }\n-        Constant { value } => visitor.visit_const(*value),\n-        Range(range) => {\n-            visitor.visit_const(range.lo);\n-            visitor.visit_const(range.hi);\n-        }\n+        Constant { value: _ } => {}\n+        Range(_) => {}\n         Slice { prefix, slice, suffix } | Array { prefix, slice, suffix } => {\n             for subpattern in prefix {\n                 visitor.visit_pat(&subpattern);"}, {"sha": "6856ded3498eed2c5043eb6cc3a93bf03049bd92", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 108, "deletions": 10, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -1,43 +1,141 @@\n //! See docs in build/expr/mod.rs\n \n use crate::build::Builder;\n-use rustc_middle::mir::interpret::{ConstValue, Scalar};\n+use crate::thir::constant::parse_float;\n+use rustc_ast::ast;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::mir::interpret::{\n+    Allocation, ConstValue, LitToConstError, LitToConstInput, Scalar,\n+};\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n-use rustc_middle::ty::CanonicalUserTypeAnnotation;\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt};\n+use rustc_target::abi::Size;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a compile-time constant. Assumes that\n     /// `expr` is a valid compile-time constant!\n     crate fn as_constant(&mut self, expr: &Expr<'tcx>) -> Constant<'tcx> {\n+        let create_uneval_from_def_id =\n+            |tcx: TyCtxt<'tcx>, def_id: DefId, ty: Ty<'tcx>, substs: SubstsRef<'tcx>| {\n+                let uneval = ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs);\n+                tcx.mk_const(ty::ConstS { val: ty::ConstKind::Unevaluated(uneval), ty })\n+            };\n+\n         let this = self;\n+        let tcx = this.tcx;\n         let Expr { ty, temp_lifetime: _, span, ref kind } = *expr;\n         match *kind {\n             ExprKind::Scope { region_scope: _, lint_level: _, value } => {\n                 this.as_constant(&this.thir[value])\n             }\n-            ExprKind::Literal { literal, user_ty, const_id: _ } => {\n+            ExprKind::Literal { lit, neg } => {\n+                let literal =\n+                    match lit_to_constant(tcx, LitToConstInput { lit: &lit.node, ty, neg }) {\n+                        Ok(c) => c,\n+                        Err(LitToConstError::Reported) => ConstantKind::Ty(tcx.const_error(ty)),\n+                        Err(LitToConstError::TypeError) => {\n+                            bug!(\"encountered type error in `lit_to_constant\")\n+                        }\n+                    };\n+\n+                Constant { span, user_ty: None, literal: literal.into() }\n+            }\n+            ExprKind::NonHirLiteral { lit, user_ty } => {\n                 let user_ty = user_ty.map(|user_ty| {\n                     this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n                         span,\n                         user_ty,\n                         inferred_ty: ty,\n                     })\n                 });\n-                assert_eq!(literal.ty(), ty);\n-                Constant { span, user_ty, literal: literal.into() }\n+\n+                let literal = ConstantKind::Val(ConstValue::Scalar(Scalar::Int(lit)), ty);\n+\n+                Constant { span, user_ty: user_ty, literal }\n+            }\n+            ExprKind::NamedConst { def_id, substs, user_ty } => {\n+                let user_ty = user_ty.map(|user_ty| {\n+                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n+                        span,\n+                        user_ty,\n+                        inferred_ty: ty,\n+                    })\n+                });\n+                let literal = ConstantKind::Ty(create_uneval_from_def_id(tcx, def_id, ty, substs));\n+\n+                Constant { user_ty, span, literal }\n+            }\n+            ExprKind::ConstParam { param, def_id: _ } => {\n+                let const_param =\n+                    tcx.mk_const(ty::ConstS { val: ty::ConstKind::Param(param), ty: expr.ty });\n+                let literal = ConstantKind::Ty(const_param);\n+\n+                Constant { user_ty: None, span, literal }\n+            }\n+            ExprKind::ConstBlock { did: def_id, substs } => {\n+                let literal = ConstantKind::Ty(create_uneval_from_def_id(tcx, def_id, ty, substs));\n+\n+                Constant { user_ty: None, span, literal }\n             }\n             ExprKind::StaticRef { alloc_id, ty, .. } => {\n-                let const_val =\n-                    ConstValue::Scalar(Scalar::from_pointer(alloc_id.into(), &this.tcx));\n+                let const_val = ConstValue::Scalar(Scalar::from_pointer(alloc_id.into(), &tcx));\n                 let literal = ConstantKind::Val(const_val, ty);\n \n                 Constant { span, user_ty: None, literal }\n             }\n-            ExprKind::ConstBlock { value } => {\n-                Constant { span: span, user_ty: None, literal: value.into() }\n-            }\n             _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n         }\n     }\n }\n+\n+crate fn lit_to_constant<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    lit_input: LitToConstInput<'tcx>,\n+) -> Result<ConstantKind<'tcx>, LitToConstError> {\n+    let LitToConstInput { lit, ty, neg } = lit_input;\n+    let trunc = |n| {\n+        let param_ty = ty::ParamEnv::reveal_all().and(ty);\n+        let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n+        trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n+        let result = width.truncate(n);\n+        trace!(\"trunc result: {}\", result);\n+        Ok(ConstValue::Scalar(Scalar::from_uint(result, width)))\n+    };\n+\n+    let value = match (lit, &ty.kind()) {\n+        (ast::LitKind::Str(s, _), ty::Ref(_, inner_ty, _)) if inner_ty.is_str() => {\n+            let s = s.as_str();\n+            let allocation = Allocation::from_bytes_byte_aligned_immutable(s.as_bytes());\n+            let allocation = tcx.intern_const_alloc(allocation);\n+            ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n+        }\n+        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _))\n+            if matches!(inner_ty.kind(), ty::Slice(_)) =>\n+        {\n+            let allocation = Allocation::from_bytes_byte_aligned_immutable(data as &[u8]);\n+            let allocation = tcx.intern_const_alloc(allocation);\n+            ConstValue::Slice { data: allocation, start: 0, end: data.len() }\n+        }\n+        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n+            let id = tcx.allocate_bytes(data);\n+            ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n+        }\n+        (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n+            ConstValue::Scalar(Scalar::from_uint(*n, Size::from_bytes(1)))\n+        }\n+        (ast::LitKind::Int(n, _), ty::Uint(_)) | (ast::LitKind::Int(n, _), ty::Int(_)) => {\n+            trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?\n+        }\n+        (ast::LitKind::Float(n, _), ty::Float(fty)) => {\n+            parse_float(*n, *fty, neg).ok_or(LitToConstError::Reported)?\n+        }\n+        (ast::LitKind::Bool(b), ty::Bool) => ConstValue::Scalar(Scalar::from_bool(*b)),\n+        (ast::LitKind::Char(c), ty::Char) => ConstValue::Scalar(Scalar::from_char(*c)),\n+        (ast::LitKind::Err(_), _) => return Err(LitToConstError::Reported),\n+        _ => return Err(LitToConstError::TypeError),\n+    };\n+\n+    Ok(ConstantKind::Val(value, ty))\n+}"}, {"sha": "10d241ee24cf4cb991cdff89c84884d8ee519daf", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -566,6 +566,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Continue { .. }\n             | ExprKind::Return { .. }\n             | ExprKind::Literal { .. }\n+            | ExprKind::NamedConst { .. }\n+            | ExprKind::NonHirLiteral { .. }\n+            | ExprKind::ConstParam { .. }\n             | ExprKind::ConstBlock { .. }\n             | ExprKind::StaticRef { .. }\n             | ExprKind::InlineAsm { .. }"}, {"sha": "3f8a1a3f7950460a81598cb5bbf6104821bf6916", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -327,6 +327,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             ExprKind::Yield { .. }\n             | ExprKind::Literal { .. }\n+            | ExprKind::NamedConst { .. }\n+            | ExprKind::NonHirLiteral { .. }\n+            | ExprKind::ConstParam { .. }\n             | ExprKind::ConstBlock { .. }\n             | ExprKind::StaticRef { .. }\n             | ExprKind::Block { .. }"}, {"sha": "6067da2f69b489f9208ab2eb3ee5938ce030c4fc", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -70,7 +70,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     local_decl.local_info =\n                         Some(Box::new(LocalInfo::StaticRef { def_id, is_thread_local: true }));\n                 }\n-                ExprKind::Literal { const_id: Some(def_id), .. } => {\n+                ExprKind::NamedConst { def_id, .. } | ExprKind::ConstParam { def_id, .. } => {\n                     local_decl.local_info = Some(Box::new(LocalInfo::ConstRef { def_id }));\n                 }\n                 _ => {}"}, {"sha": "bcece39c6206eb00cf180cca44220f6ed1855c27", "filename": "compiler/rustc_mir_build/src/build/expr/category.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -69,9 +69,12 @@ impl Category {\n             | ExprKind::AssignOp { .. }\n             | ExprKind::ThreadLocalRef(_) => Some(Category::Rvalue(RvalueFunc::AsRvalue)),\n \n-            ExprKind::ConstBlock { .. } | ExprKind::Literal { .. } | ExprKind::StaticRef { .. } => {\n-                Some(Category::Constant)\n-            }\n+            ExprKind::ConstBlock { .. }\n+            | ExprKind::Literal { .. }\n+            | ExprKind::NonHirLiteral { .. }\n+            | ExprKind::ConstParam { .. }\n+            | ExprKind::StaticRef { .. }\n+            | ExprKind::NamedConst { .. } => Some(Category::Constant),\n \n             ExprKind::Loop { .. }\n             | ExprKind::Block { .. }"}, {"sha": "a8f623dbe469309a25bca4b83dc2690af1cf917a", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -533,6 +533,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Closure { .. }\n             | ExprKind::ConstBlock { .. }\n             | ExprKind::Literal { .. }\n+            | ExprKind::NamedConst { .. }\n+            | ExprKind::NonHirLiteral { .. }\n+            | ExprKind::ConstParam { .. }\n             | ExprKind::ThreadLocalRef(_)\n             | ExprKind::StaticRef { .. } => {\n                 debug_assert!(match Category::of(&expr.kind).unwrap() {"}, {"sha": "7be435cda7db37602fc65775b9bc6d6e06aadc35", "filename": "compiler/rustc_mir_build/src/build/expr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -60,7 +60,7 @@\n //! basically the point where the \"by value\" operations are bridged\n //! over to the \"by reference\" mode (`as_place`).\n \n-mod as_constant;\n+crate mod as_constant;\n mod as_operand;\n pub mod as_place;\n mod as_rvalue;"}, {"sha": "eadce3dc9c4679a36b310450f38b4b0ce7206b8a", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -303,6 +303,9 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n             | ExprKind::Block { .. }\n             | ExprKind::Borrow { .. }\n             | ExprKind::Literal { .. }\n+            | ExprKind::NamedConst { .. }\n+            | ExprKind::NonHirLiteral { .. }\n+            | ExprKind::ConstParam { .. }\n             | ExprKind::ConstBlock { .. }\n             | ExprKind::Deref { .. }\n             | ExprKind::Index { .. }"}, {"sha": "30d7fdb7fec365de33928567e8fb729b32f7e7ed", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -7,6 +7,7 @@ use rustc_middle::ty::{self, ParamEnv, TyCtxt};\n use rustc_span::symbol::Symbol;\n use rustc_target::abi::Size;\n \n+// FIXME Once valtrees are available, get rid of this function and the query\n crate fn lit_to_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     lit_input: LitToConstInput<'tcx>,\n@@ -57,7 +58,12 @@ crate fn lit_to_const<'tcx>(\n     Ok(ty::Const::from_value(tcx, lit, ty))\n }\n \n-fn parse_float<'tcx>(num: Symbol, fty: ty::FloatTy, neg: bool) -> Option<ConstValue<'tcx>> {\n+// FIXME move this to rustc_mir_build::build\n+pub(crate) fn parse_float<'tcx>(\n+    num: Symbol,\n+    fty: ty::FloatTy,\n+    neg: bool,\n+) -> Option<ConstValue<'tcx>> {\n     let num = num.as_str();\n     use rustc_apfloat::ieee::{Double, Single};\n     let scalar = match fty {"}, {"sha": "cab5fcd179b47a217e1920ed1585c19848a15855", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 50, "deletions": 86, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -14,7 +14,9 @@ use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AutoBorrow, AutoBorrowMutability, PointerCast,\n };\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc_middle::ty::{self, AdtKind, Ty, UpvarSubsts, UserType};\n+use rustc_middle::ty::{\n+    self, AdtKind, InlineConstSubsts, InlineConstSubstsParts, ScalarInt, Ty, UpvarSubsts, UserType,\n+};\n use rustc_span::def_id::DefId;\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n@@ -290,11 +292,7 @@ impl<'tcx> Cx<'tcx> {\n                 }\n             }\n \n-            hir::ExprKind::Lit(ref lit) => ExprKind::Literal {\n-                literal: self.const_eval_literal(&lit.node, expr_ty, lit.span, false),\n-                user_ty: None,\n-                const_id: None,\n-            },\n+            hir::ExprKind::Lit(ref lit) => ExprKind::Literal { lit, neg: false },\n \n             hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n                 if self.typeck_results().is_method_call(expr) {\n@@ -359,11 +357,7 @@ impl<'tcx> Cx<'tcx> {\n                     let arg = self.mirror_expr(arg);\n                     self.overloaded_operator(expr, Box::new([arg]))\n                 } else if let hir::ExprKind::Lit(ref lit) = arg.kind {\n-                    ExprKind::Literal {\n-                        literal: self.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n-                        user_ty: None,\n-                        const_id: None,\n-                    }\n+                    ExprKind::Literal { lit, neg: true }\n                 } else {\n                     ExprKind::Unary { op: UnOp::Neg, arg: self.mirror_expr(arg) }\n                 }\n@@ -524,11 +518,7 @@ impl<'tcx> Cx<'tcx> {\n                                                 ty,\n                                                 temp_lifetime,\n                                                 span: expr.span,\n-                                                kind: ExprKind::Literal {\n-                                                    literal: ty::Const::zero_sized(self.tcx, ty),\n-                                                    user_ty,\n-                                                    const_id: None,\n-                                                },\n+                                                kind: ExprKind::zero_sized_literal(user_ty),\n                                             }),\n                                         }\n                                     }\n@@ -550,11 +540,7 @@ impl<'tcx> Cx<'tcx> {\n                                                 ty,\n                                                 temp_lifetime,\n                                                 span: expr.span,\n-                                                kind: ExprKind::Literal {\n-                                                    literal: ty::Const::zero_sized(self.tcx, ty),\n-                                                    user_ty: None,\n-                                                    const_id: None,\n-                                                },\n+                                                kind: ExprKind::zero_sized_literal(None),\n                                             }),\n                                         }\n                                     }\n@@ -568,13 +554,21 @@ impl<'tcx> Cx<'tcx> {\n             },\n \n             hir::ExprKind::ConstBlock(ref anon_const) => {\n-                let anon_const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n-\n-                // FIXME Do we want to use `from_inline_const` once valtrees\n-                // are introduced? This would create `ValTree`s that will never be used...\n-                let value = ty::Const::from_inline_const(self.tcx, anon_const_def_id);\n-\n-                ExprKind::ConstBlock { value }\n+                let tcx = self.tcx;\n+                let local_def_id = tcx.hir().local_def_id(anon_const.hir_id);\n+                let anon_const_def_id = local_def_id.to_def_id();\n+\n+                // Need to include the parent substs\n+                let hir_id = tcx.hir().local_def_id_to_hir_id(local_def_id);\n+                let ty = tcx.typeck(local_def_id).node_type(hir_id);\n+                let typeck_root_def_id = tcx.typeck_root_def_id(anon_const_def_id);\n+                let parent_substs =\n+                    tcx.erase_regions(InternalSubsts::identity_for_item(tcx, typeck_root_def_id));\n+                let substs =\n+                    InlineConstSubsts::new(tcx, InlineConstSubstsParts { parent_substs, ty })\n+                        .substs;\n+\n+                ExprKind::ConstBlock { did: anon_const_def_id, substs }\n             }\n             // Now comes the rote stuff:\n             hir::ExprKind::Repeat(ref v, _) => {\n@@ -692,32 +686,36 @@ impl<'tcx> Cx<'tcx> {\n                     };\n \n                     let source = if let Some((did, offset, var_ty)) = var {\n-                        let mk_const = |literal| Expr {\n+                        let param_env_ty = self.param_env.and(var_ty);\n+                        let size = self\n+                            .tcx\n+                            .layout_of(param_env_ty)\n+                            .unwrap_or_else(|e| {\n+                                panic!(\"could not compute layout for {:?}: {:?}\", param_env_ty, e)\n+                            })\n+                            .size;\n+                        let lit = ScalarInt::try_from_uint(offset as u128, size).unwrap();\n+                        let kind = ExprKind::NonHirLiteral { lit, user_ty: None };\n+                        let offset = self.thir.exprs.push(Expr {\n                             temp_lifetime,\n                             ty: var_ty,\n                             span: expr.span,\n-                            kind: ExprKind::Literal { literal, user_ty: None, const_id: None },\n-                        };\n-                        let offset = self.thir.exprs.push(mk_const(ty::Const::from_bits(\n-                            self.tcx,\n-                            offset as u128,\n-                            self.param_env.and(var_ty),\n-                        )));\n+                            kind,\n+                        });\n                         match did {\n                             Some(did) => {\n                                 // in case we are offsetting from a computed discriminant\n                                 // and not the beginning of discriminants (which is always `0`)\n                                 let substs = InternalSubsts::identity_for_item(self.tcx(), did);\n-                                let lhs = ty::ConstS {\n-                                    val: ty::ConstKind::Unevaluated(ty::Unevaluated::new(\n-                                        ty::WithOptConstParam::unknown(did),\n-                                        substs,\n-                                    )),\n+                                let kind =\n+                                    ExprKind::NamedConst { def_id: did, substs, user_ty: None };\n+                                let lhs = self.thir.exprs.push(Expr {\n+                                    temp_lifetime,\n                                     ty: var_ty,\n-                                };\n-                                let lhs = self.thir.exprs.push(mk_const(self.tcx().mk_const(lhs)));\n-                                let bin =\n-                                    ExprKind::Binary { op: BinOp::Add, lhs: lhs, rhs: offset };\n+                                    span: expr.span,\n+                                    kind,\n+                                });\n+                                let bin = ExprKind::Binary { op: BinOp::Add, lhs, rhs: offset };\n                                 self.thir.exprs.push(Expr {\n                                     temp_lifetime,\n                                     ty: var_ty,\n@@ -832,16 +830,7 @@ impl<'tcx> Cx<'tcx> {\n             }\n         };\n         let ty = self.tcx().mk_fn_def(def_id, substs);\n-        Expr {\n-            temp_lifetime,\n-            ty,\n-            span,\n-            kind: ExprKind::Literal {\n-                literal: ty::Const::zero_sized(self.tcx(), ty),\n-                user_ty,\n-                const_id: None,\n-            },\n-        }\n+        Expr { temp_lifetime, ty, span, kind: ExprKind::zero_sized_literal(user_ty) }\n     }\n \n     fn convert_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) -> ArmId {\n@@ -868,17 +857,9 @@ impl<'tcx> Cx<'tcx> {\n             Res::Def(DefKind::Fn, _)\n             | Res::Def(DefKind::AssocFn, _)\n             | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _)\n-            | Res::SelfCtor(..) => {\n+            | Res::SelfCtor(_) => {\n                 let user_ty = self.user_substs_applied_to_res(expr.hir_id, res);\n-                debug!(\"convert_path_expr: user_ty={:?}\", user_ty);\n-                ExprKind::Literal {\n-                    literal: ty::Const::zero_sized(\n-                        self.tcx,\n-                        self.typeck_results().node_type(expr.hir_id),\n-                    ),\n-                    user_ty,\n-                    const_id: None,\n-                }\n+                ExprKind::zero_sized_literal(user_ty)\n             }\n \n             Res::Def(DefKind::ConstParam, def_id) => {\n@@ -888,31 +869,14 @@ impl<'tcx> Cx<'tcx> {\n                 let generics = self.tcx.generics_of(item_def_id);\n                 let index = generics.param_def_id_to_index[&def_id];\n                 let name = self.tcx.hir().name(hir_id);\n-                let val = ty::ConstKind::Param(ty::ParamConst::new(index, name));\n-                ExprKind::Literal {\n-                    literal: self.tcx.mk_const(ty::ConstS {\n-                        val,\n-                        ty: self.typeck_results().node_type(expr.hir_id),\n-                    }),\n-                    user_ty: None,\n-                    const_id: Some(def_id),\n-                }\n+                let param = ty::ParamConst::new(index, name);\n+\n+                ExprKind::ConstParam { param, def_id }\n             }\n \n             Res::Def(DefKind::Const, def_id) | Res::Def(DefKind::AssocConst, def_id) => {\n                 let user_ty = self.user_substs_applied_to_res(expr.hir_id, res);\n-                debug!(\"convert_path_expr: (const) user_ty={:?}\", user_ty);\n-                ExprKind::Literal {\n-                    literal: self.tcx.mk_const(ty::ConstS {\n-                        val: ty::ConstKind::Unevaluated(ty::Unevaluated::new(\n-                            ty::WithOptConstParam::unknown(def_id),\n-                            substs,\n-                        )),\n-                        ty: self.typeck_results().node_type(expr.hir_id),\n-                    }),\n-                    user_ty,\n-                    const_id: Some(def_id),\n-                }\n+                ExprKind::NamedConst { def_id, substs, user_ty: user_ty }\n             }\n \n             Res::Def(DefKind::Ctor(_, CtorKind::Const), def_id) => {"}, {"sha": "f17fe38b292cbca5b6234856f23d40f293f68f17", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -5,17 +5,15 @@\n use crate::thir::pattern::pat_from_hir;\n use crate::thir::util::UserAnnotatedTyHelpers;\n \n-use rustc_ast as ast;\n use rustc_data_structures::steal::Steal;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::HirId;\n use rustc_hir::Node;\n use rustc_middle::middle::region;\n-use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n use rustc_middle::thir::*;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::Span;\n \n crate fn thir_body<'tcx>(\n@@ -77,25 +75,6 @@ impl<'tcx> Cx<'tcx> {\n         }\n     }\n \n-    crate fn const_eval_literal(\n-        &mut self,\n-        lit: &'tcx ast::LitKind,\n-        ty: Ty<'tcx>,\n-        sp: Span,\n-        neg: bool,\n-    ) -> ty::Const<'tcx> {\n-        trace!(\"const_eval_literal: {:#?}, {:?}, {:?}, {:?}\", lit, ty, sp, neg);\n-\n-        match self.tcx.at(sp).lit_to_const(LitToConstInput { lit, ty, neg }) {\n-            Ok(c) => c,\n-            Err(LitToConstError::Reported) => {\n-                // create a dummy value and continue compiling\n-                self.tcx.const_error(ty)\n-            }\n-            Err(LitToConstError::TypeError) => bug!(\"const_eval_literal: had type error\"),\n-        }\n-    }\n-\n     crate fn pattern_from_hir(&mut self, p: &hir::Pat<'_>) -> Pat<'tcx> {\n         let p = match self.tcx.hir().get(p.hir_id) {\n             Node::Pat(p) | Node::Binding(p) => p,"}, {"sha": "490c04e7be24147b3256ed9d5cf19417cb25749a", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 84, "deletions": 13, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -14,7 +14,9 @@ use rustc_hir::def::DefKind;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::ErrorHandled;\n+use rustc_middle::mir::interpret::{\n+    ConstValue, ErrorHandled, LitToConstError, LitToConstInput, Scalar,\n+};\n use rustc_middle::thir;\n use rustc_middle::thir::abstract_const::{self, Node, NodeId, NotConstEvaluatable};\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n@@ -28,13 +30,13 @@ use std::iter;\n use std::ops::ControlFlow;\n \n /// Check if a given constant can be evaluated.\n+#[instrument(skip(infcx), level = \"debug\")]\n pub fn is_const_evaluatable<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     uv: ty::Unevaluated<'tcx, ()>,\n     param_env: ty::ParamEnv<'tcx>,\n     span: Span,\n ) -> Result<(), NotConstEvaluatable> {\n-    debug!(\"is_const_evaluatable({:?})\", uv);\n     let tcx = infcx.tcx;\n \n     if tcx.features().generic_const_exprs {\n@@ -304,6 +306,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         Err(reported)\n     }\n \n+    #[instrument(skip(tcx, body, body_id), level = \"debug\")]\n     fn new(\n         tcx: TyCtxt<'tcx>,\n         (body, body_id): (&'a thir::Thir<'tcx>, thir::ExprId),\n@@ -315,29 +318,61 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             thir: &'a thir::Thir<'tcx>,\n         }\n \n+        use crate::rustc_middle::thir::visit::Visitor;\n         use thir::visit;\n-        impl<'a, 'tcx: 'a> visit::Visitor<'a, 'tcx> for IsThirPolymorphic<'a, 'tcx> {\n+\n+        impl<'a, 'tcx> IsThirPolymorphic<'a, 'tcx> {\n+            fn expr_is_poly(&mut self, expr: &thir::Expr<'tcx>) -> bool {\n+                if expr.ty.has_param_types_or_consts() {\n+                    return true;\n+                }\n+\n+                match expr.kind {\n+                    thir::ExprKind::NamedConst { substs, .. } => substs.has_param_types_or_consts(),\n+                    thir::ExprKind::ConstParam { .. } => true,\n+                    thir::ExprKind::Repeat { value, count } => {\n+                        self.visit_expr(&self.thir()[value]);\n+                        count.has_param_types_or_consts()\n+                    }\n+                    _ => false,\n+                }\n+            }\n+\n+            fn pat_is_poly(&mut self, pat: &thir::Pat<'tcx>) -> bool {\n+                if pat.ty.has_param_types_or_consts() {\n+                    return true;\n+                }\n+\n+                match pat.kind.as_ref() {\n+                    thir::PatKind::Constant { value } => value.has_param_types_or_consts(),\n+                    thir::PatKind::Range(thir::PatRange { lo, hi, .. }) => {\n+                        lo.has_param_types_or_consts() || hi.has_param_types_or_consts()\n+                    }\n+                    _ => false,\n+                }\n+            }\n+        }\n+\n+        impl<'a, 'tcx> visit::Visitor<'a, 'tcx> for IsThirPolymorphic<'a, 'tcx> {\n             fn thir(&self) -> &'a thir::Thir<'tcx> {\n                 &self.thir\n             }\n \n+            #[instrument(skip(self), level = \"debug\")]\n             fn visit_expr(&mut self, expr: &thir::Expr<'tcx>) {\n-                self.is_poly |= expr.ty.has_param_types_or_consts();\n+                self.is_poly |= self.expr_is_poly(expr);\n                 if !self.is_poly {\n                     visit::walk_expr(self, expr)\n                 }\n             }\n \n+            #[instrument(skip(self), level = \"debug\")]\n             fn visit_pat(&mut self, pat: &thir::Pat<'tcx>) {\n-                self.is_poly |= pat.ty.has_param_types_or_consts();\n+                self.is_poly |= self.pat_is_poly(pat);\n                 if !self.is_poly {\n                     visit::walk_pat(self, pat);\n                 }\n             }\n-\n-            fn visit_const(&mut self, ct: ty::Const<'tcx>) {\n-                self.is_poly |= ct.has_param_types_or_consts();\n-            }\n         }\n \n         let mut is_poly_vis = IsThirPolymorphic { is_poly: false, thir: body };\n@@ -393,16 +428,49 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n     fn recurse_build(&mut self, node: thir::ExprId) -> Result<NodeId, ErrorGuaranteed> {\n         use thir::ExprKind;\n         let node = &self.body.exprs[node];\n-        debug!(\"recurse_build: node={:?}\", node);\n         Ok(match &node.kind {\n             // I dont know if handling of these 3 is correct\n             &ExprKind::Scope { value, .. } => self.recurse_build(value)?,\n             &ExprKind::PlaceTypeAscription { source, .. }\n             | &ExprKind::ValueTypeAscription { source, .. } => self.recurse_build(source)?,\n+            &ExprKind::Literal { lit, neg} => {\n+                let sp = node.span;\n+                let constant =\n+                    match self.tcx.at(sp).lit_to_const(LitToConstInput { lit: &lit.node, ty: node.ty, neg }) {\n+                        Ok(c) => c,\n+                        Err(LitToConstError::Reported) => {\n+                            self.tcx.const_error(node.ty)\n+                        }\n+                        Err(LitToConstError::TypeError) => {\n+                            bug!(\"encountered type error in lit_to_const\")\n+                        }\n+                    };\n+\n+                self.nodes.push(Node::Leaf(constant))\n+            }\n+            &ExprKind::NonHirLiteral { lit , user_ty: _} => {\n+                // FIXME Construct a Valtree from this ScalarInt when introducing Valtrees\n+                let const_value = ConstValue::Scalar(Scalar::Int(lit));\n+                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, const_value, node.ty)))\n+            }\n+            &ExprKind::NamedConst { def_id, substs, user_ty: _ } => {\n+                let uneval = ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs);\n+\n+                let constant = self.tcx.mk_const(ty::ConstS {\n+                                val: ty::ConstKind::Unevaluated(uneval),\n+                                ty: node.ty,\n+                            });\n \n-            // subtle: associated consts are literals this arm handles\n-            // `<T as Trait>::ASSOC` as well as `12`\n-            &ExprKind::Literal { literal, .. } => self.nodes.push(Node::Leaf(literal)),\n+                self.nodes.push(Node::Leaf(constant))\n+            }\n+\n+            ExprKind::ConstParam {param, ..} => {\n+                let const_param = self.tcx.mk_const(ty::ConstS {\n+                        val: ty::ConstKind::Param(*param),\n+                        ty: node.ty,\n+                    });\n+                self.nodes.push(Node::Leaf(const_param))\n+            }\n \n             ExprKind::Call { fun, args, .. } => {\n                 let fun = self.recurse_build(*fun)?;\n@@ -585,6 +653,7 @@ pub(super) fn try_unify_abstract_consts<'tcx>(\n     // on `ErrorGuaranteed`.\n }\n \n+#[instrument(skip(tcx, f), level = \"debug\")]\n pub fn walk_abstract_const<'tcx, R, F>(\n     tcx: TyCtxt<'tcx>,\n     ct: AbstractConst<'tcx>,\n@@ -593,13 +662,15 @@ pub fn walk_abstract_const<'tcx, R, F>(\n where\n     F: FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n {\n+    #[instrument(skip(tcx, f), level = \"debug\")]\n     fn recurse<'tcx, R>(\n         tcx: TyCtxt<'tcx>,\n         ct: AbstractConst<'tcx>,\n         f: &mut dyn FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n     ) -> ControlFlow<R> {\n         f(ct)?;\n         let root = ct.root(tcx);\n+        debug!(?root);\n         match root {\n             Node::Leaf(_) => ControlFlow::CONTINUE,\n             Node::Binop(_, l, r) => {"}, {"sha": "cdc5910b36cfa2588f3df8c1a8d222c6fd54311d", "filename": "src/test/ui/mir/thir-constparam-temp.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/src%2Ftest%2Fui%2Fmir%2Fthir-constparam-temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/src%2Ftest%2Fui%2Fmir%2Fthir-constparam-temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fthir-constparam-temp.rs?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -0,0 +1,20 @@\n+// build-pass\n+\n+#![feature(adt_const_params)]\n+#![allow(incomplete_features)]\n+\n+#[derive(PartialEq, Eq)]\n+struct Yikes;\n+\n+impl Yikes {\n+    fn mut_self(&mut self) {}\n+}\n+\n+fn foo<const YIKES: Yikes>() {\n+    YIKES.mut_self()\n+    //~^ WARNING taking a mutable reference\n+}\n+\n+fn main() {\n+    foo::<{ Yikes }>()\n+}"}, {"sha": "297102e657ef669d7d04d8cceee5ba9d627b02b2", "filename": "src/test/ui/mir/thir-constparam-temp.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8d8135f003b35c3e109d013b2bed9ee9496da615/src%2Ftest%2Fui%2Fmir%2Fthir-constparam-temp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d8135f003b35c3e109d013b2bed9ee9496da615/src%2Ftest%2Fui%2Fmir%2Fthir-constparam-temp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fthir-constparam-temp.stderr?ref=8d8135f003b35c3e109d013b2bed9ee9496da615", "patch": "@@ -0,0 +1,22 @@\n+warning: taking a mutable reference to a `const` item\n+  --> $DIR/thir-constparam-temp.rs:14:5\n+   |\n+LL |     YIKES.mut_self()\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(const_item_mutation)]` on by default\n+   = note: each usage of a `const` item creates a new temporary\n+   = note: the mutable reference will refer to this temporary, not the original `const` item\n+note: mutable reference created due to call to this method\n+  --> $DIR/thir-constparam-temp.rs:10:5\n+   |\n+LL |     fn mut_self(&mut self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+note: `const` item defined here\n+  --> $DIR/thir-constparam-temp.rs:13:14\n+   |\n+LL | fn foo<const YIKES: Yikes>() {\n+   |              ^^^^^\n+\n+warning: 1 warning emitted\n+"}]}