{"sha": "f0edfab44cc7f0dcd00b6c9f46bd554dab5e51a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwZWRmYWI0NGNjN2YwZGNkMDBiNmM5ZjQ2YmQ1NTRkYWI1ZTUxYTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-24T16:27:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-24T16:27:01Z"}, "message": "Auto merge of #4230 - flip1995:unsugar_if, r=Manishearth\n\nReplace `unsugar_if` function with `is_if` function\n\ncc https://github.com/rust-lang/rust-clippy/pull/4123#discussion_r296581719\n\nchangelog: none\n\nr? @Manishearth", "tree": {"sha": "476b381cbb044ba7ad6d30a2ca5e37b3c7ddea68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/476b381cbb044ba7ad6d30a2ca5e37b3c7ddea68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0edfab44cc7f0dcd00b6c9f46bd554dab5e51a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0edfab44cc7f0dcd00b6c9f46bd554dab5e51a2", "html_url": "https://github.com/rust-lang/rust/commit/f0edfab44cc7f0dcd00b6c9f46bd554dab5e51a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0edfab44cc7f0dcd00b6c9f46bd554dab5e51a2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c80b65f10213c6e5f4c6d8113e8f8c9477af568", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c80b65f10213c6e5f4c6d8113e8f8c9477af568", "html_url": "https://github.com/rust-lang/rust/commit/8c80b65f10213c6e5f4c6d8113e8f8c9477af568"}, {"sha": "662037bcf28fe87ae8f49dfa774ea600f89a85a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/662037bcf28fe87ae8f49dfa774ea600f89a85a5", "html_url": "https://github.com/rust-lang/rust/commit/662037bcf28fe87ae8f49dfa774ea600f89a85a5"}], "stats": {"total": 60, "additions": 30, "deletions": 30}, "files": [{"sha": "f20c95d7684c9fb40b8abf24519805627543caf9", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f0edfab44cc7f0dcd00b6c9f46bd554dab5e51a2/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0edfab44cc7f0dcd00b6c9f46bd554dab5e51a2/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=f0edfab44cc7f0dcd00b6c9f46bd554dab5e51a2", "patch": "@@ -2,8 +2,7 @@ use crate::utils::{differing_macro_contexts, in_macro_or_desugar, snippet_opt, s\n use if_chain::if_chain;\n use rustc::lint::{in_external_macro, EarlyContext, EarlyLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n-use syntax::ast;\n-use syntax::ptr::P;\n+use syntax::ast::*;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for use of the non-existent `=*`, `=!` and `=-`\n@@ -86,33 +85,33 @@ declare_lint_pass!(Formatting => [\n ]);\n \n impl EarlyLintPass for Formatting {\n-    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &Block) {\n         for w in block.stmts.windows(2) {\n             match (&w[0].node, &w[1].node) {\n-                (&ast::StmtKind::Expr(ref first), &ast::StmtKind::Expr(ref second))\n-                | (&ast::StmtKind::Expr(ref first), &ast::StmtKind::Semi(ref second)) => {\n+                (&StmtKind::Expr(ref first), &StmtKind::Expr(ref second))\n+                | (&StmtKind::Expr(ref first), &StmtKind::Semi(ref second)) => {\n                     check_missing_else(cx, first, second);\n                 },\n                 _ => (),\n             }\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         check_assign(cx, expr);\n         check_else(cx, expr);\n         check_array(cx, expr);\n     }\n }\n \n /// Implementation of the `SUSPICIOUS_ASSIGNMENT_FORMATTING` lint.\n-fn check_assign(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n-    if let ast::ExprKind::Assign(ref lhs, ref rhs) = expr.node {\n+fn check_assign(cx: &EarlyContext<'_>, expr: &Expr) {\n+    if let ExprKind::Assign(ref lhs, ref rhs) = expr.node {\n         if !differing_macro_contexts(lhs.span, rhs.span) && !in_macro_or_desugar(lhs.span) {\n             let eq_span = lhs.span.between(rhs.span);\n-            if let ast::ExprKind::Unary(op, ref sub_rhs) = rhs.node {\n+            if let ExprKind::Unary(op, ref sub_rhs) = rhs.node {\n                 if let Some(eq_snippet) = snippet_opt(cx, eq_span) {\n-                    let op = ast::UnOp::to_string(op);\n+                    let op = UnOp::to_string(op);\n                     let eqop_span = lhs.span.between(sub_rhs.span);\n                     if eq_snippet.ends_with('=') {\n                         span_note_and_lint(\n@@ -135,10 +134,10 @@ fn check_assign(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n }\n \n /// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for weird `else`.\n-fn check_else(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n+fn check_else(cx: &EarlyContext<'_>, expr: &Expr) {\n     if_chain! {\n-        if let Some((then, &Some(ref else_))) = unsugar_if(expr);\n-        if is_block(else_) || unsugar_if(else_).is_some();\n+        if let ExprKind::If(_, then, Some(else_)) = &expr.node;\n+        if is_block(else_) || is_if(else_);\n         if !differing_macro_contexts(then.span, else_.span);\n         if !in_macro_or_desugar(then.span) && !in_external_macro(cx.sess, expr.span);\n \n@@ -154,7 +153,7 @@ fn check_else(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n         if let Some(else_snippet) = snippet_opt(cx, else_span);\n         if let Some(else_pos) = else_snippet.find(\"else\");\n         if else_snippet[else_pos..].contains('\\n');\n-        let else_desc = if unsugar_if(else_).is_some() { \"if\" } else { \"{..}\" };\n+        let else_desc = if is_if(else_) { \"if\" } else { \"{..}\" };\n \n         then {\n             span_note_and_lint(\n@@ -173,16 +172,16 @@ fn check_else(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     }\n }\n \n-fn has_unary_equivalent(bin_op: ast::BinOpKind) -> bool {\n+fn has_unary_equivalent(bin_op: BinOpKind) -> bool {\n     // &, *, -\n-    bin_op == ast::BinOpKind::And || bin_op == ast::BinOpKind::Mul || bin_op == ast::BinOpKind::Sub\n+    bin_op == BinOpKind::And || bin_op == BinOpKind::Mul || bin_op == BinOpKind::Sub\n }\n \n /// Implementation of the `POSSIBLE_MISSING_COMMA` lint for array\n-fn check_array(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n-    if let ast::ExprKind::Array(ref array) = expr.node {\n+fn check_array(cx: &EarlyContext<'_>, expr: &Expr) {\n+    if let ExprKind::Array(ref array) = expr.node {\n         for element in array {\n-            if let ast::ExprKind::Binary(ref op, ref lhs, _) = element.node {\n+            if let ExprKind::Binary(ref op, ref lhs, _) = element.node {\n                 if has_unary_equivalent(op.node) && !differing_macro_contexts(lhs.span, op.span) {\n                     let space_span = lhs.span.between(op.span);\n                     if let Some(space_snippet) = snippet_opt(cx, space_span) {\n@@ -204,18 +203,18 @@ fn check_array(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     }\n }\n \n-fn check_missing_else(cx: &EarlyContext<'_>, first: &ast::Expr, second: &ast::Expr) {\n+fn check_missing_else(cx: &EarlyContext<'_>, first: &Expr, second: &Expr) {\n     if !differing_macro_contexts(first.span, second.span)\n         && !in_macro_or_desugar(first.span)\n-        && unsugar_if(first).is_some()\n-        && (is_block(second) || unsugar_if(second).is_some())\n+        && is_if(first)\n+        && (is_block(second) || is_if(second))\n     {\n         // where the else would be\n         let else_span = first.span.between(second.span);\n \n         if let Some(else_snippet) = snippet_opt(cx, else_span) {\n             if !else_snippet.contains('\\n') {\n-                let (looks_like, next_thing) = if unsugar_if(second).is_some() {\n+                let (looks_like, next_thing) = if is_if(second) {\n                     (\"an `else if`\", \"the second `if`\")\n                 } else {\n                     (\"an `else {..}`\", \"the next block\")\n@@ -237,18 +236,19 @@ fn check_missing_else(cx: &EarlyContext<'_>, first: &ast::Expr, second: &ast::Ex\n     }\n }\n \n-fn is_block(expr: &ast::Expr) -> bool {\n-    if let ast::ExprKind::Block(..) = expr.node {\n+fn is_block(expr: &Expr) -> bool {\n+    if let ExprKind::Block(..) = expr.node {\n         true\n     } else {\n         false\n     }\n }\n \n-/// Match `if` or `if let` expressions and return the `then` and `else` block.\n-fn unsugar_if(expr: &ast::Expr) -> Option<(&P<ast::Block>, &Option<P<ast::Expr>>)> {\n-    match expr.node {\n-        ast::ExprKind::If(_, ref then, ref else_) => Some((then, else_)),\n-        _ => None,\n+/// Check if the expression is an `if` or `if let`\n+fn is_if(expr: &Expr) -> bool {\n+    if let ExprKind::If(..) = expr.node {\n+        true\n+    } else {\n+        false\n     }\n }"}]}