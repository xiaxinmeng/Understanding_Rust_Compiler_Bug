{"sha": "a8f3f038c03eb1393110dfdb1e6bdf1be6a3fb62", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ZjNmMDM4YzAzZWIxMzkzMTEwZGZkYjFlNmJkZjFiZTZhM2ZiNjI=", "commit": {"author": {"name": "Jordi Boggiano", "email": "j.boggiano@seld.be", "date": "2013-08-05T12:37:54Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-08-08T02:41:13Z"}, "message": "Turn OptGroups into a main opt and a main and an aliased opts\n\nThis way opt_present(\"apple\") will match no matter if the user passed -a or --apple", "tree": {"sha": "671ea5790dd1b70e6d14317883eb6c84d8569035", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/671ea5790dd1b70e6d14317883eb6c84d8569035"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8f3f038c03eb1393110dfdb1e6bdf1be6a3fb62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8f3f038c03eb1393110dfdb1e6bdf1be6a3fb62", "html_url": "https://github.com/rust-lang/rust/commit/a8f3f038c03eb1393110dfdb1e6bdf1be6a3fb62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8f3f038c03eb1393110dfdb1e6bdf1be6a3fb62/comments", "author": {"login": "Seldaek", "id": 183678, "node_id": "MDQ6VXNlcjE4MzY3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/183678?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Seldaek", "html_url": "https://github.com/Seldaek", "followers_url": "https://api.github.com/users/Seldaek/followers", "following_url": "https://api.github.com/users/Seldaek/following{/other_user}", "gists_url": "https://api.github.com/users/Seldaek/gists{/gist_id}", "starred_url": "https://api.github.com/users/Seldaek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Seldaek/subscriptions", "organizations_url": "https://api.github.com/users/Seldaek/orgs", "repos_url": "https://api.github.com/users/Seldaek/repos", "events_url": "https://api.github.com/users/Seldaek/events{/privacy}", "received_events_url": "https://api.github.com/users/Seldaek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7f008bc3954223d3c6693389d82880a88dc407c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f008bc3954223d3c6693389d82880a88dc407c", "html_url": "https://github.com/rust-lang/rust/commit/a7f008bc3954223d3c6693389d82880a88dc407c"}], "stats": {"total": 107, "additions": 72, "deletions": 35}, "files": [{"sha": "1b65528923a100c16a5c50108447d92dd1a637e1", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 72, "deletions": 35, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/a8f3f038c03eb1393110dfdb1e6bdf1be6a3fb62/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8f3f038c03eb1393110dfdb1e6bdf1be6a3fb62/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=a8f3f038c03eb1393110dfdb1e6bdf1be6a3fb62", "patch": "@@ -114,7 +114,8 @@ pub enum Occur {\n pub struct Opt {\n     name: Name,\n     hasarg: HasArg,\n-    occur: Occur\n+    occur: Occur,\n+    aliases: ~[Opt],\n }\n \n fn mkname(nm: &str) -> Name {\n@@ -127,37 +128,37 @@ fn mkname(nm: &str) -> Name {\n \n /// Create an option that is required and takes an argument\n pub fn reqopt(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: Yes, occur: Req};\n+    return Opt {name: mkname(name), hasarg: Yes, occur: Req, aliases: ~[]};\n }\n \n /// Create an option that is optional and takes an argument\n pub fn optopt(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: Yes, occur: Optional};\n+    return Opt {name: mkname(name), hasarg: Yes, occur: Optional, aliases: ~[]};\n }\n \n /// Create an option that is optional and does not take an argument\n pub fn optflag(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: No, occur: Optional};\n+    return Opt {name: mkname(name), hasarg: No, occur: Optional, aliases: ~[]};\n }\n \n /** Create an option that is optional, does not take an argument,\n   * and may occur multiple times.\n   */\n pub fn optflagmulti(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: No, occur: Multi};\n+    return Opt {name: mkname(name), hasarg: No, occur: Multi, aliases: ~[]};\n }\n \n /// Create an option that is optional and takes an optional argument\n pub fn optflagopt(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: Maybe, occur: Optional};\n+    return Opt {name: mkname(name), hasarg: Maybe, occur: Optional, aliases: ~[]};\n }\n \n /**\n  * Create an option that is optional, takes an argument, and may occur\n  * multiple times\n  */\n pub fn optmulti(name: &str) -> Opt {\n-    return Opt {name: mkname(name), hasarg: Yes, occur: Multi};\n+    return Opt {name: mkname(name), hasarg: Yes, occur: Multi, aliases: ~[]};\n }\n \n #[deriving(Clone, Eq)]\n@@ -189,7 +190,20 @@ fn name_str(nm: &Name) -> ~str {\n }\n \n fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n-    opts.iter().position(|opt| opt.name == nm)\n+    // search main options\n+    let pos = opts.iter().position(|opt| opt.name == nm);\n+    if pos.is_some() {\n+        return pos\n+    }\n+\n+    // search in aliases\n+    for candidate in opts.iter() {\n+        if candidate.aliases.iter().position(|opt| opt.name == nm).is_some() {\n+            return opts.iter().position(|opt| opt.name == candidate.name);\n+        }\n+    }\n+\n+    None\n }\n \n /**\n@@ -488,8 +502,6 @@ pub mod groups {\n     use getopts::{HasArg, Long, Maybe, Multi, No, Occur, Opt, Optional, Req};\n     use getopts::{Short, Yes};\n \n-    use std::vec;\n-\n     /** one group of options, e.g., both -h and --help, along with\n      * their shared description and properties\n      */\n@@ -587,40 +599,45 @@ pub mod groups {\n \n     // translate OptGroup into Opt\n     // (both short and long names correspond to different Opts)\n-    pub fn long_to_short(lopt: &OptGroup) -> ~[Opt] {\n+    pub fn long_to_short(lopt: &OptGroup) -> Opt {\n         let OptGroup{short_name: short_name,\n                      long_name: long_name,\n                      hasarg: hasarg,\n                      occur: occur,\n                      _} = (*lopt).clone();\n \n         match (short_name.len(), long_name.len()) {\n-           (0,0) => fail!(\"this long-format option was given no name\"),\n-\n-           (0,_) => ~[Opt {name: Long((long_name)),\n-                           hasarg: hasarg,\n-                           occur: occur}],\n-\n-           (1,0) => ~[Opt {name: Short(short_name.char_at(0)),\n-                           hasarg: hasarg,\n-                           occur: occur}],\n-\n-           (1,_) => ~[Opt {name: Short(short_name.char_at(0)),\n-                           hasarg: hasarg,\n-                           occur:  occur},\n-                      Opt {name:   Long((long_name)),\n-                           hasarg: hasarg,\n-                           occur:  occur}],\n-\n-           (_,_) => fail!(\"something is wrong with the long-form opt\")\n+            (0,0) => fail!(\"this long-format option was given no name\"),\n+\n+            (0,_) => Opt {name: Long((long_name)),\n+                          hasarg: hasarg,\n+                          occur: occur,\n+                          aliases: ~[]},\n+\n+            (1,0) => Opt {name: Short(short_name.char_at(0)),\n+                          hasarg: hasarg,\n+                          occur: occur,\n+                          aliases: ~[]},\n+\n+            (1,_) => Opt {name: Long((long_name)),\n+                          hasarg: hasarg,\n+                          occur:  occur,\n+                          aliases: ~[Opt {\n+                              name: Short(short_name.char_at(0)),\n+                              hasarg: hasarg,\n+                              occur:  occur,\n+                              aliases: ~[]\n+                          }]},\n+\n+            (_,_) => fail!(\"something is wrong with the long-form opt\")\n         }\n     }\n \n     /*\n      * Parse command line args with the provided long format options\n      */\n     pub fn getopts(args: &[~str], opts: &[OptGroup]) -> ::getopts::Result {\n-        ::getopts::getopts(args, vec::flat_map(opts, long_to_short))\n+        ::getopts::getopts(args, opts.map(long_to_short))\n     }\n \n     /**\n@@ -1454,18 +1471,25 @@ mod tests {\n \n     #[test]\n     fn test_groups_long_to_short() {\n-        let short = ~[reqopt(\"b\"), reqopt(\"banana\")];\n+        let mut short = reqopt(\"banana\");\n+        short.aliases = ~[reqopt(\"b\")];\n         let verbose = groups::reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n \n         assert_eq!(groups::long_to_short(&verbose), short);\n     }\n \n     #[test]\n     fn test_groups_getopts() {\n+        let mut banana = reqopt(\"banana\");\n+        banana.aliases = ~[reqopt(\"b\")];\n+        let mut apple = optopt(\"apple\");\n+        apple.aliases = ~[optopt(\"a\")];\n+        let mut kiwi = optflag(\"kiwi\");\n+        kiwi.aliases = ~[optflag(\"k\")];\n         let short = ~[\n-            reqopt(\"b\"), reqopt(\"banana\"),\n-            optopt(\"a\"), optopt(\"apple\"),\n-            optflag(\"k\"), optflagopt(\"kiwi\"),\n+            banana,\n+            apple,\n+            kiwi,\n             optflagopt(\"p\"),\n             optmulti(\"l\")\n         ];\n@@ -1478,14 +1502,27 @@ mod tests {\n             groups::optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n         ];\n \n-        let sample_args = ~[~\"-k\", ~\"15\", ~\"--apple\", ~\"1\", ~\"k\",\n+        let sample_args = ~[~\"--kiwi\", ~\"15\", ~\"--apple\", ~\"1\", ~\"k\",\n                             ~\"-p\", ~\"16\", ~\"l\", ~\"35\"];\n \n         // FIXME #4681: sort options here?\n         assert!(getopts(sample_args, short)\n             == groups::getopts(sample_args, verbose));\n     }\n \n+    #[test]\n+    fn test_groups_aliases_long_and_short() {\n+        let opts = ~[\n+            groups::optflagmulti(\"a\", \"apple\", \"Desc\"),\n+        ];\n+\n+        let args = ~[~\"-a\", ~\"--apple\", ~\"-a\"];\n+\n+        let matches = groups::getopts(args, opts).unwrap();\n+        assert_eq!(3, opt_count(&matches, \"a\"));\n+        assert_eq!(3, opt_count(&matches, \"apple\"));\n+    }\n+\n     #[test]\n     fn test_groups_usage() {\n         let optgroups = ~["}]}