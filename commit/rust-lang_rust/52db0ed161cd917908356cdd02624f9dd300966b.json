{"sha": "52db0ed161cd917908356cdd02624f9dd300966b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyZGIwZWQxNjFjZDkxNzkwODM1NmNkZDAyNjI0ZjlkZDMwMDk2NmI=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-08-04T09:19:38Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-08-04T09:19:38Z"}, "message": "Rollup merge of #51919 - tbu-:pr_num_to_from_bytes2, r=SimonSapin\n\nProvide `{to,from}_{ne,le,be}_bytes` functions on integers\n\nIf one doesn't view integers as containers of bytes, converting them to\nbytes necessarily needs the specfication of encoding.\n\nI think Rust is a language that wants to be explicit. The `to_bytes`\nfunction is basically the opposite of that \u2013 it converts an integer into\nthe native byte representation, but there's no mention (in the function\nname) of it being very much platform dependent. Therefore, I think it\nwould be better to replace that method by three methods, the explicit\n`to_ne_bytes` (\"native endian\") which does the same thing and\n`to_{le,be}_bytes` which return the little- resp. big-endian encoding.", "tree": {"sha": "9f380d2c15da850a8e6a0eb386993e9d574f1cb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f380d2c15da850a8e6a0eb386993e9d574f1cb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52db0ed161cd917908356cdd02624f9dd300966b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAltlb6oACgkQ/vbIBR0O\nATymxxAAkgao/Af0FrP+tknhV3dV/qg+pJWDdJQhI9DsS/Oo8E+P0iNN72fwQkuK\nu74j81teom88iR7H4CCvg586LYsgB6xCO1ELDuxjlEUEzzK34V1LtKWB4ToP0rqU\nnKsitQp1hYRfWEuYAGmqBHjGZx2Q0mOE6cDCj0FBWd9EYL9JCe5SzP/7QZmH8/6v\nMicNvttKviKgJAUmazVUAZ7e1wBB1KOseLXOD8amJLrjC3E8+EmgWQQ8YULEg/+8\nEMsdZXZ6EBghmNEyijMBc9Bgf3O6FfmcVckTN5XXrv00F/ZzM2/KxzkJBX1cGzzx\ndDg5Xb3eFJF/48kOzJr/W7nlWizCM8gGXg+CJ7qoVuiNJWx/STU0Pkk89V2QWILH\nWWBSvtdOWU/19QaamqwZ6UEwEgJWTD8rAVxPxnkv2xaTC7JccQOCLfX3Kg5izMBa\nvNhAUjETIVsAdWkcH86IxSN7mZV827Np5c4RtVIOsi+XwybL4T+P4U5FJWi4kzCo\nlb47Vzatguonqx0KjsxkIsEZVjPwyYUfGmL8AWOYhIsCtmk9wx9GKrtRmMWFvIw3\n+60p/4e9WajYXOMk46IcrdQYb0Mr+Skn1LMMKEuTNRLrZvNXOoEvSRxAa6zlHP7T\njO9YrPcbWg+mHqB6g5hI7ja0PaIq8OiWY2yg6pqHAEBagO2K8B4=\n=Ghjx\n-----END PGP SIGNATURE-----", "payload": "tree 9f380d2c15da850a8e6a0eb386993e9d574f1cb8\nparent aefa307c1fce043062d9d811f91476c0b22c6a6d\nparent 0ddfae5ba2d0104a33f3a7162571b761458f0464\nauthor kennytm <kennytm@gmail.com> 1533374378 +0800\ncommitter kennytm <kennytm@gmail.com> 1533374378 +0800\n\nRollup merge of #51919 - tbu-:pr_num_to_from_bytes2, r=SimonSapin\n\nProvide `{to,from}_{ne,le,be}_bytes` functions on integers\n\nIf one doesn't view integers as containers of bytes, converting them to\nbytes necessarily needs the specfication of encoding.\n\nI think Rust is a language that wants to be explicit. The `to_bytes`\nfunction is basically the opposite of that \u2013 it converts an integer into\nthe native byte representation, but there's no mention (in the function\nname) of it being very much platform dependent. Therefore, I think it\nwould be better to replace that method by three methods, the explicit\n`to_ne_bytes` (\"native endian\") which does the same thing and\n`to_{le,be}_bytes` which return the little- resp. big-endian encoding.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52db0ed161cd917908356cdd02624f9dd300966b", "html_url": "https://github.com/rust-lang/rust/commit/52db0ed161cd917908356cdd02624f9dd300966b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52db0ed161cd917908356cdd02624f9dd300966b/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aefa307c1fce043062d9d811f91476c0b22c6a6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/aefa307c1fce043062d9d811f91476c0b22c6a6d", "html_url": "https://github.com/rust-lang/rust/commit/aefa307c1fce043062d9d811f91476c0b22c6a6d"}, {"sha": "0ddfae5ba2d0104a33f3a7162571b761458f0464", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ddfae5ba2d0104a33f3a7162571b761458f0464", "html_url": "https://github.com/rust-lang/rust/commit/0ddfae5ba2d0104a33f3a7162571b761458f0464"}], "stats": {"total": 108, "additions": 90, "deletions": 18}, "files": [{"sha": "6e2fbf6f84f0f48a63832f877f69d78256362187", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 90, "deletions": 18, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/52db0ed161cd917908356cdd02624f9dd300966b/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52db0ed161cd917908356cdd02624f9dd300966b/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=52db0ed161cd917908356cdd02624f9dd300966b", "patch": "@@ -1892,47 +1892,119 @@ $EndFeature, \"\n             pub fn is_negative(self) -> bool { self < 0 }\n         }\n \n-        /// Return the memory representation of this integer as a byte array.\n+        /// Return the memory representation of this integer as a byte array in\n+        /// big-endian (network) byte order.\n         ///\n-        /// The target platform\u2019s native endianness is used.\n-        /// Portable code likely wants to use this after [`to_be`] or [`to_le`].\n+        /// # Examples\n         ///\n-        /// [`to_be`]: #method.to_be\n-        /// [`to_le`]: #method.to_le\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let bytes = 0x12345678i32.to_be_bytes();\n+        /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        pub fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            self.to_be().to_ne_bytes()\n+        }\n+\n+        /// Return the memory representation of this integer as a byte array in\n+        /// little-endian byte order.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let bytes = 0x12345678i32.to_le_bytes();\n+        /// assert_eq!(bytes, [0x78, 0x56, 0x34, 0x12]);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        pub fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            self.to_le().to_ne_bytes()\n+        }\n+\n+        /// Return the memory representation of this integer as a byte array in\n+        /// native byte order.\n+        ///\n+        /// As the target platform's native endianness is used, portable code\n+        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n+        /// instead.\n+        ///\n+        /// [`to_be_bytes`]: #method.to_be_bytes\n+        /// [`to_le_bytes`]: #method.to_le_bytes\n         ///\n         /// # Examples\n         ///\n         /// ```\n         /// #![feature(int_to_from_bytes)]\n         ///\n-        /// let bytes = i32::min_value().to_be().to_bytes();\n+        /// let bytes = i32::min_value().to_be().to_ne_bytes();\n         /// assert_eq!(bytes, [0x80, 0, 0, 0]);\n         /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n         #[inline]\n-        pub fn to_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+        pub fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n             unsafe { mem::transmute(self) }\n         }\n \n-        /// Create an integer value from its memory representation as a byte array.\n+        /// Create an integer value from its representation as a byte array in\n+        /// big endian.\n         ///\n-        /// The target platform\u2019s native endianness is used.\n-        /// Portable code likely wants to use [`from_be`] or [`from_le`] after this.\n+        /// # Examples\n         ///\n-        /// [`from_be`]: #method.from_be\n-        /// [`from_le`]: #method.from_le\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let int = i32::from_be_bytes([0x12, 0x34, 0x56, 0x78]);\n+        /// assert_eq!(int, 0x12_34_56_78);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        pub fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            Self::from_be(Self::from_ne_bytes(bytes))\n+        }\n+\n+        /// Create an integer value from its representation as a byte array in\n+        /// little endian.\n         ///\n         /// # Examples\n         ///\n         /// ```\n         /// #![feature(int_to_from_bytes)]\n         ///\n-        /// let int = i32::from_be(i32::from_bytes([0x80, 0, 0, 0]));\n+        /// let int = i32::from_le_bytes([0x12, 0x34, 0x56, 0x78]);\n+        /// assert_eq!(int, 0x78_56_34_12);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        pub fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            Self::from_le(Self::from_ne_bytes(bytes))\n+        }\n+\n+        /// Create an integer value from its memory representation as a byte\n+        /// array in native endianness.\n+        ///\n+        /// As the target platform's native endianness is used, portable code\n+        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n+        /// appropriate instead.\n+        ///\n+        /// [`from_be_bytes`]: #method.from_be_bytes\n+        /// [`from_le_bytes`]: #method.from_le_bytes\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let int = i32::from_be(i32::from_ne_bytes([0x80, 0, 0, 0]));\n         /// assert_eq!(int, i32::min_value());\n         /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n         #[inline]\n-        pub fn from_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+        pub fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n             unsafe { mem::transmute(bytes) }\n         }\n     }\n@@ -3517,7 +3589,7 @@ $EndFeature, \"\n         /// let bytes = 0x1234_5678_u32.to_be().to_bytes();\n         /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);\n         /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n         #[inline]\n         pub fn to_bytes(self) -> [u8; mem::size_of::<Self>()] {\n             unsafe { mem::transmute(self) }\n@@ -3539,7 +3611,7 @@ $EndFeature, \"\n         /// let int = u32::from_be(u32::from_bytes([0x12, 0x34, 0x56, 0x78]));\n         /// assert_eq!(int, 0x1234_5678_u32);\n         /// ```\n-        #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n         #[inline]\n         pub fn from_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n             unsafe { mem::transmute(bytes) }"}]}