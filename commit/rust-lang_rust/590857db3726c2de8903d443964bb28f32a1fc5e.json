{"sha": "590857db3726c2de8903d443964bb28f32a1fc5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MDg1N2RiMzcyNmMyZGU4OTAzZDQ0Mzk2NGJiMjhmMzJhMWZjNWU=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-01-10T08:15:02Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-01-10T08:15:02Z"}, "message": "Reformat a nested function call with a single newline using larger budget", "tree": {"sha": "afb17beca88e13263be6acdddd5ddd0d7a1e7c73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afb17beca88e13263be6acdddd5ddd0d7a1e7c73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/590857db3726c2de8903d443964bb28f32a1fc5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/590857db3726c2de8903d443964bb28f32a1fc5e", "html_url": "https://github.com/rust-lang/rust/commit/590857db3726c2de8903d443964bb28f32a1fc5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/590857db3726c2de8903d443964bb28f32a1fc5e/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60256b7f3d92a70ec9ab06f4ff28a9fde0728e7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/60256b7f3d92a70ec9ab06f4ff28a9fde0728e7b", "html_url": "https://github.com/rust-lang/rust/commit/60256b7f3d92a70ec9ab06f4ff28a9fde0728e7b"}], "stats": {"total": 28, "additions": 24, "deletions": 4}, "files": [{"sha": "157147c4a06ede9098af1d2d86c77771150ece38", "filename": "src/expr.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/590857db3726c2de8903d443964bb28f32a1fc5e/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590857db3726c2de8903d443964bb28f32a1fc5e/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=590857db3726c2de8903d443964bb28f32a1fc5e", "patch": "@@ -31,9 +31,10 @@ use shape::{Indent, Shape};\n use spanned::Spanned;\n use string::{rewrite_string, StringFormat};\n use types::{can_be_overflowed_type, rewrite_path, PathContext};\n-use utils::{colon_spaces, contains_skip, extra_offset, first_line_width, inner_attributes,\n-            last_line_extendable, last_line_width, mk_sp, outer_attributes, paren_overhead,\n-            ptr_vec_to_ref_vec, semicolon_for_stmt, trimmed_last_line_width, wrap_str};\n+use utils::{colon_spaces, contains_skip, count_newlines, extra_offset, first_line_width,\n+            inner_attributes, last_line_extendable, last_line_width, mk_sp, outer_attributes,\n+            paren_overhead, ptr_vec_to_ref_vec, semicolon_for_stmt, trimmed_last_line_width,\n+            wrap_str};\n use vertical::rewrite_with_alignment;\n use visitor::FmtVisitor;\n \n@@ -2053,6 +2054,26 @@ where\n     // Replace the stub with the full overflowing last argument if the rewrite\n     // succeeded and its first line fits with the other arguments.\n     match (overflow_last, tactic, placeholder) {\n+        (true, DefinitiveListTactic::Horizontal, Some(ref overflowed)) if args.len() == 1 => {\n+            // When we are rewriting a nested function call, we restrict the\n+            // bugdet for the inner function to avoid them being deeply nested.\n+            // However, when the inner function has a prefix or a suffix\n+            // (e.g. `foo() as u32`), this budget reduction may produce poorly\n+            // formatted code, where a prefix or a suffix being left on its own\n+            // line. Here we explicitlly check those cases.\n+            if count_newlines(overflowed) == 1 {\n+                let rw = args.last()\n+                    .and_then(|last_arg| last_arg.rewrite(context, nested_shape));\n+                let no_newline = rw.as_ref().map_or(false, |s| !s.contains('\\n'));\n+                if no_newline {\n+                    item_vec[args.len() - 1].item = rw;\n+                } else {\n+                    item_vec[args.len() - 1].item = Some(overflowed.to_owned());\n+                }\n+            } else {\n+                item_vec[args.len() - 1].item = Some(overflowed.to_owned());\n+            }\n+        }\n         (true, DefinitiveListTactic::Horizontal, placeholder @ Some(..)) => {\n             item_vec[args.len() - 1].item = placeholder;\n         }\n@@ -2824,7 +2845,6 @@ pub fn choose_rhs<R: Rewrite>(\n }\n \n fn prefer_next_line(orig_rhs: &str, next_line_rhs: &str) -> bool {\n-    use utils::count_newlines;\n     !next_line_rhs.contains('\\n') || count_newlines(orig_rhs) > count_newlines(next_line_rhs) + 1\n }\n "}]}