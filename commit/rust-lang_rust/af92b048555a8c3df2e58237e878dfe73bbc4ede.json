{"sha": "af92b048555a8c3df2e58237e878dfe73bbc4ede", "node_id": "C_kwDOAAsO6NoAKGFmOTJiMDQ4NTU1YThjM2RmMmU1ODIzN2U4NzhkZmU3M2JiYzRlZGU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-27T14:19:00Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-28T07:53:14Z"}, "message": "move interpreter loop into thread manager; they are pretty tightly coupled anyway", "tree": {"sha": "246c646e30ef60e54c6edacd502e5aa025759645", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/246c646e30ef60e54c6edacd502e5aa025759645"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af92b048555a8c3df2e58237e878dfe73bbc4ede", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af92b048555a8c3df2e58237e878dfe73bbc4ede", "html_url": "https://github.com/rust-lang/rust/commit/af92b048555a8c3df2e58237e878dfe73bbc4ede", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af92b048555a8c3df2e58237e878dfe73bbc4ede/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5238d1779778097d0bcf3a9fc83bb4a37732cb3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5238d1779778097d0bcf3a9fc83bb4a37732cb3e", "html_url": "https://github.com/rust-lang/rust/commit/5238d1779778097d0bcf3a9fc83bb4a37732cb3e"}], "stats": {"total": 154, "additions": 76, "deletions": 78}, "files": [{"sha": "900d24443cc9668b454dc038271ab0b9e2535c26", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 70, "deletions": 50, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/af92b048555a8c3df2e58237e878dfe73bbc4ede/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af92b048555a8c3df2e58237e878dfe73bbc4ede/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=af92b048555a8c3df2e58237e878dfe73bbc4ede", "patch": "@@ -21,7 +21,7 @@ use crate::shims::tls;\n use crate::*;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-pub enum SchedulingAction {\n+enum SchedulingAction {\n     /// Execute step on the active thread.\n     ExecuteStep,\n     /// Execute a timeout callback.\n@@ -450,8 +450,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Get a mutable borrow of the currently active thread.\n-    /// (Private for a bit of protection.)\n-    fn active_thread_mut(&mut self) -> &mut Thread<'mir, 'tcx> {\n+    pub fn active_thread_mut(&mut self) -> &mut Thread<'mir, 'tcx> {\n         &mut self.threads[self.active_thread]\n     }\n \n@@ -718,6 +717,51 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n }\n \n+impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n+    /// Execute a timeout callback on the callback's thread.\n+    #[inline]\n+    fn run_timeout_callback(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let (thread, callback) = if let Some((thread, callback)) =\n+            this.machine.threads.get_ready_callback(&this.machine.clock)\n+        {\n+            (thread, callback)\n+        } else {\n+            // get_ready_callback can return None if the computer's clock\n+            // was shifted after calling the scheduler and before the call\n+            // to get_ready_callback (see issue\n+            // https://github.com/rust-lang/miri/issues/1763). In this case,\n+            // just do nothing, which effectively just returns to the\n+            // scheduler.\n+            return Ok(());\n+        };\n+        // This back-and-forth with `set_active_thread` is here because of two\n+        // design decisions:\n+        // 1. Make the caller and not the callback responsible for changing\n+        //    thread.\n+        // 2. Make the scheduler the only place that can change the active\n+        //    thread.\n+        let old_thread = this.set_active_thread(thread);\n+        callback.call(this)?;\n+        this.set_active_thread(old_thread);\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn run_on_stack_empty(&mut self) -> InterpResult<'tcx, Poll<()>> {\n+        let this = self.eval_context_mut();\n+        let mut callback = this\n+            .active_thread_mut()\n+            .on_stack_empty\n+            .take()\n+            .expect(\"`on_stack_empty` not set up, or already running\");\n+        let res = callback(this)?;\n+        this.active_thread_mut().on_stack_empty = Some(callback);\n+        Ok(res)\n+    }\n+}\n+\n // Public interface to thread management.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n@@ -961,61 +1005,37 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.machine.threads.unregister_timeout_callback_if_exists(thread);\n     }\n \n-    /// Execute a timeout callback on the callback's thread.\n-    #[inline]\n-    fn run_timeout_callback(&mut self) -> InterpResult<'tcx> {\n+    /// Run the core interpreter loop. Returns only when an interrupt occurs (an error or program\n+    /// termination).\n+    fn run_threads(&mut self) -> InterpResult<'tcx, !> {\n         let this = self.eval_context_mut();\n-        let (thread, callback) = if let Some((thread, callback)) =\n-            this.machine.threads.get_ready_callback(&this.machine.clock)\n-        {\n-            (thread, callback)\n-        } else {\n-            // get_ready_callback can return None if the computer's clock\n-            // was shifted after calling the scheduler and before the call\n-            // to get_ready_callback (see issue\n-            // https://github.com/rust-lang/miri/issues/1763). In this case,\n-            // just do nothing, which effectively just returns to the\n-            // scheduler.\n-            return Ok(());\n-        };\n-        // This back-and-forth with `set_active_thread` is here because of two\n-        // design decisions:\n-        // 1. Make the caller and not the callback responsible for changing\n-        //    thread.\n-        // 2. Make the scheduler the only place that can change the active\n-        //    thread.\n-        let old_thread = this.set_active_thread(thread);\n-        callback.call(this)?;\n-        this.set_active_thread(old_thread);\n-        Ok(())\n-    }\n-\n-    #[inline]\n-    fn run_on_stack_empty(&mut self) -> InterpResult<'tcx, Poll<()>> {\n-        let this = self.eval_context_mut();\n-        let mut callback = this\n-            .active_thread_mut()\n-            .on_stack_empty\n-            .take()\n-            .expect(\"`on_stack_empty` not set up, or already running\");\n-        let res = callback(this)?;\n-        this.active_thread_mut().on_stack_empty = Some(callback);\n-        Ok(res)\n-    }\n-\n-    /// Decide which action to take next and on which thread.\n-    #[inline]\n-    fn schedule(&mut self) -> InterpResult<'tcx, SchedulingAction> {\n-        let this = self.eval_context_mut();\n-        this.machine.threads.schedule(&this.machine.clock)\n+        loop {\n+            match this.machine.threads.schedule(&this.machine.clock)? {\n+                SchedulingAction::ExecuteStep => {\n+                    if !this.step()? {\n+                        // See if this thread can do something else.\n+                        match this.run_on_stack_empty()? {\n+                            Poll::Pending => {} // keep going\n+                            Poll::Ready(()) => this.terminate_active_thread()?,\n+                        }\n+                    }\n+                }\n+                SchedulingAction::ExecuteTimeoutCallback => {\n+                    this.run_timeout_callback()?;\n+                }\n+                SchedulingAction::Sleep(duration) => {\n+                    this.machine.clock.sleep(duration);\n+                }\n+            }\n+        }\n     }\n \n     /// Handles thread termination of the active thread: wakes up threads joining on this one,\n     /// and deallocated thread-local statics.\n     ///\n     /// This is called by the eval loop when a thread's on_stack_empty returns `Ready`.\n     #[inline]\n-    fn thread_terminated(&mut self) -> InterpResult<'tcx> {\n+    fn terminate_active_thread(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let thread = this.active_thread_mut();\n         assert!(thread.stack.is_empty(), \"only threads with an empty stack can be terminated\");"}, {"sha": "c7f3c9577a8754db8dce549f808c7642ec2e4376", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/af92b048555a8c3df2e58237e878dfe73bbc4ede/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af92b048555a8c3df2e58237e878dfe73bbc4ede/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=af92b048555a8c3df2e58237e878dfe73bbc4ede", "patch": "@@ -229,9 +229,9 @@ impl MainThreadState {\n                     this.machine.layouts.isize,\n                 );\n                 let exit_code = this.read_scalar(&ret_place.into())?.to_machine_isize(this)?;\n-                // Need to call `thread_terminated` ourselves since we are not going to\n-                // return to the scheduler loop.\n-                this.thread_terminated()?;\n+                // Need to call this ourselves since we are not going to return to the scheduler\n+                // loop, and we want the main thread TLS to not show up as memory leaks.\n+                this.terminate_active_thread()?;\n                 // Stop interpreter loop.\n                 throw_machine_stop!(TerminationInfo::Exit { code: exit_code, leak_check: true });\n             }\n@@ -416,28 +416,8 @@ pub fn eval_entry<'tcx>(\n     };\n \n     // Perform the main execution.\n-    let res: thread::Result<InterpResult<'_, !>> = panic::catch_unwind(AssertUnwindSafe(|| {\n-        // Main loop. Goes on forever until an interrupt is triggered (represented as `InterpError`).\n-        loop {\n-            match ecx.schedule()? {\n-                SchedulingAction::ExecuteStep => {\n-                    if !ecx.step()? {\n-                        // See if this thread can do something else.\n-                        match ecx.run_on_stack_empty()? {\n-                            Poll::Pending => {} // keep going\n-                            Poll::Ready(()) => ecx.thread_terminated()?,\n-                        }\n-                    }\n-                }\n-                SchedulingAction::ExecuteTimeoutCallback => {\n-                    ecx.run_timeout_callback()?;\n-                }\n-                SchedulingAction::Sleep(duration) => {\n-                    ecx.machine.clock.sleep(duration);\n-                }\n-            }\n-        }\n-    }));\n+    let res: thread::Result<InterpResult<'_, !>> =\n+        panic::catch_unwind(AssertUnwindSafe(|| ecx.run_threads()));\n     let res = res.unwrap_or_else(|panic_payload| {\n         ecx.handle_ice();\n         panic::resume_unwind(panic_payload)"}, {"sha": "6f483cf2cc4800d84ef71ef4781de05e65437f66", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af92b048555a8c3df2e58237e878dfe73bbc4ede/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af92b048555a8c3df2e58237e878dfe73bbc4ede/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=af92b048555a8c3df2e58237e878dfe73bbc4ede", "patch": "@@ -89,9 +89,7 @@ pub use crate::concurrency::{\n     data_race::{AtomicFenceOrd, AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd, EvalContextExt as _},\n     init_once::{EvalContextExt as _, InitOnceId},\n     sync::{CondvarId, EvalContextExt as _, MutexId, RwLockId, SyncId},\n-    thread::{\n-        EvalContextExt as _, SchedulingAction, StackEmptyCallback, ThreadId, ThreadManager, Time,\n-    },\n+    thread::{EvalContextExt as _, StackEmptyCallback, ThreadId, ThreadManager, Time},\n };\n pub use crate::diagnostics::{\n     report_error, EvalContextExt as _, NonHaltingDiagnostic, TerminationInfo,"}]}