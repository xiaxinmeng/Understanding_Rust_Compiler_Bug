{"sha": "7945eff0805d91d3c0ca10df872bcabdd88aa4b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5NDVlZmYwODA1ZDkxZDNjMGNhMTBkZjg3MmJjYWJkZDg4YWE0YjY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-03-26T14:02:02Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-03-27T09:19:47Z"}, "message": "generalize diagnostic for x = y where type bool is expected.", "tree": {"sha": "f31e4a3c86622a43b443f0feff9eed6038fa00e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f31e4a3c86622a43b443f0feff9eed6038fa00e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7945eff0805d91d3c0ca10df872bcabdd88aa4b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7945eff0805d91d3c0ca10df872bcabdd88aa4b6", "html_url": "https://github.com/rust-lang/rust/commit/7945eff0805d91d3c0ca10df872bcabdd88aa4b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7945eff0805d91d3c0ca10df872bcabdd88aa4b6/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "267fb90b55736dc2362e8621a247f54da5fd8d40", "url": "https://api.github.com/repos/rust-lang/rust/commits/267fb90b55736dc2362e8621a247f54da5fd8d40", "html_url": "https://github.com/rust-lang/rust/commit/267fb90b55736dc2362e8621a247f54da5fd8d40"}], "stats": {"total": 196, "additions": 111, "deletions": 85}, "files": [{"sha": "ac8b639edbfa363556799a79a3579ee8c9d50605", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7945eff0805d91d3c0ca10df872bcabdd88aa4b6/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7945eff0805d91d3c0ca10df872bcabdd88aa4b6/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=7945eff0805d91d3c0ca10df872bcabdd88aa4b6", "patch": "@@ -1233,7 +1233,12 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                     augment_error(&mut db);\n                 }\n \n-                db.emit();\n+                if expression.filter(|e| fcx.is_assign_to_bool(e, expected)).is_some() {\n+                    // Error reported in `check_assign` so avoid emitting error again.\n+                    db.delay_as_bug();\n+                } else {\n+                    db.emit();\n+                }\n \n                 self.final_ty = Some(fcx.tcx.types.err);\n             }"}, {"sha": "60fa266f0bbe1350828f135aeffe57bea4702e05", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 52, "deletions": 31, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7945eff0805d91d3c0ca10df872bcabdd88aa4b6/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7945eff0805d91d3c0ca10df872bcabdd88aa4b6/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=7945eff0805d91d3c0ca10df872bcabdd88aa4b6", "patch": "@@ -119,44 +119,65 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n         let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e);\n \n-        // If the expected type is an enum (Issue #55250) with any variants whose\n-        // sole field is of the found type, suggest such variants. (Issue #42764)\n-        if let ty::Adt(expected_adt, substs) = expected.sty {\n-            if expected_adt.is_enum() {\n-                let mut compatible_variants = expected_adt.variants\n-                    .iter()\n-                    .filter(|variant| variant.fields.len() == 1)\n-                    .filter_map(|variant| {\n-                        let sole_field = &variant.fields[0];\n-                        let sole_field_ty = sole_field.ty(self.tcx, substs);\n-                        if self.can_coerce(expr_ty, sole_field_ty) {\n-                            let variant_path = self.tcx.def_path_str(variant.def_id);\n-                            // FIXME #56861: DRYer prelude filtering\n-                            Some(variant_path.trim_start_matches(\"std::prelude::v1::\").to_string())\n-                        } else {\n-                            None\n-                        }\n-                    }).peekable();\n-\n-                if compatible_variants.peek().is_some() {\n-                    let expr_text = print::to_string(print::NO_ANN, |s| s.print_expr(expr));\n-                    let suggestions = compatible_variants\n-                        .map(|v| format!(\"{}({})\", v, expr_text));\n-                    err.span_suggestions(\n-                        expr.span,\n-                        \"try using a variant of the expected type\",\n-                        suggestions,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-            }\n+        if self.is_assign_to_bool(expr, expected) {\n+            // Error reported in `check_assign` so avoid emitting error again.\n+            err.delay_as_bug();\n+            return (expected, None)\n         }\n \n+        self.suggest_compatible_variants(&mut err, expr, expected, expr_ty);\n         self.suggest_ref_or_into(&mut err, expr, expected, expr_ty);\n \n         (expected, Some(err))\n     }\n \n+    /// Returns whether the expected type is `bool` and the expression is `x = y`.\n+    pub fn is_assign_to_bool(&self, expr: &hir::Expr, expected: Ty<'tcx>) -> bool {\n+        if let hir::ExprKind::Assign(..) = expr.node {\n+            return expected == self.tcx.types.bool;\n+        }\n+        false\n+    }\n+\n+    /// If the expected type is an enum (Issue #55250) with any variants whose\n+    /// sole field is of the found type, suggest such variants. (Issue #42764)\n+    fn suggest_compatible_variants(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr,\n+        expected: Ty<'tcx>,\n+        expr_ty: Ty<'tcx>,\n+    ) {\n+        if let ty::Adt(expected_adt, substs) = expected.sty {\n+            if !expected_adt.is_enum() {\n+                return;\n+            }\n+\n+            let mut compatible_variants = expected_adt.variants\n+                .iter()\n+                .filter(|variant| variant.fields.len() == 1)\n+                .filter_map(|variant| {\n+                    let sole_field = &variant.fields[0];\n+                    let sole_field_ty = sole_field.ty(self.tcx, substs);\n+                    if self.can_coerce(expr_ty, sole_field_ty) {\n+                        let variant_path = self.tcx.def_path_str(variant.def_id);\n+                        // FIXME #56861: DRYer prelude filtering\n+                        Some(variant_path.trim_start_matches(\"std::prelude::v1::\").to_string())\n+                    } else {\n+                        None\n+                    }\n+                }).peekable();\n+\n+            if compatible_variants.peek().is_some() {\n+                let expr_text = print::to_string(print::NO_ANN, |s| s.print_expr(expr));\n+                let suggestions = compatible_variants\n+                    .map(|v| format!(\"{}({})\", v, expr_text));\n+                let msg = \"try using a variant of the expected type\";\n+                err.span_suggestions(expr.span, msg, suggestions, Applicability::MaybeIncorrect);\n+            }\n+        }\n+    }\n+\n     pub fn get_conversion_methods(&self, span: Span, expected: Ty<'tcx>, checked_ty: Ty<'tcx>)\n                               -> Vec<AssociatedItem> {\n         let mut methods = self.probe_for_return_type(span,"}, {"sha": "804fe9c5b5dc97f0885f7eae91cc495803eb70b4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/7945eff0805d91d3c0ca10df872bcabdd88aa4b6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7945eff0805d91d3c0ca10df872bcabdd88aa4b6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7945eff0805d91d3c0ca10df872bcabdd88aa4b6", "patch": "@@ -246,9 +246,6 @@ pub enum Expectation<'tcx> {\n     /// We know nothing about what type this expression should have.\n     NoExpectation,\n \n-    /// This expression is an `if` condition, it must resolve to `bool`.\n-    ExpectIfCondition,\n-\n     /// This expression should have the type given (or some subtype).\n     ExpectHasType(Ty<'tcx>),\n \n@@ -328,7 +325,6 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     fn resolve(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Expectation<'tcx> {\n         match self {\n             NoExpectation => NoExpectation,\n-            ExpectIfCondition => ExpectIfCondition,\n             ExpectCastableToType(t) => {\n                 ExpectCastableToType(fcx.resolve_type_vars_if_possible(&t))\n             }\n@@ -344,7 +340,6 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     fn to_option(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             NoExpectation => None,\n-            ExpectIfCondition => Some(fcx.tcx.types.bool),\n             ExpectCastableToType(ty) |\n             ExpectHasType(ty) |\n             ExpectRvalueLikeUnsized(ty) => Some(ty),\n@@ -358,7 +353,6 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     fn only_has_type(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             ExpectHasType(ty) => Some(ty),\n-            ExpectIfCondition => Some(fcx.tcx.types.bool),\n             NoExpectation | ExpectCastableToType(_) | ExpectRvalueLikeUnsized(_) => None,\n         }\n     }\n@@ -3150,25 +3144,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            // Add help to type error if this is an `if` condition with an assignment.\n-            if let (ExpectIfCondition, &ExprKind::Assign(ref lhs, ref rhs))\n-                 = (expected, &expr.node)\n-            {\n-                let msg = \"try comparing for equality\";\n-                if let (Ok(left), Ok(right)) = (\n-                    self.tcx.sess.source_map().span_to_snippet(lhs.span),\n-                    self.tcx.sess.source_map().span_to_snippet(rhs.span))\n-                {\n-                    err.span_suggestion(\n-                        expr.span,\n-                        msg,\n-                        format!(\"{} == {}\", left, right),\n-                        Applicability::MaybeIncorrect);\n-                } else {\n-                    err.help(msg);\n-                }\n+            if self.is_assign_to_bool(expr, expected_ty) {\n+                // Error reported in `check_assign` so avoid emitting error again.\n+                // FIXME(centril): Consider removing if/when `if` desugars to `match`.\n+                err.delay_as_bug();\n+            } else {\n+                err.emit();\n             }\n-            err.emit();\n         }\n         ty\n     }\n@@ -3339,7 +3321,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        opt_else_expr: Option<&'gcx hir::Expr>,\n                        sp: Span,\n                        expected: Expectation<'tcx>) -> Ty<'tcx> {\n-        let cond_ty = self.check_expr_meets_expectation_or_error(cond_expr, ExpectIfCondition);\n+        let cond_ty = self.check_expr_has_type_or_error(cond_expr, self.tcx.types.bool);\n         let cond_diverges = self.diverges.get();\n         self.diverges.set(Diverges::Maybe);\n \n@@ -4424,34 +4406,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 tcx.types.never\n             }\n             ExprKind::Assign(ref lhs, ref rhs) => {\n-                let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n-\n-                let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n-\n-                match expected {\n-                    ExpectIfCondition => {\n-                        self.tcx.sess.delay_span_bug(lhs.span, \"invalid lhs expression in if;\\\n-                                                                expected error elsehwere\");\n-                    }\n-                    _ => {\n-                        // Only check this if not in an `if` condition, as the\n-                        // mistyped comparison help is more appropriate.\n-                        if !lhs.is_place_expr() {\n-                            struct_span_err!(self.tcx.sess, expr.span, E0070,\n-                                                \"invalid left-hand side expression\")\n-                                .span_label(expr.span, \"left-hand of expression not valid\")\n-                                .emit();\n-                        }\n-                    }\n-                }\n-\n-                self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n-\n-                if lhs_ty.references_error() || rhs_ty.references_error() {\n-                    tcx.types.err\n-                } else {\n-                    tcx.mk_unit()\n-                }\n+                self.check_assign(expr, expected, lhs, rhs)\n             }\n             ExprKind::If(ref cond, ref then_expr, ref opt_else_expr) => {\n                 self.check_then_else(&cond, then_expr, opt_else_expr.as_ref().map(|e| &**e),\n@@ -4752,6 +4707,51 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Type check assignment expression `expr` of form `lhs = rhs`.\n+    /// The expected type is `()` and is passsed to the function for the purposes of diagnostics.\n+    fn check_assign(\n+        &self,\n+        expr: &'gcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+        lhs: &'gcx hir::Expr,\n+        rhs: &'gcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n+        let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n+\n+        let expected_ty = expected.coercion_target_type(self, expr.span);\n+        if expected_ty == self.tcx.types.bool {\n+            // The expected type is `bool` but this will result in `()` so we can reasonably\n+            // say that the user intended to write `lhs == rhs` instead of `lhs = rhs`.\n+            // The likely cause of this is `if foo = bar { .. }`.\n+            let actual_ty = self.tcx.mk_unit();\n+            let mut err = self.demand_suptype_diag(expr.span, expected_ty, actual_ty).unwrap();\n+            let msg = \"try comparing for equality\";\n+            let left = self.tcx.sess.source_map().span_to_snippet(lhs.span);\n+            let right = self.tcx.sess.source_map().span_to_snippet(rhs.span);\n+            if let (Ok(left), Ok(right)) = (left, right) {\n+                let help = format!(\"{} == {}\", left, right);\n+                err.span_suggestion(expr.span, msg, help, Applicability::MaybeIncorrect);\n+            } else {\n+                err.help(msg);\n+            }\n+            err.emit();\n+        } else if !lhs.is_place_expr() {\n+            struct_span_err!(self.tcx.sess, expr.span, E0070,\n+                                \"invalid left-hand side expression\")\n+                .span_label(expr.span, \"left-hand of expression not valid\")\n+                .emit();\n+        }\n+\n+        self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n+\n+        if lhs_ty.references_error() || rhs_ty.references_error() {\n+            self.tcx.types.err\n+        } else {\n+            self.tcx.mk_unit()\n+        }\n+    }\n+\n     // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n     // The newly resolved definition is written into `type_dependent_defs`.\n     fn finish_resolving_struct_path(&self,"}]}