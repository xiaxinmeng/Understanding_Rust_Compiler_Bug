{"sha": "276b8b125d3f60cebab702542b60207429fbb333", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NmI4YjEyNWQzZjYwY2ViYWI3MDI1NDJiNjAyMDc0MjlmYmIzMzM=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-08-19T00:52:38Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-08-28T16:12:54Z"}, "message": "Fallout from stabilizing core::option", "tree": {"sha": "022549e5a1b801df28b222d3bcd37194b997b849", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/022549e5a1b801df28b222d3bcd37194b997b849"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/276b8b125d3f60cebab702542b60207429fbb333", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/276b8b125d3f60cebab702542b60207429fbb333", "html_url": "https://github.com/rust-lang/rust/commit/276b8b125d3f60cebab702542b60207429fbb333", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/276b8b125d3f60cebab702542b60207429fbb333/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a52ef4613f85fba1ecfd8746388bf34a5499bf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a52ef4613f85fba1ecfd8746388bf34a5499bf9", "html_url": "https://github.com/rust-lang/rust/commit/3a52ef4613f85fba1ecfd8746388bf34a5499bf9"}], "stats": {"total": 237, "additions": 121, "deletions": 116}, "files": [{"sha": "2c3aa88a680833ddf75f94ad95b5a7f84892de6c", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -47,7 +47,7 @@ pub fn run(lib_path: &str,\n     match cmd.spawn() {\n         Ok(mut process) => {\n             for input in input.iter() {\n-                process.stdin.get_mut_ref().write(input.as_bytes()).unwrap();\n+                process.stdin.as_mut().unwrap().write(input.as_bytes()).unwrap();\n             }\n             let ProcessOutput { status, output, error } =\n                 process.wait_with_output().unwrap();\n@@ -79,7 +79,7 @@ pub fn run_background(lib_path: &str,\n     match cmd.spawn() {\n         Ok(mut process) => {\n             for input in input.iter() {\n-                process.stdin.get_mut_ref().write(input.as_bytes()).unwrap();\n+                process.stdin.as_mut().unwrap().write(input.as_bytes()).unwrap();\n             }\n \n             Some(process)"}, {"sha": "7a0245164ec098a20abcd2d0e134ae947ad17d81", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -1526,7 +1526,7 @@ fn compile_cc_with_clang_and_save_bitcode(config: &Config, _props: &TestProps,\n     let testcc = testfile.with_extension(\"cc\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prog: config.clang_path.get_ref().as_str().unwrap().to_string(),\n+        prog: config.clang_path.as_ref().unwrap().as_str().unwrap().to_string(),\n         args: vec!(\"-c\".to_string(),\n                    \"-emit-llvm\".to_string(),\n                    \"-o\".to_string(),\n@@ -1542,7 +1542,7 @@ fn extract_function_from_bitcode(config: &Config, _props: &TestProps,\n     let bitcodefile = output_base_name(config, testfile).with_extension(\"bc\");\n     let bitcodefile = append_suffix_to_stem(&bitcodefile, suffix);\n     let extracted_bc = append_suffix_to_stem(&bitcodefile, \"extract\");\n-    let prog = config.llvm_bin_path.get_ref().join(\"llvm-extract\");\n+    let prog = config.llvm_bin_path.as_ref().unwrap().join(\"llvm-extract\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prog: prog.as_str().unwrap().to_string(),\n@@ -1559,7 +1559,7 @@ fn disassemble_extract(config: &Config, _props: &TestProps,\n     let bitcodefile = append_suffix_to_stem(&bitcodefile, suffix);\n     let extracted_bc = append_suffix_to_stem(&bitcodefile, \"extract\");\n     let extracted_ll = extracted_bc.with_extension(\"ll\");\n-    let prog = config.llvm_bin_path.get_ref().join(\"llvm-dis\");\n+    let prog = config.llvm_bin_path.as_ref().unwrap().join(\"llvm-dis\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prog: prog.as_str().unwrap().to_string(),"}, {"sha": "73464047319886d53d2990bddc636b13d980881c", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -476,7 +476,7 @@ impl<T> TypedArena<T> {\n     /// Grows the arena.\n     #[inline(never)]\n     fn grow(&self) {\n-        let chunk = self.first.borrow_mut().take_unwrap();\n+        let chunk = self.first.borrow_mut().take().unwrap();\n         let new_capacity = chunk.capacity.checked_mul(&2).unwrap();\n         let chunk = TypedArenaChunk::<T>::new(Some(chunk), new_capacity);\n         self.ptr.set(chunk.start() as *const T);\n@@ -489,13 +489,13 @@ impl<T> TypedArena<T> {\n impl<T> Drop for TypedArena<T> {\n     fn drop(&mut self) {\n         // Determine how much was filled.\n-        let start = self.first.borrow().get_ref().start() as uint;\n+        let start = self.first.borrow().as_ref().unwrap().start() as uint;\n         let end = self.ptr.get() as uint;\n         let diff = (end - start) / mem::size_of::<T>();\n \n         // Pass that to the `destroy` method.\n         unsafe {\n-            self.first.borrow_mut().get_mut_ref().destroy(diff)\n+            self.first.borrow_mut().as_mut().unwrap().destroy(diff)\n         }\n     }\n }"}, {"sha": "22ac0a60c769bb96173873d2e78d0605bd1cfd70", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -630,7 +630,7 @@ impl<'a, A> MutItems<'a, A> {\n                     None => return self.list.push_front_node(ins_node),\n                     Some(prev) => prev,\n                 };\n-                let node_own = prev_node.next.take_unwrap();\n+                let node_own = prev_node.next.take().unwrap();\n                 ins_node.next = link_with_prev(node_own, Rawlink::some(&mut *ins_node));\n                 prev_node.next = link_with_prev(ins_node, Rawlink::some(prev_node));\n                 self.list.length += 1;"}, {"sha": "296383f39e85ea58b18d6a8c8fb3f1f348dacf4e", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -309,7 +309,7 @@ impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n         }\n         let raw_index = raw_index(self.lo, self.elts.len(), self.index);\n         self.index += 1;\n-        Some(self.elts[raw_index].get_ref())\n+        Some(self.elts[raw_index].as_ref().unwrap())\n     }\n \n     #[inline]\n@@ -327,7 +327,7 @@ impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n         }\n         self.rindex -= 1;\n         let raw_index = raw_index(self.lo, self.elts.len(), self.rindex);\n-        Some(self.elts[raw_index].get_ref())\n+        Some(self.elts[raw_index].as_ref().unwrap())\n     }\n }\n \n@@ -343,7 +343,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n             None\n         } else {\n             let raw_index = raw_index(self.lo, self.elts.len(), self.index + j);\n-            Some(self.elts[raw_index].get_ref())\n+            Some(self.elts[raw_index].as_ref().unwrap())\n         }\n     }\n }"}, {"sha": "9c049d975c5bfd90f25cae6108573f6a3be0e72d", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -1447,7 +1447,7 @@ impl<K: Ord, V> TreeNode<K, V> {\n // Remove left horizontal link by rotating right\n fn skew<K: Ord, V>(node: &mut Box<TreeNode<K, V>>) {\n     if node.left.as_ref().map_or(false, |x| x.level == node.level) {\n-        let mut save = node.left.take_unwrap();\n+        let mut save = node.left.take().unwrap();\n         swap(&mut node.left, &mut save.right); // save.right now None\n         swap(node, &mut save);\n         node.right = Some(save);\n@@ -1459,7 +1459,7 @@ fn skew<K: Ord, V>(node: &mut Box<TreeNode<K, V>>) {\n fn split<K: Ord, V>(node: &mut Box<TreeNode<K, V>>) {\n     if node.right.as_ref().map_or(false,\n       |x| x.right.as_ref().map_or(false, |y| y.level == node.level)) {\n-        let mut save = node.right.take_unwrap();\n+        let mut save = node.right.take().unwrap();\n         swap(&mut node.right, &mut save.left); // save.left now None\n         save.level += 1;\n         swap(node, &mut save);\n@@ -1563,7 +1563,7 @@ fn remove<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n           Equal => {\n             if save.left.is_some() {\n                 if save.right.is_some() {\n-                    let mut left = save.left.take_unwrap();\n+                    let mut left = save.left.take().unwrap();\n                     if left.right.is_some() {\n                         heir_swap(save, &mut left.right);\n                     } else {\n@@ -1573,13 +1573,13 @@ fn remove<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n                     save.left = Some(left);\n                     (remove(&mut save.left, key), true)\n                 } else {\n-                    let new = save.left.take_unwrap();\n+                    let new = save.left.take().unwrap();\n                     let box TreeNode{value, ..} = replace(save, new);\n-                    *save = save.left.take_unwrap();\n+                    *save = save.left.take().unwrap();\n                     (Some(value), true)\n                 }\n             } else if save.right.is_some() {\n-                let new = save.right.take_unwrap();\n+                let new = save.right.take().unwrap();\n                 let box TreeNode{value, ..} = replace(save, new);\n                 (Some(value), true)\n             } else {"}, {"sha": "c24db8376710dd9a680467ab3e1d1a811ac321c9", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -99,7 +99,7 @@\n //!             // Take a reference to the inside of cache cell\n //!             let mut cache = self.span_tree_cache.borrow_mut();\n //!             if cache.is_some() {\n-//!                 return cache.get_ref().clone();\n+//!                 return cache.as_ref().unwrap().clone();\n //!             }\n //!\n //!             let span_tree = self.calc_span_tree();"}, {"sha": "580d45ee8a6f955c0784676eeb77df8ad44f2e40", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -2191,7 +2191,12 @@ pub fn iterate<'a, T: Clone>(f: |T|: 'a -> T, seed: T) -> Iterate<'a, T> {\n         if *first {\n             *first = false;\n         } else {\n-            val.mutate(|x| (*f)(x));\n+            match val.take() {\n+                Some(x) => {\n+                    *val = Some((*f)(x))\n+                }\n+                None => {}\n+            }\n         }\n         val.clone()\n     })"}, {"sha": "537d78a67feb2230188246c1d81d9a0f47e95f46", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -341,7 +341,7 @@ impl<T> Option<T> {\n     #[deprecated = \"removed due to lack of use\"]\n     pub fn mutate(&mut self, f: |T| -> T) -> bool {\n         if self.is_some() {\n-            *self = Some(f(self.take_unwrap()));\n+            *self = Some(f(self.take().unwrap()));\n             true\n         } else { false }\n     }\n@@ -353,7 +353,7 @@ impl<T> Option<T> {\n     #[deprecated = \"removed due to lack of use\"]\n     pub fn mutate_or_set(&mut self, def: T, f: |T| -> T) -> bool {\n         if self.is_some() {\n-            *self = Some(f(self.take_unwrap()));\n+            *self = Some(f(self.take().unwrap()));\n             true\n         } else {\n             *self = Some(def);"}, {"sha": "2dad9fc3a22c42def94cc7973600ae2fcfecb0d2", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -73,7 +73,7 @@ fn test_option_dance() {\n     let mut y = Some(5i);\n     let mut y2 = 0;\n     for _x in x.iter() {\n-        y2 = y.take_unwrap();\n+        y2 = y.take().unwrap();\n     }\n     assert_eq!(y2, 5);\n     assert!(y.is_none());\n@@ -82,8 +82,8 @@ fn test_option_dance() {\n #[test] #[should_fail]\n fn test_option_too_much_dance() {\n     let mut y = Some(marker::NoCopy);\n-    let _y2 = y.take_unwrap();\n-    let _y3 = y.take_unwrap();\n+    let _y2 = y.take().unwrap();\n+    let _y3 = y.take().unwrap();\n }\n \n #[test]"}, {"sha": "90afee652646ce71f02bd163a1b0848da88fe0f5", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -106,7 +106,7 @@ pub fn glob_with(pattern: &str, options: MatchOptions) -> Paths {\n     let mut root = os::getcwd();\n     let pat_root = Path::new(pattern).root_path();\n     if pat_root.is_some() {\n-        if check_windows_verbatim(pat_root.get_ref()) {\n+        if check_windows_verbatim(pat_root.as_ref().unwrap()) {\n             // FIXME: How do we want to handle verbatim paths? I'm inclined to return nothing,\n             // since we can't very well find all UNC shares with a 1-letter server name.\n             return Paths {\n@@ -116,7 +116,7 @@ pub fn glob_with(pattern: &str, options: MatchOptions) -> Paths {\n                 todo: Vec::new(),\n             };\n         }\n-        root.push(pat_root.get_ref());\n+        root.push(pat_root.as_ref().unwrap());\n     }\n \n     let root_len = pat_root.map_or(0u, |p| p.as_vec().len());"}, {"sha": "cc77d151231e87484d329aa9245f049f7b0bf6c2", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -305,7 +305,7 @@ pub fn start(argc: int, argv: *const *const u8,\n     let mut main = Some(main);\n     let mut ret = None;\n     simple::task().run(|| {\n-        ret = Some(run(event_loop_factory, main.take_unwrap()));\n+        ret = Some(run(event_loop_factory, main.take().unwrap()));\n     }).destroy();\n     // unsafe is ok b/c we're sure that the runtime is gone\n     unsafe { rt::cleanup() }"}, {"sha": "084a66fdddf154c26f2daef852910273fe7fbbb8", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -203,7 +203,7 @@ impl Scheduler {\n         let mut sched_task = self.run(sched_task);\n \n         // Close the idle callback.\n-        let mut sched = sched_task.sched.take_unwrap();\n+        let mut sched = sched_task.sched.take().unwrap();\n         sched.idle_callback.take();\n         // Make one go through the loop to run the close callback.\n         let mut stask = sched.run(sched_task);\n@@ -702,7 +702,7 @@ impl Scheduler {\n             assert!(sched.sched_task.is_none());\n             sched.sched_task = Some(stask);\n         });\n-        (cur.sched.take_unwrap(), cur)\n+        (cur.sched.take().unwrap(), cur)\n     }\n \n     fn resume_task_immediately_cl(sched: Box<Scheduler>,\n@@ -738,7 +738,7 @@ impl Scheduler {\n                                             f: |&mut Scheduler, BlockedTask|) {\n         // Trickier - we need to get the scheduler task out of self\n         // and use it as the destination.\n-        let stask = self.sched_task.take_unwrap();\n+        let stask = self.sched_task.take().unwrap();\n         // Otherwise this is the same as below.\n         self.switch_running_tasks_and_then(cur, stask, f)\n     }\n@@ -788,7 +788,7 @@ impl Scheduler {\n                 sched.enqueue_task(last_task);\n             }\n         });\n-        (cur.sched.take_unwrap(), cur)\n+        (cur.sched.take().unwrap(), cur)\n     }\n \n     // * Task Context Helpers\n@@ -800,9 +800,9 @@ impl Scheduler {\n                                   -> ! {\n         // Similar to deschedule running task and then, but cannot go through\n         // the task-blocking path. The task is already dying.\n-        let stask = self.sched_task.take_unwrap();\n+        let stask = self.sched_task.take().unwrap();\n         let _cur = self.change_task_context(cur, stask, |sched, mut dead_task| {\n-            let coroutine = dead_task.coroutine.take_unwrap();\n+            let coroutine = dead_task.coroutine.take().unwrap();\n             coroutine.recycle(&mut sched.stack_pool);\n             sched.task_state.decrement();\n         });\n@@ -818,7 +818,7 @@ impl Scheduler {\n     }\n \n     pub fn run_task_later(mut cur: Box<GreenTask>, next: Box<GreenTask>) {\n-        let mut sched = cur.sched.take_unwrap();\n+        let mut sched = cur.sched.take().unwrap();\n         sched.enqueue_task(next);\n         cur.put_with_sched(sched);\n     }\n@@ -838,7 +838,7 @@ impl Scheduler {\n             self.yield_check_count = reset_yield_check(&mut self.rng);\n             // Tell the scheduler to start stealing on the next iteration\n             self.steal_for_yield = true;\n-            let stask = self.sched_task.take_unwrap();\n+            let stask = self.sched_task.take().unwrap();\n             let cur = self.change_task_context(cur, stask, |sched, task| {\n                 sched.enqueue_task(task);\n             });\n@@ -878,7 +878,7 @@ impl Scheduler {\n     pub fn sched_id(&self) -> uint { self as *const Scheduler as uint }\n \n     pub fn run_cleanup_job(&mut self) {\n-        let cleanup_job = self.cleanup_job.take_unwrap();\n+        let cleanup_job = self.cleanup_job.take().unwrap();\n         cleanup_job.run(self)\n     }\n \n@@ -1235,7 +1235,7 @@ mod test {\n \n             fn run(next: Box<GreenTask>) {\n                 let mut task = GreenTask::convert(Local::take());\n-                let sched = task.sched.take_unwrap();\n+                let sched = task.sched.take().unwrap();\n                 sched.run_task(task, next)\n             }\n "}, {"sha": "28e1e94e807b34d3db377830d4c252b9aae311b6", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -110,7 +110,7 @@ extern fn bootstrap_green_task(task: uint, code: *mut (), env: *mut ()) -> ! {\n     // requested. This is the \"try/catch\" block for this green task and\n     // is the wrapper for *all* code run in the task.\n     let mut start = Some(start);\n-    let task = task.swap().run(|| start.take_unwrap()()).destroy();\n+    let task = task.swap().run(|| start.take().unwrap()()).destroy();\n \n     // Once the function has exited, it's time to run the termination\n     // routine. This means we need to context switch one more time but\n@@ -212,7 +212,7 @@ impl GreenTask {\n \n     pub fn take_unwrap_home(&mut self) -> Home {\n         match self.task_type {\n-            TypeGreen(ref mut home) => home.take_unwrap(),\n+            TypeGreen(ref mut home) => home.take().unwrap(),\n             TypeSched => rtabort!(\"type error: used SchedTask as GreenTask\"),\n         }\n     }\n@@ -277,7 +277,7 @@ impl GreenTask {\n     }\n \n     pub fn swap(mut self: Box<GreenTask>) -> Box<Task> {\n-        let mut task = self.task.take_unwrap();\n+        let mut task = self.task.take().unwrap();\n         task.put_runtime(self);\n         return task;\n     }\n@@ -288,7 +288,7 @@ impl GreenTask {\n     }\n \n     fn terminate(mut self: Box<GreenTask>) -> ! {\n-        let sched = self.sched.take_unwrap();\n+        let sched = self.sched.take().unwrap();\n         sched.terminate_current_task(self)\n     }\n \n@@ -324,13 +324,13 @@ impl GreenTask {\n impl Runtime for GreenTask {\n     fn yield_now(mut self: Box<GreenTask>, cur_task: Box<Task>) {\n         self.put_task(cur_task);\n-        let sched = self.sched.take_unwrap();\n+        let sched = self.sched.take().unwrap();\n         sched.yield_now(self);\n     }\n \n     fn maybe_yield(mut self: Box<GreenTask>, cur_task: Box<Task>) {\n         self.put_task(cur_task);\n-        let sched = self.sched.take_unwrap();\n+        let sched = self.sched.take().unwrap();\n         sched.maybe_yield(self);\n     }\n \n@@ -339,7 +339,7 @@ impl Runtime for GreenTask {\n                   cur_task: Box<Task>,\n                   f: |BlockedTask| -> Result<(), BlockedTask>) {\n         self.put_task(cur_task);\n-        let mut sched = self.sched.take_unwrap();\n+        let mut sched = self.sched.take().unwrap();\n \n         // In order for this task to be reawoken in all possible contexts, we\n         // may need a handle back in to the current scheduler. When we're woken\n@@ -418,7 +418,7 @@ impl Runtime for GreenTask {\n         match running_task.maybe_take_runtime::<GreenTask>() {\n             Some(mut running_green_task) => {\n                 running_green_task.put_task(running_task);\n-                let sched = running_green_task.sched.take_unwrap();\n+                let sched = running_green_task.sched.take().unwrap();\n \n                 if sched.pool_id == self.pool_id {\n                     sched.run_task(running_green_task, self);"}, {"sha": "06b78a54e53ee8906110ae29d8a41f3dde70831d", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -119,7 +119,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n         let mut timer = match active.shift() {\n             Some(timer) => timer, None => return\n         };\n-        let mut cb = timer.cb.take_unwrap();\n+        let mut cb = timer.cb.take().unwrap();\n         cb.call();\n         if timer.repeat {\n             timer.cb = Some(cb);"}, {"sha": "06f89d38ca0a183da8e7b9a8795a53ade841ec39", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -139,7 +139,7 @@ pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int {\n         unsafe {\n             rt::stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n         }\n-        exit_code = Some(run(main.take_unwrap()));\n+        exit_code = Some(run(main.take().unwrap()));\n     }).destroy());\n     unsafe { rt::cleanup(); }\n     // If the exit code wasn't set, then the task block must have failed."}, {"sha": "3109fd8458187498dc0edd31196bfe5f964f00fc", "filename": "src/libnative/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -92,7 +92,7 @@ pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n         let mut f = Some(f);\n         let mut task = task;\n         task.put_runtime(ops);\n-        drop(task.run(|| { f.take_unwrap()() }).destroy());\n+        drop(task.run(|| { f.take().unwrap()() }).destroy());\n         drop(token);\n     })\n }"}, {"sha": "e07132b1f9cca3d15c9d567383f8f9bf70d8ee98", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -223,7 +223,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     let mut addl_plugins = Some(addl_plugins);\n     let Plugins { macros, registrars }\n         = time(time_passes, \"plugin loading\", (), |_|\n-               plugin::load::load_plugins(sess, &krate, addl_plugins.take_unwrap()));\n+               plugin::load::load_plugins(sess, &krate, addl_plugins.take().unwrap()));\n \n     let mut registry = Registry::new(&krate);\n "}, {"sha": "8952e565008e8fd5d9b60780db664b2bb19dc665", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -207,7 +207,7 @@ pub struct Context<'a> {\n macro_rules! run_lints ( ($cx:expr, $f:ident, $($args:expr),*) => ({\n     // Move the vector of passes out of `$cx` so that we can\n     // iterate over it mutably while passing `$cx` to the methods.\n-    let mut passes = $cx.lints.passes.take_unwrap();\n+    let mut passes = $cx.lints.passes.take().unwrap();\n     for obj in passes.mut_iter() {\n         obj.$f($cx, $($args),*);\n     }"}, {"sha": "f05602bbb58c830fabc42bc4cf9b418a06781887", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -166,7 +166,7 @@ impl<'a> Drop for StatRecorder<'a> {\n             let end = time::precise_time_ns();\n             let elapsed = ((end - self.start) / 1_000_000) as uint;\n             let iend = self.ccx.stats.n_llvm_insns.get();\n-            self.ccx.stats.fn_stats.borrow_mut().push((self.name.take_unwrap(),\n+            self.ccx.stats.fn_stats.borrow_mut().push((self.name.take().unwrap(),\n                                                        elapsed,\n                                                        iend - self.istart));\n             self.ccx.stats.n_fns.set(self.ccx.stats.n_fns.get() + 1);"}, {"sha": "f2a7f1dc4f8ee287d9814bb153384857b05ca6c6", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -147,7 +147,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             decl_internal_rust_fn(ccx, mono_ty, s.as_slice())\n         };\n \n-        ccx.monomorphized.borrow_mut().insert(hash_id.take_unwrap(), lldecl);\n+        ccx.monomorphized.borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n         lldecl\n     };\n "}, {"sha": "76ab164bc2d3a9b12456d76203efdfaac39f9a88", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -108,7 +108,7 @@ fn try_inline_def(cx: &core::DocContext,\n         _ => return None,\n     };\n     let fqn = csearch::get_item_path(tcx, did);\n-    cx.inlined.borrow_mut().get_mut_ref().insert(did);\n+    cx.inlined.borrow_mut().as_mut().unwrap().insert(did);\n     ret.push(clean::Item {\n         source: clean::Span::empty(),\n         name: Some(fqn.last().unwrap().to_string()),\n@@ -142,7 +142,7 @@ pub fn record_extern_fqn(cx: &core::DocContext,\n         core::Typed(ref tcx) => {\n             let fqn = csearch::get_item_path(tcx, did);\n             let fqn = fqn.move_iter().map(|i| i.to_string()).collect();\n-            cx.external_paths.borrow_mut().get_mut_ref().insert(did, (fqn, kind));\n+            cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n         }\n         core::NotTyped(..) => {}\n     }\n@@ -278,7 +278,7 @@ fn build_impls(cx: &core::DocContext,\n fn build_impl(cx: &core::DocContext,\n               tcx: &ty::ctxt,\n               did: ast::DefId) -> Option<clean::Item> {\n-    if !cx.inlined.borrow_mut().get_mut_ref().insert(did) {\n+    if !cx.inlined.borrow_mut().as_mut().unwrap().insert(did) {\n         return None\n     }\n "}, {"sha": "0516f533ffe4c485bcce6fc58322ced1cb82323d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -468,7 +468,7 @@ impl Clean<TyParam> for ast::TyParam {\n \n impl Clean<TyParam> for ty::TypeParameterDef {\n     fn clean(&self) -> TyParam {\n-        get_cx().external_typarams.borrow_mut().get_mut_ref()\n+        get_cx().external_typarams.borrow_mut().as_mut().unwrap()\n                 .insert(self.def_id, self.ident.clean());\n         TyParam {\n             name: self.ident.clean(),\n@@ -541,8 +541,8 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n         };\n         let fqn = csearch::get_item_path(tcx, did);\n         let fqn = fqn.move_iter().map(|i| i.to_string()).collect();\n-        cx.external_paths.borrow_mut().get_mut_ref().insert(did,\n-                                                            (fqn, TypeTrait));\n+        cx.external_paths.borrow_mut().as_mut().unwrap().insert(did,\n+                                                                (fqn, TypeTrait));\n         TraitBound(ResolvedPath {\n             path: path,\n             typarams: None,\n@@ -563,7 +563,7 @@ impl Clean<TyParamBound> for ty::TraitRef {\n                      .collect::<Vec<String>>();\n         let path = external_path(fqn.last().unwrap().as_slice(),\n                                  &self.substs);\n-        cx.external_paths.borrow_mut().get_mut_ref().insert(self.def_id,\n+        cx.external_paths.borrow_mut().as_mut().unwrap().insert(self.def_id,\n                                                             (fqn, TypeTrait));\n         TraitBound(ResolvedPath {\n             path: path,\n@@ -1294,7 +1294,7 @@ impl Clean<Type> for ty::t {\n                 };\n                 let path = external_path(fqn.last().unwrap().to_string().as_slice(),\n                                          substs);\n-                get_cx().external_paths.borrow_mut().get_mut_ref()\n+                get_cx().external_paths.borrow_mut().as_mut().unwrap()\n                                        .insert(did, (fqn, kind));\n                 ResolvedPath {\n                     path: path,\n@@ -2086,7 +2086,7 @@ fn register_def(cx: &core::DocContext, def: def::Def) -> ast::DefId {\n     match kind {\n         TypeTrait => {\n             let t = inline::build_external_trait(tcx, did);\n-            cx.external_traits.borrow_mut().get_mut_ref().insert(did, t);\n+            cx.external_traits.borrow_mut().as_mut().unwrap().insert(did, t);\n         }\n         _ => {}\n     }\n@@ -2153,7 +2153,7 @@ fn lang_struct(did: Option<ast::DefId>, t: ty::t, name: &str,\n     let fqn: Vec<String> = fqn.move_iter().map(|i| {\n         i.to_string()\n     }).collect();\n-    get_cx().external_paths.borrow_mut().get_mut_ref()\n+    get_cx().external_paths.borrow_mut().as_mut().unwrap()\n                            .insert(did, (fqn, TypeStruct));\n     ResolvedPath {\n         typarams: None,"}, {"sha": "c2caa474f9fb15b6910c7445b31528d56a688016", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -297,7 +297,7 @@ pub fn run(mut krate: clean::Crate, external_html: &ExternalHtml, dst: Path) ->\n     let public_items = public_items.unwrap_or(NodeSet::new());\n     let paths: HashMap<ast::DefId, (Vec<String>, ItemType)> =\n       analysis.as_ref().map(|a| {\n-        let paths = a.external_paths.borrow_mut().take_unwrap();\n+        let paths = a.external_paths.borrow_mut().take().unwrap();\n         paths.move_iter().map(|(k, (v, t))| {\n             (k, (v, match t {\n                 clean::TypeStruct => item_type::Struct,\n@@ -325,13 +325,13 @@ pub fn run(mut krate: clean::Crate, external_html: &ExternalHtml, dst: Path) ->\n         public_items: public_items,\n         orphan_methods: Vec::new(),\n         traits: analysis.as_ref().map(|a| {\n-            a.external_traits.borrow_mut().take_unwrap()\n+            a.external_traits.borrow_mut().take().unwrap()\n         }).unwrap_or(HashMap::new()),\n         typarams: analysis.as_ref().map(|a| {\n-            a.external_typarams.borrow_mut().take_unwrap()\n+            a.external_typarams.borrow_mut().take().unwrap()\n         }).unwrap_or(HashMap::new()),\n         inlined: analysis.as_ref().map(|a| {\n-            a.inlined.borrow_mut().take_unwrap()\n+            a.inlined.borrow_mut().take().unwrap()\n         }).unwrap_or(HashSet::new()),\n     };\n     cache.stack.push(krate.name.clone());\n@@ -805,7 +805,7 @@ impl DocFolder for Cache {\n                         v.push(Implementor {\n                             def_id: item.def_id,\n                             generics: i.generics.clone(),\n-                            trait_: i.trait_.get_ref().clone(),\n+                            trait_: i.trait_.as_ref().unwrap().clone(),\n                             for_: i.for_.clone(),\n                             stability: item.stability.clone(),\n                         });\n@@ -878,7 +878,7 @@ impl DocFolder for Cache {\n \n         // Keep track of the fully qualified path for this item.\n         let pushed = if item.name.is_some() {\n-            let n = item.name.get_ref();\n+            let n = item.name.as_ref().unwrap();\n             if n.len() > 0 {\n                 self.stack.push(n.to_string());\n                 true\n@@ -1125,7 +1125,7 @@ impl Context {\n                 if title.len() > 0 {\n                     title.push_str(\"::\");\n                 }\n-                title.push_str(it.name.get_ref().as_slice());\n+                title.push_str(it.name.as_ref().unwrap().as_slice());\n             }\n             title.push_str(\" - Rust\");\n             let tyname = shortty(it).to_static_str();\n@@ -1191,10 +1191,10 @@ impl Context {\n             // modules are special because they add a namespace. We also need to\n             // recurse into the items of the module as well.\n             clean::ModuleItem(..) => {\n-                let name = item.name.get_ref().to_string();\n+                let name = item.name.as_ref().unwrap().to_string();\n                 let mut item = Some(item);\n                 self.recurse(name, |this| {\n-                    let item = item.take_unwrap();\n+                    let item = item.take().unwrap();\n                     let dst = this.dst.join(\"index.html\");\n                     let dst = try!(File::create(&dst));\n                     try!(render(dst, this, &item, false));\n@@ -1398,7 +1398,7 @@ fn item_path(item: &clean::Item) -> String {\n fn full_path(cx: &Context, item: &clean::Item) -> String {\n     let mut s = cx.current.connect(\"::\");\n     s.push_str(\"::\");\n-    s.push_str(item.name.get_ref().as_slice());\n+    s.push_str(item.name.as_ref().unwrap().as_slice());\n     return s\n }\n \n@@ -1809,7 +1809,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n         try!(write!(w, \" {{\\n\"));\n         for v in e.variants.iter() {\n             try!(write!(w, \"    \"));\n-            let name = v.name.get_ref().as_slice();\n+            let name = v.name.as_ref().unwrap().as_slice();\n             match v.inner {\n                 clean::VariantItem(ref var) => {\n                     match var.kind {\n@@ -2098,7 +2098,7 @@ impl<'a> fmt::Show for Sidebar<'a> {\n             try!(write!(w, \"<div class='block {}'><h2>{}</h2>\", short, longty));\n             for item in items.iter() {\n                 let curty = shortty(cur).to_static_str();\n-                let class = if cur.name.get_ref() == item &&\n+                let class = if cur.name.as_ref().unwrap() == item &&\n                                short == curty { \"current\" } else { \"\" };\n                 try!(write!(w, \"<a class='{ty} {class}' href='{href}{path}'>\\\n                                 {name}</a>\","}, {"sha": "2f140aa8a6802c2841d08419a4b56821f621f48a", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -385,7 +385,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n \n     // Process all of the crate attributes, extracting plugin metadata along\n     // with the passes which we are supposed to run.\n-    match krate.module.get_ref().doc_list() {\n+    match krate.module.as_ref().unwrap().doc_list() {\n         Some(nested) => {\n             for inner in nested.iter() {\n                 match *inner {"}, {"sha": "30a6b1f56e03ab65ecf01e36d78b2d3ac707acd3", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -384,7 +384,7 @@ impl Task {\n         //      function, and I would be saddened if more usage of the function\n         //      crops up.\n         unsafe {\n-            let imp = self.imp.take_unwrap();\n+            let imp = self.imp.take().unwrap();\n             let vtable = mem::transmute::<_, &raw::TraitObject>(&imp).vtable;\n             match imp.wrap().downcast::<T>() {\n                 Ok(t) => Some(t),\n@@ -407,7 +407,7 @@ impl Task {\n     pub fn spawn_sibling(mut self: Box<Task>,\n                          opts: TaskOpts,\n                          f: proc(): Send) {\n-        let ops = self.imp.take_unwrap();\n+        let ops = self.imp.take().unwrap();\n         ops.spawn_sibling(self, opts, f)\n     }\n \n@@ -417,51 +417,51 @@ impl Task {\n     pub fn deschedule(mut self: Box<Task>,\n                       amt: uint,\n                       f: |BlockedTask| -> ::core::result::Result<(), BlockedTask>) {\n-        let ops = self.imp.take_unwrap();\n+        let ops = self.imp.take().unwrap();\n         ops.deschedule(amt, self, f)\n     }\n \n     /// Wakes up a previously blocked task, optionally specifying whether the\n     /// current task can accept a change in scheduling. This function can only\n     /// be called on tasks that were previously blocked in `deschedule`.\n     pub fn reawaken(mut self: Box<Task>) {\n-        let ops = self.imp.take_unwrap();\n+        let ops = self.imp.take().unwrap();\n         ops.reawaken(self);\n     }\n \n     /// Yields control of this task to another task. This function will\n     /// eventually return, but possibly not immediately. This is used as an\n     /// opportunity to allow other tasks a chance to run.\n     pub fn yield_now(mut self: Box<Task>) {\n-        let ops = self.imp.take_unwrap();\n+        let ops = self.imp.take().unwrap();\n         ops.yield_now(self);\n     }\n \n     /// Similar to `yield_now`, except that this function may immediately return\n     /// without yielding (depending on what the runtime decides to do).\n     pub fn maybe_yield(mut self: Box<Task>) {\n-        let ops = self.imp.take_unwrap();\n+        let ops = self.imp.take().unwrap();\n         ops.maybe_yield(self);\n     }\n \n     /// Acquires a handle to the I/O factory that this task contains, normally\n     /// stored in the task's runtime. This factory may not always be available,\n     /// which is why the return type is `Option`\n     pub fn local_io<'a>(&'a mut self) -> Option<LocalIo<'a>> {\n-        self.imp.get_mut_ref().local_io()\n+        self.imp.as_mut().unwrap().local_io()\n     }\n \n     /// Returns the stack bounds for this task in (lo, hi) format. The stack\n     /// bounds may not be known for all tasks, so the return value may be\n     /// `None`.\n     pub fn stack_bounds(&self) -> (uint, uint) {\n-        self.imp.get_ref().stack_bounds()\n+        self.imp.as_ref().unwrap().stack_bounds()\n     }\n \n     /// Returns whether it is legal for this task to block the OS thread that it\n     /// is running on.\n     pub fn can_block(&self) -> bool {\n-        self.imp.get_ref().can_block()\n+        self.imp.as_ref().unwrap().can_block()\n     }\n \n     /// Consume this task, flagging it as a candidate for destruction."}, {"sha": "1f0b0c7c207bfbb540ee66d7bf256f902531304d", "filename": "src/librustrt/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -128,7 +128,7 @@ impl<T: Send> Thread<T> {\n         unsafe { imp::join(self.native) };\n         self.joined = true;\n         assert!(self.packet.is_some());\n-        self.packet.take_unwrap()\n+        self.packet.take().unwrap()\n     }\n }\n "}, {"sha": "8b41219db62f154d6b2837b6524aaf9742f1a359", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -86,7 +86,7 @@ impl GetAddrInfoRequest {\n                 });\n \n                 match cx.status {\n-                    0 => Ok(accum_addrinfo(cx.addrinfo.get_ref())),\n+                    0 => Ok(accum_addrinfo(cx.addrinfo.as_ref().unwrap())),\n                     n => Err(UvError(n))\n                 }\n             }"}, {"sha": "8bed4cfb8114b590c800b9ba630928ed4f2694d8", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -136,7 +136,7 @@ mod test_remote {\n                 // once\n                 let MyCallback(ref mut s) = *self;\n                 if s.is_some() {\n-                    s.take_unwrap().send(1);\n+                    s.take().unwrap().send(1);\n                 }\n             }\n         }"}, {"sha": "561a4dffe82f2f6aef886041d404c698fd4ab14f", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -259,7 +259,7 @@ fn wait_until_woken_after(slot: *mut Option<BlockedTask>,\n \n fn wakeup(slot: &mut Option<BlockedTask>) {\n     assert!(slot.is_some());\n-    let _ = slot.take_unwrap().wake().map(|t| t.reawaken());\n+    let _ = slot.take().unwrap().wake().map(|t| t.reawaken());\n }\n \n pub struct Request {"}, {"sha": "09d008a9fa9046e666877fd6aa94c8404c93946d", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -596,7 +596,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                 wait_until_woken_after(&mut cx.task, &loop_, || {\n                     unsafe { uvll::set_data_for_uv_handle(handle, &mut cx) }\n                 });\n-                match cx.result.take_unwrap() {\n+                match cx.result.take().unwrap() {\n                     (n, _) if n < 0 =>\n                         Err(uv_error_to_io_error(UvError(n as c_int))),\n                     (n, addr) => Ok((n as uint, addr.unwrap()))\n@@ -657,7 +657,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         // here.\n         let data = if guard.can_timeout {Some(Vec::from_slice(buf))} else {None};\n         let uv_buf = if guard.can_timeout {\n-            slice_to_uv_buf(data.get_ref().as_slice())\n+            slice_to_uv_buf(data.as_ref().unwrap().as_slice())\n         } else {\n             slice_to_uv_buf(buf)\n         };"}, {"sha": "4a12f959ad9a530c8616f52c3e83636ccfa0f205", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -297,7 +297,7 @@ impl rtio::RtioProcess for Process {\n             self.timer = Some(timer);\n         }\n \n-        let timer = self.timer.get_mut_ref();\n+        let timer = self.timer.as_mut().unwrap();\n         timer.stop();\n         timer.start(timer_cb, ms, 0);\n         self.timeout_state = TimeoutPending;"}, {"sha": "12831002b65ec3c1730334a4d808d1707623531d", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -161,7 +161,7 @@ impl StreamWatcher {\n         // bytes.\n         let data = if may_timeout {Some(Vec::from_slice(buf))} else {None};\n         let uv_buf = if may_timeout {\n-            slice_to_uv_buf(data.get_ref().as_slice())\n+            slice_to_uv_buf(data.as_ref().unwrap().as_slice())\n         } else {\n             slice_to_uv_buf(buf)\n         };"}, {"sha": "0fc5772c188080fc28585721aaa357d9ae77144b", "filename": "src/librustuv/timeout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimeout.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -140,7 +140,7 @@ impl<T: Send> AccessTimeout<T> {\n             self.timer = Some(timer);\n         }\n \n-        let timer = self.timer.get_mut_ref();\n+        let timer = self.timer.as_mut().unwrap();\n         unsafe {\n             let cx = uvll::get_data_for_uv_handle(timer.handle);\n             let cx = cx as *mut TimerContext;"}, {"sha": "412506604c674cc50bf90e8e1c6939ce47b91e87", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -132,9 +132,9 @@ extern fn timer_cb(handle: *mut uvll::uv_timer_t) {\n     let _f = ForbidSwitch::new(\"timer callback can't switch\");\n     let timer: &mut TimerWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n \n-    match timer.action.take_unwrap() {\n+    match timer.action.take().unwrap() {\n         WakeTask => {\n-            let task = timer.blocker.take_unwrap();\n+            let task = timer.blocker.take().unwrap();\n             let _ = task.wake().map(|t| t.reawaken());\n         }\n         CallOnce(mut cb) => { cb.call() }"}, {"sha": "30b172c5b6bf010cf229de1b73e463e3b6190eda", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -66,7 +66,7 @@ impl Drop for UvEventLoop {\n         // Lastly, after we've closed the pool of handles we pump the event loop\n         // one last time to run any closing callbacks to make sure the loop\n         // shuts down cleanly.\n-        let handle = self.uvio.handle_pool.get_ref().handle();\n+        let handle = self.uvio.handle_pool.as_ref().unwrap().handle();\n         drop(self.uvio.handle_pool.take());\n         self.run();\n \n@@ -132,7 +132,7 @@ impl UvIoFactory {\n         // It's understood by the homing code that the \"local id\" is just the\n         // pointer of the local I/O factory cast to a uint.\n         let id: uint = unsafe { mem::transmute_copy(&self) };\n-        HomeHandle::new(id, &mut **self.handle_pool.get_mut_ref())\n+        HomeHandle::new(id, &mut **self.handle_pool.as_mut().unwrap())\n     }\n }\n "}, {"sha": "0c63f1a901f5a248cfef32e275e908c1b94c24b6", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -182,7 +182,7 @@ impl<W: Writer> BufferedWriter<W> {\n     pub fn unwrap(mut self) -> W {\n         // FIXME(#12628): is failing the right thing to do if flushing fails?\n         self.flush_buf().unwrap();\n-        self.inner.take_unwrap()\n+        self.inner.take().unwrap()\n     }\n }\n "}, {"sha": "c1f4161fe181fc7d1386c47068ee019c0257f644", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -54,7 +54,7 @@ use collections::HashMap;\n ///     Err(e) => fail!(\"failed to execute child: {}\", e),\n /// };\n ///\n-/// let contents = child.stdout.get_mut_ref().read_to_end();\n+/// let contents = child.stdout.as_mut().unwrap().read_to_end();\n /// assert!(child.wait().unwrap().success());\n /// ```\n pub struct Process {\n@@ -95,7 +95,7 @@ pub type EnvMap = HashMap<CString, CString>;\n ///   Err(e) => fail!(\"failed to execute process: {}\", e),\n /// };\n ///\n-/// let output = process.stdout.get_mut_ref().read_to_end();\n+/// let output = process.stdout.as_mut().unwrap().read_to_end();\n /// ```\n #[deriving(Clone)]\n pub struct Command {"}, {"sha": "8def5d5c99752d76728b0a12cf7af7ed106eaf11", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -70,7 +70,7 @@ impl TempDir {\n     /// temporary directory is prevented.\n     pub fn unwrap(self) -> Path {\n         let mut tmpdir = self;\n-        tmpdir.path.take_unwrap()\n+        tmpdir.path.take().unwrap()\n     }\n \n     /// Access the wrapped `std::path::Path` to the temporary directory."}, {"sha": "5b3cf33ebf0934d9a1128b4599cf4087b110b218", "filename": "src/libsync/comm/oneshot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibsync%2Fcomm%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibsync%2Fcomm%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Foneshot.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -107,7 +107,7 @@ impl<T: Send> Packet<T> {\n             // Couldn't send the data, the port hung up first. Return the data\n             // back up the stack.\n             DISCONNECTED => {\n-                Err(self.data.take_unwrap())\n+                Err(self.data.take().unwrap())\n             }\n \n             // Not possible, these are one-use channels\n@@ -244,7 +244,7 @@ impl<T: Send> Packet<T> {\n             // There's data on the channel, so make sure we destroy it promptly.\n             // This is why not using an arc is a little difficult (need the box\n             // to stay valid while we take the data).\n-            DATA => { self.data.take_unwrap(); }\n+            DATA => { self.data.take().unwrap(); }\n \n             // We're the only ones that can block on this port\n             _ => unreachable!()"}, {"sha": "528a15cf6d7658a10bb26332d814e10794eee340", "filename": "src/libsync/comm/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibsync%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibsync%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fsync.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -347,7 +347,7 @@ impl<T: Send> Packet<T> {\n         let waiter = match mem::replace(&mut state.blocker, NoneBlocked) {\n             NoneBlocked => None,\n             BlockedSender(task) => {\n-                *state.canceled.take_unwrap() = true;\n+                *state.canceled.take().unwrap() = true;\n                 Some(task)\n             }\n             BlockedReceiver(..) => unreachable!(),\n@@ -434,7 +434,7 @@ impl<T> Buffer<T> {\n         let start = self.start;\n         self.size -= 1;\n         self.start = (self.start + 1) % self.buf.len();\n-        self.buf.get_mut(start).take_unwrap()\n+        self.buf.get_mut(start).take().unwrap()\n     }\n \n     fn size(&self) -> uint { self.size }\n@@ -481,7 +481,7 @@ impl Queue {\n         }\n         unsafe {\n             (*node).next = 0 as *mut Node;\n-            Some((*node).task.take_unwrap())\n+            Some((*node).task.take().unwrap())\n         }\n     }\n }"}, {"sha": "ad2539fc260082c9028ece661853ad1bf1a8034c", "filename": "src/libsync/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpsc_queue.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -122,7 +122,7 @@ impl<T: Send> Queue<T> {\n                 *self.tail.get() = next;\n                 assert!((*tail).value.is_none());\n                 assert!((*next).value.is_some());\n-                let ret = (*next).value.take_unwrap();\n+                let ret = (*next).value.take().unwrap();\n                 let _: Box<Node<T>> = mem::transmute(tail);\n                 return Data(ret);\n             }"}, {"sha": "ba6d0f03d83970c1ff6c3672e1b118183d75f72b", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -259,7 +259,7 @@ impl<'a> Condvar<'a> {\n             // signaller already sent -- I mean 'unconditionally' in contrast\n             // with acquire().)\n             (|| {\n-                let _ = wait_end.take_unwrap().recv();\n+                let _ = wait_end.take().unwrap().recv();\n             }).finally(|| {\n                 // Reacquire the condvar.\n                 match self.order {\n@@ -318,7 +318,7 @@ impl<'a> Condvar<'a> {\n                               condvar_id,\n                               \"cond.signal_on()\",\n                               || {\n-                queue.take_unwrap().broadcast()\n+                queue.take().unwrap().broadcast()\n             })\n         }\n     }"}, {"sha": "88f9c2b4ce39db28e04856b7c65aec1bcf962570", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -245,7 +245,7 @@ impl<'a> Iterator<&'a str> for Graphemes<'a> {\n             // looking up each character twice.\n             cat = match self.cat {\n                 None => gr::grapheme_category(ch),\n-                _ => self.cat.take_unwrap()\n+                _ => self.cat.take().unwrap()\n             };\n \n             if match cat {\n@@ -345,7 +345,7 @@ impl<'a> DoubleEndedIterator<&'a str> for Graphemes<'a> {\n             // cached category, if any\n             cat = match self.catb {\n                 None => gr::grapheme_category(ch),\n-                _ => self.catb.take_unwrap()\n+                _ => self.catb.take().unwrap()\n             };\n \n             // a matching state machine that runs *backwards* across an input string"}, {"sha": "ebd5aa4b37bec1790284b61ba2adee2f6ef42551", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -52,8 +52,8 @@ fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n     // Send/Receive lots of messages.\n     for j in range(0u, count) {\n         //println!(\"task %?, iter %?\", i, j);\n-        let num_chan2 = num_chan.take_unwrap();\n-        let num_port2 = num_port.take_unwrap();\n+        let num_chan2 = num_chan.take().unwrap();\n+        let num_port2 = num_port.take().unwrap();\n         send(&num_chan2, i * j);\n         num_chan = Some(num_chan2);\n         let _n = recv(&num_port2);"}, {"sha": "764d80984c3040189c86de52ca7a4501c3ebbb1b", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/276b8b125d3f60cebab702542b60207429fbb333/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276b8b125d3f60cebab702542b60207429fbb333/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=276b8b125d3f60cebab702542b60207429fbb333", "patch": "@@ -52,8 +52,8 @@ fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n     // Send/Receive lots of messages.\n     for j in range(0u, count) {\n         //println!(\"task %?, iter %?\", i, j);\n-        let num_chan2 = num_chan.take_unwrap();\n-        let num_port2 = num_port.take_unwrap();\n+        let num_chan2 = num_chan.take().unwrap();\n+        let num_port2 = num_port.take().unwrap();\n         send(&num_chan2, i * j);\n         num_chan = Some(num_chan2);\n         let _n = recv(&num_port2);"}]}