{"sha": "2c3b05d90d4dee879a0d9f33e721c930b087d7d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjM2IwNWQ5MGQ0ZGVlODc5YTBkOWYzM2U3MjFjOTMwYjA4N2Q3ZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-18T05:07:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-18T05:07:36Z"}, "message": "Auto merge of #62669 - estebank:suggest-assoc-type, r=cramertj\n\nSuggest assoc type on type not found in trait method definition\n\nGiven\n\n```\ntrait A {\n    type Bla;\n    fn to_bla(&self) -> Bla;\n}\n```\nsuggest using `Self::Bla`:\n\n```\nerror[E0412]: cannot find type `Bla` in this scope\n  --> file.rs:3:25\n   |\nLL |     fn to_bla(&self) -> Bla;\n   |                         ^^^ help: try: `Self::Bla`\n```\n\nFix #62650.", "tree": {"sha": "8117600bdf54f8e50b5226db76a490e75f39f77c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8117600bdf54f8e50b5226db76a490e75f39f77c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c3b05d90d4dee879a0d9f33e721c930b087d7d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c3b05d90d4dee879a0d9f33e721c930b087d7d1", "html_url": "https://github.com/rust-lang/rust/commit/2c3b05d90d4dee879a0d9f33e721c930b087d7d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c3b05d90d4dee879a0d9f33e721c930b087d7d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efb74579150a6ea0ad99a8568aa02a1aa23f6dd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/efb74579150a6ea0ad99a8568aa02a1aa23f6dd5", "html_url": "https://github.com/rust-lang/rust/commit/efb74579150a6ea0ad99a8568aa02a1aa23f6dd5"}, {"sha": "6b9580b651fa67ca7cf536ceab995d185202a114", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b9580b651fa67ca7cf536ceab995d185202a114", "html_url": "https://github.com/rust-lang/rust/commit/6b9580b651fa67ca7cf536ceab995d185202a114"}], "stats": {"total": 121, "additions": 86, "deletions": 35}, "files": [{"sha": "f867fb2078549ddf3268b8c7a968743118dbbfa2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 70, "deletions": 35, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/2c3b05d90d4dee879a0d9f33e721c930b087d7d1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c3b05d90d4dee879a0d9f33e721c930b087d7d1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2c3b05d90d4dee879a0d9f33e721c930b087d7d1", "patch": "@@ -52,7 +52,7 @@ use syntax::ast::{CRATE_NODE_ID, Arm, IsAsync, BindingMode, Block, Crate, Expr,\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, GenericParamKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n-use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n+use syntax::ast::{QSelf, TraitItem, TraitItemKind, TraitRef, Ty, TyKind};\n use syntax::ptr::P;\n use syntax::{span_err, struct_span_err, unwrap_or, walk_list};\n \n@@ -1053,6 +1053,7 @@ impl<'a, R> Rib<'a, R> {\n /// This refers to the thing referred by a name. The difference between `Res` and `Item` is that\n /// items are visible in their whole block, while `Res`es only from the place they are defined\n /// forward.\n+#[derive(Debug)]\n enum LexicalScopeBinding<'a> {\n     Item(&'a NameBinding<'a>),\n     Res(Res),\n@@ -1601,6 +1602,9 @@ pub struct Resolver<'a> {\n     /// The trait that the current context can refer to.\n     current_trait_ref: Option<(Module<'a>, TraitRef)>,\n \n+    /// The current trait's associated types' ident, used for diagnostic suggestions.\n+    current_trait_assoc_types: Vec<Ident>,\n+\n     /// The current self type if inside an impl (used for better errors).\n     current_self_type: Option<Ty>,\n \n@@ -1971,6 +1975,7 @@ impl<'a> Resolver<'a> {\n             label_ribs: Vec::new(),\n \n             current_trait_ref: None,\n+            current_trait_assoc_types: Vec::new(),\n             current_self_type: None,\n             current_self_item: None,\n             last_import_segment: false,\n@@ -2579,32 +2584,36 @@ impl<'a> Resolver<'a> {\n                         walk_list!(this, visit_param_bound, bounds);\n \n                         for trait_item in trait_items {\n-                            let generic_params = HasGenericParams(&trait_item.generics,\n-                                                                    AssocItemRibKind);\n-                            this.with_generic_param_rib(generic_params, |this| {\n-                                match trait_item.node {\n-                                    TraitItemKind::Const(ref ty, ref default) => {\n-                                        this.visit_ty(ty);\n-\n-                                        // Only impose the restrictions of\n-                                        // ConstRibKind for an actual constant\n-                                        // expression in a provided default.\n-                                        if let Some(ref expr) = *default{\n-                                            this.with_constant_rib(|this| {\n-                                                this.visit_expr(expr);\n-                                            });\n+                            this.with_trait_items(trait_items, |this| {\n+                                let generic_params = HasGenericParams(\n+                                    &trait_item.generics,\n+                                    AssocItemRibKind,\n+                                );\n+                                this.with_generic_param_rib(generic_params, |this| {\n+                                    match trait_item.node {\n+                                        TraitItemKind::Const(ref ty, ref default) => {\n+                                            this.visit_ty(ty);\n+\n+                                            // Only impose the restrictions of\n+                                            // ConstRibKind for an actual constant\n+                                            // expression in a provided default.\n+                                            if let Some(ref expr) = *default{\n+                                                this.with_constant_rib(|this| {\n+                                                    this.visit_expr(expr);\n+                                                });\n+                                            }\n                                         }\n-                                    }\n-                                    TraitItemKind::Method(_, _) => {\n-                                        visit::walk_trait_item(this, trait_item)\n-                                    }\n-                                    TraitItemKind::Type(..) => {\n-                                        visit::walk_trait_item(this, trait_item)\n-                                    }\n-                                    TraitItemKind::Macro(_) => {\n-                                        panic!(\"unexpanded macro in resolve!\")\n-                                    }\n-                                };\n+                                        TraitItemKind::Method(_, _) => {\n+                                            visit::walk_trait_item(this, trait_item)\n+                                        }\n+                                        TraitItemKind::Type(..) => {\n+                                            visit::walk_trait_item(this, trait_item)\n+                                        }\n+                                        TraitItemKind::Macro(_) => {\n+                                            panic!(\"unexpanded macro in resolve!\")\n+                                        }\n+                                    };\n+                                });\n                             });\n                         }\n                     });\n@@ -2774,6 +2783,22 @@ impl<'a> Resolver<'a> {\n         result\n     }\n \n+    /// When evaluating a `trait` use its associated types' idents for suggestionsa in E0412.\n+    fn with_trait_items<T, F>(&mut self, trait_items: &Vec<TraitItem>, f: F) -> T\n+        where F: FnOnce(&mut Resolver<'_>) -> T\n+    {\n+        let trait_assoc_types = replace(\n+            &mut self.current_trait_assoc_types,\n+            trait_items.iter().filter_map(|item| match &item.node {\n+                TraitItemKind::Type(bounds, _) if bounds.len() == 0 => Some(item.ident),\n+                _ => None,\n+            }).collect(),\n+        );\n+        let result = f(self);\n+        self.current_trait_assoc_types = trait_assoc_types;\n+        result\n+    }\n+\n     /// This is called to resolve a trait reference from an `impl` (i.e., `impl Trait for Foo`).\n     fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T\n         where F: FnOnce(&mut Resolver<'_>, Option<DefId>) -> T\n@@ -3464,8 +3489,12 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn self_type_is_available(&mut self, span: Span) -> bool {\n-        let binding = self.resolve_ident_in_lexical_scope(Ident::with_empty_ctxt(kw::SelfUpper),\n-                                                          TypeNS, None, span);\n+        let binding = self.resolve_ident_in_lexical_scope(\n+            Ident::with_empty_ctxt(kw::SelfUpper),\n+            TypeNS,\n+            None,\n+            span,\n+        );\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n@@ -4095,13 +4124,12 @@ impl<'a> Resolver<'a> {\n         res\n     }\n \n-    fn lookup_assoc_candidate<FilterFn>(&mut self,\n-                                        ident: Ident,\n-                                        ns: Namespace,\n-                                        filter_fn: FilterFn)\n-                                        -> Option<AssocSuggestion>\n-        where FilterFn: Fn(Res) -> bool\n-    {\n+    fn lookup_assoc_candidate<FilterFn: Fn(Res) -> bool>(\n+        &mut self,\n+        ident: Ident,\n+        ns: Namespace,\n+        filter_fn: FilterFn,\n+    ) -> Option<AssocSuggestion> {\n         fn extract_node_id(t: &Ty) -> Option<NodeId> {\n             match t.node {\n                 TyKind::Path(None, _) => Some(t.id),\n@@ -4133,6 +4161,12 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n+        for assoc_type_ident in &self.current_trait_assoc_types {\n+            if *assoc_type_ident == ident {\n+                return Some(AssocSuggestion::AssocItem);\n+            }\n+        }\n+\n         // Look for associated items in the current trait.\n         if let Some((module, _)) = self.current_trait_ref {\n             if let Ok(binding) = self.resolve_ident_in_module(\n@@ -4145,6 +4179,7 @@ impl<'a> Resolver<'a> {\n                 ) {\n                 let res = binding.res();\n                 if filter_fn(res) {\n+                    debug!(\"extract_node_id res not filtered\");\n                     return Some(if self.has_self.contains(&res.def_id()) {\n                         AssocSuggestion::MethodWithSelf\n                     } else {"}, {"sha": "9bde65998d7441ad96a45e9d2b468516cdbf9c11", "filename": "src/test/ui/suggestions/assoc-type-in-method-return.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2c3b05d90d4dee879a0d9f33e721c930b087d7d1/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-type-in-method-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c3b05d90d4dee879a0d9f33e721c930b087d7d1/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-type-in-method-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-type-in-method-return.rs?ref=2c3b05d90d4dee879a0d9f33e721c930b087d7d1", "patch": "@@ -0,0 +1,7 @@\n+trait A {\n+    type Bla;\n+    fn to_bla(&self) -> Bla;\n+    //~^ ERROR cannot find type `Bla` in this scope\n+}\n+\n+fn main() {}"}, {"sha": "bf908d36d2e3f141360549783997b782353b07fb", "filename": "src/test/ui/suggestions/assoc-type-in-method-return.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2c3b05d90d4dee879a0d9f33e721c930b087d7d1/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-type-in-method-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2c3b05d90d4dee879a0d9f33e721c930b087d7d1/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-type-in-method-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-type-in-method-return.stderr?ref=2c3b05d90d4dee879a0d9f33e721c930b087d7d1", "patch": "@@ -0,0 +1,9 @@\n+error[E0412]: cannot find type `Bla` in this scope\n+  --> $DIR/assoc-type-in-method-return.rs:3:25\n+   |\n+LL |     fn to_bla(&self) -> Bla;\n+   |                         ^^^ help: try: `Self::Bla`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}]}