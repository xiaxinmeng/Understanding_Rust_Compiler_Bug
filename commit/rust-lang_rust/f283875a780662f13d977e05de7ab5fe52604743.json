{"sha": "f283875a780662f13d977e05de7ab5fe52604743", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyODM4NzVhNzgwNjYyZjEzZDk3N2UwNWRlN2FiNWZlNTI2MDQ3NDM=", "commit": {"author": {"name": "Lucas Morales", "email": "lucas@lucasem.com", "date": "2017-09-22T22:43:09Z"}, "committer": {"name": "Lucas Morales", "email": "lucas@lucasem.com", "date": "2017-09-23T02:12:21Z"}, "message": "std::sync::RwLock docs improvement", "tree": {"sha": "6503d461ef5aa8de10c62199fc5641ddf95cab45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6503d461ef5aa8de10c62199fc5641ddf95cab45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f283875a780662f13d977e05de7ab5fe52604743", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEExgMSdpt0+BFsq5IwqzHpWfdVnhkFAlnFwwUACgkQqzHpWfdV\nnhkbjw//cxvzjA4oUkaRdQsKmgJBEAVij66Yn1NGlxVNqQFPtnNvHeYIuj4nN3dd\nFuOOnMUiog5Ap2qcNjBHQ307qQ6ZQPnGEkoqmPer/4YPiYdFEYo2re6Qo0q3JUOm\nE+9Sz2fgoazAHDZ2C3pGUG0RFHH3/E9FIecHkwb6iqPBcROGErVs1QPWa1pW98py\newmFzjpSBrENCew+n2MQrPdVxKWqSQG/vaxvGOXH75cpvo8LKQHKX1643WJ7uEEX\nlPSjVbgSFk7742O8iEyPKS9jNSQ9FE4p8LEzC3TSLFFyiKUxa3i9X/6qorGwDPpB\nyL3PUXiWeGfwUFiyxQxfxds6vwE3SAYAE2wXPkTrDjo7Zqa6BMSg+aA1yqyk1vKQ\nGM15wTrpU2M2R3VnDfH8w3Xeq84FQswB3ZPcNR7cwXcC6CYcx/elzp8OBp5hwyP9\ndhvxM4NkiiBPwSeASYu+/Za+hnaUVUsyd2uQUah9gW2+m5erem3VE4tlpJb/CTka\nnCE6MSwy5gbE4IUTt0QZgf8o2wbx+9ZalzaR9yQzSBcYWVULtytX6mtdyHGJNbbU\nihpAXiUypGvQ9C/Im1VeKMqpAMK4RSUR54+L+YkMJsl9alHEcqNX38hw9NMVuFws\nO/v2Tv4YWeUnXA83MwDHNALPpNJNWFzqdcqjGxmn49a5W01kGGY=\n=VXhm\n-----END PGP SIGNATURE-----", "payload": "tree 6503d461ef5aa8de10c62199fc5641ddf95cab45\nparent 14039a42ac6365afc842214989613f9a688c9a66\nauthor Lucas Morales <lucas@lucasem.com> 1506120189 -0400\ncommitter Lucas Morales <lucas@lucasem.com> 1506132741 -0400\n\nstd::sync::RwLock docs improvement\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f283875a780662f13d977e05de7ab5fe52604743", "html_url": "https://github.com/rust-lang/rust/commit/f283875a780662f13d977e05de7ab5fe52604743", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f283875a780662f13d977e05de7ab5fe52604743/comments", "author": {"login": "lorepozo", "id": 859306, "node_id": "MDQ6VXNlcjg1OTMwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/859306?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lorepozo", "html_url": "https://github.com/lorepozo", "followers_url": "https://api.github.com/users/lorepozo/followers", "following_url": "https://api.github.com/users/lorepozo/following{/other_user}", "gists_url": "https://api.github.com/users/lorepozo/gists{/gist_id}", "starred_url": "https://api.github.com/users/lorepozo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lorepozo/subscriptions", "organizations_url": "https://api.github.com/users/lorepozo/orgs", "repos_url": "https://api.github.com/users/lorepozo/repos", "events_url": "https://api.github.com/users/lorepozo/events{/privacy}", "received_events_url": "https://api.github.com/users/lorepozo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lorepozo", "id": 859306, "node_id": "MDQ6VXNlcjg1OTMwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/859306?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lorepozo", "html_url": "https://github.com/lorepozo", "followers_url": "https://api.github.com/users/lorepozo/followers", "following_url": "https://api.github.com/users/lorepozo/following{/other_user}", "gists_url": "https://api.github.com/users/lorepozo/gists{/gist_id}", "starred_url": "https://api.github.com/users/lorepozo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lorepozo/subscriptions", "organizations_url": "https://api.github.com/users/lorepozo/orgs", "repos_url": "https://api.github.com/users/lorepozo/repos", "events_url": "https://api.github.com/users/lorepozo/events{/privacy}", "received_events_url": "https://api.github.com/users/lorepozo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14039a42ac6365afc842214989613f9a688c9a66", "url": "https://api.github.com/repos/rust-lang/rust/commits/14039a42ac6365afc842214989613f9a688c9a66", "html_url": "https://github.com/rust-lang/rust/commit/14039a42ac6365afc842214989613f9a688c9a66"}], "stats": {"total": 133, "additions": 120, "deletions": 13}, "files": [{"sha": "4757faabfb873aee9118656509e8f3734c296478", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 120, "deletions": 13, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/f283875a780662f13d977e05de7ab5fe52604743/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f283875a780662f13d977e05de7ab5fe52604743/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=f283875a780662f13d977e05de7ab5fe52604743", "patch": "@@ -24,19 +24,24 @@ use sys_common::rwlock as sys;\n /// of the underlying data (exclusive access) and the read portion of this lock\n /// typically allows for read-only access (shared access).\n ///\n+/// In comparison, a [`Mutex`] does not distinguish between readers or writers\n+/// that aquire the lock, therefore blocking any threads waiting for the lock to\n+/// become available. An `RwLock` will allow any number of readers to aquire the\n+/// lock as long as a writer is not holding the lock.\n+///\n /// The priority policy of the lock is dependent on the underlying operating\n /// system's implementation, and this type does not guarantee that any\n /// particular policy will be used.\n ///\n /// The type parameter `T` represents the data that this lock protects. It is\n-/// required that `T` satisfies `Send` to be shared across threads and `Sync` to\n-/// allow concurrent access through readers. The RAII guards returned from the\n-/// locking methods implement `Deref` (and `DerefMut` for the `write` methods)\n-/// to allow access to the contained of the lock.\n+/// required that `T` satisfies [`Send`] to be shared across threads and\n+/// [`Sync`] to allow concurrent access through readers. The RAII guards\n+/// returned from the locking methods implement [`Deref`][] (and [`DerefMut`]\n+/// for the `write` methods) to allow access to the contained of the lock.\n ///\n /// # Poisoning\n ///\n-/// An `RwLock`, like `Mutex`, will become poisoned on a panic. Note, however,\n+/// An `RwLock`, like [`Mutex`], will become poisoned on a panic. Note, however,\n /// that an `RwLock` may only be poisoned if a panic occurs while it is locked\n /// exclusively (write mode). If a panic occurs in any reader, then the lock\n /// will not be poisoned.\n@@ -63,6 +68,12 @@ use sys_common::rwlock as sys;\n ///     assert_eq!(*w, 6);\n /// } // write lock is dropped here\n /// ```\n+///\n+/// [`Deref`]: ../../std/ops/trait.Deref.html\n+/// [`DerefMut`]: ../../std/ops/trait.DerefMut.html\n+/// [`Send`]: ../../std/marker/trait.Send.html\n+/// [`Sync`]: ../../std/marker/trait.Sync.html\n+/// [`Mutex`]: struct.Mutex.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLock<T: ?Sized> {\n     inner: Box<sys::RWLock>,\n@@ -154,6 +165,24 @@ impl<T: ?Sized> RwLock<T> {\n     /// # Panics\n     ///\n     /// This function might panic when called if the lock is already held by the current thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, RwLock};\n+    /// use std::thread;\n+    ///\n+    /// let lock = Arc::new(RwLock::new(1));\n+    /// let c_lock = lock.clone();\n+    ///\n+    /// let n = lock.read().unwrap();\n+    /// assert_eq!(*n, 1);\n+    ///\n+    /// thread::spawn(move || {\n+    ///     let r = c_lock.read();\n+    ///     assert!(r.is_ok());\n+    /// }).join().unwrap();\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn read(&self) -> LockResult<RwLockReadGuard<T>> {\n@@ -180,6 +209,19 @@ impl<T: ?Sized> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(1);\n+    ///\n+    /// match lock.try_read() {\n+    ///     Ok(n) => assert_eq!(*n, 1),\n+    ///     Err(_) => unreachable!(),\n+    /// };\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> {\n@@ -210,6 +252,19 @@ impl<T: ?Sized> RwLock<T> {\n     /// # Panics\n     ///\n     /// This function might panic when called if the lock is already held by the current thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(1);\n+    ///\n+    /// let mut n = lock.write().unwrap();\n+    /// *n = 2;\n+    ///\n+    /// assert!(lock.try_read().is_err());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> {\n@@ -236,6 +291,19 @@ impl<T: ?Sized> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(1);\n+    ///\n+    /// let n = lock.read().unwrap();\n+    /// assert_eq!(*n, 1);\n+    ///\n+    /// assert!(lock.try_write().is_err());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> {\n@@ -253,6 +321,22 @@ impl<T: ?Sized> RwLock<T> {\n     /// If another thread is active, the lock can still become poisoned at any\n     /// time.  You should not trust a `false` value for program correctness\n     /// without additional synchronization.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, RwLock};\n+    /// use std::thread;\n+    ///\n+    /// let lock = Arc::new(RwLock::new(0));\n+    /// let c_lock = lock.clone();\n+    ///\n+    /// let _ = thread::spawn(move || {\n+    ///     let _lock = c_lock.write().unwrap();\n+    ///     panic!(); // the lock gets poisoned\n+    /// }).join();\n+    /// assert_eq!(lock.is_poisoned(), true);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn is_poisoned(&self) -> bool {\n@@ -267,6 +351,19 @@ impl<T: ?Sized> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(String::new());\n+    /// {\n+    ///     let mut s = lock.write().unwrap();\n+    ///     *s = \"modified\".to_owned();\n+    /// }\n+    /// assert_eq!(lock.into_inner().unwrap(), \"modified\");\n+    /// ```\n     #[stable(feature = \"rwlock_into_inner\", since = \"1.6.0\")]\n     pub fn into_inner(self) -> LockResult<T> where T: Sized {\n         // We know statically that there are no outstanding references to\n@@ -282,7 +379,7 @@ impl<T: ?Sized> RwLock<T> {\n                 (ptr::read(inner), ptr::read(poison), ptr::read(data))\n             };\n             mem::forget(self);\n-            inner.destroy();  // Keep in sync with the `Drop` impl.\n+            inner.destroy(); // Keep in sync with the `Drop` impl.\n             drop(inner);\n \n             poison::map_result(poison.borrow(), |_| data.into_inner())\n@@ -300,6 +397,16 @@ impl<T: ?Sized> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let mut lock = RwLock::new(0);\n+    /// *lock.get_mut().unwrap() = 10;\n+    /// assert_eq!(*lock.read().unwrap(), 10);\n+    /// ```\n     #[stable(feature = \"rwlock_get_mut\", since = \"1.6.0\")]\n     pub fn get_mut(&mut self) -> LockResult<&mut T> {\n         // We know statically that there are no other references to `self`, so\n@@ -486,7 +593,7 @@ mod tests {\n     fn test_rw_arc_poison_wr() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<(), _> = thread::spawn(move|| {\n+        let _: Result<(), _> = thread::spawn(move || {\n             let _lock = arc2.write().unwrap();\n             panic!();\n         }).join();\n@@ -498,7 +605,7 @@ mod tests {\n         let arc = Arc::new(RwLock::new(1));\n         assert!(!arc.is_poisoned());\n         let arc2 = arc.clone();\n-        let _: Result<(), _> = thread::spawn(move|| {\n+        let _: Result<(), _> = thread::spawn(move || {\n             let _lock = arc2.write().unwrap();\n             panic!();\n         }).join();\n@@ -510,7 +617,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rr() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<(), _> = thread::spawn(move|| {\n+        let _: Result<(), _> = thread::spawn(move || {\n             let _lock = arc2.read().unwrap();\n             panic!();\n         }).join();\n@@ -521,7 +628,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rw() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<(), _> = thread::spawn(move|| {\n+        let _: Result<(), _> = thread::spawn(move || {\n             let _lock = arc2.read().unwrap();\n             panic!()\n         }).join();\n@@ -535,7 +642,7 @@ mod tests {\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n-        thread::spawn(move|| {\n+        thread::spawn(move || {\n             let mut lock = arc2.write().unwrap();\n             for _ in 0..10 {\n                 let tmp = *lock;\n@@ -550,7 +657,7 @@ mod tests {\n         let mut children = Vec::new();\n         for _ in 0..5 {\n             let arc3 = arc.clone();\n-            children.push(thread::spawn(move|| {\n+            children.push(thread::spawn(move || {\n                 let lock = arc3.read().unwrap();\n                 assert!(*lock >= 0);\n             }));\n@@ -571,7 +678,7 @@ mod tests {\n     fn test_rw_arc_access_in_unwind() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _ = thread::spawn(move|| -> () {\n+        let _ = thread::spawn(move || -> () {\n             struct Unwinder {\n                 i: Arc<RwLock<isize>>,\n             }"}]}