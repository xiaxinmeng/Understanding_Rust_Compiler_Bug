{"sha": "728edb5af6917956596bd19f4298137df97c44f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyOGVkYjVhZjY5MTc5NTY1OTZiZDE5ZjQyOTgxMzdkZjk3YzQ0ZjM=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-15T18:27:33Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-20T09:08:58Z"}, "message": "(cleanup) impl TaskSet", "tree": {"sha": "1b813106290eee0add373d252763b6fe83374738", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b813106290eee0add373d252763b6fe83374738"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/728edb5af6917956596bd19f4298137df97c44f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/728edb5af6917956596bd19f4298137df97c44f3", "html_url": "https://github.com/rust-lang/rust/commit/728edb5af6917956596bd19f4298137df97c44f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/728edb5af6917956596bd19f4298137df97c44f3/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d9184609a6edb54eb06f402dedcbc8f13da3d1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d9184609a6edb54eb06f402dedcbc8f13da3d1a", "html_url": "https://github.com/rust-lang/rust/commit/6d9184609a6edb54eb06f402dedcbc8f13da3d1a"}], "stats": {"total": 85, "additions": 46, "deletions": 39}, "files": [{"sha": "f5e5dbb3dbf7ff5db30dddd4fa8d9b62799b9274", "filename": "src/libstd/option.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/728edb5af6917956596bd19f4298137df97c44f3/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728edb5af6917956596bd19f4298137df97c44f3/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=728edb5af6917956596bd19f4298137df97c44f3", "patch": "@@ -180,6 +180,13 @@ impl<T> Option<T> {\n         match *self { Some(ref mut x) => Some(f(x)), None => None }\n     }\n \n+    /// Maps a `some` value from one type to another by a mutable reference,\n+    /// or returns a default value.\n+    #[inline]\n+    pub fn map_mut_default<'a, U>(&'a mut self, def: U, f: &fn(&'a mut T) -> U) -> U {\n+        match *self { Some(ref mut x) => f(x), None => def }\n+    }\n+\n     /// As `map`, but consumes the option and gives `f` ownership to avoid\n     /// copying.\n     #[inline]"}, {"sha": "aac4463888b3e7476eb4e59d8a956b2344c786da", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/728edb5af6917956596bd19f4298137df97c44f3/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728edb5af6917956596bd19f4298137df97c44f3/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=728edb5af6917956596bd19f4298137df97c44f3", "patch": "@@ -128,21 +128,27 @@ impl IterBytes for TaskHandle {\n     }\n }\n \n-type TaskSet = HashSet<TaskHandle>;\n+struct TaskSet(HashSet<TaskHandle>);\n \n-fn new_taskset() -> TaskSet {\n-    HashSet::new()\n-}\n-fn taskset_insert(tasks: &mut TaskSet, task: TaskHandle) {\n-    let didnt_overwrite = tasks.insert(task);\n-    assert!(didnt_overwrite);\n-}\n-fn taskset_remove(tasks: &mut TaskSet, task: &TaskHandle) {\n-    let was_present = tasks.remove(task);\n-    assert!(was_present);\n-}\n-fn taskset_consume(tasks: TaskSet) -> HashSetConsumeIterator<TaskHandle> {\n-    tasks.consume()\n+impl TaskSet {\n+    #[inline]\n+    fn new() -> TaskSet {\n+        TaskSet(HashSet::new())\n+    }\n+    #[inline]\n+    fn insert(&mut self, task: TaskHandle) {\n+        let didnt_overwrite = (**self).insert(task);\n+        assert!(didnt_overwrite);\n+    }\n+    #[inline]\n+    fn remove(&mut self, task: &TaskHandle) {\n+        let was_present = (**self).remove(task);\n+        assert!(was_present);\n+    }\n+    #[inline]\n+    fn consume(self) -> HashSetConsumeIterator<TaskHandle> {\n+        (*self).consume()\n+    }\n }\n \n // One of these per group of linked-failure tasks.\n@@ -413,36 +419,30 @@ fn AutoNotify(chan: Chan<TaskResult>) -> AutoNotify {\n \n fn enlist_in_taskgroup(state: TaskGroupInner, me: TaskHandle,\n                            is_member: bool) -> bool {\n-    let newstate = util::replace(&mut *state, None);\n+    let me = Cell::new(me); // :(\n     // If 'None', the group was failing. Can't enlist.\n-    if newstate.is_some() {\n-        let mut group = newstate.unwrap();\n-        taskset_insert(if is_member {\n+    do state.map_mut_default(false) |group| {\n+        (if is_member {\n             &mut group.members\n         } else {\n             &mut group.descendants\n-        }, me);\n-        *state = Some(group);\n+        }).insert(me.take());\n         true\n-    } else {\n-        false\n     }\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n fn leave_taskgroup(state: TaskGroupInner, me: &TaskHandle,\n                        is_member: bool) {\n-    let newstate = util::replace(&mut *state, None);\n+    let me = Cell::new(me); // :(\n     // If 'None', already failing and we've already gotten a kill signal.\n-    if newstate.is_some() {\n-        let mut group = newstate.unwrap();\n-        taskset_remove(if is_member {\n+    do state.map_mut |group| {\n+        (if is_member {\n             &mut group.members\n         } else {\n             &mut group.descendants\n-        }, me);\n-        *state = Some(group);\n-    }\n+        }).remove(me.take());\n+    };\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n@@ -464,13 +464,13 @@ fn kill_taskgroup(state: TaskGroupInner, me: &TaskHandle, is_main: bool) {\n         if newstate.is_some() {\n             let TaskGroupData { members: members, descendants: descendants } =\n                 newstate.unwrap();\n-            for taskset_consume(members).advance() |sibling| {\n+            for members.consume().advance |sibling| {\n                 // Skip self - killing ourself won't do much good.\n                 if &sibling != me {\n                     RuntimeGlue::kill_task(sibling);\n                 }\n             }\n-            do taskset_consume(descendants).advance() |child| {\n+            for descendants.consume().advance |child| {\n                 assert!(&child != me);\n                 RuntimeGlue::kill_task(child);\n             }\n@@ -548,11 +548,11 @@ impl RuntimeGlue {\n                     match g {\n                         None => {\n                             // Main task, doing first spawn ever. Lazily initialise here.\n-                            let mut members = new_taskset();\n-                            taskset_insert(&mut members, OldTask(me));\n+                            let mut members = TaskSet::new();\n+                            members.insert(OldTask(me));\n                             let tasks = exclusive(Some(TaskGroupData {\n                                 members: members,\n-                                descendants: new_taskset(),\n+                                descendants: TaskSet::new(),\n                             }));\n                             // Main task/group has no ancestors, no notifier, etc.\n                             let group = @@mut TCB(tasks, AncestorList(None), true, None);\n@@ -570,12 +570,12 @@ impl RuntimeGlue {\n                 blk(match (*me).taskgroup {\n                     None => {\n                         // Main task, doing first spawn ever. Lazily initialize.\n-                        let mut members = new_taskset();\n+                        let mut members = TaskSet::new();\n                         let my_handle = (*me).death.kill_handle.get_ref().clone();\n-                        taskset_insert(&mut members, NewTask(my_handle));\n+                        members.insert(NewTask(my_handle));\n                         let tasks = exclusive(Some(TaskGroupData {\n                             members: members,\n-                            descendants: new_taskset(),\n+                            descendants: TaskSet::new(),\n                         }));\n                         let group = TCB(tasks, AncestorList(None), true, None);\n                         (*me).taskgroup = Some(group);\n@@ -601,8 +601,8 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         } else {\n             // Child is in a separate group from spawner.\n             let g = exclusive(Some(TaskGroupData {\n-                members:     new_taskset(),\n-                descendants: new_taskset(),\n+                members:     TaskSet::new(),\n+                descendants: TaskSet::new(),\n             }));\n             let a = if supervised {\n                 let new_generation = incr_generation(&ancestors);"}]}