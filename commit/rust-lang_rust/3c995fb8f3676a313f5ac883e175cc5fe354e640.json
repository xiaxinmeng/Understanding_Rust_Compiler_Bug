{"sha": "3c995fb8f3676a313f5ac883e175cc5fe354e640", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjOTk1ZmI4ZjM2NzZhMzEzZjVhYzg4M2UxNzVjYzVmZTM1NGU2NDA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-19T04:26:25Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-20T04:01:11Z"}, "message": "make nominal types optionally parameterized by a self region.\n\nIssue #2201.", "tree": {"sha": "fa1a0f749b8e6efcb360977f4ad1fa9a397e0cb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa1a0f749b8e6efcb360977f4ad1fa9a397e0cb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c995fb8f3676a313f5ac883e175cc5fe354e640", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c995fb8f3676a313f5ac883e175cc5fe354e640", "html_url": "https://github.com/rust-lang/rust/commit/3c995fb8f3676a313f5ac883e175cc5fe354e640", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c995fb8f3676a313f5ac883e175cc5fe354e640/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3f34bf09b2512cac0e77281d8f2249d64cf2743", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3f34bf09b2512cac0e77281d8f2249d64cf2743", "html_url": "https://github.com/rust-lang/rust/commit/f3f34bf09b2512cac0e77281d8f2249d64cf2743"}], "stats": {"total": 2260, "additions": 1326, "deletions": 934}, "files": [{"sha": "ff581b6dbf5419baf5ba6f6cdd29458037d0b724", "filename": "src/librustsyntax/ast.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Flibrustsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Flibrustsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -645,21 +645,29 @@ type iface_ref = {path: @path, id: node_id};\n type item = {ident: ident, attrs: [attribute],\n              id: node_id, node: item_, span: span};\n \n+#[auto_serialize]\n+enum region_param {\n+    rp_none,\n+    rp_self\n+}\n+\n #[auto_serialize]\n enum item_ {\n     item_const(@ty, @expr),\n     item_fn(fn_decl, [ty_param], blk),\n     item_mod(_mod),\n     item_native_mod(native_mod),\n-    item_ty(@ty, [ty_param]),\n-    item_enum([variant], [ty_param]),\n+    item_ty(@ty, [ty_param], region_param),\n+    item_enum([variant], [ty_param], region_param),\n     item_res(fn_decl /* dtor */, [ty_param], blk /* dtor body */,\n-             node_id /* dtor id */, node_id /* ctor id */),\n+             node_id /* dtor id */, node_id /* ctor id */,\n+             region_param),\n     item_class([ty_param], /* ty params for class */\n                [iface_ref],   /* ifaces this class implements */\n                [@class_member], /* methods, etc. */\n                                /* (not including ctor) */\n-               class_ctor\n+               class_ctor,\n+               region_param\n                ),\n     item_iface([ty_param], [ty_method]),\n     item_impl([ty_param], option<@ty> /* iface */,"}, {"sha": "ddfb9e6de16e8a7d09b817df48987eb5bfd77d9f", "filename": "src/librustsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Flibrustsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Flibrustsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast_util.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -149,7 +149,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n     for m.items.each {|it|\n         if it.ident == i { local = true; }\n         alt it.node {\n-          item_enum(variants, _) {\n+          item_enum(variants, _, _) {\n             for variants.each {|v|\n                 if v.node.name == i {\n                    local = true;"}, {"sha": "a6700b566a300d6a85d2b147e2d621b0b56e642f", "filename": "src/librustsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -102,11 +102,11 @@ fn expand(cx: ext_ctxt,\n \n     vec::flat_map(in_items) {|in_item|\n         alt in_item.node {\n-          ast::item_ty(ty, tps) {\n+          ast::item_ty(ty, tps, _) {\n             [filter_attrs(in_item)] + ty_fns(cx, in_item.ident, ty, tps)\n           }\n \n-          ast::item_enum(variants, tps) {\n+          ast::item_enum(variants, tps, _) {\n             [filter_attrs(in_item)] + enum_fns(cx, in_item.ident,\n                                                in_item.span, variants, tps)\n           }"}, {"sha": "6e4d89eb5c0f2712fe8cc530adc07f0c970a7a26", "filename": "src/librustsyntax/fold.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Flibrustsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Flibrustsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Ffold.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -265,36 +265,42 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           }\n           item_mod(m) { item_mod(fld.fold_mod(m)) }\n           item_native_mod(nm) { item_native_mod(fld.fold_native_mod(nm)) }\n-          item_ty(t, typms) { item_ty(fld.fold_ty(t),\n-                                      fold_ty_params(typms, fld)) }\n-          item_enum(variants, typms) {\n+          item_ty(t, typms, rp) { item_ty(fld.fold_ty(t),\n+                                          fold_ty_params(typms, fld),\n+                                          rp) }\n+          item_enum(variants, typms, r) {\n             item_enum(vec::map(variants, fld.fold_variant),\n-                      fold_ty_params(typms, fld))\n+                      fold_ty_params(typms, fld),\n+                      r)\n           }\n-          item_class(typms, ifaces, items, ctor) {\n+          item_class(typms, ifaces, items, ctor, rp) {\n               let ctor_body = fld.fold_block(ctor.node.body);\n               let ctor_decl = fold_fn_decl(ctor.node.dec, fld);\n               let ctor_id   = fld.new_id(ctor.node.id);\n-              item_class(typms, vec::map(ifaces, {|p|\n-                              {path: fld.fold_path(p.path),\n-                               id: fld.new_id(p.id)}}),\n-                         vec::map(items, fld.fold_class_item),\n-                         {node: {body: ctor_body,\n-                                 dec: ctor_decl,\n-                                 id: ctor_id with ctor.node}\n-                             with ctor})\n+              item_class(\n+                  typms,\n+                  vec::map(ifaces, {|p|\n+                      {path: fld.fold_path(p.path),\n+                       id: fld.new_id(p.id)}}),\n+                  vec::map(items, fld.fold_class_item),\n+                  {node: {body: ctor_body,\n+                          dec: ctor_decl,\n+                          id: ctor_id with ctor.node}\n+                   with ctor},\n+                  rp)\n           }\n           item_impl(tps, ifce, ty, methods) {\n             item_impl(tps, option::map(ifce, fld.fold_ty), fld.fold_ty(ty),\n                       vec::map(methods, fld.fold_method))\n           }\n           item_iface(tps, methods) { item_iface(tps, methods) }\n-          item_res(decl, typms, body, did, cid) {\n+          item_res(decl, typms, body, did, cid, rp) {\n             item_res(fold_fn_decl(decl, fld),\n                      fold_ty_params(typms, fld),\n                      fld.fold_block(body),\n                      fld.new_id(did),\n-                     fld.new_id(cid))\n+                     fld.new_id(cid),\n+                     rp)\n           }\n         };\n }"}, {"sha": "8b1fc2d6ada87a2be19d789569827b6de6363eba", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -1992,6 +1992,7 @@ fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo;\n     let ident = parse_value_ident(p);\n+    let rp = parse_region_param(p);\n     let ty_params = parse_ty_params(p);\n     expect(p, token::LPAREN);\n     let arg_ident = parse_value_ident(p);\n@@ -2010,7 +2011,8 @@ fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n          cf: ast::return_val,\n          constraints: []};\n     ret mk_item(p, lo, dtor.span.hi, ident,\n-                ast::item_res(decl, ty_params, dtor, p.get_id(), p.get_id()),\n+                ast::item_res(decl, ty_params, dtor,\n+                              p.get_id(), p.get_id(), rp),\n                 attrs);\n }\n \n@@ -2035,6 +2037,7 @@ fn parse_iface_ref_list(p:parser) -> [ast::iface_ref] {\n fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo;\n     let class_name = parse_value_ident(p);\n+    let rp = parse_region_param(p);\n     let ty_params = parse_ty_params(p);\n     let class_path = ident_to_path_tys(p, class_name, ty_params);\n     let ifaces : [ast::iface_ref] = if eat_word(p, \"implements\")\n@@ -2057,11 +2060,11 @@ fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n       some((ct_d, ct_b, ct_s)) {\n           ret mk_item(p, lo, p.last_span.hi, class_name,\n                       ast::item_class(ty_params, ifaces, ms,\n-                         {node: {id: ctor_id,\n-                                 self_id: p.get_id(),\n-                                 dec: ct_d,\n-                                 body: ct_b},\n-                          span: ct_s}), attrs); }\n+                                      {node: {id: ctor_id,\n+                                              self_id: p.get_id(),\n+                                              dec: ct_d,\n+                                              body: ct_b},\n+                                       span: ct_s}, rp), attrs); }\n        /*\n          Is it strange for the parser to check this?\n        */\n@@ -2236,17 +2239,23 @@ fn parse_type_decl(p: parser) -> {lo: uint, ident: ast::ident} {\n \n fn parse_item_type(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let t = parse_type_decl(p);\n+    let rp = parse_region_param(p);\n     let tps = parse_ty_params(p);\n     expect(p, token::EQ);\n     let ty = parse_ty(p, false);\n     let mut hi = p.span.hi;\n     expect(p, token::SEMI);\n-    ret mk_item(p, t.lo, hi, t.ident, ast::item_ty(ty, tps), attrs);\n+    ret mk_item(p, t.lo, hi, t.ident, ast::item_ty(ty, tps, rp), attrs);\n+}\n+\n+fn parse_region_param(p: parser) -> ast::region_param {\n+    if eat(p, token::BINOP(token::AND)) {ast::rp_self} else {ast::rp_none}\n }\n \n fn parse_item_enum(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo;\n     let id = parse_ident(p);\n+    let rp = parse_region_param(p);\n     let ty_params = parse_ty_params(p);\n     let mut variants: [ast::variant] = [];\n     // Newtype syntax\n@@ -2265,7 +2274,7 @@ fn parse_item_enum(p: parser, attrs: [ast::attribute]) -> @ast::item {\n                      id: p.get_id(),\n                      disr_expr: none});\n         ret mk_item(p, lo, ty.span.hi, id,\n-                    ast::item_enum([variant], ty_params), attrs);\n+                    ast::item_enum([variant], ty_params, rp), attrs);\n     }\n     expect(p, token::LBRACE);\n \n@@ -2301,7 +2310,7 @@ fn parse_item_enum(p: parser, attrs: [ast::attribute]) -> @ast::item {\n         p.fatal(\"discriminator values can only be used with a c-like enum\");\n     }\n     ret mk_item(p, lo, p.last_span.hi, id,\n-                ast::item_enum(variants, ty_params), attrs);\n+                ast::item_enum(variants, ty_params, rp), attrs);\n }\n \n fn parse_fn_ty_proto(p: parser) -> ast::proto {"}, {"sha": "d5be2d12bc9d07f434a006f0698bb4bbcc926a72", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -125,10 +125,10 @@ fn test_fun_to_str() {\n }\n \n fn res_to_str(decl: ast::fn_decl, name: ast::ident,\n-              params: [ast::ty_param]) -> str {\n+              params: [ast::ty_param], rp: ast::region_param) -> str {\n     let buffer = io::mem_buffer();\n     let s = rust_printer(io::mem_buffer_writer(buffer));\n-    print_res(s, decl, name, params);\n+    print_res(s, decl, name, params, rp);\n     end(s); // Close the head box\n     end(s); // Close the outer box\n     eof(s.s);\n@@ -454,11 +454,12 @@ fn print_item(s: ps, &&item: @ast::item) {\n         print_native_mod(s, nmod, item.attrs);\n         bclose(s, item.span);\n       }\n-      ast::item_ty(ty, params) {\n+      ast::item_ty(ty, params, rp) {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n         word_nbsp(s, \"type\");\n         word(s.s, item.ident);\n+        print_region_param(s, rp);\n         print_type_params(s, params);\n         end(s); // end the inner ibox\n \n@@ -468,7 +469,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         word(s.s, \";\");\n         end(s); // end the outer ibox\n       }\n-      ast::item_enum(variants, params) {\n+      ast::item_enum(variants, params, rp) {\n         let newtype =\n             vec::len(variants) == 1u &&\n                 str::eq(item.ident, variants[0].node.name) &&\n@@ -478,6 +479,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n             word_space(s, \"enum\");\n         } else { head(s, \"enum\"); }\n         word(s.s, item.ident);\n+        print_region_param(s, rp);\n         print_type_params(s, params);\n         space(s.s);\n         if newtype {\n@@ -500,9 +502,10 @@ fn print_item(s: ps, &&item: @ast::item) {\n             bclose(s, item.span);\n         }\n       }\n-      ast::item_class(tps,ifaces,items,ctor) {\n+      ast::item_class(tps,ifaces,items,ctor, rp) {\n           head(s, \"class\");\n           word_nbsp(s, item.ident);\n+          print_region_param(s, rp);\n           print_type_params(s, tps);\n           word_space(s, \"implements\");\n           commasep(s, inconsistent, ifaces, {|s, p|\n@@ -584,18 +587,19 @@ fn print_item(s: ps, &&item: @ast::item) {\n         for methods.each {|meth| print_ty_method(s, meth); }\n         bclose(s, item.span);\n       }\n-      ast::item_res(decl, tps, body, dt_id, ct_id) {\n-        print_res(s, decl, item.ident, tps);\n+      ast::item_res(decl, tps, body, dt_id, ct_id, rp) {\n+        print_res(s, decl, item.ident, tps, rp);\n         print_block(s, body);\n       }\n     }\n     s.ann.post(ann_node);\n }\n \n fn print_res(s: ps, decl: ast::fn_decl, name: ast::ident,\n-             typarams: [ast::ty_param]) {\n+             typarams: [ast::ty_param], rp: ast::region_param) {\n     head(s, \"resource\");\n     word(s.s, name);\n+    print_region_param(s, rp);\n     print_type_params(s, typarams);\n     popen(s);\n     word_space(s, decl.inputs[0].ident + \":\");\n@@ -1401,6 +1405,13 @@ fn print_bounds(s: ps, bounds: @[ast::ty_param_bound]) {\n     }\n }\n \n+fn print_region_param(s: ps, rp: ast::region_param) {\n+    alt rp {\n+      ast::rp_self { word(s.s, \"&\") }\n+      ast::rp_none { }\n+    }\n+}\n+\n fn print_type_params(s: ps, &&params: [ast::ty_param]) {\n     if vec::len(params) > 0u {\n         word(s.s, \"<\");"}, {"sha": "8aad377888006ab568046ff826db81a6dd4106c2", "filename": "src/librustsyntax/visit.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Flibrustsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Flibrustsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fvisit.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -15,7 +15,7 @@ enum vt<E> { mk_vt(visitor<E>), }\n enum fn_kind {\n     fk_item_fn(ident, [ty_param]), //< an item declared with fn()\n     fk_method(ident, [ty_param], @method),\n-    fk_res(ident, [ty_param]),\n+    fk_res(ident, [ty_param], region_param),\n     fk_anon(proto),  //< an anonymous function like fn@(...)\n     fk_fn_block,     //< a block {||...}\n     fk_ctor(ident, [ty_param], node_id /* self id */,\n@@ -24,15 +24,15 @@ enum fn_kind {\n \n fn name_of_fn(fk: fn_kind) -> ident {\n     alt fk {\n-      fk_item_fn(name, _) | fk_method(name, _, _) | fk_res(name, _)\n+      fk_item_fn(name, _) | fk_method(name, _, _) | fk_res(name, _, _)\n           | fk_ctor(name, _, _, _) { name }\n       fk_anon(_) | fk_fn_block { \"anon\" }\n     }\n }\n \n fn tps_of_fn(fk: fn_kind) -> [ty_param] {\n     alt fk {\n-      fk_item_fn(_, tps) | fk_method(_, tps, _) | fk_res(_, tps)\n+      fk_item_fn(_, tps) | fk_method(_, tps, _) | fk_res(_, tps, _)\n           | fk_ctor(_, tps, _, _) { tps }\n       fk_anon(_) | fk_fn_block { [] }\n     }\n@@ -118,12 +118,15 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         for nm.view_items.each {|vi| v.visit_view_item(vi, e, v); }\n         for nm.items.each {|ni| v.visit_native_item(ni, e, v); }\n       }\n-      item_ty(t, tps) { v.visit_ty(t, e, v); v.visit_ty_params(tps, e, v); }\n-      item_res(decl, tps, body, dtor_id, _) {\n-        v.visit_fn(fk_res(i.ident, tps), decl, body, i.span,\n+      item_ty(t, tps, rp) {\n+        v.visit_ty(t, e, v);\n+        v.visit_ty_params(tps, e, v);\n+      }\n+      item_res(decl, tps, body, dtor_id, _, rp) {\n+        v.visit_fn(fk_res(i.ident, tps, rp), decl, body, i.span,\n                    dtor_id, e, v);\n       }\n-      item_enum(variants, tps) {\n+      item_enum(variants, tps, _) {\n         v.visit_ty_params(tps, e, v);\n         for variants.each {|vr|\n             for vr.node.args.each {|va| v.visit_ty(va.ty, e, v); }\n@@ -137,7 +140,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n             visit_method_helper(m, e, v)\n         }\n       }\n-      item_class(tps, ifaces, members, ctor) {\n+      item_class(tps, ifaces, members, ctor, _) {\n           v.visit_ty_params(tps, e, v);\n           for members.each {|m|\n              v.visit_class_item(m, e, v);"}, {"sha": "0ef8dfa1243c67355d32dedb326ab8b9142b4357", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -143,8 +143,8 @@ fn visit_ids(item: ast::inlined_item, vfn: fn@(ast::node_id)) {\n         visit_item: fn@(i: @ast::item) {\n             vfn(i.id);\n             alt i.node {\n-              ast::item_res(_, _, _, d_id, c_id) { vfn(d_id); vfn(c_id); }\n-              ast::item_enum(vs, _) { for vs.each {|v| vfn(v.node.id); } }\n+              ast::item_res(_, _, _, d_id, c_id, _) { vfn(d_id); vfn(c_id); }\n+              ast::item_enum(vs, _, _) { for vs.each {|v| vfn(v.node.id); } }\n               _ {}\n             }\n         },\n@@ -209,7 +209,7 @@ fn visit_ids(item: ast::inlined_item, vfn: fn@(ast::node_id)) {\n                 vfn(parent_id.node);\n               }\n               visit::fk_item_fn(_, tps) |\n-              visit::fk_res(_, tps) {\n+              visit::fk_res(_, tps, _) {\n                 vec::iter(tps) {|tp| vfn(tp.id)}\n               }\n               visit::fk_method(_, tps, m) {\n@@ -679,7 +679,10 @@ impl helpers for ebml::writer {\n                     self.emit_bounds(ecx, bs)\n                 }\n             }\n-            self.emit_rec_field(\"ty\", 0u) {||\n+            self.emit_rec_field(\"rp\", 1u) {||\n+                ast::serialize_region_param(self, tpbt.rp)\n+            }\n+            self.emit_rec_field(\"ty\", 2u) {||\n                 self.emit_ty(ecx, tpbt.ty);\n             }\n         }\n@@ -848,6 +851,11 @@ impl decoder for ebml::doc {\n \n impl decoder for ebml::ebml_deserializer {\n     fn read_ty(xcx: extended_decode_ctxt) -> ty::t {\n+        // Note: regions types embed local node ids.  In principle, we\n+        // should translate these node ids into the new decode\n+        // context.  However, we do not bother, because region types\n+        // are not used during trans.\n+\n         tydecode::parse_ty_data(\n             self.parent.data, xcx.dcx.cdata.cnum, self.pos, xcx.dcx.tcx,\n             xcx.tr_def_id(_))\n@@ -870,7 +878,10 @@ impl decoder for ebml::ebml_deserializer {\n                 bounds: self.read_rec_field(\"bounds\", 0u) {||\n                     @self.read_to_vec {|| self.read_bounds(xcx) }\n                 },\n-                ty: self.read_rec_field(\"ty\", 1u) {||\n+                rp: self.read_rec_field(\"rp\", 1u) {||\n+                    ast::deserialize_region_param(self)\n+                },\n+                ty: self.read_rec_field(\"ty\", 2u) {||\n                     self.read_ty(xcx)\n                 }\n             }"}, {"sha": "33ae58d3a052588395f68e4b4256ee44790536f2", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -84,6 +84,8 @@ const tag_path_elt_name: uint = 0x43u;\n const tag_item_field: uint = 0x44u;\n const tag_class_mut: uint = 0x45u;\n \n+const tag_region_param: uint = 0x46u;\n+\n // used to encode crate_ctxt side tables\n enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_ast = 0x50,"}, {"sha": "0b7dada4f2dde591513a156ad41df8d0eb0e1d5c", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -157,7 +157,7 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n                  class_id, def)});\n     #debug(\"got field data %?\", the_field);\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n-    ret {bounds: @[], ty: ty};\n+    ret {bounds: @[], rp: ast::rp_none, ty: ty};\n }\n \n fn get_impl_iface(tcx: ty::ctxt, def: ast::def_id)"}, {"sha": "0fed31c20bcc0ddcecc7ab3b2170634e744a6a70", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -15,6 +15,7 @@ import syntax::print::pprust;\n import cmd=cstore::crate_metadata;\n import middle::trans::common::maps;\n import util::ppaux::ty_to_str;\n+import ebml::deserializer;\n \n export get_class_fields;\n export get_symbol;\n@@ -176,6 +177,18 @@ fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     @bounds\n }\n \n+fn item_ty_region_param(item: ebml::doc) -> ast::region_param {\n+    alt ebml::maybe_get_doc(item, tag_region_param) {\n+      some(rp_doc) {\n+        let dsr = ebml::ebml_deserializer(rp_doc);\n+        ast::deserialize_region_param(dsr)\n+      }\n+      none { // not all families of items have region params\n+        ast::rp_none\n+      }\n+    }\n+}\n+\n fn item_ty_param_count(item: ebml::doc) -> uint {\n     let mut n = 0u;\n     ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds,\n@@ -272,12 +285,14 @@ fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: ast::def_id) ->\n \n fn get_type(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     -> ty::ty_param_bounds_and_ty {\n+\n     let item = lookup_item(id, cdata.data);\n     let t = item_type({crate: cdata.cnum, node: id}, item, tcx, cdata);\n     let tp_bounds = if family_has_type_params(item_family(item)) {\n         item_ty_param_bounds(item, tcx, cdata)\n     } else { @[] };\n-    ret {bounds: tp_bounds, ty: t};\n+    let rp = item_ty_region_param(item);\n+    ret {bounds: tp_bounds, rp: rp, ty: t};\n }\n \n fn get_type_param_count(data: @[u8], id: ast::node_id) -> uint {"}, {"sha": "dfefe8d78b72449ddfbae5e26ba2692f8ed0221f", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -16,6 +16,7 @@ import middle::ast_map;\n import syntax::attr;\n import driver::session::session;\n import std::serialization::serializer;\n+import std::ebml::serializer;\n \n export encode_metadata;\n export encoded_ty;\n@@ -40,6 +41,12 @@ fn encode_def_id(ebml_w: ebml::writer, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n+fn encode_region_param(ebml_w: ebml::writer, rp: region_param) {\n+    ebml_w.wr_tag(tag_region_param) {||\n+        serialize_region_param(ebml_w, rp)\n+    }\n+}\n+\n fn encode_named_def_id(ebml_w: ebml::writer, name: str, id: def_id) {\n     ebml_w.wr_tag(tag_paths_data_item) {||\n         encode_name(ebml_w, name);\n@@ -132,14 +139,14 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                                             index);\n             ebml_w.end_tag();\n           }\n-          item_ty(_, tps) {\n+          item_ty(_, tps, _) {\n             add_to_index(ebml_w, path, index, it.ident);\n             ebml_w.start_tag(tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml_w.end_tag();\n           }\n-          item_res(_, tps, _, _, ctor_id) {\n+          item_res(_, tps, _, _, ctor_id, _) {\n             add_to_index(ebml_w, path, index, it.ident);\n             ebml_w.start_tag(tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n@@ -151,7 +158,7 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml_w.end_tag();\n           }\n-          item_class(_, _, items, ctor) {\n+          item_class(_, _, items, ctor, _) {\n             add_to_index(ebml_w, path, index, it.ident);\n             ebml_w.start_tag(tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n@@ -165,7 +172,7 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                                       index);\n             ebml_w.end_tag();\n           }\n-          item_enum(variants, tps) {\n+          item_enum(variants, _, _) {\n             add_to_index(ebml_w, path, index, it.ident);\n             ebml_w.start_tag(tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n@@ -480,7 +487,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                         index: @mut [entry<int>], path: ast_map::path) {\n \n     let tcx = ecx.ccx.tcx;\n-    let must_write = alt item.node { item_enum(_, _) { true } _ { false } };\n+    let must_write =\n+        alt item.node { item_enum(_, _, _) { true } _ { false } };\n     if !must_write && !ecx.ccx.reachable.contains_key(item.id) { ret; }\n \n     fn add_to_index_(item: @item, ebml_w: ebml::writer,\n@@ -528,7 +536,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n-      item_ty(_, tps) {\n+      item_ty(_, tps, rp) {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -537,26 +545,28 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n+        encode_region_param(ebml_w, rp);\n         ebml_w.end_tag();\n       }\n-      item_enum(variants, tps) {\n+      item_enum(variants, tps, rp) {\n         add_to_index();\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 't');\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-        encode_name(ebml_w, item.ident);\n-        for variants.each {|v|\n-            encode_variant_id(ebml_w, local_def(v.node.id));\n+        ebml_w.wr_tag(tag_items_data_item) {||\n+            encode_def_id(ebml_w, local_def(item.id));\n+            encode_family(ebml_w, 't');\n+            encode_type_param_bounds(ebml_w, ecx, tps);\n+            encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+            encode_name(ebml_w, item.ident);\n+            for variants.each {|v|\n+                encode_variant_id(ebml_w, local_def(v.node.id));\n+            }\n+            astencode::encode_inlined_item(ecx, ebml_w, path, ii_item(item));\n+            encode_path(ebml_w, path, ast_map::path_name(item.ident));\n+            encode_region_param(ebml_w, rp);\n         }\n-        astencode::encode_inlined_item(ecx, ebml_w, path, ii_item(item));\n-        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-        ebml_w.end_tag();\n         encode_enum_variant_info(ecx, ebml_w, item.id, variants,\n                                  path, index, tps);\n       }\n-      item_class(tps, _ifaces, items,ctor) {\n+      item_class(tps, _ifaces, items, ctor, rp) {\n         /* First, encode the fields and methods\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n@@ -573,6 +583,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n+        encode_region_param(ebml_w, rp);\n         /* FIXME: encode ifaces */\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_iface_method\n@@ -605,7 +616,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_index(ebml_w, bkts, write_int);\n         ebml_w.end_tag();\n       }\n-      item_res(_, tps, _, _, ctor_id) {\n+      item_res(_, tps, _, _, ctor_id, rp) {\n         add_to_index();\n         let fn_ty = node_id_to_type(tcx, ctor_id);\n \n@@ -620,6 +631,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             encode_symbol(ecx, ebml_w, item.id);\n         }\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n+        encode_region_param(ebml_w, rp);\n         ebml_w.end_tag();\n \n         *index += [{val: ctor_id, pos: ebml_w.writer.tell()}];\n@@ -732,7 +744,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                 encode_info_for_item(ecx, ebml_w, i, index, *pt);\n                 /* encode ctor, then encode items */\n                 alt i.node {\n-                  item_class(tps,_,_,ctor) {\n+                  item_class(tps, _, _, ctor, _) {\n                    /* this is assuming that ctors aren't inlined...\n                       probably shouldn't assume that */\n                    #debug(\"encoding info for ctor %s %d\", i.ident,"}, {"sha": "139840f5616eb90e8b63b599d97fc92c0dcb237e", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 68, "deletions": 16, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -182,6 +182,65 @@ fn parse_vstore(st: @pstate) -> ty::vstore {\n     st.tcx.sess.unimpl(\"tydecode::parse_vstore\");\n }\n \n+fn parse_substs(st: @pstate, conv: conv_did) -> ty::substs {\n+    let self_r = parse_opt(st) {|| parse_region(st) };\n+\n+    assert next(st) == '[';\n+    let mut params: [ty::t] = [];\n+    while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n+    st.pos = st.pos + 1u;\n+\n+    ret {self_r: self_r, tps: params};\n+}\n+\n+fn parse_bound_region(st: @pstate) -> ty::bound_region {\n+    alt check next(st) {\n+      's' { ty::br_self }\n+      'a' { ty::br_anon }\n+      '[' { ty::br_named(parse_str(st, ']')) }\n+    }\n+}\n+\n+fn parse_region(st: @pstate) -> ty::region {\n+    alt check next(st) {\n+      'b' {\n+        ty::re_bound(parse_bound_region(st))\n+      }\n+      'f' {\n+        assert next(st) == '[';\n+        let id = parse_int(st);\n+        assert next(st) == '|';\n+        let br = parse_bound_region(st);\n+        assert next(st) == ']';\n+        ty::re_free(id, br)\n+      }\n+      's' {\n+        let id = parse_int(st);\n+        assert next(st) == '|';\n+        ty::re_scope(id)\n+      }\n+      't' {\n+        ty::re_static\n+      }\n+    }\n+}\n+\n+fn parse_opt<T>(st: @pstate, f: fn() -> T) -> option<T> {\n+    alt check next(st) {\n+      'n' { none }\n+      's' { some(f()) }\n+    }\n+}\n+\n+fn parse_str(st: @pstate, term: char) -> str {\n+    let mut result = \"\";\n+    while peek(st) != term {\n+        result += str::from_byte(next_byte(st));\n+    }\n+    next(st);\n+    ret result;\n+}\n+\n fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n     alt check next(st) {\n       'n' { ret ty::mk_nil(st.tcx); }\n@@ -209,10 +268,9 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       't' {\n         assert (next(st) == '[');\n         let def = parse_def(st, conv);\n-        let mut params: [ty::t] = [];\n-        while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n-        st.pos = st.pos + 1u;\n-        ret ty::mk_enum(st.tcx, def, params);\n+        let substs = parse_substs(st, conv);\n+        assert next(st) == ']';\n+        ret ty::mk_enum(st.tcx, def, substs);\n       }\n       'x' {\n         assert (next(st) == '[');\n@@ -250,11 +308,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         assert (next(st) == '[');\n         let mut fields: [ty::field] = [];\n         while peek(st) != ']' {\n-            let mut name = \"\";\n-            while peek(st) != '=' {\n-                name += str::from_byte(next_byte(st));\n-            }\n-            st.pos = st.pos + 1u;\n+            let name = parse_str(st, '=');\n             fields += [{ident: name, mt: parse_mt(st, conv)}];\n         }\n         st.pos = st.pos + 1u;\n@@ -275,10 +329,9 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         assert (next(st) == '[');\n         let def = parse_def(st, conv);\n         let inner = parse_ty(st, conv);\n-        let mut params: [ty::t] = [];\n-        while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n-        st.pos = st.pos + 1u;\n-        ret ty::mk_res(st.tcx, def, inner, params);\n+        let substs = parse_substs(st, conv);\n+        assert next(st) == ']';\n+        ret ty::mk_res(st.tcx, def, inner, substs);\n       }\n       'X' {\n         ret ty::mk_var(st.tcx, ty::ty_vid(parse_int(st) as uint));\n@@ -326,10 +379,9 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n           #debug(\"saw a [\");\n           let did = parse_def(st, conv);\n           #debug(\"parsed a def_id %?\", did);\n-          let mut params: [ty::t] = [];\n-          while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n+          let substs = parse_substs(st, conv);\n           assert (next(st) == ']');\n-          ret ty::mk_class(st.tcx, did, params);\n+          ret ty::mk_class(st.tcx, did, substs);\n       }\n       c { #error(\"unexpected char in type string: %c\", c); fail;}\n     }"}, {"sha": "9c63337970cbb7db523df92a157efbc0963b21bb", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -100,18 +100,25 @@ fn enc_mt(w: io::writer, cx: @ctxt, mt: ty::mt) {\n     }\n     enc_ty(w, cx, mt.ty);\n }\n-fn enc_bound_region(w: io::writer, br: ty::bound_region) {\n-    alt br {\n-      ty::br_self { w.write_char('s') }\n-      ty::br_anon { w.write_char('a') }\n-      ty::br_named(s) {\n-        w.write_char('[');\n-        w.write_str(s);\n-        w.write_char(']')\n+\n+fn enc_opt<T>(w: io::writer, t: option<T>, enc_f: fn(T)) {\n+    alt t {\n+      none { w.write_char('n') }\n+      some(v) {\n+        w.write_char('s');\n+        enc_f(v);\n       }\n     }\n }\n-fn enc_region(w: io::writer, r: ty::region) {\n+\n+fn enc_substs(w: io::writer, cx: @ctxt, substs: ty::substs) {\n+    enc_opt(w, substs.self_r) { |r| enc_region(w, cx, r) }\n+    w.write_char('[');\n+    for substs.tps.each { |t| enc_ty(w, cx, t); }\n+    w.write_char(']');\n+}\n+\n+fn enc_region(w: io::writer, cx: @ctxt, r: ty::region) {\n     alt r {\n       ty::re_bound(br) {\n         w.write_char('b');\n@@ -130,18 +137,29 @@ fn enc_region(w: io::writer, r: ty::region) {\n         w.write_int(nid);\n         w.write_char('|');\n       }\n-      ty::re_var(id) {\n-        w.write_char('v');\n-        w.write_uint(id.to_uint());\n-        w.write_char('|');\n-      }\n       ty::re_static {\n         w.write_char('t');\n       }\n+      ty::re_var(_) {\n+        // these should not crop up after typeck\n+        cx.tcx.sess.bug(\"Cannot encode region variables\");\n+      }\n     }\n }\n \n-fn enc_vstore(w: io::writer, v: ty::vstore) {\n+fn enc_bound_region(w: io::writer, br: ty::bound_region) {\n+    alt br {\n+      ty::br_self { w.write_char('s') }\n+      ty::br_anon { w.write_char('a') }\n+      ty::br_named(s) {\n+        w.write_char('[');\n+        w.write_str(s);\n+        w.write_char(']')\n+      }\n+    }\n+}\n+\n+fn enc_vstore(w: io::writer, cx: @ctxt, v: ty::vstore) {\n     w.write_char('/');\n     alt v {\n       ty::vstore_fixed(u)  {\n@@ -156,7 +174,7 @@ fn enc_vstore(w: io::writer, v: ty::vstore) {\n       }\n       ty::vstore_slice(r) {\n         w.write_char('&');\n-        enc_region(w, r);\n+        enc_region(w, cx, r);\n       }\n     }\n }\n@@ -193,11 +211,11 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         }\n       }\n       ty::ty_str { w.write_char('S'); }\n-      ty::ty_enum(def, tys) {\n+      ty::ty_enum(def, substs) {\n         w.write_str(\"t[\");\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n-        for tys.each {|t| enc_ty(w, cx, t); }\n+        enc_substs(w, cx, substs);\n         w.write_char(']');\n       }\n       ty::ty_iface(def, tys) {\n@@ -217,17 +235,17 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       ty::ty_ptr(mt) { w.write_char('*'); enc_mt(w, cx, mt); }\n       ty::ty_rptr(r, mt) {\n         w.write_char('&');\n-        enc_region(w, r);\n+        enc_region(w, cx, r);\n         enc_mt(w, cx, mt);\n       }\n       ty::ty_evec(mt, v) {\n         w.write_char('V');\n         enc_mt(w, cx, mt);\n-        enc_vstore(w, v);\n+        enc_vstore(w, cx, v);\n       }\n       ty::ty_estr(v) {\n         w.write_char('v');\n-        enc_vstore(w, v);\n+        enc_vstore(w, cx, v);\n       }\n       ty::ty_vec(mt) { w.write_char('I'); enc_mt(w, cx, mt); }\n       ty::ty_rec(fields) {\n@@ -243,12 +261,12 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         enc_proto(w, f.proto);\n         enc_ty_fn(w, cx, f);\n       }\n-      ty::ty_res(def, ty, tps) {\n+      ty::ty_res(def, ty, substs) {\n         w.write_str(\"r[\");\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n         enc_ty(w, cx, ty);\n-        for tps.each {|t| enc_ty(w, cx, t); }\n+        enc_substs(w, cx, substs);\n         w.write_char(']');\n       }\n       ty::ty_var(id) {\n@@ -277,15 +295,15 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         w.write_char(']');\n       }\n       ty::ty_opaque_box { w.write_char('B'); }\n-      ty::ty_class(def, tys) {\n+      ty::ty_class(def, substs) {\n           #debug(\"~~~~ %s\", \"a[\");\n           w.write_str(\"a[\");\n           let s = cx.ds(def);\n           #debug(\"~~~~ %s\", s);\n           w.write_str(s);\n           #debug(\"~~~~ %s\", \"|\");\n           w.write_str(\"|\");\n-          for tys.each {|t| enc_ty(w, cx, t); }\n+          enc_substs(w, cx, substs);\n           #debug(\"~~~~ %s\", \"]\");\n           w.write_char(']');\n       }"}, {"sha": "de591b9cc4e5ffe7f7c18f09c9acb1658152ede2", "filename": "src/rustc/middle/alias.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Falias.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -503,7 +503,7 @@ fn ty_can_unsafely_include(cx: ctx, needle: unsafe_ty, haystack: ty::t,\n         } { ret true; }\n         alt ty::get(haystack).struct {\n           ty::ty_enum(_, ts) {\n-            for ts.each {|t|\n+            for ts.tps.each {|t|\n                 if helper(tcx, needle, t, mutbl) { ret true; }\n             }\n             ret false;\n@@ -565,10 +565,11 @@ fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n           ty::ty_fn(_) { 4u }\n           ty::ty_str | ty::ty_vec(_) | ty::ty_param(_, _) { 50u }\n           ty::ty_uniq(mt) { 1u + score_ty(tcx, mt.ty) }\n-          ty::ty_enum(_, ts) | ty::ty_tup(ts) {\n-            let mut sum = 0u;\n-            for ts.each {|t| sum += score_ty(tcx, t); }\n-            sum\n+          ty::ty_enum(_, substs) {\n+            substs.tps.foldl(0u) { |sum, t| sum + score_ty(tcx, t) }\n+          }\n+          ty::ty_tup(ts) {\n+            ts.foldl(0u) { |sum, t| sum + score_ty(tcx, t) }\n           }\n           ty::ty_rec(fs) {\n             let mut sum = 0u;"}, {"sha": "ab7a884eaeb494926c0d1dd7a8742b079abd5cf4", "filename": "src/rustc/middle/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fast_map.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -183,13 +183,13 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n             map_method(impl_did, extend(cx, i.ident), m, cx);\n         }\n       }\n-      item_res(decl, tps, _, dtor_id, ctor_id) {\n+      item_res(decl, tps, _, dtor_id, ctor_id, _) {\n         cx.map.insert(ctor_id, node_ctor(i.ident, tps,\n                                          res_ctor(decl, ctor_id, i.span),\n                                          item_path));\n         cx.map.insert(dtor_id, node_item(i, item_path));\n       }\n-      item_enum(vs, _) {\n+      item_enum(vs, _, _) {\n         for vs.each {|v|\n             cx.map.insert(v.node.id, node_variant(\n                 v, i, extend(cx, i.ident)));\n@@ -204,7 +204,7 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n             cx.map.insert(nitem.id, node_native_item(nitem, abi, @cx.path));\n         }\n       }\n-      item_class(_, _, items, ctor) {\n+      item_class(_, _, items, ctor, _) {\n           let d_id = ast_util::local_def(i.id);\n           let p = extend(cx, i.ident);\n           for items.each {|ci|"}, {"sha": "e73cb0fb5fcce694c50d44881b33f90a23d6bff2", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -22,7 +22,7 @@ fn check_item(sess: session, ast_map: ast_map::map, def_map: resolve::def_map,\n         v.visit_expr(ex, true, v);\n         check_item_recursion(sess, ast_map, def_map, it);\n       }\n-      item_enum(vs, _) {\n+      item_enum(vs, _, _) {\n         for vs.each {|var|\n             option::iter(var.node.disr_expr) {|ex|\n                 v.visit_expr(ex, true, v);"}, {"sha": "568fd830e40493246e8dcaa5fe8af2dc75e21067", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 67, "deletions": 8, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -538,11 +538,21 @@ impl unify_methods for infer_ctxt {\n         sub(self).tys(a, b).chain {|_t| ok(()) }\n     }\n \n+    fn sub_regions(a: ty::region, b: ty::region) -> ures {\n+        sub(self).regions(a, b).chain {|_t| ok(()) }\n+    }\n+\n     fn eq_tys(a: ty::t, b: ty::t) -> ures {\n         self.sub_tys(a, b).then {||\n             self.sub_tys(b, a)\n         }\n     }\n+\n+    fn eq_regions(a: ty::region, b: ty::region) -> ures {\n+        self.sub_regions(a, b).then {||\n+            self.sub_regions(b, a)\n+        }\n+    }\n }\n \n impl resolve_methods for infer_ctxt {\n@@ -905,6 +915,7 @@ iface combine {\n     fn contratys(a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tps(as: [ty::t], bs: [ty::t]) -> cres<[ty::t]>;\n+    fn substs(as: ty::substs, bs: ty::substs) -> cres<ty::substs>;\n     fn fns(a: ty::fn_ty, b: ty::fn_ty) -> cres<ty::fn_ty>;\n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field>;\n     fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode>;\n@@ -921,6 +932,41 @@ enum sub = infer_ctxt;  // \"subtype\", \"subregion\" etc\n enum lub = infer_ctxt;  // \"least upper bound\" (common supertype)\n enum glb = infer_ctxt;  // \"greatest lower bound\" (common subtype)\n \n+fn super_substs<C:combine>(\n+    self: C, a: ty::substs, b: ty::substs) -> cres<ty::substs> {\n+\n+    fn eq_opt_regions(infcx: infer_ctxt,\n+                      a: option<ty::region>,\n+                      b: option<ty::region>) -> cres<option<ty::region>> {\n+        alt (a, b) {\n+          (none, none) {\n+            ok(none)\n+          }\n+          (some(a), some(b)) {\n+            infcx.eq_regions(a, b);\n+            ok(some(a))\n+          }\n+          (_, _) {\n+            // If these two substitutions are for the same type (and\n+            // they should be), then the type should either\n+            // consistenly have a region parameter or not have a\n+            // region parameter.\n+            infcx.tcx.sess.bug(\n+                #fmt[\"substitution a had opt_region %s and \\\n+                      b had opt_region %s\",\n+                     a.to_str(infcx),\n+                     b.to_str(infcx)]);\n+          }\n+        }\n+    }\n+\n+    self.tps(a.tps, b.tps).chain { |tps|\n+        eq_opt_regions(self.infcx(), a.self_r, b.self_r).chain { |self_r|\n+            ok({self_r: self_r, tps: tps})\n+        }\n+    }\n+}\n+\n fn super_tps<C:combine>(\n     self: C, as: [ty::t], bs: [ty::t]) -> cres<[ty::t]> {\n \n@@ -1057,9 +1103,9 @@ fn super_tys<C:combine>(\n         ok(a)\n       }\n \n-      (ty::ty_enum(a_id, a_tps), ty::ty_enum(b_id, b_tps))\n+      (ty::ty_enum(a_id, a_substs), ty::ty_enum(b_id, b_substs))\n       if a_id == b_id {\n-        self.tps(a_tps, b_tps).chain {|tps|\n+        self.substs(a_substs, b_substs).chain {|tps|\n             ok(ty::mk_enum(tcx, a_id, tps))\n         }\n       }\n@@ -1071,10 +1117,10 @@ fn super_tys<C:combine>(\n         }\n       }\n \n-      (ty::ty_class(a_id, a_tps), ty::ty_class(b_id, b_tps))\n+      (ty::ty_class(a_id, a_substs), ty::ty_class(b_id, b_substs))\n       if a_id == b_id {\n-        self.tps(a_tps, b_tps).chain {|tps|\n-            ok(ty::mk_class(tcx, a_id, tps))\n+        self.substs(a_substs, b_substs).chain {|substs|\n+            ok(ty::mk_class(tcx, a_id, substs))\n         }\n       }\n \n@@ -1124,11 +1170,12 @@ fn super_tys<C:combine>(\n         }\n       }\n \n-      (ty::ty_res(a_id, a_t, a_tps), ty::ty_res(b_id, b_t, b_tps))\n+      (ty::ty_res(a_id, a_t, a_substs),\n+       ty::ty_res(b_id, b_t, b_substs))\n       if a_id == b_id {\n         self.tys(a_t, b_t).chain {|t|\n-            self.tps(a_tps, b_tps).chain {|tps|\n-                ok(ty::mk_res(tcx, a_id, t, tps))\n+            self.substs(a_substs, b_substs).chain {|substs|\n+                ok(ty::mk_res(tcx, a_id, t, substs))\n             }\n         }\n       }\n@@ -1299,6 +1346,10 @@ impl of combine for sub {\n         super_fns(self, a, b)\n     }\n \n+    fn substs(as: ty::substs, bs: ty::substs) -> cres<ty::substs> {\n+        super_substs(self, as, bs)\n+    }\n+\n     fn tps(as: [ty::t], bs: [ty::t]) -> cres<[ty::t]> {\n         super_tps(self, as, bs)\n     }\n@@ -1470,6 +1521,10 @@ impl of combine for lub {\n         super_fns(self, a, b)\n     }\n \n+    fn substs(as: ty::substs, bs: ty::substs) -> cres<ty::substs> {\n+        super_substs(self, as, bs)\n+    }\n+\n     fn tps(as: [ty::t], bs: [ty::t]) -> cres<[ty::t]> {\n         super_tps(self, as, bs)\n     }\n@@ -1656,6 +1711,10 @@ impl of combine for glb {\n         super_fns(self, a, b)\n     }\n \n+    fn substs(as: ty::substs, bs: ty::substs) -> cres<ty::substs> {\n+        super_substs(self, as, bs)\n+    }\n+\n     fn tps(as: [ty::t], bs: [ty::t]) -> cres<[ty::t]> {\n         super_tps(self, as, bs)\n     }"}, {"sha": "35561c56e65ec0ded7e3b99f041ac4ace1b44a00", "filename": "src/rustc/middle/mutbl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Fmutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Fmutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmutbl.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -30,18 +30,18 @@ fn expr_root_(tcx: ty::ctxt, ctor_self: option<node_id>,\n                          outer_t: t}];\n                 t = mt.ty;\n               }\n-              ty::ty_res(_, inner, tps) {\n+              ty::ty_res(_, inner, substs) {\n                 ds += [@{mutbl: false, kind: unbox(false), outer_t: t}];\n-                t = ty::substitute_type_params(tcx, tps, inner);\n+                t = ty::subst(tcx, substs, inner);\n               }\n-              ty::ty_enum(did, tps) {\n+              ty::ty_enum(did, substs) {\n                 let variants = ty::enum_variants(tcx, did);\n                 if vec::len(*variants) != 1u ||\n                        vec::len(variants[0].args) != 1u {\n                     break;\n                 }\n                 ds += [@{mutbl: false, kind: unbox(false), outer_t: t}];\n-                t = ty::substitute_type_params(tcx, tps, variants[0].args[0]);\n+                t = ty::subst(tcx, substs, variants[0].args[0]);\n               }\n               _ { break; }\n             }\n@@ -216,7 +216,7 @@ fn visit_expr(ex: @expr, &&cx: @ctx, v: visit::vt<@ctx>) {\n \n fn visit_item(item: @item, &&cx: @ctx, v: visit::vt<@ctx>) {\n     alt item.node {\n-      item_class(tps, _, items, ctor) {\n+      item_class(tps, _, items, ctor, _) {\n          v.visit_ty_params(tps, cx, v);\n          vec::map::<@class_member, ()>(items,\n              {|i| v.visit_class_item(i, cx, v); });"}, {"sha": "53c52cf9fc2769d2740db95e1b026894186bc9a3", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 9, "deletions": 110, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -143,16 +143,7 @@ import std::list::list;\n import std::map;\n import std::map::hashmap;\n \n-/* Represents the type of the most immediate parent node. */\n-enum parent {\n-    pa_fn_item(ast::node_id),\n-    pa_block(ast::node_id),\n-    pa_nested_fn(ast::node_id),\n-    pa_item(ast::node_id),\n-    pa_call(ast::node_id),\n-    pa_alt(ast::node_id),\n-    pa_crate\n-}\n+type parent = option<ast::node_id>;\n \n /* Records the parameter ID of a region name. */\n type binding = {node_id: ast::node_id,\n@@ -167,43 +158,11 @@ type region_map = {\n     local_blocks: hashmap<ast::node_id,ast::node_id>\n };\n \n-type region_scope = @{\n-    node_id: ast::node_id,\n-    kind: region_scope_kind\n-};\n-\n-enum region_scope_kind {\n-    rsk_root,\n-    rsk_body(region_scope),\n-    rsk_self(region_scope),\n-    rsk_binding(region_scope, @mut [binding])\n-}\n-\n-fn root_scope(node_id: ast::node_id) -> region_scope {\n-    @{node_id: node_id, kind: rsk_root}\n-}\n-\n-impl methods for region_scope {\n-    fn body_subscope(node_id: ast::node_id) -> region_scope {\n-        @{node_id: node_id, kind: rsk_body(self)}\n-    }\n-\n-    fn binding_subscope(node_id: ast::node_id) -> region_scope {\n-        @{node_id: node_id, kind: rsk_binding(self, @mut [])}\n-    }\n-\n-    fn self_subscope(node_id: ast::node_id) -> region_scope {\n-        @{node_id: node_id, kind: rsk_self(self)}\n-    }\n-}\n-\n type ctxt = {\n     sess: session,\n     def_map: resolve::def_map,\n     region_map: @region_map,\n \n-    scope: region_scope,\n-\n     parent: parent\n };\n \n@@ -269,40 +228,8 @@ fn nearest_common_ancestor(region_map: @region_map, scope_a: ast::node_id,\n     }\n }\n \n-fn get_inferred_region(cx: ctxt, sp: syntax::codemap::span) -> ty::region {\n-    // We infer to the caller region if we're at item scope\n-    // and to the block region if we're at block scope.\n-    //\n-    // TODO: What do we do if we're in an alt?\n-\n-    ret alt cx.parent {\n-      pa_fn_item(_) | pa_nested_fn(_) { ty::re_bound(ty::br_anon) }\n-      pa_block(node_id) | pa_call(node_id) | pa_alt(node_id) {\n-        ty::re_scope(node_id)\n-      }\n-      pa_item(_) { ty::re_bound(ty::br_anon) }\n-      pa_crate { cx.sess.span_bug(sp, \"inferred region at crate level?!\"); }\n-    }\n-}\n-\n-fn opt_parent_id(cx: ctxt) -> option<ast::node_id> {\n-    alt cx.parent {\n-      pa_fn_item(parent_id) |\n-      pa_item(parent_id) |\n-      pa_block(parent_id) |\n-      pa_alt(parent_id) |\n-      pa_call(parent_id) |\n-      pa_nested_fn(parent_id) {\n-        some(parent_id)\n-      }\n-      pa_crate {\n-        none\n-      }\n-    }\n-}\n-\n fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n-    alt opt_parent_id(cx) {\n+    alt cx.parent {\n       none {\n         cx.sess.span_bug(span, \"crate should not be parent here\");\n       }\n@@ -313,7 +240,7 @@ fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n }\n \n fn record_parent(cx: ctxt, child_id: ast::node_id) {\n-    alt opt_parent_id(cx) {\n+    alt cx.parent {\n       none { /* no-op */ }\n       some(parent_id) {\n         cx.region_map.parents.insert(child_id, parent_id);\n@@ -326,8 +253,7 @@ fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n     record_parent(cx, blk.node.id);\n \n     // Descend.\n-    let new_cx: ctxt = {parent: pa_block(blk.node.id),\n-                        scope: cx.scope.body_subscope(blk.node.id)\n+    let new_cx: ctxt = {parent: some(blk.node.id)\n                         with cx};\n     visit::visit_block(blk, new_cx, visitor);\n }\n@@ -361,21 +287,15 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n     record_parent(cx, expr.id);\n     alt expr.node {\n       ast::expr_fn(_, _, _, _) | ast::expr_fn_block(_, _) {\n-        let new_cx = {parent: pa_nested_fn(expr.id),\n-                      scope: cx.scope.binding_subscope(expr.id)\n-                      with cx};\n+        let new_cx = {parent: some(expr.id) with cx};\n         visit::visit_expr(expr, new_cx, visitor);\n       }\n       ast::expr_call(_, _, _) {\n-        let new_cx = {parent: pa_call(expr.id),\n-                      scope: cx.scope.binding_subscope(expr.id)\n-                      with cx};\n+        let new_cx = {parent: some(expr.id) with cx};\n         visit::visit_expr(expr, new_cx, visitor);\n       }\n       ast::expr_alt(subexpr, _, _) {\n-        let new_cx = {parent: pa_alt(expr.id),\n-                      scope: cx.scope.binding_subscope(expr.id)\n-                      with cx};\n+        let new_cx = {parent: some(expr.id) with cx};\n         visit::visit_expr(expr, new_cx, visitor);\n       }\n       _ {\n@@ -392,27 +312,7 @@ fn resolve_local(local: @ast::local, cx: ctxt, visitor: visit::vt<ctxt>) {\n \n fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n     // Items create a new outer block scope as far as we're concerned.\n-    let {parent, scope} = {\n-        alt item.node {\n-          ast::item_fn(_, _, _) | ast::item_enum(_, _) {\n-            {parent: pa_fn_item(item.id),\n-             scope: cx.scope.binding_subscope(item.id)}\n-          }\n-          ast::item_impl(_, _, _, _) | ast::item_class(_, _, _, _) {\n-            {parent: pa_item(item.id),\n-             scope: cx.scope.self_subscope(item.id)}\n-          }\n-          _ {\n-            {parent: pa_item(item.id),\n-             scope: root_scope(item.id)}\n-          }\n-        }\n-    };\n-\n-    let new_cx: ctxt = {parent: parent,\n-                        scope: scope\n-                        with cx};\n-\n+    let new_cx: ctxt = {parent: some(item.id) with cx};\n     visit::visit_item(item, new_cx, visitor);\n }\n \n@@ -422,8 +322,7 @@ fn resolve_crate(sess: session, def_map: resolve::def_map, crate: @ast::crate)\n                     def_map: def_map,\n                     region_map: @{parents: map::int_hash(),\n                                   local_blocks: map::int_hash()},\n-                    scope: root_scope(0),\n-                    parent: pa_crate};\n+                    parent: none};\n     let visitor = visit::mk_vt(@{\n         visit_block: resolve_block,\n         visit_item: resolve_item,"}, {"sha": "4fff72fcc8bb3cae8bc4d8973c55ac8fc717f926", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -434,7 +434,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           non-class items\n          */\n         alt i.node {\n-           ast::item_class(_, ifaces, _, _) {\n+           ast::item_class(_, ifaces, _, _, _) {\n              /* visit the iface paths... */\n              for ifaces.each {|p|\n                maybe_insert(e, p.id,\n@@ -559,7 +559,7 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n             v.visit_ty(m.decl.output, msc, v);\n         }\n       }\n-      ast::item_class(tps, ifaces, members, ctor) {\n+      ast::item_class(tps, ifaces, members, ctor, _) {\n         visit::visit_ty_params(tps, sc, v);\n         // Can maybe skip this now that we require self on class fields\n         let class_scope = cons(scope_item(i), @sc);\n@@ -613,7 +613,7 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n     // for f's constrs in the table.\n     for decl.constraints.each {|c| resolve_constr(e, c, sc, v); }\n     let scope = alt fk {\n-      visit::fk_item_fn(_, tps) | visit::fk_res(_, tps) |\n+      visit::fk_item_fn(_, tps) | visit::fk_res(_, tps, _) |\n       visit::fk_method(_, tps, _) | visit::fk_ctor(_, tps, _, _)\n          { scope_bare_fn(decl, id, tps) }\n       visit::fk_anon(ast::proto_bare) { scope_bare_fn(decl, id, []) }\n@@ -1019,7 +1019,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace,\n               ast::item_impl(tps, _, _, _) {\n                 if ns == ns_type { ret lookup_in_ty_params(e, name, tps); }\n               }\n-              ast::item_enum(_, tps) | ast::item_ty(_, tps) {\n+              ast::item_enum(_, tps, _) | ast::item_ty(_, tps, _) {\n                 if ns == ns_type { ret lookup_in_ty_params(e, name, tps); }\n               }\n               ast::item_iface(tps, _) {\n@@ -1036,7 +1036,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace,\n               ast::item_native_mod(m) {\n                 ret lookup_in_local_native_mod(e, it.id, sp, name, ns);\n               }\n-              ast::item_class(tps, _, members, ctor) {\n+              ast::item_class(tps, _, members, ctor, _) {\n                   if ns == ns_type {\n                     ret lookup_in_ty_params(e, name, tps);\n                   }\n@@ -1210,7 +1210,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n               }\n               ast::decl_item(it) {\n                 alt it.node {\n-                  ast::item_enum(variants, _) {\n+                  ast::item_enum(variants, _, _) {\n                     if ns == ns_type {\n                         if str::eq(it.ident, name) {\n                             ret some(ast::def_ty(local_def(it.id)));\n@@ -1309,10 +1309,10 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n       ast::item_native_mod(_) {\n         if ns == ns_module { ret some(ast::def_native_mod(local_def(i.id))); }\n       }\n-      ast::item_ty(_, _) | item_iface(_, _) | item_enum(_, _) {\n+      ast::item_ty(_, _, _) | item_iface(_, _) | item_enum(_, _, _) {\n         if ns == ns_type { ret some(ast::def_ty(local_def(i.id))); }\n       }\n-      ast::item_res(_, _, _, _, ctor_id) {\n+      ast::item_res(_, _, _, _, ctor_id, _) {\n         alt ns {\n           ns_val {\n             ret some(ast::def_fn(local_def(ctor_id), ast::impure_fn));\n@@ -1321,7 +1321,7 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n           _ { }\n         }\n       }\n-      ast::item_class(_, _, _, _) {\n+      ast::item_class(_, _, _, _, _) {\n           if ns == ns_type {\n             ret some(ast::def_class(local_def(i.id)));\n           }\n@@ -1614,12 +1614,12 @@ fn index_mod(md: ast::_mod) -> mod_index {\n     for md.items.each {|it|\n         alt it.node {\n           ast::item_const(_, _) | ast::item_fn(_, _, _) | ast::item_mod(_) |\n-          ast::item_native_mod(_) | ast::item_ty(_, _) |\n-          ast::item_res(_, _, _, _, _) |\n+          ast::item_native_mod(_) | ast::item_ty(_, _, _) |\n+          ast::item_res(_, _, _, _, _, _) |\n           ast::item_impl(_, _, _, _) | ast::item_iface(_, _) {\n             add_to_index(index, it.ident, mie_item(it));\n           }\n-          ast::item_enum(variants, _) {\n+          ast::item_enum(variants, _, _) {\n             add_to_index(index, it.ident, mie_item(it));\n             let mut variant_idx: uint = 0u;\n             for variants.each {|v|\n@@ -1629,7 +1629,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n                 variant_idx += 1u;\n             }\n           }\n-          ast::item_class(tps, _, items, ctor) {\n+          ast::item_class(tps, _, items, ctor, _) {\n               // add the class name itself\n               add_to_index(index, it.ident, mie_item(it));\n               // add the constructor decl\n@@ -1763,7 +1763,7 @@ fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n         ensure_unique(*e, i.span, ty_params, {|tp| tp.ident},\n                       \"type parameter\");\n       }\n-      ast::item_enum(_, ty_params) {\n+      ast::item_enum(_, ty_params, _) {\n         ensure_unique(*e, i.span, ty_params, {|tp| tp.ident},\n                       \"type parameter\");\n       }\n@@ -1837,7 +1837,7 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n               }\n               ast::decl_item(it) {\n                 alt it.node {\n-                  ast::item_enum(variants, _) {\n+                  ast::item_enum(variants, _, _) {\n                     add_name(types, it.span, it.ident);\n                     for variants.each {|v|\n                         add_name(values, v.span, v.node.name);\n@@ -1849,10 +1849,10 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n                   ast::item_const(_, _) | ast::item_fn(_, _, _) {\n                     add_name(values, it.span, it.ident);\n                   }\n-                  ast::item_ty(_, _) | ast::item_iface(_, _) {\n+                  ast::item_ty(_, _, _) | ast::item_iface(_, _) {\n                     add_name(types, it.span, it.ident);\n                   }\n-                  ast::item_res(_, _, _, _, _) {\n+                  ast::item_res(_, _, _, _, _, _) {\n                     add_name(types, it.span, it.ident);\n                     add_name(values, it.span, it.ident);\n                   }\n@@ -2030,7 +2030,7 @@ fn check_exports(e: @env) {\n           some(ms) {\n             let maybe_id = list_search(ms) {|m|\n                 alt m {\n-                  mie_item(@{node: item_enum(_, _), id, _}) { some(id) }\n+                  mie_item(@{node: item_enum(_, _, _), id, _}) { some(id) }\n                   _ { none }\n                 }\n             };"}, {"sha": "71aa0c0e9cc565cd818bdda44a38a8dd7321b8dd", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -263,26 +263,23 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     let _icx = bcx.insn_ctxt(\"alt::extract_variant_args\");\n     let ccx = bcx.fcx.ccx;\n     let enum_ty_substs = alt check ty::get(node_id_type(bcx, pat_id)).struct {\n-      ty::ty_enum(id, tps) { assert id == vdefs.enm; tps }\n+      ty::ty_enum(id, substs) { assert id == vdefs.enm; substs.tps }\n     };\n     let mut blobptr = val;\n     let variants = ty::enum_variants(ccx.tcx, vdefs.enm);\n-    let mut args = [];\n     let size = ty::enum_variant_with_id(ccx.tcx, vdefs.enm,\n                                         vdefs.var).args.len();\n     if size > 0u && (*variants).len() != 1u {\n         let enumptr =\n             PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n         blobptr = GEPi(bcx, enumptr, [0, 1]);\n     }\n-    let mut i = 0u;\n     let vdefs_tg = vdefs.enm;\n     let vdefs_var = vdefs.var;\n-    while i < size {\n-        args += [GEP_enum(bcx, blobptr, vdefs_tg, vdefs_var,\n-                          enum_ty_substs, i)];\n-        i += 1u;\n-    }\n+    let args = vec::from_fn(size) { |i|\n+        GEP_enum(bcx, blobptr, vdefs_tg, vdefs_var,\n+                 enum_ty_substs, i)\n+    };\n     ret {vals: args, bcx: bcx};\n }\n "}, {"sha": "6052418640429cd3b08585e78fbb3f698e7f367a", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 41, "deletions": 34, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -297,7 +297,7 @@ fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n     assert ix < variant.args.len();\n \n     let arg_lltys = vec::map(variant.args, {|aty|\n-        type_of(ccx, ty::substitute_type_params(ccx.tcx, ty_substs, aty))\n+        type_of(ccx, ty::subst_tps(ccx.tcx, ty_substs, aty))\n     });\n     let typed_blobptr = PointerCast(bcx, llblobptr,\n                                     T_ptr(T_struct(arg_lltys)));\n@@ -686,8 +686,8 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) {\n         free_ty(bcx, Load(bcx, v0), t)\n       }\n-      ty::ty_res(did, inner, tps) {\n-        trans_res_drop(bcx, v0, did, inner, tps)\n+      ty::ty_res(did, inner, substs) {\n+        trans_res_drop(bcx, v0, did, inner, substs.tps)\n       }\n       ty::ty_fn(_) {\n         closure::make_fn_glue(bcx, v0, t, drop_ty)\n@@ -735,7 +735,7 @@ fn trans_res_drop(bcx: block, rs: ValueRef, did: ast::def_id,\n                   inner_t: ty::t, tps: [ty::t]) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_res_drop\");\n     let ccx = bcx.ccx();\n-    let inner_t_s = ty::substitute_type_params(ccx.tcx, tps, inner_t);\n+    let inner_t_s = ty::subst_tps(ccx.tcx, tps, inner_t);\n \n     let drop_flag = GEPi(bcx, rs, [0, 0]);\n     with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) {|bcx|\n@@ -911,7 +911,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n             let v_id = variant.id;\n             for vec::each(args) {|a|\n                 let llfldp_a = GEP_enum(cx, a_tup, tid, v_id, tps, j);\n-                let ty_subst = ty::substitute_type_params(ccx.tcx, tps, a.ty);\n+                let ty_subst = ty::subst_tps(ccx.tcx, tps, a.ty);\n                 cx = f(cx, llfldp_a, ty_subst);\n                 j += 1u;\n             }\n@@ -943,19 +943,20 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n             cx = f(cx, llfld_a, arg);\n         }\n       }\n-      ty::ty_res(_, inner, tps) {\n+      ty::ty_res(_, inner, substs) {\n         let tcx = cx.tcx();\n-        let inner1 = ty::substitute_type_params(tcx, tps, inner);\n+        let inner1 = ty::subst(tcx, substs, inner);\n         let llfld_a = GEPi(cx, av, [0, 1]);\n         ret f(cx, llfld_a, inner1);\n       }\n-      ty::ty_enum(tid, tps) {\n+      ty::ty_enum(tid, substs) {\n         let variants = ty::enum_variants(cx.tcx(), tid);\n         let n_variants = (*variants).len();\n \n         // Cast the enums to types we can GEP into.\n         if n_variants == 1u {\n-            ret iter_variant(cx, av, variants[0], tps, tid, f);\n+            ret iter_variant(cx, av, variants[0],\n+                             substs.tps, tid, f);\n         }\n \n         let ccx = cx.ccx();\n@@ -979,15 +980,16 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                                        int::to_str(variant.disr_val, 10u));\n             AddCase(llswitch, C_int(ccx, variant.disr_val), variant_cx.llbb);\n             let variant_cx =\n-                iter_variant(variant_cx, llunion_a_ptr, variant, tps, tid, f);\n+                iter_variant(variant_cx, llunion_a_ptr, variant,\n+                             substs.tps, tid, f);\n             Br(variant_cx, next_cx.llbb);\n         }\n         ret next_cx;\n       }\n-      ty::ty_class(did, tps) {\n+      ty::ty_class(did, substs) {\n           // a class is like a record type\n         let mut i: int = 0;\n-        for vec::each(ty::class_items_as_fields(cx.tcx(), did, tps)) {|fld|\n+        for vec::each(ty::class_items_as_fields(cx.tcx(), did, substs)) {|fld|\n             let llfld_a = GEPi(cx, av, [0, i]);\n             cx = f(cx, llfld_a, fld.mt.ty);\n             i += 1;\n@@ -1617,17 +1619,17 @@ fn autoderef(cx: block, v: ValueRef, t: ty::t) -> result_t {\n             t1 = mt.ty;\n             v1 = v;\n           }\n-          ty::ty_res(did, inner, tps) {\n-            t1 = ty::substitute_type_params(ccx.tcx, tps, inner);\n+          ty::ty_res(did, inner, substs) {\n+            t1 = ty::subst(ccx.tcx, substs, inner);\n             v1 = GEPi(cx, v1, [0, 1]);\n           }\n-          ty::ty_enum(did, tps) {\n+          ty::ty_enum(did, substs) {\n             let variants = ty::enum_variants(ccx.tcx, did);\n             if (*variants).len() != 1u || variants[0].args.len() != 1u {\n                 break;\n             }\n             t1 =\n-                ty::substitute_type_params(ccx.tcx, tps, variants[0].args[0]);\n+                ty::subst(ccx.tcx, substs, variants[0].args[0]);\n             v1 = PointerCast(cx, v1, T_ptr(type_of(ccx, t1)));\n           }\n           _ { break; }\n@@ -1939,7 +1941,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n     let (pt, name) = alt map_node {\n       ast_map::node_item(i, pt) {\n         alt i.node {\n-          ast::item_res(_, _, _, dtor_id, _) {\n+          ast::item_res(_, _, _, dtor_id, _, _) {\n             item_ty = ty::node_id_to_type(ccx.tcx, dtor_id);\n           }\n           _ {}\n@@ -1958,7 +1960,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n       ast_map::node_ctor(nm, _, _, pt) { (pt, nm) }\n       _ { fail \"unexpected node type\"; }\n     };\n-    let mono_ty = ty::substitute_type_params(ccx.tcx, substs, item_ty);\n+    let mono_ty = ty::subst_tps(ccx.tcx, substs, item_ty);\n     let llfty = type_of_fn_from_ty(ccx, mono_ty);\n \n     let pt = *pt + [path_name(ccx.names(name))];\n@@ -1972,7 +1974,8 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n         set_inline_hint_if_appr(i.attrs, lldecl);\n         trans_fn(ccx, pt, decl, body, lldecl, no_self, psubsts, fn_id.node);\n       }\n-      ast_map::node_item(@{node: ast::item_res(d, _, body, d_id, _), _}, _) {\n+      ast_map::node_item(\n+          @{node: ast::item_res(d, _, body, d_id, _, _), _}, _) {\n         trans_fn(ccx, pt, d, body, lldecl, no_self, psubsts, d_id);\n       }\n       ast_map::node_native_item(i, _, _) {\n@@ -1990,7 +1993,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n       ast_map::node_method(mth, impl_def_id, _) {\n         set_inline_hint_if_appr(mth.attrs, lldecl);\n         let selfty = ty::node_id_to_type(ccx.tcx, mth.self_id);\n-        let selfty = ty::substitute_type_params(ccx.tcx, substs, selfty);\n+        let selfty = ty::subst_tps(ccx.tcx, substs, selfty);\n         trans_fn(ccx, pt, mth.decl, mth.body, lldecl,\n                  impl_self(selfty), psubsts, fn_id.node);\n       }\n@@ -2048,22 +2051,24 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n             ccx.external.insert(parent_id, some(item.id));\n             let mut my_id = 0;\n             alt check item.node {\n-              ast::item_enum(_, _) {\n+              ast::item_enum(_, _, _) {\n                 let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n                 let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n                 vec::iter2(*vs_here, *vs_there) {|here, there|\n                     if there.id == fn_id { my_id = here.id.node; }\n                     ccx.external.insert(there.id, some(here.id.node));\n                 }\n               }\n-              ast::item_res(_, _, _, _, ctor_id) { my_id = ctor_id; }\n+              ast::item_res(_, _, _, _, ctor_id, _) {\n+                my_id = ctor_id;\n+              }\n             }\n             trans_item(ccx, *item);\n             local_def(my_id)\n           }\n           csearch::found(ast::ii_method(impl_did, mth)) {\n             ccx.external.insert(fn_id, some(mth.id));\n-            let {bounds: impl_bnds, ty: impl_ty} =\n+            let {bounds: impl_bnds, rp: _, ty: impl_ty} =\n                 ty::lookup_item_type(ccx.tcx, impl_did);\n             if (*impl_bnds).len() + mth.tps.len() == 0u {\n                 let llfn = get_item_val(ccx, mth.id);\n@@ -2264,8 +2269,8 @@ fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n                          field: ast::ident, sp: span) -> lval_result {\n     let fields = alt ty::get(ty).struct {\n             ty::ty_rec(fs) { fs }\n-            ty::ty_class(did,ts) {\n-                ty::class_items_as_fields(bcx.tcx(), did, ts) }\n+            ty::ty_class(did, substs) {\n+                ty::class_items_as_fields(bcx.tcx(), did, substs) }\n             // Constraint?\n             _ { bcx.tcx().sess.span_bug(sp, \"trans_rec_field:\\\n                  base expr has non-record type\"); }\n@@ -4379,7 +4384,9 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n   // kludgy -- this wouldn't be necessary if the typechecker\n   // special-cased constructors, then we could just look up\n   // the ctor's return type.\n-  let rslt_ty =  ty::mk_class(ccx.tcx, parent_id, psubsts.tys);\n+  let rslt_ty =  ty::mk_class(ccx.tcx, parent_id,\n+                              dummy_substs(psubsts.tys));\n+\n   // Make the fn context\n   let fcx = new_fn_ctxt_w_id(ccx, path, llctor_decl, ctor_id,\n                                    some(psubsts), some(sp));\n@@ -4397,7 +4404,7 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n   let selfptr = alloc_ty(bcx_top, rslt_ty);\n   // initialize fields to zero\n   let fields = ty::class_items_as_fields(bcx_top.tcx(), parent_id,\n-                                         psubsts.tys);\n+                                         dummy_substs(psubsts.tys));\n   let mut bcx = bcx_top;\n   // Initialize fields to zero so init assignments can validly\n   // drop their LHS\n@@ -4450,7 +4457,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n       ast::item_impl(tps, _, _, ms) {\n         impl::trans_impl(ccx, *path, item.ident, ms, tps);\n       }\n-      ast::item_res(decl, tps, body, dtor_id, ctor_id) {\n+      ast::item_res(decl, tps, body, dtor_id, ctor_id, _) {\n         if tps.len() == 0u {\n             let llctor_decl = get_item_val(ccx, ctor_id);\n             trans_res_ctor(ccx, *path, decl, ctor_id, none, llctor_decl);\n@@ -4463,7 +4470,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n       ast::item_mod(m) {\n         trans_mod(ccx, m);\n       }\n-      ast::item_enum(variants, tps) {\n+      ast::item_enum(variants, tps, _) {\n         if tps.len() == 0u {\n             let degen = variants.len() == 1u;\n             let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n@@ -4487,15 +4494,15 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         };\n         native::trans_native_mod(ccx, native_mod, abi);\n       }\n-      ast::item_class(tps, _ifaces, items, ctor) {\n+      ast::item_class(tps, _ifaces, items, ctor, _) {\n         if tps.len() == 0u {\n           let psubsts = {tys: ty::ty_params_to_tys(ccx.tcx, tps),\n                          // FIXME: vtables have to get filled in depending\n                          // on ifaces\n                          vtables: none,\n                          bounds: @[]};\n           trans_class_ctor(ccx, *path, ctor.node.dec, ctor.node.body,\n-                         get_item_val(ccx, ctor.node.id), psubsts,\n+                           get_item_val(ccx, ctor.node.id), psubsts,\n                            ctor.node.id, local_def(item.id), ctor.span);\n         }\n         // If there are ty params, the ctor will get monomorphized\n@@ -4684,7 +4691,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                 set_inline_hint_if_appr(i.attrs, llfn);\n                 llfn\n               }\n-              ast::item_res(_, _, _, dtor_id, _) {\n+              ast::item_res(_, _, _, dtor_id, _, _) {\n                 // Note that the destructor is associated with the item's id,\n                 // not the dtor_id. This is a bit counter-intuitive, but\n                 // simplifies ty_res, which would have to carry around two\n@@ -4726,7 +4733,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n             assert v.node.args.len() != 0u;\n             let pth = *pth + [path_name(enm.ident), path_name(v.node.name)];\n             let llfn = alt check enm.node {\n-              ast::item_enum(_, _) {\n+              ast::item_enum(_, _, _) {\n                 register_fn(ccx, v.span, pth, id)\n               }\n             };\n@@ -4747,7 +4754,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_constant\");\n     alt it.node {\n-      ast::item_enum(variants, _) {\n+      ast::item_enum(variants, _, _) {\n         let vi = ty::enum_variants(ccx.tcx, {crate: ast::local_crate,\n                                              node: it.id});\n         let mut i = 0;"}, {"sha": "2cdea6ce8ebdf5c07477aa17fbf48e189f3fbf93", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -882,7 +882,7 @@ fn node_id_type(bcx: block, id: ast::node_id) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n     alt bcx.fcx.param_substs {\n-      some(substs) { ty::substitute_type_params(tcx, substs.tys, t) }\n+      some(substs) { ty::subst_tps(tcx, substs.tys, t) }\n       _ { assert !ty::type_has_params(t); t }\n     }\n }\n@@ -894,7 +894,7 @@ fn node_id_type_params(bcx: block, id: ast::node_id) -> [ty::t] {\n     let params = ty::node_id_to_type_params(tcx, id);\n     alt bcx.fcx.param_substs {\n       some(substs) {\n-        vec::map(params) {|t| ty::substitute_type_params(tcx, substs.tys, t) }\n+        vec::map(params) {|t| ty::subst_tps(tcx, substs.tys, t) }\n       }\n       _ { params }\n     }\n@@ -910,6 +910,10 @@ fn field_idx_strict(cx: ty::ctxt, sp: span, ident: ast::ident,\n         }\n }\n \n+fn dummy_substs(tps: [ty::t]) -> ty::substs {\n+    {self_r: some(ty::re_bound(ty::br_self)), tps: tps}\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "ce71a568c629470099a2924964fbce161812e8c5", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -747,7 +747,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let (ident, ret_ty, id) = alt cx.tcx.items.get(fcx.id) {\n       ast_map::node_item(item, _) {\n         alt item.node {\n-          ast::item_fn(decl, _, _) | ast::item_res(decl, _, _, _, _) {\n+          ast::item_fn(decl, _, _) | ast::item_res(decl, _, _, _, _, _) {\n             (item.ident, decl.output, item.id)\n           }\n           _ { fcx.ccx.sess.span_bug(item.span, \"create_function: item \\"}, {"sha": "fe545a9a4fd92e4094faa64c88c85346fec3554b", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -178,7 +178,7 @@ fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n         let tys = alt fcx.param_substs {\n           some(substs) {\n             vec::map(tys, {|t|\n-                ty::substitute_type_params(fcx.ccx.tcx, substs.tys, t)\n+                ty::subst_tps(fcx.ccx.tcx, substs.tys, t)\n             })\n           }\n           _ { tys }\n@@ -244,7 +244,7 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: [ty::t],\n     let ifce_id = ty::ty_to_def_id(option::get(ty::impl_iface(tcx, impl_id)));\n     let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;\n     make_vtable(ccx, vec::map(*ty::iface_methods(tcx, ifce_id), {|im|\n-        let fty = ty::substitute_type_params(tcx, substs,\n+        let fty = ty::subst_tps(tcx, substs,\n                                              ty::mk_fn(tcx, im.fty));\n         if (*im.tps).len() > 0u || ty::type_has_vars(fty) {\n             C_null(T_ptr(T_nil()))"}, {"sha": "05cc22243844f889724adca49f71684129dbf57e", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -84,7 +84,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n               for vec::each(nm.items) {|item| cx.rmap.insert(item.id, ()); }\n           }\n       }\n-      item_res(_, tps, blk, _, _) {\n+      item_res(_, tps, blk, _, _, _) {\n         // resources seem to be unconditionally inlined\n         traverse_inline_body(cx, blk);\n       }\n@@ -102,7 +102,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n             }\n         }\n       }\n-      item_class(tps, _ifaces, items, ctor) {\n+      item_class(tps, _ifaces, items, ctor, _) {\n         cx.rmap.insert(ctor.node.id, ());\n         for vec::each(items) {|item|\n             alt item.node {\n@@ -117,7 +117,8 @@ fn traverse_public_item(cx: ctx, item: @item) {\n             }\n         }\n       }\n-      item_const(_, _) | item_ty(_, _) | item_enum(_, _) | item_iface(_, _) {}\n+      item_const(_, _) | item_ty(_, _, _) |\n+      item_enum(_, _, _) | item_iface(_, _) {}\n     }\n }\n \n@@ -152,7 +153,9 @@ fn traverse_all_resources(cx: ctx, crate_mod: _mod) {\n         visit_item: {|i, cx, v|\n             visit::visit_item(i, cx, v);\n             alt i.node {\n-              item_res(_, _, _, _, _) { traverse_public_item(cx, i); }\n+              item_res(_, _, _, _, _, _) {\n+                traverse_public_item(cx, i);\n+              }\n               _ {}\n             }\n         }"}, {"sha": "effb71c0c8c4f056594117e518efa1874f9f4f6e", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -315,7 +315,9 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         add_substr(s, shape_of(ccx, unit_ty, ty_param_map));\n         s\n       }\n-      ty::ty_enum(did, tps) {\n+      ty::ty_enum(did, substs) {\n+        let tps = substs.tps;\n+\n         alt enum_kind(ccx, did) {\n           // FIXME: For now we do this.\n           tk_unit { [s_variant_enum_t(ccx.tcx)] }\n@@ -437,8 +439,9 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         add_substr(s, shape_of(ccx, tm.ty, ty_param_map));\n         s\n       }\n-      ty::ty_res(did, raw_subt, tps) {\n-        let subt = ty::substitute_type_params(ccx.tcx, tps, raw_subt);\n+      ty::ty_res(did, raw_subt, substs) {\n+        let subt = ty::subst(ccx.tcx, substs, raw_subt);\n+        let tps = substs.tps;\n         let ri = {did: did, tps: tps};\n         let id = interner::intern(ccx.shape_cx.resources, ri);\n \n@@ -651,15 +654,15 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n     if cx.enum_sizes.contains_key(t) { ret cx.enum_sizes.get(t); }\n     alt ty::get(t).struct {\n-      ty::ty_enum(tid, subtys) {\n+      ty::ty_enum(tid, substs) {\n         // Compute max(variant sizes).\n         let mut max_size = 0u;\n         let variants = ty::enum_variants(cx.tcx, tid);\n         for vec::each(*variants) {|variant|\n             let tup_ty = simplify_type(cx.tcx,\n                                        ty::mk_tup(cx.tcx, variant.args));\n             // Perform any type parameter substitutions.\n-            let tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n+            let tup_ty = ty::subst(cx.tcx, substs, tup_ty);\n             // Here we possibly do a recursive call.\n             let this_size =\n                 llsize_of_real(cx, type_of::type_of(cx, tup_ty));\n@@ -690,8 +693,8 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n           ty::ty_estr(ty::vstore_uniq) | ty::ty_estr(ty::vstore_box) |\n           ty::ty_ptr(_) | ty::ty_rptr(_,_) { nilptr(tcx) }\n           ty::ty_fn(_) { ty::mk_tup(tcx, [nilptr(tcx), nilptr(tcx)]) }\n-          ty::ty_res(_, sub, tps) {\n-            let sub1 = ty::substitute_type_params(tcx, tps, sub);\n+          ty::ty_res(_, sub, substs) {\n+            let sub1 = ty::subst(tcx, substs, sub);\n             ty::mk_tup(tcx, [ty::mk_int(tcx), simplify_type(tcx, sub1)])\n           }\n           ty::ty_evec(_, ty::vstore_slice(_)) |"}, {"sha": "7f11108edde1d0ebf74ed55758e1e57f1782392e", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -89,8 +89,8 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       }\n       ty::ty_fn(_) { T_fn_pair(cx, type_of_fn_from_ty(cx, t)) }\n       ty::ty_iface(_, _) { T_opaque_iface(cx) }\n-      ty::ty_res(_, sub, tps) {\n-        let sub1 = ty::substitute_type_params(cx.tcx, tps, sub);\n+      ty::ty_res(_, sub, substs) {\n+        let sub1 = ty::subst(cx.tcx, substs, sub);\n         ret T_struct([T_i8(), type_of(cx, sub1)]);\n       }\n       ty::ty_param(_, _) { T_typaram(cx.tn) }"}, {"sha": "59ae4ec6d047c2175418601ecd3eddf5faaf223b", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -65,7 +65,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     };\n     alt check map_node {\n       ast_map::node_item(@{node: item_fn(_, _, body), _}, _) |\n-      ast_map::node_item(@{node: item_res(_, _, body, _, _), _}, _) |\n+      ast_map::node_item(@{node: item_res(_, _, body, _, _, _), _}, _) |\n       ast_map::node_method(@{body, _}, _, _) {\n         handle_body(cx, body);\n       }\n@@ -107,13 +107,12 @@ fn type_needs_inner(cx: ctx, use: uint, ty: ty::t,\n             alt ty::get(ty).struct {\n               ty::ty_fn(_) | ty::ty_ptr(_) | ty::ty_rptr(_, _) |\n               ty::ty_box(_) | ty::ty_iface(_, _) { false }\n-              ty::ty_enum(did, tps) {\n+              ty::ty_enum(did, substs) {\n                 if option::is_none(list::find(enums_seen, {|id| id == did})) {\n                     let seen = list::cons(did, @enums_seen);\n                     for vec::each(*ty::enum_variants(cx.ccx.tcx, did)) {|v|\n                         for vec::each(v.args) {|aty|\n-                            let t = ty::substitute_type_params(cx.ccx.tcx,\n-                                                               tps, aty);\n+                            let t = ty::subst(cx.ccx.tcx, substs, aty);\n                             type_needs_inner(cx, use, t, seen);\n                         }\n                     }\n@@ -153,7 +152,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         }\n       }\n       expr_path(_) {\n-        option::iter(cx.ccx.tcx.node_type_substs.find(e.id)) {|ts|\n+        cx.ccx.tcx.node_type_substs.find(e.id).iter {|ts|\n             let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get(e.id));\n             vec::iter2(type_uses_for(cx.ccx, id, ts.len()), ts) {|uses, subst|\n                 type_needs(cx, uses, subst)"}, {"sha": "03f5a56a1c076b306b4f48e7cd1249ae5c8ada3a", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -48,16 +48,16 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n       }\n       item_mod(m) { find_pre_post_mod(m); }\n       item_native_mod(nm) { find_pre_post_native_mod(nm); }\n-      item_ty(_, _) | item_enum(_, _) | item_iface(_, _) { ret; }\n-      item_res(_, _, body, dtor_id, _) {\n+      item_ty(_, _, _) | item_enum(_, _, _) | item_iface(_, _) { ret; }\n+      item_res(_, _, body, dtor_id, _, _) {\n         let fcx =\n             {enclosing: ccx.fm.get(dtor_id),\n              id: dtor_id,\n              name: i.ident,\n              ccx: ccx};\n         find_pre_post_fn(fcx, body);\n       }\n-      item_class(_,_,_,_) {\n+      item_class(_,_,_,_,_) {\n           fail \"find_pre_post_item: shouldn't be called on item_class\";\n       }\n       item_impl(_, _, _, ms) {"}, {"sha": "fd87173005b82fed2eb5b4051ff6243864cd137f", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 236, "deletions": 116, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -61,7 +61,7 @@ export sequence_element_type;\n export sort_methods;\n export stmt_node_id;\n export sty;\n-export substitute_type_params;\n+export subst, subst_tps, substs_is_noop, substs;\n export t;\n export new_ty_hash;\n export enum_variants, substd_enum_variants;\n@@ -281,6 +281,23 @@ enum bound_region {\n     br_named(str) // A named region parameter.\n }\n \n+type opt_region = option<region>;\n+\n+// The type substs represents the kinds of things that can be substituted into\n+// a type.  There may be at most one region parameter (self_r), along with\n+// some number of type parameters (tps).\n+//\n+// The region parameter is present on nominative types (enums, resources,\n+// classes) that are declared as having a region parameter.  If the type is\n+// declared as `enum foo&`, then self_r should always be non-none.  If the\n+// type is declared as `enum foo`, then self_r will always be none.  In the\n+// latter case, typeck::ast_ty_to_ty() will reject any references to `&T` or\n+// `&self.T` within the type and report an error.\n+type substs = {\n+    self_r: opt_region,\n+    tps: [t]\n+};\n+\n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in front/ast::rs as well.\n enum sty {\n@@ -292,7 +309,7 @@ enum sty {\n     ty_float(ast::float_ty),\n     ty_str,\n     ty_estr(vstore),\n-    ty_enum(def_id, [t]),\n+    ty_enum(def_id, substs),\n     ty_box(mt),\n     ty_uniq(mt),\n     ty_vec(mt),\n@@ -302,8 +319,8 @@ enum sty {\n     ty_rec([field]),\n     ty_fn(fn_ty),\n     ty_iface(def_id, [t]),\n-    ty_class(def_id, [t]),\n-    ty_res(def_id, t, [t]),\n+    ty_class(def_id, substs),\n+    ty_res(def_id, t, substs),\n     ty_tup([t]),\n \n     ty_var(ty_vid), // type variable during typechecking\n@@ -389,7 +406,9 @@ fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n     kind\n }\n \n-type ty_param_bounds_and_ty = {bounds: @[param_bounds], ty: t};\n+type ty_param_bounds_and_ty = {bounds: @[param_bounds],\n+                               rp: ast::region_param,\n+                               ty: t};\n \n type type_cache = hashmap<ast::def_id, ty_param_bounds_and_ty>;\n \n@@ -475,7 +494,13 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n       ty_opaque_box {}\n       ty_param(_, _) { has_params = true; }\n       ty_var(_) | ty_self(_) { has_vars = true; }\n-      ty_enum(_, tys) | ty_iface(_, tys) | ty_class(_, tys) {\n+      ty_enum(_, substs) | ty_class(_, substs) {\n+        for substs.tps.each {|tt|\n+            derive_flags(has_params, has_vars, has_regions, tt);\n+        }\n+        substs.self_r.iter { |_i| has_regions = true; }\n+      }\n+      ty_iface(_, tys) {\n         for tys.each {|tt|\n             derive_flags(has_params, has_vars, has_regions, tt);\n         }\n@@ -506,9 +531,9 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n         }\n         derive_flags(has_params, has_vars, has_regions, f.output);\n       }\n-      ty_res(_, tt, tps) {\n+      ty_res(_, tt, substs) {\n         derive_flags(has_params, has_vars, has_regions, tt);\n-        for tps.each {|tt|\n+        for substs.tps.each {|tt|\n             derive_flags(has_params, has_vars, has_regions, tt);\n         }\n       }\n@@ -553,8 +578,8 @@ fn mk_estr(cx: ctxt, t: vstore) -> t {\n     mk_t(cx, ty_estr(t))\n }\n \n-fn mk_enum(cx: ctxt, did: ast::def_id, tys: [t]) -> t {\n-    mk_t(cx, ty_enum(did, tys))\n+fn mk_enum(cx: ctxt, did: ast::def_id, substs: substs) -> t {\n+    mk_t(cx, ty_enum(did, substs))\n }\n \n fn mk_box(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_box(tm)) }\n@@ -602,12 +627,13 @@ fn mk_iface(cx: ctxt, did: ast::def_id, tys: [t]) -> t {\n     mk_t(cx, ty_iface(did, tys))\n }\n \n-fn mk_class(cx: ctxt, class_id: ast::def_id, tys: [t]) -> t {\n-    mk_t(cx, ty_class(class_id, tys))\n+fn mk_class(cx: ctxt, class_id: ast::def_id, substs: substs) -> t {\n+    mk_t(cx, ty_class(class_id, substs))\n }\n \n-fn mk_res(cx: ctxt, did: ast::def_id, inner: t, tps: [t]) -> t {\n-    mk_t(cx, ty_res(did, inner, tps))\n+fn mk_res(cx: ctxt, did: ast::def_id,\n+          inner: t, substs: substs) -> t {\n+    mk_t(cx, ty_res(did, inner, substs))\n }\n \n fn mk_var(cx: ctxt, v: ty_vid) -> t { mk_t(cx, ty_var(v)) }\n@@ -657,8 +683,10 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n       ty_ptr(tm) | ty_rptr(_, tm) {\n         maybe_walk_ty(tm.ty, f);\n       }\n-      ty_enum(_, subtys) | ty_iface(_, subtys) | ty_class(_, subtys)\n-       | ty_self(subtys) {\n+      ty_enum(_, substs) | ty_class(_, substs) {\n+        for substs.tps.each {|subty| maybe_walk_ty(subty, f); }\n+      }\n+      ty_iface(_, subtys) |ty_self(subtys) {\n         for subtys.each {|subty| maybe_walk_ty(subty, f); }\n       }\n       ty_rec(fields) {\n@@ -669,9 +697,9 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n         for ft.inputs.each {|a| maybe_walk_ty(a.ty, f); }\n         maybe_walk_ty(ft.output, f);\n       }\n-      ty_res(_, sub, tps) {\n+      ty_res(_, sub, substs) {\n         maybe_walk_ty(sub, f);\n-        for tps.each {|tp| maybe_walk_ty(tp, f); }\n+        for substs.tps.each {|tp| maybe_walk_ty(tp, f); }\n       }\n       ty_constr(sub, _) { maybe_walk_ty(sub, f); }\n       ty_uniq(tm) { maybe_walk_ty(tm.ty, f); }\n@@ -683,6 +711,11 @@ fn fold_sty_to_ty(tcx: ty::ctxt, sty: sty, foldop: fn(t) -> t) -> t {\n }\n \n fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n+    fn fold_substs(substs: substs, fldop: fn(t) -> t) -> substs {\n+        {self_r: substs.self_r,\n+         tps: substs.tps.map { |t| fldop(t) }}\n+    }\n+\n     alt sty {\n       ty_box(tm) {\n         ty_box({ty: fldop(tm.ty), mutbl: tm.mutbl})\n@@ -699,8 +732,8 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n       ty_evec(tm, vst) {\n         ty_evec({ty: fldop(tm.ty), mutbl: tm.mutbl}, vst)\n       }\n-      ty_enum(tid, subtys) {\n-        ty_enum(tid, vec::map(subtys) {|t| fldop(t) })\n+      ty_enum(tid, substs) {\n+        ty_enum(tid, fold_substs(substs, fldop))\n       }\n       ty_iface(did, subtys) {\n         ty_iface(did, vec::map(subtys) {|t| fldop(t) })\n@@ -728,19 +761,18 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n         let new_output = fldop(f.output);\n         ty_fn({inputs: new_args, output: new_output with f})\n       }\n-      ty_res(did, subty, tps) {\n-        let new_tps = vec::map(tps) {|ty| fldop(ty) };\n-        ty_res(did, fldop(subty), new_tps)\n+      ty_res(did, subty, substs) {\n+        ty_res(did, fldop(subty),\n+               fold_substs(substs, fldop))\n       }\n       ty_rptr(r, tm) {\n         ty_rptr(r, {ty: fldop(tm.ty), mutbl: tm.mutbl})\n       }\n       ty_constr(subty, cs) {\n         ty_constr(fldop(subty), cs)\n       }\n-      ty_class(did, tps) {\n-        let new_tps = vec::map(tps) {|ty| fldop(ty) };\n-        ty_class(did, new_tps)\n+      ty_class(did, substs) {\n+        ty_class(did, fold_substs(substs, fldop))\n       }\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_str | ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n@@ -765,6 +797,61 @@ fn fold_ty_var(cx: ctxt, t0: t, fldop: fn(ty_vid) -> t) -> t {\n     }\n }\n \n+fn fold_regions_and_ty(\n+    cx: ctxt,\n+    ty: t,\n+    fldr: fn(r: region) -> region,\n+    fldfnt: fn(t: t) -> t,\n+    fldt: fn(t: t) -> t) -> t {\n+\n+    fn fold_substs(\n+        substs: substs,\n+        fldr: fn(r: region) -> region,\n+        fldt: fn(t: t) -> t) -> substs {\n+\n+        {self_r: substs.self_r.map { |r| fldr(r) },\n+         tps: substs.tps.map { |t| fldt(t) }}\n+    }\n+\n+    let tb = ty::get(ty);\n+    alt tb.struct {\n+      ty::ty_rptr(r, mt) {\n+        let m_r = fldr(r);\n+        let m_t = fldt(mt.ty);\n+        ty::mk_rptr(cx, m_r, {ty: m_t, mutbl: mt.mutbl})\n+      }\n+      ty_estr(vstore_slice(r)) {\n+        let m_r = fldr(r);\n+        ty::mk_estr(cx, vstore_slice(m_r))\n+      }\n+      ty_evec(mt, vstore_slice(r)) {\n+        let m_r = fldr(r);\n+        let m_t = fldt(mt.ty);\n+        ty::mk_evec(cx, {ty: m_t, mutbl: mt.mutbl}, vstore_slice(m_r))\n+      }\n+      ty_enum(def_id, substs) {\n+        ty::mk_enum(cx, def_id, fold_substs(substs, fldr, fldt))\n+      }\n+      ty_class(def_id, substs) {\n+        ty::mk_class(cx, def_id, fold_substs(substs, fldr, fldt))\n+      }\n+      ty_res(def_id, t, substs) {\n+        ty::mk_res(cx, def_id, fldt(t),\n+                   fold_substs(substs, fldr, fldt))\n+      }\n+      sty @ ty_fn(_) {\n+        fold_sty_to_ty(cx, sty) {|t|\n+            fldfnt(t)\n+        }\n+      }\n+      sty {\n+        fold_sty_to_ty(cx, sty) {|t|\n+            fldt(t)\n+        }\n+      }\n+    }\n+}\n+\n // n.b. this function is intended to eventually replace fold_region() below,\n // that is why its name is so similar.\n fn fold_regions(\n@@ -774,36 +861,13 @@ fn fold_regions(\n \n     fn do_fold(cx: ctxt, ty: t, in_fn: bool,\n                fldr: fn(region, bool) -> region) -> t {\n-        let tb = ty::get(ty);\n-        if !tb.has_regions { ret ty; }\n-        alt tb.struct {\n-          ty::ty_rptr(r, mt) {\n-            let m_r = fldr(r, in_fn);\n-            let m_t = do_fold(cx, mt.ty, in_fn, fldr);\n-            ty::mk_rptr(cx, m_r, {ty: m_t, mutbl: mt.mutbl})\n-          }\n-          ty_estr(vstore_slice(r)) {\n-            let m_r = fldr(r, in_fn);\n-            ty::mk_estr(cx, vstore_slice(m_r))\n-          }\n-          ty_evec(mt, vstore_slice(r)) {\n-            let m_r = fldr(r, in_fn);\n-            let m_t = do_fold(cx, mt.ty, in_fn, fldr);\n-            ty::mk_evec(cx, {ty: m_t, mutbl: mt.mutbl}, vstore_slice(m_r))\n-          }\n-          sty @ ty_fn(_) {\n-            fold_sty_to_ty(cx, sty) {|t|\n-                do_fold(cx, t, true, fldr)\n-            }\n-          }\n-          sty {\n-            fold_sty_to_ty(cx, sty) {|t|\n-                do_fold(cx, t, in_fn, fldr)\n-            }\n-          }\n-        }\n+        if !type_has_regions(ty) { ret ty; }\n+        fold_regions_and_ty(\n+            cx, ty,\n+            { |r| fldr(r, in_fn) },\n+            { |t| do_fold(cx, t, true, fldr) },\n+            { |t| do_fold(cx, t, in_fn, fldr) })\n     }\n-\n     do_fold(cx, ty, false, fldr)\n }\n \n@@ -842,13 +906,63 @@ fn fold_region(cx: ctxt, t0: t, fldop: fn(region, bool) -> region) -> t {\n     do_fold(cx, t0, false, fldop)\n }\n \n-fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n-    if substs.len() == 0u { ret typ; }\n-    let tb = get(typ);\n+// Substitute *only* type parameters.  Used in trans where regions are erased.\n+fn subst_tps(cx: ctxt, tps: [t], typ: t) -> t {\n+    if tps.len() == 0u { ret typ; }\n+    let tb = ty::get(typ);\n     if !tb.has_params { ret typ; }\n     alt tb.struct {\n-      ty_param(idx, _) { substs[idx] }\n-      s { mk_t(cx, fold_sty(s) {|t| substitute_type_params(cx, substs, t)}) }\n+      ty_param(idx, _) { tps[idx] }\n+      sty { fold_sty_to_ty(cx, sty) {|t| subst_tps(cx, tps, t) } }\n+    }\n+}\n+\n+fn substs_is_noop(substs: substs) -> bool {\n+    substs.tps.len() == 0u && substs.self_r.is_none()\n+}\n+\n+fn substs_to_str(cx: ctxt, substs: substs) -> str {\n+    #fmt[\"substs(self_r=%s, tps=%?)\",\n+         substs.self_r.map_default(\"none\", { |r| region_to_str(cx, r) }),\n+         substs.tps.map { |t| ty_to_str(cx, t) }]\n+}\n+\n+fn subst(cx: ctxt,\n+         substs: substs,\n+         typ: t) -> t {\n+\n+    if substs_is_noop(substs) { ret typ; }\n+    #debug[\"subst(substs=%s, typ=%s)\",\n+           substs_to_str(cx, substs),\n+           ty_to_str(cx, typ)];\n+    let r = do_subst(cx, substs, typ);\n+    #debug[\"  r = %s\", ty_to_str(cx, r)];\n+    ret r;\n+\n+    fn do_subst(cx: ctxt,\n+                substs: substs,\n+                typ: t) -> t {\n+        let tb = get(typ);\n+        if !tb.has_params && !tb.has_regions { ret typ; }\n+        alt tb.struct {\n+          ty_param(idx, _) { substs.tps[idx] }\n+          _ {\n+            fold_regions_and_ty(\n+                cx, typ,\n+                { |r|\n+                    alt r {\n+                      re_bound(br_self) {\n+                        option::get(substs.self_r)\n+                      }\n+                      _ {\n+                        r\n+                      }\n+                    }\n+                },\n+                { |t| do_subst(cx, substs, t) },\n+                { |t| do_subst(cx, substs, t) })\n+          }\n+        }\n     }\n }\n \n@@ -862,7 +976,7 @@ fn type_is_bool(ty: t) -> bool { get(ty).struct == ty_bool }\n \n fn type_is_structural(ty: t) -> bool {\n     alt get(ty).struct {\n-      ty_rec(_) | ty_class(_,_) | ty_tup(_) | ty_enum(_, _) | ty_fn(_) |\n+      ty_rec(_) | ty_class(_, _) | ty_tup(_) | ty_enum(_, _) | ty_fn(_) |\n       ty_iface(_, _) | ty_res(_, _, _) | ty_evec(_, vstore_fixed(_))\n       | ty_estr(vstore_fixed(_)) { true }\n       _ { false }\n@@ -994,8 +1108,8 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n         for flds.each {|f| if type_needs_drop(cx, f.mt.ty) { accum = true; } }\n         accum\n       }\n-      ty_class(did, ts) {\n-        for vec::each(ty::class_items_as_fields(cx, did, ts)) {|f|\n+      ty_class(did, substs) {\n+        for vec::each(ty::class_items_as_fields(cx, did, substs)) {|f|\n             if type_needs_drop(cx, f.mt.ty) { accum = true; }\n         }\n         accum\n@@ -1005,12 +1119,12 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n         for elts.each {|m| if type_needs_drop(cx, m) { accum = true; } }\n         accum\n       }\n-      ty_enum(did, tps) {\n+      ty_enum(did, substs) {\n         let variants = enum_variants(cx, did);\n         for vec::each(*variants) {|variant|\n             for variant.args.each {|aty|\n                 // Perform any type parameter substitutions.\n-                let arg_ty = substitute_type_params(cx, tps, aty);\n+                let arg_ty = subst(cx, substs, aty);\n                 if type_needs_drop(cx, arg_ty) { accum = true; }\n             }\n             if accum { break; }\n@@ -1064,10 +1178,10 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n           ty_rec(_) | ty_tup(_) | ty_ptr(_) {\n             true\n           }\n-          ty_enum(did, tps) {\n+          ty_enum(did, substs) {\n             for vec::each(*enum_variants(cx, did)) {|v|\n                 for v.args.each {|aty|\n-                    let t = substitute_type_params(cx, tps, aty);\n+                    let t = subst(cx, substs, aty);\n                     needs_unwind_cleanup |=\n                         type_needs_unwind_cleanup_(cx, t, tycache,\n                                                    encountered_box);\n@@ -1211,7 +1325,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         lowest\n       }\n       // Enums lower to the lowest of their variants.\n-      ty_enum(did, tps) {\n+      ty_enum(did, substs) {\n         let mut lowest = kind_sendable;\n         let variants = enum_variants(cx, did);\n         if vec::len(*variants) == 0u {\n@@ -1220,7 +1334,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n             for vec::each(*variants) {|variant|\n                 for variant.args.each {|aty|\n                     // Perform any type parameter substitutions.\n-                    let arg_ty = substitute_type_params(cx, tps, aty);\n+                    let arg_ty = subst(cx, substs, aty);\n                     lowest = lower_kind(lowest, type_kind(cx, arg_ty));\n                     if lowest == kind_noncopyable { break; }\n                 }\n@@ -1316,11 +1430,11 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             false\n           }\n \n-          ty_class(did, tps) {\n+          ty_class(did, substs) {\n             vec::push(*seen, did);\n             let r = vec::any(lookup_class_fields(cx, did)) {|f|\n                 let fty = ty::lookup_item_type(cx, f.id);\n-                let sty = substitute_type_params(cx, tps, fty.ty);\n+                let sty = subst(cx, substs, fty.ty);\n                 type_requires(cx, seen, r_ty, sty)\n             };\n             vec::pop(*seen);\n@@ -1331,9 +1445,9 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             false\n           }\n \n-          ty_res(did, sub, tps) {\n+          ty_res(did, sub, substs) {\n             vec::push(*seen, did);\n-            let sty = substitute_type_params(cx, tps, sub);\n+            let sty = subst(cx, substs, sub);\n             let r = type_requires(cx, seen, r_ty, sty);\n             vec::pop(*seen);\n             r\n@@ -1349,12 +1463,12 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             false\n           }\n \n-          ty_enum(did, tps) {\n+          ty_enum(did, substs) {\n             vec::push(*seen, did);\n             let vs = enum_variants(cx, did);\n             let r = vec::len(*vs) > 0u && vec::all(*vs) {|variant|\n                 vec::any(variant.args) {|aty|\n-                    let sty = substitute_type_params(cx, tps, aty);\n+                    let sty = subst(cx, substs, aty);\n                     type_requires(cx, seen, r_ty, sty)\n                 }\n             };\n@@ -1380,10 +1494,10 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n     let sty = get(ty).struct;\n     if test(sty) { ret true; }\n     alt sty {\n-      ty_enum(did, tps) {\n+      ty_enum(did, substs) {\n         for vec::each(*enum_variants(cx, did)) {|variant|\n             for variant.args.each {|aty|\n-                let sty = substitute_type_params(cx, tps, aty);\n+                let sty = subst(cx, substs, aty);\n                 if type_structurally_contains(cx, sty, test) { ret true; }\n             }\n         }\n@@ -1401,8 +1515,8 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n         }\n         ret false;\n       }\n-      ty_res(_, sub, tps) {\n-        let sty = substitute_type_params(cx, tps, sub);\n+      ty_res(_, sub, substs) {\n+        let sty = subst(cx, substs, sub);\n         ret type_structurally_contains(cx, sty, test);\n       }\n       ty_evec(mt, vstore_fixed(_)) {\n@@ -1485,13 +1599,13 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_str | ty_box(_) | ty_uniq(_) | ty_vec(_) | ty_fn(_) |\n       ty_iface(_, _) | ty_rptr(_,_) | ty_opaque_box { result = false; }\n       // Structural types\n-      ty_enum(did, tps) {\n+      ty_enum(did, substs) {\n         let variants = enum_variants(cx, did);\n         for vec::each(*variants) {|variant|\n             let tup_ty = mk_tup(cx, variant.args);\n \n             // Perform any type parameter substitutions.\n-            let tup_ty = substitute_type_params(cx, tps, tup_ty);\n+            let tup_ty = subst(cx, substs, tup_ty);\n             if !type_is_pod(cx, tup_ty) { result = false; }\n         }\n       }\n@@ -1507,8 +1621,8 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_evec(mt, vstore_fixed(_)) {\n         result = type_is_pod(cx, mt.ty);\n       }\n-      ty_res(_, inner, tps) {\n-        result = type_is_pod(cx, substitute_type_params(cx, tps, inner));\n+      ty_res(_, inner, substs) {\n+        result = type_is_pod(cx, subst(cx, substs, inner));\n       }\n       ty_constr(subt, _) { result = type_is_pod(cx, subt); }\n       ty_param(_, _) { result = false; }\n@@ -1530,7 +1644,7 @@ fn type_is_enum(ty: t) -> bool {\n // constructors\n fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n     alt get(ty).struct {\n-      ty_enum(did, tps) {\n+      ty_enum(did, substs) {\n         let variants = enum_variants(cx, did);\n         let some_n_ary = vec::any(*variants, {|v| vec::len(v.args) > 0u});\n         ret !some_n_ary;\n@@ -1562,15 +1676,15 @@ fn type_autoderef(cx: ctxt, t: t) -> t {\n     loop {\n         alt get(t1).struct {\n           ty_box(mt) | ty_uniq(mt) | ty::ty_rptr(_, mt) { t1 = mt.ty; }\n-          ty_res(_, inner, tps) {\n-            t1 = substitute_type_params(cx, tps, inner);\n+          ty_res(_, inner, substs) {\n+            t1 = subst(cx, substs, inner);\n           }\n-          ty_enum(did, tps) {\n+          ty_enum(did, substs) {\n             let variants = enum_variants(cx, did);\n             if vec::len(*variants) != 1u || vec::len(variants[0].args) != 1u {\n                 break;\n             }\n-            t1 = substitute_type_params(cx, tps, variants[0].args[0]);\n+            t1 = subst(cx, substs, variants[0].args[0]);\n           }\n           _ { break; }\n         }\n@@ -1627,6 +1741,10 @@ fn hash_type_structure(st: sty) -> uint {\n           re_bot        { 4u }\n         }\n     }\n+    fn hash_substs(h: uint, substs: substs) -> uint {\n+        let h = hash_subtys(h, substs.tps);\n+        h + substs.self_r.map_default(0u, hash_region)\n+    }\n     alt st {\n       ty_nil { 0u } ty_bool { 1u }\n       ty_int(t) {\n@@ -1646,10 +1764,9 @@ fn hash_type_structure(st: sty) -> uint {\n       }\n       ty_estr(_) { 16u }\n       ty_str { 17u }\n-      ty_enum(did, tys) {\n+      ty_enum(did, substs) {\n         let mut h = hash_def(18u, did);\n-        for tys.each {|typ| h = hash_subty(h, typ); }\n-        h\n+        hash_substs(h, substs)\n       }\n       ty_box(mt) { hash_subty(19u, mt.ty) }\n       ty_evec(mt, _) { hash_subty(20u, mt.ty) }\n@@ -1679,9 +1796,9 @@ fn hash_type_structure(st: sty) -> uint {\n         let mut h = (46u << 2u) + hash_region(region);\n         hash_subty(h, mt.ty)\n       }\n-      ty_res(did, sub, tps) {\n+      ty_res(did, sub, substs) {\n         let mut h = hash_subty(hash_def(18u, did), sub);\n-        hash_subtys(h, tps)\n+        hash_substs(h, substs)\n       }\n       ty_constr(t, cs) {\n         let mut h = hash_subty(36u, t);\n@@ -1698,10 +1815,9 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_opaque_closure_ptr(ck_box) { 42u }\n       ty_opaque_closure_ptr(ck_uniq) { 43u }\n       ty_opaque_box { 44u }\n-      ty_class(did, tys) {\n-          let mut h = hash_def(45u, did);\n-          for tys.each {|typ| h = hash_subty(h, typ); }\n-          h\n+      ty_class(did, substs) {\n+        let mut h = hash_def(45u, did);\n+        hash_substs(h, substs)\n       }\n     }\n }\n@@ -1997,17 +2113,17 @@ fn ty_sort_str(cx: ctxt, t: t) -> str {\n         ty_to_str(cx, t)\n       }\n \n-      ty_enum(_, _) { \"enum\" }\n+      ty_enum(id, _) { #fmt[\"enum %s\", item_path_str(cx, id)] }\n       ty_box(_) { \"@-ptr\" }\n       ty_uniq(_) { \"~-ptr\" }\n       ty_evec(_, _) | ty_vec(_) { \"vector\" }\n       ty_ptr(_) { \"*-ptr\" }\n       ty_rptr(_, _) { \"&-ptr\" }\n       ty_rec(_) { \"record\" }\n       ty_fn(_) { \"fn\" }\n-      ty_iface(_, _) { \"iface\" }\n-      ty_class(_, _) { \"class\" }\n-      ty_res(_, _, _) { \"resource\" }\n+      ty_iface(id, _) { #fmt[\"iface %s\", item_path_str(cx, id)] }\n+      ty_class(id, _) { #fmt[\"class %s\", item_path_str(cx, id)] }\n+      ty_res(id, _, _) { #fmt[\"resource %s\", item_path_str(cx, id)] }\n       ty_tup(_) { \"tuple\" }\n       ty_var(_) { \"variable\" }\n       ty_param(_, _) { \"type parameter\" }\n@@ -2148,15 +2264,15 @@ fn ty_to_def_id(ty: t) -> ast::def_id {\n type variant_info = @{args: [t], ctor_ty: t, name: str,\n                       id: ast::def_id, disr_val: int};\n \n-fn substd_enum_variants(cx: ctxt, id: ast::def_id, tps: [ty::t])\n-    -> [variant_info] {\n+fn substd_enum_variants(cx: ctxt,\n+                        id: ast::def_id,\n+                        substs: substs) -> [variant_info] {\n     vec::map(*enum_variants(cx, id)) { |variant_info|\n         let substd_args = vec::map(variant_info.args) {|aty|\n-            substitute_type_params(cx, tps, aty)\n+            subst(cx, substs, aty)\n         };\n \n-        let substd_ctor_ty =\n-            substitute_type_params(cx, tps, variant_info.ctor_ty);\n+        let substd_ctor_ty = subst(cx, substs, variant_info.ctor_ty);\n \n         @{args: substd_args, ctor_ty: substd_ctor_ty with *variant_info}\n     }\n@@ -2214,20 +2330,23 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n       some(variants) { ret variants; }\n       _ { /* fallthrough */ }\n     }\n+\n     let result = if ast::local_crate != id.crate {\n         @csearch::get_enum_variants(cx, id)\n     } else {\n         // FIXME: Now that the variants are run through the type checker (to\n         // check the disr_expr if it exists), this code should likely be\n         // moved there to avoid having to call eval_const_expr twice.\n         alt cx.items.get(id.node) {\n-          ast_map::node_item(@{node: ast::item_enum(variants, _), _}, _) {\n+          ast_map::node_item(@{node: ast::item_enum(variants, _, _), _}, _) {\n             let mut disr_val = -1;\n             @vec::map(variants, {|variant|\n                 let ctor_ty = node_id_to_type(cx, variant.node.id);\n-                let arg_tys = if vec::len(variant.node.args) > 0u {\n-                    vec::map(ty_fn_args(ctor_ty), {|a| a.ty})\n-                } else { [] };\n+                let arg_tys = {\n+                    if vec::len(variant.node.args) > 0u {\n+                        ty_fn_args(ctor_ty).map { |a| a.ty }\n+                    } else { [] }\n+                };\n                 alt variant.node.disr_expr {\n                   some (ex) {\n                     // FIXME: issue #1417\n@@ -2287,7 +2406,8 @@ fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n // Look up a field ID, whether or not it's local\n // Takes a list of type substs in case the class is generic\n fn lookup_field_type(tcx: ctxt, class_id: def_id, id: def_id,\n-                     substs: [ty::t]) -> ty::t {\n+                     substs: substs) -> ty::t {\n+\n     let t = if id.crate == ast::local_crate {\n         node_id_to_type(tcx, id.node)\n     }\n@@ -2304,7 +2424,7 @@ fn lookup_field_type(tcx: ctxt, class_id: def_id, id: def_id,\n            }\n         }\n     };\n-    substitute_type_params(tcx, substs, t)\n+    subst(tcx, substs, t)\n }\n \n // Look up the list of field names and IDs for a given class\n@@ -2314,7 +2434,7 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> [field_ty] {\n     alt cx.items.find(did.node) {\n        some(ast_map::node_item(i,_)) {\n          alt i.node {\n-           ast::item_class(_, _, items, _) {\n+           ast::item_class(_, _, items, _, _) {\n                class_field_tys(items)\n            }\n            _ { cx.sess.bug(\"class ID bound to non-class\"); }\n@@ -2356,7 +2476,7 @@ pure fn is_public(f: field_ty) -> bool {\n fn lookup_class_method_ids(cx: ctxt, did: ast::def_id)\n     : is_local(did) -> [{name: ident, id: node_id, privacy: privacy}] {\n     alt cx.items.find(did.node) {\n-       some(ast_map::node_item(@{node: item_class(_,_,items,_), _}, _)) {\n+       some(ast_map::node_item(@{node: item_class(_,_,items,_,_), _}, _)) {\n          let (_,ms) = split_class_items(items);\n          vec::map(ms, {|m| {name: m.ident, id: m.id,\n                          privacy: m.privacy}})\n@@ -2406,8 +2526,8 @@ fn class_field_tys(items: [@class_member]) -> [field_ty] {\n // Return a list of fields corresponding to the class's items\n // (as if the class was a record). trans uses this\n // Takes a list of substs with which to instantiate field types\n-fn class_items_as_fields(cx:ctxt, did: ast::def_id, substs: [ty::t])\n-    -> [field] {\n+fn class_items_as_fields(cx:ctxt, did: ast::def_id,\n+                         substs: substs) -> [field] {\n     let mut rslt = [];\n     for lookup_class_fields(cx, did).each {|f|\n        // consider all instance vars mut, because the"}, {"sha": "d13a23fccb9792fb161cb0511bc3867d171f91a5", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 489, "deletions": 455, "changes": 944, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -1,4 +1,4 @@\n-import result::result;\n+import result::{result, extensions};\n import syntax::{ast, ast_util};\n import ast::spanned;\n import syntax::ast_util::{local_def, respan, split_class_items};\n@@ -12,7 +12,7 @@ import middle::ty;\n import middle::ty::{arg, field, node_type_table, mk_nil,\n                     ty_param_bounds_and_ty, lookup_public_fields};\n import middle::ty::{ty_vid, region_vid, vid};\n-import util::ppaux::ty_to_str;\n+import util::ppaux::{ty_to_str, region_to_str};\n import std::smallintmap;\n import std::smallintmap::map;\n import std::map;\n@@ -69,7 +69,7 @@ type class_map = hashmap<ast::node_id, ty::t>;\n \n // a list of mapping from in-scope-region-names (\"isr\") to the\n // corresponding ty::region\n-type isr_alist = @list<(str, ty::region)>;\n+type isr_alist = @list<(ty::bound_region, ty::region)>;\n \n type fn_ctxt =\n     // var_bindings, locals and next_var_id are shared\n@@ -112,7 +112,7 @@ type fn_ctxt =\n      // eventually be resolved to some concrete type (which might itself be\n      // type parameter).\n      node_types: smallintmap::smallintmap<ty::t>,\n-     node_type_substs: hashmap<ast::node_id, [ty::t]>,\n+     node_type_substs: hashmap<ast::node_id, ty::substs>,\n \n      ccx: @crate_ctxt};\n \n@@ -153,24 +153,29 @@ fn lookup_def(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ast::def {\n     lookup_def_ccx(fcx.ccx, sp, id)\n }\n \n+fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n+    {bounds: @[], rp: ast::rp_none, ty: t}\n+}\n+\n // Returns the type parameter count and the type for the given definition.\n fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n-   ty_param_bounds_and_ty {\n+    ty_param_bounds_and_ty {\n+\n     alt defn {\n       ast::def_arg(nid, _) {\n         assert (fcx.locals.contains_key(nid));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, nid));\n-        ret {bounds: @[], ty: typ};\n+        ret no_params(typ);\n       }\n       ast::def_local(nid, _) {\n         assert (fcx.locals.contains_key(nid));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, nid));\n-        ret {bounds: @[], ty: typ};\n+        ret no_params(typ);\n       }\n       ast::def_self(_) {\n         alt fcx.self_ty {\n           some(self_ty) {\n-            ret {bounds: @[], ty: self_ty};\n+            ret no_params(self_ty);\n           }\n           none {\n               fcx.ccx.tcx.sess.span_bug(sp, \"def_self with no self_ty\");\n@@ -181,6 +186,7 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n         // Crust functions are just u8 pointers\n         ret {\n             bounds: @[],\n+            rp: ast::rp_none,\n             ty: ty::mk_ptr(\n                 fcx.ccx.tcx,\n                 {\n@@ -195,7 +201,7 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n       ast::def_binding(nid) {\n         assert (fcx.locals.contains_key(nid));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, nid));\n-        ret {bounds: @[], ty: typ};\n+        ret no_params(typ);\n       }\n       ast::def_ty(_) | ast::def_prim_ty(_) {\n         fcx.ccx.tcx.sess.span_fatal(sp, \"expected value but found type\");\n@@ -212,36 +218,41 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n \n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n-fn instantiate_path(fcx: @fn_ctxt, pth: @ast::path,\n-                    tpt: ty_param_bounds_and_ty, sp: span,\n+fn instantiate_path(fcx: @fn_ctxt,\n+                    pth: @ast::path,\n+                    tpt: ty_param_bounds_and_ty,\n+                    sp: span,\n                     id: ast::node_id) {\n     let ty_param_count = vec::len(*tpt.bounds);\n     let ty_substs_len = vec::len(pth.node.types);\n-    if ty_substs_len > 0u {\n-        if ty_param_count == 0u {\n-            fcx.ccx.tcx.sess.span_fatal\n-                (sp, \"this item does not take type parameters\");\n-        } else if ty_substs_len > ty_param_count {\n-            fcx.ccx.tcx.sess.span_fatal\n-                (sp, \"too many type parameters provided for this item\");\n-        } else if ty_substs_len < ty_param_count {\n-            fcx.ccx.tcx.sess.span_fatal\n-                (sp, \"not enough type parameters provided for this item\");\n-        }\n-        if ty_param_count == 0u {\n-            fcx.ccx.tcx.sess.span_fatal(\n-                sp, \"this item does not take type parameters\");\n-        }\n-        let substs = vec::map(pth.node.types, {|aty|\n-            fcx.to_ty(aty)\n-        });\n-        fcx.write_ty_substs(id, tpt.ty, substs);\n-    } else if ty_param_count > 0u {\n-        let vars = fcx.next_ty_vars(ty_param_count);\n-        fcx.write_ty_substs(id, tpt.ty, vars);\n+\n+    // For now, there is no way to explicitly specify the region bound.\n+    // This will have to change eventually.\n+    let self_r = alt tpt.rp {\n+      ast::rp_self { some(fcx.next_region_var()) }\n+      ast::rp_none { none }\n+    };\n+\n+    let tps = if ty_substs_len == 0u {\n+        fcx.next_ty_vars(ty_param_count)\n+    } else if ty_param_count == 0u {\n+        fcx.ccx.tcx.sess.span_err\n+            (sp, \"this item does not take type parameters\");\n+        fcx.next_ty_vars(ty_param_count)\n+    } else if ty_substs_len > ty_param_count {\n+        fcx.ccx.tcx.sess.span_err\n+            (sp, \"too many type parameters provided for this item\");\n+        fcx.next_ty_vars(ty_param_count)\n+    } else if ty_substs_len < ty_param_count {\n+        fcx.ccx.tcx.sess.span_err\n+            (sp, \"not enough type parameters provided for this item\");\n+        fcx.next_ty_vars(ty_param_count)\n     } else {\n-        fcx.write_ty(id, tpt.ty);\n-    }\n+        pth.node.types.map { |aty| fcx.to_ty(aty) }\n+    };\n+\n+    let substs = {self_r: self_r, tps: tps};\n+    fcx.write_ty_substs(id, tpt.ty, substs);\n }\n \n // Type tests\n@@ -358,20 +369,54 @@ impl of ast_conv for @fn_ctxt {\n }\n \n iface region_scope {\n-    fn anon_region() -> ty::region;\n-    fn named_region(id: str) -> option<ty::region>;\n+    fn anon_region() -> result<ty::region, str>;\n+    fn named_region(id: str) -> result<ty::region, str>;\n }\n \n-enum base_rscope { base_rscope }\n-impl of region_scope for base_rscope {\n-    fn anon_region() -> ty::region { ty::re_bound(ty::br_anon) }\n-    fn named_region(_id: str) -> option<ty::region> { none }\n+enum empty_rscope { empty_rscope }\n+impl of region_scope for empty_rscope {\n+    fn anon_region() -> result<ty::region, str> {\n+        result::err(\"region types are not allowed here\")\n+    }\n+    fn named_region(_id: str) -> result<ty::region, str> {\n+        result::err(\"region types are not allowed here\")\n+    }\n+}\n+\n+enum type_rscope = ast::region_param;\n+impl of region_scope for type_rscope {\n+    fn anon_region() -> result<ty::region, str> {\n+        alt *self {\n+          ast::rp_self {\n+            result::ok(ty::re_bound(ty::br_self))\n+          }\n+          ast::rp_none {\n+            result::err(\"to use region types here, the containing type \\\n+                         must be declared with a region bound\")\n+          }\n+        }\n+    }\n+    fn named_region(id: str) -> result<ty::region, str> {\n+        if id == \"self\" {\n+            self.anon_region()\n+        } else {\n+            result::err(\"named regions other than `self` are not \\\n+                         allowed as part of a type declaration\")\n+        }\n+    }\n }\n \n impl of region_scope for @fn_ctxt {\n-    fn anon_region() -> ty::region { self.next_region_var() }\n-    fn named_region(id: str) -> option<ty::region> {\n-        self.in_scope_regions.find(id)\n+    fn anon_region() -> result<ty::region, str> {\n+        result::ok(self.next_region_var())\n+    }\n+    fn named_region(id: str) -> result<ty::region, str> {\n+        alt self.in_scope_regions.find(ty::br_named(id)) {\n+          some(r) { result::ok(r) }\n+          none {\n+            result::err(#fmt[\"named region `%s` not in scope here\", id])\n+          }\n+        }\n     }\n }\n \n@@ -381,17 +426,11 @@ fn in_anon_rscope<RS: region_scope copy>(self: RS, r: ty::region)\n     @anon_rscope({anon: r, base: self as region_scope})\n }\n impl of region_scope for @anon_rscope {\n-    fn anon_region() -> ty::region { self.anon }\n-    fn named_region(id: str) -> option<ty::region> {\n-        self.base.named_region(id)\n+    fn anon_region() -> result<ty::region, str> {\n+        result::ok(self.anon)\n     }\n-}\n-\n-enum self_rscope { self_rscope }\n-impl of region_scope for self_rscope {\n-    fn anon_region() -> ty::region { ty::re_bound(ty::br_self) }\n-    fn named_region(id: str) -> option<ty::region> {\n-        if id == \"self\" {some(self.anon_region())} else {none}\n+    fn named_region(id: str) -> result<ty::region, str> {\n+        self.base.named_region(id)\n     }\n }\n \n@@ -401,40 +440,41 @@ fn in_binding_rscope<RS: region_scope copy>(self: RS) -> @binding_rscope {\n     @binding_rscope({base: base})\n }\n impl of region_scope for @binding_rscope {\n-    fn anon_region() -> ty::region { ty::re_bound(ty::br_anon) }\n-    fn named_region(id: str) -> option<ty::region> {\n-        let nr = self.base.named_region(id);\n-        alt nr {\n-          some(r) { some(r) }\n-          none { some(ty::re_bound(ty::br_named(id))) }\n+    fn anon_region() -> result<ty::region, str> {\n+        result::ok(ty::re_bound(ty::br_anon))\n+    }\n+    fn named_region(id: str) -> result<ty::region, str> {\n+        self.base.named_region(id).chain_err {|_e|\n+            result::ok(ty::re_bound(ty::br_named(id)))\n         }\n     }\n }\n \n-fn ast_region_to_region<AC: ast_conv, RS: region_scope copy>(\n-    self: AC, rscope: RS, span: span, a_r: ast::region) -> ty::region {\n+fn get_region_reporting_err(tcx: ty::ctxt,\n+                            span: span,\n+                            res: result<ty::region, str>) -> ty::region {\n \n-    alt a_r.node {\n-      ast::re_anon {\n-        rscope.anon_region()\n-      }\n-      ast::re_named(id) {\n-        alt rscope.named_region(id) {\n-          some(r) { r }\n-          none {\n-            self.tcx().sess.span_err(\n-                span,\n-                #fmt[\"named region `%s` not in scope here\", id]);\n-            rscope.anon_region()\n-          }\n-        }\n-      }\n-      ast::re_static {\n+    alt res {\n+      result::ok(r) { r }\n+      result::err(e) {\n+        tcx.sess.span_err(span, e);\n         ty::re_static\n       }\n     }\n }\n \n+fn ast_region_to_region<AC: ast_conv, RS: region_scope>(\n+    self: AC, rscope: RS, span: span, a_r: ast::region) -> ty::region {\n+\n+    let res = alt a_r.node {\n+      ast::re_anon { rscope.anon_region() }\n+      ast::re_named(id) { rscope.named_region(id) }\n+      ast::re_static { result::ok(ty::re_static) }\n+    };\n+\n+    get_region_reporting_err(self.tcx(), span, res)\n+}\n+\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n@@ -452,30 +492,34 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n         path_id: ast::node_id, args: [@ast::ty]) -> ty::t {\n \n         let tcx = self.tcx();\n-        let {bounds, ty} = self.get_item_ty(id);\n-\n-        // The type of items may include a reference to the bound anon region.\n-        // Replace it with the current binding for that region in this\n-        // context.\n-        //\n-        // n.b. Ordinarily, one should do all substitutions at once to avoid\n-        // capture problems.  But in this instance it is ok to substitute for\n-        // the bound region first and then type parameters second, as the\n-        // bound region cannot be replaced with a type parameter.\n-        let ty = subst_anon_region(tcx, rscope.anon_region(), ty);\n-\n-        // The typedef is type-parametric. Do the type substitution.\n+        let {bounds, rp, ty} = self.get_item_ty(id);\n+\n+        // If the type is parameterized by the self region, then replace self\n+        // region with the current anon region binding (in other words,\n+        // whatever & would get replaced with).\n+        let self_r = alt rp {\n+          ast::rp_none { none }\n+          ast::rp_self {\n+            let res = rscope.anon_region();\n+            let r = get_region_reporting_err(self.tcx(), sp, res);\n+            some(r)\n+          }\n+        };\n+\n+        // Convert the type parameters supplied by the user.\n         if vec::len(args) != vec::len(*bounds) {\n             tcx.sess.span_fatal(\n-                sp, \"wrong number of type arguments for a \\\n-                     polymorphic type\");\n+                sp, #fmt[\"wrong number of type arguments, \\\n+                          expected %u but found %u\",\n+                         vec::len(*bounds),\n+                         vec::len(args)]);\n         }\n-        let param_bindings = args.map { |t| ast_ty_to_ty(self, rscope, t) };\n-        #debug(\"substituting(%? into %?)\",\n-               vec::map(param_bindings) {|t| ty_to_str(tcx, t)},\n-               ty_to_str(tcx, ty));\n-        let ty = ty::substitute_type_params(tcx, param_bindings, ty);\n-        write_substs_to_tcx(tcx, path_id, param_bindings);\n+        let tps = args.map { |t| ast_ty_to_ty(self, rscope, t) };\n+\n+        // Perform the substitution and store the tps for future ref.\n+        let substs = {self_r: self_r, tps: tps};\n+        let ty = ty::subst(tcx, substs, ty);\n+        write_substs_to_tcx(tcx, path_id, substs.tps);\n         ret ty;\n     }\n \n@@ -636,24 +680,29 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n     }\n     alt it.node {\n       ast::item_const(t, _) {\n-        let typ = ccx.to_ty(t);\n-        let tpt = {bounds: @[], ty: typ};\n+        let typ = ccx.to_ty(empty_rscope, t);\n+        let tpt = no_params(typ);\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n       ast::item_fn(decl, tps, _) {\n-        ret ty_of_fn(ccx, decl, tps, local_def(it.id));\n+        let bounds = ty_param_bounds(ccx, tps);\n+        let tofd = ty_of_fn_decl(ccx, empty_rscope, ast::proto_bare, decl);\n+        let tpt = {bounds: bounds,\n+                   rp: ast::rp_none, // functions do not have a self\n+                   ty: ty::mk_fn(ccx.tcx, tofd)};\n+        ccx.tcx.tcache.insert(local_def(it.id), tpt);\n+        ret tpt;\n       }\n-      ast::item_ty(t, tps) {\n+      ast::item_ty(t, tps, rp) {\n         alt tcx.tcache.find(local_def(it.id)) {\n           some(tpt) { ret tpt; }\n           none { }\n         }\n-        // Tell ast_ty_to_ty() that we want to perform a recursive\n-        // call to resolve any named types.\n+\n         let tpt = {\n             let ty = {\n-                let t0 = ccx.to_ty(t);\n+                let t0 = ccx.to_ty(type_rscope(rp), t);\n                 // Do not associate a def id with a named, parameterized type\n                 // like \"foo<X>\".  This is because otherwise ty_to_str will\n                 // print the name as merely \"foo\", as it has no way to\n@@ -662,38 +711,39 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n                     ty::mk_with_id(tcx, t0, def_id)\n                 }\n             };\n-            {bounds: ty_param_bounds(ccx, tps), ty: ty}\n+            {bounds: ty_param_bounds(ccx, tps), rp: rp, ty: ty}\n         };\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n-      ast::item_res(decl, tps, _, _, _) {\n-        let {bounds, params} = mk_ty_params(ccx, tps);\n-        let t_arg = ty_of_arg(ccx, base_rscope, decl.inputs[0]);\n-        let t = ty::mk_res(tcx, local_def(it.id), t_arg.ty, params);\n-        let t_res = {bounds: bounds, ty: t};\n+      ast::item_res(decl, tps, _, _, _, rp) {\n+        let {bounds, substs} = mk_substs(ccx, tps, rp);\n+        let t_arg = ty_of_arg(ccx, empty_rscope, decl.inputs[0]);\n+        let t = ty::mk_res(tcx, local_def(it.id), t_arg.ty, substs);\n+        let t_res = {bounds: bounds, rp: rp, ty: t};\n         tcx.tcache.insert(local_def(it.id), t_res);\n         ret t_res;\n       }\n-      ast::item_enum(_, tps) {\n+      ast::item_enum(_, tps, rp) {\n         // Create a new generic polytype.\n-        let {bounds, params} = mk_ty_params(ccx, tps);\n-        let t = ty::mk_enum(tcx, local_def(it.id), params);\n-        let tpt = {bounds: bounds, ty: t};\n+        let {bounds, substs} = mk_substs(ccx, tps, rp);\n+        let t = ty::mk_enum(tcx, local_def(it.id), substs);\n+        let tpt = {bounds: bounds, rp: rp, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n       ast::item_iface(tps, ms) {\n         let {bounds, params} = mk_ty_params(ccx, tps);\n         let t = ty::mk_iface(tcx, local_def(it.id), params);\n-        let tpt = {bounds: bounds, ty: t};\n+        // NDM iface/impl regions\n+        let tpt = {bounds: bounds, rp: ast::rp_none, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n-      ast::item_class(tps,_,_,_) {\n-          let {bounds,params} = mk_ty_params(ccx, tps);\n-          let t = ty::mk_class(tcx, local_def(it.id), params);\n-          let tpt = {bounds: bounds, ty: t};\n+      ast::item_class(tps, _, _, _, rp) {\n+          let {bounds,substs} = mk_substs(ccx, tps, rp);\n+          let t = ty::mk_class(tcx, local_def(it.id), substs);\n+          let tpt = {bounds: bounds, rp: rp, ty: t};\n           tcx.tcache.insert(local_def(it.id), tpt);\n           ret tpt;\n       }\n@@ -713,57 +763,50 @@ fn ty_of_native_item(ccx: @crate_ctxt, it: @ast::native_item)\n \n type next_region_param_id = { mut id: uint };\n \n-fn collect_named_regions_in_tys(\n+fn collect_bound_regions_in_tys(\n     tcx: ty::ctxt,\n     isr: isr_alist,\n     tys: [ty::t],\n-    to_r: fn(str) -> ty::region) -> isr_alist {\n+    to_r: fn(ty::bound_region) -> ty::region) -> isr_alist {\n \n     tys.foldl(isr) { |isr, t|\n-        collect_named_regions_in_ty(tcx, isr, t, to_r)\n+        collect_bound_regions_in_ty(tcx, isr, t, to_r)\n     }\n }\n \n-fn collect_named_regions_in_ty(\n-    _tcx: ty::ctxt,\n+fn collect_bound_regions_in_ty(\n+    tcx: ty::ctxt,\n     isr: isr_alist,\n     ty: ty::t,\n-    to_r: fn(str) -> ty::region) -> isr_alist {\n+    to_r: fn(ty::bound_region) -> ty::region) -> isr_alist {\n \n     fn append_isr(isr: isr_alist,\n-                  to_r: fn(str) -> ty::region,\n+                  to_r: fn(ty::bound_region) -> ty::region,\n                   r: ty::region) -> isr_alist {\n         alt r {\n           ty::re_free(_, _) | ty::re_static | ty::re_scope(_) |\n-          ty::re_var(_) | ty::re_bound(ty::br_anon) |\n-          ty::re_bound(ty::br_self) {\n+          ty::re_var(_) {\n             isr\n           }\n-          ty::re_bound(br @ ty::br_named(id)) {\n-            alt isr.find(id) {\n+          ty::re_bound(br) {\n+            alt isr.find(br) {\n               some(_) { isr }\n-              none { @cons((id, to_r(id)), isr) }\n+              none { @cons((br, to_r(br)), isr) }\n             }\n           }\n         }\n     }\n \n     let mut isr = isr;\n \n-    ty::maybe_walk_ty(ty) {|t|\n-        alt ty::get(t).struct {\n-          // do not walk fn contents\n-          ty::ty_fn(_) { false }\n-\n-          // collect named regions into the isr list\n-          ty::ty_evec(_, ty::vstore_slice(r)) |\n-          ty::ty_estr(ty::vstore_slice(r)) |\n-          ty::ty_rptr(r, _) { isr = append_isr(isr, to_r, r); true }\n-\n-          // otherwise just walk the types\n-          _ { true }\n-        }\n-    }\n+    // Using fold_regions is inefficient, because it constructs new types, but\n+    // it avoids code duplication in terms of locating all the regions within\n+    // the various kinds of types.  This had already caused me several bugs\n+    // so I decided to switch over.\n+    ty::fold_regions(tcx, ty) { |r, in_fn|\n+        if !in_fn { isr = append_isr(isr, to_r, r); }\n+        r\n+    };\n \n     ret isr;\n }\n@@ -781,36 +824,34 @@ fn replace_bound_self(\n fn replace_bound_regions(\n     tcx: ty::ctxt,\n     span: span,\n-    anon_r: ty::region,\n     isr: isr_alist,\n     ty: ty::t) -> ty::t {\n \n     ty::fold_regions(tcx, ty) { |r, in_fn|\n         alt r {\n-          ty::re_bound(ty::br_named(id)) {\n-            alt isr.find(id) {\n+          // As long as we are not within a fn() type, `&T` is mapped to the\n+          // free region anon_r.  But within a fn type, it remains bound.\n+          ty::re_bound(ty::br_anon) if in_fn { r }\n+\n+          ty::re_bound(br) {\n+            alt isr.find(br) {\n               // In most cases, all named, bound regions will be mapped to\n               // some free region.\n               some(fr) { fr }\n \n               // But in the case of a fn() type, there may be named regions\n               // within that remain bound:\n-              none { assert in_fn; r }\n+              none if in_fn { r }\n+              none {\n+                tcx.sess.span_bug(\n+                    span,\n+                    #fmt[\"Bound region not found in \\\n+                          in_scope_regions list: %s\",\n+                         region_to_str(tcx, r)]);\n+              }\n             }\n           }\n \n-          // As long as we are not within a fn() type, `&T` is mapped to the\n-          // free region anon_r.  But within a fn type, it remains bound.\n-          ty::re_bound(ty::br_anon) if !in_fn { anon_r }\n-          ty::re_bound(ty::br_anon) { r }\n-\n-          // The &self region is special.  Any bound references to self should\n-          // have already been replaced using replace_bound_self() when\n-          // this function is called.\n-          ty::re_bound(ty::br_self) {\n-            tcx.sess.span_bug(span, \"Bound self region found\");\n-          }\n-\n           // Free regions like these just stay the same:\n           ty::re_static |\n           ty::re_scope(_) |\n@@ -870,25 +911,13 @@ fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy>(\n     }\n }\n \n-fn ty_of_fn(ccx: @crate_ctxt,\n-            decl: ast::fn_decl,\n-            ty_params: [ast::ty_param],\n-            def_id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n-\n-    let bounds = ty_param_bounds(ccx, ty_params);\n-    let tofd = ty_of_fn_decl(ccx, base_rscope, ast::proto_bare, decl);\n-    let tpt = {bounds: bounds, ty: ty::mk_fn(ccx.tcx, tofd)};\n-    ccx.tcx.tcache.insert(def_id, tpt);\n-    ret tpt;\n-}\n-\n fn ty_of_native_fn_decl(ccx: @crate_ctxt,\n                         decl: ast::fn_decl,\n                         ty_params: [ast::ty_param],\n                         def_id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n \n     let bounds = ty_param_bounds(ccx, ty_params);\n-    let rb = in_binding_rscope(base_rscope);\n+    let rb = in_binding_rscope(empty_rscope);\n     let input_tys = vec::map(decl.inputs) { |a| ty_of_arg(ccx, rb, a) };\n     let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n \n@@ -897,7 +926,7 @@ fn ty_of_native_fn_decl(ccx: @crate_ctxt,\n                                    output: output_ty,\n                                    ret_style: ast::return_val,\n                                    constraints: []});\n-    let tpt = {bounds: bounds, ty: t_fn};\n+    let tpt = {bounds: bounds, rp: ast::rp_none, ty: t_fn};\n     ccx.tcx.tcache.insert(def_id, tpt);\n     ret tpt;\n }\n@@ -909,21 +938,23 @@ fn ty_param_bounds(ccx: @crate_ctxt,\n         alt ccx.tcx.ty_param_bounds.find(param.id) {\n           some(bs) { bs }\n           none {\n-            let bounds = @vec::map(*param.bounds) { |b|\n+            let bounds = @vec::flat_map(*param.bounds) { |b|\n                 alt b {\n-                  ast::bound_send { ty::bound_send }\n-                  ast::bound_copy { ty::bound_copy }\n+                  ast::bound_send { [ty::bound_send] }\n+                  ast::bound_copy { [ty::bound_copy] }\n                   ast::bound_iface(t) {\n-                    let ity = ccx.to_ty(t);\n+                    let ity = ccx.to_ty(empty_rscope, t);\n                     alt ty::get(ity).struct {\n-                      ty::ty_iface(_, _) {}\n+                      ty::ty_iface(_, _) {\n+                        [ty::bound_iface(ity)]\n+                      }\n                       _ {\n-                        ccx.tcx.sess.span_fatal(\n+                        ccx.tcx.sess.span_err(\n                             t.span, \"type parameter bounds must be \\\n                                      interface types\");\n+                        []\n                       }\n                     }\n-                    ty::bound_iface(ity)\n                   }\n                 }\n             };\n@@ -934,66 +965,50 @@ fn ty_param_bounds(ccx: @crate_ctxt,\n     }\n }\n \n-fn ty_of_method(ccx: @crate_ctxt, m: @ast::method) -> ty::method {\n+fn ty_of_method(ccx: @crate_ctxt,\n+                m: @ast::method,\n+                rp: ast::region_param) -> ty::method {\n     {ident: m.ident, tps: ty_param_bounds(ccx, m.tps),\n-     fty: ty_of_fn_decl(ccx, base_rscope, ast::proto_bare, m.decl),\n+     fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare, m.decl),\n      purity: m.decl.purity, privacy: m.privacy}\n }\n \n fn ty_of_ty_method(self: @crate_ctxt, m: ast::ty_method) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(self, m.tps),\n-     fty: ty_of_fn_decl(self, base_rscope, ast::proto_bare, m.decl),\n+     fty: ty_of_fn_decl(self, empty_rscope, ast::proto_bare, m.decl),\n      // assume public, because this is only invoked on iface methods\n      purity: m.decl.purity, privacy: ast::pub}\n }\n \n-// A wrapper around ast_ty_to_ty_crate that handles ty_infer.\n-fn ast_ty_to_ty_infer(fcx: @fn_ctxt, &&ast_ty: @ast::ty) -> option<ty::t> {\n-    alt ast_ty.node {\n-      ast::ty_infer { none }\n-      _ { some(fcx.to_ty(ast_ty)) }\n-    }\n-}\n-\n-\n // Functions that write types into the node type table\n fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n     #debug[\"write_ty_to_tcx(%d, %s)\", node_id, ty_to_str(tcx, ty)];\n     smallintmap::insert(*tcx.node_types, node_id as uint, ty);\n }\n-fn write_substs_to_tcx(tcx: ty::ctxt, node_id: ast::node_id,\n+fn write_substs_to_tcx(tcx: ty::ctxt,\n+                       node_id: ast::node_id,\n                        +substs: [ty::t]) {\n     if substs.len() > 0u {\n         tcx.node_type_substs.insert(node_id, substs);\n     }\n }\n-fn write_ty_substs_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t,\n-                   +substs: [ty::t]) {\n-    if substs.len() == 0u {\n-        write_ty_to_tcx(tcx, node_id, ty);\n-    } else {\n-        let ty = ty::substitute_type_params(tcx, substs, ty);\n-        write_ty_to_tcx(tcx, node_id, ty);\n-        write_substs_to_tcx(tcx, node_id, substs);\n-    }\n-}\n \n impl methods for @crate_ctxt {\n-    fn to_ty(ast_ty: @ast::ty) -> ty::t {\n-        ast_ty_to_ty(self, base_rscope, ast_ty)\n-    }\n-\n-    fn to_self_ty(ast_ty: @ast::ty) -> ty::t {\n-        ast_ty_to_ty(self, self_rscope, ast_ty)\n+    fn to_ty<RS: region_scope copy>(rs: RS, ast_ty: @ast::ty) -> ty::t {\n+        ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n impl methods for isr_alist {\n-    fn find(id: str) -> option<ty::region> {\n+    fn get(br: ty::bound_region) -> ty::region {\n+        option::get(self.find(br))\n+    }\n+\n+    fn find(br: ty::bound_region) -> option<ty::region> {\n         for list::each(*self) { |isr|\n-            let (isr_id, isr_r) = isr;\n-            if isr_id == id { ret some(isr_r); }\n+            let (isr_br, isr_r) = isr;\n+            if isr_br == br { ret some(isr_r); }\n         }\n         ret none;\n     }\n@@ -1009,18 +1024,17 @@ impl methods for @fn_ctxt {\n                node_id, ty_to_str(self.tcx(), ty), self.tag()];\n         self.node_types.insert(node_id as uint, ty);\n     }\n-    fn write_substs(node_id: ast::node_id, +substs: [ty::t]) {\n-        self.node_type_substs.insert(node_id, substs);\n-    }\n-    fn write_ty_substs(node_id: ast::node_id, ty: ty::t, +substs: [ty::t]) {\n-        if substs.len() == 0u {\n-            self.write_ty(node_id, ty)\n-        } else {\n-            let ty = ty::substitute_type_params(self.tcx(), substs, ty);\n-            self.write_ty(node_id, ty);\n-            self.write_substs(node_id, substs);\n+    fn write_substs(node_id: ast::node_id, +substs: ty::substs) {\n+        if !ty::substs_is_noop(substs) {\n+            self.node_type_substs.insert(node_id, substs);\n         }\n     }\n+    fn write_ty_substs(node_id: ast::node_id, ty: ty::t,\n+                       +substs: ty::substs) {\n+        let ty = ty::subst(self.tcx(), substs, ty);\n+        self.write_ty(node_id, ty);\n+        self.write_substs(node_id, substs);\n+    }\n     fn write_nil(node_id: ast::node_id) {\n         self.write_ty(node_id, ty::mk_nil(self.tcx()));\n     }\n@@ -1052,7 +1066,7 @@ impl methods for @fn_ctxt {\n           }\n         }\n     }\n-    fn node_ty_substs(id: ast::node_id) -> [ty::t] {\n+    fn node_ty_substs(id: ast::node_id) -> ty::substs {\n         alt self.node_type_substs.find(id) {\n           some(ts) { ts }\n           none {\n@@ -1063,7 +1077,7 @@ impl methods for @fn_ctxt {\n           }\n         }\n     }\n-    fn opt_node_ty_substs(id: ast::node_id) -> option<[ty::t]> {\n+    fn opt_node_ty_substs(id: ast::node_id) -> option<ty::substs> {\n         self.node_type_substs.find(id)\n     }\n     fn next_ty_var_id() -> ty_vid {\n@@ -1109,6 +1123,17 @@ fn mk_ty_params(ccx: @crate_ctxt, atps: [ast::ty_param])\n      })}\n }\n \n+fn mk_substs(ccx: @crate_ctxt, atps: [ast::ty_param], rp: ast::region_param)\n+    -> {bounds: @[ty::param_bounds], substs: ty::substs} {\n+\n+    let {bounds, params} = mk_ty_params(ccx, atps);\n+    let self_r = alt rp {\n+      ast::rp_self { some(ty::re_bound(ty::br_self)) }\n+      ast::rp_none { none }\n+    };\n+    {bounds: bounds, substs: {self_r: self_r, tps: params}}\n+}\n+\n fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n                        impl_tps: uint, if_m: ty::method, substs: [ty::t],\n                        self_ty: ty::t) -> ty::t {\n@@ -1134,12 +1159,13 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n             }\n         });\n         let impl_fty = ty::mk_fn(tcx, {inputs: auto_modes with impl_m.fty});\n+\n         // Add dummy substs for the parameters of the impl method\n         let substs = substs + vec::from_fn(vec::len(*if_m.tps), {|i|\n             ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n         });\n         let mut if_fty = ty::mk_fn(tcx, if_m.fty);\n-        if_fty = ty::substitute_type_params(tcx, substs, if_fty);\n+        if_fty = ty::subst_tps(tcx, substs, if_fty);\n         if_fty = fixup_self_full(tcx, if_fty, substs, self_ty, impl_tps);\n         require_same_types(\n             tcx, sp, impl_fty, if_fty,\n@@ -1167,7 +1193,7 @@ fn fixup_self_full(cx: ty::ctxt, mty: ty::t, m_substs: [ty::t],\n             // context.\n             let mut substs = vec::map(tps) {|t|\n                 let f = fixup_self_full(cx, t, m_substs, selfty, impl_n_tps);\n-                ty::substitute_type_params(cx, m_substs, f)\n+                ty::subst_tps(cx, m_substs, f)\n             };\n \n             // Add extra substs for impl type parameters.\n@@ -1185,7 +1211,7 @@ fn fixup_self_full(cx: ty::ctxt, mty: ty::t, m_substs: [ty::t],\n             }\n \n             // And then instantiate the self type using all those.\n-            ty::substitute_type_params(cx, substs, selfty)\n+            ty::subst_tps(cx, substs, selfty)\n           }\n           _ {\n               t\n@@ -1212,7 +1238,7 @@ fn fixup_self_param(fcx: @fn_ctxt, mty: ty::t, m_substs: [ty::t],\n             // context.\n             let mut substs = vec::map(tps) {|t|\n                 let f = fixup_self_param(fcx, t, m_substs, selfty, sp);\n-                ty::substitute_type_params(tcx, m_substs, f)\n+                ty::subst_tps(tcx, m_substs, f)\n             };\n \n             // Simply ensure that the type parameters for the self\n@@ -1251,7 +1277,6 @@ fn instantiate_bound_regions(tcx: ty::ctxt, region: ty::region, &&ty: ty::t)\n     }\n }\n \n-\n // Item collection - a pair of bootstrap passes:\n //\n // (1) Collect the IDs of all type items (typedefs) and store them in a table.\n@@ -1263,9 +1288,11 @@ fn instantiate_bound_regions(tcx: ty::ctxt, region: ty::region, &&ty: ty::t)\n // We then annotate the AST with the resulting types and return the annotated\n // AST, along with a table mapping item IDs to their types.\n mod collect {\n-    fn get_enum_variant_types(ccx: @crate_ctxt, enum_ty: ty::t,\n+    fn get_enum_variant_types(ccx: @crate_ctxt,\n+                              enum_ty: ty::t,\n                               variants: [ast::variant],\n-                              ty_params: [ast::ty_param]) {\n+                              ty_params: [ast::ty_param],\n+                              rp: ast::region_param) {\n         let tcx = ccx.tcx;\n \n         // Create a set of parameter types shared among all the variants.\n@@ -1277,17 +1304,19 @@ mod collect {\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n+                let rs = type_rscope(rp);\n                 let args = variant.node.args.map { |va|\n-                    {mode: ast::expl(ast::by_copy),\n-                     ty: ccx.to_ty(va.ty)}\n+                    let arg_ty = ccx.to_ty(rs, va.ty);\n+                    {mode: ast::expl(ast::by_copy), ty: arg_ty}\n                 };\n-                // FIXME: this will be different for constrained types\n-                ty::mk_fn(tcx,\n-                          {proto: ast::proto_box,\n-                           inputs: args, output: enum_ty,\n-                           ret_style: ast::return_val, constraints: []})\n+                ty::mk_fn(tcx, {proto: ast::proto_box,\n+                                inputs: args,\n+                                output: enum_ty,\n+                                ret_style: ast::return_val,\n+                                constraints: []})\n             };\n             let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n+                       rp: ast::rp_none,\n                        ty: result_ty};\n             tcx.tcache.insert(local_def(variant.node.id), tpt);\n             write_ty_to_tcx(tcx, variant.node.id, result_ty);\n@@ -1307,25 +1336,28 @@ mod collect {\n                   ty_of_ty_method(ccx, m)\n               };\n           }\n-          ast_map::node_item(@{node: ast::item_class(_,_,its,_), _}, _) {\n+          ast_map::node_item(@{node: ast::item_class(_,_,its,_,rp), _}, _) {\n               let (_,ms) = split_class_items(its);\n               // All methods need to be stored, since lookup_method\n               // relies on the same method cache for self-calls\n               store_methods::<@ast::method>(ccx, id, ms) {|m|\n-                  ty_of_method(ccx, m)\n+                  ty_of_method(ccx, m, rp)\n               };\n           }\n         }\n     }\n \n-    fn check_methods_against_iface(ccx: @crate_ctxt, tps: [ast::ty_param],\n-                                   selfty: ty::t, t: @ast::ty,\n+    fn check_methods_against_iface(ccx: @crate_ctxt,\n+                                   tps: [ast::ty_param],\n+                                   rp: ast::region_param,\n+                                   selfty: ty::t,\n+                                   t: @ast::ty,\n                                    ms: [@ast::method]) {\n \n         let tcx = ccx.tcx;\n         let i_bounds = ty_param_bounds(ccx, tps);\n-        let my_methods = convert_methods(ccx, ms, i_bounds, some(selfty));\n-        let iface_ty = ccx.to_ty(t);\n+        let my_methods = convert_methods(ccx, ms, rp, i_bounds, selfty);\n+        let iface_ty = ccx.to_ty(empty_rscope, t);\n         alt ty::get(iface_ty).struct {\n           ty::ty_iface(did, tys) {\n             // Store the iface type in the type node\n@@ -1352,9 +1384,11 @@ mod collect {\n                         if_m, tys, selfty);\n                     let old = tcx.tcache.get(local_def(id));\n                     if old.ty != mt {\n-                        tcx.tcache.insert(local_def(id),\n-                                          {bounds: old.bounds,\n-                                           ty: mt});\n+                        tcx.tcache.insert(\n+                            local_def(id),\n+                            {bounds: old.bounds,\n+                             rp: old.rp,\n+                             ty: mt});\n                         write_ty_to_tcx(tcx, id, mt);\n                     }\n                   }\n@@ -1372,37 +1406,32 @@ mod collect {\n       }\n     }\n \n-    fn convert_class_item(ccx: @crate_ctxt, v: ast_util::ivar) {\n-        /* we want to do something here, b/c within the\n-         scope of the class, it's ok to refer to fields &\n-        methods unqualified */\n-\n+    fn convert_class_item(ccx: @crate_ctxt,\n+                          rp: ast::region_param,\n+                          v: ast_util::ivar) {\n         /* they have these types *within the scope* of the\n          class. outside the class, it's done with expr_field */\n-        let tt = ccx.to_self_ty(v.ty);\n+        let tt = ccx.to_ty(type_rscope(rp), v.ty);\n         #debug(\"convert_class_item: %s %?\", v.ident, v.id);\n         write_ty_to_tcx(ccx.tcx, v.id, tt);\n     }\n \n-    fn convert_methods(ccx: @crate_ctxt, ms: [@ast::method],\n+    fn convert_methods(ccx: @crate_ctxt,\n+                       ms: [@ast::method],\n+                       rp: ast::region_param,\n                        i_bounds: @[ty::param_bounds],\n-                       maybe_self: option<ty::t>)\n+                       self_ty: ty::t)\n         -> [{mty: ty::method, id: ast::node_id, span: span}] {\n \n         let tcx = ccx.tcx;\n         vec::map(ms) { |m|\n-            alt maybe_self {\n-              some(selfty) {\n-                write_ty_to_tcx(tcx, m.self_id, selfty);\n-              }\n-             _ {}\n-           }\n+            write_ty_to_tcx(tcx, m.self_id, self_ty);\n             let bounds = ty_param_bounds(ccx, m.tps);\n-            let mty = ty_of_method(ccx, m);\n+            let mty = ty_of_method(ccx, m, rp);\n             let fty = ty::mk_fn(tcx, mty.fty);\n-            tcx.tcache.insert(local_def(m.id),\n-                              {bounds: @(*i_bounds + *bounds),\n-                               ty: fty});\n+            tcx.tcache.insert(\n+                local_def(m.id),\n+                {bounds: @(*i_bounds + *bounds), rp: rp, ty: fty});\n             write_ty_to_tcx(tcx, m.id, fty);\n             {mty: mty, id: m.id, span: m.span}\n         }\n@@ -1419,36 +1448,45 @@ mod collect {\n                 for m.items.each { |item| check_intrinsic_type(ccx, item); }\n             }\n           }\n-          ast::item_enum(variants, ty_params) {\n+          ast::item_enum(variants, ty_params, rp) {\n             let tpt = ty_of_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, tpt.ty);\n-            get_enum_variant_types(ccx, tpt.ty, variants, ty_params);\n+            get_enum_variant_types(ccx, tpt.ty, variants,\n+                                   ty_params, rp);\n           }\n           ast::item_impl(tps, ifce, selfty, ms) {\n             let i_bounds = ty_param_bounds(ccx, tps);\n-            let selfty = ccx.to_self_ty(selfty);\n+            // NDM iface/impl regions\n+            let selfty = ccx.to_ty(empty_rscope, selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n             tcx.tcache.insert(local_def(it.id),\n-                              {bounds: i_bounds, ty: selfty});\n+                              {bounds: i_bounds,\n+                               rp: ast::rp_none, // NDM iface/impl regions\n+                               ty: selfty});\n             alt ifce {\n               some(t) {\n-                check_methods_against_iface(ccx, tps, selfty, t, ms);\n+                check_methods_against_iface(\n+                    ccx, tps, ast::rp_none, // NDM iface/impl regions\n+                    selfty, t, ms);\n               }\n               _ {\n                 // Still have to do this to write method types\n                 // into the table\n-                convert_methods(ccx, ms, i_bounds, some(selfty));\n+                convert_methods(\n+                    ccx, ms, ast::rp_none, // NDM iface/impl regions\n+                    i_bounds, selfty);\n               }\n             }\n           }\n-          ast::item_res(decl, tps, _, dtor_id, ctor_id) {\n-            let {bounds, params} = mk_ty_params(ccx, tps);\n+          ast::item_res(decl, tps, _, dtor_id, ctor_id, rp) {\n+            let {bounds, substs} = mk_substs(ccx, tps, rp);\n             let def_id = local_def(it.id);\n-            let t_arg = ty_of_arg(ccx, base_rscope, decl.inputs[0]);\n-            let t_res = ty::mk_res(tcx, def_id, t_arg.ty, params);\n+            let t_arg = ty_of_arg(ccx, type_rscope(rp), decl.inputs[0]);\n+            let t_res = ty::mk_res(tcx, def_id, t_arg.ty, substs);\n+\n             let t_ctor = ty::mk_fn(tcx, {\n                 proto: ast::proto_box,\n-                inputs: [{mode: ast::expl(ast::by_copy) with t_arg}],\n+                inputs: [{mode: ast::expl(ast::by_copy), ty: t_arg.ty}],\n                 output: t_res,\n                 ret_style: ast::return_val, constraints: []\n             });\n@@ -1460,66 +1498,81 @@ mod collect {\n             write_ty_to_tcx(tcx, it.id, t_res);\n             write_ty_to_tcx(tcx, ctor_id, t_ctor);\n             tcx.tcache.insert(local_def(ctor_id),\n-                              {bounds: bounds, ty: t_ctor});\n-            tcx.tcache.insert(def_id, {bounds: bounds, ty: t_res});\n+                              {bounds: bounds,\n+                               rp: ast::rp_none,\n+                               ty: t_ctor});\n+            tcx.tcache.insert(def_id, {bounds: bounds,\n+                                       rp: ast::rp_none,\n+                                       ty: t_res});\n             write_ty_to_tcx(tcx, dtor_id, t_dtor);\n           }\n           ast::item_iface(_, ms) {\n             let tpt = ty_of_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, tpt.ty);\n             ensure_iface_methods(ccx, it.id);\n           }\n-          ast::item_class(tps, ifaces, members, ctor) {\n-              // Write the class type\n-              let tpt = ty_of_item(ccx, it);\n-              write_ty_to_tcx(tcx, it.id, tpt.ty);\n-              // Write the ctor type\n-              let t_ctor =\n-                  ty::mk_fn(tcx,\n-                            ty_of_fn_decl(ccx, base_rscope,\n-                                          ast::proto_any,\n-                                          ctor.node.dec));\n-              write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n-              tcx.tcache.insert(local_def(ctor.node.id),\n-                                   {bounds: tpt.bounds, ty: t_ctor});\n-              ensure_iface_methods(ccx, it.id);\n-              /* FIXME: check for proper public/privateness */\n-              // Write the type of each of the members\n-              let (fields, methods) = split_class_items(members);\n-              for fields.each {|f|\n-                 convert_class_item(ccx, f);\n-              }\n-              // The selfty is just the class type\n-              let selfty = ty::mk_class(tcx, local_def(it.id),\n-                                        mk_ty_params(ccx, tps).params);\n-              // Need to convert all methods so we can check internal\n-              // references to private methods\n-              convert_methods(ccx, methods, @[], some(selfty));\n-              /*\n-                Finally, check that the class really implements the ifaces\n-                that it claims to implement.\n-               */\n-              for ifaces.each {|ifce|\n+          ast::item_class(tps, ifaces, members, ctor, rp) {\n+            // Write the class type\n+            let tpt = ty_of_item(ccx, it);\n+            write_ty_to_tcx(tcx, it.id, tpt.ty);\n+            // Write the ctor type\n+            let t_ctor =\n+                ty::mk_fn(tcx,\n+                          ty_of_fn_decl(ccx,\n+                                        empty_rscope,\n+                                        ast::proto_any,\n+                                        ctor.node.dec));\n+            write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n+            tcx.tcache.insert(local_def(ctor.node.id),\n+                              {bounds: tpt.bounds,\n+                               rp: ast::rp_none, // NDM self->anon\n+                               ty: t_ctor});\n+            ensure_iface_methods(ccx, it.id);\n+            /* FIXME: check for proper public/privateness */\n+            // Write the type of each of the members\n+            let (fields, methods) = split_class_items(members);\n+            for fields.each {|f|\n+                convert_class_item(ccx, rp, f);\n+            }\n+            // The selfty is just the class type\n+            let {bounds:_, substs} = mk_substs(ccx, tps, rp);\n+            let selfty = ty::mk_class(tcx, local_def(it.id), substs);\n+            // Need to convert all methods so we can check internal\n+            // references to private methods\n+\n+            // NDM to TJC---I think we ought to be using bounds here, not @[].\n+            // But doing so causes errors later on.\n+            convert_methods(ccx, methods, rp, @[], selfty);\n+\n+            /*\n+            Finally, check that the class really implements the ifaces\n+            that it claims to implement.\n+            */\n+            for ifaces.each { |ifce|\n                 alt lookup_def_tcx(tcx, it.span, ifce.id) {\n-                   ast::def_ty(t_id) {\n-                     let t = ty::lookup_item_type(tcx, t_id).ty;\n-                     alt ty::get(t).struct {\n-                        ty::ty_iface(_,_) {\n-                          write_ty_to_tcx(tcx, ifce.id, t);\n-                            check_methods_against_iface(ccx, tps, selfty,\n-                               @{id: ifce.id,\n-                                 node: ast::ty_path(ifce.path, ifce.id),\n-                                 span: ifce.path.span},\n-                               methods);\n-                        }\n-                        _ { tcx.sess.span_fatal(ifce.path.span,\n-                           \"can only implement interface types\"); }\n-                     }\n-                   }\n-                   _ { tcx.sess.span_err(ifce.path.span, \"not an interface \\\n-                           type\"); }\n-                };\n-              }\n+                  ast::def_ty(t_id) {\n+                    let t = ty::lookup_item_type(tcx, t_id).ty;\n+                    alt ty::get(t).struct {\n+                      ty::ty_iface(_,_) {\n+                        write_ty_to_tcx(tcx, ifce.id, t);\n+                        check_methods_against_iface(\n+                            ccx, tps, rp, selfty,\n+                            @{id: ifce.id,\n+                              node: ast::ty_path(ifce.path, ifce.id),\n+                              span: ifce.path.span},\n+                            methods);\n+                      }\n+                      _ {\n+                        tcx.sess.span_fatal(\n+                            ifce.path.span,\n+                            \"can only implement interface types\");\n+                      }\n+                    }\n+                  }\n+                  _ { tcx.sess.span_err(ifce.path.span, \"not an interface \\\n+                                                         type\"); }\n+                }\n+            }\n           }\n           _ {\n             // This call populates the type cache with the converted type\n@@ -1577,10 +1630,10 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n             }\n             t1 = inner.ty;\n           }\n-          ty::ty_res(_, inner, tps) {\n-            t1 = ty::substitute_type_params(fcx.ccx.tcx, tps, inner);\n+          ty::ty_res(_, inner, substs) {\n+            t1 = ty::subst(fcx.ccx.tcx, substs, inner);\n           }\n-          ty::ty_enum(did, tps) {\n+          ty::ty_enum(did, substs) {\n             // Watch out for a type like `enum t = @t`.  Such a type would\n             // otherwise infinitely auto-deref.  This is the only autoderef\n             // loop that needs to be concerned with this, as an error will be\n@@ -1595,9 +1648,7 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n             if vec::len(*variants) != 1u || vec::len(variants[0].args) != 1u {\n                 ret t1;\n             }\n-            t1 =\n-                ty::substitute_type_params(fcx.ccx.tcx, tps,\n-                                           variants[0].args[0]);\n+            t1 = ty::subst(fcx.ccx.tcx, substs, variants[0].args[0]);\n           }\n           _ { ret t1; }\n         }\n@@ -1613,7 +1664,7 @@ fn resolve_type_vars_if_possible(fcx: @fn_ctxt, typ: ty::t) -> ty::t {\n \n // Demands - procedures that require that two types unify and emit an error\n // message if they don't.\n-type ty_param_substs_and_ty = {substs: [ty::t], ty: ty::t};\n+type ty_param_substs_and_ty = {substs: ty::substs, ty: ty::t};\n \n fn require_same_types(\n     tcx: ty::ctxt,\n@@ -1669,30 +1720,6 @@ fn are_compatible(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) -> bool {\n }\n \n \n-// Returns the types of the arguments to a enum variant.\n-fn variant_arg_types(ccx: @crate_ctxt, _sp: span, vid: ast::def_id,\n-                     enum_ty_params: [ty::t]) -> [ty::t] {\n-    let mut result: [ty::t] = [];\n-    let tpt = ty::lookup_item_type(ccx.tcx, vid);\n-    alt ty::get(tpt.ty).struct {\n-      ty::ty_fn(f) {\n-        // N-ary variant.\n-        for f.inputs.each {|arg|\n-            let arg_ty =\n-                ty::substitute_type_params(ccx.tcx, enum_ty_params, arg.ty);\n-            result += [arg_ty];\n-        }\n-      }\n-      _ {\n-        // Nullary variant. Do nothing, as there are no arguments.\n-      }\n-    }\n-    /* result is a vector of the *expected* types of all the fields */\n-\n-    ret result;\n-}\n-\n-\n // Type resolution: the phase that finds all the types in the AST with\n // unresolved type variables and replaces \"ty_var\" types with their\n // substitutions.\n@@ -1734,14 +1761,14 @@ mod writeback {\n             write_ty_to_tcx(tcx, id, t);\n             alt fcx.opt_node_ty_substs(id) {\n               some(substs) {\n-                let mut new_substs = [];\n-                for substs.each {|subst|\n+                let mut new_tps = [];\n+                for substs.tps.each {|subst|\n                     alt resolve_type_vars_in_type(fcx, sp, subst) {\n-                      some(t) { new_substs += [t]; }\n+                      some(t) { new_tps += [t]; }\n                       none { wbcx.success = false; ret none; }\n                     }\n                 }\n-                write_substs_to_tcx(tcx, id, new_substs);\n+                write_substs_to_tcx(tcx, id, new_tps);\n               }\n               none {}\n             }\n@@ -1959,14 +1986,6 @@ type pat_ctxt = {\n     pat_region: ty::region\n };\n \n-fn subst_anon_region(tcx: ty::ctxt,\n-                     with_r: ty::region,\n-                     ty: ty::t) -> ty::t {\n-    ty::fold_regions(tcx, ty) {|r, in_fn|\n-        if !in_fn && r == ty::re_bound(ty::br_anon) {with_r} else {r}\n-    }\n-}\n-\n // Helper for the other universally_quantify_*() routines.  Extracts the bound\n // regions from bound_tys and then replaces those same regions with fresh\n // variables in `sty`, returning the resulting type.\n@@ -1979,12 +1998,11 @@ fn universally_quantify_from_sty(fcx: @fn_ctxt,\n            bound_tys.map {|x| fcx.ty_to_str(x) }];\n     indent {||\n         let tcx = fcx.tcx();\n-        let isr = collect_named_regions_in_tys(tcx, @nil, bound_tys) { |_id|\n+        let isr = collect_bound_regions_in_tys(tcx, @nil, bound_tys) { |_id|\n             fcx.next_region_var()\n         };\n-        let anon_r = fcx.next_region_var();\n         ty::fold_sty_to_ty(fcx.ccx.tcx, sty) { |t|\n-            replace_bound_regions(tcx, span, anon_r, isr, t)\n+            replace_bound_regions(tcx, span, isr, t)\n         }\n     }\n }\n@@ -2012,18 +2030,6 @@ fn universally_quantify_before_call(fcx: @fn_ctxt,\n     // introduce a level of binding.  In this case, we want to process the\n     // types bound by the function but not by any nested functions.\n     // Therefore, we match one level of structure.\n-    //\n-    // Specifically what we do is:\n-    // - Find the set of named regions that appear in arguments, return\n-    //   type, etc. We use collect_named_regions_in_ty(), which\n-    //   returns a free version of the region---not quite what we want.\n-    //\n-    // - So then we map the resulting map so that we each bound region\n-    //   will be mapped to a fresh variable.\n-    //\n-    // - Finally, we can use fold_sty_to_ty() and replace_bound_regions()\n-    //   to replace the bound regions as well as the bound anonymous region.\n-    //   We have to use fold_sty_to_ty() to ignore the outer fn().\n     alt structure_of(fcx, span, ty) {\n       sty @ ty::ty_fn(fty) {\n         let all_tys = fty.inputs.map({|a| a.ty}) + [fty.output];\n@@ -2056,19 +2062,20 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n \n     // Take the enum type params out of `expected`.\n     alt structure_of(pcx.fcx, pat.span, expected) {\n-      ty::ty_enum(_, expected_tps) {\n+      ty::ty_enum(_, expected_substs) {\n         // check that the type of the value being matched is a subtype\n         // of the type of the pattern:\n         let pat_ty = fcx.node_ty(pat.id);\n         demand::suptype(fcx, pat.span, pat_ty, expected);\n \n-        // Get the number of arguments in this enum variant.\n-        let arg_types = variant_arg_types(pcx.fcx.ccx, pat.span,\n-                                          v_def_ids.var, expected_tps);\n-        let arg_types = vec::map(arg_types) {|t|\n-            // NDM---is this reasonable?\n-            instantiate_bound_regions(pcx.fcx.ccx.tcx, pcx.pat_region, t)\n+        // Get the expected types of the arguments.\n+        let arg_types = {\n+            let vinfo =\n+                ty::enum_variant_with_id(\n+                    tcx, v_def_ids.enm, v_def_ids.var);\n+            vinfo.args.map { |t| ty::subst(tcx, expected_substs, t) }\n         };\n+\n         let subpats_len = subpats.len(), arg_len = arg_types.len();\n         if arg_len > 0u {\n             // N-ary variant.\n@@ -2079,14 +2086,14 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n                              if subpats_len == 1u { \"\" } else { \"s\" },\n                              arg_len,\n                              if arg_len == 1u { \"\" } else { \"s\" }];\n-                tcx.sess.span_err(pat.span, s);\n+                tcx.sess.span_fatal(pat.span, s);\n             }\n \n             vec::iter2(subpats, arg_types) {|subpat, arg_ty|\n                 check_pat(pcx, subpat, arg_ty);\n             }\n         } else if subpats_len > 0u {\n-            tcx.sess.span_err\n+            tcx.sess.span_fatal\n                 (pat.span, #fmt[\"this pattern has %u field%s, \\\n                                  but the corresponding variant has no fields\",\n                                 subpats_len,\n@@ -2095,10 +2102,10 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n         }\n       }\n       _ {\n-        tcx.sess.span_err\n+        tcx.sess.span_fatal\n             (pat.span,\n              #fmt[\"mismatched types: expected enum but found `%s`\",\n-                  ty_to_str(tcx, expected)]);\n+                  fcx.ty_to_str(expected)]);\n       }\n     }\n }\n@@ -2345,8 +2352,10 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n          raw_ty: ity.ty}\n     };\n \n-    let substs = fcx.next_ty_vars(n_tps);\n-    let substd_ty = ty::substitute_type_params(tcx, substs, raw_ty);\n+    let self_r = none; // NDM iface/impl regions\n+    let tps = fcx.next_ty_vars(n_tps);\n+    let substs = {self_r: self_r, tps: tps};\n+    let substd_ty = ty::subst(tcx, substs, raw_ty);\n     {substs: substs, ty: substd_ty}\n }\n \n@@ -2375,8 +2384,8 @@ impl methods for lookup {\n           ty::ty_iface(did, tps) {\n             self.method_from_iface(did, tps)\n           }\n-          ty::ty_class(did, tps) {\n-            self.method_from_class(did, tps)\n+          ty::ty_class(did, substs) {\n+            self.method_from_class(did, substs)\n           }\n           _ {\n             none\n@@ -2413,9 +2422,12 @@ impl methods for lookup {\n               }\n \n               some(pos) {\n-                  ret some(self.write_mty_from_m(\n-                      some(self.self_ty), bound_tps, ifce_methods[pos],\n-                      method_param(iid, pos, n, iface_bnd_idx)));\n+                let bound_substs = { // NDM iface/impl regions\n+                    self_r: none, tps: bound_tps\n+                };\n+                ret some(self.write_mty_from_m(\n+                    some(self.self_ty), bound_substs, ifce_methods[pos],\n+                    method_param(iid, pos, n, iface_bnd_idx)));\n               }\n             }\n         }\n@@ -2445,15 +2457,19 @@ impl methods for lookup {\n                      boxed iface\");\n             }\n \n+            let iface_substs = { // NDM iface/impl regions\n+                self_r: none, tps: iface_tps\n+            };\n+\n             ret some(self.write_mty_from_m(\n-                none, iface_tps, m,\n+                none, iface_substs, m,\n                 method_iface(did, i)));\n         }\n \n         ret none;\n     }\n \n-    fn method_from_class(did: ast::def_id, class_tps: [ty::t])\n+    fn method_from_class(did: ast::def_id, class_substs: ty::substs)\n         -> option<method_origin> {\n \n         let ms = *ty::iface_methods(self.tcx(), did);\n@@ -2473,7 +2489,7 @@ impl methods for lookup {\n                 self.tcx(), did, self.m_name, self.expr.span);\n \n             ret some(self.write_mty_from_m(\n-                none, class_tps, m,\n+                none, class_substs, m,\n                 method_static(m_declared)));\n         }\n \n@@ -2484,7 +2500,8 @@ impl methods for lookup {\n         if did.crate == ast::local_crate {\n             alt check self.tcx().items.get(did.node) {\n               ast_map::node_method(m, _, _) {\n-                let mt = ty_of_method(self.fcx.ccx, m);\n+                // NDM iface/impl regions\n+                let mt = ty_of_method(self.fcx.ccx, m, ast::rp_none);\n                 ty::mk_fn(self.tcx(), {proto: ast::proto_box with mt.fty})\n               }\n             }\n@@ -2551,7 +2568,7 @@ impl methods for lookup {\n     }\n \n     fn write_mty_from_m(self_ty_sub: option<ty::t>,\n-                        self_substs: [ty::t],\n+                        self_substs: ty::substs,\n                         m: ty::method,\n                         origin: method_origin) -> method_origin {\n         let tcx = self.fcx.ccx.tcx;\n@@ -2565,7 +2582,7 @@ impl methods for lookup {\n     }\n \n     fn write_mty_from_fty(self_ty_sub: option<ty::t>,\n-                          self_substs: [ty::t],\n+                          self_substs: ty::substs,\n                           n_tps_m: uint,\n                           fty: ty::t,\n                           origin: method_origin) -> method_origin {\n@@ -2596,7 +2613,8 @@ impl methods for lookup {\n             }\n         };\n \n-        let all_substs = self_substs + m_substs;\n+        let all_substs = {self_r: self_substs.self_r,\n+                          tps: self_substs.tps + m_substs};\n         self.fcx.write_ty_substs(self.node_id, fty, all_substs);\n \n         // FIXME--this treatment of self and regions seems wrong.  As a rule\n@@ -2610,7 +2628,7 @@ impl methods for lookup {\n         if has_self && !option::is_none(self_ty_sub) {\n             let fty = self.fcx.node_ty(self.node_id);\n             let fty = fixup_self_param(\n-                self.fcx, fty, all_substs, self_ty_sub.get(),\n+                self.fcx, fty, all_substs.tps, self_ty_sub.get(),\n                 self.expr.span);\n             self.fcx.write_ty(self.node_id, fty);\n         }\n@@ -2630,7 +2648,7 @@ impl methods for lookup {\n // FIXME: privacy flags\n fn lookup_field_ty(tcx: ty::ctxt, class_id: ast::def_id,\n                    items:[ty::field_ty], fieldname: ast::ident,\n-                   substs: [ty::t]) -> option<ty::t> {\n+                   substs: ty::substs) -> option<ty::t> {\n \n     let o_field = vec::find(items, {|f| f.ident == fieldname});\n     option::map(o_field) {|f|\n@@ -3083,7 +3101,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               ty::ty_box(inner) { oper_t = inner.ty; }\n               ty::ty_uniq(inner) { oper_t = inner.ty; }\n               ty::ty_res(_, inner, _) { oper_t = inner; }\n-              ty::ty_enum(id, tps) {\n+              ty::ty_enum(id, substs) {\n                 let variants = ty::enum_variants(tcx, id);\n                 if vec::len(*variants) != 1u ||\n                        vec::len(variants[0].args) != 1u {\n@@ -3092,8 +3110,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                         \"with a single variant which has a \"\n                                             + \"single argument\");\n                 }\n-                oper_t =\n-                    ty::substitute_type_params(tcx, tps, variants[0].args[0]);\n+                oper_t = ty::subst(tcx, substs, variants[0].args[0]);\n               }\n               ty::ty_ptr(inner) {\n                 oper_t = inner.ty;\n@@ -3493,7 +3510,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               _ {}\n             }\n           }\n-          ty::ty_class(base_id, params) {\n+          ty::ty_class(base_id, substs) {\n               // This is just for fields -- the same code handles\n               // methods in both classes and ifaces\n \n@@ -3512,7 +3529,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               else {\n                   lookup_public_fields(tcx, base_id)\n               };\n-              alt lookup_field_ty(tcx, base_id, cls_items, field, params) {\n+              alt lookup_field_ty(tcx, base_id, cls_items, field, substs) {\n                  some(field_ty) {\n                     // (2) look up what field's type is, and return it\n                     // FIXME: actually instantiate any type params\n@@ -3801,8 +3818,10 @@ fn check_instantiable(tcx: ty::ctxt,\n     }\n }\n \n-fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n-                      id: ast::node_id) {\n+fn check_enum_variants(ccx: @crate_ctxt,\n+                       sp: span,\n+                       vs: [ast::variant],\n+                       id: ast::node_id) {\n     // FIXME: this is kinda a kludge; we manufacture a fake function context\n     // and statement context for checking the initializer expression.\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n@@ -4005,34 +4024,39 @@ fn check_fn(ccx: @crate_ctxt,\n \n     let tcx = ccx.tcx;\n \n-    // See big comment in region.rs.\n     let isr = {\n+        // Find the list of in-scope regions.  These are derived from the\n+        // various regions that are bound in the argument, return, and self\n+        // types.  For each of those bound regions, we will create a mapping\n+        // to a free region tied to the node_id of this function.  For an\n+        // in-depth discussion of why we must distinguish bound/free regions,\n+        // see the big comment in region.rs.\n         let all_tys = arg_tys + [ret_ty] + self_ty.to_vec();\n         let old_isr = option::map_default(old_fcx, @nil) {\n             |fcx| fcx.in_scope_regions };\n-        collect_named_regions_in_tys(tcx, old_isr, all_tys) {\n-            |id| ty::re_free(fid, ty::br_named(id)) }\n+        collect_bound_regions_in_tys(tcx, old_isr, all_tys) {\n+            |br| ty::re_free(fid, br) }\n     };\n-    let anon_r = ty::re_free(fid, ty::br_anon);\n-    let self_r = ty::re_free(fid, ty::br_self);\n-    let arg_tys = arg_tys.map {|arg_ty|\n-        let arg_ty = replace_bound_self(tcx, self_r, arg_ty);\n-        replace_bound_regions(tcx, body.span, anon_r, isr, arg_ty)\n+\n+    // Replace the bound regions that appear in the arg tys, ret ty, etc with\n+    // the free versions we just collected.\n+    let arg_tys = arg_tys.map {\n+        |arg_ty| replace_bound_regions(tcx, body.span, isr, arg_ty)\n     };\n-    let ret_ty = replace_bound_self(tcx, self_r, ret_ty);\n-    let ret_ty = replace_bound_regions(tcx, body.span, anon_r, isr, ret_ty);\n-    let self_ty = option::map(self_ty) {|self_ty|\n-        let self_ty = replace_bound_self(tcx, self_r, self_ty);\n-        replace_bound_regions(tcx, body.span, anon_r, isr, self_ty)\n+    let ret_ty = {\n+        replace_bound_regions(tcx, body.span, isr, ret_ty)\n+    };\n+    let self_ty = option::map(self_ty) {\n+        |self_ty| replace_bound_regions(tcx, body.span, isr, self_ty)\n     };\n \n     #debug[\"check_fn(arg_tys=%?, ret_ty=%?, self_ty=%?)\",\n            arg_tys.map {|a| ty_to_str(tcx, a) },\n            ty_to_str(tcx, ret_ty),\n            option::map(self_ty) {|st| ty_to_str(tcx, st) }];\n \n-    // If old_fcx is some(...), this is a block fn { |x| ... }.\n-    // In that case, the purity is inherited from the context.\n+    // Create the function context.  This is either derived from scratch or,\n+    // in the case of function expressions, based on the outer context.\n     let fcx: @fn_ctxt = {\n         let {infcx, locals, tvc, rvc, purity,\n              node_types, node_type_substs} = alt old_fcx {\n@@ -4184,16 +4208,20 @@ fn check_method(ccx: @crate_ctxt, method: @ast::method, self_ty: ty::t) {\n     check_bare_fn(ccx, method.decl, method.body, method.id, some(self_ty));\n }\n \n-fn class_types(ccx: @crate_ctxt, members: [@ast::class_member]) -> class_map {\n+fn class_types(ccx: @crate_ctxt, members: [@ast::class_member],\n+               rp: ast::region_param) -> class_map {\n+\n     let rslt = int_hash::<ty::t>();\n-    for members.each {|m|\n+    let rs = type_rscope(rp);\n+    for members.each { |m|\n       alt m.node {\n          ast::instance_var(_,t,_,id,_) {\n-           rslt.insert(id, ccx.to_ty(t));\n+           rslt.insert(id, ccx.to_ty(rs, t));\n          }\n          ast::class_method(mth) {\n-             rslt.insert(mth.id, ty::mk_fn(ccx.tcx,\n-                ty_of_method(ccx, mth).fty));\n+           rslt.insert(mth.id,\n+                       ty::mk_fn(ccx.tcx,\n+                                 ty_of_method(ccx, mth, rp).fty));\n          }\n       }\n     }\n@@ -4213,24 +4241,26 @@ fn check_class_member(ccx: @crate_ctxt, class_t: ty::t,\n fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     alt it.node {\n       ast::item_const(_, e) { check_const(ccx, it.span, e, it.id); }\n-      ast::item_enum(vs, _) { check_enum_variants(ccx, it.span, vs, it.id); }\n+      ast::item_enum(vs, _, _) {\n+        check_enum_variants(ccx, it.span, vs, it.id);\n+      }\n       ast::item_fn(decl, tps, body) {\n         check_bare_fn(ccx, decl, body, it.id, none);\n       }\n-      ast::item_res(decl, tps, body, dtor_id, _) {\n+      ast::item_res(decl, tps, body, dtor_id, _, rp) {\n         check_instantiable(ccx.tcx, it.span, it.id);\n         check_bare_fn(ccx, decl, body, dtor_id, none);\n       }\n       ast::item_impl(tps, _, ty, ms) {\n-        let self_ty = ccx.to_self_ty(ty);\n+        let self_ty = ccx.to_ty(empty_rscope, ty); // NDM iface/impl regions\n         let self_region = ty::re_free(it.id, ty::br_self);\n         let self_ty = replace_self_region(ccx.tcx, self_region, self_ty);\n         for ms.each {|m| check_method(ccx, m, self_ty);}\n       }\n-      ast::item_class(tps, ifaces, members, ctor) {\n+      ast::item_class(tps, ifaces, members, ctor, rp) {\n           let cid = some(it.id), tcx = ccx.tcx;\n           let class_t = ty::node_id_to_type(tcx, it.id);\n-          let members_info = class_types(ccx, members);\n+          let members_info = class_types(ccx, members, rp);\n           // can also ditch the enclosing_class stuff once we move to self\n           // FIXME\n           let class_ccx = @{enclosing_class_id:cid,\n@@ -4330,7 +4360,7 @@ mod vtable {\n             for vec::each(*bounds[i]) {|bound|\n                 alt bound {\n                   ty::bound_iface(i_ty) {\n-                    let i_ty = ty::substitute_type_params(tcx, tys, i_ty);\n+                    let i_ty = ty::subst_tps(tcx, tys, i_ty);\n                     result += [lookup_vtable(fcx, isc, sp, ty, i_ty,\n                                              allow_unsafe)];\n                   }\n@@ -4398,7 +4428,7 @@ mod vtable {\n                           _ { false }\n                         };\n                         if match {\n-                            let {substs: vars, ty: self_ty} =\n+                            let {substs: substs, ty: self_ty} =\n                                 impl_self_ty(fcx, im.did);\n                             let im_bs =\n                                 ty::lookup_item_type(tcx, im.did).bounds;\n@@ -4409,6 +4439,7 @@ mod vtable {\n                                         sp, \"multiple applicable implemen\\\n                                              tations in scope\");\n                                 } else {\n+                                    let vars = substs.tps;\n                                     connect_iface_tps(fcx, sp, vars,\n                                                       iface_tps, im.did);\n                                     let params = vec::map(vars, {|t|\n@@ -4456,7 +4487,7 @@ mod vtable {\n                          iface_tys: [ty::t], impl_did: ast::def_id) {\n         let tcx = fcx.ccx.tcx;\n         let ity = option::get(ty::impl_iface(tcx, impl_did));\n-        let iface_ty = ty::substitute_type_params(tcx, impl_tys, ity);\n+        let iface_ty = ty::subst_tps(tcx, impl_tys, ity);\n         alt check ty::get(iface_ty).struct {\n           ty::ty_iface(_, tps) {\n             vec::iter2(tps, iface_tys,\n@@ -4470,13 +4501,15 @@ mod vtable {\n         alt ex.node {\n           ast::expr_path(_) {\n             alt fcx.opt_node_ty_substs(ex.id) {\n-              some(ts) {\n+              some(substs) {\n+                let ts = substs.tps; // NDM regions for iface/impls\n                 let did = ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id));\n                 let item_ty = ty::lookup_item_type(cx.tcx, did);\n                 if has_iface_bounds(*item_ty.bounds) {\n                     let impls = cx.impl_map.get(ex.id);\n                     cx.vtable_map.insert(ex.id, lookup_vtables(\n-                        fcx, impls, ex.span, item_ty.bounds, ts, false));\n+                        fcx, impls, ex.span,\n+                        item_ty.bounds, ts, false));\n                 }\n               }\n               _ {}\n@@ -4494,7 +4527,8 @@ mod vtable {\n                       ast::expr_field(_, _, _) { ex.id }\n                       _ { ast_util::op_expr_callee_id(ex) }\n                     };\n-                    let ts = fcx.node_ty_substs(callee_id);\n+                    // NDM iface/impl regions\n+                    let ts = fcx.node_ty_substs(callee_id).tps;\n                     let iscs = cx.impl_map.get(ex.id);\n                     cx.vtable_map.insert(callee_id, lookup_vtables(\n                         fcx, iscs, ex.span, bounds, ts, false));"}, {"sha": "30e20883e529a6c21bf56f862ede87ca5bfff3a0", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -10,11 +10,12 @@ import syntax::{ast, ast_util};\n import middle::ast_map;\n import driver::session::session;\n \n-fn bound_region_to_str(_cx: ctxt, br: bound_region) -> str {\n+fn bound_region_to_str(cx: ctxt, br: bound_region) -> str {\n     alt br {\n-      br_anon          { \"&\" }\n-      br_named(str)    { #fmt[\"&%s\", str] }\n-      br_self          { \"&self\" }\n+      br_anon                             { \"&\" }\n+      br_named(str)                       { #fmt[\"&%s\", str] }\n+      br_self if cx.sess.opts.debug_rustc { \"&<self>\" }\n+      br_self                             { \"&self\" }\n     }\n }\n \n@@ -127,12 +128,23 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     fn field_to_str(cx: ctxt, f: field) -> str {\n         ret f.ident + \": \" + mt_to_str(cx, f.mt);\n     }\n-    fn parameterized(cx: ctxt, base: str, tps: [ty::t]) -> str {\n+    fn parameterized(cx: ctxt,\n+                     base: str,\n+                     self_r: option<ty::region>,\n+                     tps: [ty::t]) -> str {\n+\n+        let r_str = alt self_r {\n+          none { \"\" }\n+          some(r) {\n+            #fmt[\"/%s\", region_to_str(cx, r)]\n+          }\n+        };\n+\n         if vec::len(tps) > 0u {\n             let strs = vec::map(tps, {|t| ty_to_str(cx, t)});\n-            #fmt[\"%s<%s>\", base, str::connect(strs, \",\")]\n+            #fmt[\"%s%s<%s>\", base, r_str, str::connect(strs, \",\")]\n         } else {\n-            base\n+            #fmt[\"%s%s\", base, r_str]\n         }\n     }\n \n@@ -141,9 +153,11 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n       some(def_id) {\n         let cs = ast_map::path_to_str(ty::item_path(cx, def_id));\n         ret alt ty::get(typ).struct {\n-          ty_enum(_, tps) | ty_res(_, _, tps) | ty_iface(_, tps) |\n-          ty_class(_, tps) {\n-            parameterized(cx, cs, tps)\n+          ty_enum(_, substs) | ty_res(_, _, substs) | ty_class(_, substs) {\n+            parameterized(cx, cs, substs.self_r, substs.tps)\n+          }\n+          ty_iface(_, tps) {\n+            parameterized(cx, cs, none, tps)\n           }\n           _ { cs }\n         };\n@@ -164,7 +178,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n       ty_float(ast::ty_f) { \"float\" }\n       ty_float(t) { ast_util::float_ty_to_str(t) }\n       ty_str { \"str\" }\n-      ty_self(ts) { parameterized(cx, \"self\", ts) }\n+      ty_self(ts) { parameterized(cx, \"self\", none, ts) }\n       ty_box(tm) { \"@\" + mt_to_str(cx, tm) }\n       ty_uniq(tm) { \"~\" + mt_to_str(cx, tm) }\n       ty_ptr(tm) { \"*\" + mt_to_str(cx, tm) }\n@@ -196,11 +210,15 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n       ty_param(id, _) {\n         \"'\" + str::from_bytes([('a' as u8) + (id as u8)])\n       }\n-      ty_enum(did, tps) | ty_res(did, _, tps) | ty_iface(did, tps) |\n-      ty_class(did, tps) {\n+      ty_enum(did, substs) | ty_res(did, _, substs) | ty_class(did, substs) {\n+        let path = ty::item_path(cx, did);\n+        let base = ast_map::path_to_str(path);\n+        parameterized(cx, base, substs.self_r, substs.tps)\n+      }\n+      ty_iface(did, tps) {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path);\n-        parameterized(cx, base, tps)\n+        parameterized(cx, base, none, tps)\n       }\n       ty_evec(mt, vs) {\n         #fmt[\"[%s]/%s\", mt_to_str(cx, mt),"}, {"sha": "674d7a7fc3b9ce0d88eb7bbf154cadbe660acd71", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -147,7 +147,7 @@ fn fold_enum(\n             let desc = astsrv::exec(srv) {|ctxt|\n                 alt check ctxt.ast_map.get(doc_id) {\n                   ast_map::node_item(@{\n-                    node: ast::item_enum(ast_variants, _), _\n+                    node: ast::item_enum(ast_variants, _, _), _\n                   }, _) {\n                     let ast_variant = option::get(\n                         vec::find(ast_variants) {|v|"}, {"sha": "e9cfdc4db90a5f94853d51616664e946c6ae9df0", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -78,12 +78,12 @@ fn moddoc_from_mod(\n                     constdoc_from_const(itemdoc)\n                 ))\n               }\n-              ast::item_enum(variants, _) {\n+              ast::item_enum(variants, _, _) {\n                 some(doc::enumtag(\n                     enumdoc_from_enum(itemdoc, variants)\n                 ))\n               }\n-              ast::item_res(_, _, _, _, _) {\n+              ast::item_res(_, _, _, _, _, _) {\n                 some(doc::restag(\n                     resdoc_from_resource(itemdoc)\n                 ))\n@@ -98,7 +98,7 @@ fn moddoc_from_mod(\n                     impldoc_from_impl(itemdoc, methods)\n                 ))\n               }\n-              ast::item_ty(_, _) {\n+              ast::item_ty(_, _, _) {\n                 some(doc::tytag(\n                     tydoc_from_ty(itemdoc)\n                 ))"}, {"sha": "3e5ac07f0938cbdca97c9f3fe2b41264a71c2512", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -112,7 +112,7 @@ fn fold_enum(\n             let sig = astsrv::exec(srv) {|ctxt|\n                 alt check ctxt.ast_map.get(doc_id) {\n                   ast_map::node_item(@{\n-                    node: ast::item_enum(ast_variants, _), _\n+                    node: ast::item_enum(ast_variants, _, _), _\n                   }, _) {\n                     let ast_variant = option::get(\n                         vec::find(ast_variants) {|v|\n@@ -149,9 +149,9 @@ fn fold_res(\n         sig: some(astsrv::exec(srv) {|ctxt|\n             alt check ctxt.ast_map.get(doc.id()) {\n               ast_map::node_item(@{\n-                node: ast::item_res(decl, tys, _, _, _), _\n+                node: ast::item_res(decl, tys, _, _, _, rp), _\n               }, _) {\n-                pprust::res_to_str(decl, doc.name(), tys)\n+                pprust::res_to_str(decl, doc.name(), tys, rp)\n               }\n             }\n         })\n@@ -303,7 +303,7 @@ fn fold_type(\n             alt ctxt.ast_map.get(doc.id()) {\n               ast_map::node_item(@{\n                 ident: ident,\n-                node: ast::item_ty(ty, params), _\n+                node: ast::item_ty(ty, params, ast::rp_none), _\n               }, _) {\n                 some(#fmt(\n                     \"type %s%s = %s\","}, {"sha": "bbe6667ced61b3b0f6f8083bd16460424263d078", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -2,7 +2,7 @@ use std;\n import std::arena;\n import std::arena::arena;\n \n-enum tree { nil, node(&tree, &tree, int), }\n+enum tree& { nil, node(&tree, &tree, int), }\n \n fn item_check(t: &tree) -> int {\n     alt *t {"}, {"sha": "ae90feadd57e09f8311d45aeec39b822f1e901bb", "filename": "src/test/compile-fail/regions-creating-enums.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -0,0 +1,33 @@\n+enum ast& {\n+    num(uint),\n+    add(&ast, &ast)\n+}\n+\n+fn build() {\n+    let x = num(3u);\n+    let y = num(4u);\n+    let z = add(&x, &y);\n+    compute(&z);\n+}\n+\n+fn compute(x: &ast) -> uint {\n+    alt *x {\n+      num(x) { x }\n+      add(x, y) { compute(x) + compute(y) }\n+    }\n+}\n+\n+fn map_nums(x: &ast, f: fn(uint) -> uint) -> &ast {\n+    alt *x {\n+      num(x) {\n+        ret &num(f(x)); //! ERROR mismatched types: expected `&ast/&` but found\n+      }\n+      add(x, y) {\n+        let m_x = map_nums(x, f);\n+        let m_y = map_nums(y, f);\n+        ret &add(m_x, m_y);  //! ERROR mismatched types: expected `&ast/&` but found\n+      }\n+    }\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "4585c781739afca8238fe0ad0de7b8aa9a3138d9", "filename": "src/test/compile-fail/regions-in-enums.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -0,0 +1,25 @@\n+enum no0 {\n+    x0(&uint) //! ERROR to use region types here, the containing type must be declared with a region bound\n+}\n+\n+enum no1 {\n+    x1(&self.uint) //! ERROR to use region types here, the containing type must be declared with a region bound\n+}\n+\n+enum no2 {\n+    x2(&foo.uint) //! ERROR named regions other than `self` are not allowed as part of a type declaration\n+}\n+\n+enum yes0& {\n+    x3(&uint)\n+}\n+\n+enum yes1& {\n+    x4(&self.uint)\n+}\n+\n+enum yes2& {\n+    x5(&foo.uint) //! ERROR named regions other than `self` are not allowed as part of a type declaration\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "3b0e61d6163e5048443bc3d93401c473acbd034b", "filename": "src/test/compile-fail/regions-in-rsrcs.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Ftest%2Fcompile-fail%2Fregions-in-rsrcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Ftest%2Fcompile-fail%2Fregions-in-rsrcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-rsrcs.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -0,0 +1,19 @@\n+resource no0(x: &uint) { //! ERROR to use region types here, the containing type must be declared with a region bound\n+}\n+\n+resource no1(x: &self.uint) { //! ERROR to use region types here, the containing type must be declared with a region bound\n+}\n+\n+resource no2(x: &foo.uint) { //! ERROR named regions other than `self` are not allowed as part of a type declaration\n+}\n+\n+resource yes0&(x: &uint) {\n+}\n+\n+resource yes1&(x: &self.uint) {\n+}\n+\n+resource yes2&(x: &foo.uint) { //! ERROR named regions other than `self` are not allowed as part of a type declaration\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "80d734d9992e79a0f83b489bc81a44f528d28ee3", "filename": "src/test/compile-fail/regions-in-type-items.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Ftest%2Fcompile-fail%2Fregions-in-type-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Ftest%2Fcompile-fail%2Fregions-in-type-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-type-items.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -0,0 +1,25 @@\n+type item_ty_no0 = {\n+    x: &uint //! ERROR to use region types here, the containing type must be declared with a region bound\n+};\n+\n+type item_ty_no1 = {\n+    x: &self.uint //! ERROR to use region types here, the containing type must be declared with a region bound\n+};\n+\n+type item_ty_no2 = {\n+    x: &foo.uint //! ERROR named regions other than `self` are not allowed as part of a type declaration\n+};\n+\n+type item_ty_yes0& = {\n+    x: &uint\n+};\n+\n+type item_ty_yes1& = {\n+    x: &self.uint\n+};\n+\n+type item_ty_yes2& = {\n+    x: &foo.uint //! ERROR named regions other than `self` are not allowed as part of a type declaration\n+};\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "4273675e4dab36f182521c78bde578e040b2e7fa", "filename": "src/test/compile-fail/seq-args.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Ftest%2Fcompile-fail%2Fseq-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Ftest%2Fcompile-fail%2Fseq-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fseq-args.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -2,8 +2,7 @@ use std;\n fn main() {\n iface seq { }\n \n-impl <T> of seq<T> for [T] {\n-    //!^ ERROR wrong number of type arguments for a polymorphic type\n+impl <T> of seq<T> for [T] { //! ERROR wrong number of type arguments\n     /* ... */\n }\n impl of seq<bool> for u32 {"}, {"sha": "4801524c55f9dfd8cda8df8df0018fbf4ca978dc", "filename": "src/test/run-pass/regions-mock-trans-impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -2,11 +2,11 @@ import libc, sys, unsafe;\n \n enum arena = ();\n \n-type bcx = {\n+type bcx& = {\n     fcx: &fcx\n };\n \n-type fcx = {\n+type fcx& = {\n     arena: &arena,\n     ccx: &ccx\n };"}, {"sha": "959319381c6f0797ca593697e616641de3c2f211", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c995fb8f3676a313f5ac883e175cc5fe354e640/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=3c995fb8f3676a313f5ac883e175cc5fe354e640", "patch": "@@ -2,11 +2,11 @@ import libc, sys, unsafe;\n \n enum arena = ();\n \n-type bcx = {\n+type bcx& = {\n     fcx: &fcx\n };\n \n-type fcx = {\n+type fcx& = {\n     arena: &arena,\n     ccx: &ccx\n };"}]}