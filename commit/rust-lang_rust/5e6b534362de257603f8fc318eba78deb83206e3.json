{"sha": "5e6b534362de257603f8fc318eba78deb83206e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNmI1MzQzNjJkZTI1NzYwM2Y4ZmMzMThlYmE3OGRlYjgzMjA2ZTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-24T16:36:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-24T16:36:32Z"}, "message": "Auto merge of #27087 - nikomatsakis:closure-exploration, r=nrc\n\nRefactors the \"desugaring\" of closures to expose the types of the upvars. This is necessary to be faithful with how actual structs work. The reasoning of the particular desugaring that I chose is explained in a fairly detailed comment.\r\n\r\nAs a side-effect, recursive closure types are prohibited unless a trait object intermediary is used. This fixes #25954 and also eliminates concerns about unrepresentable closure types that have infinite size, I believe. I don't believe this can cause regressions because of #25954.\r\n\r\n(As for motivation, besides #25954 etc, this work is also intended as refactoring in support of incremental compilation, since closures are one of the thornier cases encountered when attempting to split node-ids into item-ids and within-item-ids. The goal is to eliminate the \"internal def-id\" distinction in astdecoding. However, I have to do more work on trans to really make progress there.)\r\n\r\nr? @nrc", "tree": {"sha": "35a5516d09c3cb4da6fbec652460293a9e261c98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35a5516d09c3cb4da6fbec652460293a9e261c98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e6b534362de257603f8fc318eba78deb83206e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e6b534362de257603f8fc318eba78deb83206e3", "html_url": "https://github.com/rust-lang/rust/commit/5e6b534362de257603f8fc318eba78deb83206e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e6b534362de257603f8fc318eba78deb83206e3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fb8ab04bcdd93f522b594da72a966f39a5268b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fb8ab04bcdd93f522b594da72a966f39a5268b0", "html_url": "https://github.com/rust-lang/rust/commit/0fb8ab04bcdd93f522b594da72a966f39a5268b0"}, {"sha": "71d44189e04d714a64c304f00a7ebfd48150b93a", "url": "https://api.github.com/repos/rust-lang/rust/commits/71d44189e04d714a64c304f00a7ebfd48150b93a", "html_url": "https://github.com/rust-lang/rust/commit/71d44189e04d714a64c304f00a7ebfd48150b93a"}], "stats": {"total": 913, "additions": 539, "deletions": 374}, "files": [{"sha": "72e1525b506d13edc96722dfb35977812a4017d2", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -564,8 +564,13 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n           assert_eq!(next(st), '[');\n           let did = parse_def_(st, ClosureSource, conv);\n           let substs = parse_substs_(st, conv);\n+          let mut tys = vec![];\n+          while peek(st) != '.' {\n+              tys.push(parse_ty_(st, conv));\n+          }\n+          assert_eq!(next(st), '.');\n           assert_eq!(next(st), ']');\n-          return st.tcx.mk_closure(did, st.tcx.mk_substs(substs));\n+          return st.tcx.mk_closure(did, st.tcx.mk_substs(substs), tys);\n       }\n       'P' => {\n           assert_eq!(next(st), '[');"}, {"sha": "c77e96f1648882da676ae3c8b966b9ed1d856be2", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -143,9 +143,13 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::TyClosure(def, substs) => {\n+        ty::TyClosure(def, ref substs) => {\n             mywrite!(w, \"k[{}|\", (cx.ds)(def));\n-            enc_substs(w, cx, substs);\n+            enc_substs(w, cx, &substs.func_substs);\n+            for ty in &substs.upvar_tys {\n+                enc_ty(w, cx, ty);\n+            }\n+            mywrite!(w, \".\");\n             mywrite!(w, \"]\");\n         }\n         ty::TyProjection(ref data) => {"}, {"sha": "469aacaf50677df1ab735b856633dbd5ff10c88e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -256,7 +256,10 @@ macro_rules! return_if_err {\n     ($inp: expr) => (\n         match $inp {\n             Ok(v) => v,\n-            Err(()) => return\n+            Err(()) => {\n+                debug!(\"mc reported err\");\n+                return\n+            }\n         }\n     )\n }"}, {"sha": "102cd001a296a563d070117c4a8c08749c24db47", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -40,7 +40,6 @@ impl FreeRegionMap {\n                     self.relate_free_regions(free_a, free_b);\n                 }\n                 Implication::RegionSubRegion(..) |\n-                Implication::RegionSubClosure(..) |\n                 Implication::RegionSubGeneric(..) |\n                 Implication::Predicate(..) => {\n                 }"}, {"sha": "799d9a653ae38be181ba141ecfa92ebefc2a4a73", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -28,7 +28,6 @@ use util::nodemap::FnvHashSet;\n pub enum Implication<'tcx> {\n     RegionSubRegion(Option<Ty<'tcx>>, ty::Region, ty::Region),\n     RegionSubGeneric(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n-    RegionSubClosure(Option<Ty<'tcx>>, ty::Region, ast::DefId, &'tcx Substs<'tcx>),\n     Predicate(ast::DefId, ty::Predicate<'tcx>),\n }\n \n@@ -96,9 +95,47 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                 // No borrowed content reachable here.\n             }\n \n-            ty::TyClosure(def_id, substs) => {\n-                let &(r_a, opt_ty) = self.stack.last().unwrap();\n-                self.out.push(Implication::RegionSubClosure(opt_ty, r_a, def_id, substs));\n+            ty::TyClosure(_, ref substs) => {\n+                // FIXME(#27086). We do not accumulate from substs, since they\n+                // don't represent reachable data. This means that, in\n+                // practice, some of the lifetime parameters might not\n+                // be in scope when the body runs, so long as there is\n+                // no reachable data with that lifetime. For better or\n+                // worse, this is consistent with fn types, however,\n+                // which can also encapsulate data in this fashion\n+                // (though it's somewhat harder, and typically\n+                // requires virtual dispatch).\n+                //\n+                // Note that changing this (in a naive way, at least)\n+                // causes regressions for what appears to be perfectly\n+                // reasonable code like this:\n+                //\n+                // ```\n+                // fn foo<'a>(p: &Data<'a>) {\n+                //    bar(|q: &mut Parser| q.read_addr())\n+                // }\n+                // fn bar(p: Box<FnMut(&mut Parser)+'static>) {\n+                // }\n+                // ```\n+                //\n+                // Note that `p` (and `'a`) are not used in the\n+                // closure at all, but to meet the requirement that\n+                // the closure type `C: 'static` (so it can be coerced\n+                // to the object type), we get the requirement that\n+                // `'a: 'static` since `'a` appears in the closure\n+                // type `C`.\n+                //\n+                // A smarter fix might \"prune\" unused `func_substs` --\n+                // this would avoid breaking simple examples like\n+                // this, but would still break others (which might\n+                // indeed be invalid, depending on your POV). Pruning\n+                // would be a subtle process, since we have to see\n+                // what func/type parameters are used and unused,\n+                // taking into consideration UFCS and so forth.\n+\n+                for &upvar_ty in &substs.upvar_tys {\n+                    self.accumulate_from_ty(upvar_ty);\n+                }\n             }\n \n             ty::TyTrait(ref t) => {\n@@ -273,6 +310,21 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n         self.out.extend(obligations);\n \n         let variances = self.tcx().item_variances(def_id);\n+        self.accumulate_from_substs(substs, Some(&variances));\n+    }\n+\n+    fn accumulate_from_substs(&mut self,\n+                              substs: &Substs<'tcx>,\n+                              variances: Option<&ty::ItemVariances>)\n+    {\n+        let mut tmp_variances = None;\n+        let variances = variances.unwrap_or_else(|| {\n+            tmp_variances = Some(ty::ItemVariances {\n+                types: substs.types.map(|_| ty::Variance::Invariant),\n+                regions: substs.regions().map(|_| ty::Variance::Invariant),\n+            });\n+            tmp_variances.as_ref().unwrap()\n+        });\n \n         for (&region, &variance) in substs.regions().iter().zip(&variances.regions) {\n             match variance {"}, {"sha": "a54aee24367721e8b0d93ac5bb73457d922da16d", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -1162,7 +1162,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// these unconstrained type variables.\n     fn resolve_type_vars_or_error(&self, t: &Ty<'tcx>) -> mc::McResult<Ty<'tcx>> {\n         let ty = self.resolve_type_vars_if_possible(t);\n-        if ty.has_infer_types() || ty.references_error() { Err(()) } else { Ok(ty) }\n+        if ty.references_error() || ty.is_ty_var() {\n+            debug!(\"resolve_type_vars_or_error: error from {:?}\", ty);\n+            Err(())\n+        } else {\n+            Ok(ty)\n+        }\n     }\n \n     pub fn fully_resolve<T:TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<T> {\n@@ -1374,38 +1379,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn closure_type(&self,\n-                    def_id: ast::DefId,\n-                    substs: &subst::Substs<'tcx>)\n-                    -> ty::ClosureTy<'tcx>\n+                        def_id: ast::DefId,\n+                        substs: &ty::ClosureSubsts<'tcx>)\n+                        -> ty::ClosureTy<'tcx>\n     {\n-\n         let closure_ty = self.tables\n                              .borrow()\n                              .closure_tys\n                              .get(&def_id)\n                              .unwrap()\n-                             .subst(self.tcx, substs);\n+                             .subst(self.tcx, &substs.func_substs);\n \n         if self.normalize {\n             normalize_associated_type(&self.tcx, &closure_ty)\n         } else {\n             closure_ty\n         }\n     }\n-\n-    pub fn closure_upvars(&self,\n-                          def_id: ast::DefId,\n-                          substs: &Substs<'tcx>)\n-                          -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n-    {\n-        let result = ty::ctxt::closure_upvars(self, def_id, substs);\n-\n-        if self.normalize {\n-            normalize_associated_type(&self.tcx, &result)\n-        } else {\n-            result\n-        }\n-    }\n }\n \n impl<'tcx> TypeTrace<'tcx> {"}, {"sha": "7db740798bd406f989be18c519cbfca939a638f3", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -1493,7 +1493,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n         let fn_ty = self.ir.tcx.node_id_to_type(id);\n         match fn_ty.sty {\n-            ty::TyClosure(closure_def_id, substs) =>\n+            ty::TyClosure(closure_def_id, ref substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n             _ => fn_ty.fn_ret()\n         }"}, {"sha": "ee7079bb47d5920876358134884e2519d7930ecd", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -367,7 +367,13 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n     }\n \n     fn expr_ty(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n-        self.typer.node_ty(expr.id)\n+        match self.typer.node_ty(expr.id) {\n+            Ok(t) => Ok(t),\n+            Err(()) => {\n+                debug!(\"expr_ty({:?}) yielded Err\", expr);\n+                Err(())\n+            }\n+        }\n     }\n \n     fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {"}, {"sha": "376430e87c6f005b10ee6615a33df7ef044c7a08", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -270,7 +270,7 @@ pub struct VtableImplData<'tcx, N> {\n #[derive(Clone, PartialEq, Eq)]\n pub struct VtableClosureData<'tcx, N> {\n     pub closure_def_id: ast::DefId,\n-    pub substs: subst::Substs<'tcx>,\n+    pub substs: ty::ClosureSubsts<'tcx>,\n     /// Nested obligations. This can be non-empty if the closure\n     /// signature contains associated types.\n     pub nested: Vec<N>\n@@ -548,7 +548,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableClosure(c) => VtableClosure(VtableClosureData {\n                 closure_def_id: c.closure_def_id,\n                 substs: c.substs,\n-                nested: c.nested.into_iter().map(f).collect()\n+                nested: c.nested.into_iter().map(f).collect(),\n             })\n         }\n     }"}, {"sha": "ef3a217ecdbf28d494d691def3fe700300a7ab9a", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -154,7 +154,7 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n     debug!(\"consider_unification_despite_ambiguity: self_ty.sty={:?}\",\n            self_ty.sty);\n     match self_ty.sty {\n-        ty::TyClosure(closure_def_id, substs) => {\n+        ty::TyClosure(closure_def_id, ref substs) => {\n             let closure_typer = selcx.closure_typer();\n             let closure_type = closure_typer.closure_type(closure_def_id, substs);\n             let ty::Binder((_, ret_type)) ="}, {"sha": "4061581ded8f080b717efcd7dfc92881fe0a0ad2", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 41, "deletions": 69, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -201,7 +201,7 @@ enum SelectionCandidate<'tcx> {\n \n     /// Implementation of a `Fn`-family trait by one of the\n     /// anonymous types generated for a `||` expression.\n-    ClosureCandidate(/* closure */ ast::DefId, Substs<'tcx>),\n+    ClosureCandidate(/* closure */ ast::DefId, &'tcx ty::ClosureSubsts<'tcx>),\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous\n     /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n@@ -348,7 +348,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // lifetimes can appear inside the self-type.\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n-            ty::TyClosure(id, ref substs) => (id, substs.clone()),\n+            ty::TyClosure(id, ref substs) => (id, substs),\n             _ => { return; }\n         };\n         assert!(!substs.has_escaping_regions());\n@@ -1143,7 +1143,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // type/region parameters\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n-            ty::TyClosure(id, substs) => (id, substs),\n+            ty::TyClosure(id, ref substs) => (id, substs),\n             ty::TyInfer(ty::TyVar(_)) => {\n                 debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n@@ -1161,8 +1161,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Some(closure_kind) => {\n                 debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n                 if closure_kind.extends(kind) {\n-                    candidates.vec.push(ClosureCandidate(closure_def_id,\n-                                                         substs.clone()));\n+                    candidates.vec.push(ClosureCandidate(closure_def_id, substs));\n                 }\n             }\n             None => {\n@@ -1285,22 +1284,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     candidates.ambiguous = true;\n                 }\n                 _ => {\n-                    if self.constituent_types_for_ty(self_ty).is_some() {\n-                        candidates.vec.push(DefaultImplCandidate(def_id.clone()))\n-                    } else {\n-                        // We don't yet know what the constituent\n-                        // types are. So call it ambiguous for now,\n-                        // though this is a bit stronger than\n-                        // necessary: that is, we know that the\n-                        // defaulted impl applies, but we can't\n-                        // process the confirmation step without\n-                        // knowing the constituent types. (Anyway, in\n-                        // the particular case of defaulted impls, it\n-                        // doesn't really matter much either way,\n-                        // since we won't be aiding inference by\n-                        // processing the confirmation step.)\n-                        candidates.ambiguous = true;\n-                    }\n+                    candidates.vec.push(DefaultImplCandidate(def_id.clone()))\n                 }\n             }\n         }\n@@ -1704,7 +1688,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n             ty::TyTuple(ref tys) => ok_if(tys.clone()),\n \n-            ty::TyClosure(def_id, substs) => {\n+            ty::TyClosure(def_id, ref substs) => {\n                 // FIXME -- This case is tricky. In the case of by-ref\n                 // closures particularly, we need the results of\n                 // inference to decide how to reflect the type of each\n@@ -1730,13 +1714,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     return ok_if(Vec::new());\n                 }\n \n-                match self.infcx.closure_upvars(def_id, substs) {\n-                    Some(upvars) => ok_if(upvars.iter().map(|c| c.ty).collect()),\n-                    None => {\n-                        debug!(\"assemble_builtin_bound_candidates: no upvar types available yet\");\n-                        Ok(AmbiguousBuiltin)\n-                    }\n-                }\n+                ok_if(substs.upvar_tys.clone())\n             }\n \n             ty::TyStruct(def_id, substs) => {\n@@ -1819,7 +1797,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Bar<i32> where struct Bar<T> { x: T, y: u32 } -> [i32, u32]\n     /// Zed<i32> where enum Zed { A(T), B(u32) } -> [i32, u32]\n     /// ```\n-    fn constituent_types_for_ty(&self, t: Ty<'tcx>) -> Option<Vec<Ty<'tcx>>> {\n+    fn constituent_types_for_ty(&self, t: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n         match t.sty {\n             ty::TyUint(_) |\n             ty::TyInt(_) |\n@@ -1831,7 +1809,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::TyInfer(ty::IntVar(_)) |\n             ty::TyInfer(ty::FloatVar(_)) |\n             ty::TyChar => {\n-                Some(Vec::new())\n+                Vec::new()\n             }\n \n             ty::TyTrait(..) |\n@@ -1848,55 +1826,56 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::TyBox(referent_ty) => {  // Box<T>\n-                Some(vec![referent_ty])\n+                vec![referent_ty]\n             }\n \n             ty::TyRawPtr(ty::TypeAndMut { ty: element_ty, ..}) |\n             ty::TyRef(_, ty::TypeAndMut { ty: element_ty, ..}) => {\n-                Some(vec![element_ty])\n+                vec![element_ty]\n             },\n \n             ty::TyArray(element_ty, _) | ty::TySlice(element_ty) => {\n-                Some(vec![element_ty])\n+                vec![element_ty]\n             }\n \n             ty::TyTuple(ref tys) => {\n                 // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-                Some(tys.clone())\n-            }\n-\n-            ty::TyClosure(def_id, substs) => {\n+                tys.clone()\n+            }\n+\n+            ty::TyClosure(def_id, ref substs) => {\n+                // FIXME(#27086). We are invariant w/r/t our\n+                // substs.func_substs, but we don't see them as\n+                // constituent types; this seems RIGHT but also like\n+                // something that a normal type couldn't simulate. Is\n+                // this just a gap with the way that PhantomData and\n+                // OIBIT interact? That is, there is no way to say\n+                // \"make me invariant with respect to this TYPE, but\n+                // do not act as though I can reach it\"\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n-\n-                match self.infcx.closure_upvars(def_id, substs) {\n-                    Some(upvars) => {\n-                        Some(upvars.iter().map(|c| c.ty).collect())\n-                    }\n-                    None => {\n-                        None\n-                    }\n-                }\n+                substs.upvar_tys.clone()\n             }\n \n             // for `PhantomData<T>`, we pass `T`\n             ty::TyStruct(def_id, substs)\n                 if Some(def_id) == self.tcx().lang_items.phantom_data() =>\n             {\n-                Some(substs.types.get_slice(TypeSpace).to_vec())\n+                substs.types.get_slice(TypeSpace).to_vec()\n             }\n \n             ty::TyStruct(def_id, substs) => {\n-                Some(self.tcx().struct_fields(def_id, substs).iter()\n-                     .map(|f| f.mt.ty)\n-                     .collect())\n+                self.tcx().struct_fields(def_id, substs)\n+                          .iter()\n+                          .map(|f| f.mt.ty)\n+                          .collect()\n             }\n \n             ty::TyEnum(def_id, substs) => {\n-                Some(self.tcx().substd_enum_variants(def_id, substs)\n-                     .iter()\n-                     .flat_map(|variant| &variant.args)\n-                     .map(|&ty| ty)\n-                     .collect())\n+                self.tcx().substd_enum_variants(def_id, substs)\n+                          .iter()\n+                          .flat_map(|variant| &variant.args)\n+                          .map(|&ty| ty)\n+                          .collect()\n             }\n         }\n     }\n@@ -2016,7 +1995,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ClosureCandidate(closure_def_id, substs) => {\n                 let vtable_closure =\n-                    try!(self.confirm_closure_candidate(obligation, closure_def_id, &substs));\n+                    try!(self.confirm_closure_candidate(obligation, closure_def_id, substs));\n                 Ok(VtableClosure(vtable_closure))\n             }\n \n@@ -2146,15 +2125,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // binder is moved below\n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n-        match self.constituent_types_for_ty(self_ty) {\n-            Some(types) => self.vtable_default_impl(obligation, trait_def_id, ty::Binder(types)),\n-            None => {\n-                self.tcx().sess.bug(\n-                    &format!(\n-                        \"asked to confirm default implementation for ambiguous type: {:?}\",\n-                        self_ty));\n-            }\n-        }\n+        let types = self.constituent_types_for_ty(self_ty);\n+        self.vtable_default_impl(obligation, trait_def_id, ty::Binder(types))\n     }\n \n     fn confirm_default_impl_object_candidate(&mut self,\n@@ -2365,7 +2337,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_closure_candidate(&mut self,\n                                  obligation: &TraitObligation<'tcx>,\n                                  closure_def_id: ast::DefId,\n-                                 substs: &Substs<'tcx>)\n+                                 substs: &ty::ClosureSubsts<'tcx>)\n                                  -> Result<VtableClosureData<'tcx, PredicateObligation<'tcx>>,\n                                            SelectionError<'tcx>>\n     {\n@@ -2852,7 +2824,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn closure_trait_ref_unnormalized(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n                                       closure_def_id: ast::DefId,\n-                                      substs: &Substs<'tcx>)\n+                                      substs: &ty::ClosureSubsts<'tcx>)\n                                       -> ty::PolyTraitRef<'tcx>\n     {\n         let closure_type = self.infcx.closure_type(closure_def_id, substs);\n@@ -2874,7 +2846,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn closure_trait_ref(&mut self,\n                          obligation: &TraitObligation<'tcx>,\n                          closure_def_id: ast::DefId,\n-                         substs: &Substs<'tcx>)\n+                         substs: &ty::ClosureSubsts<'tcx>)\n                          -> Normalized<'tcx, ty::PolyTraitRef<'tcx>>\n     {\n         let trait_ref = self.closure_trait_ref_unnormalized("}, {"sha": "aa1c8bfaa904fb465080a68cfd41ff6f46e46706", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 124, "deletions": 68, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -1767,7 +1767,7 @@ pub enum TypeVariants<'tcx> {\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n-    TyClosure(DefId, &'tcx Substs<'tcx>),\n+    TyClosure(DefId, Box<ClosureSubsts<'tcx>>),\n \n     /// A tuple type.  For example, `(i32, bool)`.\n     TyTuple(Vec<Ty<'tcx>>),\n@@ -1787,6 +1787,93 @@ pub enum TypeVariants<'tcx> {\n     TyError,\n }\n \n+/// A closure can be modeled as a struct that looks like:\n+///\n+///     struct Closure<'l0...'li, T0...Tj, U0...Uk> {\n+///         upvar0: U0,\n+///         ...\n+///         upvark: Uk\n+///     }\n+///\n+/// where 'l0...'li and T0...Tj are the lifetime and type parameters\n+/// in scope on the function that defined the closure, and U0...Uk are\n+/// type parameters representing the types of its upvars (borrowed, if\n+/// appropriate).\n+///\n+/// So, for example, given this function:\n+///\n+///     fn foo<'a, T>(data: &'a mut T) {\n+///          do(|| data.count += 1)\n+///     }\n+///\n+/// the type of the closure would be something like:\n+///\n+///     struct Closure<'a, T, U0> {\n+///         data: U0\n+///     }\n+///\n+/// Note that the type of the upvar is not specified in the struct.\n+/// You may wonder how the impl would then be able to use the upvar,\n+/// if it doesn't know it's type? The answer is that the impl is\n+/// (conceptually) not fully generic over Closure but rather tied to\n+/// instances with the expected upvar types:\n+///\n+///     impl<'b, 'a, T> FnMut() for Closure<'a, T, &'b mut &'a mut T> {\n+///         ...\n+///     }\n+///\n+/// You can see that the *impl* fully specified the type of the upvar\n+/// and thus knows full well that `data` has type `&'b mut &'a mut T`.\n+/// (Here, I am assuming that `data` is mut-borrowed.)\n+///\n+/// Now, the last question you may ask is: Why include the upvar types\n+/// as extra type parameters? The reason for this design is that the\n+/// upvar types can reference lifetimes that are internal to the\n+/// creating function. In my example above, for example, the lifetime\n+/// `'b` represents the extent of the closure itself; this is some\n+/// subset of `foo`, probably just the extent of the call to the to\n+/// `do()`. If we just had the lifetime/type parameters from the\n+/// enclosing function, we couldn't name this lifetime `'b`. Note that\n+/// there can also be lifetimes in the types of the upvars themselves,\n+/// if one of them happens to be a reference to something that the\n+/// creating fn owns.\n+///\n+/// OK, you say, so why not create a more minimal set of parameters\n+/// that just includes the extra lifetime parameters? The answer is\n+/// primarily that it would be hard --- we don't know at the time when\n+/// we create the closure type what the full types of the upvars are,\n+/// nor do we know which are borrowed and which are not. In this\n+/// design, we can just supply a fresh type parameter and figure that\n+/// out later.\n+///\n+/// All right, you say, but why include the type parameters from the\n+/// original function then? The answer is that trans may need them\n+/// when monomorphizing, and they may not appear in the upvars.  A\n+/// closure could capture no variables but still make use of some\n+/// in-scope type parameter with a bound (e.g., if our example above\n+/// had an extra `U: Default`, and the closure called `U::default()`).\n+///\n+/// There is another reason. This design (implicitly) prohibits\n+/// closures from capturing themselves (except via a trait\n+/// object). This simplifies closure inference considerably, since it\n+/// means that when we infer the kind of a closure or its upvars, we\n+/// don't have to handle cycles where the decisions we make for\n+/// closure C wind up influencing the decisions we ought to make for\n+/// closure C (which would then require fixed point iteration to\n+/// handle). Plus it fixes an ICE. :P\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct ClosureSubsts<'tcx> {\n+    /// Lifetime and type parameters from the enclosing function.\n+    /// These are separated out because trans wants to pass them around\n+    /// when monomorphizing.\n+    pub func_substs: &'tcx Substs<'tcx>,\n+\n+    /// The types of the upvars. The list parallels the freevars and\n+    /// `upvar_borrows` lists. These are kept distinct so that we can\n+    /// easily index into them.\n+    pub upvar_tys: Vec<Ty<'tcx>>\n+}\n+\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct TraitTy<'tcx> {\n     pub principal: ty::PolyTraitRef<'tcx>,\n@@ -3214,10 +3301,11 @@ impl FlagComputation {\n                 }\n             }\n \n-            &TyClosure(_, substs) => {\n+            &TyClosure(_, ref substs) => {\n                 self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n                 self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n-                self.add_substs(substs);\n+                self.add_substs(&substs.func_substs);\n+                self.add_tys(&substs.upvar_tys);\n             }\n \n             &TyInfer(_) => {\n@@ -3461,10 +3549,10 @@ impl<'tcx> ctxt<'tcx> {\n \n     pub fn closure_type(&self,\n                         def_id: ast::DefId,\n-                        substs: &subst::Substs<'tcx>)\n+                        substs: &ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n-        self.tables.borrow().closure_tys.get(&def_id).unwrap().subst(self, substs)\n+        self.tables.borrow().closure_tys.get(&def_id).unwrap().subst(self, &substs.func_substs)\n     }\n \n     pub fn type_parameter_def(&self,\n@@ -3659,9 +3747,22 @@ impl<'tcx> ctxt<'tcx> {\n         self.mk_ty(TyStruct(struct_id, substs))\n     }\n \n-    pub fn mk_closure(&self, closure_id: ast::DefId, substs: &'tcx Substs<'tcx>)\n+    pub fn mk_closure(&self,\n+                      closure_id: ast::DefId,\n+                      substs: &'tcx Substs<'tcx>,\n+                      tys: Vec<Ty<'tcx>>)\n                       -> Ty<'tcx> {\n-        self.mk_ty(TyClosure(closure_id, substs))\n+        self.mk_closure_from_closure_substs(closure_id, Box::new(ClosureSubsts {\n+            func_substs: substs,\n+            upvar_tys: tys\n+        }))\n+    }\n+\n+    pub fn mk_closure_from_closure_substs(&self,\n+                                          closure_id: ast::DefId,\n+                                          closure_substs: Box<ClosureSubsts<'tcx>>)\n+                                          -> Ty<'tcx> {\n+        self.mk_ty(TyClosure(closure_id, closure_substs))\n     }\n \n     pub fn mk_var(&self, v: TyVid) -> Ty<'tcx> {\n@@ -4146,11 +4247,8 @@ impl<'tcx> TyS<'tcx> {\n                     apply_lang_items(cx, did, res)\n                 }\n \n-                TyClosure(did, substs) => {\n-                    let param_env = cx.empty_parameter_environment();\n-                    let infcx = infer::new_infer_ctxt(cx, &cx.tables, Some(param_env), false);\n-                    let upvars = infcx.closure_upvars(did, substs).unwrap();\n-                    TypeContents::union(&upvars, |f| tc_ty(cx, &f.ty, cache))\n+                TyClosure(_, ref substs) => {\n+                    TypeContents::union(&substs.upvar_tys, |ty| tc_ty(cx, &ty, cache))\n                 }\n \n                 TyTuple(ref tys) => {\n@@ -5905,62 +6003,6 @@ impl<'tcx> ctxt<'tcx> {\n         (a, b)\n     }\n \n-    // Returns a list of `ClosureUpvar`s for each upvar.\n-    pub fn closure_upvars<'a>(typer: &infer::InferCtxt<'a, 'tcx>,\n-                          closure_id: ast::DefId,\n-                          substs: &Substs<'tcx>)\n-                          -> Option<Vec<ClosureUpvar<'tcx>>>\n-    {\n-        // Presently an unboxed closure type cannot \"escape\" out of a\n-        // function, so we will only encounter ones that originated in the\n-        // local crate or were inlined into it along with some function.\n-        // This may change if abstract return types of some sort are\n-        // implemented.\n-        assert!(closure_id.krate == ast::LOCAL_CRATE);\n-        let tcx = typer.tcx;\n-        match tcx.freevars.borrow().get(&closure_id.node) {\n-            None => Some(vec![]),\n-            Some(ref freevars) => {\n-                freevars.iter()\n-                        .map(|freevar| {\n-                            let freevar_def_id = freevar.def.def_id();\n-                            let freevar_ty = match typer.node_ty(freevar_def_id.node) {\n-                                Ok(t) => { t }\n-                                Err(()) => { return None; }\n-                            };\n-                            let freevar_ty = freevar_ty.subst(tcx, substs);\n-\n-                            let upvar_id = ty::UpvarId {\n-                                var_id: freevar_def_id.node,\n-                                closure_expr_id: closure_id.node\n-                            };\n-\n-                            typer.upvar_capture(upvar_id).map(|capture| {\n-                                let freevar_ref_ty = match capture {\n-                                    UpvarCapture::ByValue => {\n-                                        freevar_ty\n-                                    }\n-                                    UpvarCapture::ByRef(borrow) => {\n-                                        tcx.mk_ref(tcx.mk_region(borrow.region),\n-                                            ty::TypeAndMut {\n-                                                ty: freevar_ty,\n-                                                mutbl: borrow.kind.to_mutbl_lossy(),\n-                                            })\n-                                    }\n-                                };\n-\n-                                ClosureUpvar {\n-                                    def: freevar.def,\n-                                    span: freevar.span,\n-                                    ty: freevar_ref_ty,\n-                                }\n-                            })\n-                        })\n-                        .collect()\n-            }\n-        }\n-    }\n-\n     // Returns the repeat count for a repeating vector expression.\n     pub fn eval_repeat_count(&self, count_expr: &ast::Expr) -> usize {\n         let hint = UncheckedExprHint(self.types.usize);\n@@ -6759,6 +6801,13 @@ impl<'tcx> RegionEscape for Substs<'tcx> {\n     }\n }\n \n+impl<'tcx> RegionEscape for ClosureSubsts<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.func_substs.has_regions_escaping_depth(depth) ||\n+            self.upvar_tys.iter().any(|t| t.has_regions_escaping_depth(depth))\n+    }\n+}\n+\n impl<T:RegionEscape> RegionEscape for Vec<T> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.iter().any(|t| t.has_regions_escaping_depth(depth))\n@@ -7102,6 +7151,13 @@ impl<'tcx> HasTypeFlags for BareFnTy<'tcx> {\n     }\n }\n \n+impl<'tcx> HasTypeFlags for ClosureSubsts<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.func_substs.has_type_flags(flags) ||\n+            self.upvar_tys.iter().any(|t| t.has_type_flags(flags))\n+    }\n+}\n+\n impl<'tcx> fmt::Debug for ClosureTy<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ClosureTy({},{:?},{})\","}, {"sha": "b6bb82ad7b15b2f5bd16ddea6e4ab490ca04efe0", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -296,6 +296,16 @@ impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureSubsts<'tcx> {\n+        let func_substs = self.func_substs.fold_with(folder);\n+        ty::ClosureSubsts {\n+            func_substs: folder.tcx().mk_substs(func_substs),\n+            upvar_tys: self.upvar_tys.fold_with(folder),\n+        }\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ItemSubsts<'tcx> {\n         ty::ItemSubsts {\n@@ -604,7 +614,7 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n         }\n         ty::TyClosure(did, ref substs) => {\n             let s = substs.fold_with(this);\n-            ty::TyClosure(did, this.tcx().mk_substs(s))\n+            ty::TyClosure(did, s)\n         }\n         ty::TyProjection(ref data) => {\n             ty::TyProjection(data.fold_with(this))"}, {"sha": "f8678b4d8e3bd1b47cd6481758474bc37400eb87", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -48,6 +48,12 @@ pub trait TypeRelation<'a,'tcx> : Sized {\n         Relate::relate(self, a, b)\n     }\n \n+    /// Relete elements of two slices pairwise.\n+    fn relate_zip<T:Relate<'a,'tcx>>(&mut self, a: &[T], b: &[T]) -> RelateResult<'tcx, Vec<T>> {\n+        assert_eq!(a.len(), b.len());\n+        a.iter().zip(b).map(|(a, b)| self.relate(a, b)).collect()\n+    }\n+\n     /// Switch variance for the purpose of relating `a` and `b`.\n     fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n                                                variance: ty::Variance,\n@@ -500,15 +506,15 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             Ok(tcx.mk_struct(a_id, tcx.mk_substs(substs)))\n         }\n \n-        (&ty::TyClosure(a_id, a_substs),\n-         &ty::TyClosure(b_id, b_substs))\n+        (&ty::TyClosure(a_id, ref a_substs),\n+         &ty::TyClosure(b_id, ref b_substs))\n             if a_id == b_id =>\n         {\n             // All TyClosure types with the same id represent\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n-            let substs = try!(relate_substs(relation, None, a_substs, b_substs));\n-            Ok(tcx.mk_closure(a_id, tcx.mk_substs(substs)))\n+            let substs = try!(relation.relate(a_substs, b_substs));\n+            Ok(tcx.mk_closure_from_closure_substs(a_id, substs))\n         }\n \n         (&ty::TyBox(a_inner), &ty::TyBox(b_inner)) =>\n@@ -581,6 +587,20 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n     }\n }\n \n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ClosureSubsts<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::ClosureSubsts<'tcx>,\n+                 b: &ty::ClosureSubsts<'tcx>)\n+                 -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let func_substs = try!(relate_substs(relation, None, a.func_substs, b.func_substs));\n+        let upvar_tys = try!(relation.relate_zip(&a.upvar_tys, &b.upvar_tys));\n+        Ok(ty::ClosureSubsts { func_substs: relation.tcx().mk_substs(func_substs),\n+                               upvar_tys: upvar_tys })\n+    }\n+}\n+\n impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::Region {\n     fn relate<R>(relation: &mut R,\n                  a: &ty::Region,"}, {"sha": "81cad4486904b7e6e7ee946bbd2a2ebc53ca540a", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -88,10 +88,13 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n             }).collect::<Vec<_>>());\n         }\n         ty::TyEnum(_, ref substs) |\n-        ty::TyStruct(_, ref substs) |\n-        ty::TyClosure(_, ref substs) => {\n+        ty::TyStruct(_, ref substs) => {\n             push_reversed(stack, substs.types.as_slice());\n         }\n+        ty::TyClosure(_, ref substs) => {\n+            push_reversed(stack, substs.func_substs.types.as_slice());\n+            push_reversed(stack, &substs.upvar_tys);\n+        }\n         ty::TyTuple(ref ts) => {\n             push_reversed(stack, ts);\n         }"}, {"sha": "fd49d0468c9063b12289bfd66bfe1efc60e64cfe", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -662,22 +662,35 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyTrait(ref data) => write!(f, \"{}\", data),\n             ty::TyProjection(ref data) => write!(f, \"{}\", data),\n             TyStr => write!(f, \"str\"),\n-            TyClosure(ref did, substs) => ty::tls::with(|tcx| {\n+            TyClosure(ref did, ref substs) => ty::tls::with(|tcx| {\n                 try!(write!(f, \"[closure\"));\n-                let closure_tys = &tcx.tables.borrow().closure_tys;\n-                try!(closure_tys.get(did).map(|cty| &cty.sig).and_then(|sig| {\n-                    tcx.lift(&substs).map(|substs| sig.subst(tcx, substs))\n-                }).map(|sig| {\n-                    fn_sig(f, &sig.0.inputs, false, sig.0.output)\n-                }).unwrap_or_else(|| {\n-                    if did.krate == ast::LOCAL_CRATE {\n-                        try!(write!(f, \" {:?}\", tcx.map.span(did.node)));\n+\n+                if did.krate == ast::LOCAL_CRATE {\n+                    try!(write!(f, \"@{:?}\", tcx.map.span(did.node)));\n+                    let mut sep = \" \";\n+                    try!(tcx.with_freevars(did.node, |freevars| {\n+                        for (freevar, upvar_ty) in freevars.iter().zip(&substs.upvar_tys) {\n+                            let node_id = freevar.def.local_node_id();\n+                            try!(write!(f,\n+                                        \"{}{}:{}\",\n+                                        sep,\n+                                        tcx.local_var_name_str(node_id),\n+                                        upvar_ty));\n+                            sep = \", \";\n+                        }\n+                        Ok(())\n+                    }))\n+                } else {\n+                    // cross-crate closure types should only be\n+                    // visible in trans bug reports, I imagine.\n+                    try!(write!(f, \"@{:?}\", did));\n+                    let mut sep = \" \";\n+                    for (index, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n+                        try!(write!(f, \"{}{}:{}\", sep, index, upvar_ty));\n+                        sep = \", \";\n                     }\n-                    Ok(())\n-                }));\n-                if verbose() {\n-                    try!(write!(f, \" id={:?}\", did));\n                 }\n+\n                 write!(f, \"]\")\n             }),\n             TyArray(ty, sz) => write!(f, \"[{}; {}]\",  ty, sz),"}, {"sha": "dc7e34a386f93d124377eb22ca85dd0f052922ae", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -48,7 +48,6 @@ use std::rc::Rc;\n use llvm::{ValueRef, True, IntEQ, IntNE};\n use back::abi::FAT_PTR_ADDR;\n use middle::subst;\n-use middle::infer;\n use middle::ty::{self, Ty};\n use middle::ty::Disr;\n use syntax::ast;\n@@ -221,11 +220,8 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             Univariant(mk_struct(cx, &ftys[..], packed, t), dtor_to_init_u8(dtor))\n         }\n-        ty::TyClosure(def_id, substs) => {\n-            let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n-            let upvars = infcx.closure_upvars(def_id, substs).unwrap();\n-            let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            Univariant(mk_struct(cx, &upvar_types[..], false, t), 0)\n+        ty::TyClosure(_, ref substs) => {\n+            Univariant(mk_struct(cx, &substs.upvar_tys, false, t), 0)\n         }\n         ty::TyEnum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n@@ -441,12 +437,8 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         // Perhaps one of the upvars of this struct is non-zero\n         // Let's recurse and find out!\n-        ty::TyClosure(def_id, substs) => {\n-            let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n-            let upvars = infcx.closure_upvars(def_id, substs).unwrap();\n-            let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-\n-            for (j, &ty) in upvar_types.iter().enumerate() {\n+        ty::TyClosure(_, ref substs) => {\n+            for (j, &ty) in substs.upvar_tys.iter().enumerate() {\n                 if let Some(mut fpath) = find_discr_field_candidate(tcx, ty, path.clone()) {\n                     fpath.push(j);\n                     return Some(fpath);"}, {"sha": "62b03c9fb0f1fcaa858b6ed464efe9628220e4df", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -145,7 +145,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n     let function_type;\n     let (fn_sig, abi, env_ty) = match fn_type.sty {\n         ty::TyBareFn(_, ref f) => (&f.sig, f.abi, None),\n-        ty::TyClosure(closure_did, substs) => {\n+        ty::TyClosure(closure_did, ref substs) => {\n             let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n             function_type = infcx.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);"}, {"sha": "207251496e45769d919b4d44877dcae8d9ec2ac2", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -37,7 +37,6 @@ use llvm;\n use metadata::{csearch, encoder, loader};\n use middle::astencode;\n use middle::cfg;\n-use middle::infer;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n use middle::pat_util::simple_identifier;\n@@ -470,13 +469,11 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n               }\n           })\n       }\n-      ty::TyClosure(def_id, substs) => {\n+      ty::TyClosure(_, ref substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n-          let upvars = infcx.closure_upvars(def_id, substs).unwrap();\n-          for (i, upvar) in upvars.iter().enumerate() {\n+          for (i, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n               let llupvar = adt::trans_field_ptr(cx, &*repr, data_ptr, 0, i);\n-              cx = f(cx, llupvar, upvar.ty);\n+              cx = f(cx, llupvar, upvar_ty);\n           }\n       }\n       ty::TyArray(_, n) => {"}, {"sha": "0f75c1f8ab65a6d0befe9ec2f3b25a57db63db43", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -32,7 +32,6 @@ use trans::build::*;\n use trans::callee;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n-use trans::closure;\n use trans::common::{self, Block, Result, NodeIdAndSpan, ExprId, CrateContext,\n                     ExprOrMethodCall, FunctionContext, MethodCallKey};\n use trans::consts;\n@@ -446,12 +445,6 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n         }\n     };\n \n-    // If this is a closure, redirect to it.\n-    match closure::get_or_create_declaration_if_closure(ccx, def_id, substs) {\n-        None => {}\n-        Some(llfn) => return llfn,\n-    }\n-\n     // Check whether this fn has an inlined copy and, if so, redirect\n     // def_id to the local id of the inlined copy.\n     let def_id = inline::maybe_instantiate_inline(ccx, def_id);"}, {"sha": "ef5da3e40dfda9559e0a753482d5a2e9c9af14ce", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 27, "deletions": 54, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -23,10 +23,9 @@ use trans::datum::{self, Datum, rvalue_scratch_datum, Rvalue, ByValue};\n use trans::debuginfo::{self, DebugLoc};\n use trans::declare;\n use trans::expr;\n-use trans::monomorphize::{self, MonoId};\n+use trans::monomorphize::{MonoId};\n use trans::type_of::*;\n use middle::ty;\n-use middle::subst::Substs;\n use session::config::FullDebugInfo;\n \n use syntax::abi::RustCall;\n@@ -126,46 +125,29 @@ impl<'a> ClosureEnv<'a> {\n \n /// Returns the LLVM function declaration for a closure, creating it if\n /// necessary. If the ID does not correspond to a closure ID, returns None.\n-pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                      closure_id: ast::DefId,\n-                                                      substs: &Substs<'tcx>)\n-                                                      -> Option<Datum<'tcx, Rvalue>> {\n-    if !ccx.tcx().tables.borrow().closure_kinds.contains_key(&closure_id) {\n-        // Not a closure.\n-        return None\n-    }\n-\n-    let function_type = ccx.tcx().node_id_to_type(closure_id.node);\n-    let function_type = monomorphize::apply_param_substs(ccx.tcx(), substs, &function_type);\n-\n+pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                   closure_id: ast::DefId,\n+                                                   substs: &ty::ClosureSubsts<'tcx>)\n+                                                   -> ValueRef {\n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n-    let function_type = erase_regions(ccx.tcx(), &function_type);\n-    let params = match function_type.sty {\n-        ty::TyClosure(_, substs) => &substs.types,\n-        _ => unreachable!()\n-    };\n+    let substs = erase_regions(ccx.tcx(), substs);\n     let mono_id = MonoId {\n         def: closure_id,\n-        params: params\n+        params: &substs.func_substs.types\n     };\n \n-    match ccx.closure_vals().borrow().get(&mono_id) {\n-        Some(&llfn) => {\n-            debug!(\"get_or_create_declaration_if_closure(): found closure {:?}: {:?}\",\n-                   mono_id, ccx.tn().val_to_string(llfn));\n-            return Some(Datum::new(llfn, function_type, Rvalue::new(ByValue)))\n-        }\n-        None => {}\n+    if let Some(&llfn) = ccx.closure_vals().borrow().get(&mono_id) {\n+        debug!(\"get_or_create_closure_declaration(): found closure {:?}: {:?}\",\n+               mono_id, ccx.tn().val_to_string(llfn));\n+        return llfn;\n     }\n \n     let symbol = ccx.tcx().map.with_path(closure_id.node, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n \n-    // Currently there\u2019s only a single user of\n-    // get_or_create_declaration_if_closure and it unconditionally defines the\n-    // function, therefore we use define_* here.\n+    let function_type = ccx.tcx().mk_closure_from_closure_substs(closure_id, Box::new(substs));\n     let llfn = declare::define_internal_rust_fn(ccx, &symbol[..], function_type);\n \n     // set an inline hint for all closures\n@@ -178,7 +160,7 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n            ccx.tn().val_to_string(llfn));\n     ccx.closure_vals().borrow_mut().insert(mono_id, llfn);\n \n-    Some(Datum::new(llfn, function_type, Rvalue::new(ByValue)))\n+    llfn\n }\n \n pub enum Dest<'a, 'tcx: 'a> {\n@@ -190,9 +172,11 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n                                     decl: &ast::FnDecl,\n                                     body: &ast::Block,\n                                     id: ast::NodeId,\n-                                    param_substs: &'tcx Substs<'tcx>)\n+                                    closure_substs: &'tcx ty::ClosureSubsts<'tcx>)\n                                     -> Option<Block<'a, 'tcx>>\n {\n+    let param_substs = closure_substs.func_substs;\n+\n     let ccx = match dest {\n         Dest::SaveIn(bcx, _) => bcx.ccx(),\n         Dest::Ignore(ccx) => ccx\n@@ -203,10 +187,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     debug!(\"trans_closure_expr()\");\n \n     let closure_id = ast_util::local_def(id);\n-    let llfn = get_or_create_declaration_if_closure(\n-        ccx,\n-        closure_id,\n-        param_substs).unwrap();\n+    let llfn = get_or_create_closure_declaration(ccx, closure_id, closure_substs);\n \n     // Get the type of this closure. Use the current `param_substs` as\n     // the closure substitutions. This makes sense because the closure\n@@ -215,7 +196,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // of the closure expression.\n \n     let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n-    let function_type = infcx.closure_type(closure_id, param_substs);\n+    let function_type = infcx.closure_type(closure_id, closure_substs);\n \n     let freevars: Vec<ty::Freevar> =\n         tcx.with_freevars(id, |fv| fv.iter().cloned().collect());\n@@ -225,7 +206,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     trans_closure(ccx,\n                   decl,\n                   body,\n-                  llfn.val,\n+                  llfn,\n                   param_substs,\n                   id,\n                   &[],\n@@ -268,19 +249,12 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n \n pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                                       closure_def_id: ast::DefId,\n-                                      substs: Substs<'tcx>,\n-                                      node: ExprOrMethodCall,\n-                                      param_substs: &'tcx Substs<'tcx>,\n+                                      substs: ty::ClosureSubsts<'tcx>,\n                                       trait_closure_kind: ty::ClosureKind)\n                                       -> ValueRef\n {\n-    // The substitutions should have no type parameters remaining\n-    // after passing through fulfill_obligation\n-    let llfn = callee::trans_fn_ref_with_substs(ccx,\n-                                                closure_def_id,\n-                                                node,\n-                                                param_substs,\n-                                                substs.clone()).val;\n+    // If this is a closure, redirect to it.\n+    let llfn = get_or_create_closure_declaration(ccx, closure_def_id, &substs);\n \n     // If the closure is a Fn closure, but a FnOnce is needed (etc),\n     // then adapt the self type\n@@ -296,7 +270,7 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n fn trans_closure_adapter_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     closure_def_id: ast::DefId,\n-    substs: Substs<'tcx>,\n+    substs: ty::ClosureSubsts<'tcx>,\n     llfn_closure_kind: ty::ClosureKind,\n     trait_closure_kind: ty::ClosureKind,\n     llfn: ValueRef)\n@@ -348,7 +322,7 @@ fn trans_closure_adapter_shim<'a, 'tcx>(\n fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     closure_def_id: ast::DefId,\n-    substs: Substs<'tcx>,\n+    substs: ty::ClosureSubsts<'tcx>,\n     llreffn: ValueRef)\n     -> ValueRef\n {\n@@ -362,12 +336,11 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Find a version of the closure type. Substitute static for the\n     // region since it doesn't really matter.\n-    let substs = tcx.mk_substs(substs);\n-    let closure_ty = tcx.mk_closure(closure_def_id, substs);\n+    let closure_ty = tcx.mk_closure_from_closure_substs(closure_def_id, Box::new(substs.clone()));\n     let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), closure_ty);\n \n     // Make a version with the type of by-ref closure.\n-    let ty::ClosureTy { unsafety, abi, mut sig } = infcx.closure_type(closure_def_id, substs);\n+    let ty::ClosureTy { unsafety, abi, mut sig } = infcx.closure_type(closure_def_id, &substs);\n     sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n     let llref_bare_fn_ty = tcx.mk_bare_fn(ty::BareFnTy { unsafety: unsafety,\n                                                                abi: abi,\n@@ -397,7 +370,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n                       ast::DUMMY_NODE_ID,\n                       false,\n                       sig.output,\n-                      substs,\n+                      substs.func_substs,\n                       None,\n                       &block_arena);\n     let mut bcx = init_function(&fcx, false, sig.output);"}, {"sha": "deab11332c809cb09e97d4973ba6c0f332ec1484", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -882,11 +882,16 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n         },\n         ast::ExprClosure(_, ref decl, ref body) => {\n-            closure::trans_closure_expr(closure::Dest::Ignore(cx),\n-                                        decl,\n-                                        body,\n-                                        e.id,\n-                                        param_substs);\n+            match ety.sty {\n+                ty::TyClosure(_, ref substs) => {\n+                    closure::trans_closure_expr(closure::Dest::Ignore(cx), decl,\n+                                                body, e.id, substs);\n+                }\n+                _ =>\n+                    cx.sess().span_bug(\n+                        e.span,\n+                        &format!(\"bad type for closure expr: {:?}\", ety))\n+            }\n             C_null(type_of::type_of(cx, ety))\n         },\n         _ => cx.sess().span_bug(e.span,"}, {"sha": "09495dea286864777596fd26fae84c3b36bdd3c8", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -287,7 +287,7 @@ impl<'tcx> TypeMap<'tcx> {\n                     }\n                 }\n             },\n-            ty::TyClosure(def_id, substs) => {\n+            ty::TyClosure(def_id, ref substs) => {\n                 let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n                 let closure_ty = infcx.closure_type(def_id, substs);\n                 self.get_unique_type_id_of_closure_type(cx,\n@@ -811,14 +811,10 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             MetadataCreationResult::new(pointer_type_metadata(cx, t, fn_metadata), false)\n \n         }\n-        ty::TyClosure(def_id, substs) => {\n-            let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n-            let upvars = infcx.closure_upvars(def_id, substs).unwrap();\n-            let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-\n+        ty::TyClosure(_, ref substs) => {\n             prepare_tuple_metadata(cx,\n                                    t,\n-                                   &upvar_types[..],\n+                                   &substs.upvar_tys,\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }"}, {"sha": "8e4e0aaa75fec338bcb5311a8f6d71ddfb77a1f0", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -416,7 +416,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             ty::TyBareFn(_, ref barefnty) => {\n                 (cx.tcx().erase_late_bound_regions(&barefnty.sig), barefnty.abi)\n             }\n-            ty::TyClosure(def_id, substs) => {\n+            ty::TyClosure(def_id, ref substs) => {\n                 let closure_type = cx.tcx().closure_type(def_id, substs);\n                 (cx.tcx().erase_late_bound_regions(&closure_type.sig), closure_type.abi)\n             }"}, {"sha": "0c77e74be38aa1f831bc8a0525ff17a2582694e0", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -116,7 +116,7 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n         ty::TyBareFn(_, ref f) => {\n             (&f.sig, f.abi, None)\n         }\n-        ty::TyClosure(closure_did, substs) => {\n+        ty::TyClosure(closure_did, ref substs) => {\n             let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n             function_type = infcx.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);"}, {"sha": "962803932b88b03361d671be9dfd79b6dadc6c40", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -1146,8 +1146,14 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 SaveIn(lldest) => closure::Dest::SaveIn(bcx, lldest),\n                 Ignore => closure::Dest::Ignore(bcx.ccx())\n             };\n-            closure::trans_closure_expr(dest, decl, body, expr.id, bcx.fcx.param_substs)\n-                .unwrap_or(bcx)\n+            let substs = match expr_ty(bcx, expr).sty {\n+                ty::TyClosure(_, ref substs) => substs,\n+                ref t =>\n+                    bcx.tcx().sess.span_bug(\n+                        expr.span,\n+                        &format!(\"closure expr without closure type: {:?}\", t)),\n+            };\n+            closure::trans_closure_expr(dest, decl, body, expr.id, substs).unwrap_or(bcx)\n         }\n         ast::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {"}, {"sha": "4a549d9c24cdab5e0a31250e5430d2198eeae11e", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -341,8 +341,6 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let llfn = closure::trans_closure_method(bcx.ccx(),\n                                                      vtable_closure.closure_def_id,\n                                                      vtable_closure.substs,\n-                                                     MethodCallKey(method_call),\n-                                                     bcx.fcx.param_substs,\n                                                      trait_closure_kind);\n             Callee {\n                 bcx: bcx,\n@@ -646,8 +644,6 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 let llfn = closure::trans_closure_method(ccx,\n                                                          closure_def_id,\n                                                          substs,\n-                                                         ExprId(0),\n-                                                         param_substs,\n                                                          trait_closure_kind);\n                 vec![llfn].into_iter()\n             }"}, {"sha": "4cca3b7582bfb0897a3d0ee13b380ec841bf424c", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -131,7 +131,7 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             return Some(CallStep::Builtin);\n         }\n \n-        ty::TyClosure(def_id, substs) => {\n+        ty::TyClosure(def_id, ref substs) => {\n             assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n \n             // Check whether this is a call to a closure where we"}, {"sha": "cb5875ec8bcea89e9c7602c56af547331e77a21d", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -53,15 +53,26 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n            opt_kind,\n            expected_sig);\n \n-    let mut fn_ty = astconv::ty_of_closure(\n-        fcx,\n-        ast::Unsafety::Normal,\n-        decl,\n-        abi::RustCall,\n-        expected_sig);\n-\n-    let closure_type = fcx.ccx.tcx.mk_closure(expr_def_id,\n-        fcx.ccx.tcx.mk_substs(fcx.inh.infcx.parameter_environment.free_substs.clone()));\n+    let mut fn_ty = astconv::ty_of_closure(fcx,\n+                                           ast::Unsafety::Normal,\n+                                           decl,\n+                                           abi::RustCall,\n+                                           expected_sig);\n+\n+    // Create type variables (for now) to represent the transformed\n+    // types of upvars. These will be unified during the upvar\n+    // inference phase (`upvar.rs`).\n+    let num_upvars = fcx.tcx().with_freevars(expr.id, |fv| fv.len());\n+    let upvar_tys = fcx.infcx().next_ty_vars(num_upvars);\n+\n+    debug!(\"check_closure: expr.id={:?} upvar_tys={:?}\",\n+           expr.id, upvar_tys);\n+\n+    let closure_type =\n+        fcx.ccx.tcx.mk_closure(\n+            expr_def_id,\n+            fcx.ccx.tcx.mk_substs(fcx.inh.infcx.parameter_environment.free_substs.clone()),\n+            upvar_tys);\n \n     fcx.write_ty(expr.id, closure_type);\n "}, {"sha": "38207354792ae783c4cb703b74e3cf0686c81798", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -41,8 +41,7 @@ pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(),\n     let dtor_predicates = tcx.lookup_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n         ty::TyEnum(self_type_did, self_to_impl_substs) |\n-        ty::TyStruct(self_type_did, self_to_impl_substs) |\n-        ty::TyClosure(self_type_did, self_to_impl_substs) => {\n+        ty::TyStruct(self_type_did, self_to_impl_substs) => {\n             try!(ensure_drop_params_and_item_params_correspond(tcx,\n                                                                drop_impl_did,\n                                                                dtor_generics,"}, {"sha": "c6f543210ad141eb7258ec5223d0c00df237054e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -89,7 +89,6 @@ use middle::free_region::FreeRegionMap;\n use middle::implicator;\n use middle::mem_categorization as mc;\n use middle::region::CodeExtent;\n-use middle::subst::Substs;\n use middle::traits;\n use middle::ty::{self, ReScope, Ty, MethodCall, HasTypeFlags};\n use middle::infer::{self, GenericKind};\n@@ -383,7 +382,6 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                         self.region_bound_pairs.push((r_a, generic_b.clone()));\n                     }\n                     implicator::Implication::RegionSubRegion(..) |\n-                    implicator::Implication::RegionSubClosure(..) |\n                     implicator::Implication::Predicate(..) => {\n                         // In principle, we could record (and take\n                         // advantage of) every relationship here, but\n@@ -1426,9 +1424,6 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n                 generic_must_outlive(rcx, o1, r_a, generic_b);\n             }\n-            implicator::Implication::RegionSubClosure(_, r_a, def_id, substs) => {\n-                closure_must_outlive(rcx, origin.clone(), r_a, def_id, substs);\n-            }\n             implicator::Implication::Predicate(def_id, predicate) => {\n                 let cause = traits::ObligationCause::new(origin.span(),\n                                                          rcx.body_id,\n@@ -1440,23 +1435,6 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n     }\n }\n \n-fn closure_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n-                                  origin: infer::SubregionOrigin<'tcx>,\n-                                  region: ty::Region,\n-                                  def_id: ast::DefId,\n-                                  substs: &'tcx Substs<'tcx>) {\n-    debug!(\"closure_must_outlive(region={:?}, def_id={:?}, substs={:?})\",\n-           region, def_id, substs);\n-\n-    let upvars = rcx.fcx.infcx().closure_upvars(def_id, substs).unwrap();\n-    for upvar in upvars {\n-        let var_id = upvar.def.def_id().local_id();\n-        type_must_outlive(\n-            rcx, infer::FreeVariable(origin.span(), var_id),\n-            upvar.ty, region);\n-    }\n-}\n-\n fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                   origin: infer::SubregionOrigin<'tcx>,\n                                   region: ty::Region,"}, {"sha": "0e3fa654efaadf38a9f71aaca2645ddcc2752f98", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 83, "deletions": 48, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -42,9 +42,10 @@\n \n use super::FnCtxt;\n \n+use check::demand;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n-use middle::ty::{self};\n+use middle::ty::{self, Ty};\n use middle::infer::{InferCtxt, UpvarRegion};\n use std::collections::HashSet;\n use syntax::ast;\n@@ -178,55 +179,55 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         AdjustBorrowKind { fcx: fcx, closures_with_inferred_kinds: closures_with_inferred_kinds }\n     }\n \n-    fn analyze_closure(&mut self, id: ast::NodeId, decl: &ast::FnDecl, body: &ast::Block) {\n+    fn analyze_closure(&mut self,\n+                       id: ast::NodeId,\n+                       span: Span,\n+                       decl: &ast::FnDecl,\n+                       body: &ast::Block) {\n         /*!\n          * Analysis starting point.\n          */\n \n-        self.visit_block(body);\n+        debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id);\n \n-        debug!(\"analyzing closure `{}` with fn body id `{}`\", id, body.id);\n-\n-        let mut euv = euv::ExprUseVisitor::new(self, self.fcx.infcx());\n-        euv.walk_fn(decl, body);\n+        {\n+            let mut euv = euv::ExprUseVisitor::new(self, self.fcx.infcx());\n+            euv.walk_fn(decl, body);\n+        }\n \n-        // If we had not yet settled on a closure kind for this closure,\n-        // then we should have by now. Process and remove any deferred resolutions.\n-        //\n-        // Interesting fact: all calls to this closure must come\n-        // *after* its definition.  Initially, I thought that some\n-        // kind of fixed-point iteration would be required, due to the\n-        // possibility of twisted examples like this one:\n-        //\n-        // ```rust\n-        // let mut closure0 = None;\n-        // let vec = vec!(1, 2, 3);\n-        //\n-        // loop {\n-        //     {\n-        //         let closure1 = || {\n-        //             match closure0.take() {\n-        //                 Some(c) => {\n-        //                     return c(); // (*) call to `closure0` before it is defined\n-        //                 }\n-        //                 None => { }\n-        //             }\n-        //         };\n-        //         closure1();\n-        //     }\n-        //\n-        //     closure0 = || vec;\n-        // }\n-        // ```\n+        // Now that we've analyzed the closure, we know how each\n+        // variable is borrowed, and we know what traits the closure\n+        // implements (Fn vs FnMut etc). We now have some updates to do\n+        // with that information.\n         //\n-        // However, this turns out to be wrong. Examples like this\n-        // fail to compile because the type of the variable `c` above\n-        // is an inference variable.  And in fact since closure types\n-        // cannot be written, there is no way to make this example\n-        // work without a boxed closure. This implies that we can't\n-        // have two closures that recursively call one another without\n-        // some form of boxing (and hence explicit writing of a\n-        // closure kind) involved. Huzzah. -nmatsakis\n+        // Note that no closure type C may have an upvar of type C\n+        // (though it may reference itself via a trait object). This\n+        // results from the desugaring of closures to a struct like\n+        // `Foo<..., UV0...UVn>`. If one of those upvars referenced\n+        // C, then the type would have infinite size (and the\n+        // inference algorithm will reject it).\n+\n+        // Extract the type variables UV0...UVn.\n+        let closure_substs = match self.fcx.node_ty(id).sty {\n+            ty::TyClosure(_, ref substs) => substs,\n+            ref t => {\n+                self.fcx.tcx().sess.span_bug(\n+                    span,\n+                    &format!(\"type of closure expr {:?} is not a closure {:?}\",\n+                             id, t));\n+            }\n+        };\n+\n+        // Equate the type variables with the actual types.\n+        let final_upvar_tys = self.final_upvar_tys(id);\n+        debug!(\"analyze_closure: id={:?} closure_substs={:?} final_upvar_tys={:?}\",\n+               id, closure_substs, final_upvar_tys);\n+        for (&upvar_ty, final_upvar_ty) in closure_substs.upvar_tys.iter().zip(final_upvar_tys) {\n+            demand::eqtype(self.fcx, span, final_upvar_ty, upvar_ty);\n+        }\n+\n+        // Now we must process and remove any deferred resolutions,\n+        // since we have a concrete closure kind.\n         let closure_def_id = ast_util::local_def(id);\n         if self.closures_with_inferred_kinds.contains(&id) {\n             let mut deferred_call_resolutions =\n@@ -237,6 +238,42 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         }\n     }\n \n+    // Returns a list of `ClosureUpvar`s for each upvar.\n+    fn final_upvar_tys(&mut self, closure_id: ast::NodeId) -> Vec<Ty<'tcx>> {\n+        // Presently an unboxed closure type cannot \"escape\" out of a\n+        // function, so we will only encounter ones that originated in the\n+        // local crate or were inlined into it along with some function.\n+        // This may change if abstract return types of some sort are\n+        // implemented.\n+        let tcx = self.fcx.tcx();\n+        tcx.with_freevars(closure_id, |freevars| {\n+            freevars.iter()\n+                    .map(|freevar| {\n+                        let freevar_def_id = freevar.def.def_id();\n+                        let freevar_ty = self.fcx.node_ty(freevar_def_id.node);\n+                        let upvar_id = ty::UpvarId {\n+                            var_id: freevar_def_id.node,\n+                            closure_expr_id: closure_id\n+                        };\n+                        let capture = self.fcx.infcx().upvar_capture(upvar_id).unwrap();\n+\n+                        debug!(\"freevar_def_id={:?} freevar_ty={:?} capture={:?}\",\n+                               freevar_def_id, freevar_ty, capture);\n+\n+                        match capture {\n+                            ty::UpvarCapture::ByValue => freevar_ty,\n+                            ty::UpvarCapture::ByRef(borrow) =>\n+                                tcx.mk_ref(tcx.mk_region(borrow.region),\n+                                           ty::TypeAndMut {\n+                                               ty: freevar_ty,\n+                                               mutbl: borrow.kind.to_mutbl_lossy(),\n+                                           }),\n+                        }\n+                    })\n+                    .collect()\n+            })\n+    }\n+\n     fn adjust_upvar_borrow_kind_for_consume(&self,\n                                             cmt: mc::cmt<'tcx>,\n                                             mode: euv::ConsumeMode)\n@@ -268,10 +305,8 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n                         // to move out of an upvar, this must be a FnOnce closure\n                         self.adjust_closure_kind(upvar_id.closure_expr_id, ty::FnOnceClosureKind);\n \n-                        let upvar_capture_map = &mut self.fcx\n-                                                         .inh\n-                                                         .tables.borrow_mut()\n-                                                         .upvar_capture_map;\n+                        let upvar_capture_map =\n+                            &mut self.fcx.inh.tables.borrow_mut().upvar_capture_map;\n                         upvar_capture_map.insert(upvar_id, ty::UpvarCapture::ByValue);\n                     }\n                     mc::NoteClosureEnv(upvar_id) => {\n@@ -485,8 +520,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'tcx> {\n                 // ignore nested fn items\n             }\n             visit::FkFnBlock => {\n-                self.analyze_closure(id, decl, body);\n                 visit::walk_fn(self, fn_kind, decl, body, span);\n+                self.analyze_closure(id, span, decl, body);\n             }\n         }\n     }"}, {"sha": "9357d0e7615712e8f08957a09d3b3cac9c083099", "filename": "src/test/compile-fail/closure-referencing-itself-issue-25954.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Ftest%2Fcompile-fail%2Fclosure-referencing-itself-issue-25954.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Ftest%2Fcompile-fail%2Fclosure-referencing-itself-issue-25954.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-referencing-itself-issue-25954.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #25954: detect and reject a closure type that\n+// references itself.\n+\n+use std::cell::{Cell, RefCell};\n+\n+struct A<T: Fn()> {\n+    x: RefCell<Option<T>>,\n+    b: Cell<i32>,\n+}\n+\n+fn main() {\n+    let mut p = A{x: RefCell::new(None), b: Cell::new(4i32)};\n+\n+    // This is an error about types of infinite size:\n+    let q = || p.b.set(5i32); //~ ERROR mismatched types\n+\n+    *(p.x.borrow_mut()) = Some(q);\n+}"}, {"sha": "e70c00502210fa641f628276729a179c0eccada0", "filename": "src/test/compile-fail/issue-25368.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Ftest%2Fcompile-fail%2Fissue-25368.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Ftest%2Fcompile-fail%2Fissue-25368.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25368.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::sync::mpsc::channel;\n+use std::thread::spawn;\n+use std::marker::PhantomData;\n+\n+struct Foo<T> {foo: PhantomData<T>}\n+\n+fn main() {\n+    let (tx, rx) = channel();\n+\n+    spawn(move || {\n+        tx.send(Foo{ foo: PhantomData }); //~ ERROR E0282\n+    });\n+}"}, {"sha": "48b6e8b773f3b65dea7ef1d02532f2812b8bf444", "filename": "src/test/compile-fail/regions-proc-bound-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e6b534362de257603f8fc318eba78deb83206e3/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6b534362de257603f8fc318eba78deb83206e3/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs?ref=5e6b534362de257603f8fc318eba78deb83206e3", "patch": "@@ -18,7 +18,7 @@ fn borrowed_proc<'a>(x: &'a isize) -> Box<FnMut()->(isize) + 'a> {\n \n fn static_proc(x: &isize) -> Box<FnMut()->(isize) + 'static> {\n     // This is illegal, because the region bound on `proc` is 'static.\n-    Box::new(move|| { *x }) //~ ERROR captured variable `x` does not outlive the enclosing closure\n+    Box::new(move|| { *x }) //~ ERROR does not fulfill the required lifetime\n }\n \n fn main() { }"}]}