{"sha": "3f5ed285249b7222d05051b16c97e25b7bbd086d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNWVkMjg1MjQ5YjcyMjJkMDUwNTFiMTZjOTdlMjViN2JiZDA4NmQ=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-01-09T17:12:54Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-02-21T10:14:16Z"}, "message": "Let's do it the easy way\n\nQueries are cool, but too hard to find.", "tree": {"sha": "dea104fc17c9c2d50adb6748cdd2993edf0085fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dea104fc17c9c2d50adb6748cdd2993edf0085fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f5ed285249b7222d05051b16c97e25b7bbd086d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZxoS6lESXlRGMHWcaTCGhp1QZjcFAl5PrXgACgkQaTCGhp1Q\nZjetWg/9Glod3Pd6UoELLWYhaeCu/p9j7VfMSUVQtZh96rXPPFi3tlxcT5mxQzKb\nGT+HybstZsRNJt8lt0ICpLOaIDf/TCDIuPZRC+SgOTxHJm0pJ4zqqRt2b9lU7dcB\nxf6Bn92juxOLU1g5wX4kwXtPSCK0ThMkmO/CWlQPVHFqu4t9UPWw44HlLXeXTK59\nvXS9KnLR0rrc1Qr5LBnxTK8m/neYibMP34L2tpti6jjJ4eW80NO2MwBl/AWlPv7c\nL431T+3jgaosHOh4Tyyxk7a3Yq2BB3LsjGGgDx9w9OGj7nYfcwxIXAxQh6kaINn9\nqtxd3oDp6Vfy9+ictVjFkPo6rPhtRTcaMTx4q3VBoRljudCuEkWyl4yW4EnpDQLf\nO1RKZcwr+SF/XwDJYGSCnsvUm/3TsGQ/78JOVTdnmJYsVQ3Uy95NLIY5+k2ctfqp\nPr/3BXwrrnO45HQbE1p9+s8ahpQ2Xk3XLkIjQED8K9GJFdU12L0MolyS6bkGcYyG\nriGbu46ZnCVmnQJ4Gcrf+hUCcy8SsCWq9xCwwr53Lv90KLNz/MI6j8WSJy8/VkpW\nAXetAb8thu++ed8pZYVwvQa0lyl/PoI85ypAUoGA5x1P4qx+nEePBcIwwOIqFa0Q\nNgZ6IRMdhIgXtpjYPVewA6FFKBHIxjuS8/FYW8/PvZE3WOiQ/xk=\n=fIor\n-----END PGP SIGNATURE-----", "payload": "tree dea104fc17c9c2d50adb6748cdd2993edf0085fd\nparent 4229dbcf335fa7a11b5566d9e916384bf9739c34\nauthor flip1995 <hello@philkrones.com> 1578589974 +0100\ncommitter flip1995 <hello@philkrones.com> 1582280056 +0100\n\nLet's do it the easy way\n\nQueries are cool, but too hard to find.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f5ed285249b7222d05051b16c97e25b7bbd086d", "html_url": "https://github.com/rust-lang/rust/commit/3f5ed285249b7222d05051b16c97e25b7bbd086d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f5ed285249b7222d05051b16c97e25b7bbd086d/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4229dbcf335fa7a11b5566d9e916384bf9739c34", "url": "https://api.github.com/repos/rust-lang/rust/commits/4229dbcf335fa7a11b5566d9e916384bf9739c34", "html_url": "https://github.com/rust-lang/rust/commit/4229dbcf335fa7a11b5566d9e916384bf9739c34"}], "stats": {"total": 242, "additions": 40, "deletions": 202}, "files": [{"sha": "597552f033eba08d43f41968b8b103f563007ec3", "filename": "clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 40, "deletions": 202, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/3f5ed285249b7222d05051b16c97e25b7bbd086d/clippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f5ed285249b7222d05051b16c97e25b7bbd086d/clippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=3f5ed285249b7222d05051b16c97e25b7bbd086d", "patch": "@@ -1,14 +1,10 @@\n use crate::utils::{in_macro, snippet_with_applicability, span_lint_and_sugg};\n use if_chain::if_chain;\n-use rustc::ty::DefIdTree;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::intravisit::{walk_item, NestedVisitorMap, Visitor};\n use rustc_hir::*;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{symbol::Symbol, BytePos};\n+use rustc_span::BytePos;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for wildcard imports `use _::*`.\n@@ -59,213 +55,55 @@ impl LateLintPass<'_, '_> for WildcardImports {\n         if_chain! {\n             if !in_macro(item.span);\n             if let ItemKind::Use(use_path, UseKind::Glob) = &item.kind;\n-            if let Some(def_id) = use_path.res.opt_def_id();\n+            let used_imports = cx.tcx.names_imported_by_glob_use(item.hir_id.owner_def_id());\n+            if !used_imports.is_empty(); // Already handled by `unused_imports`\n             then {\n-                let hir = cx.tcx.hir();\n-                let parent_id = hir.get_parent_item(item.hir_id);\n-                let (items, in_module) = if parent_id == CRATE_HIR_ID {\n-                    let items = hir\n-                        .krate()\n-                        .module\n-                        .item_ids\n-                        .iter()\n-                        .map(|item_id| hir.get(item_id.id))\n-                        .filter_map(|node| {\n-                            if let Node::Item(item) = node {\n-                                Some(item)\n-                            } else {\n-                                None\n-                            }\n-                        })\n-                        .collect();\n-                    (items, true)\n-                } else if let Node::Item(item) = hir.get(parent_id) {\n-                    (vec![item], false)\n+                let mut applicability = Applicability::MachineApplicable;\n+                let import_source = snippet_with_applicability(cx, use_path.span, \"..\", &mut applicability);\n+                let (span, braced_glob) = if import_source.is_empty() {\n+                    // This is a `_::{_, *}` import\n+                    (\n+                        use_path.span.with_hi(use_path.span.hi() + BytePos(1)),\n+                        true,\n+                    )\n                 } else {\n-                    (vec![], false)\n+                    (\n+                        use_path.span.with_hi(use_path.span.hi() + BytePos(3)),\n+                        false,\n+                    )\n                 };\n \n-                let mut import_used_visitor = ImportsUsedVisitor {\n-                    cx,\n-                    wildcard_def_id: def_id,\n-                    in_module,\n-                    used_imports: FxHashSet::default(),\n-                };\n-                for item in items {\n-                    import_used_visitor.visit_item(item);\n-                }\n-\n-                if !import_used_visitor.used_imports.is_empty() {\n-                    let module_name = use_path\n-                        .segments\n+                let imports_string = if used_imports.len() == 1 {\n+                    used_imports.iter().next().unwrap().to_string()\n+                } else {\n+                    let mut imports = used_imports\n                         .iter()\n-                        .last()\n-                        .expect(\"path has at least one segment\")\n-                        .ident\n-                        .name;\n-\n-                    let mut applicability = Applicability::MachineApplicable;\n-                    let import_source = snippet_with_applicability(cx, use_path.span, \"..\", &mut applicability);\n-                    let (span, braced_glob) = if import_source.is_empty() {\n-                        // This is a `_::{_, *}` import\n-                        // Probably it's `_::{self, *}`, in that case we don't want to suggest to\n-                        // import `self`.\n-                        // If it is something else, we also don't want to include `self` in the\n-                        // suggestion, since either it was imported through another use statement:\n-                        // ```\n-                        // use foo::bar;\n-                        // use foo::bar::{baz, *};\n-                        // ```\n-                        // or it couldn't be used anywhere.\n-                        (\n-                            use_path.span.with_hi(use_path.span.hi() + BytePos(1)),\n-                            true,\n-                        )\n-                    } else {\n-                        (\n-                            use_path.span.with_hi(use_path.span.hi() + BytePos(3)),\n-                            false,\n-                        )\n-                    };\n-\n-                    let imports_string = if import_used_visitor.used_imports.len() == 1 {\n-                        // We don't need to check for accidental suggesting the module name instead\n-                        // of `self` here, since if `used_imports.len() == 1`, and the only usage\n-                        // is `self`, then it's not through a `*` and if there is a `*`, it gets\n-                        // already linted by `unused_imports` of rustc.\n-                        import_used_visitor.used_imports.iter().next().unwrap().to_string()\n-                    } else {\n-                        let mut imports = import_used_visitor\n-                            .used_imports\n-                            .iter()\n-                            .filter_map(|import_name| {\n-                                if braced_glob && *import_name == module_name {\n-                                    None\n-                                } else if *import_name == module_name {\n-                                    Some(\"self\".to_string())\n-                                } else {\n-                                    Some(import_name.to_string())\n-                                }\n-                            })\n-                            .collect::<Vec<_>>();\n-                        imports.sort();\n-                        if braced_glob {\n-                            imports.join(\", \")\n-                        } else {\n-                            format!(\"{{{}}}\", imports.join(\", \"))\n-                        }\n-                    };\n-\n-                    let sugg = if import_source.is_empty() {\n-                        imports_string\n+                        .map(ToString::to_string)\n+                        .collect::<Vec<_>>();\n+                    imports.sort();\n+                    if braced_glob {\n+                        imports.join(\", \")\n                     } else {\n-                        format!(\"{}::{}\", import_source, imports_string)\n-                    };\n-\n-                    span_lint_and_sugg(\n-                        cx,\n-                        WILDCARD_IMPORTS,\n-                        span,\n-                        \"usage of wildcard import\",\n-                        \"try\",\n-                        sugg,\n-                        applicability,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-struct ImportsUsedVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'a, 'tcx>,\n-    wildcard_def_id: def_id::DefId,\n-    in_module: bool,\n-    used_imports: FxHashSet<Symbol>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ImportsUsedVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_item(&mut self, item: &'tcx Item<'_>) {\n-        match item.kind {\n-            ItemKind::Use(..) => {},\n-            ItemKind::Mod(..) if self.in_module => {},\n-            ItemKind::Mod(..) => self.in_module = true,\n-            _ => walk_item(self, item),\n-        }\n-    }\n-\n-    fn visit_path(&mut self, path: &Path<'_>, _: HirId) {\n-        if let Some(def_id) = self.first_path_segment_def_id(path) {\n-            // Check if the function/enum/... was exported\n-            if let Some(exports) = self.cx.tcx.module_exports(self.wildcard_def_id) {\n-                for export in exports {\n-                    if let Some(export_def_id) = export.res.opt_def_id() {\n-                        if export_def_id == def_id {\n-                            self.used_imports.insert(\n-                                path.segments\n-                                    .iter()\n-                                    .next()\n-                                    .expect(\"path has at least one segment\")\n-                                    .ident\n-                                    .name,\n-                            );\n-                            return;\n-                        }\n+                        format!(\"{{{}}}\", imports.join(\", \"))\n                     }\n-                }\n-            }\n-\n-            // Check if it is directly in the module\n-            if let Some(parent_def_id) = self.cx.tcx.parent(def_id) {\n-                if self.wildcard_def_id == parent_def_id {\n-                    self.used_imports.insert(\n-                        path.segments\n-                            .iter()\n-                            .next()\n-                            .expect(\"path has at least one segment\")\n-                            .ident\n-                            .name,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<'_, Self::Map> {\n-        NestedVisitorMap::All(&self.cx.tcx.hir())\n-    }\n-}\n+                };\n \n-impl ImportsUsedVisitor<'_, '_> {\n-    fn skip_def_id(&self, def_id: DefId) -> DefId {\n-        let def_key = self.cx.tcx.def_key(def_id);\n-        match def_key.disambiguated_data.data {\n-            DefPathData::Ctor => {\n-                if let Some(def_id) = self.cx.tcx.parent(def_id) {\n-                    self.skip_def_id(def_id)\n+                let sugg = if import_source.is_empty() {\n+                    imports_string\n                 } else {\n-                    def_id\n-                }\n-            },\n-            _ => def_id,\n-        }\n-    }\n+                    format!(\"{}::{}\", import_source, imports_string)\n+                };\n \n-    fn first_path_segment_def_id(&self, path: &Path<'_>) -> Option<DefId> {\n-        path.res.opt_def_id().and_then(|mut def_id| {\n-            def_id = self.skip_def_id(def_id);\n-            for _ in path.segments.iter().skip(1) {\n-                def_id = self.skip_def_id(def_id);\n-                if let Some(parent_def_id) = self.cx.tcx.parent(def_id) {\n-                    def_id = parent_def_id;\n-                } else {\n-                    return None;\n-                }\n+                span_lint_and_sugg(\n+                    cx,\n+                    WILDCARD_IMPORTS,\n+                    span,\n+                    \"usage of wildcard import\",\n+                    \"try\",\n+                    sugg,\n+                    applicability,\n+                );\n             }\n-\n-            Some(def_id)\n-        })\n+        }\n     }\n }"}]}