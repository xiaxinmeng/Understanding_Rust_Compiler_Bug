{"sha": "d3b7ea6c9eae104995da1e2a29d662320d30b9f1", "node_id": "C_kwDOAAsO6NoAKGQzYjdlYTZjOWVhZTEwNDk5NWRhMWUyYTI5ZDY2MjMyMGQzMGI5ZjE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-03-01T20:08:26Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-03-12T13:18:56Z"}, "message": "Identify anonymous lifetimes by their DefId in HIR.", "tree": {"sha": "20675ed5b06943e0749df7ee277ee0773aa6a8d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20675ed5b06943e0749df7ee277ee0773aa6a8d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3b7ea6c9eae104995da1e2a29d662320d30b9f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3b7ea6c9eae104995da1e2a29d662320d30b9f1", "html_url": "https://github.com/rust-lang/rust/commit/d3b7ea6c9eae104995da1e2a29d662320d30b9f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3b7ea6c9eae104995da1e2a29d662320d30b9f1/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "012720ffb075a087b781325d17d1822a340a2f2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/012720ffb075a087b781325d17d1822a340a2f2a", "html_url": "https://github.com/rust-lang/rust/commit/012720ffb075a087b781325d17d1822a340a2f2a"}], "stats": {"total": 173, "additions": 104, "deletions": 69}, "files": [{"sha": "73fdc74b6f075dfced2bd728efb1d6b6b1087eea", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d3b7ea6c9eae104995da1e2a29d662320d30b9f1/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3b7ea6c9eae104995da1e2a29d662320d30b9f1/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=d3b7ea6c9eae104995da1e2a29d662320d30b9f1", "patch": "@@ -95,6 +95,7 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n     }\n \n     fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n+        debug!(in_scope_lifetimes = ?self.lctx.in_scope_lifetimes);\n         self.lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n             AssocCtxt::Trait => hir::OwnerNode::TraitItem(lctx.lower_trait_item(item)),\n             AssocCtxt::Impl => hir::OwnerNode::ImplItem(lctx.lower_impl_item(item)),\n@@ -118,35 +119,42 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     // This should only be used with generics that have already had their\n     // in-band lifetimes added. In practice, this means that this function is\n     // only used when lowering a child item of a trait or impl.\n+    #[tracing::instrument(level = \"debug\", skip(self, f))]\n     fn with_parent_item_lifetime_defs<T>(\n         &mut self,\n         parent_hir_id: LocalDefId,\n         f: impl FnOnce(&mut Self) -> T,\n     ) -> T {\n-        let old_len = self.in_scope_lifetimes.len();\n-\n         let parent_generics = match self.owners[parent_hir_id].unwrap().node().expect_item().kind {\n             hir::ItemKind::Impl(hir::Impl { ref generics, .. })\n             | hir::ItemKind::Trait(_, _, ref generics, ..) => generics.params,\n             _ => &[],\n         };\n-        let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n-            hir::GenericParamKind::Lifetime { .. } => Some(param.name.normalize_to_macros_2_0()),\n-            _ => None,\n-        });\n-        self.in_scope_lifetimes.extend(lt_def_names);\n+        let lt_def_names = parent_generics\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                hir::GenericParamKind::Lifetime { .. } => {\n+                    Some(param.name.normalize_to_macros_2_0())\n+                }\n+                _ => None,\n+            })\n+            .collect();\n+        let old_in_scope_lifetimes = mem::replace(&mut self.in_scope_lifetimes, lt_def_names);\n+        debug!(in_scope_lifetimes = ?self.in_scope_lifetimes);\n \n         let res = f(self);\n \n-        self.in_scope_lifetimes.truncate(old_len);\n+        self.in_scope_lifetimes = old_in_scope_lifetimes;\n         res\n     }\n \n     // Clears (and restores) the `in_scope_lifetimes` field. Used when\n     // visiting nested items, which never inherit in-scope lifetimes\n     // from their surrounding environment.\n+    #[tracing::instrument(level = \"debug\", skip(self, f))]\n     fn without_in_scope_lifetime_defs<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n         let old_in_scope_lifetimes = mem::replace(&mut self.in_scope_lifetimes, vec![]);\n+        debug!(?old_in_scope_lifetimes);\n \n         // this vector is only used when walking over impl headers,\n         // input types, and the like, and should not be non-empty in"}, {"sha": "8799e6ff89763da72a426a884cf4a0517eb29e95", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 86, "deletions": 59, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/d3b7ea6c9eae104995da1e2a29d662320d30b9f1/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3b7ea6c9eae104995da1e2a29d662320d30b9f1/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=d3b7ea6c9eae104995da1e2a29d662320d30b9f1", "patch": "@@ -136,13 +136,13 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// (i.e., it doesn't appear in the in_scope_lifetimes list), it is added\n     /// to this list. The results of this list are then added to the list of\n     /// lifetime definitions in the corresponding impl or function generics.\n-    lifetimes_to_define: Vec<(Span, ParamName)>,\n+    lifetimes_to_define: Vec<(Span, NodeId)>,\n \n     /// `true` if in-band lifetimes are being collected. This is used to\n     /// indicate whether or not we're in a place where new lifetimes will result\n     /// in in-band lifetime definitions, such a function or an impl header,\n     /// including implicit lifetimes from `impl_header_lifetime_elision`.\n-    is_collecting_anonymous_lifetimes: bool,\n+    is_collecting_anonymous_lifetimes: Option<LocalDefId>,\n \n     /// Currently in-scope lifetimes defined in impl headers, fn headers, or HRTB.\n     /// We always store a `normalize_to_macros_2_0()` version of the param-name in this\n@@ -375,7 +375,7 @@ pub fn lower_crate<'a, 'hir>(\n         task_context: None,\n         current_item: None,\n         lifetimes_to_define: Vec::new(),\n-        is_collecting_anonymous_lifetimes: false,\n+        is_collecting_anonymous_lifetimes: None,\n         in_scope_lifetimes: Vec::new(),\n         allow_try_trait: Some([sym::try_trait_v2][..].into()),\n         allow_gen_future: Some([sym::gen_future][..].into()),\n@@ -720,9 +720,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// parameter while `f` is running (and restored afterwards).\n     fn collect_in_band_defs<T>(\n         &mut self,\n+        parent_def_id: LocalDefId,\n         f: impl FnOnce(&mut Self) -> T,\n-    ) -> (Vec<(Span, ParamName)>, T) {\n-        let was_collecting = std::mem::replace(&mut self.is_collecting_anonymous_lifetimes, true);\n+    ) -> (Vec<(Span, NodeId)>, T) {\n+        let was_collecting =\n+            std::mem::replace(&mut self.is_collecting_anonymous_lifetimes, Some(parent_def_id));\n         let len = self.lifetimes_to_define.len();\n \n         let res = f(self);\n@@ -733,49 +735,41 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// Converts a lifetime into a new generic parameter.\n-    fn lifetime_to_generic_param(\n+    fn fresh_lifetime_to_generic_param(\n         &mut self,\n         span: Span,\n-        hir_name: ParamName,\n-        parent_def_id: LocalDefId,\n+        node_id: NodeId,\n     ) -> hir::GenericParam<'hir> {\n-        let node_id = self.resolver.next_node_id();\n-\n-        // Get the name we'll use to make the def-path. Note\n-        // that collisions are ok here and this shouldn't\n-        // really show up for end-user.\n-        let (str_name, kind) = match hir_name {\n-            ParamName::Plain(ident) => (ident.name, hir::LifetimeParamKind::Explicit),\n-            ParamName::Fresh(_) => (kw::UnderscoreLifetime, hir::LifetimeParamKind::Elided),\n-            ParamName::Error => (kw::UnderscoreLifetime, hir::LifetimeParamKind::Error),\n-        };\n-\n-        // Add a definition for the in-band lifetime def.\n-        self.resolver.create_def(\n-            parent_def_id,\n-            node_id,\n-            DefPathData::LifetimeNs(str_name),\n-            ExpnId::root(),\n-            span.with_parent(None),\n-        );\n-\n+        let hir_id = self.lower_node_id(node_id);\n+        let def_id = self.resolver.local_def_id(node_id);\n         hir::GenericParam {\n-            hir_id: self.lower_node_id(node_id),\n-            name: hir_name,\n+            hir_id,\n+            name: hir::ParamName::Fresh(def_id),\n             bounds: &[],\n             span: self.lower_span(span),\n             pure_wrt_drop: false,\n-            kind: hir::GenericParamKind::Lifetime { kind },\n+            kind: hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Elided },\n         }\n     }\n \n     /// When we have either an elided or `'_` lifetime in an impl\n     /// header, we convert it to an in-band lifetime.\n     fn collect_fresh_anonymous_lifetime(&mut self, span: Span) -> ParamName {\n-        assert!(self.is_collecting_anonymous_lifetimes);\n-        let index = self.lifetimes_to_define.len() + self.in_scope_lifetimes.len();\n-        let hir_name = ParamName::Fresh(index);\n-        self.lifetimes_to_define.push((span, hir_name));\n+        let Some(parent_def_id) = self.is_collecting_anonymous_lifetimes else { panic!() };\n+\n+        let node_id = self.resolver.next_node_id();\n+\n+        // Add a definition for the in-band lifetime def.\n+        let param_def_id = self.resolver.create_def(\n+            parent_def_id,\n+            node_id,\n+            DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+            ExpnId::root(),\n+            span.with_parent(None),\n+        );\n+\n+        let hir_name = ParamName::Fresh(param_def_id);\n+        self.lifetimes_to_define.push((span, node_id));\n         hir_name\n     }\n \n@@ -817,7 +811,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         f: impl FnOnce(&mut Self, &mut Vec<hir::GenericParam<'hir>>) -> T,\n     ) -> (hir::Generics<'hir>, T) {\n         let (lifetimes_to_define, (mut lowered_generics, impl_trait_defs, res)) = self\n-            .collect_in_band_defs(|this| {\n+            .collect_in_band_defs(parent_def_id, |this| {\n                 this.with_anonymous_lifetime_mode(anonymous_lifetime_mode, |this| {\n                     this.with_in_scope_lifetime_defs(&generics.params, |this| {\n                         let mut impl_trait_defs = Vec::new();\n@@ -844,9 +838,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         lowered_generics.params.extend(\n             lifetimes_to_define\n                 .into_iter()\n-                .map(|(span, hir_name)| {\n-                    self.lifetime_to_generic_param(span, hir_name, parent_def_id)\n-                })\n+                .map(|(span, node_id)| self.fresh_lifetime_to_generic_param(span, node_id))\n                 .chain(impl_trait_defs),\n         );\n \n@@ -1763,15 +1755,53 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .in_scope_lifetimes\n             .iter()\n             .cloned()\n-            .map(|name| (name.ident().span, name, hir::LifetimeName::Param(name)))\n-            .chain(\n-                self.lifetimes_to_define\n-                    .iter()\n-                    .map(|&(span, name)| (span, name, hir::LifetimeName::Param(name))),\n-            )\n+            .map(|name| (name.ident().span, hir::LifetimeName::Param(name)))\n+            .chain(self.lifetimes_to_define.iter().map(|&(span, node_id)| {\n+                let def_id = self.resolver.local_def_id(node_id);\n+                let name = hir::ParamName::Fresh(def_id);\n+                (span, hir::LifetimeName::Param(name))\n+            }))\n             .collect();\n \n         self.with_hir_id_owner(opaque_ty_node_id, |this| {\n+            let mut generic_params: Vec<_> = lifetime_params\n+                .iter()\n+                .map(|&(span, name)| {\n+                    // We can only get lifetime names from the outside.\n+                    let hir::LifetimeName::Param(hir_name) = name else { panic!() };\n+\n+                    let node_id = this.resolver.next_node_id();\n+\n+                    // Add a definition for the in-band lifetime def.\n+                    let def_id = this.resolver.create_def(\n+                        opaque_ty_def_id,\n+                        node_id,\n+                        DefPathData::LifetimeNs(hir_name.ident().name),\n+                        ExpnId::root(),\n+                        span.with_parent(None),\n+                    );\n+\n+                    let (kind, name) = match hir_name {\n+                        ParamName::Plain(ident) => {\n+                            (hir::LifetimeParamKind::Explicit, hir::ParamName::Plain(ident))\n+                        }\n+                        ParamName::Fresh(_) => {\n+                            (hir::LifetimeParamKind::Elided, hir::ParamName::Fresh(def_id))\n+                        }\n+                        ParamName::Error => (hir::LifetimeParamKind::Error, hir::ParamName::Error),\n+                    };\n+\n+                    hir::GenericParam {\n+                        hir_id: this.lower_node_id(node_id),\n+                        name,\n+                        bounds: &[],\n+                        span: this.lower_span(span),\n+                        pure_wrt_drop: false,\n+                        kind: hir::GenericParamKind::Lifetime { kind },\n+                    }\n+                })\n+                .collect();\n+\n             // We have to be careful to get elision right here. The\n             // idea is that we create a lifetime parameter for each\n             // lifetime in the return type.  So, given a return type\n@@ -1782,25 +1812,22 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // hence the elision takes place at the fn site.\n             let (lifetimes_to_define, future_bound) =\n                 this.with_anonymous_lifetime_mode(AnonymousLifetimeMode::CreateParameter, |this| {\n-                    this.collect_in_band_defs(|this| {\n+                    this.collect_in_band_defs(opaque_ty_def_id, |this| {\n                         this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span)\n                     })\n                 });\n             debug!(\"lower_async_fn_ret_ty: future_bound={:#?}\", future_bound);\n             debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", lifetimes_to_define);\n \n-            lifetime_params.extend(\n-                // Output lifetime like `'_`:\n-                lifetimes_to_define\n-                    .into_iter()\n-                    .map(|(span, name)| (span, name, hir::LifetimeName::Implicit(false))),\n-            );\n+            // Output lifetime like `'_`:\n+            for (span, node_id) in lifetimes_to_define {\n+                let param = this.fresh_lifetime_to_generic_param(span, node_id);\n+                lifetime_params.push((span, hir::LifetimeName::Implicit(false)));\n+                generic_params.push(param);\n+            }\n+            let generic_params = this.arena.alloc_from_iter(generic_params);\n             debug!(\"lower_async_fn_ret_ty: lifetime_params={:#?}\", lifetime_params);\n-\n-            let generic_params =\n-                this.arena.alloc_from_iter(lifetime_params.iter().map(|&(span, hir_name, _)| {\n-                    this.lifetime_to_generic_param(span, hir_name, opaque_ty_def_id)\n-                }));\n+            debug!(\"lower_async_fn_ret_ty: generic_params={:#?}\", generic_params);\n \n             let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n@@ -1833,7 +1860,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // For the \"output\" lifetime parameters, we just want to\n         // generate `'_`.\n         let generic_args =\n-            self.arena.alloc_from_iter(lifetime_params.into_iter().map(|(span, _, name)| {\n+            self.arena.alloc_from_iter(lifetime_params.into_iter().map(|(span, name)| {\n                 GenericArg::Lifetime(hir::Lifetime {\n                     hir_id: self.next_id(),\n                     span: self.lower_span(span),\n@@ -1969,7 +1996,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let (name, kind) = match param.kind {\n             GenericParamKind::Lifetime => {\n                 let was_collecting_in_band = self.is_collecting_anonymous_lifetimes;\n-                self.is_collecting_anonymous_lifetimes = false;\n+                self.is_collecting_anonymous_lifetimes = None;\n \n                 let lt = self\n                     .with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {"}, {"sha": "64ce196e4407bd727693d6717a776b11d2110a91", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3b7ea6c9eae104995da1e2a29d662320d30b9f1/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3b7ea6c9eae104995da1e2a29d662320d30b9f1/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=d3b7ea6c9eae104995da1e2a29d662320d30b9f1", "patch": "@@ -59,7 +59,7 @@ pub enum ParamName {\n     ///\n     /// where `'f` is something like `Fresh(0)`. The indices are\n     /// unique per impl, but not necessarily continuous.\n-    Fresh(usize),\n+    Fresh(LocalDefId),\n \n     /// Indicates an illegal name was given and an error has been\n     /// reported (so we should squelch other derived errors). Occurs\n@@ -3303,7 +3303,7 @@ mod size_asserts {\n     rustc_data_structures::static_assert_size!(super::Expr<'static>, 56);\n     rustc_data_structures::static_assert_size!(super::Pat<'static>, 88);\n     rustc_data_structures::static_assert_size!(super::QPath<'static>, 24);\n-    rustc_data_structures::static_assert_size!(super::Ty<'static>, 80);\n+    rustc_data_structures::static_assert_size!(super::Ty<'static>, 72);\n \n     rustc_data_structures::static_assert_size!(super::Item<'static>, 184);\n     rustc_data_structures::static_assert_size!(super::TraitItem<'static>, 128);"}]}