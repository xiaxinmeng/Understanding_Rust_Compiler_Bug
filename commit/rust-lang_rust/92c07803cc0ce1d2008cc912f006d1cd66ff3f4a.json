{"sha": "92c07803cc0ce1d2008cc912f006d1cd66ff3f4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyYzA3ODAzY2MwY2UxZDIwMDhjYzkxMmYwMDZkMWNkNjZmZjNmNGE=", "commit": {"author": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-07T16:37:54Z"}, "committer": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-08T17:34:53Z"}, "message": "Rename `textual_macro` -> `legacy_macro`\nAdd comments", "tree": {"sha": "2ab6e7c3f12be1d82e9da854e4ed091b7fd15877", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ab6e7c3f12be1d82e9da854e4ed091b7fd15877"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92c07803cc0ce1d2008cc912f006d1cd66ff3f4a", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl11O70ACgkQztOS3gxI\nPQCEhA//cElisOEc5ByjDa9pjh4yRd/+2i2/4THl6nWz/vQUHzzWoWRSE4ExDVKR\ntVfCjlFnOJdMEnEaEXcTjhm/kdaeKClvuiiHZFQP5sYsmBtxQ5bCJN+vvp8iogE5\niRx/5ZAF0OT1L9/1D8VOAfCd+I3NrxXRwP0fx7fkWZi658m+p4gxyOg2J5POmz2y\n96vvNy5zagzYyBepILNJDB+36Dz2/IY+hawpAO7RqaSqLk4FfeGjiPMXPM7TffV9\n05p2kqsThA4+7cPtSTgJNljhhf7UAgCbsZmDm5CgSVAVsGvgXo/iD5GYdrmxzo6C\nM5slP6DBXKkhQVqj1TYxMPpcFcs5gbv7U7ffJ77DFAB6Jrr4ycvvnovpfYdp0miI\nmGTH68TSCFO8bDoDGUjFUaBnDFI883k346a//yt97fLIUCAWIOaMEdYnQOSfeHeb\nUrZ91CNZulumw693imp8nT++zXwdW50f3P7yS81DQSNOFrKI/iySGx/6uw3eAoTy\nTwGts9MJjk4bmEn4Xe5K82fpt82b2KScaktxoW8sBe8/i38tQDXdlXspQ3W+Jgt5\nJfZ8BipDP1oczT4oGpcrHS9d/CAXDGZuF6M71qfheHVXECHr0HZr4QFj/TWWfLFg\n0RzZJA1rDuVKNlPiK5wsDCvZxZ1NpyAmGuf4q1XEryXcg8Yzsj8=\n=OFG7\n-----END PGP SIGNATURE-----", "payload": "tree 2ab6e7c3f12be1d82e9da854e4ed091b7fd15877\nparent f7f7c2aff80f0870f0d71bf70075e3b5bf68994f\nauthor uHOOCCOOHu <hooccooh1896@gmail.com> 1567874274 +0800\ncommitter uHOOCCOOHu <hooccooh1896@gmail.com> 1567964093 +0800\n\nRename `textual_macro` -> `legacy_macro`\nAdd comments\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92c07803cc0ce1d2008cc912f006d1cd66ff3f4a", "html_url": "https://github.com/rust-lang/rust/commit/92c07803cc0ce1d2008cc912f006d1cd66ff3f4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92c07803cc0ce1d2008cc912f006d1cd66ff3f4a/comments", "author": null, "committer": null, "parents": [{"sha": "f7f7c2aff80f0870f0d71bf70075e3b5bf68994f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7f7c2aff80f0870f0d71bf70075e3b5bf68994f", "html_url": "https://github.com/rust-lang/rust/commit/f7f7c2aff80f0870f0d71bf70075e3b5bf68994f"}], "stats": {"total": 68, "additions": 39, "deletions": 29}, "files": [{"sha": "74546e5e29c9986db4a152ae127fcc1e4ec150e5", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/92c07803cc0ce1d2008cc912f006d1cd66ff3f4a/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92c07803cc0ce1d2008cc912f006d1cd66ff3f4a/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=92c07803cc0ce1d2008cc912f006d1cd66ff3f4a", "patch": "@@ -138,8 +138,21 @@ pub(crate) struct ModuleData {\n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct ModuleScope {\n     items: FxHashMap<Name, Resolution>,\n+    /// Macros in current module scoped\n+    ///\n+    /// This scope works exactly the same way that item scoping does.\n+    /// Macro invocation with quantified path will search in it.\n+    /// See details below.\n     macros: FxHashMap<Name, MacroDef>,\n-    textual_macros: FxHashMap<Name, MacroDef>,\n+    /// Macros visable in current module in legacy textual scope\n+    ///\n+    /// For macros invoked by an unquatified identifier like `bar!()`, `legacy_macros` will be searched in first.\n+    /// If it yields no result, then it turns to module scoped `macros`.\n+    /// It macros with name quatified with a path like `crate::foo::bar!()`, `legacy_macros` will be skipped,\n+    /// and only normal scoped `macros` will be searched in.\n+    ///\n+    /// Note that this automatically inherit macros defined textually before the definition of module itself.\n+    legacy_macros: FxHashMap<Name, MacroDef>,\n }\n \n static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n@@ -173,8 +186,8 @@ impl ModuleScope {\n             _ => None,\n         }\n     }\n-    fn get_textual_macro(&self, name: &Name) -> Option<MacroDef> {\n-        self.textual_macros.get(name).copied()\n+    fn get_legacy_macro(&self, name: &Name) -> Option<MacroDef> {\n+        self.legacy_macros.get(name).copied()\n     }\n }\n \n@@ -489,21 +502,21 @@ impl CrateDefMap {\n         name: &Name,\n     ) -> ItemOrMacro {\n         // Resolve in:\n-        //  - textual scoped macros\n+        //  - legacy scope\n         //  - current module / scope\n         //  - extern prelude\n         //  - std prelude\n-        let from_textual_mcro = self[module]\n+        let from_legacy_macro = self[module]\n             .scope\n-            .get_textual_macro(name)\n+            .get_legacy_macro(name)\n             .map_or_else(|| Either::A(PerNs::none()), Either::B);\n         let from_scope =\n             self[module].scope.get_item_or_macro(name).unwrap_or_else(|| Either::A(PerNs::none()));\n         let from_extern_prelude =\n             self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n         let from_prelude = self.resolve_in_prelude(db, name);\n \n-        or(from_textual_mcro, or(from_scope, or(Either::A(from_extern_prelude), from_prelude)))\n+        or(from_legacy_macro, or(from_scope, or(Either::A(from_extern_prelude), from_prelude)))\n     }\n \n     fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {"}, {"sha": "09cda76567c7de968f6ffa31ce3ab8dd7dfb4883", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/92c07803cc0ce1d2008cc912f006d1cd66ff3f4a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92c07803cc0ce1d2008cc912f006d1cd66ff3f4a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=92c07803cc0ce1d2008cc912f006d1cd66ff3f4a", "patch": "@@ -146,22 +146,19 @@ where\n             self.def_map.exported_macros.insert(name.clone(), macro_id);\n         }\n         self.update(module_id, None, &[(name.clone(), def)]);\n-        self.define_textual_macro(module_id, name.clone(), macro_id);\n+        self.define_legacy_macro(module_id, name.clone(), macro_id);\n     }\n \n-    /// Define a macro in current textual scope.\n+    /// Define a legacy textual scoped macro in module\n     ///\n-    /// We use a map `textual_macros` to store all textual macros visable per module.\n-    /// It will clone all macros from parent textual scope, whose definition is prior to\n+    /// We use a map `legacy_macros` to store all legacy textual scoped macros visable per module.\n+    /// It will clone all macros from parent legacy scope, whose definition is prior to\n     /// the definition of current module.\n-    /// And also, `macro_use` on a module will import all textual macros visable inside to\n-    /// current textual scope, with possible shadowing.\n-    fn define_textual_macro(&mut self, module_id: CrateModuleId, name: Name, macro_id: MacroDefId) {\n+    /// And also, `macro_use` on a module will import all legacy macros visable inside to\n+    /// current legacy scope, with possible shadowing.\n+    fn define_legacy_macro(&mut self, module_id: CrateModuleId, name: Name, macro_id: MacroDefId) {\n         // Always shadowing\n-        self.def_map.modules[module_id]\n-            .scope\n-            .textual_macros\n-            .insert(name, MacroDef { id: macro_id });\n+        self.def_map.modules[module_id].scope.legacy_macros.insert(name, MacroDef { id: macro_id });\n     }\n \n     /// Import macros from `#[macro_use] extern crate`.\n@@ -194,7 +191,7 @@ where\n     fn import_all_macros_exported(&mut self, current_module_id: CrateModuleId, module: Module) {\n         let item_map = self.db.crate_def_map(module.krate);\n         for (name, &macro_id) in &item_map.exported_macros {\n-            self.define_textual_macro(current_module_id, name.clone(), macro_id);\n+            self.define_legacy_macro(current_module_id, name.clone(), macro_id);\n         }\n     }\n \n@@ -578,7 +575,7 @@ where\n                 }\n                 .collect(&*items);\n                 if *is_macro_use {\n-                    self.import_all_textual_macros(module_id);\n+                    self.import_all_legacy_macros(module_id);\n                 }\n             }\n             // out of line module, resolve, parse and recurse\n@@ -605,7 +602,7 @@ where\n                         }\n                         .collect(raw_items.items());\n                         if *is_macro_use {\n-                            self.import_all_textual_macros(module_id);\n+                            self.import_all_legacy_macros(module_id);\n                         }\n                     }\n                     Err(candidate) => self.def_collector.def_map.diagnostics.push(\n@@ -631,7 +628,7 @@ where\n         modules[res].parent = Some(self.module_id);\n         modules[res].declaration = Some(declaration);\n         modules[res].definition = definition;\n-        modules[res].scope.textual_macros = modules[self.module_id].scope.textual_macros.clone();\n+        modules[res].scope.legacy_macros = modules[self.module_id].scope.legacy_macros.clone();\n         modules[self.module_id].children.insert(name.clone(), res);\n         let resolution = Resolution {\n             def: PerNs::types(\n@@ -685,10 +682,10 @@ where\n \n         let ast_id = mac.ast_id.with_file_id(self.file_id);\n \n-        // Case 2: try to resolve in textual scope and expand macro_rules, triggering\n+        // Case 2: try to resolve in legacy scope and expand macro_rules, triggering\n         // recursive item collection.\n         if let Some(macro_def) = mac.path.as_ident().and_then(|name| {\n-            self.def_collector.def_map[self.module_id].scope.get_textual_macro(&name)\n+            self.def_collector.def_map[self.module_id].scope.get_legacy_macro(&name)\n         }) {\n             let def = macro_def.id;\n             let macro_call_id = MacroCallLoc { def, ast_id }.id(self.def_collector.db);\n@@ -706,10 +703,10 @@ where\n         self.def_collector.unexpanded_macros.push((self.module_id, ast_id, path));\n     }\n \n-    fn import_all_textual_macros(&mut self, module_id: CrateModuleId) {\n-        let macros = self.def_collector.def_map[module_id].scope.textual_macros.clone();\n+    fn import_all_legacy_macros(&mut self, module_id: CrateModuleId) {\n+        let macros = self.def_collector.def_map[module_id].scope.legacy_macros.clone();\n         for (name, macro_) in macros {\n-            self.def_collector.define_textual_macro(self.module_id, name.clone(), macro_.id);\n+            self.def_collector.define_legacy_macro(self.module_id, name.clone(), macro_.id);\n         }\n     }\n }"}, {"sha": "21fab53e947413e56da1de32a764cefa868fd619", "filename": "crates/ra_hir/src/nameres/tests/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92c07803cc0ce1d2008cc912f006d1cd66ff3f4a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92c07803cc0ce1d2008cc912f006d1cd66ff3f4a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=92c07803cc0ce1d2008cc912f006d1cd66ff3f4a", "patch": "@@ -279,7 +279,7 @@ fn prelude_cycle() {\n }\n \n #[test]\n-fn plain_macros_are_textual_scoped() {\n+fn plain_macros_are_legacy_textual_scoped() {\n     let map = def_map(\n         r#\"\n         //- /main.rs"}, {"sha": "25716fe8c105d2316fbb1b4761dc9f341ef5ab3b", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92c07803cc0ce1d2008cc912f006d1cd66ff3f4a/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92c07803cc0ce1d2008cc912f006d1cd66ff3f4a/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=92c07803cc0ce1d2008cc912f006d1cd66ff3f4a", "patch": "@@ -2804,7 +2804,7 @@ fn main() {\n }\n \n #[test]\n-fn infer_textual_scoped_macros_expanded() {\n+fn infer_legacy_textual_scoped_macros_expanded() {\n     assert_snapshot!(\n         infer(r#\"\n struct Foo(Vec<i32>);"}]}