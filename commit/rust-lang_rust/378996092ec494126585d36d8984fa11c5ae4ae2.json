{"sha": "378996092ec494126585d36d8984fa11c5ae4ae2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3ODk5NjA5MmVjNDk0MTI2NTg1ZDM2ZDg5ODRmYTExYzVhZTRhZTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-13T21:52:11Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-14T04:06:57Z"}, "message": "store into the borrowings table", "tree": {"sha": "dea7e2db86c0e6713b6c816e431da82a9b7d9195", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dea7e2db86c0e6713b6c816e431da82a9b7d9195"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/378996092ec494126585d36d8984fa11c5ae4ae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/378996092ec494126585d36d8984fa11c5ae4ae2", "html_url": "https://github.com/rust-lang/rust/commit/378996092ec494126585d36d8984fa11c5ae4ae2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/378996092ec494126585d36d8984fa11c5ae4ae2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d73185f3e848c0b317341b11318f1a27d1270eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d73185f3e848c0b317341b11318f1a27d1270eb", "html_url": "https://github.com/rust-lang/rust/commit/4d73185f3e848c0b317341b11318f1a27d1270eb"}], "stats": {"total": 120, "additions": 61, "deletions": 59}, "files": [{"sha": "513cd524d72bec87ce3ac47cbf95ccfe228a03a1", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/378996092ec494126585d36d8984fa11c5ae4ae2/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/378996092ec494126585d36d8984fa11c5ae4ae2/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=378996092ec494126585d36d8984fa11c5ae4ae2", "patch": "@@ -1,6 +1,7 @@\n import std::smallintmap;\n import std::smallintmap::smallintmap;\n import std::smallintmap::map;\n+import std::map::hashmap;\n import middle::ty;\n import middle::ty::{ty_vid, region_vid, vid};\n import syntax::ast;\n@@ -77,11 +78,12 @@ fn mk_eqty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n     indent {|| cx.commit {|| cx.eq_tys(a, b) } }.to_ures()\n }\n \n-fn mk_assignty(cx: infer_ctxt, encl_node_id: ast::node_id,\n+fn mk_assignty(cx: infer_ctxt, a_node_id: ast::node_id,\n              a: ty::t, b: ty::t) -> ures {\n-    #debug[\"mk_assignty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n+    #debug[\"mk_assignty(%? / %s <: %s)\",\n+           a_node_id, a.to_str(cx), b.to_str(cx)];\n     indent {|| cx.commit {||\n-        cx.assign_tys(encl_node_id, a, b)\n+        cx.assign_tys(a_node_id, a, b)\n     } }.to_ures()\n }\n \n@@ -686,7 +688,7 @@ impl resolve_methods for infer_ctxt {\n // Type assignment\n //\n // True if rvalues of type `a` can be assigned to lvalues of type `b`.\n-// This may cause borrowing to the region scope for `encl_node_id`.\n+// This may cause borrowing to the region scope enclosing `a_node_id`.\n //\n // The strategy here is somewhat non-obvious.  The problem is\n // that the constraint we wish to contend with is not a subtyping\n@@ -730,7 +732,7 @@ impl resolve_methods for infer_ctxt {\n // this upper-bound might be stricter than what is truly needed.\n \n impl assignment for infer_ctxt {\n-    fn assign_tys(encl_node_id: ast::node_id,\n+    fn assign_tys(a_node_id: ast::node_id,\n                   a: ty::t, b: ty::t) -> ures {\n \n         fn select(fst: option<ty::t>, snd: option<ty::t>) -> option<ty::t> {\n@@ -745,8 +747,8 @@ impl assignment for infer_ctxt {\n             }\n         }\n \n-        #debug[\"assign_tys(encl_node_id=%?, %s -> %s)\",\n-               encl_node_id, a.to_str(self), b.to_str(self)];\n+        #debug[\"assign_tys(a_node_id=%?, %s -> %s)\",\n+               a_node_id, a.to_str(self), b.to_str(self)];\n         let _r = indenter();\n \n         alt (ty::get(a).struct, ty::get(b).struct) {\n@@ -759,34 +761,34 @@ impl assignment for infer_ctxt {\n             let {root:_, bounds: b_bounds} = self.get(self.vb, b_id);\n             let a_bnd = select(a_bounds.ub, a_bounds.lb);\n             let b_bnd = select(b_bounds.lb, b_bounds.ub);\n-            self.assign_tys_or_sub(encl_node_id, a, b, a_bnd, b_bnd)\n+            self.assign_tys_or_sub(a_node_id, a, b, a_bnd, b_bnd)\n           }\n \n           (ty::ty_var(a_id), _) {\n             let {root:_, bounds:a_bounds} = self.get(self.vb, a_id);\n             let a_bnd = select(a_bounds.ub, a_bounds.lb);\n-            self.assign_tys_or_sub(encl_node_id, a, b, a_bnd, some(b))\n+            self.assign_tys_or_sub(a_node_id, a, b, a_bnd, some(b))\n           }\n \n           (_, ty::ty_var(b_id)) {\n             let {root:_, bounds: b_bounds} = self.get(self.vb, b_id);\n             let b_bnd = select(b_bounds.lb, b_bounds.ub);\n-            self.assign_tys_or_sub(encl_node_id, a, b, some(a), b_bnd)\n+            self.assign_tys_or_sub(a_node_id, a, b, some(a), b_bnd)\n           }\n \n           (_, _) {\n-            self.assign_tys_or_sub(encl_node_id, a, b, some(a), some(b))\n+            self.assign_tys_or_sub(a_node_id, a, b, some(a), some(b))\n           }\n         }\n     }\n \n     fn assign_tys_or_sub(\n-        encl_node_id: ast::node_id,\n+        a_node_id: ast::node_id,\n         a: ty::t, b: ty::t,\n         a_bnd: option<ty::t>, b_bnd: option<ty::t>) -> ures {\n \n-        #debug[\"assign_tys_or_sub(encl_node_id=%?, %s -> %s, %s -> %s)\",\n-               encl_node_id, a.to_str(self), b.to_str(self),\n+        #debug[\"assign_tys_or_sub(a_node_id=%?, %s -> %s, %s -> %s)\",\n+               a_node_id, a.to_str(self), b.to_str(self),\n                a_bnd.to_str(self), b_bnd.to_str(self)];\n         let _r = indenter();\n \n@@ -802,17 +804,17 @@ impl assignment for infer_ctxt {\n             alt (ty::get(a_bnd).struct, ty::get(b_bnd).struct) {\n               (ty::ty_box(mt_a), ty::ty_rptr(r_b, mt_b)) {\n                 let nr_b = ty::mk_box(self.tcx, mt_b);\n-                self.crosspolinate(encl_node_id, a, nr_b, r_b)\n+                self.crosspolinate(a_node_id, a, nr_b, r_b)\n               }\n               (ty::ty_uniq(mt_a), ty::ty_rptr(r_b, mt_b)) {\n                 let nr_b = ty::mk_uniq(self.tcx, mt_b);\n-                self.crosspolinate(encl_node_id, a, nr_b, r_b)\n+                self.crosspolinate(a_node_id, a, nr_b, r_b)\n               }\n               (ty::ty_evec(mt_a, vs_a),\n                ty::ty_evec(mt_b, ty::vstore_slice(r_b)))\n               if is_borrowable(vs_a) {\n                 let nr_b = ty::mk_evec(self.tcx, mt_b, vs_a);\n-                self.crosspolinate(encl_node_id, a, nr_b, r_b)\n+                self.crosspolinate(a_node_id, a, nr_b, r_b)\n               }\n               _ {\n                 self.sub_tys(a, b)\n@@ -825,17 +827,26 @@ impl assignment for infer_ctxt {\n         }\n     }\n \n-    fn crosspolinate(encl_node_id: ast::node_id,\n-                     a: ty::t, nr_b: ty::t, r_b: ty::region) -> ures {\n+    fn crosspolinate(a_node_id: ast::node_id,\n+                     a: ty::t,\n+                     nr_b: ty::t,\n+                     r_b: ty::region) -> ures {\n \n-        #debug[\"crosspolinate(encl_node_id=%?, a=%s, nr_b=%s, r_b=%s)\",\n-               encl_node_id, a.to_str(self), nr_b.to_str(self),\n+        #debug[\"crosspolinate(a_node_id=%?, a=%s, nr_b=%s, r_b=%s)\",\n+               a_node_id, a.to_str(self), nr_b.to_str(self),\n                r_b.to_str(self)];\n \n         indent {||\n             self.sub_tys(a, nr_b).then {||\n-                let r_a = ty::re_scope(encl_node_id);\n-                sub(self).contraregions(r_a, r_b).to_ures()\n+                let a_scope_id = self.tcx.region_map.parents.get(a_node_id);\n+                let r_a = ty::re_scope(a_scope_id);\n+                #debug[\"a_scope_id=%?\", a_scope_id];\n+                sub(self).contraregions(r_a, r_b).chain {|_r|\n+                    // if successful, add an entry indicating that\n+                    // borrowing occurred\n+                    self.tcx.borrowings.insert(a_node_id, ());\n+                    uok()\n+                }\n             }\n         }\n     }"}, {"sha": "d5a3169f1b5cb828f888b7bb0114b88786face4d", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/378996092ec494126585d36d8984fa11c5ae4ae2/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/378996092ec494126585d36d8984fa11c5ae4ae2/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=378996092ec494126585d36d8984fa11c5ae4ae2", "patch": "@@ -192,12 +192,6 @@ enum ast_ty_to_ty_cache_entry {\n     atttce_resolved(t)  /* resolved to a type, irrespective of region */\n }\n \n-enum borrowing {\n-    bo_none,\n-    bo_box(@borrowing),\n-    bo_uniq(@borrowing)\n-}\n-\n type ctxt =\n     @{interner: hashmap<intern_key, t_box>,\n       mut next_id: uint,\n@@ -229,7 +223,7 @@ type ctxt =\n       iface_method_cache: hashmap<def_id, @[method]>,\n       ty_param_bounds: hashmap<ast::node_id, param_bounds>,\n       inferred_modes: hashmap<ast::node_id, ast::mode>,\n-      borrowings: hashmap<ast::node_id, borrowing>};\n+      borrowings: hashmap<ast::node_id, ()>};\n \n type t_box = @{struct: sty,\n                id: uint,"}, {"sha": "49c2b0adc38dcc8a9a0c531043b92d34eef9d6cb", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/378996092ec494126585d36d8984fa11c5ae4ae2/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/378996092ec494126585d36d8984fa11c5ae4ae2/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=378996092ec494126585d36d8984fa11c5ae4ae2", "patch": "@@ -1426,15 +1426,13 @@ mod demand {\n         }\n     }\n \n-    // Checks that the type `actual` can be assigned to `expected`, borrowing\n-    // to `encl_node_id` if necessary.\n-    fn assign(fcx: @fn_ctxt, sp: span, encl_node_id: ast::node_id,\n-              expected: ty::t, actual: ty::t) {\n-\n-        alt infer::mk_assignty(fcx.infcx, encl_node_id, actual, expected) {\n+    // Checks that the type `actual` can be assigned to `expected`.\n+    fn assign(fcx: @fn_ctxt, sp: span, expected: ty::t, expr: @ast::expr) {\n+        let expr_ty = fcx.expr_ty(expr);\n+        alt infer::mk_assignty(fcx.infcx, expr.id, expr_ty, expected) {\n           result::ok(()) { /* ok */ }\n           result::err(err) {\n-            fcx.report_mismatched_types(sp, expected, actual, err);\n+            fcx.report_mismatched_types(sp, expected, expr_ty, err);\n           }\n         }\n     }\n@@ -2179,17 +2177,16 @@ fn require_pure_call(ccx: @crate_ctxt, caller_purity: ast::purity,\n     }\n }\n \n-type unifier = fn(@fn_ctxt, span, ty::t, ty::t);\n-\n fn check_expr(fcx: @fn_ctxt, expr: @ast::expr) -> bool {\n-    ret check_expr_with_unifier(fcx, expr, ty::mk_nil(fcx.ccx.tcx)) {\n-        |_fcx, _span, _t1, _t2|\n-        /* unify is a no-op */\n+    ret check_expr_with_unifier(fcx, expr, ty::mk_nil(fcx.ccx.tcx)) {||\n+        /* do not take any action on unify */\n     };\n }\n \n fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n-    ret check_expr_with_unifier(fcx, expr, expected, demand::suptype);\n+    ret check_expr_with_unifier(fcx, expr, expected) {||\n+        demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n+    };\n }\n \n // determine the `self` type, using fresh variables for all variables declared\n@@ -2548,9 +2545,8 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n                               proto: ast::proto,\n                               decl: ast::fn_decl,\n                               body: ast::blk,\n-                              unifier: unifier,\n-                              expected: ty::t,\n-                              is_loop_body: bool) {\n+                              is_loop_body: bool,\n+                              unifier: fn()) {\n     let tcx = fcx.ccx.tcx;\n     let fty = ty::mk_fn(tcx,\n                         ty_of_fn_decl(tcx, m_check_tyvar(fcx), proto, decl));\n@@ -2564,7 +2560,7 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n     // typecheck the body so that we have more information about the\n     // argument types in the body. This is needed to make binops and\n     // record projection work on type inferred arguments.\n-    unifier(fcx, expr.span, expected, fty);\n+    unifier();\n \n     let ret_ty = ty::ty_fn_ret(fty);\n     let arg_tys = vec::map(ty::ty_fn_args(fty)) {|a| a.ty };\n@@ -2574,8 +2570,10 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n              fcx.self_ty);\n }\n \n-fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr,\n-                           expected: ty::t, unifier: unifier) -> bool {\n+fn check_expr_with_unifier(fcx: @fn_ctxt,\n+                           expr: @ast::expr,\n+                           expected: ty::t,\n+                           unifier: fn()) -> bool {\n \n     #debug(\">> typechecking expr %d (%s)\",\n            expr.id, syntax::print::pprust::expr_to_str(expr));\n@@ -2646,10 +2644,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr,\n                     };\n                     if is_block == check_blocks {\n                         let arg_ty = arg_tys[i].ty;\n-                        bot |= check_expr_with_unifier(fcx, a, arg_ty) {\n-                            |fcx, span, expected, actual|\n-                            demand::assign(fcx, span, call_expr_id,\n-                                           expected, actual);\n+                        bot |= check_expr_with_unifier(fcx, a, arg_ty) {||\n+                            demand::assign(fcx, a.span, arg_ty, a);\n                         };\n                     }\n                   }\n@@ -3071,7 +3067,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr,\n         fcx.write_nil(id);\n       }\n       ast::expr_copy(a) {\n-        bot = check_expr_with_unifier(fcx, a, expected, unifier);\n+        bot = check_expr_with(fcx, a, expected);\n         fcx.write_ty(id, fcx.expr_ty(a));\n       }\n       ast::expr_move(lhs, rhs) {\n@@ -3142,7 +3138,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr,\n       }\n       ast::expr_fn(proto, decl, body, captures) {\n         check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n-                                   unifier, expected, false);\n+                                   false, unifier);\n         capture::check_capture_clause(tcx, expr.id, proto, *captures);\n       }\n       ast::expr_fn_block(decl, body) {\n@@ -3155,7 +3151,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr,\n                expr_to_str(expr),\n                ty_to_str(tcx, expected));\n         check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n-                                   unifier, expected, false);\n+                                   false, unifier);\n       }\n       ast::expr_loop_body(b) {\n         let rty = structurally_resolved_type(fcx, expr.span, expected);\n@@ -3168,8 +3164,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr,\n         };\n         alt check b.node {\n           ast::expr_fn_block(decl, body) {\n-            check_expr_fn_with_unifier(fcx, b, proto, decl, body,\n-                                       unifier, inner_ty, true);\n+            check_expr_fn_with_unifier(fcx, b, proto, decl, body, true) {||\n+                demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n+            }\n           }\n         }\n         let block_ty = structurally_resolved_type(\n@@ -3517,7 +3514,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr,\n            ty_to_str(tcx, fcx.expr_ty(expr)),\n            ty_to_str(tcx, expected));\n \n-    unifier(fcx, expr.span, expected, fcx.expr_ty(expr));\n+    unifier();\n \n     #debug(\"<< bot=%b\", bot);\n     ret bot;"}]}