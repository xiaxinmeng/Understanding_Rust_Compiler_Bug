{"sha": "f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZTU2ZDI1NTkwNWFiZDJiNzcyOGZmYmYyNGMwYzViMDlmNWQxZWQ=", "commit": {"author": {"name": "Phil Ellison", "email": "phil.j.ellison@gmail.com", "date": "2018-01-14T08:27:53Z"}, "committer": {"name": "Phil Ellison", "email": "phil.j.ellison@gmail.com", "date": "2018-01-14T08:27:53Z"}, "message": "First pass at linting for .any expressed as a .fold", "tree": {"sha": "665d4d9131aa3d7db951e5c5e6d15dcf63540efd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/665d4d9131aa3d7db951e5c5e6d15dcf63540efd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed", "html_url": "https://github.com/rust-lang/rust/commit/f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed/comments", "author": {"login": "theotherphil", "id": 1974256, "node_id": "MDQ6VXNlcjE5NzQyNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1974256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theotherphil", "html_url": "https://github.com/theotherphil", "followers_url": "https://api.github.com/users/theotherphil/followers", "following_url": "https://api.github.com/users/theotherphil/following{/other_user}", "gists_url": "https://api.github.com/users/theotherphil/gists{/gist_id}", "starred_url": "https://api.github.com/users/theotherphil/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theotherphil/subscriptions", "organizations_url": "https://api.github.com/users/theotherphil/orgs", "repos_url": "https://api.github.com/users/theotherphil/repos", "events_url": "https://api.github.com/users/theotherphil/events{/privacy}", "received_events_url": "https://api.github.com/users/theotherphil/received_events", "type": "User", "site_admin": false}, "committer": {"login": "theotherphil", "id": 1974256, "node_id": "MDQ6VXNlcjE5NzQyNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1974256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theotherphil", "html_url": "https://github.com/theotherphil", "followers_url": "https://api.github.com/users/theotherphil/followers", "following_url": "https://api.github.com/users/theotherphil/following{/other_user}", "gists_url": "https://api.github.com/users/theotherphil/gists{/gist_id}", "starred_url": "https://api.github.com/users/theotherphil/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theotherphil/subscriptions", "organizations_url": "https://api.github.com/users/theotherphil/orgs", "repos_url": "https://api.github.com/users/theotherphil/repos", "events_url": "https://api.github.com/users/theotherphil/events{/privacy}", "received_events_url": "https://api.github.com/users/theotherphil/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b863a00a4eff98335ab7994bece97c632a8ad65a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b863a00a4eff98335ab7994bece97c632a8ad65a", "html_url": "https://github.com/rust-lang/rust/commit/b863a00a4eff98335ab7994bece97c632a8ad65a"}], "stats": {"total": 105, "additions": 101, "deletions": 4}, "files": [{"sha": "4277b4b15d3f853c707e989c03fe745f4dedb13c", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed", "patch": "@@ -12,7 +12,7 @@ use syntax::ast;\n use syntax::codemap::Span;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_self, is_self_ty,\n             iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n-            match_type, method_chain_args, return_ty, same_tys, single_segment_path, snippet, span_lint,\n+            match_type, method_chain_args, return_ty, remove_blocks, same_tys, single_segment_path, snippet, span_lint,\n             span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n use utils::paths;\n use utils::sugg;\n@@ -623,6 +623,23 @@ declare_lint! {\n     \"using `as_ref` where the types before and after the call are the same\"\n }\n \n+\n+/// **What it does:** Checks for using `fold` to implement `any`.\n+///\n+/// **Why is this bad?** Readability.\n+///\n+/// **Known problems:** Changes semantics - the suggested replacement is short-circuiting.\n+///\n+/// **Example:**\n+/// ```rust\n+/// let _ = (0..3).fold(false, |acc, x| acc || x > 2);\n+/// ```\n+declare_lint! {\n+    pub FOLD_ANY,\n+    Warn,\n+    \"TODO\"\n+}\n+\n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(\n@@ -653,7 +670,8 @@ impl LintPass for Pass {\n             GET_UNWRAP,\n             STRING_EXTEND_CHARS,\n             ITER_CLONED_COLLECT,\n-            USELESS_ASREF\n+            USELESS_ASREF,\n+            FOLD_ANY\n         )\n     }\n }\n@@ -717,6 +735,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     lint_asref(cx, expr, \"as_ref\", arglists[0]);\n                 } else if let Some(arglists) = method_chain_args(expr, &[\"as_mut\"]) {\n                     lint_asref(cx, expr, \"as_mut\", arglists[0]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"fold\"]) {\n+                    lint_fold_any(cx, expr, arglists[0]);\n                 }\n \n                 lint_or_fun_call(cx, expr, &method_call.name.as_str(), args);\n@@ -1105,6 +1125,70 @@ fn lint_iter_cloned_collect(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir\n     }\n }\n \n+// DONOTMERGE: copy-pasted from map_clone\n+fn get_arg_name(pat: &hir::Pat) -> Option<ast::Name> {\n+    match pat.node {\n+        hir::PatKind::Binding(_, _, name, None) => Some(name.node),\n+        hir::PatKind::Ref(ref subpat, _) => get_arg_name(subpat),\n+        _ => None,\n+    }\n+}\n+\n+fn lint_fold_any(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::Expr]) {\n+    // DONOTMERGE: What if this is just some other method called fold?\n+    assert!(fold_args.len() == 3,\n+        \"Expected fold_args to have three entries - the receiver, the initial value and the closure\");\n+\n+    if let hir::ExprLit(ref lit) = fold_args[1].node {\n+        if let ast::LitKind::Bool(ref b) = lit.node {\n+            let initial_value = b.to_string();\n+\n+            if let hir::ExprClosure(_, ref decl, body_id, _, _) = fold_args[2].node {\n+                let closure_body = cx.tcx.hir.body(body_id);\n+                let closure_expr = remove_blocks(&closure_body.value);\n+\n+                let first_arg = &closure_body.arguments[0];\n+                let arg_ident = get_arg_name(&first_arg.pat).unwrap();\n+\n+                let second_arg = &closure_body.arguments[1];\n+                let second_arg_ident = get_arg_name(&second_arg.pat).unwrap();\n+\n+                if let hir::ExprBinary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.node {\n+                    if bin_op.node != hir::BinOp_::BiOr {\n+                        return;\n+                    }\n+                    if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = left_expr.node {\n+                        if path.segments.len() == 1 {\n+                            let left_name =  &path.segments[0].name;\n+                            let right_source = cx.sess().codemap().span_to_snippet(right_expr.span).unwrap();\n+\n+                            if left_name == &arg_ident {\n+                                span_lint(\n+                                    cx,\n+                                    FOLD_ANY,\n+                                    expr.span,\n+                                    // TODO: don't suggest .any(|x| f(x)) if we can suggest .any(f)\n+                                    // TODO: these have difference semantics - original code might be deliberately avoiding short-circuiting\n+                                    &format!(\n+                                        \".fold(false, |{f}, {s}| {f} || {r})) is more succinctly expressed as .any(|{s}| {r})\",\n+                                        f = arg_ident,\n+                                        s = second_arg_ident,\n+                                        r = right_source\n+                                    ),\n+                                );\n+                            }\n+                        }\n+                    }\n+                }\n+            } else{\n+                panic!(\"DONOTMERGE: can this happen?\");\n+            }\n+        }\n+    } else {\n+        return;\n+    }\n+}\n+\n fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool) {\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some() {"}, {"sha": "2dcc085add322bb9702bd0651c6a840375a91769", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed", "patch": "@@ -385,6 +385,11 @@ fn iter_skip_next() {\n     let _ = foo.filter().skip(42).next();\n }\n \n+/// Checks implementation of the `FOLD_ANY` lint\n+fn fold_any() {\n+    let _ = (0..3).fold(false, |acc, x| acc || x > 2);\n+}\n+\n #[allow(similar_names)]\n fn main() {\n     let opt = Some(0);"}, {"sha": "768fbd1df54569180fc25a576f220894855db1c9", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=f6e56d255905abd2b7728ffbf24c0c5b09f5d1ed", "patch": "@@ -493,10 +493,18 @@ error: called `skip(x).next()` on an iterator. This is more succinctly expressed\n 382 |     let _ = &some_vec[..].iter().skip(3).next();\n     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: .fold(false, |acc, x| acc || x > 2)) is more succinctly expressed as .any(|x| x > 2)\n+   --> $DIR/methods.rs:390:13\n+    |\n+390 |     let _ = (0..3).fold(false, |acc, x| acc || x > 2);\n+    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: `-D fold-any` implied by `-D warnings`\n+\n error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n-   --> $DIR/methods.rs:391:13\n+   --> $DIR/methods.rs:396:13\n     |\n-391 |     let _ = opt.unwrap();\n+396 |     let _ = opt.unwrap();\n     |             ^^^^^^^^^^^^\n     |\n     = note: `-D option-unwrap-used` implied by `-D warnings`"}]}