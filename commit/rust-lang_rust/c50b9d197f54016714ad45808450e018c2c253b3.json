{"sha": "c50b9d197f54016714ad45808450e018c2c253b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MGI5ZDE5N2Y1NDAxNjcxNGFkNDU4MDg0NTBlMDE4YzJjMjUzYjM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-23T12:26:36Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-23T13:55:04Z"}, "message": "Centralize bounds, alignment and NULL checking for memory accesses in one function: memory.check_ptr_access\n\nThat function also takes care of converting a Scalar to a Pointer, should that be needed.  Not all accesses need that though: if the access has size 0, None is returned.\nEveryone accessing memory based on a Scalar should use this method to get the Pointer they need.\n\nAll operations on the Allocation work on Pointer inputs and expect all the checks to have happened (and will ICE if the bounds are violated).\nThe operations on Memory work on Scalar inputs and do the checks themselves.\n\nThe only other public method to check pointers is memory.ptr_may_be_null, which is needed in a few places.\nWith this, we can make all the other methods (tests for a pointer being in-bounds and checking alignment) private helper methods, used to implement the two public methods.\nThat maks the public API surface much easier to use and harder to mis-use.\n\nWhile I am at it, this also removes the assumption that the vtable part of a `dyn Trait`-fat-pointer is a `Pointer` (as opposed to a pointer cast to an integer, stored as raw bits).", "tree": {"sha": "65a6ef56bb3da4b9218d3779aa0a949acc7871da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65a6ef56bb3da4b9218d3779aa0a949acc7871da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c50b9d197f54016714ad45808450e018c2c253b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c50b9d197f54016714ad45808450e018c2c253b3", "html_url": "https://github.com/rust-lang/rust/commit/c50b9d197f54016714ad45808450e018c2c253b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c50b9d197f54016714ad45808450e018c2c253b3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "305930cffeac1da0fd73a08d9f5680e4a49bfb9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/305930cffeac1da0fd73a08d9f5680e4a49bfb9f", "html_url": "https://github.com/rust-lang/rust/commit/305930cffeac1da0fd73a08d9f5680e4a49bfb9f"}], "stats": {"total": 365, "additions": 214, "deletions": 151}, "files": [{"sha": "964929547b77b12948ba89bc1f653ffd3d532b9d", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 51, "deletions": 49, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/c50b9d197f54016714ad45808450e018c2c253b3/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50b9d197f54016714ad45808450e018c2c253b3/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=c50b9d197f54016714ad45808450e018c2c253b3", "patch": "@@ -8,7 +8,7 @@ use crate::ty::layout::{Size, Align};\n use syntax::ast::Mutability;\n use std::{iter, fmt::{self, Display}};\n use crate::mir;\n-use std::ops::{Deref, DerefMut};\n+use std::ops::{Range, Deref, DerefMut};\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_macros::HashStable;\n use rustc_target::abi::HasDataLayout;\n@@ -146,54 +146,48 @@ impl<Tag> Allocation<Tag> {\n \n impl<'tcx> ::serialize::UseSpecializedDecodable for &'tcx Allocation {}\n \n-/// Alignment and bounds checks\n-impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n-    /// Checks if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n-    /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n-    /// in-bounds!  This follows C's/LLVM's rules.\n-    /// If you want to check bounds before doing a memory access, better use `check_bounds`.\n-    fn check_bounds_ptr(\n+/// Byte accessors\n+impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n+    /// Just a small local helper function to avoid a bit of code repetition.\n+    /// Returns the range of this allocation that was meant.\n+    #[inline]\n+    fn check_bounds(\n         &self,\n-        ptr: Pointer<Tag>,\n-        msg: CheckInAllocMsg,\n-    ) -> InterpResult<'tcx> {\n-        let allocation_size = self.bytes.len() as u64;\n-        ptr.check_in_alloc(Size::from_bytes(allocation_size), msg)\n+        offset: Size,\n+        size: Size\n+    ) -> Range<usize> {\n+        let end = offset + size; // this does overflow checking\n+        assert_eq!(\n+            end.bytes() as usize as u64, end.bytes(),\n+            \"cannot handle this access on this host architecture\"\n+        );\n+        let end = end.bytes() as usize;\n+        assert!(\n+            end <= self.bytes.len(),\n+            \"Out-of-bounds access at offset {}, size {} in allocation of size {}\",\n+            offset.bytes(), size.bytes(), self.bytes.len()\n+        );\n+        (offset.bytes() as usize)..end\n     }\n \n-    /// Checks if the memory range beginning at `ptr` and of size `Size` is \"in-bounds\".\n-    #[inline(always)]\n-    pub fn check_bounds(\n-        &self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-        msg: CheckInAllocMsg,\n-    ) -> InterpResult<'tcx> {\n-        // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_bounds_ptr(ptr.offset(size, cx)?, msg)\n-    }\n-}\n-\n-/// Byte accessors\n-impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// The last argument controls whether we error out when there are undefined\n     /// or pointer bytes. You should never call this, call `get_bytes` or\n     /// `get_bytes_with_undef_and_ptr` instead,\n     ///\n     /// This function also guarantees that the resulting pointer will remain stable\n     /// even when new allocations are pushed to the `HashMap`. `copy_repeatedly` relies\n     /// on that.\n+    ///\n+    /// It is the callers responsibility to check bounds and alignment beforehand.\n     fn get_bytes_internal(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n         check_defined_and_ptr: bool,\n-        msg: CheckInAllocMsg,\n     ) -> InterpResult<'tcx, &[u8]>\n     {\n-        self.check_bounds(cx, ptr, size, msg)?;\n+        let range = self.check_bounds(ptr.offset, size);\n \n         if check_defined_and_ptr {\n             self.check_defined(ptr, size)?;\n@@ -205,12 +199,13 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n         AllocationExtra::memory_read(self, ptr, size)?;\n \n-        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n-        let offset = ptr.offset.bytes() as usize;\n-        Ok(&self.bytes[offset..offset + size.bytes() as usize])\n+        Ok(&self.bytes[range])\n     }\n \n+    /// Check that these bytes are initialized and not pointer bytes, and then return them\n+    /// as a slice.\n+    ///\n+    /// It is the callers responsibility to check bounds and alignment beforehand.\n     #[inline]\n     pub fn get_bytes(\n         &self,\n@@ -219,11 +214,13 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         size: Size,\n     ) -> InterpResult<'tcx, &[u8]>\n     {\n-        self.get_bytes_internal(cx, ptr, size, true, CheckInAllocMsg::MemoryAccessTest)\n+        self.get_bytes_internal(cx, ptr, size, true)\n     }\n \n     /// It is the caller's responsibility to handle undefined and pointer bytes.\n     /// However, this still checks that there are no relocations on the *edges*.\n+    ///\n+    /// It is the callers responsibility to check bounds and alignment beforehand.\n     #[inline]\n     pub fn get_bytes_with_undef_and_ptr(\n         &self,\n@@ -232,30 +229,28 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         size: Size,\n     ) -> InterpResult<'tcx, &[u8]>\n     {\n-        self.get_bytes_internal(cx, ptr, size, false, CheckInAllocMsg::MemoryAccessTest)\n+        self.get_bytes_internal(cx, ptr, size, false)\n     }\n \n     /// Just calling this already marks everything as defined and removes relocations,\n     /// so be sure to actually put data there!\n+    ///\n+    /// It is the callers responsibility to check bounds and alignment beforehand.\n     pub fn get_bytes_mut(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx, &mut [u8]>\n     {\n-        assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n-        self.check_bounds(cx, ptr, size, CheckInAllocMsg::MemoryAccessTest)?;\n+        let range = self.check_bounds(ptr.offset, size);\n \n         self.mark_definedness(ptr, size, true);\n         self.clear_relocations(cx, ptr, size)?;\n \n         AllocationExtra::memory_written(self, ptr, size)?;\n \n-        assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n-        let offset = ptr.offset.bytes() as usize;\n-        Ok(&mut self.bytes[offset..offset + size.bytes() as usize])\n+        Ok(&mut self.bytes[range])\n     }\n }\n \n@@ -276,9 +271,10 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n                 let size_with_null = Size::from_bytes((size + 1) as u64);\n                 // Go through `get_bytes` for checks and AllocationExtra hooks.\n                 // We read the null, so we include it in the request, but we want it removed\n-                // from the result!\n+                // from the result, so we do subslicing.\n                 Ok(&self.get_bytes(cx, ptr, size_with_null)?[..size])\n             }\n+            // This includes the case where `offset` is out-of-bounds to begin with.\n             None => err!(UnterminatedCString(ptr.erase_tag())),\n         }\n     }\n@@ -306,7 +302,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n     /// Writes `src` to the memory starting at `ptr.offset`.\n     ///\n-    /// Will do bounds checks on the allocation.\n+    /// It is the callers responsibility to check bounds and alignment beforehand.\n     pub fn write_bytes(\n         &mut self,\n         cx: &impl HasDataLayout,\n@@ -320,6 +316,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n \n     /// Sets `count` bytes starting at `ptr.offset` with `val`. Basically `memset`.\n+    ///\n+    /// It is the callers responsibility to check bounds and alignment beforehand.\n     pub fn write_repeat(\n         &mut self,\n         cx: &impl HasDataLayout,\n@@ -342,7 +340,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// * in oder to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n     ///   being valid for ZSTs\n     ///\n-    /// Note: This function does not do *any* alignment checks, you need to do these before calling\n+    /// It is the callers responsibility to check bounds and alignment beforehand.\n     pub fn read_scalar(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -378,7 +376,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(ScalarMaybeUndef::Scalar(Scalar::from_uint(bits, size)))\n     }\n \n-    /// Note: This function does not do *any* alignment checks, you need to do these before calling\n+    /// Read a pointer-sized scalar.\n+    ///\n+    /// It is the callers responsibility to check bounds and alignment beforehand.\n     pub fn read_ptr_sized(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -395,7 +395,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// * in oder to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n     ///   being valid for ZSTs\n     ///\n-    /// Note: This function does not do *any* alignment checks, you need to do these before calling\n+    /// It is the callers responsibility to check bounds and alignment beforehand.\n     pub fn write_scalar(\n         &mut self,\n         cx: &impl HasDataLayout,\n@@ -435,7 +435,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(())\n     }\n \n-    /// Note: This function does not do *any* alignment checks, you need to do these before calling\n+    /// Write a pointer-sized scalar.\n+    ///\n+    /// It is the callers responsibility to check bounds and alignment beforehand.\n     pub fn write_ptr_sized(\n         &mut self,\n         cx: &impl HasDataLayout,"}, {"sha": "ae994d14b1029e73cd7b7c458f829d92347f509c", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c50b9d197f54016714ad45808450e018c2c253b3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50b9d197f54016714ad45808450e018c2c253b3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=c50b9d197f54016714ad45808450e018c2c253b3", "patch": "@@ -437,7 +437,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                 Ok(Some((size.align_to(align), align)))\n             }\n             ty::Dynamic(..) => {\n-                let vtable = metadata.expect(\"dyn trait fat ptr must have vtable\").to_ptr()?;\n+                let vtable = metadata.expect(\"dyn trait fat ptr must have vtable\");\n                 // the second entry in the vtable is the dynamic size of the object.\n                 Ok(Some(self.read_size_and_align_from_vtable(vtable)?))\n             }"}, {"sha": "05d110a4372a185963462f75d661decd6715ed9a", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 97, "deletions": 27, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c50b9d197f54016714ad45808450e018c2c253b3/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50b9d197f54016714ad45808450e018c2c253b3/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=c50b9d197f54016714ad45808450e018c2c253b3", "patch": "@@ -250,7 +250,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n     /// Checks that the pointer is aligned AND non-NULL. This supports ZSTs in two ways:\n     /// You can pass a scalar, and a `Pointer` does not have to actually still be allocated.\n-    pub fn check_align(\n+    fn check_align(\n         &self,\n         ptr: Scalar<M::PointerTag>,\n         required_align: Align\n@@ -260,7 +260,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Err(ptr) => {\n                 // check this is not NULL -- which we can ensure only if this is in-bounds\n                 // of some (potentially dead) allocation.\n-                let align = self.check_bounds_ptr(ptr, InboundsCheck::MaybeDead,\n+                let align = self.check_ptr_bounds(ptr, InboundsCheck::MaybeDead,\n                                                   CheckInAllocMsg::NullPointerTest)?;\n                 (ptr.offset.bytes(), align)\n             }\n@@ -291,12 +291,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n     }\n \n-    /// Checks if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n-    /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n-    /// in-bounds!  This follows C's/LLVM's rules.\n-    /// If you want to check bounds before doing a memory access, better first obtain\n-    /// an `Allocation` and call `check_bounds`.\n-    pub fn check_bounds_ptr(\n+    /// Checks if the pointer is \"in-bounds\" of *some* (live or dead) allocation. Notice that\n+    /// a pointer pointing at the end of an allocation (i.e., at the first *inaccessible* location)\n+    /// *is* considered in-bounds!  This follows C's/LLVM's rules.\n+    /// `liveness` can be used to rule out dead allocations.  Testing in-bounds with a dead\n+    /// allocation is useful e.g. to exclude the possibility of this pointer being NULL.\n+    /// If you want to check bounds before doing a memory access, call `check_ptr_access`.\n+    fn check_ptr_bounds(\n         &self,\n         ptr: Pointer<M::PointerTag>,\n         liveness: InboundsCheck,\n@@ -306,6 +307,77 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         ptr.check_in_alloc(allocation_size, msg)?;\n         Ok(align)\n     }\n+\n+    /// Check if the given scalar is allowed to do a memory access of given `size`\n+    /// and `align`.  On success, returns `None` for zero-sized accesses (where\n+    /// nothing else is left to do) and a `Pointer` to use for the actual access otherwise.\n+    /// Crucially, if the input is a `Pointer`, we will test it for liveness\n+    /// *even of* the size is 0.\n+    ///\n+    /// Everyone accessing memory based on a `Scalar` should use this method to get the\n+    /// `Pointer` they need.  And even if you already have a `Pointer`, call this method\n+    /// to make sure it is sufficiently aligned and not dangling.  Not doing that may\n+    /// cause ICEs.\n+    pub fn check_ptr_access(\n+        &self,\n+        sptr: Scalar<M::PointerTag>,\n+        size: Size,\n+        align: Align,\n+    ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n+        // Normalize to a `Pointer` if we definitely need one.\n+        let normalized = if size.bytes() == 0 {\n+            // Can be an integer, just take what we got.\n+            sptr\n+        } else {\n+            // A \"real\" access, we must get a pointer.\n+            Scalar::Ptr(self.force_ptr(sptr)?)\n+        };\n+        Ok(match normalized.to_bits_or_ptr(self.pointer_size(), self) {\n+            Ok(bits) => {\n+                let bits = bits as u64; // it's ptr-sized\n+                assert!(size.bytes() == 0);\n+                // Must be non-NULL and aligned.\n+                if bits == 0 {\n+                    return err!(InvalidNullPointerUsage);\n+                }\n+                if bits % align.bytes() != 0 {\n+                    let bits_pow1 = 1 << bits.trailing_zeros();\n+                    return err!(AlignmentCheckFailed {\n+                        has: Align::from_bytes(bits_pow1).unwrap(),\n+                        required: align,\n+                    });\n+                }\n+                None\n+            }\n+            Err(ptr) => {\n+                // Test bounds.\n+                self.check_ptr_bounds(\n+                    ptr.offset(size, self)?,\n+                    InboundsCheck::Live,\n+                    CheckInAllocMsg::MemoryAccessTest,\n+                )?;\n+                // Test align and non-NULL.\n+                self.check_align(ptr.into(), align)?;\n+                // FIXME: Alignment check is too strict, depending on the base address that\n+                // got picked we might be aligned even if this check fails.\n+                // We instead have to fall back to converting to an integer and checking\n+                // the \"real\" alignment.\n+\n+                // We can still be zero-sized in this branch, in which case we have to\n+                // return `None`.\n+                if size.bytes() == 0 { None } else { Some(ptr) }\n+            }\n+        })\n+    }\n+\n+    /// Test if the pointer might be NULL.\n+    pub fn ptr_may_be_null(\n+        &self,\n+        ptr: Pointer<M::PointerTag>,\n+    ) -> bool {\n+        self.check_ptr_bounds(ptr, InboundsCheck::MaybeDead, CheckInAllocMsg::NullPointerTest)\n+            .is_err()\n+    }\n }\n \n /// Allocation accessors\n@@ -629,24 +701,22 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n }\n \n-/// Byte Accessors\n+/// Reading and writing.\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n+    /// Performs appropriate bounds checks.\n     pub fn read_bytes(\n         &self,\n         ptr: Scalar<M::PointerTag>,\n         size: Size,\n     ) -> InterpResult<'tcx, &[u8]> {\n-        if size.bytes() == 0 {\n-            Ok(&[])\n-        } else {\n-            let ptr = self.force_ptr(ptr)?;\n-            self.get(ptr.alloc_id)?.get_bytes(self, ptr, size)\n-        }\n+        let ptr = match self.check_ptr_access(ptr, size, Align::from_bytes(1).unwrap())? {\n+            Some(ptr) => ptr,\n+            None => return Ok(&[]), // zero-sized access\n+        };\n+        self.get(ptr.alloc_id)?.get_bytes(self, ptr, size)\n     }\n-}\n \n-/// Reading and writing.\n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n+    /// Performs appropriate bounds checks.\n     pub fn copy(\n         &mut self,\n         src: Scalar<M::PointerTag>,\n@@ -659,6 +729,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         self.copy_repeatedly(src, src_align, dest, dest_align, size, 1, nonoverlapping)\n     }\n \n+    /// Performs appropriate bounds checks.\n     pub fn copy_repeatedly(\n         &mut self,\n         src: Scalar<M::PointerTag>,\n@@ -669,15 +740,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         length: u64,\n         nonoverlapping: bool,\n     ) -> InterpResult<'tcx> {\n-        self.check_align(src, src_align)?;\n-        self.check_align(dest, dest_align)?;\n-        if size.bytes() == 0 {\n-            // Nothing to do for ZST, other than checking alignment and\n-            // non-NULLness which already happened.\n-            return Ok(());\n-        }\n-        let src = self.force_ptr(src)?;\n-        let dest = self.force_ptr(dest)?;\n+        // We need to check *both* before early-aborting due to the size being 0.\n+        let (src, dest) = match (self.check_ptr_access(src, size, src_align)?,\n+                self.check_ptr_access(dest, size * length, dest_align)?)\n+        {\n+            (Some(src), Some(dest)) => (src, dest),\n+            // One of the two sizes is 0.\n+            _ => return Ok(()),\n+        };\n \n         // first copy the relocations to a temporary buffer, because\n         // `get_bytes_mut` will clear the relocations, which is correct,"}, {"sha": "2ed6917e9da56ba4adb7a3dbe62e649ff5bbed48", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c50b9d197f54016714ad45808450e018c2c253b3/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50b9d197f54016714ad45808450e018c2c253b3/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=c50b9d197f54016714ad45808450e018c2c253b3", "patch": "@@ -9,9 +9,9 @@ use rustc::ty::layout::{\n };\n \n use rustc::mir::interpret::{\n-    GlobalId, AllocId, CheckInAllocMsg,\n+    GlobalId, AllocId,\n     ConstValue, Pointer, Scalar,\n-    InterpResult, InterpError, InboundsCheck,\n+    InterpResult, InterpError,\n     sign_extend, truncate,\n };\n use super::{\n@@ -226,19 +226,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n         }\n         let (ptr, ptr_align) = mplace.to_scalar_ptr_align();\n \n-        if mplace.layout.is_zst() {\n-            // Not all ZSTs have a layout we would handle below, so just short-circuit them\n-            // all here.\n-            self.memory.check_align(ptr, ptr_align)?;\n-            return Ok(Some(ImmTy {\n+        let ptr = match self.memory.check_ptr_access(ptr, mplace.layout.size, ptr_align)? {\n+            Some(ptr) => ptr,\n+            None => return Ok(Some(ImmTy {\n                 imm: Immediate::Scalar(Scalar::zst().into()),\n                 layout: mplace.layout,\n-            }));\n-        }\n+            })), // zero-sized access\n+        };\n \n-        // check for integer pointers before alignment to report better errors\n-        let ptr = self.force_ptr(ptr)?;\n-        self.memory.check_align(ptr.into(), ptr_align)?;\n         match mplace.layout.abi {\n             layout::Abi::Scalar(..) => {\n                 let scalar = self.memory\n@@ -250,17 +245,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                 }))\n             }\n             layout::Abi::ScalarPair(ref a, ref b) => {\n+                // We checked `ptr_align` above, so all fields will have the alignment they need.\n+                // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n+                // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n                 let (a, b) = (&a.value, &b.value);\n                 let (a_size, b_size) = (a.size(self), b.size(self));\n                 let a_ptr = ptr;\n                 let b_offset = a_size.align_to(b.align(self).abi);\n-                assert!(b_offset.bytes() > 0); // we later use the offset to test which field to use\n+                assert!(b_offset.bytes() > 0); // we later use the offset to tell apart the fields\n                 let b_ptr = ptr.offset(b_offset, self)?;\n                 let a_val = self.memory\n                     .get(ptr.alloc_id)?\n                     .read_scalar(self, a_ptr, a_size)?;\n-                let b_align = ptr_align.restrict_for_offset(b_offset);\n-                self.memory.check_align(b_ptr.into(), b_align)?;\n                 let b_val = self.memory\n                     .get(ptr.alloc_id)?\n                     .read_scalar(self, b_ptr, b_size)?;\n@@ -639,8 +635,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                     Err(ptr) => {\n                         // The niche must be just 0 (which an inbounds pointer value never is)\n                         let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n-                            self.memory.check_bounds_ptr(ptr, InboundsCheck::MaybeDead,\n-                                                         CheckInAllocMsg::NullPointerTest).is_ok();\n+                            !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n                             return err!(InvalidDiscriminant(raw_discr.erase_tag().into()));\n                         }"}, {"sha": "1351b5bb8bd88a6684ca967e69559cd7ba588111", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c50b9d197f54016714ad45808450e018c2c253b3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50b9d197f54016714ad45808450e018c2c253b3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=c50b9d197f54016714ad45808450e018c2c253b3", "patch": "@@ -222,9 +222,9 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub(super) fn vtable(self) -> InterpResult<'tcx, Pointer<Tag>> {\n+    pub(super) fn vtable(self) -> Scalar<Tag> {\n         match self.layout.ty.sty {\n-            ty::Dynamic(..) => self.mplace.meta.unwrap().to_ptr(),\n+            ty::Dynamic(..) => self.mplace.meta.unwrap(),\n             _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n         }\n     }\n@@ -746,15 +746,13 @@ where\n         // type things are read at. In case `src_val` is a `ScalarPair`, we don't do any magic here\n         // to handle padding properly, which is only correct if we never look at this data with the\n         // wrong type.\n+        assert!(!dest.layout.is_unsized());\n \n-        // Nothing to do for ZSTs, other than checking alignment\n-        if dest.layout.is_zst() {\n-            return self.memory.check_align(ptr, ptr_align);\n-        }\n+        let ptr = match self.memory.check_ptr_access(ptr, dest.layout.size, ptr_align)? {\n+            Some(ptr) => ptr,\n+            None => return Ok(()), // zero-sized access\n+        };\n \n-        // check for integer pointers before alignment to report better errors\n-        let ptr = self.force_ptr(ptr)?;\n-        self.memory.check_align(ptr.into(), ptr_align)?;\n         let tcx = &*self.tcx;\n         // FIXME: We should check that there are dest.layout.size many bytes available in\n         // memory.  The code below is not sufficient, with enough padding it might not\n@@ -771,18 +769,18 @@ where\n                 )\n             }\n             Immediate::ScalarPair(a_val, b_val) => {\n+                // We checked `ptr_align` above, so all fields will have the alignment they need.\n+                // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n+                // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n                 let (a, b) = match dest.layout.abi {\n                     layout::Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n                     _ => bug!(\"write_immediate_to_mplace: invalid ScalarPair layout: {:#?}\",\n                               dest.layout)\n                 };\n                 let (a_size, b_size) = (a.size(self), b.size(self));\n                 let b_offset = a_size.align_to(b.align(self).abi);\n-                let b_align = ptr_align.restrict_for_offset(b_offset);\n                 let b_ptr = ptr.offset(b_offset, self)?;\n \n-                self.memory.check_align(b_ptr.into(), b_align)?;\n-\n                 // It is tempting to verify `b_offset` against `layout.fields.offset(1)`,\n                 // but that does not work: We could be a newtype around a pair, then the\n                 // fields do not match the `ScalarPair` components.\n@@ -1053,7 +1051,7 @@ where\n     /// Also return some more information so drop doesn't have to run the same code twice.\n     pub(super) fn unpack_dyn_trait(&self, mplace: MPlaceTy<'tcx, M::PointerTag>)\n     -> InterpResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx, M::PointerTag>)> {\n-        let vtable = mplace.vtable()?; // also sanity checks the type\n+        let vtable = mplace.vtable(); // also sanity checks the type\n         let (instance, ty) = self.read_drop_type_from_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;\n "}, {"sha": "af061f968104e576725c9def03d7adc79ebc344c", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c50b9d197f54016714ad45808450e018c2c253b3/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50b9d197f54016714ad45808450e018c2c253b3/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=c50b9d197f54016714ad45808450e018c2c253b3", "patch": "@@ -425,12 +425,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                     }\n                 };\n                 // Find and consult vtable\n-                let vtable = receiver_place.vtable()?;\n-                self.memory.check_align(vtable.into(), self.tcx.data_layout.pointer_align.abi)?;\n-                let fn_ptr = self.memory.get(vtable.alloc_id)?.read_ptr_sized(\n-                    self,\n-                    vtable.offset(ptr_size * (idx as u64 + 3), self)?,\n-                )?.to_ptr()?;\n+                let vtable = receiver_place.vtable();\n+                let vtable_slot = vtable.ptr_offset(ptr_size * (idx as u64 + 3), self)?;\n+                let vtable_slot = self.memory.check_ptr_access(\n+                    vtable_slot,\n+                    ptr_size,\n+                    self.tcx.data_layout.pointer_align.abi,\n+                )?.expect(\"cannot be a ZST\");\n+                let fn_ptr = self.memory.get(vtable_slot.alloc_id)?\n+                    .read_ptr_sized(self, vtable_slot)?.to_ptr()?;\n                 let instance = self.memory.get_fn(fn_ptr)?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we"}, {"sha": "bbf063a18b69545be62812d992554c00d41b9914", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c50b9d197f54016714ad45808450e018c2c253b3/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50b9d197f54016714ad45808450e018c2c253b3/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=c50b9d197f54016714ad45808450e018c2c253b3", "patch": "@@ -101,10 +101,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     /// Returns the drop fn instance as well as the actual dynamic type\n     pub fn read_drop_type_from_vtable(\n         &self,\n-        vtable: Pointer<M::PointerTag>,\n+        vtable: Scalar<M::PointerTag>,\n     ) -> InterpResult<'tcx, (ty::Instance<'tcx>, Ty<'tcx>)> {\n         // we don't care about the pointee type, we just want a pointer\n-        self.memory.check_align(vtable.into(), self.tcx.data_layout.pointer_align.abi)?;\n+        let vtable = self.memory.check_ptr_access(\n+            vtable,\n+            self.tcx.data_layout.pointer_size,\n+            self.tcx.data_layout.pointer_align.abi,\n+        )?.expect(\"cannot be a ZST\");\n         let drop_fn = self.memory\n             .get(vtable.alloc_id)?\n             .read_ptr_sized(self, vtable)?\n@@ -113,17 +117,23 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n         let fn_sig = drop_instance.ty(*self.tcx).fn_sig(*self.tcx);\n         let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);\n-        // the drop function takes *mut T where T is the type being dropped, so get that\n+        // The drop function takes `*mut T` where `T` is the type being dropped, so get that.\n         let ty = fn_sig.inputs()[0].builtin_deref(true).unwrap().ty;\n         Ok((drop_instance, ty))\n     }\n \n     pub fn read_size_and_align_from_vtable(\n         &self,\n-        vtable: Pointer<M::PointerTag>,\n+        vtable: Scalar<M::PointerTag>,\n     ) -> InterpResult<'tcx, (Size, Align)> {\n         let pointer_size = self.pointer_size();\n-        self.memory.check_align(vtable.into(), self.tcx.data_layout.pointer_align.abi)?;\n+        // We check for size = 3*ptr_size, that covers the drop fn (unused here),\n+        // the size, and the align.\n+        let vtable = self.memory.check_ptr_access(\n+            vtable,\n+            3*pointer_size,\n+            self.tcx.data_layout.pointer_align.abi,\n+        )?.expect(\"cannot be a ZST\");\n         let alloc = self.memory.get(vtable.alloc_id)?;\n         let size = alloc.read_ptr_sized(self, vtable.offset(pointer_size, self)?)?\n             .to_bits(pointer_size)? as u64;"}, {"sha": "57c3fe4cb3e27e2c30b5f0e50c2090ad9a76ac99", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 18, "deletions": 33, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c50b9d197f54016714ad45808450e018c2c253b3/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50b9d197f54016714ad45808450e018c2c253b3/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=c50b9d197f54016714ad45808450e018c2c253b3", "patch": "@@ -3,11 +3,11 @@ use std::ops::RangeInclusive;\n \n use syntax_pos::symbol::{sym, Symbol};\n use rustc::hir;\n-use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf, VariantIdx};\n+use rustc::ty::layout::{self, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n-    Scalar, GlobalAlloc, InterpResult, InterpError, CheckInAllocMsg,\n+    GlobalAlloc, InterpResult, InterpError,\n };\n \n use std::hash::Hash;\n@@ -365,8 +365,12 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     let tail = self.ecx.tcx.struct_tail(layout.ty);\n                     match tail.sty {\n                         ty::Dynamic(..) => {\n-                            let vtable = try_validation!(meta.unwrap().to_ptr(),\n-                                \"non-pointer vtable in fat pointer\", self.path);\n+                            let vtable = meta.unwrap();\n+                            try_validation!(self.ecx.memory.check_ptr_access(\n+                                vtable,\n+                                3*self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n+                                self.ecx.tcx.data_layout.pointer_align.abi,\n+                            ), \"dangling or unaligned vtable pointer\", self.path);\n                             try_validation!(self.ecx.read_drop_type_from_vtable(vtable),\n                                 \"invalid drop fn in vtable\", self.path);\n                             try_validation!(self.ecx.read_size_and_align_from_vtable(vtable),\n@@ -384,14 +388,14 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                             bug!(\"Unexpected unsized type tail: {:?}\", tail),\n                     }\n                 }\n-                // Make sure this is non-NULL and aligned\n+                // Make sure this is dereferencable and all.\n                 let (size, align) = self.ecx.size_and_align_of(meta, layout)?\n                     // for the purpose of validity, consider foreign types to have\n                     // alignment and size determined by the layout (size will be 0,\n                     // alignment should take attributes into account).\n                     .unwrap_or_else(|| (layout.size, layout.align.abi));\n-                match self.ecx.memory.check_align(ptr, align) {\n-                    Ok(_) => {},\n+                let ptr: Option<_> = match self.ecx.memory.check_ptr_access(ptr, size, align) {\n+                    Ok(ptr) => ptr,\n                     Err(err) => {\n                         info!(\"{:?} is not aligned to {:?}\", ptr, align);\n                         match err.kind {\n@@ -403,21 +407,16 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                                     required.bytes(), has.bytes()), self.path),\n                             _ =>\n                                 return validation_failure!(\n-                                    \"dangling (out-of-bounds) reference (might be NULL at \\\n-                                        run-time)\",\n+                                    \"dangling (not entirely in bounds) reference\",\n                                     self.path\n                                 ),\n                         }\n                     }\n-                }\n+                };\n                 // Recursive checking\n                 if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n                     let place = self.ecx.ref_to_mplace(value)?;\n-                    // FIXME(RalfJ): check ZST for inbound pointers\n-                    if size != Size::ZERO {\n-                        // Non-ZST also have to be dereferencable\n-                        let ptr = try_validation!(place.ptr.to_ptr(),\n-                            \"integer pointer in non-ZST reference\", self.path);\n+                    if let Some(ptr) = ptr { // not a ZST\n                         // Skip validation entirely for some external statics\n                         let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n                         if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n@@ -429,18 +428,10 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                                 return Ok(());\n                             }\n                         }\n-                        // Maintain the invariant that the place we are checking is\n-                        // already verified to be in-bounds.\n-                        try_validation!(\n-                            self.ecx.memory\n-                                .get(ptr.alloc_id)?\n-                                .check_bounds(self.ecx, ptr, size, CheckInAllocMsg::InboundsTest),\n-                            \"dangling (not entirely in bounds) reference\", self.path);\n                     }\n                     // Check if we have encountered this pointer+layout combination\n-                    // before.  Proceed recursively even for integer pointers, no\n-                    // reason to skip them! They are (recursively) valid for some ZST,\n-                    // but not for others (e.g., `!` is a ZST).\n+                    // before.  Proceed recursively even for ZST, no\n+                    // reason to skip them! E.g., `!` is a ZST and we want to validate it.\n                     let path = &self.path;\n                     ref_tracking.track(place, || {\n                         // We need to clone the path anyway, make sure it gets created\n@@ -499,14 +490,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         let bits = match value.to_bits_or_ptr(op.layout.size, self.ecx) {\n             Err(ptr) => {\n                 if lo == 1 && hi == max_hi {\n-                    // only NULL is not allowed.\n-                    // We can call `check_align` to check non-NULL-ness, but have to also look\n-                    // for function pointers.\n-                    let non_null =\n-                        self.ecx.memory.check_align(\n-                            Scalar::Ptr(ptr), Align::from_bytes(1).unwrap()\n-                        ).is_ok();\n-                    if !non_null {\n+                    // Only NULL is the niche.  So make sure the ptr is NOT NULL.\n+                    if self.ecx.memory.ptr_may_be_null(ptr) {\n                         // These conditions are just here to improve the diagnostics so we can\n                         // differentiate between null pointers and dangling pointers\n                         if self.ref_tracking_for_consts.is_some() &&"}]}