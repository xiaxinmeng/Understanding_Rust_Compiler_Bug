{"sha": "8131445e536869b4b73b07d1be1b2e03f7493898", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxMzE0NDVlNTM2ODY5YjRiNzNiMDdkMWJlMWIyZTAzZjc0OTM4OTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-13T14:31:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-13T14:31:02Z"}, "message": "Auto merge of #7446 - Y-Nak:fix-7445, r=xFrednet,flip1995\n\n`default_numeric_fallback`: Fix FP with floating literal\n\nFix #7445\n\nchangelog: `default_numeric_fallback`: Fix FP with floating literal", "tree": {"sha": "eaf87cfe60eed75f6872ec34d3082911de7b1c72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eaf87cfe60eed75f6872ec34d3082911de7b1c72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8131445e536869b4b73b07d1be1b2e03f7493898", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8131445e536869b4b73b07d1be1b2e03f7493898", "html_url": "https://github.com/rust-lang/rust/commit/8131445e536869b4b73b07d1be1b2e03f7493898", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8131445e536869b4b73b07d1be1b2e03f7493898/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf4512ef57aaaebcf537af47380026d40238685b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf4512ef57aaaebcf537af47380026d40238685b", "html_url": "https://github.com/rust-lang/rust/commit/bf4512ef57aaaebcf537af47380026d40238685b"}, {"sha": "25e4c7d73fd4c929208edf151c827f6c97318374", "url": "https://api.github.com/repos/rust-lang/rust/commits/25e4c7d73fd4c929208edf151c827f6c97318374", "html_url": "https://github.com/rust-lang/rust/commit/25e4c7d73fd4c929208edf151c827f6c97318374"}], "stats": {"total": 781, "additions": 738, "deletions": 43}, "files": [{"sha": "e719a1b0abf8744dd2f483d542c9c017e96e6b67", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8131445e536869b4b73b07d1be1b2e03f7493898/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8131445e536869b4b73b07d1be1b2e03f7493898/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=8131445e536869b4b73b07d1be1b2e03f7493898", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet;\n+use clippy_utils::numeric_literal;\n+use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n use rustc_ast::ast::{LitFloatType, LitIntType, LitKind};\n use rustc_errors::Applicability;\n@@ -78,16 +79,25 @@ impl<'a, 'tcx> NumericFallbackVisitor<'a, 'tcx> {\n                 if let Some(ty_bound) = self.ty_bounds.last();\n                 if matches!(lit.node,\n                             LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed));\n-                if !ty_bound.is_integral();\n+                if !ty_bound.is_numeric();\n                 then {\n-                    let suffix = match lit_ty.kind() {\n-                        ty::Int(IntTy::I32) => \"i32\",\n-                        ty::Float(FloatTy::F64) => \"f64\",\n+                    let (suffix, is_float) = match lit_ty.kind() {\n+                        ty::Int(IntTy::I32) => (\"i32\", false),\n+                        ty::Float(FloatTy::F64) => (\"f64\", true),\n                         // Default numeric fallback never results in other types.\n                         _ => return,\n                     };\n \n-                    let sugg = format!(\"{}_{}\", snippet(self.cx, lit.span, \"\"), suffix);\n+                    let src = if let Some(src) = snippet_opt(self.cx, lit.span) {\n+                        src\n+                    } else {\n+                        match lit.node {\n+                            LitKind::Int(src, _) => format!(\"{}\", src),\n+                            LitKind::Float(src, _) => format!(\"{}\", src),\n+                            _ => return,\n+                        }\n+                    };\n+                    let sugg = numeric_literal::format(&src, Some(suffix), is_float);\n                     span_lint_and_sugg(\n                         self.cx,\n                         DEFAULT_NUMERIC_FALLBACK,\n@@ -219,10 +229,10 @@ enum TyBound<'tcx> {\n }\n \n impl<'tcx> TyBound<'tcx> {\n-    fn is_integral(self) -> bool {\n+    fn is_numeric(self) -> bool {\n         match self {\n             TyBound::Any => true,\n-            TyBound::Ty(t) => t.is_integral(),\n+            TyBound::Ty(t) => t.is_numeric(),\n             TyBound::Nothing => false,\n         }\n     }"}, {"sha": "4a28c7dd9a04a3885251ef7ab44e7d5ea65aa7fe", "filename": "clippy_utils/src/numeric_literal.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8131445e536869b4b73b07d1be1b2e03f7493898/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8131445e536869b4b73b07d1be1b2e03f7493898/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fnumeric_literal.rs?ref=8131445e536869b4b73b07d1be1b2e03f7493898", "patch": "@@ -162,6 +162,9 @@ impl<'a> NumericLiteral<'a> {\n         }\n \n         if let Some(suffix) = self.suffix {\n+            if output.ends_with('.') {\n+                output.push('0');\n+            }\n             output.push('_');\n             output.push_str(suffix);\n         }"}, {"sha": "1b0e7544e79c6289f17b6d48b9f1a0dc7c51e579", "filename": "tests/ui/default_numeric_fallback_f64.fixed", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/8131445e536869b4b73b07d1be1b2e03f7493898/tests%2Fui%2Fdefault_numeric_fallback_f64.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8131445e536869b4b73b07d1be1b2e03f7493898/tests%2Fui%2Fdefault_numeric_fallback_f64.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_f64.fixed?ref=8131445e536869b4b73b07d1be1b2e03f7493898", "patch": "@@ -0,0 +1,174 @@\n+// run-rustfix\n+// aux-build:macro_rules.rs\n+\n+#![warn(clippy::default_numeric_fallback)]\n+#![allow(unused)]\n+#![allow(clippy::never_loop)]\n+#![allow(clippy::no_effect)]\n+#![allow(clippy::unnecessary_operation)]\n+#![allow(clippy::branches_sharing_code)]\n+#![allow(clippy::match_single_binding)]\n+\n+#[macro_use]\n+extern crate macro_rules;\n+\n+mod basic_expr {\n+    fn test() {\n+        // Should lint unsuffixed literals typed `f64`.\n+        let x = 0.12_f64;\n+        let x = [1.0_f64, 2.0_f64, 3.0_f64];\n+        let x = if true { (1.0_f64, 2.0_f64) } else { (3.0_f64, 4.0_f64) };\n+        let x = match 1.0_f64 {\n+            _ => 1.0_f64,\n+        };\n+\n+        // Should NOT lint suffixed literals.\n+        let x = 0.12_f64;\n+\n+        // Should NOT lint literals in init expr if `Local` has a type annotation.\n+        let x: f64 = 0.1;\n+        let x: [f64; 3] = [1., 2., 3.];\n+        let x: (f64, f64) = if true { (1., 2.) } else { (3., 4.) };\n+        let x: _ = 1.;\n+    }\n+}\n+\n+mod nested_local {\n+    fn test() {\n+        let x: _ = {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1.0_f64;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1.\n+        };\n+\n+        let x: _ = if true {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1.0_f64;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1.\n+        } else {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1.0_f64;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            2.\n+        };\n+    }\n+}\n+\n+mod function_def {\n+    fn ret_f64() -> f64 {\n+        // Even though the output type is specified,\n+        // this unsuffixed literal is linted to reduce heuristics and keep codebase simple.\n+        1.0_f64\n+    }\n+\n+    fn test() {\n+        // Should lint this because return type is inferred to `f64` and NOT bound to a concrete\n+        // type.\n+        let f = || -> _ { 1.0_f64 };\n+\n+        // Even though the output type is specified,\n+        // this unsuffixed literal is linted to reduce heuristics and keep codebase simple.\n+        let f = || -> f64 { 1.0_f64 };\n+    }\n+}\n+\n+mod function_calls {\n+    fn concrete_arg(f: f64) {}\n+\n+    fn generic_arg<T>(t: T) {}\n+\n+    fn test() {\n+        // Should NOT lint this because the argument type is bound to a concrete type.\n+        concrete_arg(1.);\n+\n+        // Should lint this because the argument type is inferred to `f64` and NOT bound to a concrete type.\n+        generic_arg(1.0_f64);\n+\n+        // Should lint this because the argument type is inferred to `f64` and NOT bound to a concrete type.\n+        let x: _ = generic_arg(1.0_f64);\n+    }\n+}\n+\n+mod struct_ctor {\n+    struct ConcreteStruct {\n+        x: f64,\n+    }\n+\n+    struct GenericStruct<T> {\n+        x: T,\n+    }\n+\n+    fn test() {\n+        // Should NOT lint this because the field type is bound to a concrete type.\n+        ConcreteStruct { x: 1. };\n+\n+        // Should lint this because the field type is inferred to `f64` and NOT bound to a concrete type.\n+        GenericStruct { x: 1.0_f64 };\n+\n+        // Should lint this because the field type is inferred to `f64` and NOT bound to a concrete type.\n+        let _ = GenericStruct { x: 1.0_f64 };\n+    }\n+}\n+\n+mod enum_ctor {\n+    enum ConcreteEnum {\n+        X(f64),\n+    }\n+\n+    enum GenericEnum<T> {\n+        X(T),\n+    }\n+\n+    fn test() {\n+        // Should NOT lint this because the field type is bound to a concrete type.\n+        ConcreteEnum::X(1.);\n+\n+        // Should lint this because the field type is inferred to `f64` and NOT bound to a concrete type.\n+        GenericEnum::X(1.0_f64);\n+    }\n+}\n+\n+mod method_calls {\n+    struct StructForMethodCallTest {}\n+\n+    impl StructForMethodCallTest {\n+        fn concrete_arg(&self, f: f64) {}\n+\n+        fn generic_arg<T>(&self, t: T) {}\n+    }\n+\n+    fn test() {\n+        let s = StructForMethodCallTest {};\n+\n+        // Should NOT lint this because the argument type is bound to a concrete type.\n+        s.concrete_arg(1.);\n+\n+        // Should lint this because the argument type is bound to a concrete type.\n+        s.generic_arg(1.0_f64);\n+    }\n+}\n+\n+mod in_macro {\n+    macro_rules! internal_macro {\n+        () => {\n+            let x = 22.0_f64;\n+        };\n+    }\n+\n+    // Should lint in internal macro.\n+    fn internal() {\n+        internal_macro!();\n+    }\n+\n+    // Should NOT lint in external macro.\n+    fn external() {\n+        default_numeric_fallback!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e9687777bbd0bed95d74767187deb9566e5e8167", "filename": "tests/ui/default_numeric_fallback_f64.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/8131445e536869b4b73b07d1be1b2e03f7493898/tests%2Fui%2Fdefault_numeric_fallback_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8131445e536869b4b73b07d1be1b2e03f7493898/tests%2Fui%2Fdefault_numeric_fallback_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_f64.rs?ref=8131445e536869b4b73b07d1be1b2e03f7493898", "patch": "@@ -0,0 +1,174 @@\n+// run-rustfix\n+// aux-build:macro_rules.rs\n+\n+#![warn(clippy::default_numeric_fallback)]\n+#![allow(unused)]\n+#![allow(clippy::never_loop)]\n+#![allow(clippy::no_effect)]\n+#![allow(clippy::unnecessary_operation)]\n+#![allow(clippy::branches_sharing_code)]\n+#![allow(clippy::match_single_binding)]\n+\n+#[macro_use]\n+extern crate macro_rules;\n+\n+mod basic_expr {\n+    fn test() {\n+        // Should lint unsuffixed literals typed `f64`.\n+        let x = 0.12;\n+        let x = [1., 2., 3.];\n+        let x = if true { (1., 2.) } else { (3., 4.) };\n+        let x = match 1. {\n+            _ => 1.,\n+        };\n+\n+        // Should NOT lint suffixed literals.\n+        let x = 0.12_f64;\n+\n+        // Should NOT lint literals in init expr if `Local` has a type annotation.\n+        let x: f64 = 0.1;\n+        let x: [f64; 3] = [1., 2., 3.];\n+        let x: (f64, f64) = if true { (1., 2.) } else { (3., 4.) };\n+        let x: _ = 1.;\n+    }\n+}\n+\n+mod nested_local {\n+    fn test() {\n+        let x: _ = {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1.;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1.\n+        };\n+\n+        let x: _ = if true {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1.;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1.\n+        } else {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1.;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            2.\n+        };\n+    }\n+}\n+\n+mod function_def {\n+    fn ret_f64() -> f64 {\n+        // Even though the output type is specified,\n+        // this unsuffixed literal is linted to reduce heuristics and keep codebase simple.\n+        1.\n+    }\n+\n+    fn test() {\n+        // Should lint this because return type is inferred to `f64` and NOT bound to a concrete\n+        // type.\n+        let f = || -> _ { 1. };\n+\n+        // Even though the output type is specified,\n+        // this unsuffixed literal is linted to reduce heuristics and keep codebase simple.\n+        let f = || -> f64 { 1. };\n+    }\n+}\n+\n+mod function_calls {\n+    fn concrete_arg(f: f64) {}\n+\n+    fn generic_arg<T>(t: T) {}\n+\n+    fn test() {\n+        // Should NOT lint this because the argument type is bound to a concrete type.\n+        concrete_arg(1.);\n+\n+        // Should lint this because the argument type is inferred to `f64` and NOT bound to a concrete type.\n+        generic_arg(1.);\n+\n+        // Should lint this because the argument type is inferred to `f64` and NOT bound to a concrete type.\n+        let x: _ = generic_arg(1.);\n+    }\n+}\n+\n+mod struct_ctor {\n+    struct ConcreteStruct {\n+        x: f64,\n+    }\n+\n+    struct GenericStruct<T> {\n+        x: T,\n+    }\n+\n+    fn test() {\n+        // Should NOT lint this because the field type is bound to a concrete type.\n+        ConcreteStruct { x: 1. };\n+\n+        // Should lint this because the field type is inferred to `f64` and NOT bound to a concrete type.\n+        GenericStruct { x: 1. };\n+\n+        // Should lint this because the field type is inferred to `f64` and NOT bound to a concrete type.\n+        let _ = GenericStruct { x: 1. };\n+    }\n+}\n+\n+mod enum_ctor {\n+    enum ConcreteEnum {\n+        X(f64),\n+    }\n+\n+    enum GenericEnum<T> {\n+        X(T),\n+    }\n+\n+    fn test() {\n+        // Should NOT lint this because the field type is bound to a concrete type.\n+        ConcreteEnum::X(1.);\n+\n+        // Should lint this because the field type is inferred to `f64` and NOT bound to a concrete type.\n+        GenericEnum::X(1.);\n+    }\n+}\n+\n+mod method_calls {\n+    struct StructForMethodCallTest {}\n+\n+    impl StructForMethodCallTest {\n+        fn concrete_arg(&self, f: f64) {}\n+\n+        fn generic_arg<T>(&self, t: T) {}\n+    }\n+\n+    fn test() {\n+        let s = StructForMethodCallTest {};\n+\n+        // Should NOT lint this because the argument type is bound to a concrete type.\n+        s.concrete_arg(1.);\n+\n+        // Should lint this because the argument type is bound to a concrete type.\n+        s.generic_arg(1.);\n+    }\n+}\n+\n+mod in_macro {\n+    macro_rules! internal_macro {\n+        () => {\n+            let x = 22.;\n+        };\n+    }\n+\n+    // Should lint in internal macro.\n+    fn internal() {\n+        internal_macro!();\n+    }\n+\n+    // Should NOT lint in external macro.\n+    fn external() {\n+        default_numeric_fallback!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "961c7cb57c523f2746985606bb43cd4f8a55eb64", "filename": "tests/ui/default_numeric_fallback_f64.stderr", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/8131445e536869b4b73b07d1be1b2e03f7493898/tests%2Fui%2Fdefault_numeric_fallback_f64.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8131445e536869b4b73b07d1be1b2e03f7493898/tests%2Fui%2Fdefault_numeric_fallback_f64.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_f64.stderr?ref=8131445e536869b4b73b07d1be1b2e03f7493898", "patch": "@@ -0,0 +1,147 @@\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:18:17\n+   |\n+LL |         let x = 0.12;\n+   |                 ^^^^ help: consider adding suffix: `0.12_f64`\n+   |\n+   = note: `-D clippy::default-numeric-fallback` implied by `-D warnings`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:19:18\n+   |\n+LL |         let x = [1., 2., 3.];\n+   |                  ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:19:22\n+   |\n+LL |         let x = [1., 2., 3.];\n+   |                      ^^ help: consider adding suffix: `2.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:19:26\n+   |\n+LL |         let x = [1., 2., 3.];\n+   |                          ^^ help: consider adding suffix: `3.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:20:28\n+   |\n+LL |         let x = if true { (1., 2.) } else { (3., 4.) };\n+   |                            ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:20:32\n+   |\n+LL |         let x = if true { (1., 2.) } else { (3., 4.) };\n+   |                                ^^ help: consider adding suffix: `2.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:20:46\n+   |\n+LL |         let x = if true { (1., 2.) } else { (3., 4.) };\n+   |                                              ^^ help: consider adding suffix: `3.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:20:50\n+   |\n+LL |         let x = if true { (1., 2.) } else { (3., 4.) };\n+   |                                                  ^^ help: consider adding suffix: `4.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:21:23\n+   |\n+LL |         let x = match 1. {\n+   |                       ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:22:18\n+   |\n+LL |             _ => 1.,\n+   |                  ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:40:21\n+   |\n+LL |             let y = 1.;\n+   |                     ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:48:21\n+   |\n+LL |             let y = 1.;\n+   |                     ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:54:21\n+   |\n+LL |             let y = 1.;\n+   |                     ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:66:9\n+   |\n+LL |         1.\n+   |         ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:72:27\n+   |\n+LL |         let f = || -> _ { 1. };\n+   |                           ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:76:29\n+   |\n+LL |         let f = || -> f64 { 1. };\n+   |                             ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:90:21\n+   |\n+LL |         generic_arg(1.);\n+   |                     ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:93:32\n+   |\n+LL |         let x: _ = generic_arg(1.);\n+   |                                ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:111:28\n+   |\n+LL |         GenericStruct { x: 1. };\n+   |                            ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:114:36\n+   |\n+LL |         let _ = GenericStruct { x: 1. };\n+   |                                    ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:132:24\n+   |\n+LL |         GenericEnum::X(1.);\n+   |                        ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:152:23\n+   |\n+LL |         s.generic_arg(1.);\n+   |                       ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:159:21\n+   |\n+LL |             let x = 22.;\n+   |                     ^^^ help: consider adding suffix: `22.0_f64`\n+...\n+LL |         internal_macro!();\n+   |         ------------------ in this macro invocation\n+   |\n+   = note: this error originates in the macro `internal_macro` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 23 previous errors\n+"}, {"sha": "55c082fcb19fb7f1b563539721f9a89b111ba14b", "filename": "tests/ui/default_numeric_fallback_i32.fixed", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/8131445e536869b4b73b07d1be1b2e03f7493898/tests%2Fui%2Fdefault_numeric_fallback_i32.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8131445e536869b4b73b07d1be1b2e03f7493898/tests%2Fui%2Fdefault_numeric_fallback_i32.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_i32.fixed?ref=8131445e536869b4b73b07d1be1b2e03f7493898", "patch": "@@ -0,0 +1,173 @@\n+// run-rustfix\n+// aux-build:macro_rules.rs\n+\n+#![warn(clippy::default_numeric_fallback)]\n+#![allow(unused)]\n+#![allow(clippy::never_loop)]\n+#![allow(clippy::no_effect)]\n+#![allow(clippy::unnecessary_operation)]\n+#![allow(clippy::branches_sharing_code)]\n+\n+#[macro_use]\n+extern crate macro_rules;\n+\n+mod basic_expr {\n+    fn test() {\n+        // Should lint unsuffixed literals typed `i32`.\n+        let x = 22_i32;\n+        let x = [1_i32, 2_i32, 3_i32];\n+        let x = if true { (1_i32, 2_i32) } else { (3_i32, 4_i32) };\n+        let x = match 1_i32 {\n+            1_i32 => 1_i32,\n+            _ => 2_i32,\n+        };\n+\n+        // Should NOT lint suffixed literals.\n+        let x = 22_i32;\n+\n+        // Should NOT lint literals in init expr if `Local` has a type annotation.\n+        let x: [i32; 3] = [1, 2, 3];\n+        let x: (i32, i32) = if true { (1, 2) } else { (3, 4) };\n+        let x: _ = 1;\n+    }\n+}\n+\n+mod nested_local {\n+    fn test() {\n+        let x: _ = {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1_i32;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1\n+        };\n+\n+        let x: _ = if true {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1_i32;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1\n+        } else {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1_i32;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            2\n+        };\n+    }\n+}\n+\n+mod function_def {\n+    fn ret_i32() -> i32 {\n+        // Even though the output type is specified,\n+        // this unsuffixed literal is linted to reduce heuristics and keep codebase simple.\n+        1_i32\n+    }\n+\n+    fn test() {\n+        // Should lint this because return type is inferred to `i32` and NOT bound to a concrete\n+        // type.\n+        let f = || -> _ { 1_i32 };\n+\n+        // Even though the output type is specified,\n+        // this unsuffixed literal is linted to reduce heuristics and keep codebase simple.\n+        let f = || -> i32 { 1_i32 };\n+    }\n+}\n+\n+mod function_calls {\n+    fn concrete_arg(x: i32) {}\n+\n+    fn generic_arg<T>(t: T) {}\n+\n+    fn test() {\n+        // Should NOT lint this because the argument type is bound to a concrete type.\n+        concrete_arg(1);\n+\n+        // Should lint this because the argument type is inferred to `i32` and NOT bound to a concrete type.\n+        generic_arg(1_i32);\n+\n+        // Should lint this because the argument type is inferred to `i32` and NOT bound to a concrete type.\n+        let x: _ = generic_arg(1_i32);\n+    }\n+}\n+\n+mod struct_ctor {\n+    struct ConcreteStruct {\n+        x: i32,\n+    }\n+\n+    struct GenericStruct<T> {\n+        x: T,\n+    }\n+\n+    fn test() {\n+        // Should NOT lint this because the field type is bound to a concrete type.\n+        ConcreteStruct { x: 1 };\n+\n+        // Should lint this because the field type is inferred to `i32` and NOT bound to a concrete type.\n+        GenericStruct { x: 1_i32 };\n+\n+        // Should lint this because the field type is inferred to `i32` and NOT bound to a concrete type.\n+        let _ = GenericStruct { x: 1_i32 };\n+    }\n+}\n+\n+mod enum_ctor {\n+    enum ConcreteEnum {\n+        X(i32),\n+    }\n+\n+    enum GenericEnum<T> {\n+        X(T),\n+    }\n+\n+    fn test() {\n+        // Should NOT lint this because the field type is bound to a concrete type.\n+        ConcreteEnum::X(1);\n+\n+        // Should lint this because the field type is inferred to `i32` and NOT bound to a concrete type.\n+        GenericEnum::X(1_i32);\n+    }\n+}\n+\n+mod method_calls {\n+    struct StructForMethodCallTest {}\n+\n+    impl StructForMethodCallTest {\n+        fn concrete_arg(&self, x: i32) {}\n+\n+        fn generic_arg<T>(&self, t: T) {}\n+    }\n+\n+    fn test() {\n+        let s = StructForMethodCallTest {};\n+\n+        // Should NOT lint this because the argument type is bound to a concrete type.\n+        s.concrete_arg(1);\n+\n+        // Should lint this because the argument type is bound to a concrete type.\n+        s.generic_arg(1_i32);\n+    }\n+}\n+\n+mod in_macro {\n+    macro_rules! internal_macro {\n+        () => {\n+            let x = 22_i32;\n+        };\n+    }\n+\n+    // Should lint in internal macro.\n+    fn internal() {\n+        internal_macro!();\n+    }\n+\n+    // Should NOT lint in external macro.\n+    fn external() {\n+        default_numeric_fallback!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e0a4828ce9ff636aed3c8c510e6e094b9f370826", "filename": "tests/ui/default_numeric_fallback_i32.rs", "status": "renamed", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8131445e536869b4b73b07d1be1b2e03f7493898/tests%2Fui%2Fdefault_numeric_fallback_i32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8131445e536869b4b73b07d1be1b2e03f7493898/tests%2Fui%2Fdefault_numeric_fallback_i32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_i32.rs?ref=8131445e536869b4b73b07d1be1b2e03f7493898", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n // aux-build:macro_rules.rs\n \n #![warn(clippy::default_numeric_fallback)]\n@@ -21,15 +22,10 @@ mod basic_expr {\n             _ => 2,\n         };\n \n-        // Should lint unsuffixed literals typed `f64`.\n-        let x = 0.12;\n-\n         // Should NOT lint suffixed literals.\n         let x = 22_i32;\n-        let x = 0.12_f64;\n \n         // Should NOT lint literals in init expr if `Local` has a type annotation.\n-        let x: f64 = 0.1;\n         let x: [i32; 3] = [1, 2, 3];\n         let x: (i32, i32) = if true { (1, 2) } else { (3, 4) };\n         let x: _ = 1;\n@@ -118,6 +114,24 @@ mod struct_ctor {\n     }\n }\n \n+mod enum_ctor {\n+    enum ConcreteEnum {\n+        X(i32),\n+    }\n+\n+    enum GenericEnum<T> {\n+        X(T),\n+    }\n+\n+    fn test() {\n+        // Should NOT lint this because the field type is bound to a concrete type.\n+        ConcreteEnum::X(1);\n+\n+        // Should lint this because the field type is inferred to `i32` and NOT bound to a concrete type.\n+        GenericEnum::X(1);\n+    }\n+}\n+\n mod method_calls {\n     struct StructForMethodCallTest {}\n ", "previous_filename": "tests/ui/default_numeric_fallback.rs"}, {"sha": "5edf48b202087d01335588de9b0a7823926030ea", "filename": "tests/ui/default_numeric_fallback_i32.stderr", "status": "renamed", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8131445e536869b4b73b07d1be1b2e03f7493898/tests%2Fui%2Fdefault_numeric_fallback_i32.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8131445e536869b4b73b07d1be1b2e03f7493898/tests%2Fui%2Fdefault_numeric_fallback_i32.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_i32.stderr?ref=8131445e536869b4b73b07d1be1b2e03f7493898", "patch": "@@ -1,151 +1,151 @@\n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:16:17\n+  --> $DIR/default_numeric_fallback_i32.rs:17:17\n    |\n LL |         let x = 22;\n    |                 ^^ help: consider adding suffix: `22_i32`\n    |\n    = note: `-D clippy::default-numeric-fallback` implied by `-D warnings`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:17:18\n+  --> $DIR/default_numeric_fallback_i32.rs:18:18\n    |\n LL |         let x = [1, 2, 3];\n    |                  ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:17:21\n+  --> $DIR/default_numeric_fallback_i32.rs:18:21\n    |\n LL |         let x = [1, 2, 3];\n    |                     ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:17:24\n+  --> $DIR/default_numeric_fallback_i32.rs:18:24\n    |\n LL |         let x = [1, 2, 3];\n    |                        ^ help: consider adding suffix: `3_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:18:28\n+  --> $DIR/default_numeric_fallback_i32.rs:19:28\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                            ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:18:31\n+  --> $DIR/default_numeric_fallback_i32.rs:19:31\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                               ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:18:44\n+  --> $DIR/default_numeric_fallback_i32.rs:19:44\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                                            ^ help: consider adding suffix: `3_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:18:47\n+  --> $DIR/default_numeric_fallback_i32.rs:19:47\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                                               ^ help: consider adding suffix: `4_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:19:23\n+  --> $DIR/default_numeric_fallback_i32.rs:20:23\n    |\n LL |         let x = match 1 {\n    |                       ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:20:13\n+  --> $DIR/default_numeric_fallback_i32.rs:21:13\n    |\n LL |             1 => 1,\n    |             ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:20:18\n+  --> $DIR/default_numeric_fallback_i32.rs:21:18\n    |\n LL |             1 => 1,\n    |                  ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:21:18\n+  --> $DIR/default_numeric_fallback_i32.rs:22:18\n    |\n LL |             _ => 2,\n    |                  ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:25:17\n-   |\n-LL |         let x = 0.12;\n-   |                 ^^^^ help: consider adding suffix: `0.12_f64`\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:43:21\n+  --> $DIR/default_numeric_fallback_i32.rs:39:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:51:21\n+  --> $DIR/default_numeric_fallback_i32.rs:47:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:57:21\n+  --> $DIR/default_numeric_fallback_i32.rs:53:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:69:9\n+  --> $DIR/default_numeric_fallback_i32.rs:65:9\n    |\n LL |         1\n    |         ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:75:27\n+  --> $DIR/default_numeric_fallback_i32.rs:71:27\n    |\n LL |         let f = || -> _ { 1 };\n    |                           ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:79:29\n+  --> $DIR/default_numeric_fallback_i32.rs:75:29\n    |\n LL |         let f = || -> i32 { 1 };\n    |                             ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:93:21\n+  --> $DIR/default_numeric_fallback_i32.rs:89:21\n    |\n LL |         generic_arg(1);\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:96:32\n+  --> $DIR/default_numeric_fallback_i32.rs:92:32\n    |\n LL |         let x: _ = generic_arg(1);\n    |                                ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:114:28\n+  --> $DIR/default_numeric_fallback_i32.rs:110:28\n    |\n LL |         GenericStruct { x: 1 };\n    |                            ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:117:36\n+  --> $DIR/default_numeric_fallback_i32.rs:113:36\n    |\n LL |         let _ = GenericStruct { x: 1 };\n    |                                    ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:137:23\n+  --> $DIR/default_numeric_fallback_i32.rs:131:24\n+   |\n+LL |         GenericEnum::X(1);\n+   |                        ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_i32.rs:151:23\n    |\n LL |         s.generic_arg(1);\n    |                       ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:144:21\n+  --> $DIR/default_numeric_fallback_i32.rs:158:21\n    |\n LL |             let x = 22;\n    |                     ^^ help: consider adding suffix: `22_i32`", "previous_filename": "tests/ui/default_numeric_fallback.stderr"}]}