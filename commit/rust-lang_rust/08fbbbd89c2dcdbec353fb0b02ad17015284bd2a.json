{"sha": "08fbbbd89c2dcdbec353fb0b02ad17015284bd2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZmJiYmQ4OWMyZGNkYmVjMzUzZmIwYjAyYWQxNzAxNTI4NGJkMmE=", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2018-12-10T20:12:47Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2018-12-10T20:12:47Z"}, "message": "Fix nitpicks\n\nSwitch to vec::IntoIter as our backing double-ended iterator.\n\nFix incorrect comment.", "tree": {"sha": "acb1c92637689067133fea36f50853dd7ee4b577", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acb1c92637689067133fea36f50853dd7ee4b577"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08fbbbd89c2dcdbec353fb0b02ad17015284bd2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08fbbbd89c2dcdbec353fb0b02ad17015284bd2a", "html_url": "https://github.com/rust-lang/rust/commit/08fbbbd89c2dcdbec353fb0b02ad17015284bd2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08fbbbd89c2dcdbec353fb0b02ad17015284bd2a/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81de5d9519270e1c9dc3c1ee97067ac7058edefe", "url": "https://api.github.com/repos/rust-lang/rust/commits/81de5d9519270e1c9dc3c1ee97067ac7058edefe", "html_url": "https://github.com/rust-lang/rust/commit/81de5d9519270e1c9dc3c1ee97067ac7058edefe"}], "stats": {"total": 44, "additions": 21, "deletions": 23}, "files": [{"sha": "a0369fffa0c6e3175db838d1fd524d1a693010b7", "filename": "src/libstd/sys/windows/args.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/08fbbbd89c2dcdbec353fb0b02ad17015284bd2a/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08fbbbd89c2dcdbec353fb0b02ad17015284bd2a/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs?ref=08fbbbd89c2dcdbec353fb0b02ad17015284bd2a", "patch": "@@ -15,7 +15,7 @@ use sys::windows::os::current_exe;\n use sys::c;\n use ffi::OsString;\n use fmt;\n-use collections::VecDeque;\n+use vec;\n use core::iter;\n use slice;\n use path::PathBuf;\n@@ -43,19 +43,19 @@ pub fn args() -> Args {\n /// GUI applications add a bunch of overhead, even if no windows are drawn. See\n /// <https://randomascii.wordpress.com/2018/12/03/a-not-called-function-can-cause-a-5x-slowdown/>.\n unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_name: F)\n-                                                 -> VecDeque<OsString> {\n+                                                 -> vec::IntoIter<OsString> {\n     const BACKSLASH: u16 = '\\\\' as u16;\n     const QUOTE: u16 = '\"' as u16;\n     const TAB: u16 = '\\t' as u16;\n     const SPACE: u16 = ' ' as u16;\n     let mut in_quotes = false;\n     let mut was_in_quotes = false;\n     let mut backslash_count: usize = 0;\n-    let mut ret_val = VecDeque::new();\n+    let mut ret_val = Vec::new();\n     let mut cur = Vec::new();\n     if lp_cmd_line.is_null() || *lp_cmd_line == 0 {\n-        ret_val.push_back(exe_name());\n-        return ret_val;\n+        ret_val.push(exe_name());\n+        return ret_val.into_iter();\n     }\n     let mut i = 0;\n     // The executable name at the beginning is special.\n@@ -66,16 +66,16 @@ unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_na\n             loop {\n                 i += 1;\n                 if *lp_cmd_line.offset(i) == 0 {\n-                    ret_val.push_back(OsString::from_wide(\n+                    ret_val.push(OsString::from_wide(\n                         slice::from_raw_parts(lp_cmd_line.offset(1), i as usize - 1)\n                     ));\n-                    return ret_val;\n+                    return ret_val.into_iter();\n                 }\n                 if *lp_cmd_line.offset(i) == QUOTE {\n                     break;\n                 }\n             }\n-            ret_val.push_back(OsString::from_wide(\n+            ret_val.push(OsString::from_wide(\n                 slice::from_raw_parts(lp_cmd_line.offset(1), i as usize - 1)\n             ));\n             i += 1;\n@@ -86,25 +86,25 @@ unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_na\n         // will consider the first argument to be an empty string. Excess whitespace at the\n         // end of lpCmdLine is ignored.\"\n         0...SPACE => {\n-            ret_val.push_back(OsString::new());\n+            ret_val.push(OsString::new());\n             i += 1;\n         },\n-        // The executable name ends at the next quote mark,\n+        // The executable name ends at the next whitespace,\n         // no matter what.\n         _ => {\n             loop {\n                 i += 1;\n                 if *lp_cmd_line.offset(i) == 0 {\n-                    ret_val.push_back(OsString::from_wide(\n+                    ret_val.push(OsString::from_wide(\n                         slice::from_raw_parts(lp_cmd_line, i as usize)\n                     ));\n-                    return ret_val;\n+                    return ret_val.into_iter();\n                 }\n                 if let 0...SPACE = *lp_cmd_line.offset(i) {\n                     break;\n                 }\n             }\n-            ret_val.push_back(OsString::from_wide(\n+            ret_val.push(OsString::from_wide(\n                 slice::from_raw_parts(lp_cmd_line, i as usize)\n             ));\n             i += 1;\n@@ -138,7 +138,7 @@ unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_na\n             SPACE | TAB if !in_quotes => {\n                 cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n                 if !cur.is_empty() || was_in_quotes {\n-                    ret_val.push_back(OsString::from_wide(&cur[..]));\n+                    ret_val.push(OsString::from_wide(&cur[..]));\n                     cur.truncate(0);\n                 }\n                 backslash_count = 0;\n@@ -148,7 +148,7 @@ unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_na\n                 cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n                 // include empty quoted strings at the end of the arguments list\n                 if !cur.is_empty() || was_in_quotes || in_quotes {\n-                    ret_val.push_back(OsString::from_wide(&cur[..]));\n+                    ret_val.push(OsString::from_wide(&cur[..]));\n                 }\n                 break;\n             }\n@@ -161,11 +161,11 @@ unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_na\n         }\n         i += 1;\n     }\n-    ret_val\n+    ret_val.into_iter()\n }\n \n pub struct Args {\n-    parsed_args_list: VecDeque<OsString>,\n+    parsed_args_list: vec::IntoIter<OsString>,\n }\n \n pub struct ArgsInnerDebug<'a> {\n@@ -176,7 +176,7 @@ impl<'a> fmt::Debug for ArgsInnerDebug<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(\"[\")?;\n         let mut first = true;\n-        for i in &self.args.parsed_args_list {\n+        for i in self.args.parsed_args_list.clone() {\n             if !first {\n                 f.write_str(\", \")?;\n             }\n@@ -199,14 +199,12 @@ impl Args {\n \n impl Iterator for Args {\n     type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> { self.parsed_args_list.pop_front() }\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.parsed_args_list.len(), Some(self.parsed_args_list.len()))\n-    }\n+    fn next(&mut self) -> Option<OsString> { self.parsed_args_list.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.parsed_args_list.size_hint() }\n }\n \n impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> { self.parsed_args_list.pop_back() }\n+    fn next_back(&mut self) -> Option<OsString> { self.parsed_args_list.next_back() }\n }\n \n impl ExactSizeIterator for Args {"}]}