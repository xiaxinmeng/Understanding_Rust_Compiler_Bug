{"sha": "7cbd0dcf9372814cacc43d1860fce8bd36c44489", "node_id": "C_kwDOAAsO6NoAKDdjYmQwZGNmOTM3MjgxNGNhY2M0M2QxODYwZmNlOGJkMzZjNDQ0ODk", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2021-12-13T06:10:39Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2021-12-13T06:10:39Z"}, "message": "I wrote these functions, I should use them dang it", "tree": {"sha": "7e3cf32c635077c1b12518b8691a81a23f658121", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e3cf32c635077c1b12518b8691a81a23f658121"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cbd0dcf9372814cacc43d1860fce8bd36c44489", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cbd0dcf9372814cacc43d1860fce8bd36c44489", "html_url": "https://github.com/rust-lang/rust/commit/7cbd0dcf9372814cacc43d1860fce8bd36c44489", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cbd0dcf9372814cacc43d1860fce8bd36c44489/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a28c172a128dee00debcf828e2243e94d56fb5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a28c172a128dee00debcf828e2243e94d56fb5f", "html_url": "https://github.com/rust-lang/rust/commit/8a28c172a128dee00debcf828e2243e94d56fb5f"}], "stats": {"total": 152, "additions": 60, "deletions": 92}, "files": [{"sha": "3576764596cc5af7232a7f3de287a6b783470a68", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 60, "deletions": 92, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/7cbd0dcf9372814cacc43d1860fce8bd36c44489/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cbd0dcf9372814cacc43d1860fce8bd36c44489/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=7cbd0dcf9372814cacc43d1860fce8bd36c44489", "patch": "@@ -14,9 +14,8 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::ItemKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::outlives::obligations::TypeOutlives;\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::infer::{self, RegionckMode, SubregionOrigin};\n-use rustc_infer::infer::{RegionResolutionError, TyCtxtInferExt};\n-use rustc_infer::traits::TraitEngine;\n use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n@@ -27,9 +26,7 @@ use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n-use rustc_trait_selection::traits::{\n-    self, ObligationCause, ObligationCauseCode, TraitEngineExt, WellFormedLoc,\n-};\n+use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, WellFormedLoc};\n \n use std::convert::TryInto;\n use std::iter;\n@@ -435,99 +432,70 @@ fn check_gat_where_clauses(\n     if !clauses.is_empty() {\n         let param_env = tcx.param_env(trait_item.def_id);\n \n-        // This shouldn't really matter, but we need it\n-        let cause = traits::ObligationCause::new(\n-            trait_item.span,\n-            trait_item.hir_id(),\n-            ObligationCauseCode::MiscObligation,\n-        );\n-        // Create an `InferCtxt` to try to prove the clauses we require\n-        tcx.infer_ctxt().enter(|infcx| {\n-            let mut fulfillment_cx = <dyn TraitEngine<'_>>::new(tcx);\n-\n-            // Register all the clauses as obligations\n-            clauses\n-                .clone()\n-                .into_iter()\n-                .map(|predicate| {\n-                    traits::Obligation::new(\n-                        cause.clone(),\n+        let mut clauses: Vec<_> = clauses\n+            .into_iter()\n+            .filter(|clause| match clause.kind().skip_binder() {\n+                ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n+                    !region_known_to_outlive(\n+                        tcx,\n+                        trait_item.hir_id(),\n                         param_env,\n-                        predicate,\n+                        &FxHashSet::default(),\n+                        a,\n+                        b,\n                     )\n-                })\n-                .for_each(|obligation| {\n-                    fulfillment_cx.register_predicate_obligation(&infcx, obligation)\n-                });\n-\n-            // Convert these obligations into constraints by selecting\n-            let errors = fulfillment_cx.select_all_or_error(&infcx);\n-            if !errors.is_empty() {\n-                bug!(\"should have only registered region obligations, which get registerd as constraints\");\n-            }\n+                }\n+                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n+                    !ty_known_to_outlive(\n+                        tcx,\n+                        trait_item.hir_id(),\n+                        param_env,\n+                        &FxHashSet::default(),\n+                        a,\n+                        b,\n+                    )\n+                }\n+                _ => bug!(\"Unexpected PredicateKind\"),\n+            })\n+            .map(|clause| format!(\"{}\", clause))\n+            .collect();\n \n-            // FIXME(jackh726): some of this code is shared with `regionctxt`, but in a different\n-            // flow; we could probably better extract the shared logic\n-\n-            // Process the region obligations\n-            let body_id_map = infcx\n-                .inner\n-                .borrow()\n-                .region_obligations()\n-                .iter()\n-                .map(|&(id, _)| (id, vec![]))\n-                .collect();\n-\n-            infcx.process_registered_region_obligations(&body_id_map, None, param_env);\n-\n-            // Resolve the region constraints to find any constraints that we're provable\n-            let outlives_env = OutlivesEnvironment::new(param_env);\n-            let errors = infcx.resolve_regions(trait_item.def_id.to_def_id(), &outlives_env, RegionckMode::default());\n-\n-            // Emit an error if there are non-provable constriants\n-            if !errors.is_empty() {\n-                let mut clauses: Vec<_> = errors.into_iter().map(|error| match error {\n-                    RegionResolutionError::ConcreteFailure(_, sup, sub) => format!(\"{}: {}\", sub, sup),\n-                    RegionResolutionError::GenericBoundFailure(_, sub, sup) => format!(\"{}: {}\", sub, sup),\n-                    _ => bug!(\"Unexpected region resolution error when resolving outlives lint\"),\n-                }).collect();\n-                clauses.sort();\n-\n-                let plural = if clauses.len() > 1 { \"s\" } else { \"\" };\n-                let mut err = tcx.sess.struct_span_err(\n-                    trait_item.span,\n-                    &format!(\"missing required bound{} on `{}`\", plural, trait_item.ident),\n-                );\n+        // We sort so that order is predictable\n+        clauses.sort();\n \n-                let suggestion = format!(\n-                    \"{} {}\",\n-                    if !trait_item.generics.where_clause.predicates.is_empty() {\n-                        \",\"\n-                    } else {\n-                        \" where\"\n-                    },\n-                    clauses.join(\", \"),\n-                );\n-                err.span_suggestion(\n-                    trait_item.generics.where_clause.tail_span_for_suggestion(),\n-                    &format!(\"add the required where clause{}\", plural),\n-                    suggestion,\n-                    Applicability::MachineApplicable,\n-                );\n+        if !clauses.is_empty() {\n+            let plural = if clauses.len() > 1 { \"s\" } else { \"\" };\n+            let mut err = tcx.sess.struct_span_err(\n+                trait_item.span,\n+                &format!(\"missing required bound{} on `{}`\", plural, trait_item.ident),\n+            );\n \n-                let bound = if clauses.len() > 1 { \"these bounds are\" } else { \"this bound is\" };\n-                err.note(\n-                    &format!(\"{} required to ensure that impls have maximum flexibility\", bound)\n-                );\n-                err.note(\n-                    \"see issue #87479 \\\n-                     <https://github.com/rust-lang/rust/issues/87479> \\\n-                     for more information\",\n-                );\n+            let suggestion = format!(\n+                \"{} {}\",\n+                if !trait_item.generics.where_clause.predicates.is_empty() {\n+                    \",\"\n+                } else {\n+                    \" where\"\n+                },\n+                clauses.join(\", \"),\n+            );\n+            err.span_suggestion(\n+                trait_item.generics.where_clause.tail_span_for_suggestion(),\n+                &format!(\"add the required where clause{}\", plural),\n+                suggestion,\n+                Applicability::MachineApplicable,\n+            );\n \n-                err.emit()\n-            }\n-        });\n+            let bound = if clauses.len() > 1 { \"these bounds are\" } else { \"this bound is\" };\n+            err.note(&format!(\"{} required to ensure that impls have maximum flexibility\", bound));\n+            err.note(\n+                \"see issue #87479 \\\n+                 <https://github.com/rust-lang/rust/issues/87479> \\\n+                 for more information\",\n+            );\n+\n+            err.emit()\n+        }\n     }\n }\n "}]}