{"sha": "16d80de231abb2b1756f3951ffd4776d681035eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZDgwZGUyMzFhYmIyYjE3NTZmMzk1MWZmZDQ3NzZkNjgxMDM1ZWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-09T05:51:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-09T05:51:44Z"}, "message": "auto merge of #18557 : aturon/rust/io-removal, r=alexcrichton\n\nThis PR includes a sequence of commits that gradually dismantles the `librustrt` `rtio` system -- the main trait previously used to abstract over green and native io. It also largely dismantles `libnative`, moving much of its code into `libstd` and refactoring as it does so.\r\n\r\nTL;DR:\r\n\r\n* Before this PR: `rustc hello.rs && wc -c hello` produces 715,996\r\n* After this PR:  `rustc hello.rs && wc -c hello` produces 368,100\r\n\r\nThat is, this PR reduces the footprint of hello world by ~50%.\r\n\r\nThis is a major step toward #17325 (i.e. toward implementing the [runtime removal RFC](https://github.com/rust-lang/rfcs/pull/230).) What remains is to pull out the scheduling, synchronization and task infrastructure, and to remove `libgreen`. These will be done soon in a follow-up PR.\r\n\r\nPart of the work here is eliminating the `rtio` abstraction, which in many cases means bringing the implementation of io closer to the actual API presented in `std::io`.\r\n\r\nAnother aspect of this PR is the creation of two new, *private* modules within `std` that implement io:\r\n\r\n* The `sys` module, which represents a platform-specific implementation of a number of low-level abstractions that are used directly within `std::io` and `std::os`. These \"abstractions\" are left largely the same as they were in `libnative` (except for the removal of `Arc` in file descriptors), but they are expected to evolve greatly over time. Organizationally, there are `sys/unix/` and `sys/windows/` directories which both implement the entire `sys` module hierarchy; this means that nearly all of the platform-specific code is isolated and you can get a handle on each platform in isolation.\r\n\r\n* The `sys_common` module, which is rooted at `sys/common`, and provides a few pieces of private, low-level, but cross-platform functionality.\r\n\r\nIn the long term, the `sys` modules will provide hooks for exposing high-level platform-specific APIs as part of `libstd`. The first such API will be access to file descriptors from `std::io` abstractions, but a bit of design work remains before that step can be taken. \r\n\r\nThe `sys_common` module includes some traits (like `AsFileDesc`) which allow communication of private details between modules in disparate locations in the hierarchy; this helps overcome the relatively simple hierarchical privacy system in Rust.\r\n\r\nTo emphasize: the organization in `sys` is *very preliminary* and the main goal was to migrate away from `rtio` as quickly and simply as possible. The design will certainly evolve over time, and all of the details are currently private.\r\n\r\nAlong the way, this PR also entirely removes signal handling, since it was only supported on `librustuv` which was removed a while ago. \r\n\r\nBecause of the removal of APIs from `libnative` and `librustrt`, and the removal of signal handling, this is a:\r\n\r\n[breaking-change]\r\n\r\nSome of these APIs will return in public from from `std` over time.\r\n\r\nr? @alexcrichton", "tree": {"sha": "4b84ec180f4fd1debe62d440dd8be665582e55f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b84ec180f4fd1debe62d440dd8be665582e55f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16d80de231abb2b1756f3951ffd4776d681035eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16d80de231abb2b1756f3951ffd4776d681035eb", "html_url": "https://github.com/rust-lang/rust/commit/16d80de231abb2b1756f3951ffd4776d681035eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16d80de231abb2b1756f3951ffd4776d681035eb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2f303ad098844351d08800038a4f99fa2ff0817", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2f303ad098844351d08800038a4f99fa2ff0817", "html_url": "https://github.com/rust-lang/rust/commit/a2f303ad098844351d08800038a4f99fa2ff0817"}, {"sha": "5ea09e6a25816fb6f0aca5adb874c623981653df", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ea09e6a25816fb6f0aca5adb874c623981653df", "html_url": "https://github.com/rust-lang/rust/commit/5ea09e6a25816fb6f0aca5adb874c623981653df"}], "stats": {"total": 7605, "additions": 3929, "deletions": 3676}, "files": [{"sha": "e2b8eb54ac3aefa15655afca4a259497ff610312", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -18,7 +18,7 @@\n use alloc::arc::Arc;\n use std::sync::atomic;\n use std::mem;\n-use std::rt::rtio::{EventLoop, IoFactory, RemoteCallback};\n+use std::rt::rtio::{EventLoop, RemoteCallback};\n use std::rt::rtio::{PausableIdleCallback, Callback};\n use std::rt::exclusive::Exclusive;\n \n@@ -150,8 +150,6 @@ impl EventLoop for BasicLoop {\n             Box<RemoteCallback + Send>\n     }\n \n-    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory> { None }\n-\n     fn has_active_io(&self) -> bool { false }\n }\n "}, {"sha": "e26a099c0282561f0a19628f1f0df3cbbdf504f3", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -16,7 +16,6 @@ use std::mem;\n use std::rt::Runtime;\n use std::rt::local::Local;\n use std::rt::mutex::NativeMutex;\n-use std::rt::rtio;\n use std::rt::task::{Task, BlockedTask, TaskOpts};\n \n struct SimpleTask {\n@@ -79,9 +78,10 @@ impl Runtime for SimpleTask {\n                      _f: proc():Send) {\n         panic!()\n     }\n-    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> { None }\n+\n     fn stack_bounds(&self) -> (uint, uint) { panic!() }\n     fn stack_guard(&self) -> Option<uint> { panic!() }\n+\n     fn can_block(&self) -> bool { true }\n     fn wrap(self: Box<SimpleTask>) -> Box<Any+'static> { panic!() }\n }"}, {"sha": "428b64144128b0ccad1c654fe8b27b157e4a8b21", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -24,7 +24,6 @@ use std::raw;\n use std::rt::Runtime;\n use std::rt::local::Local;\n use std::rt::mutex::NativeMutex;\n-use std::rt::rtio;\n use std::rt::stack;\n use std::rt::task::{Task, BlockedTask, TaskOpts};\n use std::rt;\n@@ -468,14 +467,6 @@ impl Runtime for GreenTask {\n         sched.run_task(me, sibling)\n     }\n \n-    // Local I/O is provided by the scheduler's event loop\n-    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> {\n-        match self.sched.as_mut().unwrap().event_loop.io() {\n-            Some(io) => Some(rtio::LocalIo::new(io)),\n-            None => None,\n-        }\n-    }\n-\n     fn stack_bounds(&self) -> (uint, uint) {\n         let c = self.coroutine.as_ref()\n             .expect(\"GreenTask.stack_bounds called without a coroutine\");"}, {"sha": "f616295c73d1b1aafbcf7e6b61b684ea97d6e4ef", "filename": "src/libnative/io/file_unix.rs", "status": "removed", "additions": 0, "deletions": 554, "changes": 554, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -1,554 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Blocking posix-based file I/O\n-\n-use alloc::arc::Arc;\n-use libc::{mod, c_int, c_void};\n-use std::c_str::CString;\n-use std::mem;\n-use std::rt::rtio::{mod, IoResult};\n-\n-use io::{retry, keep_going};\n-use io::util;\n-\n-pub type fd_t = libc::c_int;\n-\n-struct Inner {\n-    fd: fd_t,\n-    close_on_drop: bool,\n-}\n-\n-pub struct FileDesc {\n-    inner: Arc<Inner>\n-}\n-\n-impl FileDesc {\n-    /// Create a `FileDesc` from an open C file descriptor.\n-    ///\n-    /// The `FileDesc` will take ownership of the specified file descriptor and\n-    /// close it upon destruction if the `close_on_drop` flag is true, otherwise\n-    /// it will not close the file descriptor when this `FileDesc` is dropped.\n-    ///\n-    /// Note that all I/O operations done on this object will be *blocking*, but\n-    /// they do not require the runtime to be active.\n-    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n-        FileDesc { inner: Arc::new(Inner {\n-            fd: fd,\n-            close_on_drop: close_on_drop\n-        }) }\n-    }\n-\n-    // FIXME(#10465) these functions should not be public, but anything in\n-    //               native::io wanting to use them is forced to have all the\n-    //               rtio traits in scope\n-    pub fn inner_read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        let ret = retry(|| unsafe {\n-            libc::read(self.fd(),\n-                       buf.as_mut_ptr() as *mut libc::c_void,\n-                       buf.len() as libc::size_t)\n-        });\n-        if ret == 0 {\n-            Err(util::eof())\n-        } else if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as uint)\n-        }\n-    }\n-    pub fn inner_write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::write(self.fd(), buf as *const libc::c_void,\n-                            len as libc::size_t) as i64\n-            }\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    pub fn fd(&self) -> fd_t { self.inner.fd }\n-}\n-\n-impl rtio::RtioFileStream for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> {\n-        self.inner_read(buf).map(|i| i as int)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner_write(buf)\n-    }\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n-        match retry(|| unsafe {\n-            libc::pread(self.fd(), buf.as_ptr() as *mut _,\n-                        buf.len() as libc::size_t,\n-                        offset as libc::off_t)\n-        }) {\n-            -1 => Err(super::last_error()),\n-            n => Ok(n as int)\n-        }\n-    }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe {\n-            libc::pwrite(self.fd(), buf.as_ptr() as *const _,\n-                         buf.len() as libc::size_t, offset as libc::off_t)\n-        }))\n-    }\n-    fn seek(&mut self, pos: i64, whence: rtio::SeekStyle) -> IoResult<u64> {\n-        let whence = match whence {\n-            rtio::SeekSet => libc::SEEK_SET,\n-            rtio::SeekEnd => libc::SEEK_END,\n-            rtio::SeekCur => libc::SEEK_CUR,\n-        };\n-        let n = unsafe { libc::lseek(self.fd(), pos as libc::off_t, whence) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-    fn tell(&self) -> IoResult<u64> {\n-        let n = unsafe { libc::lseek(self.fd(), 0, libc::SEEK_CUR) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-    fn fsync(&mut self) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe { libc::fsync(self.fd()) }))\n-    }\n-    fn datasync(&mut self) -> IoResult<()> {\n-        return super::mkerr_libc(os_datasync(self.fd()));\n-\n-        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-        fn os_datasync(fd: c_int) -> c_int {\n-            unsafe { libc::fcntl(fd, libc::F_FULLFSYNC) }\n-        }\n-        #[cfg(target_os = \"linux\")]\n-        fn os_datasync(fd: c_int) -> c_int {\n-            retry(|| unsafe { libc::fdatasync(fd) })\n-        }\n-        #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"linux\")))]\n-        fn os_datasync(fd: c_int) -> c_int {\n-            retry(|| unsafe { libc::fsync(fd) })\n-        }\n-    }\n-    fn truncate(&mut self, offset: i64) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe {\n-            libc::ftruncate(self.fd(), offset as libc::off_t)\n-        }))\n-    }\n-\n-    fn fstat(&mut self) -> IoResult<rtio::FileStat> {\n-        let mut stat: libc::stat = unsafe { mem::zeroed() };\n-        match unsafe { libc::fstat(self.fd(), &mut stat) } {\n-            0 => Ok(mkstat(&stat)),\n-            _ => Err(super::last_error()),\n-        }\n-    }\n-}\n-\n-impl rtio::RtioPipe for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.inner_read(buf)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner_write(buf)\n-    }\n-    fn clone(&self) -> Box<rtio::RtioPipe + Send> {\n-        box FileDesc { inner: self.inner.clone() } as Box<rtio::RtioPipe + Send>\n-    }\n-\n-    // Only supported on named pipes currently. Note that this doesn't have an\n-    // impact on the std::io primitives, this is never called via\n-    // std::io::PipeStream. If the functionality is exposed in the future, then\n-    // these methods will need to be implemented.\n-    fn close_read(&mut self) -> IoResult<()> {\n-        Err(super::unimpl())\n-    }\n-    fn close_write(&mut self) -> IoResult<()> {\n-        Err(super::unimpl())\n-    }\n-    fn set_timeout(&mut self, _t: Option<u64>) {}\n-    fn set_read_timeout(&mut self, _t: Option<u64>) {}\n-    fn set_write_timeout(&mut self, _t: Option<u64>) {}\n-}\n-\n-impl rtio::RtioTTY for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.inner_read(buf)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner_write(buf)\n-    }\n-    fn set_raw(&mut self, _raw: bool) -> IoResult<()> {\n-        Err(super::unimpl())\n-    }\n-    fn get_winsize(&mut self) -> IoResult<(int, int)> {\n-        Err(super::unimpl())\n-    }\n-    fn isatty(&self) -> bool { false }\n-}\n-\n-impl Drop for Inner {\n-    fn drop(&mut self) {\n-        // closing stdio file handles makes no sense, so never do it. Also, note\n-        // that errors are ignored when closing a file descriptor. The reason\n-        // for this is that if an error occurs we don't actually know if the\n-        // file descriptor was closed or not, and if we retried (for something\n-        // like EINTR), we might close another valid file descriptor (opened\n-        // after we closed ours.\n-        if self.close_on_drop && self.fd > libc::STDERR_FILENO {\n-            let n = unsafe { libc::close(self.fd) };\n-            if n != 0 {\n-                println!(\"error {} when closing file descriptor {}\", n,\n-                         self.fd);\n-            }\n-        }\n-    }\n-}\n-\n-pub struct CFile {\n-    file: *mut libc::FILE,\n-    fd: FileDesc,\n-}\n-\n-impl CFile {\n-    /// Create a `CFile` from an open `FILE` pointer.\n-    ///\n-    /// The `CFile` takes ownership of the `FILE` pointer and will close it upon\n-    /// destruction.\n-    pub fn new(file: *mut libc::FILE) -> CFile {\n-        CFile {\n-            file: file,\n-            fd: FileDesc::new(unsafe { libc::fileno(file) }, false)\n-        }\n-    }\n-\n-    pub fn flush(&mut self) -> IoResult<()> {\n-        super::mkerr_libc(retry(|| unsafe { libc::fflush(self.file) }))\n-    }\n-}\n-\n-impl rtio::RtioFileStream for CFile {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::fread(buf as *mut libc::c_void, 1, len as libc::size_t,\n-                            self.file) as i64\n-            }\n-        });\n-        if ret == 0 {\n-            Err(util::eof())\n-        } else if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as int)\n-        }\n-    }\n-\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let ret = keep_going(buf, |buf, len| {\n-            unsafe {\n-                libc::fwrite(buf as *const libc::c_void, 1, len as libc::size_t,\n-                            self.file) as i64\n-            }\n-        });\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n-        self.flush().and_then(|()| self.fd.pread(buf, offset))\n-    }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()> {\n-        self.flush().and_then(|()| self.fd.pwrite(buf, offset))\n-    }\n-    fn seek(&mut self, pos: i64, style: rtio::SeekStyle) -> IoResult<u64> {\n-        let whence = match style {\n-            rtio::SeekSet => libc::SEEK_SET,\n-            rtio::SeekEnd => libc::SEEK_END,\n-            rtio::SeekCur => libc::SEEK_CUR,\n-        };\n-        let n = unsafe { libc::fseek(self.file, pos as libc::c_long, whence) };\n-        if n < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(n as u64)\n-        }\n-    }\n-    fn tell(&self) -> IoResult<u64> {\n-        let ret = unsafe { libc::ftell(self.file) };\n-        if ret < 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(ret as u64)\n-        }\n-    }\n-    fn fsync(&mut self) -> IoResult<()> {\n-        self.flush().and_then(|()| self.fd.fsync())\n-    }\n-    fn datasync(&mut self) -> IoResult<()> {\n-        self.flush().and_then(|()| self.fd.datasync())\n-    }\n-    fn truncate(&mut self, offset: i64) -> IoResult<()> {\n-        self.flush().and_then(|()| self.fd.truncate(offset))\n-    }\n-\n-    fn fstat(&mut self) -> IoResult<rtio::FileStat> {\n-        self.flush().and_then(|()| self.fd.fstat())\n-    }\n-}\n-\n-impl Drop for CFile {\n-    fn drop(&mut self) {\n-        unsafe { let _ = libc::fclose(self.file); }\n-    }\n-}\n-\n-pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n-    -> IoResult<FileDesc>\n-{\n-    let flags = match fm {\n-        rtio::Open => 0,\n-        rtio::Append => libc::O_APPEND,\n-        rtio::Truncate => libc::O_TRUNC,\n-    };\n-    // Opening with a write permission must silently create the file.\n-    let (flags, mode) = match fa {\n-        rtio::Read => (flags | libc::O_RDONLY, 0),\n-        rtio::Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n-                        libc::S_IRUSR | libc::S_IWUSR),\n-        rtio::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n-                            libc::S_IRUSR | libc::S_IWUSR),\n-    };\n-\n-    match retry(|| unsafe { libc::open(path.as_ptr(), flags, mode) }) {\n-        -1 => Err(super::last_error()),\n-        fd => Ok(FileDesc::new(fd, true)),\n-    }\n-}\n-\n-pub fn mkdir(p: &CString, mode: uint) -> IoResult<()> {\n-    super::mkerr_libc(unsafe { libc::mkdir(p.as_ptr(), mode as libc::mode_t) })\n-}\n-\n-pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n-    use libc::{dirent_t};\n-    use libc::{opendir, readdir_r, closedir};\n-\n-    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<CString> {\n-        let root = unsafe { CString::new(root.as_ptr(), false) };\n-        let root = Path::new(root);\n-\n-        dirs.into_iter().filter(|path| {\n-            path.as_vec() != b\".\" && path.as_vec() != b\"..\"\n-        }).map(|path| root.join(path).to_c_str()).collect()\n-    }\n-\n-    extern {\n-        fn rust_dirent_t_size() -> libc::c_int;\n-        fn rust_list_dir_val(ptr: *mut dirent_t) -> *const libc::c_char;\n-    }\n-\n-    let size = unsafe { rust_dirent_t_size() };\n-    let mut buf = Vec::<u8>::with_capacity(size as uint);\n-    let ptr = buf.as_mut_slice().as_mut_ptr() as *mut dirent_t;\n-\n-    let dir_ptr = unsafe {opendir(p.as_ptr())};\n-\n-    if dir_ptr as uint != 0 {\n-        let mut paths = vec!();\n-        let mut entry_ptr = 0 as *mut dirent_t;\n-        while unsafe { readdir_r(dir_ptr, ptr, &mut entry_ptr) == 0 } {\n-            if entry_ptr.is_null() { break }\n-            let cstr = unsafe {\n-                CString::new(rust_list_dir_val(entry_ptr), false)\n-            };\n-            paths.push(Path::new(cstr));\n-        }\n-        assert_eq!(unsafe { closedir(dir_ptr) }, 0);\n-        Ok(prune(p, paths))\n-    } else {\n-        Err(super::last_error())\n-    }\n-}\n-\n-pub fn unlink(p: &CString) -> IoResult<()> {\n-    super::mkerr_libc(unsafe { libc::unlink(p.as_ptr()) })\n-}\n-\n-pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n-    super::mkerr_libc(unsafe { libc::rename(old.as_ptr(), new.as_ptr()) })\n-}\n-\n-pub fn chmod(p: &CString, mode: uint) -> IoResult<()> {\n-    super::mkerr_libc(retry(|| unsafe {\n-        libc::chmod(p.as_ptr(), mode as libc::mode_t)\n-    }))\n-}\n-\n-pub fn rmdir(p: &CString) -> IoResult<()> {\n-    super::mkerr_libc(unsafe { libc::rmdir(p.as_ptr()) })\n-}\n-\n-pub fn chown(p: &CString, uid: int, gid: int) -> IoResult<()> {\n-    super::mkerr_libc(retry(|| unsafe {\n-        libc::chown(p.as_ptr(), uid as libc::uid_t,\n-                    gid as libc::gid_t)\n-    }))\n-}\n-\n-pub fn readlink(p: &CString) -> IoResult<CString> {\n-    let p = p.as_ptr();\n-    let mut len = unsafe { libc::pathconf(p as *mut _, libc::_PC_NAME_MAX) };\n-    if len == -1 {\n-        len = 1024; // FIXME: read PATH_MAX from C ffi?\n-    }\n-    let mut buf: Vec<u8> = Vec::with_capacity(len as uint);\n-    match unsafe {\n-        libc::readlink(p, buf.as_ptr() as *mut libc::c_char,\n-                       len as libc::size_t) as libc::c_int\n-    } {\n-        -1 => Err(super::last_error()),\n-        n => {\n-            assert!(n > 0);\n-            unsafe { buf.set_len(n as uint); }\n-            Ok(buf.as_slice().to_c_str())\n-        }\n-    }\n-}\n-\n-pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-    super::mkerr_libc(unsafe { libc::symlink(src.as_ptr(), dst.as_ptr()) })\n-}\n-\n-pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n-    super::mkerr_libc(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })\n-}\n-\n-fn mkstat(stat: &libc::stat) -> rtio::FileStat {\n-    // FileStat times are in milliseconds\n-    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n-\n-    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn flags(_stat: &libc::stat) -> u64 { 0 }\n-\n-    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn gen(_stat: &libc::stat) -> u64 { 0 }\n-\n-    rtio::FileStat {\n-        size: stat.st_size as u64,\n-        kind: stat.st_mode as u64,\n-        perm: stat.st_mode as u64,\n-        created: mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64),\n-        modified: mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64),\n-        accessed: mktime(stat.st_atime as u64, stat.st_atime_nsec as u64),\n-        device: stat.st_dev as u64,\n-        inode: stat.st_ino as u64,\n-        rdev: stat.st_rdev as u64,\n-        nlink: stat.st_nlink as u64,\n-        uid: stat.st_uid as u64,\n-        gid: stat.st_gid as u64,\n-        blksize: stat.st_blksize as u64,\n-        blocks: stat.st_blocks as u64,\n-        flags: flags(stat),\n-        gen: gen(stat),\n-    }\n-}\n-\n-pub fn stat(p: &CString) -> IoResult<rtio::FileStat> {\n-    let mut stat: libc::stat = unsafe { mem::zeroed() };\n-    match unsafe { libc::stat(p.as_ptr(), &mut stat) } {\n-        0 => Ok(mkstat(&stat)),\n-        _ => Err(super::last_error()),\n-    }\n-}\n-\n-pub fn lstat(p: &CString) -> IoResult<rtio::FileStat> {\n-    let mut stat: libc::stat = unsafe { mem::zeroed() };\n-    match unsafe { libc::lstat(p.as_ptr(), &mut stat) } {\n-        0 => Ok(mkstat(&stat)),\n-        _ => Err(super::last_error()),\n-    }\n-}\n-\n-pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n-    let buf = libc::utimbuf {\n-        actime: (atime / 1000) as libc::time_t,\n-        modtime: (mtime / 1000) as libc::time_t,\n-    };\n-    super::mkerr_libc(unsafe { libc::utime(p.as_ptr(), &buf) })\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::{CFile, FileDesc};\n-    use libc;\n-    use std::os;\n-    use std::rt::rtio::{RtioFileStream, SeekSet};\n-\n-    #[cfg_attr(target_os = \"freebsd\", ignore)] // hmm, maybe pipes have a tiny buffer\n-    #[test]\n-    fn test_file_desc() {\n-        // Run this test with some pipes so we don't have to mess around with\n-        // opening or closing files.\n-        let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n-        let mut reader = FileDesc::new(reader, true);\n-        let mut writer = FileDesc::new(writer, true);\n-\n-        writer.inner_write(b\"test\").ok().unwrap();\n-        let mut buf = [0u8, ..4];\n-        match reader.inner_read(buf) {\n-            Ok(4) => {\n-                assert_eq!(buf[0], 't' as u8);\n-                assert_eq!(buf[1], 'e' as u8);\n-                assert_eq!(buf[2], 's' as u8);\n-                assert_eq!(buf[3], 't' as u8);\n-            }\n-            r => panic!(\"invalid read: {}\", r),\n-        }\n-\n-        assert!(writer.inner_read(buf).is_err());\n-        assert!(reader.inner_write(buf).is_err());\n-    }\n-\n-    #[test]\n-    fn test_cfile() {\n-        unsafe {\n-            let f = libc::tmpfile();\n-            assert!(!f.is_null());\n-            let mut file = CFile::new(f);\n-\n-            file.write(b\"test\").ok().unwrap();\n-            let mut buf = [0u8, ..4];\n-            let _ = file.seek(0, SeekSet).ok().unwrap();\n-            match file.read(buf) {\n-                Ok(4) => {\n-                    assert_eq!(buf[0], 't' as u8);\n-                    assert_eq!(buf[1], 'e' as u8);\n-                    assert_eq!(buf[2], 's' as u8);\n-                    assert_eq!(buf[3], 't' as u8);\n-                }\n-                r => panic!(\"invalid read: {}\", r)\n-            }\n-        }\n-    }\n-}"}, {"sha": "954f7bbc59adcd0dd48b8b4039d99d5e1419c26a", "filename": "src/libnative/io/mod.rs", "status": "removed", "additions": 0, "deletions": 311, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -1,311 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Native thread-blocking I/O implementation\n-//!\n-//! This module contains the implementation of native thread-blocking\n-//! implementations of I/O on all platforms. This module is not intended to be\n-//! used directly, but rather the rust runtime will fall back to using it if\n-//! necessary.\n-//!\n-//! Rust code normally runs inside of green tasks with a local scheduler using\n-//! asynchronous I/O to cooperate among tasks. This model is not always\n-//! available, however, and that's where these native implementations come into\n-//! play. The only dependencies of these modules are the normal system libraries\n-//! that you would find on the respective platform.\n-\n-#![allow(non_snake_case)]\n-\n-use libc::{mod, c_int};\n-use std::c_str::CString;\n-use std::os;\n-use std::rt::rtio::{mod, IoResult, IoError};\n-use std::num;\n-\n-// Local re-exports\n-pub use self::file::FileDesc;\n-pub use self::process::Process;\n-\n-mod helper_thread;\n-\n-// Native I/O implementations\n-pub mod addrinfo;\n-pub mod net;\n-pub mod process;\n-mod util;\n-\n-#[cfg(unix)]\n-#[path = \"file_unix.rs\"]\n-pub mod file;\n-#[cfg(windows)]\n-#[path = \"file_windows.rs\"]\n-pub mod file;\n-\n-#[cfg(any(target_os = \"macos\",\n-          target_os = \"ios\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"android\",\n-          target_os = \"linux\"))]\n-#[path = \"timer_unix.rs\"]\n-pub mod timer;\n-\n-#[cfg(target_os = \"windows\")]\n-#[path = \"timer_windows.rs\"]\n-pub mod timer;\n-\n-#[cfg(unix)]\n-#[path = \"pipe_unix.rs\"]\n-pub mod pipe;\n-\n-#[cfg(windows)]\n-#[path = \"pipe_windows.rs\"]\n-pub mod pipe;\n-\n-#[cfg(windows)]\n-#[path = \"tty_windows.rs\"]\n-mod tty;\n-\n-#[cfg(unix)]    #[path = \"c_unix.rs\"]  mod c;\n-#[cfg(windows)] #[path = \"c_windows.rs\"] mod c;\n-\n-fn unimpl() -> IoError {\n-    #[cfg(unix)] use libc::ENOSYS as ERROR;\n-    #[cfg(windows)] use libc::ERROR_CALL_NOT_IMPLEMENTED as ERROR;\n-    IoError {\n-        code: ERROR as uint,\n-        extra: 0,\n-        detail: Some(\"not yet supported by the `native` runtime, maybe try `green`.\".to_string()),\n-    }\n-}\n-\n-fn last_error() -> IoError {\n-    let errno = os::errno() as uint;\n-    IoError {\n-        code: os::errno() as uint,\n-        extra: 0,\n-        detail: Some(os::error_string(errno)),\n-    }\n-}\n-\n-// unix has nonzero values as errors\n-fn mkerr_libc <Int: num::Zero>(ret: Int) -> IoResult<()> {\n-    if !ret.is_zero() {\n-        Err(last_error())\n-    } else {\n-        Ok(())\n-    }\n-}\n-\n-// windows has zero values as errors\n-#[cfg(windows)]\n-fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> {\n-    if ret == 0 {\n-        Err(last_error())\n-    } else {\n-        Ok(())\n-    }\n-}\n-\n-#[cfg(windows)]\n-#[inline]\n-fn retry<I> (f: || -> I) -> I { f() } // PR rust-lang/rust/#17020\n-\n-#[cfg(unix)]\n-#[inline]\n-fn retry<I: PartialEq + num::One + Neg<I>> (f: || -> I) -> I {\n-    let minus_one = -num::one::<I>();\n-    loop {\n-        let n = f();\n-        if n == minus_one && os::errno() == libc::EINTR as int { }\n-        else { return n }\n-    }\n-}\n-\n-\n-fn keep_going(data: &[u8], f: |*const u8, uint| -> i64) -> i64 {\n-    let origamt = data.len();\n-    let mut data = data.as_ptr();\n-    let mut amt = origamt;\n-    while amt > 0 {\n-        let ret = retry(|| f(data, amt));\n-        if ret == 0 {\n-            break\n-        } else if ret != -1 {\n-            amt -= ret as uint;\n-            data = unsafe { data.offset(ret as int) };\n-        } else {\n-            return ret;\n-        }\n-    }\n-    return (origamt - amt) as i64;\n-}\n-\n-/// Implementation of rt::rtio's IoFactory trait to generate handles to the\n-/// native I/O functionality.\n-pub struct IoFactory {\n-    _cannot_construct_outside_of_this_module: ()\n-}\n-\n-impl IoFactory {\n-    pub fn new() -> IoFactory {\n-        net::init();\n-        IoFactory { _cannot_construct_outside_of_this_module: () }\n-    }\n-}\n-\n-impl rtio::IoFactory for IoFactory {\n-    // networking\n-    fn tcp_connect(&mut self, addr: rtio::SocketAddr,\n-                   timeout: Option<u64>)\n-        -> IoResult<Box<rtio::RtioTcpStream + Send>>\n-    {\n-        net::TcpStream::connect(addr, timeout).map(|s| {\n-            box s as Box<rtio::RtioTcpStream + Send>\n-        })\n-    }\n-    fn tcp_bind(&mut self, addr: rtio::SocketAddr)\n-                -> IoResult<Box<rtio::RtioTcpListener + Send>> {\n-        net::TcpListener::bind(addr).map(|s| {\n-            box s as Box<rtio::RtioTcpListener + Send>\n-        })\n-    }\n-    fn udp_bind(&mut self, addr: rtio::SocketAddr)\n-                -> IoResult<Box<rtio::RtioUdpSocket + Send>> {\n-        net::UdpSocket::bind(addr).map(|u| {\n-            box u as Box<rtio::RtioUdpSocket + Send>\n-        })\n-    }\n-    fn unix_bind(&mut self, path: &CString)\n-                 -> IoResult<Box<rtio::RtioUnixListener + Send>> {\n-        pipe::UnixListener::bind(path).map(|s| {\n-            box s as Box<rtio::RtioUnixListener + Send>\n-        })\n-    }\n-    fn unix_connect(&mut self, path: &CString,\n-                    timeout: Option<u64>) -> IoResult<Box<rtio::RtioPipe + Send>> {\n-        pipe::UnixStream::connect(path, timeout).map(|s| {\n-            box s as Box<rtio::RtioPipe + Send>\n-        })\n-    }\n-    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<rtio::AddrinfoHint>)\n-        -> IoResult<Vec<rtio::AddrinfoInfo>>\n-    {\n-        addrinfo::GetAddrInfoRequest::run(host, servname, hint)\n-    }\n-\n-    // filesystem operations\n-    fn fs_from_raw_fd(&mut self, fd: c_int, close: rtio::CloseBehavior)\n-                      -> Box<rtio::RtioFileStream + Send> {\n-        let close = match close {\n-            rtio::CloseSynchronously | rtio::CloseAsynchronously => true,\n-            rtio::DontClose => false\n-        };\n-        box file::FileDesc::new(fd, close) as Box<rtio::RtioFileStream + Send>\n-    }\n-    fn fs_open(&mut self, path: &CString, fm: rtio::FileMode,\n-               fa: rtio::FileAccess)\n-        -> IoResult<Box<rtio::RtioFileStream + Send>>\n-    {\n-        file::open(path, fm, fa).map(|fd| box fd as Box<rtio::RtioFileStream + Send>)\n-    }\n-    fn fs_unlink(&mut self, path: &CString) -> IoResult<()> {\n-        file::unlink(path)\n-    }\n-    fn fs_stat(&mut self, path: &CString) -> IoResult<rtio::FileStat> {\n-        file::stat(path)\n-    }\n-    fn fs_mkdir(&mut self, path: &CString, mode: uint) -> IoResult<()> {\n-        file::mkdir(path, mode)\n-    }\n-    fn fs_chmod(&mut self, path: &CString, mode: uint) -> IoResult<()> {\n-        file::chmod(path, mode)\n-    }\n-    fn fs_rmdir(&mut self, path: &CString) -> IoResult<()> {\n-        file::rmdir(path)\n-    }\n-    fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()> {\n-        file::rename(path, to)\n-    }\n-    fn fs_readdir(&mut self, path: &CString, _flags: c_int) -> IoResult<Vec<CString>> {\n-        file::readdir(path)\n-    }\n-    fn fs_lstat(&mut self, path: &CString) -> IoResult<rtio::FileStat> {\n-        file::lstat(path)\n-    }\n-    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> IoResult<()> {\n-        file::chown(path, uid, gid)\n-    }\n-    fn fs_readlink(&mut self, path: &CString) -> IoResult<CString> {\n-        file::readlink(path)\n-    }\n-    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()> {\n-        file::symlink(src, dst)\n-    }\n-    fn fs_link(&mut self, src: &CString, dst: &CString) -> IoResult<()> {\n-        file::link(src, dst)\n-    }\n-    fn fs_utime(&mut self, src: &CString, atime: u64,\n-                mtime: u64) -> IoResult<()> {\n-        file::utime(src, atime, mtime)\n-    }\n-\n-    // misc\n-    fn timer_init(&mut self) -> IoResult<Box<rtio::RtioTimer + Send>> {\n-        timer::Timer::new().map(|t| box t as Box<rtio::RtioTimer + Send>)\n-    }\n-    fn spawn(&mut self, cfg: rtio::ProcessConfig)\n-            -> IoResult<(Box<rtio::RtioProcess + Send>,\n-                         Vec<Option<Box<rtio::RtioPipe + Send>>>)> {\n-        process::Process::spawn(cfg).map(|(p, io)| {\n-            (box p as Box<rtio::RtioProcess + Send>,\n-             io.into_iter().map(|p| p.map(|p| {\n-                 box p as Box<rtio::RtioPipe + Send>\n-             })).collect())\n-        })\n-    }\n-    fn kill(&mut self, pid: libc::pid_t, signum: int) -> IoResult<()> {\n-        process::Process::kill(pid, signum)\n-    }\n-    fn pipe_open(&mut self, fd: c_int) -> IoResult<Box<rtio::RtioPipe + Send>> {\n-        Ok(box file::FileDesc::new(fd, true) as Box<rtio::RtioPipe + Send>)\n-    }\n-    #[cfg(unix)]\n-    fn tty_open(&mut self, fd: c_int, _readable: bool)\n-                -> IoResult<Box<rtio::RtioTTY + Send>> {\n-        if unsafe { libc::isatty(fd) } != 0 {\n-            Ok(box file::FileDesc::new(fd, true) as Box<rtio::RtioTTY + Send>)\n-        } else {\n-            Err(IoError {\n-                code: libc::ENOTTY as uint,\n-                extra: 0,\n-                detail: None,\n-            })\n-        }\n-    }\n-    #[cfg(windows)]\n-    fn tty_open(&mut self, fd: c_int, _readable: bool)\n-                -> IoResult<Box<rtio::RtioTTY + Send>> {\n-        if tty::is_tty(fd) {\n-            Ok(box tty::WindowsTTY::new(fd) as Box<rtio::RtioTTY + Send>)\n-        } else {\n-            Err(IoError {\n-                code: libc::ERROR_INVALID_HANDLE as uint,\n-                extra: 0,\n-                detail: None,\n-            })\n-        }\n-    }\n-    fn signal(&mut self, _signal: int, _cb: Box<rtio::Callback>)\n-              -> IoResult<Box<rtio::RtioSignal + Send>> {\n-        Err(unimpl())\n-    }\n-}"}, {"sha": "5f69ec00cddd493195ab2989e8aea1ae9268dcce", "filename": "src/libnative/io/util.rs", "status": "removed", "additions": 0, "deletions": 209, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibnative%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibnative%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Futil.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -1,209 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc;\n-use std::cmp;\n-use std::mem;\n-use std::os;\n-use std::ptr;\n-use std::rt::rtio::{IoResult, IoError};\n-\n-use super::c;\n-use super::net;\n-use super::{retry, last_error};\n-\n-#[deriving(Show)]\n-pub enum SocketStatus {\n-    Readable,\n-    Writable,\n-}\n-\n-pub fn timeout(desc: &'static str) -> IoError {\n-    #[cfg(unix)] use libc::ETIMEDOUT as ERROR;\n-    #[cfg(windows)] use libc::ERROR_OPERATION_ABORTED as ERROR;\n-    IoError {\n-        code: ERROR as uint,\n-        extra: 0,\n-        detail: Some(desc.to_string()),\n-    }\n-}\n-\n-pub fn short_write(n: uint, desc: &'static str) -> IoError {\n-    #[cfg(unix)] use libc::EAGAIN as ERROR;\n-    #[cfg(windows)] use libc::ERROR_OPERATION_ABORTED as ERROR;\n-    IoError {\n-        code: ERROR as uint,\n-        extra: n,\n-        detail: Some(desc.to_string()),\n-    }\n-}\n-\n-pub fn eof() -> IoError {\n-    IoError {\n-        code: libc::EOF as uint,\n-        extra: 0,\n-        detail: None,\n-    }\n-}\n-\n-#[cfg(windows)]\n-pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n-    libc::timeval {\n-        tv_sec: (ms / 1000) as libc::c_long,\n-        tv_usec: ((ms % 1000) * 1000) as libc::c_long,\n-    }\n-}\n-#[cfg(not(windows))]\n-pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n-    libc::timeval {\n-        tv_sec: (ms / 1000) as libc::time_t,\n-        tv_usec: ((ms % 1000) * 1000) as libc::suseconds_t,\n-    }\n-}\n-\n-#[cfg(unix)]\n-pub fn wouldblock() -> bool {\n-    let err = os::errno();\n-    err == libc::EWOULDBLOCK as int || err == libc::EAGAIN as int\n-}\n-\n-#[cfg(windows)]\n-pub fn wouldblock() -> bool {\n-    let err = os::errno();\n-    err == libc::WSAEWOULDBLOCK as uint\n-}\n-\n-#[cfg(unix)]\n-pub fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n-    let set = nb as libc::c_int;\n-    super::mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) }))\n-}\n-\n-#[cfg(windows)]\n-pub fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n-    let mut set = nb as libc::c_ulong;\n-    if unsafe { c::ioctlsocket(fd, c::FIONBIO, &mut set) != 0 } {\n-        Err(last_error())\n-    } else {\n-        Ok(())\n-    }\n-}\n-\n-// See http://developerweb.net/viewtopic.php?id=3196 for where this is\n-// derived from.\n-pub fn connect_timeout(fd: net::sock_t,\n-                       addrp: *const libc::sockaddr,\n-                       len: libc::socklen_t,\n-                       timeout_ms: u64) -> IoResult<()> {\n-    use std::os;\n-    #[cfg(unix)]    use libc::EINPROGRESS as INPROGRESS;\n-    #[cfg(windows)] use libc::WSAEINPROGRESS as INPROGRESS;\n-    #[cfg(unix)]    use libc::EWOULDBLOCK as WOULDBLOCK;\n-    #[cfg(windows)] use libc::WSAEWOULDBLOCK as WOULDBLOCK;\n-\n-    // Make sure the call to connect() doesn't block\n-    try!(set_nonblocking(fd, true));\n-\n-    let ret = match unsafe { libc::connect(fd, addrp, len) } {\n-        // If the connection is in progress, then we need to wait for it to\n-        // finish (with a timeout). The current strategy for doing this is\n-        // to use select() with a timeout.\n-        -1 if os::errno() as int == INPROGRESS as int ||\n-              os::errno() as int == WOULDBLOCK as int => {\n-            let mut set: c::fd_set = unsafe { mem::zeroed() };\n-            c::fd_set(&mut set, fd);\n-            match await(fd, &mut set, timeout_ms) {\n-                0 => Err(timeout(\"connection timed out\")),\n-                -1 => Err(last_error()),\n-                _ => {\n-                    let err: libc::c_int = try!(\n-                        net::getsockopt(fd, libc::SOL_SOCKET, libc::SO_ERROR));\n-                    if err == 0 {\n-                        Ok(())\n-                    } else {\n-                        Err(IoError {\n-                            code: err as uint,\n-                            extra: 0,\n-                            detail: Some(os::error_string(err as uint)),\n-                        })\n-                    }\n-                }\n-            }\n-        }\n-\n-        -1 => Err(last_error()),\n-        _ => Ok(()),\n-    };\n-\n-    // be sure to turn blocking I/O back on\n-    try!(set_nonblocking(fd, false));\n-    return ret;\n-\n-    #[cfg(unix)]\n-    fn await(fd: net::sock_t, set: &mut c::fd_set,\n-             timeout: u64) -> libc::c_int {\n-        let start = ::io::timer::now();\n-        retry(|| unsafe {\n-            // Recalculate the timeout each iteration (it is generally\n-            // undefined what the value of the 'tv' is after select\n-            // returns EINTR).\n-            let mut tv = ms_to_timeval(timeout - (::io::timer::now() - start));\n-            c::select(fd + 1, ptr::null_mut(), set as *mut _,\n-                      ptr::null_mut(), &mut tv)\n-        })\n-    }\n-    #[cfg(windows)]\n-    fn await(_fd: net::sock_t, set: &mut c::fd_set,\n-             timeout: u64) -> libc::c_int {\n-        let mut tv = ms_to_timeval(timeout);\n-        unsafe { c::select(1, ptr::null_mut(), set, ptr::null_mut(), &mut tv) }\n-    }\n-}\n-\n-pub fn await(fds: &[net::sock_t], deadline: Option<u64>,\n-             status: SocketStatus) -> IoResult<()> {\n-    let mut set: c::fd_set = unsafe { mem::zeroed() };\n-    let mut max = 0;\n-    for &fd in fds.iter() {\n-        c::fd_set(&mut set, fd);\n-        max = cmp::max(max, fd + 1);\n-    }\n-    if cfg!(windows) {\n-        max = fds.len() as net::sock_t;\n-    }\n-\n-    let (read, write) = match status {\n-        Readable => (&mut set as *mut _, ptr::null_mut()),\n-        Writable => (ptr::null_mut(), &mut set as *mut _),\n-    };\n-    let mut tv: libc::timeval = unsafe { mem::zeroed() };\n-\n-    match retry(|| {\n-        let now = ::io::timer::now();\n-        let tvp = match deadline {\n-            None => ptr::null_mut(),\n-            Some(deadline) => {\n-                // If we're past the deadline, then pass a 0 timeout to\n-                // select() so we can poll the status\n-                let ms = if deadline < now {0} else {deadline - now};\n-                tv = ms_to_timeval(ms);\n-                &mut tv as *mut _\n-            }\n-        };\n-        let r = unsafe {\n-            c::select(max as libc::c_int, read, write, ptr::null_mut(), tvp)\n-        };\n-        r\n-    }) {\n-        -1 => Err(last_error()),\n-        0 => Err(timeout(\"timed out\")),\n-        _ => Ok(()),\n-    }\n-}"}, {"sha": "4e25feb9d7531759475d9d06fef9331be7335d1f", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -74,7 +74,6 @@ use std::str;\n \n pub use task::NativeTaskBuilder;\n \n-pub mod io;\n pub mod task;\n \n #[cfg(any(windows, android))]"}, {"sha": "6d640b61b18d3a6dd0c79014d7ecbe6f0ebe6918", "filename": "src/libnative/task.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -19,13 +19,11 @@ use std::mem;\n use std::rt::bookkeeping;\n use std::rt::local::Local;\n use std::rt::mutex::NativeMutex;\n-use std::rt::rtio;\n use std::rt::stack;\n use std::rt::task::{Task, BlockedTask, TaskOpts};\n use std::rt::thread::Thread;\n use std::rt;\n \n-use io;\n use std::task::{TaskBuilder, Spawner};\n \n /// Creates a new Task which is ready to execute as a 1:1 task.\n@@ -42,7 +40,6 @@ fn ops() -> Box<Ops> {\n     box Ops {\n         lock: unsafe { NativeMutex::new() },\n         awoken: false,\n-        io: io::IoFactory::new(),\n         // these *should* get overwritten\n         stack_bounds: (0, 0),\n         stack_guard: 0\n@@ -112,7 +109,6 @@ impl<S: Spawner> NativeTaskBuilder for TaskBuilder<S> {\n struct Ops {\n     lock: NativeMutex,       // native synchronization\n     awoken: bool,      // used to prevent spurious wakeups\n-    io: io::IoFactory, // local I/O factory\n \n     // This field holds the known bounds of the stack in (lo, hi) form. Not all\n     // native tasks necessarily know their precise bounds, hence this is\n@@ -272,10 +268,6 @@ impl rt::Runtime for Ops {\n \n         NativeSpawner.spawn(opts, f);\n     }\n-\n-    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> {\n-        Some(rtio::LocalIo::new(&mut self.io as &mut rtio::IoFactory))\n-    }\n }\n \n #[cfg(test)]"}, {"sha": "fee748e29d9e08e6ee6ddda352f18a97b74468a0", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -90,7 +90,6 @@ pub trait Runtime {\n                      cur_task: Box<Task>,\n                      opts: TaskOpts,\n                      f: proc():Send);\n-    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>>;\n     /// The (low, high) edges of the current stack.\n     fn stack_bounds(&self) -> (uint, uint); // (lo, hi)\n     /// The last writable byte of the stack next to the guard page"}, {"sha": "86de8168189ca77afe962f35ef4f9a7ff1554602", "filename": "src/librustrt/rtio.rs", "status": "modified", "additions": 1, "deletions": 410, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -12,16 +12,6 @@\n \n use core::prelude::*;\n use alloc::boxed::Box;\n-use collections::string::String;\n-use collections::vec::Vec;\n-use core::fmt;\n-use core::mem;\n-use libc::c_int;\n-use libc;\n-\n-use c_str::CString;\n-use local::Local;\n-use task::Task;\n \n pub trait EventLoop {\n     fn run(&mut self);\n@@ -31,8 +21,7 @@ pub trait EventLoop {\n     fn remote_callback(&mut self, Box<Callback + Send>)\n                        -> Box<RemoteCallback + Send>;\n \n-    /// The asynchronous I/O services. Not all event loops may provide one.\n-    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory>;\n+    // last vestige of IoFactory\n     fn has_active_io(&self) -> bool;\n }\n \n@@ -50,405 +39,7 @@ pub trait RemoteCallback {\n     fn fire(&mut self);\n }\n \n-/// Description of what to do when a file handle is closed\n-pub enum CloseBehavior {\n-    /// Do not close this handle when the object is destroyed\n-    DontClose,\n-    /// Synchronously close the handle, meaning that the task will block when\n-    /// the handle is destroyed until it has been fully closed.\n-    CloseSynchronously,\n-    /// Asynchronously closes a handle, meaning that the task will *not* block\n-    /// when the handle is destroyed, but the handle will still get deallocated\n-    /// and cleaned up (but this will happen asynchronously on the local event\n-    /// loop).\n-    CloseAsynchronously,\n-}\n-\n-/// Data needed to spawn a process. Serializes the `std::io::process::Command`\n-/// builder.\n-pub struct ProcessConfig<'a> {\n-    /// Path to the program to run.\n-    pub program: &'a CString,\n-\n-    /// Arguments to pass to the program (doesn't include the program itself).\n-    pub args: &'a [CString],\n-\n-    /// Optional environment to specify for the program. If this is None, then\n-    /// it will inherit the current process's environment.\n-    pub env: Option<&'a [(&'a CString, &'a CString)]>,\n-\n-    /// Optional working directory for the new process. If this is None, then\n-    /// the current directory of the running process is inherited.\n-    pub cwd: Option<&'a CString>,\n-\n-    /// Configuration for the child process's stdin handle (file descriptor 0).\n-    /// This field defaults to `CreatePipe(true, false)` so the input can be\n-    /// written to.\n-    pub stdin: StdioContainer,\n-\n-    /// Configuration for the child process's stdout handle (file descriptor 1).\n-    /// This field defaults to `CreatePipe(false, true)` so the output can be\n-    /// collected.\n-    pub stdout: StdioContainer,\n-\n-    /// Configuration for the child process's stdout handle (file descriptor 2).\n-    /// This field defaults to `CreatePipe(false, true)` so the output can be\n-    /// collected.\n-    pub stderr: StdioContainer,\n-\n-    /// Any number of streams/file descriptors/pipes may be attached to this\n-    /// process. This list enumerates the file descriptors and such for the\n-    /// process to be spawned, and the file descriptors inherited will start at\n-    /// 3 and go to the length of this array. The first three file descriptors\n-    /// (stdin/stdout/stderr) are configured with the `stdin`, `stdout`, and\n-    /// `stderr` fields.\n-    pub extra_io: &'a [StdioContainer],\n-\n-    /// Sets the child process's user id. This translates to a `setuid` call in\n-    /// the child process. Setting this value on windows will cause the spawn to\n-    /// fail. Failure in the `setuid` call on unix will also cause the spawn to\n-    /// fail.\n-    pub uid: Option<uint>,\n-\n-    /// Similar to `uid`, but sets the group id of the child process. This has\n-    /// the same semantics as the `uid` field.\n-    pub gid: Option<uint>,\n-\n-    /// If true, the child process is spawned in a detached state. On unix, this\n-    /// means that the child is the leader of a new process group.\n-    pub detach: bool,\n-}\n-\n-pub struct LocalIo<'a> {\n-    factory: &'a mut IoFactory+'a,\n-}\n-\n-#[unsafe_destructor]\n-impl<'a> Drop for LocalIo<'a> {\n-    fn drop(&mut self) {\n-        // FIXME(pcwalton): Do nothing here for now, but eventually we may want\n-        // something. For now this serves to make `LocalIo` noncopyable.\n-    }\n-}\n-\n-impl<'a> LocalIo<'a> {\n-    /// Returns the local I/O: either the local scheduler's I/O services or\n-    /// the native I/O services.\n-    pub fn borrow() -> Option<LocalIo<'a>> {\n-        // FIXME(#11053): bad\n-        //\n-        // This is currently very unsafely implemented. We don't actually\n-        // *take* the local I/O so there's a very real possibility that we\n-        // can have two borrows at once. Currently there is not a clear way\n-        // to actually borrow the local I/O factory safely because even if\n-        // ownership were transferred down to the functions that the I/O\n-        // factory implements it's just too much of a pain to know when to\n-        // relinquish ownership back into the local task (but that would be\n-        // the safe way of implementing this function).\n-        //\n-        // In order to get around this, we just transmute a copy out of the task\n-        // in order to have what is likely a static lifetime (bad).\n-        let mut t: Box<Task> = match Local::try_take() {\n-            Some(t) => t,\n-            None => return None,\n-        };\n-        let ret = t.local_io().map(|t| {\n-            unsafe { mem::transmute_copy(&t) }\n-        });\n-        Local::put(t);\n-        return ret;\n-    }\n-\n-    pub fn maybe_raise<T>(f: |io: &mut IoFactory| -> IoResult<T>)\n-        -> IoResult<T>\n-    {\n-        #[cfg(unix)] use libc::EINVAL as ERROR;\n-        #[cfg(windows)] use libc::ERROR_CALL_NOT_IMPLEMENTED as ERROR;\n-        match LocalIo::borrow() {\n-            Some(mut io) => f(io.get()),\n-            None => Err(IoError {\n-                code: ERROR as uint,\n-                extra: 0,\n-                detail: None,\n-            }),\n-        }\n-    }\n-\n-    pub fn new<'a>(io: &'a mut IoFactory+'a) -> LocalIo<'a> {\n-        LocalIo { factory: io }\n-    }\n-\n-    /// Returns the underlying I/O factory as a trait reference.\n-    #[inline]\n-    pub fn get<'a>(&'a mut self) -> &'a mut IoFactory {\n-        let f: &'a mut IoFactory = self.factory;\n-        f\n-    }\n-}\n-\n-pub trait IoFactory {\n-    // networking\n-    fn tcp_connect(&mut self, addr: SocketAddr,\n-                   timeout: Option<u64>) -> IoResult<Box<RtioTcpStream + Send>>;\n-    fn tcp_bind(&mut self, addr: SocketAddr)\n-                -> IoResult<Box<RtioTcpListener + Send>>;\n-    fn udp_bind(&mut self, addr: SocketAddr)\n-                -> IoResult<Box<RtioUdpSocket + Send>>;\n-    fn unix_bind(&mut self, path: &CString)\n-                 -> IoResult<Box<RtioUnixListener + Send>>;\n-    fn unix_connect(&mut self, path: &CString,\n-                    timeout: Option<u64>) -> IoResult<Box<RtioPipe + Send>>;\n-    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<AddrinfoHint>)\n-                          -> IoResult<Vec<AddrinfoInfo>>;\n-\n-    // filesystem operations\n-    fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior)\n-                      -> Box<RtioFileStream + Send>;\n-    fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n-               -> IoResult<Box<RtioFileStream + Send>>;\n-    fn fs_unlink(&mut self, path: &CString) -> IoResult<()>;\n-    fn fs_stat(&mut self, path: &CString) -> IoResult<FileStat>;\n-    fn fs_mkdir(&mut self, path: &CString, mode: uint) -> IoResult<()>;\n-    fn fs_chmod(&mut self, path: &CString, mode: uint) -> IoResult<()>;\n-    fn fs_rmdir(&mut self, path: &CString) -> IoResult<()>;\n-    fn fs_rename(&mut self, path: &CString, to: &CString) -> IoResult<()>;\n-    fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n-        IoResult<Vec<CString>>;\n-    fn fs_lstat(&mut self, path: &CString) -> IoResult<FileStat>;\n-    fn fs_chown(&mut self, path: &CString, uid: int, gid: int) ->\n-        IoResult<()>;\n-    fn fs_readlink(&mut self, path: &CString) -> IoResult<CString>;\n-    fn fs_symlink(&mut self, src: &CString, dst: &CString) -> IoResult<()>;\n-    fn fs_link(&mut self, src: &CString, dst: &CString) -> IoResult<()>;\n-    fn fs_utime(&mut self, src: &CString, atime: u64, mtime: u64) ->\n-        IoResult<()>;\n-\n-    // misc\n-    fn timer_init(&mut self) -> IoResult<Box<RtioTimer + Send>>;\n-    fn spawn(&mut self, cfg: ProcessConfig)\n-            -> IoResult<(Box<RtioProcess + Send>,\n-                         Vec<Option<Box<RtioPipe + Send>>>)>;\n-    fn kill(&mut self, pid: libc::pid_t, signal: int) -> IoResult<()>;\n-    fn pipe_open(&mut self, fd: c_int) -> IoResult<Box<RtioPipe + Send>>;\n-    fn tty_open(&mut self, fd: c_int, readable: bool)\n-            -> IoResult<Box<RtioTTY + Send>>;\n-    fn signal(&mut self, signal: int, cb: Box<Callback + Send>)\n-        -> IoResult<Box<RtioSignal + Send>>;\n-}\n-\n-pub trait RtioTcpListener : RtioSocket {\n-    fn listen(self: Box<Self>) -> IoResult<Box<RtioTcpAcceptor + Send>>;\n-}\n-\n-pub trait RtioTcpAcceptor : RtioSocket {\n-    fn accept(&mut self) -> IoResult<Box<RtioTcpStream + Send>>;\n-    fn accept_simultaneously(&mut self) -> IoResult<()>;\n-    fn dont_accept_simultaneously(&mut self) -> IoResult<()>;\n-    fn set_timeout(&mut self, timeout: Option<u64>);\n-    fn clone(&self) -> Box<RtioTcpAcceptor + Send>;\n-    fn close_accept(&mut self) -> IoResult<()>;\n-}\n-\n-pub trait RtioTcpStream : RtioSocket {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n-    fn peer_name(&mut self) -> IoResult<SocketAddr>;\n-    fn control_congestion(&mut self) -> IoResult<()>;\n-    fn nodelay(&mut self) -> IoResult<()>;\n-    fn keepalive(&mut self, delay_in_seconds: uint) -> IoResult<()>;\n-    fn letdie(&mut self) -> IoResult<()>;\n-    fn clone(&self) -> Box<RtioTcpStream + Send>;\n-    fn close_write(&mut self) -> IoResult<()>;\n-    fn close_read(&mut self) -> IoResult<()>;\n-    fn set_timeout(&mut self, timeout_ms: Option<u64>);\n-    fn set_read_timeout(&mut self, timeout_ms: Option<u64>);\n-    fn set_write_timeout(&mut self, timeout_ms: Option<u64>);\n-}\n-\n-pub trait RtioSocket {\n-    fn socket_name(&mut self) -> IoResult<SocketAddr>;\n-}\n-\n-pub trait RtioUdpSocket : RtioSocket {\n-    fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)>;\n-    fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()>;\n-\n-    fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()>;\n-    fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()>;\n-\n-    fn loop_multicast_locally(&mut self) -> IoResult<()>;\n-    fn dont_loop_multicast_locally(&mut self) -> IoResult<()>;\n-\n-    fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()>;\n-    fn time_to_live(&mut self, ttl: int) -> IoResult<()>;\n-\n-    fn hear_broadcasts(&mut self) -> IoResult<()>;\n-    fn ignore_broadcasts(&mut self) -> IoResult<()>;\n-\n-    fn clone(&self) -> Box<RtioUdpSocket + Send>;\n-    fn set_timeout(&mut self, timeout_ms: Option<u64>);\n-    fn set_read_timeout(&mut self, timeout_ms: Option<u64>);\n-    fn set_write_timeout(&mut self, timeout_ms: Option<u64>);\n-}\n-\n-pub trait RtioTimer {\n-    fn sleep(&mut self, msecs: u64);\n-    fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>);\n-    fn period(&mut self, msecs: u64, cb: Box<Callback + Send>);\n-}\n-\n-pub trait RtioFileStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<int>;\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int>;\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()>;\n-    fn seek(&mut self, pos: i64, whence: SeekStyle) -> IoResult<u64>;\n-    fn tell(&self) -> IoResult<u64>;\n-    fn fsync(&mut self) -> IoResult<()>;\n-    fn datasync(&mut self) -> IoResult<()>;\n-    fn truncate(&mut self, offset: i64) -> IoResult<()>;\n-    fn fstat(&mut self) -> IoResult<FileStat>;\n-}\n-\n-pub trait RtioProcess {\n-    fn id(&self) -> libc::pid_t;\n-    fn kill(&mut self, signal: int) -> IoResult<()>;\n-    fn wait(&mut self) -> IoResult<ProcessExit>;\n-    fn set_timeout(&mut self, timeout: Option<u64>);\n-}\n-\n-pub trait RtioPipe {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n-    fn clone(&self) -> Box<RtioPipe + Send>;\n-\n-    fn close_write(&mut self) -> IoResult<()>;\n-    fn close_read(&mut self) -> IoResult<()>;\n-    fn set_timeout(&mut self, timeout_ms: Option<u64>);\n-    fn set_read_timeout(&mut self, timeout_ms: Option<u64>);\n-    fn set_write_timeout(&mut self, timeout_ms: Option<u64>);\n-}\n-\n-pub trait RtioUnixListener {\n-    fn listen(self: Box<Self>) -> IoResult<Box<RtioUnixAcceptor + Send>>;\n-}\n-\n-pub trait RtioUnixAcceptor {\n-    fn accept(&mut self) -> IoResult<Box<RtioPipe + Send>>;\n-    fn set_timeout(&mut self, timeout: Option<u64>);\n-    fn clone(&self) -> Box<RtioUnixAcceptor + Send>;\n-    fn close_accept(&mut self) -> IoResult<()>;\n-}\n-\n-pub trait RtioTTY {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n-    fn set_raw(&mut self, raw: bool) -> IoResult<()>;\n-    fn get_winsize(&mut self) -> IoResult<(int, int)>;\n-    fn isatty(&self) -> bool;\n-}\n-\n pub trait PausableIdleCallback {\n     fn pause(&mut self);\n     fn resume(&mut self);\n }\n-\n-pub trait RtioSignal {}\n-\n-#[deriving(Show)]\n-pub struct IoError {\n-    pub code: uint,\n-    pub extra: uint,\n-    pub detail: Option<String>,\n-}\n-\n-pub type IoResult<T> = Result<T, IoError>;\n-\n-#[deriving(PartialEq, Eq)]\n-pub enum IpAddr {\n-    Ipv4Addr(u8, u8, u8, u8),\n-    Ipv6Addr(u16, u16, u16, u16, u16, u16, u16, u16),\n-}\n-\n-impl fmt::Show for IpAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Ipv4Addr(a, b, c, d) => write!(fmt, \"{}.{}.{}.{}\", a, b, c, d),\n-            Ipv6Addr(a, b, c, d, e, f, g, h) => {\n-                write!(fmt,\n-                       \"{:04x}:{:04x}:{:04x}:{:04x}:{:04x}:{:04x}:{:04x}:{:04x}\",\n-                       a, b, c, d, e, f, g, h)\n-            }\n-        }\n-    }\n-}\n-\n-#[deriving(PartialEq, Eq)]\n-pub struct SocketAddr {\n-    pub ip: IpAddr,\n-    pub port: u16,\n-}\n-\n-pub enum StdioContainer {\n-    Ignored,\n-    InheritFd(i32),\n-    CreatePipe(bool, bool),\n-}\n-\n-pub enum ProcessExit {\n-    ExitStatus(int),\n-    ExitSignal(int),\n-}\n-\n-pub enum FileMode {\n-    Open,\n-    Append,\n-    Truncate,\n-}\n-\n-pub enum FileAccess {\n-    Read,\n-    Write,\n-    ReadWrite,\n-}\n-\n-pub struct FileStat {\n-    pub size: u64,\n-    pub kind: u64,\n-    pub perm: u64,\n-    pub created: u64,\n-    pub modified: u64,\n-    pub accessed: u64,\n-    pub device: u64,\n-    pub inode: u64,\n-    pub rdev: u64,\n-    pub nlink: u64,\n-    pub uid: u64,\n-    pub gid: u64,\n-    pub blksize: u64,\n-    pub blocks: u64,\n-    pub flags: u64,\n-    pub gen: u64,\n-}\n-\n-pub enum SeekStyle {\n-    SeekSet,\n-    SeekEnd,\n-    SeekCur,\n-}\n-\n-pub struct AddrinfoHint {\n-    pub family: uint,\n-    pub socktype: uint,\n-    pub protocol: uint,\n-    pub flags: uint,\n-}\n-\n-pub struct AddrinfoInfo {\n-    pub address: SocketAddr,\n-    pub family: uint,\n-    pub socktype: uint,\n-    pub protocol: uint,\n-    pub flags: uint,\n-}"}, {"sha": "554e4784eac51f981a80b3342de5ff8c9d3b2d7d", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -26,7 +26,6 @@ use core::raw;\n use local_data;\n use Runtime;\n use local::Local;\n-use rtio::LocalIo;\n use unwind;\n use unwind::Unwinder;\n use collections::str::SendStr;\n@@ -421,13 +420,6 @@ impl Task {\n         ops.maybe_yield(self);\n     }\n \n-    /// Acquires a handle to the I/O factory that this task contains, normally\n-    /// stored in the task's runtime. This factory may not always be available,\n-    /// which is why the return type is `Option`\n-    pub fn local_io<'a>(&'a mut self) -> Option<LocalIo<'a>> {\n-        self.imp.as_mut().unwrap().local_io()\n-    }\n-\n     /// Returns the stack bounds for this task in (lo, hi) format. The stack\n     /// bounds may not be known for all tasks, so the return value may be\n     /// `None`."}, {"sha": "5c2a5c3512d3212f9fe9fb24b336f6adc4615e96", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 87, "deletions": 217, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -52,28 +52,25 @@ fs::unlink(&path);\n \n */\n \n-use c_str::ToCStr;\n use clone::Clone;\n use io::standard_error;\n-use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n+use io::{FilePermission, Write, Open, FileAccess, FileMode};\n use io::{IoResult, IoError, FileStat, SeekStyle, Seek, Writer, Reader};\n-use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n+use io::{Read, Truncate, ReadWrite, Append};\n use io::UpdateIoError;\n use io;\n use iter::{Iterator, Extend};\n-use kinds::Send;\n-use libc;\n use option::{Some, None, Option};\n-use boxed::Box;\n use path::{Path, GenericPath};\n use path;\n use result::{Err, Ok};\n-use rt::rtio::LocalIo;\n-use rt::rtio;\n use slice::SlicePrelude;\n use string::String;\n use vec::Vec;\n \n+use sys::fs as fs_imp;\n+use sys_common;\n+\n /// Unconstrained file access type that exposes read and write operations\n ///\n /// Can be constructed via `File::open()`, `File::create()`, and\n@@ -86,11 +83,17 @@ use vec::Vec;\n /// configured at creation time, via the `FileAccess` parameter to\n /// `File::open_mode()`.\n pub struct File {\n-    fd: Box<rtio::RtioFileStream + Send>,\n+    fd: fs_imp::FileDesc,\n     path: Path,\n     last_nread: int,\n }\n \n+impl sys_common::AsFileDesc for File {\n+    fn as_fd(&self) -> &fs_imp::FileDesc {\n+        &self.fd\n+    }\n+}\n+\n impl File {\n     /// Open a file at `path` in the mode specified by the `mode` and `access`\n     /// arguments\n@@ -133,26 +136,13 @@ impl File {\n     pub fn open_mode(path: &Path,\n                      mode: FileMode,\n                      access: FileAccess) -> IoResult<File> {\n-        let rtio_mode = match mode {\n-            Open => rtio::Open,\n-            Append => rtio::Append,\n-            Truncate => rtio::Truncate,\n-        };\n-        let rtio_access = match access {\n-            Read => rtio::Read,\n-            Write => rtio::Write,\n-            ReadWrite => rtio::ReadWrite,\n-        };\n-        let err = LocalIo::maybe_raise(|io| {\n-            io.fs_open(&path.to_c_str(), rtio_mode, rtio_access).map(|fd| {\n-                File {\n-                    path: path.clone(),\n-                    fd: fd,\n-                    last_nread: -1\n-                }\n-            })\n-        }).map_err(IoError::from_rtio_error);\n-        err.update_err(\"couldn't open file\", |e| {\n+        fs_imp::open(path, mode, access).map(|fd| {\n+            File {\n+                path: path.clone(),\n+                fd: fd,\n+                last_nread: -1\n+            }\n+        }).update_err(\"couldn't open file\", |e| {\n             format!(\"{}; path={}; mode={}; access={}\", e, path.display(),\n                 mode_string(mode), access_string(access))\n         })\n@@ -194,7 +184,7 @@ impl File {\n     /// ```\n     pub fn create(path: &Path) -> IoResult<File> {\n         File::open_mode(path, Truncate, Write)\n-            .update_desc(\"couldn't create file\")\n+             .update_desc(\"couldn't create file\")\n     }\n \n     /// Returns the original path which was used to open this file.\n@@ -206,19 +196,19 @@ impl File {\n     /// device. This will flush any internal buffers necessary to perform this\n     /// operation.\n     pub fn fsync(&mut self) -> IoResult<()> {\n-        let err = self.fd.fsync().map_err(IoError::from_rtio_error);\n-        err.update_err(\"couldn't fsync file\",\n-                       |e| format!(\"{}; path={}\", e, self.path.display()))\n+        self.fd.fsync()\n+            .update_err(\"couldn't fsync file\",\n+                        |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n \n     /// This function is similar to `fsync`, except that it may not synchronize\n     /// file metadata to the filesystem. This is intended for use case which\n     /// must synchronize content, but don't need the metadata on disk. The goal\n     /// of this method is to reduce disk operations.\n     pub fn datasync(&mut self) -> IoResult<()> {\n-        let err = self.fd.datasync().map_err(IoError::from_rtio_error);\n-        err.update_err(\"couldn't datasync file\",\n-                       |e| format!(\"{}; path={}\", e, self.path.display()))\n+        self.fd.datasync()\n+            .update_err(\"couldn't datasync file\",\n+                        |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n \n     /// Either truncates or extends the underlying file, updating the size of\n@@ -230,10 +220,9 @@ impl File {\n     /// will be extended to `size` and have all of the intermediate data filled\n     /// in with 0s.\n     pub fn truncate(&mut self, size: i64) -> IoResult<()> {\n-        let err = self.fd.truncate(size).map_err(IoError::from_rtio_error);\n-        err.update_err(\"couldn't truncate file\", |e| {\n-            format!(\"{}; path={}; size={}\", e, self.path.display(), size)\n-        })\n+        self.fd.truncate(size)\n+            .update_err(\"couldn't truncate file\", |e|\n+                format!(\"{}; path={}; size={}\", e, self.path.display(), size))\n     }\n \n     /// Returns true if the stream has reached the end of the file.\n@@ -251,12 +240,9 @@ impl File {\n \n     /// Queries information about the underlying file.\n     pub fn stat(&mut self) -> IoResult<FileStat> {\n-        let err = match self.fd.fstat() {\n-            Ok(s) => Ok(from_rtio(s)),\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n-        };\n-        err.update_err(\"couldn't fstat file\",\n-                       |e| format!(\"{}; path={}\", e, self.path.display()))\n+        self.fd.fstat()\n+            .update_err(\"couldn't fstat file\", |e|\n+                format!(\"{}; path={}\", e, self.path.display()))\n     }\n }\n \n@@ -282,41 +268,9 @@ impl File {\n /// user lacks permissions to remove the file, or if some other filesystem-level\n /// error occurs.\n pub fn unlink(path: &Path) -> IoResult<()> {\n-    return match do_unlink(path) {\n-        Ok(()) => Ok(()),\n-        Err(e) => {\n-            // On unix, a readonly file can be successfully removed. On windows,\n-            // however, it cannot. To keep the two platforms in line with\n-            // respect to their behavior, catch this case on windows, attempt to\n-            // change it to read-write, and then remove the file.\n-            if cfg!(windows) && e.kind == io::PermissionDenied {\n-                let stat = match stat(path) {\n-                    Ok(stat) => stat,\n-                    Err(..) => return Err(e),\n-                };\n-                if stat.perm.intersects(io::USER_WRITE) { return Err(e) }\n-\n-                match chmod(path, stat.perm | io::USER_WRITE) {\n-                    Ok(()) => do_unlink(path),\n-                    Err(..) => {\n-                        // Try to put it back as we found it\n-                        let _ = chmod(path, stat.perm);\n-                        Err(e)\n-                    }\n-                }\n-            } else {\n-                Err(e)\n-            }\n-        }\n-    };\n-\n-    fn do_unlink(path: &Path) -> IoResult<()> {\n-        let err = LocalIo::maybe_raise(|io| {\n-            io.fs_unlink(&path.to_c_str())\n-        }).map_err(IoError::from_rtio_error);\n-        err.update_err(\"couldn't unlink path\",\n-                       |e| format!(\"{}; path={}\", e, path.display()))\n-    }\n+    fs_imp::unlink(path)\n+           .update_err(\"couldn't unlink path\", |e|\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -341,12 +295,9 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n /// to perform a `stat` call on the given `path` or if there is no entry in the\n /// filesystem at the provided path.\n pub fn stat(path: &Path) -> IoResult<FileStat> {\n-    let err = match LocalIo::maybe_raise(|io| io.fs_stat(&path.to_c_str())) {\n-        Ok(s) => Ok(from_rtio(s)),\n-        Err(e) => Err(IoError::from_rtio_error(e)),\n-    };\n-    err.update_err(\"couldn't stat path\",\n-                   |e| format!(\"{}; path={}\", e, path.display()))\n+    fs_imp::stat(path)\n+           .update_err(\"couldn't stat path\", |e|\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Perform the same operation as the `stat` function, except that this\n@@ -358,53 +309,9 @@ pub fn stat(path: &Path) -> IoResult<FileStat> {\n ///\n /// See `stat`\n pub fn lstat(path: &Path) -> IoResult<FileStat> {\n-    let err = match LocalIo::maybe_raise(|io| io.fs_lstat(&path.to_c_str())) {\n-        Ok(s) => Ok(from_rtio(s)),\n-        Err(e) => Err(IoError::from_rtio_error(e)),\n-    };\n-    err.update_err(\"couldn't lstat path\",\n-                   |e| format!(\"{}; path={}\", e, path.display()))\n-}\n-\n-fn from_rtio(s: rtio::FileStat) -> FileStat {\n-    #[cfg(windows)]\n-    type Mode = libc::c_int;\n-    #[cfg(unix)]\n-    type Mode = libc::mode_t;\n-\n-    let rtio::FileStat {\n-        size, kind, perm, created, modified,\n-        accessed, device, inode, rdev,\n-        nlink, uid, gid, blksize, blocks, flags, gen\n-    } = s;\n-\n-    FileStat {\n-        size: size,\n-        kind: match (kind as Mode) & libc::S_IFMT {\n-            libc::S_IFREG => io::TypeFile,\n-            libc::S_IFDIR => io::TypeDirectory,\n-            libc::S_IFIFO => io::TypeNamedPipe,\n-            libc::S_IFBLK => io::TypeBlockSpecial,\n-            libc::S_IFLNK => io::TypeSymlink,\n-            _ => io::TypeUnknown,\n-        },\n-        perm: FilePermission::from_bits_truncate(perm as u32),\n-        created: created,\n-        modified: modified,\n-        accessed: accessed,\n-        unstable: UnstableFileStat {\n-            device: device,\n-            inode: inode,\n-            rdev: rdev,\n-            nlink: nlink,\n-            uid: uid,\n-            gid: gid,\n-            blksize: blksize,\n-            blocks: blocks,\n-            flags: flags,\n-            gen: gen,\n-        },\n-    }\n+    fs_imp::lstat(path)\n+           .update_err(\"couldn't lstat path\", |e|\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Rename a file or directory to a new name.\n@@ -424,12 +331,9 @@ fn from_rtio(s: rtio::FileStat) -> FileStat {\n /// the process lacks permissions to view the contents, or if some other\n /// intermittent I/O error occurs.\n pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        io.fs_rename(&from.to_c_str(), &to.to_c_str())\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't rename path\", |e| {\n-        format!(\"{}; from={}; to={}\", e, from.display(), to.display())\n-    })\n+    fs_imp::rename(from, to)\n+           .update_err(\"couldn't rename path\", |e|\n+               format!(\"{}; from={}; to={}\", e, from.display(), to.display()))\n }\n \n /// Copies the contents of one file to another. This function will also\n@@ -462,8 +366,9 @@ pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n /// being created and then destroyed by this operation.\n pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n     fn update_err<T>(result: IoResult<T>, from: &Path, to: &Path) -> IoResult<T> {\n-        result.update_err(\"couldn't copy path\",\n-            |e| format!(\"{}; from={}; to={}\", e, from.display(), to.display()))\n+        result.update_err(\"couldn't copy path\", |e| {\n+            format!(\"{}; from={}; to={}\", e, from.display(), to.display())\n+        })\n     }\n \n     if !from.is_file() {\n@@ -512,45 +417,33 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n /// the process lacks permissions to change the attributes of the file, or if\n /// some other I/O error is encountered.\n pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        io.fs_chmod(&path.to_c_str(), mode.bits() as uint)\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't chmod path\", |e| {\n-        format!(\"{}; path={}; mode={}\", e, path.display(), mode)\n-    })\n+    fs_imp::chmod(path, mode.bits() as uint)\n+           .update_err(\"couldn't chmod path\", |e|\n+               format!(\"{}; path={}; mode={}\", e, path.display(), mode))\n }\n \n /// Change the user and group owners of a file at the specified path.\n pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        io.fs_chown(&path.to_c_str(), uid, gid)\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't chown path\", |e| {\n-        format!(\"{}; path={}; uid={}; gid={}\", e, path.display(), uid, gid)\n-    })\n+    fs_imp::chown(path, uid, gid)\n+           .update_err(\"couldn't chown path\", |e|\n+               format!(\"{}; path={}; uid={}; gid={}\", e, path.display(), uid, gid))\n }\n \n /// Creates a new hard link on the filesystem. The `dst` path will be a\n /// link pointing to the `src` path. Note that systems often require these\n /// two paths to both be located on the same filesystem.\n pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        io.fs_link(&src.to_c_str(), &dst.to_c_str())\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't link path\", |e| {\n-        format!(\"{}; src={}; dest={}\", e, src.display(), dst.display())\n-    })\n+    fs_imp::link(src, dst)\n+           .update_err(\"couldn't link path\", |e|\n+               format!(\"{}; src={}; dest={}\", e, src.display(), dst.display()))\n }\n \n /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n /// symlink pointing to the `src` path.\n pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        io.fs_symlink(&src.to_c_str(), &dst.to_c_str())\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't symlink path\", |e| {\n-        format!(\"{}; src={}; dest={}\", e, src.display(), dst.display())\n-    })\n+    fs_imp::symlink(src, dst)\n+           .update_err(\"couldn't symlink path\", |e|\n+               format!(\"{}; src={}; dest={}\", e, src.display(), dst.display()))\n }\n \n /// Reads a symlink, returning the file that the symlink points to.\n@@ -560,11 +453,9 @@ pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n /// This function will return an error on failure. Failure conditions include\n /// reading a file that does not exist or reading a file which is not a symlink.\n pub fn readlink(path: &Path) -> IoResult<Path> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        Ok(Path::new(try!(io.fs_readlink(&path.to_c_str()))))\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't resolve symlink for path\",\n-                   |e| format!(\"{}; path={}\", e, path.display()))\n+    fs_imp::readlink(path)\n+           .update_err(\"couldn't resolve symlink for path\", |e|\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Create a new, empty directory at the provided path\n@@ -585,12 +476,9 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n /// This function will return an error if the user lacks permissions to make a\n /// new directory at the provided `path`, or if the directory already exists.\n pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        io.fs_mkdir(&path.to_c_str(), mode.bits() as uint)\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't create directory\", |e| {\n-        format!(\"{}; path={}; mode={}\", e, path.display(), mode)\n-    })\n+    fs_imp::mkdir(path, mode.bits() as uint)\n+           .update_err(\"couldn't create directory\", |e|\n+               format!(\"{}; path={}; mode={}\", e, path.display(), mode))\n }\n \n /// Remove an existing, empty directory\n@@ -610,11 +498,9 @@ pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n /// This function will return an error if the user lacks permissions to remove\n /// the directory at the provided `path`, or if the directory isn't empty.\n pub fn rmdir(path: &Path) -> IoResult<()> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        io.fs_rmdir(&path.to_c_str())\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't remove directory\",\n-                   |e| format!(\"{}; path={}\", e, path.display()))\n+    fs_imp::rmdir(path)\n+           .update_err(\"couldn't remove directory\", |e|\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Retrieve a vector containing all entries within a provided directory\n@@ -650,13 +536,9 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        Ok(try!(io.fs_readdir(&path.to_c_str(), 0)).into_iter().map(|a| {\n-            Path::new(a)\n-        }).collect())\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't read directory\",\n-                   |e| format!(\"{}; path={}\", e, path.display()))\n+    fs_imp::readdir(path)\n+           .update_err(\"couldn't read directory\",\n+                       |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Returns an iterator which will recursively walk the directory structure\n@@ -666,8 +548,7 @@ pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n     Ok(Directories {\n         stack: try!(readdir(path).update_err(\"couldn't walk directory\",\n-                                             |e| format!(\"{}; path={}\",\n-                                                         e, path.display())))\n+                                             |e| format!(\"{}; path={}\", e, path.display())))\n     })\n }\n \n@@ -681,12 +562,7 @@ impl Iterator<Path> for Directories {\n         match self.stack.pop() {\n             Some(path) => {\n                 if path.is_dir() {\n-                    let result = readdir(&path)\n-                        .update_err(\"couldn't advance Directories iterator\",\n-                                    |e| format!(\"{}; path={}\",\n-                                                e, path.display()));\n-\n-                    match result {\n+                    match readdir(&path) {\n                         Ok(dirs) => { self.stack.extend(dirs.into_iter()); }\n                         Err(..) => {}\n                     }\n@@ -804,11 +680,9 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n /// be in milliseconds.\n // FIXME(#10301) these arguments should not be u64\n pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n-    let err = LocalIo::maybe_raise(|io| {\n-        io.fs_utime(&path.to_c_str(), atime, mtime)\n-    }).map_err(IoError::from_rtio_error);\n-    err.update_err(\"couldn't change_file_times\",\n-                   |e| format!(\"{}; path={}\", e, path.display()))\n+    fs_imp::utime(path, atime, mtime)\n+           .update_err(\"couldn't change_file_times\", |e|\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n impl Reader for File {\n@@ -819,12 +693,11 @@ impl Reader for File {\n                                           e, file.path.display()))\n         }\n \n-        let result = update_err(self.fd.read(buf)\n-                                    .map_err(IoError::from_rtio_error), self);\n+        let result = update_err(self.fd.read(buf), self);\n \n         match result {\n             Ok(read) => {\n-                self.last_nread = read;\n+                self.last_nread = read as int;\n                 match read {\n                     0 => update_err(Err(standard_error(io::EndOfFile)), self),\n                     _ => Ok(read as uint)\n@@ -837,32 +710,27 @@ impl Reader for File {\n \n impl Writer for File {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let err = self.fd.write(buf).map_err(IoError::from_rtio_error);\n-        err.update_err(\"couldn't write to file\",\n-                       |e| format!(\"{}; path={}\", e, self.path.display()))\n+        self.fd.write(buf)\n+            .update_err(\"couldn't write to file\",\n+                        |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n }\n \n impl Seek for File {\n     fn tell(&self) -> IoResult<u64> {\n-        let err = self.fd.tell().map_err(IoError::from_rtio_error);\n-        err.update_err(\"couldn't retrieve file cursor (`tell`)\",\n-                       |e| format!(\"{}; path={}\", e, self.path.display()))\n+        self.fd.tell()\n+            .update_err(\"couldn't retrieve file cursor (`tell`)\",\n+                        |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n \n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let style = match style {\n-            SeekSet => rtio::SeekSet,\n-            SeekCur => rtio::SeekCur,\n-            SeekEnd => rtio::SeekEnd,\n-        };\n         let err = match self.fd.seek(pos, style) {\n             Ok(_) => {\n                 // successful seek resets EOF indicator\n                 self.last_nread = -1;\n                 Ok(())\n             }\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n+            Err(e) => Err(e),\n         };\n         err.update_err(\"couldn't seek in file\",\n                        |e| format!(\"{}; path={}\", e, self.path.display()))\n@@ -942,6 +810,8 @@ fn access_string(access: FileAccess) -> &'static str {\n \n #[cfg(test)]\n #[allow(unused_imports)]\n+#[allow(unused_variables)]\n+#[allow(unused_mut)]\n mod test {\n     use prelude::*;\n     use io::{SeekSet, SeekCur, SeekEnd, Read, Open, ReadWrite};"}, {"sha": "31eab4363d0aaa869216d7595a34d861bbef2e15", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 6, "deletions": 98, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -228,14 +228,13 @@ use error::{FromError, Error};\n use fmt;\n use int;\n use iter::Iterator;\n-use libc;\n use mem::transmute;\n use ops::{BitOr, BitXor, BitAnd, Sub, Not};\n use option::{Option, Some, None};\n use os;\n use boxed::Box;\n use result::{Ok, Err, Result};\n-use rt::rtio;\n+use sys;\n use slice::{AsSlice, SlicePrelude};\n use str::{Str, StrPrelude};\n use str;\n@@ -312,92 +311,12 @@ impl IoError {\n     /// struct is filled with an allocated string describing the error\n     /// in more detail, retrieved from the operating system.\n     pub fn from_errno(errno: uint, detail: bool) -> IoError {\n-\n-        #[cfg(windows)]\n-        fn get_err(errno: i32) -> (IoErrorKind, &'static str) {\n-            match errno {\n-                libc::EOF => (EndOfFile, \"end of file\"),\n-                libc::ERROR_NO_DATA => (BrokenPipe, \"the pipe is being closed\"),\n-                libc::ERROR_FILE_NOT_FOUND => (FileNotFound, \"file not found\"),\n-                libc::ERROR_INVALID_NAME => (InvalidInput, \"invalid file name\"),\n-                libc::WSAECONNREFUSED => (ConnectionRefused, \"connection refused\"),\n-                libc::WSAECONNRESET => (ConnectionReset, \"connection reset\"),\n-                libc::ERROR_ACCESS_DENIED | libc::WSAEACCES =>\n-                    (PermissionDenied, \"permission denied\"),\n-                libc::WSAEWOULDBLOCK => {\n-                    (ResourceUnavailable, \"resource temporarily unavailable\")\n-                }\n-                libc::WSAENOTCONN => (NotConnected, \"not connected\"),\n-                libc::WSAECONNABORTED => (ConnectionAborted, \"connection aborted\"),\n-                libc::WSAEADDRNOTAVAIL => (ConnectionRefused, \"address not available\"),\n-                libc::WSAEADDRINUSE => (ConnectionRefused, \"address in use\"),\n-                libc::ERROR_BROKEN_PIPE => (EndOfFile, \"the pipe has ended\"),\n-                libc::ERROR_OPERATION_ABORTED =>\n-                    (TimedOut, \"operation timed out\"),\n-                libc::WSAEINVAL => (InvalidInput, \"invalid argument\"),\n-                libc::ERROR_CALL_NOT_IMPLEMENTED =>\n-                    (IoUnavailable, \"function not implemented\"),\n-                libc::ERROR_INVALID_HANDLE =>\n-                    (MismatchedFileTypeForOperation,\n-                     \"invalid handle provided to function\"),\n-                libc::ERROR_NOTHING_TO_TERMINATE =>\n-                    (InvalidInput, \"no process to kill\"),\n-\n-                // libuv maps this error code to EISDIR. we do too. if it is found\n-                // to be incorrect, we can add in some more machinery to only\n-                // return this message when ERROR_INVALID_FUNCTION after certain\n-                // Windows calls.\n-                libc::ERROR_INVALID_FUNCTION => (InvalidInput,\n-                                                 \"illegal operation on a directory\"),\n-\n-                _ => (OtherIoError, \"unknown error\")\n-            }\n-        }\n-\n-        #[cfg(not(windows))]\n-        fn get_err(errno: i32) -> (IoErrorKind, &'static str) {\n-            // FIXME: this should probably be a bit more descriptive...\n-            match errno {\n-                libc::EOF => (EndOfFile, \"end of file\"),\n-                libc::ECONNREFUSED => (ConnectionRefused, \"connection refused\"),\n-                libc::ECONNRESET => (ConnectionReset, \"connection reset\"),\n-                libc::EPERM | libc::EACCES =>\n-                    (PermissionDenied, \"permission denied\"),\n-                libc::EPIPE => (BrokenPipe, \"broken pipe\"),\n-                libc::ENOTCONN => (NotConnected, \"not connected\"),\n-                libc::ECONNABORTED => (ConnectionAborted, \"connection aborted\"),\n-                libc::EADDRNOTAVAIL => (ConnectionRefused, \"address not available\"),\n-                libc::EADDRINUSE => (ConnectionRefused, \"address in use\"),\n-                libc::ENOENT => (FileNotFound, \"no such file or directory\"),\n-                libc::EISDIR => (InvalidInput, \"illegal operation on a directory\"),\n-                libc::ENOSYS => (IoUnavailable, \"function not implemented\"),\n-                libc::EINVAL => (InvalidInput, \"invalid argument\"),\n-                libc::ENOTTY =>\n-                    (MismatchedFileTypeForOperation,\n-                     \"file descriptor is not a TTY\"),\n-                libc::ETIMEDOUT => (TimedOut, \"operation timed out\"),\n-                libc::ECANCELED => (TimedOut, \"operation aborted\"),\n-\n-                // These two constants can have the same value on some systems,\n-                // but different values on others, so we can't use a match\n-                // clause\n-                x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n-                    (ResourceUnavailable, \"resource temporarily unavailable\"),\n-\n-                _ => (OtherIoError, \"unknown error\")\n-            }\n-        }\n-\n-        let (kind, desc) = get_err(errno as i32);\n-        IoError {\n-            kind: kind,\n-            desc: desc,\n-            detail: if detail && kind == OtherIoError {\n-                Some(os::error_string(errno).as_slice().chars().map(|c| c.to_lowercase()).collect())\n-            } else {\n-                None\n-            },\n+        let mut err = sys::decode_error(errno as i32);\n+        if detail && err.kind == OtherIoError {\n+            err.detail = Some(os::error_string(errno).as_slice().chars()\n+                                 .map(|c| c.to_lowercase()).collect())\n         }\n+        err\n     }\n \n     /// Retrieve the last error to occur as a (detailed) IoError.\n@@ -409,17 +328,6 @@ impl IoError {\n     pub fn last_error() -> IoError {\n         IoError::from_errno(os::errno() as uint, true)\n     }\n-\n-    fn from_rtio_error(err: rtio::IoError) -> IoError {\n-        let rtio::IoError { code, extra, detail } = err;\n-        let mut ioerr = IoError::from_errno(code, false);\n-        ioerr.detail = detail;\n-        ioerr.kind = match ioerr.kind {\n-            TimedOut if extra > 0 => ShortWrite(extra),\n-            k => k,\n-        };\n-        return ioerr;\n-    }\n }\n \n impl fmt::Show for IoError {"}, {"sha": "22775d54eff1bbd1e1f85af789d69206468d29d0", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -20,12 +20,10 @@ getaddrinfo()\n #![allow(missing_docs)]\n \n use iter::Iterator;\n-use io::{IoResult, IoError};\n+use io::{IoResult};\n use io::net::ip::{SocketAddr, IpAddr};\n use option::{Option, Some, None};\n-use result::{Ok, Err};\n-use rt::rtio::{IoFactory, LocalIo};\n-use rt::rtio;\n+use sys;\n use vec::Vec;\n \n /// Hints to the types of sockets that are desired when looking up hosts\n@@ -94,31 +92,7 @@ pub fn get_host_addresses(host: &str) -> IoResult<Vec<IpAddr>> {\n #[allow(unused_variables)]\n fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n           -> IoResult<Vec<Info>> {\n-    let hint = hint.map(|Hint { family, socktype, protocol, flags }| {\n-        rtio::AddrinfoHint {\n-            family: family,\n-            socktype: 0, // FIXME: this should use the above variable\n-            protocol: 0, // FIXME: this should use the above variable\n-            flags: flags,\n-        }\n-    });\n-    match LocalIo::maybe_raise(|io| {\n-        io.get_host_addresses(hostname, servname, hint)\n-    }) {\n-        Ok(v) => Ok(v.into_iter().map(|info| {\n-            Info {\n-                address: SocketAddr {\n-                    ip: super::from_rtio(info.address.ip),\n-                    port: info.address.port,\n-                },\n-                family: info.family,\n-                socktype: None, // FIXME: this should use the above variable\n-                protocol: None, // FIXME: this should use the above variable\n-                flags: info.flags,\n-            }\n-        }).collect()),\n-        Err(e) => Err(IoError::from_rtio_error(e)),\n-    }\n+    sys::addrinfo::get_host_addresses(hostname, servname, hint)\n }\n \n // Ignored on android since we cannot give tcp/ip"}, {"sha": "5b1747876d7e0c537226ad6b5c6db166269a6dbf", "filename": "src/libstd/io/net/mod.rs", "status": "modified", "additions": 2, "deletions": 43, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fmod.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -12,9 +12,8 @@\n \n use io::{IoError, IoResult, InvalidInput};\n use option::None;\n-use result::{Result, Ok, Err};\n-use rt::rtio;\n-use self::ip::{Ipv4Addr, Ipv6Addr, IpAddr, SocketAddr, ToSocketAddr};\n+use result::{Ok, Err};\n+use self::ip::{SocketAddr, ToSocketAddr};\n \n pub use self::addrinfo::get_host_addresses;\n \n@@ -24,46 +23,6 @@ pub mod udp;\n pub mod ip;\n pub mod pipe;\n \n-fn to_rtio(ip: IpAddr) -> rtio::IpAddr {\n-    match ip {\n-        Ipv4Addr(a, b, c, d) => rtio::Ipv4Addr(a, b, c, d),\n-        Ipv6Addr(a, b, c, d, e, f, g, h) => {\n-            rtio::Ipv6Addr(a, b, c, d, e, f, g, h)\n-        }\n-    }\n-}\n-\n-fn from_rtio(ip: rtio::IpAddr) -> IpAddr {\n-    match ip {\n-        rtio::Ipv4Addr(a, b, c, d) => Ipv4Addr(a, b, c, d),\n-        rtio::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n-            Ipv6Addr(a, b, c, d, e, f, g, h)\n-        }\n-    }\n-}\n-\n-fn with_addresses_io<A: ToSocketAddr, T>(\n-    addr: A,\n-    action: |&mut rtio::IoFactory, rtio::SocketAddr| -> Result<T, rtio::IoError>\n-) -> Result<T, IoError> {\n-    const DEFAULT_ERROR: IoError = IoError {\n-        kind: InvalidInput,\n-        desc: \"no addresses found for hostname\",\n-        detail: None\n-    };\n-\n-    let addresses = try!(addr.to_socket_addr_all());\n-    let mut err = DEFAULT_ERROR;\n-    for addr in addresses.into_iter() {\n-        let addr = rtio::SocketAddr { ip: to_rtio(addr.ip), port: addr.port };\n-        match rtio::LocalIo::maybe_raise(|io| action(io, addr)) {\n-            Ok(r) => return Ok(r),\n-            Err(e) => err = IoError::from_rtio_error(e)\n-        }\n-    }\n-    Err(err)\n-}\n-\n fn with_addresses<A: ToSocketAddr, T>(addr: A, action: |SocketAddr| -> IoResult<T>)\n     -> IoResult<T> {\n     const DEFAULT_ERROR: IoError = IoError {"}, {"sha": "111b0f2b081fc8f4b79cb7beaee75104396d9b40", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -26,17 +26,20 @@ instances as clients.\n \n use prelude::*;\n \n-use io::{Listener, Acceptor, IoResult, IoError, TimedOut, standard_error};\n-use rt::rtio::{IoFactory, LocalIo, RtioUnixListener};\n-use rt::rtio::{RtioUnixAcceptor, RtioPipe};\n+use io::{Listener, Acceptor, IoResult, TimedOut, standard_error};\n use time::Duration;\n \n+use sys::pipe::UnixStream as UnixStreamImp;\n+use sys::pipe::UnixListener as UnixListenerImp;\n+use sys::pipe::UnixAcceptor as UnixAcceptorImp;\n+\n /// A stream which communicates over a named pipe.\n pub struct UnixStream {\n-    obj: Box<RtioPipe + Send>,\n+    inner: UnixStreamImp,\n }\n \n impl UnixStream {\n+\n     /// Connect to a pipe named by `path`. This will attempt to open a\n     /// connection to the underlying socket.\n     ///\n@@ -53,9 +56,8 @@ impl UnixStream {\n     /// stream.write([1, 2, 3]);\n     /// ```\n     pub fn connect<P: ToCStr>(path: &P) -> IoResult<UnixStream> {\n-        LocalIo::maybe_raise(|io| {\n-            io.unix_connect(&path.to_c_str(), None).map(|p| UnixStream { obj: p })\n-        }).map_err(IoError::from_rtio_error)\n+        UnixStreamImp::connect(&path.to_c_str(), None)\n+            .map(|inner| UnixStream { inner: inner })\n     }\n \n     /// Connect to a pipe named by `path`, timing out if the specified number of\n@@ -73,10 +75,8 @@ impl UnixStream {\n             return Err(standard_error(TimedOut));\n         }\n \n-        LocalIo::maybe_raise(|io| {\n-            let s = io.unix_connect(&path.to_c_str(), Some(timeout.num_milliseconds() as u64));\n-            s.map(|p| UnixStream { obj: p })\n-        }).map_err(IoError::from_rtio_error)\n+        UnixStreamImp::connect(&path.to_c_str(), Some(timeout.num_milliseconds() as u64))\n+            .map(|inner| UnixStream { inner: inner })\n     }\n \n \n@@ -88,7 +88,7 @@ impl UnixStream {\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n     pub fn close_read(&mut self) -> IoResult<()> {\n-        self.obj.close_read().map_err(IoError::from_rtio_error)\n+        self.inner.close_read()\n     }\n \n     /// Closes the writing half of this connection.\n@@ -99,60 +99,59 @@ impl UnixStream {\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n     pub fn close_write(&mut self) -> IoResult<()> {\n-        self.obj.close_write().map_err(IoError::from_rtio_error)\n+        self.inner.close_write()\n     }\n \n     /// Sets the read/write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_timeout(timeout_ms)\n+        self.inner.set_timeout(timeout_ms)\n     }\n \n     /// Sets the read timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_read_timeout(timeout_ms)\n+        self.inner.set_read_timeout(timeout_ms)\n     }\n \n     /// Sets the write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_write_timeout(timeout_ms)\n+        self.inner.set_write_timeout(timeout_ms)\n     }\n }\n \n impl Clone for UnixStream {\n     fn clone(&self) -> UnixStream {\n-        UnixStream { obj: self.obj.clone() }\n+        UnixStream { inner: self.inner.clone() }\n     }\n }\n \n impl Reader for UnixStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.obj.read(buf).map_err(IoError::from_rtio_error)\n+        self.inner.read(buf)\n     }\n }\n \n impl Writer for UnixStream {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.obj.write(buf).map_err(IoError::from_rtio_error)\n+        self.inner.write(buf)\n     }\n }\n \n /// A value that can listen for incoming named pipe connection requests.\n pub struct UnixListener {\n     /// The internal, opaque runtime Unix listener.\n-    obj: Box<RtioUnixListener + Send>,\n+    inner: UnixListenerImp,\n }\n \n impl UnixListener {\n-\n     /// Creates a new listener, ready to receive incoming connections on the\n     /// specified socket. The server will be named by `path`.\n     ///\n@@ -175,24 +174,22 @@ impl UnixListener {\n     /// # }\n     /// ```\n     pub fn bind<P: ToCStr>(path: &P) -> IoResult<UnixListener> {\n-        LocalIo::maybe_raise(|io| {\n-            io.unix_bind(&path.to_c_str()).map(|s| UnixListener { obj: s })\n-        }).map_err(IoError::from_rtio_error)\n+        UnixListenerImp::bind(&path.to_c_str())\n+            .map(|inner| UnixListener { inner: inner })\n     }\n }\n \n impl Listener<UnixStream, UnixAcceptor> for UnixListener {\n     fn listen(self) -> IoResult<UnixAcceptor> {\n-        self.obj.listen().map(|obj| {\n-            UnixAcceptor { obj: obj }\n-        }).map_err(IoError::from_rtio_error)\n+        self.inner.listen()\n+            .map(|inner| UnixAcceptor { inner: inner })\n     }\n }\n \n /// A value that can accept named pipe connections, returned from `listen()`.\n pub struct UnixAcceptor {\n     /// The internal, opaque runtime Unix acceptor.\n-    obj: Box<RtioUnixAcceptor + Send>,\n+    inner: UnixAcceptorImp\n }\n \n impl UnixAcceptor {\n@@ -210,7 +207,7 @@ impl UnixAcceptor {\n     #[experimental = \"the name and arguments to this function are likely \\\n                       to change\"]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_timeout(timeout_ms)\n+        self.inner.set_timeout(timeout_ms)\n     }\n \n     /// Closes the accepting capabilities of this acceptor.\n@@ -219,15 +216,15 @@ impl UnixAcceptor {\n     /// more information can be found in that documentation.\n     #[experimental]\n     pub fn close_accept(&mut self) -> IoResult<()> {\n-        self.obj.close_accept().map_err(IoError::from_rtio_error)\n+        self.inner.close_accept()\n     }\n }\n \n impl Acceptor<UnixStream> for UnixAcceptor {\n     fn accept(&mut self) -> IoResult<UnixStream> {\n-        self.obj.accept().map(|s| {\n-            UnixStream { obj: s }\n-        }).map_err(IoError::from_rtio_error)\n+        self.inner.accept().map(|s| {\n+            UnixStream { inner: s }\n+        })\n     }\n }\n \n@@ -246,7 +243,7 @@ impl Clone for UnixAcceptor {\n     /// This function is useful for creating a handle to invoke `close_accept`\n     /// on to wake up any other task blocked in `accept`.\n     fn clone(&self) -> UnixAcceptor {\n-        UnixAcceptor { obj: self.obj.clone() }\n+        UnixAcceptor { inner: self.inner.clone() }\n     }\n }\n "}, {"sha": "2545e07cbb5c2bd1dddbbe5a3697502abeb1ffdd", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 39, "deletions": 66, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -20,19 +20,17 @@\n use clone::Clone;\n use io::IoResult;\n use iter::Iterator;\n-use result::{Ok,Err};\n+use result::Err;\n use io::net::ip::{SocketAddr, ToSocketAddr};\n-use io::IoError;\n use io::{Reader, Writer, Listener, Acceptor};\n use io::{standard_error, TimedOut};\n-use kinds::Send;\n use option::{None, Some, Option};\n-use boxed::Box;\n-use rt::rtio::{IoFactory, RtioSocket, RtioTcpListener};\n-use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n-use rt::rtio;\n use time::Duration;\n \n+use sys::tcp::TcpStream as TcpStreamImp;\n+use sys::tcp::TcpListener as TcpListenerImp;\n+use sys::tcp::TcpAcceptor as TcpAcceptorImp;\n+\n /// A structure which represents a TCP stream between a local socket and a\n /// remote socket.\n ///\n@@ -50,12 +48,12 @@ use time::Duration;\n /// drop(stream); // close the connection\n /// ```\n pub struct TcpStream {\n-    obj: Box<RtioTcpStream + Send>,\n+    inner: TcpStreamImp,\n }\n \n impl TcpStream {\n-    fn new(s: Box<RtioTcpStream + Send>) -> TcpStream {\n-        TcpStream { obj: s }\n+    fn new(s: TcpStreamImp) -> TcpStream {\n+        TcpStream { inner: s }\n     }\n \n     /// Open a TCP connection to a remote host.\n@@ -64,7 +62,9 @@ impl TcpStream {\n     /// trait can be supplied for the address; see this trait documentation for\n     /// concrete examples.\n     pub fn connect<A: ToSocketAddr>(addr: A) -> IoResult<TcpStream> {\n-        super::with_addresses_io(addr, |io, addr| io.tcp_connect(addr, None).map(TcpStream::new))\n+        super::with_addresses(addr, |addr| {\n+            TcpStreamImp::connect(addr, None).map(TcpStream::new)\n+        })\n     }\n \n     /// Creates a TCP connection to a remote socket address, timing out after\n@@ -86,39 +86,26 @@ impl TcpStream {\n             return Err(standard_error(TimedOut));\n         }\n \n-        super::with_addresses_io(addr, |io, addr|\n-            io.tcp_connect(addr, Some(timeout.num_milliseconds() as u64)).map(TcpStream::new)\n-        )\n+        super::with_addresses(addr, |addr| {\n+            TcpStreamImp::connect(addr, Some(timeout.num_milliseconds() as u64))\n+                .map(TcpStream::new)\n+        })\n     }\n \n     /// Returns the socket address of the remote peer of this TCP connection.\n     pub fn peer_name(&mut self) -> IoResult<SocketAddr> {\n-        match self.obj.peer_name() {\n-            Ok(rtio::SocketAddr { ip, port }) => {\n-                Ok(SocketAddr { ip: super::from_rtio(ip), port: port })\n-            }\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n-        }\n+        self.inner.peer_name()\n     }\n \n     /// Returns the socket address of the local half of this TCP connection.\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        match self.obj.socket_name() {\n-            Ok(rtio::SocketAddr { ip, port }) => {\n-                Ok(SocketAddr { ip: super::from_rtio(ip), port: port })\n-            }\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n-        }\n+        self.inner.socket_name()\n     }\n \n     /// Sets the nodelay flag on this connection to the boolean specified\n     #[experimental]\n     pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n-        if nodelay {\n-            self.obj.nodelay()\n-        } else {\n-            self.obj.control_congestion()\n-        }.map_err(IoError::from_rtio_error)\n+        self.inner.set_nodelay(nodelay)\n     }\n \n     /// Sets the keepalive timeout to the timeout specified.\n@@ -128,10 +115,7 @@ impl TcpStream {\n     /// specified time, in seconds.\n     #[experimental]\n     pub fn set_keepalive(&mut self, delay_in_seconds: Option<uint>) -> IoResult<()> {\n-        match delay_in_seconds {\n-            Some(i) => self.obj.keepalive(i),\n-            None => self.obj.letdie(),\n-        }.map_err(IoError::from_rtio_error)\n+        self.inner.set_keepalive(delay_in_seconds)\n     }\n \n     /// Closes the reading half of this connection.\n@@ -165,7 +149,7 @@ impl TcpStream {\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n     pub fn close_read(&mut self) -> IoResult<()> {\n-        self.obj.close_read().map_err(IoError::from_rtio_error)\n+        self.inner.close_read()\n     }\n \n     /// Closes the writing half of this connection.\n@@ -176,7 +160,7 @@ impl TcpStream {\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n     pub fn close_write(&mut self) -> IoResult<()> {\n-        self.obj.close_write().map_err(IoError::from_rtio_error)\n+        self.inner.close_write()\n     }\n \n     /// Sets a timeout, in milliseconds, for blocking operations on this stream.\n@@ -198,7 +182,7 @@ impl TcpStream {\n     /// take a look at `set_read_timeout` and `set_write_timeout`.\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_timeout(timeout_ms)\n+        self.inner.set_timeout(timeout_ms)\n     }\n \n     /// Sets the timeout for read operations on this stream.\n@@ -215,7 +199,7 @@ impl TcpStream {\n     /// during the timeout period.\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_read_timeout(timeout_ms)\n+        self.inner.set_read_timeout(timeout_ms)\n     }\n \n     /// Sets the timeout for write operations on this stream.\n@@ -242,7 +226,7 @@ impl TcpStream {\n     /// asynchronous fashion after the call to write returns.\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_write_timeout(timeout_ms)\n+        self.inner.set_write_timeout(timeout_ms)\n     }\n }\n \n@@ -256,19 +240,19 @@ impl Clone for TcpStream {\n     /// Instead, the first read will receive the first packet received, and the\n     /// second read will receive the second packet.\n     fn clone(&self) -> TcpStream {\n-        TcpStream { obj: self.obj.clone() }\n+        TcpStream { inner: self.inner.clone() }\n     }\n }\n \n impl Reader for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.obj.read(buf).map_err(IoError::from_rtio_error)\n+        self.inner.read(buf)\n     }\n }\n \n impl Writer for TcpStream {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.obj.write(buf).map_err(IoError::from_rtio_error)\n+        self.inner.write(buf)\n     }\n }\n \n@@ -309,7 +293,7 @@ impl Writer for TcpStream {\n /// # }\n /// ```\n pub struct TcpListener {\n-    obj: Box<RtioTcpListener + Send>,\n+    inner: TcpListenerImp,\n }\n \n impl TcpListener {\n@@ -324,34 +308,28 @@ impl TcpListener {\n     /// The address type can be any implementor of `ToSocketAddr` trait. See its\n     /// documentation for concrete examples.\n     pub fn bind<A: ToSocketAddr>(addr: A) -> IoResult<TcpListener> {\n-        super::with_addresses_io(addr, |io, addr| io.tcp_bind(addr).map(|l| TcpListener { obj: l }))\n+        super::with_addresses(addr, |addr| {\n+            TcpListenerImp::bind(addr).map(|inner| TcpListener { inner: inner })\n+        })\n     }\n \n     /// Returns the local socket address of this listener.\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        match self.obj.socket_name() {\n-            Ok(rtio::SocketAddr { ip, port }) => {\n-                Ok(SocketAddr { ip: super::from_rtio(ip), port: port })\n-            }\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n-        }\n+        self.inner.socket_name()\n     }\n }\n \n impl Listener<TcpStream, TcpAcceptor> for TcpListener {\n     fn listen(self) -> IoResult<TcpAcceptor> {\n-        match self.obj.listen() {\n-            Ok(acceptor) => Ok(TcpAcceptor { obj: acceptor }),\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n-        }\n+        self.inner.listen(128).map(|a| TcpAcceptor { inner: a })\n     }\n }\n \n /// The accepting half of a TCP socket server. This structure is created through\n /// a `TcpListener`'s `listen` method, and this object can be used to accept new\n /// `TcpStream` instances.\n pub struct TcpAcceptor {\n-    obj: Box<RtioTcpAcceptor + Send>,\n+    inner: TcpAcceptorImp,\n }\n \n impl TcpAcceptor {\n@@ -399,7 +377,7 @@ impl TcpAcceptor {\n     /// ```\n     #[experimental = \"the type of the argument and name of this function are \\\n                       subject to change\"]\n-    pub fn set_timeout(&mut self, ms: Option<u64>) { self.obj.set_timeout(ms); }\n+    pub fn set_timeout(&mut self, ms: Option<u64>) { self.inner.set_timeout(ms); }\n \n     /// Closes the accepting capabilities of this acceptor.\n     ///\n@@ -445,16 +423,13 @@ impl TcpAcceptor {\n     /// ```\n     #[experimental]\n     pub fn close_accept(&mut self) -> IoResult<()> {\n-        self.obj.close_accept().map_err(IoError::from_rtio_error)\n+        self.inner.close_accept()\n     }\n }\n \n impl Acceptor<TcpStream> for TcpAcceptor {\n     fn accept(&mut self) -> IoResult<TcpStream> {\n-        match self.obj.accept(){\n-            Ok(s) => Ok(TcpStream::new(s)),\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n-        }\n+        self.inner.accept().map(TcpStream::new)\n     }\n }\n \n@@ -473,7 +448,7 @@ impl Clone for TcpAcceptor {\n     /// This function is useful for creating a handle to invoke `close_accept`\n     /// on to wake up any other task blocked in `accept`.\n     fn clone(&self) -> TcpAcceptor {\n-        TcpAcceptor { obj: self.obj.clone() }\n+        TcpAcceptor { inner: self.inner.clone() }\n     }\n }\n \n@@ -1112,8 +1087,6 @@ mod test {\n \n     #[test]\n     fn shutdown_smoke() {\n-        use rt::rtio::RtioTcpStream;\n-\n         let addr = next_test_ip4();\n         let a = TcpListener::bind(addr).unwrap().listen();\n         spawn(proc() {\n@@ -1124,7 +1097,7 @@ mod test {\n         });\n \n         let mut s = TcpStream::connect(addr).unwrap();\n-        assert!(s.obj.close_write().is_ok());\n+        assert!(s.inner.close_write().is_ok());\n         assert!(s.write([1]).is_err());\n         assert_eq!(s.read_to_end(), Ok(vec!(1)));\n     }"}, {"sha": "31b619896479b67e4dc03adb625d93b2b2973e12", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 19, "deletions": 41, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -17,13 +17,10 @@\n \n use clone::Clone;\n use io::net::ip::{SocketAddr, IpAddr, ToSocketAddr};\n-use io::{Reader, Writer, IoResult, IoError};\n-use kinds::Send;\n-use boxed::Box;\n+use io::{Reader, Writer, IoResult};\n use option::Option;\n use result::{Ok, Err};\n-use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory};\n-use rt::rtio;\n+use sys::udp::UdpSocket as UdpSocketImp;\n \n /// A User Datagram Protocol socket.\n ///\n@@ -60,7 +57,7 @@ use rt::rtio;\n /// }\n /// ```\n pub struct UdpSocket {\n-    obj: Box<RtioUdpSocket + Send>,\n+    inner: UdpSocketImp,\n }\n \n impl UdpSocket {\n@@ -69,18 +66,15 @@ impl UdpSocket {\n     /// Address type can be any implementor of `ToSocketAddr` trait. See its\n     /// documentation for concrete examples.\n     pub fn bind<A: ToSocketAddr>(addr: A) -> IoResult<UdpSocket> {\n-        super::with_addresses_io(addr, |io, addr| io.udp_bind(addr).map(|s| UdpSocket { obj: s }))\n+        super::with_addresses(addr, |addr| {\n+            UdpSocketImp::bind(addr).map(|s| UdpSocket { inner: s })\n+        })\n     }\n \n     /// Receives data from the socket. On success, returns the number of bytes\n     /// read and the address from whence the data came.\n     pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)> {\n-        match self.obj.recv_from(buf) {\n-            Ok((amt, rtio::SocketAddr { ip, port })) => {\n-                Ok((amt, SocketAddr { ip: super::from_rtio(ip), port: port }))\n-            }\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n-        }\n+        self.inner.recv_from(buf)\n     }\n \n     /// Sends data on the socket to the given address. Returns nothing on\n@@ -89,10 +83,7 @@ impl UdpSocket {\n     /// Address type can be any implementor of `ToSocketAddr` trait. See its\n     /// documentation for concrete examples.\n     pub fn send_to<A: ToSocketAddr>(&mut self, buf: &[u8], addr: A) -> IoResult<()> {\n-        super::with_addresses(addr, |addr| self.obj.send_to(buf, rtio::SocketAddr {\n-            ip: super::to_rtio(addr.ip),\n-            port: addr.port,\n-        }).map_err(IoError::from_rtio_error))\n+        super::with_addresses(addr, |addr| self.inner.send_to(buf, addr))\n     }\n \n     /// Creates a `UdpStream`, which allows use of the `Reader` and `Writer`\n@@ -112,82 +103,69 @@ impl UdpSocket {\n \n     /// Returns the socket address that this socket was created from.\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        match self.obj.socket_name() {\n-            Ok(a) => Ok(SocketAddr { ip: super::from_rtio(a.ip), port: a.port }),\n-            Err(e) => Err(IoError::from_rtio_error(e))\n-        }\n+        self.inner.socket_name()\n     }\n \n     /// Joins a multicast IP address (becomes a member of it)\n     #[experimental]\n     pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        let e = self.obj.join_multicast(super::to_rtio(multi));\n-        e.map_err(IoError::from_rtio_error)\n+        self.inner.join_multicast(multi)\n     }\n \n     /// Leaves a multicast IP address (drops membership from it)\n     #[experimental]\n     pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        let e = self.obj.leave_multicast(super::to_rtio(multi));\n-        e.map_err(IoError::from_rtio_error)\n+        self.inner.leave_multicast(multi)\n     }\n \n     /// Set the multicast loop flag to the specified value\n     ///\n     /// This lets multicast packets loop back to local sockets (if enabled)\n     #[experimental]\n     pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> {\n-        if on {\n-            self.obj.loop_multicast_locally()\n-        } else {\n-            self.obj.dont_loop_multicast_locally()\n-        }.map_err(IoError::from_rtio_error)\n+        self.inner.set_multicast_loop(on)\n     }\n \n     /// Sets the multicast TTL\n     #[experimental]\n     pub fn set_multicast_ttl(&mut self, ttl: int) -> IoResult<()> {\n-        self.obj.multicast_time_to_live(ttl).map_err(IoError::from_rtio_error)\n+        self.inner.multicast_time_to_live(ttl)\n     }\n \n     /// Sets this socket's TTL\n     #[experimental]\n     pub fn set_ttl(&mut self, ttl: int) -> IoResult<()> {\n-        self.obj.time_to_live(ttl).map_err(IoError::from_rtio_error)\n+        self.inner.time_to_live(ttl)\n     }\n \n     /// Sets the broadcast flag on or off\n     #[experimental]\n     pub fn set_broadcast(&mut self, broadcast: bool) -> IoResult<()> {\n-        if broadcast {\n-            self.obj.hear_broadcasts()\n-        } else {\n-            self.obj.ignore_broadcasts()\n-        }.map_err(IoError::from_rtio_error)\n+        self.inner.set_broadcast(broadcast)\n     }\n \n     /// Sets the read/write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_timeout(timeout_ms)\n+        self.inner.set_timeout(timeout_ms)\n     }\n \n     /// Sets the read timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_read_timeout(timeout_ms)\n+        self.inner.set_read_timeout(timeout_ms)\n     }\n \n     /// Sets the write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_write_timeout(timeout_ms)\n+        self.inner.set_write_timeout(timeout_ms)\n     }\n }\n \n@@ -201,7 +179,7 @@ impl Clone for UdpSocket {\n     /// received, and the second read will receive the second packet.\n     fn clone(&self) -> UdpSocket {\n         UdpSocket {\n-            obj: self.obj.clone(),\n+            inner: self.inner.clone(),\n         }\n     }\n }"}, {"sha": "64b2518fab1c5a841371c77a569ab99087339912", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -17,15 +17,17 @@\n \n use prelude::*;\n \n-use io::{IoResult, IoError};\n+use io::IoResult;\n use libc;\n-use os;\n-use rt::rtio::{RtioPipe, LocalIo};\n+use sync::Arc;\n+\n+use sys_common;\n+use sys;\n+use sys::fs::FileDesc as FileDesc;\n \n /// A synchronous, in-memory pipe.\n pub struct PipeStream {\n-    /// The internal, opaque runtime pipe object.\n-    obj: Box<RtioPipe + Send>,\n+    inner: Arc<FileDesc>\n }\n \n pub struct PipePair {\n@@ -55,14 +57,14 @@ impl PipeStream {\n     /// }\n     /// ```\n     pub fn open(fd: libc::c_int) -> IoResult<PipeStream> {\n-        LocalIo::maybe_raise(|io| {\n-            io.pipe_open(fd).map(|obj| PipeStream { obj: obj })\n-        }).map_err(IoError::from_rtio_error)\n+        Ok(PipeStream::from_filedesc(FileDesc::new(fd, true)))\n     }\n \n+    // FIXME: expose this some other way\n+    /// Wrap a FileDesc directly, taking ownership.\n     #[doc(hidden)]\n-    pub fn new(inner: Box<RtioPipe + Send>) -> PipeStream {\n-        PipeStream { obj: inner }\n+    pub fn from_filedesc(fd: FileDesc) -> PipeStream {\n+        PipeStream { inner: Arc::new(fd) }\n     }\n \n     /// Creates a pair of in-memory OS pipes for a unidirectional communication\n@@ -76,43 +78,35 @@ impl PipeStream {\n     /// This function can fail to succeed if the underlying OS has run out of\n     /// available resources to allocate a new pipe.\n     pub fn pair() -> IoResult<PipePair> {\n-        struct Closer { fd: libc::c_int }\n-\n-        let os::Pipe { reader, writer } = try!(unsafe { os::pipe() });\n-        let mut reader = Closer { fd: reader };\n-        let mut writer = Closer { fd: writer };\n-\n-        let io_reader = try!(PipeStream::open(reader.fd));\n-        reader.fd = -1;\n-        let io_writer = try!(PipeStream::open(writer.fd));\n-        writer.fd = -1;\n-        return Ok(PipePair { reader: io_reader, writer: io_writer });\n-\n-        impl Drop for Closer {\n-            fn drop(&mut self) {\n-                if self.fd != -1 {\n-                    let _ = unsafe { libc::close(self.fd) };\n-                }\n-            }\n-        }\n+        let (reader, writer) = try!(unsafe { sys::os::pipe() });\n+        Ok(PipePair {\n+            reader: PipeStream::from_filedesc(reader),\n+            writer: PipeStream::from_filedesc(writer),\n+        })\n+    }\n+}\n+\n+impl sys_common::AsFileDesc for PipeStream {\n+    fn as_fd(&self) -> &sys::fs::FileDesc {\n+        &*self.inner\n     }\n }\n \n impl Clone for PipeStream {\n     fn clone(&self) -> PipeStream {\n-        PipeStream { obj: self.obj.clone() }\n+        PipeStream { inner: self.inner.clone() }\n     }\n }\n \n impl Reader for PipeStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.obj.read(buf).map_err(IoError::from_rtio_error)\n+        self.inner.read(buf)\n     }\n }\n \n impl Writer for PipeStream {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.obj.write(buf).map_err(IoError::from_rtio_error)\n+        self.inner.write(buf)\n     }\n }\n "}, {"sha": "d71bab0b48f90724471b02becf21398a06dc530c", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 150, "deletions": 78, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -20,14 +20,17 @@ use os;\n use io::{IoResult, IoError};\n use io;\n use libc;\n-use mem;\n-use rt::rtio::{RtioProcess, ProcessConfig, IoFactory, LocalIo};\n-use rt::rtio;\n use c_str::CString;\n use collections::HashMap;\n use hash::Hash;\n #[cfg(windows)]\n use std::hash::sip::SipState;\n+use io::pipe::{PipeStream, PipePair};\n+use path::BytesContainer;\n+\n+use sys;\n+use sys::fs::FileDesc;\n+use sys::process::Process as ProcessImp;\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n /// SIGTERM on unix platforms.\n@@ -62,24 +65,29 @@ use std::hash::sip::SipState;\n /// assert!(child.wait().unwrap().success());\n /// ```\n pub struct Process {\n-    handle: Box<RtioProcess + Send>,\n+    handle: ProcessImp,\n     forget: bool,\n \n+    /// None until wait() is called.\n+    exit_code: Option<ProcessExit>,\n+\n+    /// Manually delivered signal\n+    exit_signal: Option<int>,\n+\n+    /// Deadline after which wait() will return\n+    deadline: u64,\n+\n     /// Handle to the child's stdin, if the `stdin` field of this process's\n     /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.\n-    pub stdin: Option<io::PipeStream>,\n+    pub stdin: Option<PipeStream>,\n \n     /// Handle to the child's stdout, if the `stdout` field of this process's\n     /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.\n-    pub stdout: Option<io::PipeStream>,\n+    pub stdout: Option<PipeStream>,\n \n     /// Handle to the child's stderr, if the `stderr` field of this process's\n     /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.\n-    pub stderr: Option<io::PipeStream>,\n-\n-    /// Extra I/O handles as configured by the original `ProcessConfig` when\n-    /// this process was created. This is by default empty.\n-    pub extra_io: Vec<Option<io::PipeStream>>,\n+    pub stderr: Option<PipeStream>,\n }\n \n /// A representation of environment variable name\n@@ -130,6 +138,13 @@ impl PartialEq for EnvKey {\n     }\n }\n \n+impl BytesContainer for EnvKey {\n+    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n+        let &EnvKey(ref k) = self;\n+        k.container_as_bytes()\n+    }\n+}\n+\n /// A HashMap representation of environment variables.\n pub type EnvMap = HashMap<EnvKey, CString>;\n \n@@ -160,7 +175,6 @@ pub struct Command {\n     stdin: StdioContainer,\n     stdout: StdioContainer,\n     stderr: StdioContainer,\n-    extra_io: Vec<StdioContainer>,\n     uid: Option<uint>,\n     gid: Option<uint>,\n     detach: bool,\n@@ -194,7 +208,6 @@ impl Command {\n             stdin: CreatePipe(true, false),\n             stdout: CreatePipe(false, true),\n             stderr: CreatePipe(false, true),\n-            extra_io: Vec::new(),\n             uid: None,\n             gid: None,\n             detach: false,\n@@ -281,14 +294,6 @@ impl Command {\n         self.stderr = cfg;\n         self\n     }\n-    /// Attaches a stream/file descriptor/pipe to the child process. Inherited\n-    /// file descriptors are numbered consecutively, starting at 3; the first\n-    /// three file descriptors (stdin/stdout/stderr) are configured with the\n-    /// `stdin`, `stdout`, and `stderr` methods.\n-    pub fn extra_io<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command {\n-        self.extra_io.push(cfg);\n-        self\n-    }\n \n     /// Sets the child process's user id. This translates to a `setuid` call in\n     /// the child process. Setting this value on windows will cause the spawn to\n@@ -315,50 +320,23 @@ impl Command {\n \n     /// Executes the command as a child process, which is returned.\n     pub fn spawn(&self) -> IoResult<Process> {\n-        fn to_rtio(p: StdioContainer) -> rtio::StdioContainer {\n-            match p {\n-                Ignored => rtio::Ignored,\n-                InheritFd(fd) => rtio::InheritFd(fd),\n-                CreatePipe(a, b) => rtio::CreatePipe(a, b),\n-            }\n-        }\n-        let extra_io: Vec<rtio::StdioContainer> =\n-            self.extra_io.iter().map(|x| to_rtio(*x)).collect();\n-        LocalIo::maybe_raise(|io| {\n-            let env = match self.env {\n-                None => None,\n-                Some(ref env_map) =>\n-                    Some(env_map.iter()\n-                                .map(|(&EnvKey(ref key), val)| (key, val))\n-                                .collect::<Vec<_>>())\n-            };\n-            let cfg = ProcessConfig {\n-                program: &self.program,\n-                args: self.args.as_slice(),\n-                env: env.as_ref().map(|e| e.as_slice()),\n-                cwd: self.cwd.as_ref(),\n-                stdin: to_rtio(self.stdin),\n-                stdout: to_rtio(self.stdout),\n-                stderr: to_rtio(self.stderr),\n-                extra_io: extra_io.as_slice(),\n-                uid: self.uid,\n-                gid: self.gid,\n-                detach: self.detach,\n-            };\n-            io.spawn(cfg).map(|(p, io)| {\n-                let mut io = io.into_iter().map(|p| {\n-                    p.map(|p| io::PipeStream::new(p))\n-                });\n-                Process {\n-                    handle: p,\n-                    forget: false,\n-                    stdin: io.next().unwrap(),\n-                    stdout: io.next().unwrap(),\n-                    stderr: io.next().unwrap(),\n-                    extra_io: io.collect(),\n-                }\n+        let (their_stdin, our_stdin) = try!(setup_io(self.stdin));\n+        let (their_stdout, our_stdout) = try!(setup_io(self.stdout));\n+        let (their_stderr, our_stderr) = try!(setup_io(self.stderr));\n+\n+        match ProcessImp::spawn(self, their_stdin, their_stdout, their_stderr) {\n+            Err(e) => Err(e),\n+            Ok(handle) => Ok(Process {\n+                handle: handle,\n+                forget: false,\n+                exit_code: None,\n+                exit_signal: None,\n+                deadline: 0,\n+                stdin: our_stdin,\n+                stdout: our_stdout,\n+                stderr: our_stderr,\n             })\n-        }).map_err(IoError::from_rtio_error)\n+        }\n     }\n \n     /// Executes the command as a child process, waiting for it to finish and\n@@ -415,6 +393,58 @@ impl fmt::Show for Command {\n     }\n }\n \n+fn setup_io(io: StdioContainer) -> IoResult<(Option<PipeStream>, Option<PipeStream>)> {\n+    let ours;\n+    let theirs;\n+    match io {\n+        Ignored => {\n+            theirs = None;\n+            ours = None;\n+        }\n+        InheritFd(fd) => {\n+            theirs = Some(PipeStream::from_filedesc(FileDesc::new(fd, false)));\n+            ours = None;\n+        }\n+        CreatePipe(readable, _writable) => {\n+            let PipePair { reader, writer } = try!(PipeStream::pair());\n+            if readable {\n+                theirs = Some(reader);\n+                ours = Some(writer);\n+            } else {\n+                theirs = Some(writer);\n+                ours = Some(reader);\n+            }\n+        }\n+    }\n+    Ok((theirs, ours))\n+}\n+\n+// Allow the sys module to get access to the Command state\n+impl sys::process::ProcessConfig<EnvKey, CString> for Command {\n+    fn program(&self) -> &CString {\n+        &self.program\n+    }\n+    fn args(&self) -> &[CString] {\n+        self.args.as_slice()\n+    }\n+    fn env(&self) -> Option<&EnvMap> {\n+        self.env.as_ref()\n+    }\n+    fn cwd(&self) -> Option<&CString> {\n+        self.cwd.as_ref()\n+    }\n+    fn uid(&self) -> Option<uint> {\n+        self.uid.clone()\n+    }\n+    fn gid(&self) -> Option<uint> {\n+        self.gid.clone()\n+    }\n+    fn detach(&self) -> bool {\n+        self.detach\n+    }\n+\n+}\n+\n /// The output of a finished process.\n #[deriving(PartialEq, Eq, Clone)]\n pub struct ProcessOutput {\n@@ -494,9 +524,7 @@ impl Process {\n     /// be successfully delivered if the child has exited, but not yet been\n     /// reaped.\n     pub fn kill(id: libc::pid_t, signal: int) -> IoResult<()> {\n-        LocalIo::maybe_raise(|io| {\n-            io.kill(id, signal)\n-        }).map_err(IoError::from_rtio_error)\n+        unsafe { ProcessImp::killpid(id, signal) }\n     }\n \n     /// Returns the process id of this child process\n@@ -518,7 +546,42 @@ impl Process {\n     ///\n     /// If the signal delivery fails, the corresponding error is returned.\n     pub fn signal(&mut self, signal: int) -> IoResult<()> {\n-        self.handle.kill(signal).map_err(IoError::from_rtio_error)\n+        #[cfg(unix)] fn collect_status(p: &mut Process) {\n+            // On Linux (and possibly other unices), a process that has exited will\n+            // continue to accept signals because it is \"defunct\". The delivery of\n+            // signals will only fail once the child has been reaped. For this\n+            // reason, if the process hasn't exited yet, then we attempt to collect\n+            // their status with WNOHANG.\n+            if p.exit_code.is_none() {\n+                match p.handle.try_wait() {\n+                    Some(code) => { p.exit_code = Some(code); }\n+                    None => {}\n+                }\n+            }\n+        }\n+        #[cfg(windows)] fn collect_status(_p: &mut Process) {}\n+\n+        collect_status(self);\n+\n+        // if the process has finished, and therefore had waitpid called,\n+        // and we kill it, then on unix we might ending up killing a\n+        // newer process that happens to have the same (re-used) id\n+        if self.exit_code.is_some() {\n+            return Err(IoError {\n+                kind: io::InvalidInput,\n+                desc: \"invalid argument: can't kill an exited process\",\n+                detail: None,\n+            })\n+        }\n+\n+        // A successfully delivered signal that isn't 0 (just a poll for being\n+        // alive) is recorded for windows (see wait())\n+        match unsafe { self.handle.kill(signal) } {\n+            Ok(()) if signal == 0 => Ok(()),\n+            Ok(()) => { self.exit_signal = Some(signal); Ok(()) }\n+            Err(e) => Err(e),\n+        }\n+\n     }\n \n     /// Sends a signal to this child requesting that it exits. This is\n@@ -545,10 +608,21 @@ impl Process {\n     /// `set_timeout` and the timeout expires before the child exits.\n     pub fn wait(&mut self) -> IoResult<ProcessExit> {\n         drop(self.stdin.take());\n-        match self.handle.wait() {\n-            Ok(rtio::ExitSignal(s)) => Ok(ExitSignal(s)),\n-            Ok(rtio::ExitStatus(s)) => Ok(ExitStatus(s)),\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n+        match self.exit_code {\n+            Some(code) => Ok(code),\n+            None => {\n+                let code = try!(self.handle.wait(self.deadline));\n+                // On windows, waitpid will never return a signal. If a signal\n+                // was successfully delivered to the process, however, we can\n+                // consider it as having died via a signal.\n+                let code = match self.exit_signal {\n+                    None => code,\n+                    Some(signal) if cfg!(windows) => ExitSignal(signal),\n+                    Some(..) => code,\n+                };\n+                self.exit_code = Some(code);\n+                Ok(code)\n+            }\n         }\n     }\n \n@@ -594,7 +668,7 @@ impl Process {\n     /// ```\n     #[experimental = \"the type of the timeout is likely to change\"]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.handle.set_timeout(timeout_ms)\n+        self.deadline = timeout_ms.map(|i| i + sys::timer::now()).unwrap_or(0);\n     }\n \n     /// Simultaneously wait for the child to exit and collect all remaining\n@@ -653,7 +727,6 @@ impl Drop for Process {\n         drop(self.stdin.take());\n         drop(self.stdout.take());\n         drop(self.stderr.take());\n-        drop(mem::replace(&mut self.extra_io, Vec::new()));\n \n         self.set_timeout(None);\n         let _ = self.wait().unwrap();\n@@ -1109,24 +1182,23 @@ mod tests {\n \n     #[test]\n     fn dont_close_fd_on_command_spawn() {\n-        use std::rt::rtio::{Truncate, Write};\n-        use self::native::io::file;\n+        use sys::fs;\n \n         let path = if cfg!(windows) {\n             Path::new(\"NUL\")\n         } else {\n             Path::new(\"/dev/null\")\n         };\n \n-        let mut fdes = match file::open(&path.to_c_str(), Truncate, Write) {\n+        let mut fdes = match fs::open(&path, Truncate, Write) {\n             Ok(f) => f,\n             Err(_) => panic!(\"failed to open file descriptor\"),\n         };\n \n         let mut cmd = pwd_cmd();\n         let _ = cmd.stdout(InheritFd(fdes.fd()));\n         assert!(cmd.status().unwrap().success());\n-        assert!(fdes.inner_write(\"extra write\\n\".as_bytes()).is_ok());\n+        assert!(fdes.write(\"extra write\\n\".as_bytes()).is_ok());\n     }\n \n     #[test]"}, {"sha": "158d596ea136bc13d619fb83bb127ab95784aedb", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -36,11 +36,11 @@ use kinds::Send;\n use libc;\n use option::{Option, Some, None};\n use boxed::Box;\n+use sys::{fs, tty};\n use result::{Ok, Err};\n use rt;\n use rt::local::Local;\n use rt::task::Task;\n-use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};\n use slice::SlicePrelude;\n use str::StrPrelude;\n use uint;\n@@ -74,17 +74,15 @@ use uint;\n // tl;dr; TTY works on everything but when windows stdout is redirected, in that\n //        case pipe also doesn't work, but magically file does!\n enum StdSource {\n-    TTY(Box<RtioTTY + Send>),\n-    File(Box<RtioFileStream + Send>),\n+    TTY(tty::TTY),\n+    File(fs::FileDesc),\n }\n \n-fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {\n-    LocalIo::maybe_raise(|io| {\n-        Ok(match io.tty_open(fd, readable) {\n-            Ok(tty) => f(TTY(tty)),\n-            Err(_) => f(File(io.fs_from_raw_fd(fd, DontClose))),\n-        })\n-    }).map_err(IoError::from_rtio_error).unwrap()\n+fn src<T>(fd: libc::c_int, _readable: bool, f: |StdSource| -> T) -> T {\n+    match tty::TTY::new(fd) {\n+        Ok(tty) => f(TTY(tty)),\n+        Err(_) => f(File(fs::FileDesc::new(fd, false))),\n+    }\n }\n \n local_data_key!(local_stdout: Box<Writer + Send>)\n@@ -278,10 +276,10 @@ impl Reader for StdReader {\n                 // print!'d prompt not being shown until after the user hits\n                 // enter.\n                 flush();\n-                tty.read(buf)\n+                tty.read(buf).map(|i| i as uint)\n             },\n             File(ref mut file) => file.read(buf).map(|i| i as uint),\n-        }.map_err(IoError::from_rtio_error);\n+        };\n         match ret {\n             // When reading a piped stdin, libuv will return 0-length reads when\n             // stdin reaches EOF. For pretty much all other streams it will\n@@ -313,7 +311,7 @@ impl StdWriter {\n     pub fn winsize(&mut self) -> IoResult<(int, int)> {\n         match self.inner {\n             TTY(ref mut tty) => {\n-                tty.get_winsize().map_err(IoError::from_rtio_error)\n+                tty.get_winsize()\n             }\n             File(..) => {\n                 Err(IoError {\n@@ -335,7 +333,7 @@ impl StdWriter {\n     pub fn set_raw(&mut self, raw: bool) -> IoResult<()> {\n         match self.inner {\n             TTY(ref mut tty) => {\n-                tty.set_raw(raw).map_err(IoError::from_rtio_error)\n+                tty.set_raw(raw)\n             }\n             File(..) => {\n                 Err(IoError {\n@@ -374,7 +372,7 @@ impl Writer for StdWriter {\n             try!(match self.inner {\n                 TTY(ref mut tty) => tty.write(chunk),\n                 File(ref mut file) => file.write(chunk),\n-            }.map_err(IoError::from_rtio_error))\n+            })\n         }\n         Ok(())\n     }"}, {"sha": "ec588f134784af9c69e746951668fedef27a9970", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -21,10 +21,9 @@ and create receivers which will receive notifications after a period of time.\n \n use comm::{Receiver, Sender, channel};\n use time::Duration;\n-use io::{IoResult, IoError};\n-use kinds::Send;\n-use boxed::Box;\n-use rt::rtio::{IoFactory, LocalIo, RtioTimer, Callback};\n+use io::IoResult;\n+use sys::timer::Callback;\n+use sys::timer::Timer as TimerImp;\n \n /// A synchronous timer object\n ///\n@@ -69,7 +68,7 @@ use rt::rtio::{IoFactory, LocalIo, RtioTimer, Callback};\n /// # }\n /// ```\n pub struct Timer {\n-    obj: Box<RtioTimer + Send>,\n+    inner: TimerImp,\n }\n \n struct TimerCallback { tx: Sender<()> }\n@@ -90,9 +89,7 @@ impl Timer {\n     /// for a number of milliseconds, or to possibly create channels which will\n     /// get notified after an amount of time has passed.\n     pub fn new() -> IoResult<Timer> {\n-        LocalIo::maybe_raise(|io| {\n-            io.timer_init().map(|t| Timer { obj: t })\n-        }).map_err(IoError::from_rtio_error)\n+        TimerImp::new().map(|t| Timer { inner: t })\n     }\n \n     /// Blocks the current task for the specified duration.\n@@ -106,7 +103,7 @@ impl Timer {\n         // Short-circuit the timer backend for 0 duration\n         let ms = in_ms_u64(duration);\n         if ms == 0 { return }\n-        self.obj.sleep(ms);\n+        self.inner.sleep(ms);\n     }\n \n     /// Creates a oneshot receiver which will have a notification sent when\n@@ -152,7 +149,7 @@ impl Timer {\n         let (tx, rx) = channel();\n         // Short-circuit the timer backend for 0 duration\n         if in_ms_u64(duration) != 0 {\n-            self.obj.oneshot(in_ms_u64(duration), box TimerCallback { tx: tx });\n+            self.inner.oneshot(in_ms_u64(duration), box TimerCallback { tx: tx });\n         } else {\n             tx.send(());\n         }\n@@ -213,7 +210,7 @@ impl Timer {\n         // not clear what use a 0ms period is anyway...\n         let ms = if ms == 0 { 1 } else { ms };\n         let (tx, rx) = channel();\n-        self.obj.period(ms, box TimerCallback { tx: tx });\n+        self.inner.period(ms, box TimerCallback { tx: tx });\n         return rx\n     }\n }"}, {"sha": "7eac455f97f250ab6efe998e315251f33295260d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -242,6 +242,13 @@ pub mod io;\n pub mod path;\n pub mod fmt;\n \n+#[cfg(unix)]\n+#[path = \"sys/unix/mod.rs\"] mod sys;\n+#[cfg(windows)]\n+#[path = \"sys/windows/mod.rs\"] mod sys;\n+\n+#[path = \"sys/common/mod.rs\"] mod sys_common;\n+\n // FIXME #7809: This shouldn't be pub, and it should be reexported under 'unstable'\n // but name resolution doesn't work without it being pub.\n pub mod rt;"}, {"sha": "ea42117bab601f99bb93dc2927a716723a524bcb", "filename": "src/libstd/os.rs", "status": "modified", "additions": 10, "deletions": 180, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -34,7 +34,7 @@\n use clone::Clone;\n use error::{FromError, Error};\n use fmt;\n-use io::{IoResult, IoError};\n+use io::IoResult;\n use iter::Iterator;\n use libc::{c_void, c_int};\n use libc;\n@@ -43,6 +43,8 @@ use ops::Drop;\n use option::{Some, None, Option};\n use os;\n use path::{Path, GenericPath, BytesContainer};\n+use sys;\n+use sys::os as os_imp;\n use ptr::RawPtr;\n use ptr;\n use result::{Err, Ok, Result};\n@@ -602,35 +604,11 @@ pub struct Pipe {\n /// descriptors to be closed, the file descriptors will leak. For safe handling\n /// of this scenario, use `std::io::PipeStream` instead.\n pub unsafe fn pipe() -> IoResult<Pipe> {\n-    return _pipe();\n-\n-    #[cfg(unix)]\n-    unsafe fn _pipe() -> IoResult<Pipe> {\n-        let mut fds = [0, ..2];\n-        match libc::pipe(fds.as_mut_ptr()) {\n-            0 => Ok(Pipe { reader: fds[0], writer: fds[1] }),\n-            _ => Err(IoError::last_error()),\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    unsafe fn _pipe() -> IoResult<Pipe> {\n-        // Windows pipes work subtly differently than unix pipes, and their\n-        // inheritance has to be handled in a different way that I do not\n-        // fully understand. Here we explicitly make the pipe non-inheritable,\n-        // which means to pass it to a subprocess they need to be duplicated\n-        // first, as in std::run.\n-        let mut fds = [0, ..2];\n-        match libc::pipe(fds.as_mut_ptr(), 1024 as ::libc::c_uint,\n-                         (libc::O_BINARY | libc::O_NOINHERIT) as c_int) {\n-            0 => {\n-                assert!(fds[0] != -1 && fds[0] != 0);\n-                assert!(fds[1] != -1 && fds[1] != 0);\n-                Ok(Pipe { reader: fds[0], writer: fds[1] })\n-            }\n-            _ => Err(IoError::last_error()),\n-        }\n-    }\n+    let (reader, writer) = try!(sys::os::pipe());\n+    Ok(Pipe {\n+        reader: reader.unwrap(),\n+        writer: writer.unwrap(),\n+    })\n }\n \n /// Returns the proper dll filename for the given basename of a file\n@@ -905,59 +883,9 @@ pub fn change_dir(p: &Path) -> bool {\n     }\n }\n \n-#[cfg(unix)]\n-/// Returns the platform-specific value of errno\n-pub fn errno() -> int {\n-    #[cfg(any(target_os = \"macos\",\n-              target_os = \"ios\",\n-              target_os = \"freebsd\"))]\n-    fn errno_location() -> *const c_int {\n-        extern {\n-            fn __error() -> *const c_int;\n-        }\n-        unsafe {\n-            __error()\n-        }\n-    }\n-\n-    #[cfg(target_os = \"dragonfly\")]\n-    fn errno_location() -> *const c_int {\n-        extern {\n-            fn __dfly_error() -> *const c_int;\n-        }\n-        unsafe {\n-            __dfly_error()\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn errno_location() -> *const c_int {\n-        extern {\n-            fn __errno_location() -> *const c_int;\n-        }\n-        unsafe {\n-            __errno_location()\n-        }\n-    }\n-\n-    unsafe {\n-        (*errno_location()) as int\n-    }\n-}\n-\n-#[cfg(windows)]\n /// Returns the platform-specific value of errno\n pub fn errno() -> uint {\n-    use libc::types::os::arch::extra::DWORD;\n-\n-    #[link_name = \"kernel32\"]\n-    extern \"system\" {\n-        fn GetLastError() -> DWORD;\n-    }\n-\n-    unsafe {\n-        GetLastError() as uint\n-    }\n+    os_imp::errno() as uint\n }\n \n /// Return the string corresponding to an `errno()` value of `errnum`.\n@@ -969,105 +897,7 @@ pub fn errno() -> uint {\n /// println!(\"{}\", os::error_string(os::errno() as uint));\n /// ```\n pub fn error_string(errnum: uint) -> String {\n-    return strerror(errnum);\n-\n-    #[cfg(unix)]\n-    fn strerror(errnum: uint) -> String {\n-        #[cfg(any(target_os = \"macos\",\n-                  target_os = \"ios\",\n-                  target_os = \"android\",\n-                  target_os = \"freebsd\",\n-                  target_os = \"dragonfly\"))]\n-        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t)\n-                      -> c_int {\n-            extern {\n-                fn strerror_r(errnum: c_int, buf: *mut c_char,\n-                              buflen: libc::size_t) -> c_int;\n-            }\n-            unsafe {\n-                strerror_r(errnum, buf, buflen)\n-            }\n-        }\n-\n-        // GNU libc provides a non-compliant version of strerror_r by default\n-        // and requires macros to instead use the POSIX compliant variant.\n-        // So we just use __xpg_strerror_r which is always POSIX compliant\n-        #[cfg(target_os = \"linux\")]\n-        fn strerror_r(errnum: c_int, buf: *mut c_char,\n-                      buflen: libc::size_t) -> c_int {\n-            extern {\n-                fn __xpg_strerror_r(errnum: c_int,\n-                                    buf: *mut c_char,\n-                                    buflen: libc::size_t)\n-                                    -> c_int;\n-            }\n-            unsafe {\n-                __xpg_strerror_r(errnum, buf, buflen)\n-            }\n-        }\n-\n-        let mut buf = [0 as c_char, ..TMPBUF_SZ];\n-\n-        let p = buf.as_mut_ptr();\n-        unsafe {\n-            if strerror_r(errnum as c_int, p, buf.len() as libc::size_t) < 0 {\n-                panic!(\"strerror_r failure\");\n-            }\n-\n-            ::string::raw::from_buf(p as *const u8)\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    fn strerror(errnum: uint) -> String {\n-        use libc::types::os::arch::extra::DWORD;\n-        use libc::types::os::arch::extra::LPWSTR;\n-        use libc::types::os::arch::extra::LPVOID;\n-        use libc::types::os::arch::extra::WCHAR;\n-\n-        #[link_name = \"kernel32\"]\n-        extern \"system\" {\n-            fn FormatMessageW(flags: DWORD,\n-                              lpSrc: LPVOID,\n-                              msgId: DWORD,\n-                              langId: DWORD,\n-                              buf: LPWSTR,\n-                              nsize: DWORD,\n-                              args: *const c_void)\n-                              -> DWORD;\n-        }\n-\n-        static FORMAT_MESSAGE_FROM_SYSTEM: DWORD = 0x00001000;\n-        static FORMAT_MESSAGE_IGNORE_INSERTS: DWORD = 0x00000200;\n-\n-        // This value is calculated from the macro\n-        // MAKELANGID(LANG_SYSTEM_DEFAULT, SUBLANG_SYS_DEFAULT)\n-        let langId = 0x0800 as DWORD;\n-\n-        let mut buf = [0 as WCHAR, ..TMPBUF_SZ];\n-\n-        unsafe {\n-            let res = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |\n-                                     FORMAT_MESSAGE_IGNORE_INSERTS,\n-                                     ptr::null_mut(),\n-                                     errnum as DWORD,\n-                                     langId,\n-                                     buf.as_mut_ptr(),\n-                                     buf.len() as DWORD,\n-                                     ptr::null());\n-            if res == 0 {\n-                // Sometimes FormatMessageW can fail e.g. system doesn't like langId,\n-                let fm_err = errno();\n-                return format!(\"OS Error {} (FormatMessageW() returned error {})\", errnum, fm_err);\n-            }\n-\n-            let msg = String::from_utf16(::str::truncate_utf16_at_nul(buf));\n-            match msg {\n-                Some(msg) => format!(\"OS Error {}: {}\", errnum, msg),\n-                None => format!(\"OS Error {} (FormatMessageW() returned invalid UTF-16)\", errnum),\n-            }\n-        }\n-    }\n+    return os_imp::error_string(errnum as i32);\n }\n \n /// Get a string representing the platform-dependent last error"}, {"sha": "87907fde2772afcb2a7fb2f64101fbc2f1e00bad", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "renamed", "additions": 14, "deletions": 80, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -20,16 +20,15 @@\n //! can be created in the future and there must be no active timers at that\n //! time.\n \n-#![macro_escape]\n+use mem;\n+use rt::bookkeeping;\n+use rt::mutex::StaticNativeMutex;\n+use rt;\n+use cell::UnsafeCell;\n+use sys::helper_signal;\n+use prelude::*;\n \n-use std::cell::UnsafeCell;\n-use std::mem;\n-use std::rt::bookkeeping;\n-use std::rt::mutex::StaticNativeMutex;\n-use std::rt;\n-use std::task::TaskBuilder;\n-\n-use NativeTaskBuilder;\n+use task;\n \n /// A structure for management of a helper thread.\n ///\n@@ -56,15 +55,6 @@ pub struct Helper<M> {\n     pub initialized: UnsafeCell<bool>,\n }\n \n-macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n-    static $name: Helper<$m> = Helper {\n-        lock: ::std::rt::mutex::NATIVE_MUTEX_INIT,\n-        chan: ::std::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n-        signal: ::std::cell::UnsafeCell { value: 0 },\n-        initialized: ::std::cell::UnsafeCell { value: false },\n-    };\n-) )\n-\n impl<M: Send> Helper<M> {\n     /// Lazily boots a helper thread, becoming a no-op if the helper has already\n     /// been spawned.\n@@ -77,17 +67,17 @@ impl<M: Send> Helper<M> {\n     /// This function is safe to be called many times.\n     pub fn boot<T: Send>(&'static self,\n                          f: || -> T,\n-                         helper: fn(imp::signal, Receiver<M>, T)) {\n+                         helper: fn(helper_signal::signal, Receiver<M>, T)) {\n         unsafe {\n             let _guard = self.lock.lock();\n             if !*self.initialized.get() {\n                 let (tx, rx) = channel();\n                 *self.chan.get() = mem::transmute(box tx);\n-                let (receive, send) = imp::new();\n+                let (receive, send) = helper_signal::new();\n                 *self.signal.get() = send as uint;\n \n                 let t = f();\n-                TaskBuilder::new().native().spawn(proc() {\n+                task::spawn(proc() {\n                     bookkeeping::decrement();\n                     helper(receive, rx, t);\n                     self.lock.lock().signal()\n@@ -111,7 +101,7 @@ impl<M: Send> Helper<M> {\n             // send the message.\n             assert!(!self.chan.get().is_null());\n             (**self.chan.get()).send(msg);\n-            imp::signal(*self.signal.get() as imp::signal);\n+            helper_signal::signal(*self.signal.get() as helper_signal::signal);\n         }\n     }\n \n@@ -126,72 +116,16 @@ impl<M: Send> Helper<M> {\n             let chan: Box<Sender<M>> = mem::transmute(*self.chan.get());\n             *self.chan.get() = 0 as *mut Sender<M>;\n             drop(chan);\n-            imp::signal(*self.signal.get() as imp::signal);\n+            helper_signal::signal(*self.signal.get() as helper_signal::signal);\n \n             // Wait for the child to exit\n             guard.wait();\n             drop(guard);\n \n             // Clean up after ourselves\n             self.lock.destroy();\n-            imp::close(*self.signal.get() as imp::signal);\n+            helper_signal::close(*self.signal.get() as helper_signal::signal);\n             *self.signal.get() = 0;\n         }\n     }\n }\n-\n-#[cfg(unix)]\n-mod imp {\n-    use libc;\n-    use std::os;\n-\n-    use io::file::FileDesc;\n-\n-    pub type signal = libc::c_int;\n-\n-    pub fn new() -> (signal, signal) {\n-        let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n-        (reader, writer)\n-    }\n-\n-    pub fn signal(fd: libc::c_int) {\n-        FileDesc::new(fd, false).inner_write([0]).ok().unwrap();\n-    }\n-\n-    pub fn close(fd: libc::c_int) {\n-        let _fd = FileDesc::new(fd, true);\n-    }\n-}\n-\n-#[cfg(windows)]\n-mod imp {\n-    use libc::{BOOL, LPCSTR, HANDLE, LPSECURITY_ATTRIBUTES, CloseHandle};\n-    use std::ptr;\n-    use libc;\n-\n-    pub type signal = HANDLE;\n-\n-    pub fn new() -> (HANDLE, HANDLE) {\n-        unsafe {\n-            let handle = CreateEventA(ptr::null_mut(), libc::FALSE, libc::FALSE,\n-                                      ptr::null());\n-            (handle, handle)\n-        }\n-    }\n-\n-    pub fn signal(handle: HANDLE) {\n-        assert!(unsafe { SetEvent(handle) != 0 });\n-    }\n-\n-    pub fn close(handle: HANDLE) {\n-        assert!(unsafe { CloseHandle(handle) != 0 });\n-    }\n-\n-    extern \"system\" {\n-        fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n-                        bManualReset: BOOL,\n-                        bInitialState: BOOL,\n-                        lpName: LPCSTR) -> HANDLE;\n-        fn SetEvent(hEvent: HANDLE) -> BOOL;\n-    }\n-}", "previous_filename": "src/libnative/io/helper_thread.rs"}, {"sha": "c5f8214a5c38c92703d4f1837db9f4229adad6d5", "filename": "src/libstd/sys/common/mod.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(missing_doc)]\n+#![allow(dead_code)]\n+\n+use io::{mod, IoError, IoResult};\n+use prelude::*;\n+use num;\n+use sys::{last_error, retry, fs};\n+use c_str::CString;\n+use path::BytesContainer;\n+use collections;\n+\n+pub mod net;\n+pub mod helper_thread;\n+\n+// common error constructors\n+\n+pub fn eof() -> IoError {\n+    IoError {\n+        kind: io::EndOfFile,\n+        desc: \"end of file\",\n+        detail: None,\n+    }\n+}\n+\n+pub fn timeout(desc: &'static str) -> IoError {\n+    IoError {\n+        kind: io::TimedOut,\n+        desc: desc,\n+        detail: None,\n+    }\n+}\n+\n+pub fn short_write(n: uint, desc: &'static str) -> IoError {\n+    IoError {\n+        kind: if n == 0 { io::TimedOut } else { io::ShortWrite(n) },\n+        desc: desc,\n+        detail: None,\n+    }\n+}\n+\n+pub fn unimpl() -> IoError {\n+    IoError {\n+        kind: io::IoUnavailable,\n+        desc: \"operations not yet supported\",\n+        detail: None,\n+    }\n+}\n+\n+// unix has nonzero values as errors\n+pub fn mkerr_libc<Int: num::Zero>(ret: Int) -> IoResult<()> {\n+    if !ret.is_zero() {\n+        Err(last_error())\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n+pub fn keep_going(data: &[u8], f: |*const u8, uint| -> i64) -> i64 {\n+    let origamt = data.len();\n+    let mut data = data.as_ptr();\n+    let mut amt = origamt;\n+    while amt > 0 {\n+        let ret = retry(|| f(data, amt));\n+        if ret == 0 {\n+            break\n+        } else if ret != -1 {\n+            amt -= ret as uint;\n+            data = unsafe { data.offset(ret as int) };\n+        } else {\n+            return ret;\n+        }\n+    }\n+    return (origamt - amt) as i64;\n+}\n+\n+// traits for extracting representations from\n+\n+pub trait AsFileDesc {\n+    fn as_fd(&self) -> &fs::FileDesc;\n+}\n+\n+pub trait ProcessConfig<K: BytesContainer, V: BytesContainer> {\n+    fn program(&self) -> &CString;\n+    fn args(&self) -> &[CString];\n+    fn env(&self) -> Option<&collections::HashMap<K, V>>;\n+    fn cwd(&self) -> Option<&CString>;\n+    fn uid(&self) -> Option<uint>;\n+    fn gid(&self) -> Option<uint>;\n+    fn detach(&self) -> bool;\n+}"}, {"sha": "7c44142d93cdb83afee4d6f44b6bd092f4f97837", "filename": "src/libstd/sys/common/net.rs", "status": "renamed", "additions": 460, "deletions": 652, "changes": 1112, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -9,21 +9,28 @@\n // except according to those terms.\n \n use alloc::arc::Arc;\n-use libc;\n-use std::mem;\n-use std::ptr;\n-use std::rt::mutex;\n-use std::rt::rtio::{mod, IoResult, IoError};\n-use std::sync::atomic;\n-\n-use super::{retry, keep_going};\n-use super::c;\n-use super::util;\n-\n-#[cfg(unix)] use super::process;\n-#[cfg(unix)] use super::file::FileDesc;\n-\n-pub use self::os::{init, sock_t, last_error};\n+use libc::{mod, c_char, c_int};\n+use mem;\n+use ptr::{mod, null, null_mut};\n+use rt::mutex;\n+use io::net::ip::{SocketAddr, IpAddr, Ipv4Addr, Ipv6Addr};\n+use io::net::addrinfo;\n+use io::{IoResult, IoError};\n+use sys::{mod, retry, c, sock_t, last_error, last_net_error, last_gai_error, close_sock,\n+          wrlen, msglen_t, os, wouldblock, set_nonblocking, timer, ms_to_timeval,\n+          decode_error_detailed};\n+use sys_common::{mod, keep_going, short_write, timeout};\n+use prelude::*;\n+use cmp;\n+use io;\n+\n+// FIXME: move uses of Arc and deadline tracking to std::io\n+\n+#[deriving(Show)]\n+pub enum SocketStatus {\n+    Readable,\n+    Writable,\n+}\n \n ////////////////////////////////////////////////////////////////////////////////\n // sockaddr and misc bindings\n@@ -36,14 +43,14 @@ pub fn ntohs(u: u16) -> u16 {\n     Int::from_be(u)\n }\n \n-enum InAddr {\n+pub enum InAddr {\n     In4Addr(libc::in_addr),\n     In6Addr(libc::in6_addr),\n }\n \n-fn ip_to_inaddr(ip: rtio::IpAddr) -> InAddr {\n+pub fn ip_to_inaddr(ip: IpAddr) -> InAddr {\n     match ip {\n-        rtio::Ipv4Addr(a, b, c, d) => {\n+        Ipv4Addr(a, b, c, d) => {\n             let ip = (a as u32 << 24) |\n                      (b as u32 << 16) |\n                      (c as u32 <<  8) |\n@@ -52,7 +59,7 @@ fn ip_to_inaddr(ip: rtio::IpAddr) -> InAddr {\n                 s_addr: Int::from_be(ip)\n             })\n         }\n-        rtio::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+        Ipv6Addr(a, b, c, d, e, f, g, h) => {\n             In6Addr(libc::in6_addr {\n                 s6_addr: [\n                     htons(a),\n@@ -69,7 +76,7 @@ fn ip_to_inaddr(ip: rtio::IpAddr) -> InAddr {\n     }\n }\n \n-fn addr_to_sockaddr(addr: rtio::SocketAddr,\n+pub fn addr_to_sockaddr(addr: SocketAddr,\n                     storage: &mut libc::sockaddr_storage)\n                     -> libc::socklen_t {\n     unsafe {\n@@ -93,28 +100,28 @@ fn addr_to_sockaddr(addr: rtio::SocketAddr,\n     }\n }\n \n-fn socket(addr: rtio::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n+pub fn socket(addr: SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n     unsafe {\n         let fam = match addr.ip {\n-            rtio::Ipv4Addr(..) => libc::AF_INET,\n-            rtio::Ipv6Addr(..) => libc::AF_INET6,\n+            Ipv4Addr(..) => libc::AF_INET,\n+            Ipv6Addr(..) => libc::AF_INET6,\n         };\n         match libc::socket(fam, ty, 0) {\n-            -1 => Err(os::last_error()),\n+            -1 => Err(last_net_error()),\n             fd => Ok(fd),\n         }\n     }\n }\n \n-fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n+pub fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n                  payload: T) -> IoResult<()> {\n     unsafe {\n         let payload = &payload as *const T as *const libc::c_void;\n         let ret = libc::setsockopt(fd, opt, val,\n                                    payload,\n                                    mem::size_of::<T>() as libc::socklen_t);\n         if ret != 0 {\n-            Err(os::last_error())\n+            Err(last_net_error())\n         } else {\n             Ok(())\n         }\n@@ -130,18 +137,18 @@ pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,\n                                 &mut slot as *mut _ as *mut _,\n                                 &mut len);\n         if ret != 0 {\n-            Err(os::last_error())\n+            Err(last_net_error())\n         } else {\n             assert!(len as uint == mem::size_of::<T>());\n             Ok(slot)\n         }\n     }\n }\n \n-fn sockname(fd: sock_t,\n+pub fn sockname(fd: sock_t,\n             f: unsafe extern \"system\" fn(sock_t, *mut libc::sockaddr,\n                                          *mut libc::socklen_t) -> libc::c_int)\n-    -> IoResult<rtio::SocketAddr>\n+    -> IoResult<SocketAddr>\n {\n     let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n     let mut len = mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n@@ -151,14 +158,14 @@ fn sockname(fd: sock_t,\n                     storage as *mut libc::sockaddr,\n                     &mut len as *mut libc::socklen_t);\n         if ret != 0 {\n-            return Err(os::last_error())\n+            return Err(last_net_error())\n         }\n     }\n     return sockaddr_to_addr(&storage, len as uint);\n }\n \n pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n-                        len: uint) -> IoResult<rtio::SocketAddr> {\n+                        len: uint) -> IoResult<SocketAddr> {\n     match storage.ss_family as libc::c_int {\n         libc::AF_INET => {\n             assert!(len as uint >= mem::size_of::<libc::sockaddr_in>());\n@@ -170,8 +177,8 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             let b = (ip >> 16) as u8;\n             let c = (ip >>  8) as u8;\n             let d = (ip >>  0) as u8;\n-            Ok(rtio::SocketAddr {\n-                ip: rtio::Ipv4Addr(a, b, c, d),\n+            Ok(SocketAddr {\n+                ip: Ipv4Addr(a, b, c, d),\n                 port: ntohs(storage.sin_port),\n             })\n         }\n@@ -188,33 +195,359 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             let f = ntohs(storage.sin6_addr.s6_addr[5]);\n             let g = ntohs(storage.sin6_addr.s6_addr[6]);\n             let h = ntohs(storage.sin6_addr.s6_addr[7]);\n-            Ok(rtio::SocketAddr {\n-                ip: rtio::Ipv6Addr(a, b, c, d, e, f, g, h),\n+            Ok(SocketAddr {\n+                ip: Ipv6Addr(a, b, c, d, e, f, g, h),\n                 port: ntohs(storage.sin6_port),\n             })\n         }\n         _ => {\n-            #[cfg(unix)] use libc::EINVAL as ERROR;\n-            #[cfg(windows)] use libc::WSAEINVAL as ERROR;\n             Err(IoError {\n-                code: ERROR as uint,\n-                extra: 0,\n+                kind: io::InvalidInput,\n+                desc: \"invalid argument\",\n                 detail: None,\n             })\n         }\n     }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n-// TCP streams\n+// get_host_addresses\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub struct TcpStream {\n-    inner: Arc<Inner>,\n-    read_deadline: u64,\n-    write_deadline: u64,\n+extern \"system\" {\n+    fn getaddrinfo(node: *const c_char, service: *const c_char,\n+                   hints: *const libc::addrinfo,\n+                   res: *mut *mut libc::addrinfo) -> c_int;\n+    fn freeaddrinfo(res: *mut libc::addrinfo);\n }\n \n+pub fn get_host_addresses(host: Option<&str>, servname: Option<&str>,\n+                          hint: Option<addrinfo::Hint>)\n+                          -> Result<Vec<addrinfo::Info>, IoError>\n+{\n+    sys::init_net();\n+\n+    assert!(host.is_some() || servname.is_some());\n+\n+    let c_host = host.map(|x| x.to_c_str());\n+    let c_host = c_host.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n+    let c_serv = servname.map(|x| x.to_c_str());\n+    let c_serv = c_serv.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n+\n+    let hint = hint.map(|hint| {\n+        libc::addrinfo {\n+            ai_flags: hint.flags as c_int,\n+            ai_family: hint.family as c_int,\n+            ai_socktype: 0,\n+            ai_protocol: 0,\n+            ai_addrlen: 0,\n+            ai_canonname: null_mut(),\n+            ai_addr: null_mut(),\n+            ai_next: null_mut()\n+        }\n+    });\n+\n+    let hint_ptr = hint.as_ref().map_or(null(), |x| {\n+        x as *const libc::addrinfo\n+    });\n+    let mut res = null_mut();\n+\n+    // Make the call\n+    let s = unsafe {\n+        getaddrinfo(c_host, c_serv, hint_ptr, &mut res)\n+    };\n+\n+    // Error?\n+    if s != 0 {\n+        return Err(last_gai_error(s));\n+    }\n+\n+    // Collect all the results we found\n+    let mut addrs = Vec::new();\n+    let mut rp = res;\n+    while rp.is_not_null() {\n+        unsafe {\n+            let addr = try!(sockaddr_to_addr(mem::transmute((*rp).ai_addr),\n+                                             (*rp).ai_addrlen as uint));\n+            addrs.push(addrinfo::Info {\n+                address: addr,\n+                family: (*rp).ai_family as uint,\n+                socktype: None,\n+                protocol: None,\n+                flags: (*rp).ai_flags as uint\n+            });\n+\n+            rp = (*rp).ai_next as *mut libc::addrinfo;\n+        }\n+    }\n+\n+    unsafe { freeaddrinfo(res); }\n+\n+    Ok(addrs)\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Timeout helpers\n+//\n+// The read/write functions below are the helpers for reading/writing a socket\n+// with a possible deadline specified. This is generally viewed as a timed out\n+// I/O operation.\n+//\n+// From the application's perspective, timeouts apply to the I/O object, not to\n+// the underlying file descriptor (it's one timeout per object). This means that\n+// we can't use the SO_RCVTIMEO and corresponding send timeout option.\n+//\n+// The next idea to implement timeouts would be to use nonblocking I/O. An\n+// invocation of select() would wait (with a timeout) for a socket to be ready.\n+// Once its ready, we can perform the operation. Note that the operation *must*\n+// be nonblocking, even though select() says the socket is ready. This is\n+// because some other thread could have come and stolen our data (handles can be\n+// cloned).\n+//\n+// To implement nonblocking I/O, the first option we have is to use the\n+// O_NONBLOCK flag. Remember though that this is a global setting, affecting all\n+// I/O objects, so this was initially viewed as unwise.\n+//\n+// It turns out that there's this nifty MSG_DONTWAIT flag which can be passed to\n+// send/recv, but the niftiness wears off once you realize it only works well on\n+// Linux [1] [2]. This means that it's pretty easy to get a nonblocking\n+// operation on Linux (no flag fiddling, no affecting other objects), but not on\n+// other platforms.\n+//\n+// To work around this constraint on other platforms, we end up using the\n+// original strategy of flipping the O_NONBLOCK flag. As mentioned before, this\n+// could cause other objects' blocking operations to suddenly become\n+// nonblocking. To get around this, a \"blocking operation\" which returns EAGAIN\n+// falls back to using the same code path as nonblocking operations, but with an\n+// infinite timeout (select + send/recv). This helps emulate blocking\n+// reads/writes despite the underlying descriptor being nonblocking, as well as\n+// optimizing the fast path of just hitting one syscall in the good case.\n+//\n+// As a final caveat, this implementation uses a mutex so only one thread is\n+// doing a nonblocking operation at at time. This is the operation that comes\n+// after the select() (at which point we think the socket is ready). This is\n+// done for sanity to ensure that the state of the O_NONBLOCK flag is what we\n+// expect (wouldn't want someone turning it on when it should be off!). All\n+// operations performed in the lock are *nonblocking* to avoid holding the mutex\n+// forever.\n+//\n+// So, in summary, Linux uses MSG_DONTWAIT and doesn't need mutexes, everyone\n+// else uses O_NONBLOCK and mutexes with some trickery to make sure blocking\n+// reads/writes are still blocking.\n+//\n+// Fun, fun!\n+//\n+// [1] http://twistedmatrix.com/pipermail/twisted-commits/2012-April/034692.html\n+// [2] http://stackoverflow.com/questions/19819198/does-send-msg-dontwait\n+\n+pub fn read<T>(fd: sock_t,\n+               deadline: u64,\n+               lock: || -> T,\n+               read: |bool| -> libc::c_int) -> IoResult<uint> {\n+    let mut ret = -1;\n+    if deadline == 0 {\n+        ret = retry(|| read(false));\n+    }\n+\n+    if deadline != 0 || (ret == -1 && wouldblock()) {\n+        let deadline = match deadline {\n+            0 => None,\n+            n => Some(n),\n+        };\n+        loop {\n+            // With a timeout, first we wait for the socket to become\n+            // readable using select(), specifying the relevant timeout for\n+            // our previously set deadline.\n+            try!(await([fd], deadline, Readable));\n+\n+            // At this point, we're still within the timeout, and we've\n+            // determined that the socket is readable (as returned by\n+            // select). We must still read the socket in *nonblocking* mode\n+            // because some other thread could come steal our data. If we\n+            // fail to read some data, we retry (hence the outer loop) and\n+            // wait for the socket to become readable again.\n+            let _guard = lock();\n+            match retry(|| read(deadline.is_some())) {\n+                -1 if wouldblock() => {}\n+                -1 => return Err(last_net_error()),\n+               n => { ret = n; break }\n+            }\n+        }\n+    }\n+\n+    match ret {\n+        0 => Err(sys_common::eof()),\n+        n if n < 0 => Err(last_net_error()),\n+        n => Ok(n as uint)\n+    }\n+}\n+\n+pub fn write<T>(fd: sock_t,\n+                deadline: u64,\n+                buf: &[u8],\n+                write_everything: bool,\n+                lock: || -> T,\n+                write: |bool, *const u8, uint| -> i64) -> IoResult<uint> {\n+    let mut ret = -1;\n+    let mut written = 0;\n+    if deadline == 0 {\n+        if write_everything {\n+            ret = keep_going(buf, |inner, len| {\n+                written = buf.len() - len;\n+                write(false, inner, len)\n+            });\n+        } else {\n+            ret = retry(|| { write(false, buf.as_ptr(), buf.len()) });\n+            if ret > 0 { written = ret as uint; }\n+        }\n+    }\n+\n+    if deadline != 0 || (ret == -1 && wouldblock()) {\n+        let deadline = match deadline {\n+            0 => None,\n+            n => Some(n),\n+        };\n+        while written < buf.len() && (write_everything || written == 0) {\n+            // As with read(), first wait for the socket to be ready for\n+            // the I/O operation.\n+            match await([fd], deadline, Writable) {\n+                Err(ref e) if e.kind == io::EndOfFile && written > 0 => {\n+                    assert!(deadline.is_some());\n+                    return Err(short_write(written, \"short write\"))\n+                }\n+                Err(e) => return Err(e),\n+                Ok(()) => {}\n+            }\n+\n+            // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n+            // against unforeseen circumstances.\n+            let _guard = lock();\n+            let ptr = buf[written..].as_ptr();\n+            let len = buf.len() - written;\n+            match retry(|| write(deadline.is_some(), ptr, len)) {\n+                -1 if wouldblock() => {}\n+                -1 => return Err(last_net_error()),\n+                n => { written += n as uint; }\n+            }\n+        }\n+        ret = 0;\n+    }\n+    if ret < 0 {\n+        Err(last_net_error())\n+    } else {\n+        Ok(written)\n+    }\n+}\n+\n+// See http://developerweb.net/viewtopic.php?id=3196 for where this is\n+// derived from.\n+pub fn connect_timeout(fd: sock_t,\n+                       addrp: *const libc::sockaddr,\n+                       len: libc::socklen_t,\n+                       timeout_ms: u64) -> IoResult<()> {\n+    #[cfg(unix)]    use libc::EINPROGRESS as INPROGRESS;\n+    #[cfg(windows)] use libc::WSAEINPROGRESS as INPROGRESS;\n+    #[cfg(unix)]    use libc::EWOULDBLOCK as WOULDBLOCK;\n+    #[cfg(windows)] use libc::WSAEWOULDBLOCK as WOULDBLOCK;\n+\n+    // Make sure the call to connect() doesn't block\n+    try!(set_nonblocking(fd, true));\n+\n+    let ret = match unsafe { libc::connect(fd, addrp, len) } {\n+        // If the connection is in progress, then we need to wait for it to\n+        // finish (with a timeout). The current strategy for doing this is\n+        // to use select() with a timeout.\n+        -1 if os::errno() as int == INPROGRESS as int ||\n+              os::errno() as int == WOULDBLOCK as int => {\n+            let mut set: c::fd_set = unsafe { mem::zeroed() };\n+            c::fd_set(&mut set, fd);\n+            match await(fd, &mut set, timeout_ms) {\n+                0 => Err(timeout(\"connection timed out\")),\n+                -1 => Err(last_net_error()),\n+                _ => {\n+                    let err: libc::c_int = try!(\n+                        getsockopt(fd, libc::SOL_SOCKET, libc::SO_ERROR));\n+                    if err == 0 {\n+                        Ok(())\n+                    } else {\n+                        Err(decode_error_detailed(err))\n+                    }\n+                }\n+            }\n+        }\n+\n+        -1 => Err(last_net_error()),\n+        _ => Ok(()),\n+    };\n+\n+    // be sure to turn blocking I/O back on\n+    try!(set_nonblocking(fd, false));\n+    return ret;\n+\n+    #[cfg(unix)]\n+    fn await(fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int {\n+        let start = timer::now();\n+        retry(|| unsafe {\n+            // Recalculate the timeout each iteration (it is generally\n+            // undefined what the value of the 'tv' is after select\n+            // returns EINTR).\n+            let mut tv = ms_to_timeval(timeout - (timer::now() - start));\n+            c::select(fd + 1, ptr::null_mut(), set as *mut _,\n+                      ptr::null_mut(), &mut tv)\n+        })\n+    }\n+    #[cfg(windows)]\n+    fn await(_fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int {\n+        let mut tv = ms_to_timeval(timeout);\n+        unsafe { c::select(1, ptr::null_mut(), set, ptr::null_mut(), &mut tv) }\n+    }\n+}\n+\n+pub fn await(fds: &[sock_t], deadline: Option<u64>,\n+             status: SocketStatus) -> IoResult<()> {\n+    let mut set: c::fd_set = unsafe { mem::zeroed() };\n+    let mut max = 0;\n+    for &fd in fds.iter() {\n+        c::fd_set(&mut set, fd);\n+        max = cmp::max(max, fd + 1);\n+    }\n+    if cfg!(windows) {\n+        max = fds.len() as sock_t;\n+    }\n+\n+    let (read, write) = match status {\n+        Readable => (&mut set as *mut _, ptr::null_mut()),\n+        Writable => (ptr::null_mut(), &mut set as *mut _),\n+    };\n+    let mut tv: libc::timeval = unsafe { mem::zeroed() };\n+\n+    match retry(|| {\n+        let now = timer::now();\n+        let tvp = match deadline {\n+            None => ptr::null_mut(),\n+            Some(deadline) => {\n+                // If we're past the deadline, then pass a 0 timeout to\n+                // select() so we can poll the status\n+                let ms = if deadline < now {0} else {deadline - now};\n+                tv = ms_to_timeval(ms);\n+                &mut tv as *mut _\n+            }\n+        };\n+        let r = unsafe {\n+            c::select(max as libc::c_int, read, write, ptr::null_mut(), tvp)\n+        };\n+        r\n+    }) {\n+        -1 => Err(last_net_error()),\n+        0 => Err(timeout(\"timed out\")),\n+        _ => Ok(()),\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Basic socket representation\n+////////////////////////////////////////////////////////////////////////////////\n+\n struct Inner {\n     fd: sock_t,\n \n@@ -223,57 +556,79 @@ struct Inner {\n     lock: mutex::NativeMutex\n }\n \n+impl Inner {\n+    fn new(fd: sock_t) -> Inner {\n+        Inner { fd: fd, lock: unsafe { mutex::NativeMutex::new() } }\n+    }\n+}\n+\n+impl Drop for Inner {\n+    fn drop(&mut self) { unsafe { close_sock(self.fd); } }\n+}\n+\n pub struct Guard<'a> {\n     pub fd: sock_t,\n     pub guard: mutex::LockGuard<'a>,\n }\n \n-impl Inner {\n-    fn new(fd: sock_t) -> Inner {\n-        Inner { fd: fd, lock: unsafe { mutex::NativeMutex::new() } }\n+#[unsafe_destructor]\n+impl<'a> Drop for Guard<'a> {\n+    fn drop(&mut self) {\n+        assert!(set_nonblocking(self.fd, false).is_ok());\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// TCP streams\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct TcpStream {\n+    inner: Arc<Inner>,\n+    read_deadline: u64,\n+    write_deadline: u64,\n+}\n+\n impl TcpStream {\n-    pub fn connect(addr: rtio::SocketAddr,\n-                   timeout: Option<u64>) -> IoResult<TcpStream> {\n+    pub fn connect(addr: SocketAddr, timeout: Option<u64>) -> IoResult<TcpStream> {\n+        sys::init_net();\n+\n         let fd = try!(socket(addr, libc::SOCK_STREAM));\n-        let ret = TcpStream::new(Inner::new(fd));\n+        let ret = TcpStream::new(fd);\n \n         let mut storage = unsafe { mem::zeroed() };\n         let len = addr_to_sockaddr(addr, &mut storage);\n         let addrp = &storage as *const _ as *const libc::sockaddr;\n \n         match timeout {\n             Some(timeout) => {\n-                try!(util::connect_timeout(fd, addrp, len, timeout));\n+                try!(connect_timeout(fd, addrp, len, timeout));\n                 Ok(ret)\n             },\n             None => {\n                 match retry(|| unsafe { libc::connect(fd, addrp, len) }) {\n-                    -1 => Err(os::last_error()),\n+                    -1 => Err(last_error()),\n                     _ => Ok(ret),\n                 }\n             }\n         }\n     }\n \n-    fn new(inner: Inner) -> TcpStream {\n+    pub fn new(fd: sock_t) -> TcpStream {\n         TcpStream {\n-            inner: Arc::new(inner),\n+            inner: Arc::new(Inner::new(fd)),\n             read_deadline: 0,\n             write_deadline: 0,\n         }\n     }\n \n     pub fn fd(&self) -> sock_t { self.inner.fd }\n \n-    fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n+    pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_NODELAY,\n                    nodelay as libc::c_int)\n     }\n \n-    fn set_keepalive(&mut self, seconds: Option<uint>) -> IoResult<()> {\n+    pub fn set_keepalive(&mut self, seconds: Option<uint>) -> IoResult<()> {\n         let ret = setsockopt(self.fd(), libc::SOL_SOCKET, libc::SO_KEEPALIVE,\n                              seconds.is_some() as libc::c_int);\n         match seconds {\n@@ -309,16 +664,11 @@ impl TcpStream {\n             fd: self.fd(),\n             guard: unsafe { self.inner.lock.lock() },\n         };\n-        assert!(util::set_nonblocking(self.fd(), true).is_ok());\n+        assert!(set_nonblocking(self.fd(), true).is_ok());\n         ret\n     }\n-}\n \n-#[cfg(windows)] type wrlen = libc::c_int;\n-#[cfg(not(windows))] type wrlen = libc::size_t;\n-\n-impl rtio::RtioTcpStream for TcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n         let doread = |nb| unsafe {\n@@ -331,7 +681,7 @@ impl rtio::RtioTcpStream for TcpStream {\n         read(fd, self.read_deadline, dolock, doread)\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n         let dowrite = |nb: bool, buf: *const u8, len: uint| unsafe {\n@@ -341,340 +691,42 @@ impl rtio::RtioTcpStream for TcpStream {\n                        len as wrlen,\n                        flags) as i64\n         };\n-        match write(fd, self.write_deadline, buf, true, dolock, dowrite) {\n-            Ok(_) => Ok(()),\n-            Err(e) => Err(e)\n-        }\n+        write(fd, self.write_deadline, buf, true, dolock, dowrite).map(|_| ())\n     }\n-    fn peer_name(&mut self) -> IoResult<rtio::SocketAddr> {\n+    pub fn peer_name(&mut self) -> IoResult<SocketAddr> {\n         sockname(self.fd(), libc::getpeername)\n     }\n-    fn control_congestion(&mut self) -> IoResult<()> {\n-        self.set_nodelay(false)\n-    }\n-    fn nodelay(&mut self) -> IoResult<()> {\n-        self.set_nodelay(true)\n-    }\n-    fn keepalive(&mut self, delay_in_seconds: uint) -> IoResult<()> {\n-        self.set_keepalive(Some(delay_in_seconds))\n-    }\n-    fn letdie(&mut self) -> IoResult<()> {\n-        self.set_keepalive(None)\n-    }\n \n-    fn clone(&self) -> Box<rtio::RtioTcpStream + Send> {\n-        box TcpStream {\n-            inner: self.inner.clone(),\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        } as Box<rtio::RtioTcpStream + Send>\n-    }\n-\n-    fn close_write(&mut self) -> IoResult<()> {\n+    pub fn close_write(&mut self) -> IoResult<()> {\n         super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_WR) })\n     }\n-    fn close_read(&mut self) -> IoResult<()> {\n+    pub fn close_read(&mut self) -> IoResult<()> {\n         super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_RD) })\n     }\n \n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        let deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n         self.read_deadline = deadline;\n         self.write_deadline = deadline;\n     }\n-    fn set_read_timeout(&mut self, timeout: Option<u64>) {\n-        self.read_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n-    }\n-    fn set_write_timeout(&mut self, timeout: Option<u64>) {\n-        self.write_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n-    }\n-}\n-\n-impl rtio::RtioSocket for TcpStream {\n-    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> {\n-        sockname(self.fd(), libc::getsockname)\n-    }\n-}\n-\n-impl Drop for Inner {\n-    fn drop(&mut self) { unsafe { os::close(self.fd); } }\n-}\n-\n-#[unsafe_destructor]\n-impl<'a> Drop for Guard<'a> {\n-    fn drop(&mut self) {\n-        assert!(util::set_nonblocking(self.fd, false).is_ok());\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// TCP listeners\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct TcpListener {\n-    inner: Inner,\n-}\n-\n-impl TcpListener {\n-    pub fn bind(addr: rtio::SocketAddr) -> IoResult<TcpListener> {\n-        let fd = try!(socket(addr, libc::SOCK_STREAM));\n-        let ret = TcpListener { inner: Inner::new(fd) };\n-\n-        let mut storage = unsafe { mem::zeroed() };\n-        let len = addr_to_sockaddr(addr, &mut storage);\n-        let addrp = &storage as *const _ as *const libc::sockaddr;\n-\n-        // On platforms with Berkeley-derived sockets, this allows\n-        // to quickly rebind a socket, without needing to wait for\n-        // the OS to clean up the previous one.\n-        if cfg!(unix) {\n-            try!(setsockopt(fd, libc::SOL_SOCKET, libc::SO_REUSEADDR,\n-                            1 as libc::c_int));\n-        }\n-\n-        match unsafe { libc::bind(fd, addrp, len) } {\n-            -1 => Err(os::last_error()),\n-            _ => Ok(ret),\n-        }\n-    }\n-\n-    pub fn fd(&self) -> sock_t { self.inner.fd }\n-\n-    pub fn native_listen(self, backlog: int) -> IoResult<TcpAcceptor> {\n-        match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n-            -1 => Err(os::last_error()),\n-\n-            #[cfg(unix)]\n-            _ => {\n-                let (reader, writer) = try!(process::pipe());\n-                try!(util::set_nonblocking(reader.fd(), true));\n-                try!(util::set_nonblocking(writer.fd(), true));\n-                try!(util::set_nonblocking(self.fd(), true));\n-                Ok(TcpAcceptor {\n-                    inner: Arc::new(AcceptorInner {\n-                        listener: self,\n-                        reader: reader,\n-                        writer: writer,\n-                        closed: atomic::AtomicBool::new(false),\n-                    }),\n-                    deadline: 0,\n-                })\n-            }\n-\n-            #[cfg(windows)]\n-            _ => {\n-                let accept = try!(os::Event::new());\n-                let ret = unsafe {\n-                    c::WSAEventSelect(self.fd(), accept.handle(), c::FD_ACCEPT)\n-                };\n-                if ret != 0 {\n-                    return Err(os::last_error())\n-                }\n-                Ok(TcpAcceptor {\n-                    inner: Arc::new(AcceptorInner {\n-                        listener: self,\n-                        abort: try!(os::Event::new()),\n-                        accept: accept,\n-                        closed: atomic::AtomicBool::new(false),\n-                    }),\n-                    deadline: 0,\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-impl rtio::RtioTcpListener for TcpListener {\n-    fn listen(self: Box<TcpListener>)\n-              -> IoResult<Box<rtio::RtioTcpAcceptor + Send>> {\n-        self.native_listen(128).map(|a| {\n-            box a as Box<rtio::RtioTcpAcceptor + Send>\n-        })\n-    }\n-}\n-\n-impl rtio::RtioSocket for TcpListener {\n-    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> {\n-        sockname(self.fd(), libc::getsockname)\n-    }\n-}\n-\n-pub struct TcpAcceptor {\n-    inner: Arc<AcceptorInner>,\n-    deadline: u64,\n-}\n-\n-#[cfg(unix)]\n-struct AcceptorInner {\n-    listener: TcpListener,\n-    reader: FileDesc,\n-    writer: FileDesc,\n-    closed: atomic::AtomicBool,\n-}\n-\n-#[cfg(windows)]\n-struct AcceptorInner {\n-    listener: TcpListener,\n-    abort: os::Event,\n-    accept: os::Event,\n-    closed: atomic::AtomicBool,\n-}\n-\n-impl TcpAcceptor {\n-    pub fn fd(&self) -> sock_t { self.inner.listener.fd() }\n-\n-    #[cfg(unix)]\n-    pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n-        // In implementing accept, the two main concerns are dealing with\n-        // close_accept() and timeouts. The unix implementation is based on a\n-        // nonblocking accept plus a call to select(). Windows ends up having\n-        // an entirely separate implementation than unix, which is explained\n-        // below.\n-        //\n-        // To implement timeouts, all blocking is done via select() instead of\n-        // accept() by putting the socket in non-blocking mode. Because\n-        // select() takes a timeout argument, we just pass through the timeout\n-        // to select().\n-        //\n-        // To implement close_accept(), we have a self-pipe to ourselves which\n-        // is passed to select() along with the socket being accepted on. The\n-        // self-pipe is never written to unless close_accept() is called.\n-        let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n-\n-        while !self.inner.closed.load(atomic::SeqCst) {\n-            match retry(|| unsafe {\n-                libc::accept(self.fd(), ptr::null_mut(), ptr::null_mut())\n-            }) {\n-                -1 if util::wouldblock() => {}\n-                -1 => return Err(os::last_error()),\n-                fd => return Ok(TcpStream::new(Inner::new(fd as sock_t))),\n-            }\n-            try!(util::await([self.fd(), self.inner.reader.fd()],\n-                             deadline, util::Readable));\n-        }\n-\n-        Err(util::eof())\n+    pub fn set_read_timeout(&mut self, timeout: Option<u64>) {\n+        self.read_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }\n-\n-    #[cfg(windows)]\n-    pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n-        // Unlink unix, windows cannot invoke `select` on arbitrary file\n-        // descriptors like pipes, only sockets. Consequently, windows cannot\n-        // use the same implementation as unix for accept() when close_accept()\n-        // is considered.\n-        //\n-        // In order to implement close_accept() and timeouts, windows uses\n-        // event handles. An acceptor-specific abort event is created which\n-        // will only get set in close_accept(), and it will never be un-set.\n-        // Additionally, another acceptor-specific event is associated with the\n-        // FD_ACCEPT network event.\n-        //\n-        // These two events are then passed to WaitForMultipleEvents to see\n-        // which one triggers first, and the timeout passed to this function is\n-        // the local timeout for the acceptor.\n-        //\n-        // If the wait times out, then the accept timed out. If the wait\n-        // succeeds with the abort event, then we were closed, and if the wait\n-        // succeeds otherwise, then we do a nonblocking poll via `accept` to\n-        // see if we can accept a connection. The connection is candidate to be\n-        // stolen, so we do all of this in a loop as well.\n-        let events = [self.inner.abort.handle(), self.inner.accept.handle()];\n-\n-        while !self.inner.closed.load(atomic::SeqCst) {\n-            let ms = if self.deadline == 0 {\n-                c::WSA_INFINITE as u64\n-            } else {\n-                let now = ::io::timer::now();\n-                if self.deadline < now {0} else {self.deadline - now}\n-            };\n-            let ret = unsafe {\n-                c::WSAWaitForMultipleEvents(2, events.as_ptr(), libc::FALSE,\n-                                            ms as libc::DWORD, libc::FALSE)\n-            };\n-            match ret {\n-                c::WSA_WAIT_TIMEOUT => {\n-                    return Err(util::timeout(\"accept timed out\"))\n-                }\n-                c::WSA_WAIT_FAILED => return Err(os::last_error()),\n-                c::WSA_WAIT_EVENT_0 => break,\n-                n => assert_eq!(n, c::WSA_WAIT_EVENT_0 + 1),\n-            }\n-\n-            let mut wsaevents: c::WSANETWORKEVENTS = unsafe { mem::zeroed() };\n-            let ret = unsafe {\n-                c::WSAEnumNetworkEvents(self.fd(), events[1], &mut wsaevents)\n-            };\n-            if ret != 0 { return Err(os::last_error()) }\n-\n-            if wsaevents.lNetworkEvents & c::FD_ACCEPT == 0 { continue }\n-            match unsafe {\n-                libc::accept(self.fd(), ptr::null_mut(), ptr::null_mut())\n-            } {\n-                -1 if util::wouldblock() => {}\n-                -1 => return Err(os::last_error()),\n-\n-                // Accepted sockets inherit the same properties as the caller,\n-                // so we need to deregister our event and switch the socket back\n-                // to blocking mode\n-                fd => {\n-                    let stream = TcpStream::new(Inner::new(fd));\n-                    let ret = unsafe {\n-                        c::WSAEventSelect(fd, events[1], 0)\n-                    };\n-                    if ret != 0 { return Err(os::last_error()) }\n-                    try!(util::set_nonblocking(fd, false));\n-                    return Ok(stream)\n-                }\n-            }\n-        }\n-\n-        Err(util::eof())\n+    pub fn set_write_timeout(&mut self, timeout: Option<u64>) {\n+        self.write_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }\n-}\n \n-impl rtio::RtioSocket for TcpAcceptor {\n-    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> {\n+    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n         sockname(self.fd(), libc::getsockname)\n     }\n }\n \n-impl rtio::RtioTcpAcceptor for TcpAcceptor {\n-    fn accept(&mut self) -> IoResult<Box<rtio::RtioTcpStream + Send>> {\n-        self.native_accept().map(|s| box s as Box<rtio::RtioTcpStream + Send>)\n-    }\n-\n-    fn accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n-    fn dont_accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        self.deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n-    }\n-\n-    fn clone(&self) -> Box<rtio::RtioTcpAcceptor + Send> {\n-        box TcpAcceptor {\n+impl Clone for TcpStream {\n+    fn clone(&self) -> TcpStream {\n+        TcpStream {\n             inner: self.inner.clone(),\n-            deadline: 0,\n-        } as Box<rtio::RtioTcpAcceptor + Send>\n-    }\n-\n-    #[cfg(unix)]\n-    fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.closed.store(true, atomic::SeqCst);\n-        let mut fd = FileDesc::new(self.inner.writer.fd(), false);\n-        match fd.inner_write([0]) {\n-            Ok(..) => Ok(()),\n-            Err(..) if util::wouldblock() => Ok(()),\n-            Err(e) => Err(e),\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.closed.store(true, atomic::SeqCst);\n-        let ret = unsafe { c::WSASetEvent(self.inner.abort.handle()) };\n-        if ret == libc::TRUE {\n-            Ok(())\n-        } else {\n-            Err(os::last_error())\n+            read_deadline: 0,\n+            write_deadline: 0,\n         }\n     }\n }\n@@ -690,7 +742,9 @@ pub struct UdpSocket {\n }\n \n impl UdpSocket {\n-    pub fn bind(addr: rtio::SocketAddr) -> IoResult<UdpSocket> {\n+    pub fn bind(addr: SocketAddr) -> IoResult<UdpSocket> {\n+        sys::init_net();\n+\n         let fd = try!(socket(addr, libc::SOCK_DGRAM));\n         let ret = UdpSocket {\n             inner: Arc::new(Inner::new(fd)),\n@@ -703,7 +757,7 @@ impl UdpSocket {\n         let addrp = &storage as *const _ as *const libc::sockaddr;\n \n         match unsafe { libc::bind(fd, addrp, len) } {\n-            -1 => Err(os::last_error()),\n+            -1 => Err(last_error()),\n             _ => Ok(ret),\n         }\n     }\n@@ -720,8 +774,7 @@ impl UdpSocket {\n                    on as libc::c_int)\n     }\n \n-    pub fn set_membership(&mut self, addr: rtio::IpAddr,\n-                          opt: libc::c_int) -> IoResult<()> {\n+    pub fn set_membership(&mut self, addr: IpAddr, opt: libc::c_int) -> IoResult<()> {\n         match ip_to_inaddr(addr) {\n             In4Addr(addr) => {\n                 let mreq = libc::ip_mreq {\n@@ -750,22 +803,15 @@ impl UdpSocket {\n             fd: self.fd(),\n             guard: unsafe { self.inner.lock.lock() },\n         };\n-        assert!(util::set_nonblocking(self.fd(), true).is_ok());\n+        assert!(set_nonblocking(self.fd(), true).is_ok());\n         ret\n     }\n-}\n \n-impl rtio::RtioSocket for UdpSocket {\n-    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> {\n+    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n         sockname(self.fd(), libc::getsockname)\n     }\n-}\n-\n-#[cfg(windows)] type msglen_t = libc::c_int;\n-#[cfg(unix)]    type msglen_t = libc::size_t;\n \n-impl rtio::RtioUdpSocket for UdpSocket {\n-    fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, rtio::SocketAddr)> {\n+    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)> {\n         let fd = self.fd();\n         let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n         let storagep = &mut storage as *mut _ as *mut libc::sockaddr;\n@@ -787,7 +833,7 @@ impl rtio::RtioUdpSocket for UdpSocket {\n         })\n     }\n \n-    fn send_to(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> IoResult<()> {\n+    pub fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n         let mut storage = unsafe { mem::zeroed() };\n         let dstlen = addr_to_sockaddr(dst, &mut storage);\n         let dstp = &storage as *const _ as *const libc::sockaddr;\n@@ -806,298 +852,60 @@ impl rtio::RtioUdpSocket for UdpSocket {\n \n         let n = try!(write(fd, self.write_deadline, buf, false, dolock, dowrite));\n         if n != buf.len() {\n-            Err(util::short_write(n, \"couldn't send entire packet at once\"))\n+            Err(short_write(n, \"couldn't send entire packet at once\"))\n         } else {\n             Ok(())\n         }\n     }\n \n-    fn join_multicast(&mut self, multi: rtio::IpAddr) -> IoResult<()> {\n+    pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n         match multi {\n-            rtio::Ipv4Addr(..) => {\n+            Ipv4Addr(..) => {\n                 self.set_membership(multi, libc::IP_ADD_MEMBERSHIP)\n             }\n-            rtio::Ipv6Addr(..) => {\n+            Ipv6Addr(..) => {\n                 self.set_membership(multi, libc::IPV6_ADD_MEMBERSHIP)\n             }\n         }\n     }\n-    fn leave_multicast(&mut self, multi: rtio::IpAddr) -> IoResult<()> {\n+    pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n         match multi {\n-            rtio::Ipv4Addr(..) => {\n+            Ipv4Addr(..) => {\n                 self.set_membership(multi, libc::IP_DROP_MEMBERSHIP)\n             }\n-            rtio::Ipv6Addr(..) => {\n+            Ipv6Addr(..) => {\n                 self.set_membership(multi, libc::IPV6_DROP_MEMBERSHIP)\n             }\n         }\n     }\n \n-    fn loop_multicast_locally(&mut self) -> IoResult<()> {\n-        self.set_multicast_loop(true)\n-    }\n-    fn dont_loop_multicast_locally(&mut self) -> IoResult<()> {\n-        self.set_multicast_loop(false)\n-    }\n-\n-    fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()> {\n+    pub fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_MULTICAST_TTL,\n                    ttl as libc::c_int)\n     }\n-    fn time_to_live(&mut self, ttl: int) -> IoResult<()> {\n+    pub fn time_to_live(&mut self, ttl: int) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_TTL, ttl as libc::c_int)\n     }\n \n-    fn hear_broadcasts(&mut self) -> IoResult<()> {\n-        self.set_broadcast(true)\n-    }\n-    fn ignore_broadcasts(&mut self) -> IoResult<()> {\n-        self.set_broadcast(false)\n-    }\n-\n-    fn clone(&self) -> Box<rtio::RtioUdpSocket + Send> {\n-        box UdpSocket {\n-            inner: self.inner.clone(),\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        } as Box<rtio::RtioUdpSocket + Send>\n-    }\n-\n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        let deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n         self.read_deadline = deadline;\n         self.write_deadline = deadline;\n     }\n-    fn set_read_timeout(&mut self, timeout: Option<u64>) {\n-        self.read_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    pub fn set_read_timeout(&mut self, timeout: Option<u64>) {\n+        self.read_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }\n-    fn set_write_timeout(&mut self, timeout: Option<u64>) {\n-        self.write_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    pub fn set_write_timeout(&mut self, timeout: Option<u64>) {\n+        self.write_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Timeout helpers\n-//\n-// The read/write functions below are the helpers for reading/writing a socket\n-// with a possible deadline specified. This is generally viewed as a timed out\n-// I/O operation.\n-//\n-// From the application's perspective, timeouts apply to the I/O object, not to\n-// the underlying file descriptor (it's one timeout per object). This means that\n-// we can't use the SO_RCVTIMEO and corresponding send timeout option.\n-//\n-// The next idea to implement timeouts would be to use nonblocking I/O. An\n-// invocation of select() would wait (with a timeout) for a socket to be ready.\n-// Once its ready, we can perform the operation. Note that the operation *must*\n-// be nonblocking, even though select() says the socket is ready. This is\n-// because some other thread could have come and stolen our data (handles can be\n-// cloned).\n-//\n-// To implement nonblocking I/O, the first option we have is to use the\n-// O_NONBLOCK flag. Remember though that this is a global setting, affecting all\n-// I/O objects, so this was initially viewed as unwise.\n-//\n-// It turns out that there's this nifty MSG_DONTWAIT flag which can be passed to\n-// send/recv, but the niftiness wears off once you realize it only works well on\n-// Linux [1] [2]. This means that it's pretty easy to get a nonblocking\n-// operation on Linux (no flag fiddling, no affecting other objects), but not on\n-// other platforms.\n-//\n-// To work around this constraint on other platforms, we end up using the\n-// original strategy of flipping the O_NONBLOCK flag. As mentioned before, this\n-// could cause other objects' blocking operations to suddenly become\n-// nonblocking. To get around this, a \"blocking operation\" which returns EAGAIN\n-// falls back to using the same code path as nonblocking operations, but with an\n-// infinite timeout (select + send/recv). This helps emulate blocking\n-// reads/writes despite the underlying descriptor being nonblocking, as well as\n-// optimizing the fast path of just hitting one syscall in the good case.\n-//\n-// As a final caveat, this implementation uses a mutex so only one thread is\n-// doing a nonblocking operation at at time. This is the operation that comes\n-// after the select() (at which point we think the socket is ready). This is\n-// done for sanity to ensure that the state of the O_NONBLOCK flag is what we\n-// expect (wouldn't want someone turning it on when it should be off!). All\n-// operations performed in the lock are *nonblocking* to avoid holding the mutex\n-// forever.\n-//\n-// So, in summary, Linux uses MSG_DONTWAIT and doesn't need mutexes, everyone\n-// else uses O_NONBLOCK and mutexes with some trickery to make sure blocking\n-// reads/writes are still blocking.\n-//\n-// Fun, fun!\n-//\n-// [1] http://twistedmatrix.com/pipermail/twisted-commits/2012-April/034692.html\n-// [2] http://stackoverflow.com/questions/19819198/does-send-msg-dontwait\n-\n-pub fn read<T>(fd: sock_t,\n-               deadline: u64,\n-               lock: || -> T,\n-               read: |bool| -> libc::c_int) -> IoResult<uint> {\n-    let mut ret = -1;\n-    if deadline == 0 {\n-        ret = retry(|| read(false));\n-    }\n-\n-    if deadline != 0 || (ret == -1 && util::wouldblock()) {\n-        let deadline = match deadline {\n-            0 => None,\n-            n => Some(n),\n-        };\n-        loop {\n-            // With a timeout, first we wait for the socket to become\n-            // readable using select(), specifying the relevant timeout for\n-            // our previously set deadline.\n-            try!(util::await([fd], deadline, util::Readable));\n-\n-            // At this point, we're still within the timeout, and we've\n-            // determined that the socket is readable (as returned by\n-            // select). We must still read the socket in *nonblocking* mode\n-            // because some other thread could come steal our data. If we\n-            // fail to read some data, we retry (hence the outer loop) and\n-            // wait for the socket to become readable again.\n-            let _guard = lock();\n-            match retry(|| read(deadline.is_some())) {\n-                -1 if util::wouldblock() => {}\n-                -1 => return Err(os::last_error()),\n-               n => { ret = n; break }\n-            }\n-        }\n-    }\n-\n-    match ret {\n-        0 => Err(util::eof()),\n-        n if n < 0 => Err(os::last_error()),\n-        n => Ok(n as uint)\n-    }\n-}\n-\n-pub fn write<T>(fd: sock_t,\n-                deadline: u64,\n-                buf: &[u8],\n-                write_everything: bool,\n-                lock: || -> T,\n-                write: |bool, *const u8, uint| -> i64) -> IoResult<uint> {\n-    let mut ret = -1;\n-    let mut written = 0;\n-    if deadline == 0 {\n-        if write_everything {\n-            ret = keep_going(buf, |inner, len| {\n-                written = buf.len() - len;\n-                write(false, inner, len)\n-            });\n-        } else {\n-            ret = retry(|| { write(false, buf.as_ptr(), buf.len()) });\n-            if ret > 0 { written = ret as uint; }\n-        }\n-    }\n-\n-    if deadline != 0 || (ret == -1 && util::wouldblock()) {\n-        let deadline = match deadline {\n-            0 => None,\n-            n => Some(n),\n-        };\n-        while written < buf.len() && (write_everything || written == 0) {\n-            // As with read(), first wait for the socket to be ready for\n-            // the I/O operation.\n-            match util::await([fd], deadline, util::Writable) {\n-                Err(ref e) if e.code == libc::EOF as uint && written > 0 => {\n-                    assert!(deadline.is_some());\n-                    return Err(util::short_write(written, \"short write\"))\n-                }\n-                Err(e) => return Err(e),\n-                Ok(()) => {}\n-            }\n-\n-            // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n-            // against unforeseen circumstances.\n-            let _guard = lock();\n-            let ptr = buf[written..].as_ptr();\n-            let len = buf.len() - written;\n-            match retry(|| write(deadline.is_some(), ptr, len)) {\n-                -1 if util::wouldblock() => {}\n-                -1 => return Err(os::last_error()),\n-                n => { written += n as uint; }\n-            }\n-        }\n-        ret = 0;\n-    }\n-    if ret < 0 {\n-        Err(os::last_error())\n-    } else {\n-        Ok(written)\n-    }\n-}\n-\n-#[cfg(windows)]\n-mod os {\n-    use libc;\n-    use std::mem;\n-    use std::rt::rtio::{IoError, IoResult};\n-\n-    use io::c;\n-\n-    pub type sock_t = libc::SOCKET;\n-    pub struct Event(c::WSAEVENT);\n-\n-    impl Event {\n-        pub fn new() -> IoResult<Event> {\n-            let event = unsafe { c::WSACreateEvent() };\n-            if event == c::WSA_INVALID_EVENT {\n-                Err(last_error())\n-            } else {\n-                Ok(Event(event))\n-            }\n-        }\n-\n-        pub fn handle(&self) -> c::WSAEVENT { let Event(handle) = *self; handle }\n-    }\n-\n-    impl Drop for Event {\n-        fn drop(&mut self) {\n-            unsafe { let _ = c::WSACloseEvent(self.handle()); }\n-        }\n-    }\n-\n-    pub fn init() {\n-        unsafe {\n-            use std::rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-            static mut INITIALIZED: bool = false;\n-            static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-\n-            let _guard = LOCK.lock();\n-            if !INITIALIZED {\n-                let mut data: c::WSADATA = mem::zeroed();\n-                let ret = c::WSAStartup(0x202,      // version 2.2\n-                                        &mut data);\n-                assert_eq!(ret, 0);\n-                INITIALIZED = true;\n-            }\n-        }\n-    }\n-\n-    pub fn last_error() -> IoError {\n-        use std::os;\n-        let code = unsafe { c::WSAGetLastError() as uint };\n-        IoError {\n-            code: code,\n-            extra: 0,\n-            detail: Some(os::error_string(code)),\n+impl Clone for UdpSocket {\n+    fn clone(&self) -> UdpSocket {\n+        UdpSocket {\n+            inner: self.inner.clone(),\n+            read_deadline: 0,\n+            write_deadline: 0,\n         }\n     }\n-\n-    pub unsafe fn close(sock: sock_t) { let _ = libc::closesocket(sock); }\n-}\n-\n-#[cfg(unix)]\n-mod os {\n-    use libc;\n-    use std::rt::rtio::IoError;\n-    use io;\n-\n-    pub type sock_t = io::file::fd_t;\n-\n-    pub fn init() {}\n-    pub fn last_error() -> IoError { io::last_error() }\n-    pub unsafe fn close(sock: sock_t) { let _ = libc::close(sock); }\n }", "previous_filename": "src/libnative/io/net.rs"}, {"sha": "e76f2a2b872db2211a8da1881e2d7e1cc6853901", "filename": "src/libstd/sys/unix/c.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -11,6 +11,7 @@\n //! C definitions used by libnative that don't belong in liblibc\n \n #![allow(dead_code)]\n+#![allow(non_camel_case_types)]\n \n pub use self::select::fd_set;\n pub use self::signal::{sigaction, siginfo, sigset_t};\n@@ -106,7 +107,7 @@ mod select {\n           target_os = \"dragonfly\",\n           target_os = \"linux\"))]\n mod select {\n-    use std::uint;\n+    use uint;\n     use libc;\n \n     pub const FD_SETSIZE: uint = 1024;", "previous_filename": "src/libnative/io/c_unix.rs"}, {"sha": "2d02c34e958c6394d064b0510f65e2061d29852d", "filename": "src/libstd/sys/unix/fs.rs", "status": "added", "additions": 392, "deletions": 0, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -0,0 +1,392 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Blocking posix-based file I/O\n+\n+use libc::{mod, c_int, c_void};\n+use c_str::CString;\n+use mem;\n+use io;\n+\n+use prelude::*;\n+\n+use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n+use io::{IoResult, FileStat, SeekStyle, Reader};\n+use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n+use result::{Ok, Err};\n+use sys::retry;\n+use sys_common::{keep_going, eof, mkerr_libc};\n+\n+pub use path::PosixPath as Path;\n+\n+pub type fd_t = libc::c_int;\n+\n+pub struct FileDesc {\n+    /// The underlying C file descriptor.\n+    fd: fd_t,\n+\n+    /// Whether to close the file descriptor on drop.\n+    close_on_drop: bool,\n+}\n+\n+impl FileDesc {\n+    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n+        FileDesc { fd: fd, close_on_drop: close_on_drop }\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> IoResult<uint> {\n+        let ret = retry(|| unsafe {\n+            libc::read(self.fd(),\n+                       buf.as_mut_ptr() as *mut libc::c_void,\n+                       buf.len() as libc::size_t)\n+        });\n+        if ret == 0 {\n+            Err(eof())\n+        } else if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(ret as uint)\n+        }\n+    }\n+    pub fn write(&self, buf: &[u8]) -> IoResult<()> {\n+        let ret = keep_going(buf, |buf, len| {\n+            unsafe {\n+                libc::write(self.fd(), buf as *const libc::c_void,\n+                            len as libc::size_t) as i64\n+            }\n+        });\n+        if ret < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    pub fn fd(&self) -> fd_t { self.fd }\n+\n+    pub fn seek(&self, pos: i64, whence: SeekStyle) -> IoResult<u64> {\n+        let whence = match whence {\n+            SeekSet => libc::SEEK_SET,\n+            SeekEnd => libc::SEEK_END,\n+            SeekCur => libc::SEEK_CUR,\n+        };\n+        let n = unsafe { libc::lseek(self.fd(), pos as libc::off_t, whence) };\n+        if n < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(n as u64)\n+        }\n+    }\n+\n+    pub fn tell(&self) -> IoResult<u64> {\n+        let n = unsafe { libc::lseek(self.fd(), 0, libc::SEEK_CUR) };\n+        if n < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(n as u64)\n+        }\n+    }\n+\n+    pub fn fsync(&self) -> IoResult<()> {\n+        mkerr_libc(retry(|| unsafe { libc::fsync(self.fd()) }))\n+    }\n+\n+    pub fn datasync(&self) -> IoResult<()> {\n+        return mkerr_libc(os_datasync(self.fd()));\n+\n+        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+        fn os_datasync(fd: c_int) -> c_int {\n+            unsafe { libc::fcntl(fd, libc::F_FULLFSYNC) }\n+        }\n+        #[cfg(target_os = \"linux\")]\n+        fn os_datasync(fd: c_int) -> c_int {\n+            retry(|| unsafe { libc::fdatasync(fd) })\n+        }\n+        #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"linux\")))]\n+        fn os_datasync(fd: c_int) -> c_int {\n+            retry(|| unsafe { libc::fsync(fd) })\n+        }\n+    }\n+\n+    pub fn truncate(&self, offset: i64) -> IoResult<()> {\n+        mkerr_libc(retry(|| unsafe {\n+            libc::ftruncate(self.fd(), offset as libc::off_t)\n+        }))\n+    }\n+\n+    pub fn fstat(&self) -> IoResult<FileStat> {\n+        let mut stat: libc::stat = unsafe { mem::zeroed() };\n+        match unsafe { libc::fstat(self.fd(), &mut stat) } {\n+            0 => Ok(mkstat(&stat)),\n+            _ => Err(super::last_error()),\n+        }\n+    }\n+\n+    /// Extract the actual filedescriptor without closing it.\n+    pub fn unwrap(self) -> fd_t {\n+        let fd = self.fd;\n+        unsafe { mem::forget(self) };\n+        fd\n+    }\n+}\n+\n+impl Drop for FileDesc {\n+    fn drop(&mut self) {\n+        // closing stdio file handles makes no sense, so never do it. Also, note\n+        // that errors are ignored when closing a file descriptor. The reason\n+        // for this is that if an error occurs we don't actually know if the\n+        // file descriptor was closed or not, and if we retried (for something\n+        // like EINTR), we might close another valid file descriptor (opened\n+        // after we closed ours.\n+        if self.close_on_drop && self.fd > libc::STDERR_FILENO {\n+            let n = unsafe { libc::close(self.fd) };\n+            if n != 0 {\n+                println!(\"error {} when closing file descriptor {}\", n, self.fd);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> {\n+    let flags = match fm {\n+        Open => 0,\n+        Append => libc::O_APPEND,\n+        Truncate => libc::O_TRUNC,\n+    };\n+    // Opening with a write permission must silently create the file.\n+    let (flags, mode) = match fa {\n+        Read => (flags | libc::O_RDONLY, 0),\n+        Write => (flags | libc::O_WRONLY | libc::O_CREAT,\n+                        libc::S_IRUSR | libc::S_IWUSR),\n+        ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n+                            libc::S_IRUSR | libc::S_IWUSR),\n+    };\n+\n+    let path = path.to_c_str();\n+    match retry(|| unsafe { libc::open(path.as_ptr(), flags, mode) }) {\n+        -1 => Err(super::last_error()),\n+        fd => Ok(FileDesc::new(fd, true)),\n+    }\n+}\n+\n+pub fn mkdir(p: &Path, mode: uint) -> IoResult<()> {\n+    let p = p.to_c_str();\n+    mkerr_libc(unsafe { libc::mkdir(p.as_ptr(), mode as libc::mode_t) })\n+}\n+\n+pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n+    use libc::{dirent_t};\n+    use libc::{opendir, readdir_r, closedir};\n+\n+    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<Path> {\n+        let root = unsafe { CString::new(root.as_ptr(), false) };\n+        let root = Path::new(root);\n+\n+        dirs.into_iter().filter(|path| {\n+            path.as_vec() != b\".\" && path.as_vec() != b\"..\"\n+        }).map(|path| root.join(path)).collect()\n+    }\n+\n+    extern {\n+        fn rust_dirent_t_size() -> libc::c_int;\n+        fn rust_list_dir_val(ptr: *mut dirent_t) -> *const libc::c_char;\n+    }\n+\n+    let size = unsafe { rust_dirent_t_size() };\n+    let mut buf = Vec::<u8>::with_capacity(size as uint);\n+    let ptr = buf.as_mut_slice().as_mut_ptr() as *mut dirent_t;\n+\n+    let p = p.to_c_str();\n+    let dir_ptr = unsafe {opendir(p.as_ptr())};\n+\n+    if dir_ptr as uint != 0 {\n+        let mut paths = vec!();\n+        let mut entry_ptr = 0 as *mut dirent_t;\n+        while unsafe { readdir_r(dir_ptr, ptr, &mut entry_ptr) == 0 } {\n+            if entry_ptr.is_null() { break }\n+            let cstr = unsafe {\n+                CString::new(rust_list_dir_val(entry_ptr), false)\n+            };\n+            paths.push(Path::new(cstr));\n+        }\n+        assert_eq!(unsafe { closedir(dir_ptr) }, 0);\n+        Ok(prune(&p, paths))\n+    } else {\n+        Err(super::last_error())\n+    }\n+}\n+\n+pub fn unlink(p: &Path) -> IoResult<()> {\n+    let p = p.to_c_str();\n+    mkerr_libc(unsafe { libc::unlink(p.as_ptr()) })\n+}\n+\n+pub fn rename(old: &Path, new: &Path) -> IoResult<()> {\n+    let old = old.to_c_str();\n+    let new = new.to_c_str();\n+    mkerr_libc(unsafe {\n+        libc::rename(old.as_ptr(), new.as_ptr())\n+    })\n+}\n+\n+pub fn chmod(p: &Path, mode: uint) -> IoResult<()> {\n+    let p = p.to_c_str();\n+    mkerr_libc(retry(|| unsafe {\n+        libc::chmod(p.as_ptr(), mode as libc::mode_t)\n+    }))\n+}\n+\n+pub fn rmdir(p: &Path) -> IoResult<()> {\n+    let p = p.to_c_str();\n+    mkerr_libc(unsafe { libc::rmdir(p.as_ptr()) })\n+}\n+\n+pub fn chown(p: &Path, uid: int, gid: int) -> IoResult<()> {\n+    let p = p.to_c_str();\n+    mkerr_libc(retry(|| unsafe {\n+        libc::chown(p.as_ptr(), uid as libc::uid_t, gid as libc::gid_t)\n+    }))\n+}\n+\n+pub fn readlink(p: &Path) -> IoResult<Path> {\n+    let c_path = p.to_c_str();\n+    let p = c_path.as_ptr();\n+    let mut len = unsafe { libc::pathconf(p as *mut _, libc::_PC_NAME_MAX) };\n+    if len == -1 {\n+        len = 1024; // FIXME: read PATH_MAX from C ffi?\n+    }\n+    let mut buf: Vec<u8> = Vec::with_capacity(len as uint);\n+    match unsafe {\n+        libc::readlink(p, buf.as_ptr() as *mut libc::c_char,\n+                       len as libc::size_t) as libc::c_int\n+    } {\n+        -1 => Err(super::last_error()),\n+        n => {\n+            assert!(n > 0);\n+            unsafe { buf.set_len(n as uint); }\n+            Ok(Path::new(buf))\n+        }\n+    }\n+}\n+\n+pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n+    let src = src.to_c_str();\n+    let dst = dst.to_c_str();\n+    mkerr_libc(unsafe { libc::symlink(src.as_ptr(), dst.as_ptr()) })\n+}\n+\n+pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n+    let src = src.to_c_str();\n+    let dst = dst.to_c_str();\n+    mkerr_libc(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })\n+}\n+\n+fn mkstat(stat: &libc::stat) -> FileStat {\n+    // FileStat times are in milliseconds\n+    fn mktime(secs: u64, nsecs: u64) -> u64 { secs * 1000 + nsecs / 1000000 }\n+\n+    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+    fn flags(stat: &libc::stat) -> u64 { stat.st_flags as u64 }\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    fn flags(_stat: &libc::stat) -> u64 { 0 }\n+\n+    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+    fn gen(stat: &libc::stat) -> u64 { stat.st_gen as u64 }\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    fn gen(_stat: &libc::stat) -> u64 { 0 }\n+\n+    FileStat {\n+        size: stat.st_size as u64,\n+        kind: match (stat.st_mode as libc::mode_t) & libc::S_IFMT {\n+            libc::S_IFREG => io::TypeFile,\n+            libc::S_IFDIR => io::TypeDirectory,\n+            libc::S_IFIFO => io::TypeNamedPipe,\n+            libc::S_IFBLK => io::TypeBlockSpecial,\n+            libc::S_IFLNK => io::TypeSymlink,\n+            _ => io::TypeUnknown,\n+        },\n+        perm: FilePermission::from_bits_truncate(stat.st_mode as u32),\n+        created: mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64),\n+        modified: mktime(stat.st_mtime as u64, stat.st_mtime_nsec as u64),\n+        accessed: mktime(stat.st_atime as u64, stat.st_atime_nsec as u64),\n+        unstable: UnstableFileStat {\n+            device: stat.st_dev as u64,\n+            inode: stat.st_ino as u64,\n+            rdev: stat.st_rdev as u64,\n+            nlink: stat.st_nlink as u64,\n+            uid: stat.st_uid as u64,\n+            gid: stat.st_gid as u64,\n+            blksize: stat.st_blksize as u64,\n+            blocks: stat.st_blocks as u64,\n+            flags: flags(stat),\n+            gen: gen(stat),\n+        },\n+    }\n+}\n+\n+pub fn stat(p: &Path) -> IoResult<FileStat> {\n+    let p = p.to_c_str();\n+    let mut stat: libc::stat = unsafe { mem::zeroed() };\n+    match unsafe { libc::stat(p.as_ptr(), &mut stat) } {\n+        0 => Ok(mkstat(&stat)),\n+        _ => Err(super::last_error()),\n+    }\n+}\n+\n+pub fn lstat(p: &Path) -> IoResult<FileStat> {\n+    let p = p.to_c_str();\n+    let mut stat: libc::stat = unsafe { mem::zeroed() };\n+    match unsafe { libc::lstat(p.as_ptr(), &mut stat) } {\n+        0 => Ok(mkstat(&stat)),\n+        _ => Err(super::last_error()),\n+    }\n+}\n+\n+pub fn utime(p: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n+    let p = p.to_c_str();\n+    let buf = libc::utimbuf {\n+        actime: (atime / 1000) as libc::time_t,\n+        modtime: (mtime / 1000) as libc::time_t,\n+    };\n+    mkerr_libc(unsafe { libc::utime(p.as_ptr(), &buf) })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::FileDesc;\n+    use libc;\n+    use os;\n+    use prelude::*;\n+\n+    #[cfg_attr(target_os = \"freebsd\", ignore)] // hmm, maybe pipes have a tiny buffer\n+    #[test]\n+    fn test_file_desc() {\n+        // Run this test with some pipes so we don't have to mess around with\n+        // opening or closing files.\n+        let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n+        let mut reader = FileDesc::new(reader, true);\n+        let mut writer = FileDesc::new(writer, true);\n+\n+        writer.write(b\"test\").ok().unwrap();\n+        let mut buf = [0u8, ..4];\n+        match reader.read(buf) {\n+            Ok(4) => {\n+                assert_eq!(buf[0], 't' as u8);\n+                assert_eq!(buf[1], 'e' as u8);\n+                assert_eq!(buf[2], 's' as u8);\n+                assert_eq!(buf[3], 't' as u8);\n+            }\n+            r => panic!(\"invalid read: {}\", r),\n+        }\n+\n+        assert!(writer.read(buf).is_err());\n+        assert!(reader.write(buf).is_err());\n+    }\n+}"}, {"sha": "a806bea2568d2512859f77d5dfd1ffd8d92826bf", "filename": "src/libstd/sys/unix/helper_signal.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc;\n+use os;\n+\n+use sys::fs::FileDesc;\n+\n+pub type signal = libc::c_int;\n+\n+pub fn new() -> (signal, signal) {\n+    let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n+    (reader, writer)\n+}\n+\n+pub fn signal(fd: libc::c_int) {\n+    FileDesc::new(fd, false).write([0]).ok().unwrap();\n+}\n+\n+pub fn close(fd: libc::c_int) {\n+    let _fd = FileDesc::new(fd, true);\n+}"}, {"sha": "d3f55d59534d37c27f6dd9336568150149c66fee", "filename": "src/libstd/sys/unix/mod.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -0,0 +1,146 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(missing_doc)]\n+#![allow(non_camel_case_types)]\n+#![allow(unused_imports)]\n+#![allow(dead_code)]\n+#![allow(unused_unsafe)]\n+#![allow(unused_mut)]\n+\n+extern crate libc;\n+\n+use num;\n+use prelude::*;\n+use io::{mod, IoResult, IoError};\n+use sys_common::mkerr_libc;\n+\n+macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n+    static $name: Helper<$m> = Helper {\n+        lock: ::rt::mutex::NATIVE_MUTEX_INIT,\n+        chan: ::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n+        signal: ::cell::UnsafeCell { value: 0 },\n+        initialized: ::cell::UnsafeCell { value: false },\n+    };\n+) )\n+\n+pub mod c;\n+pub mod fs;\n+pub mod os;\n+pub mod tcp;\n+pub mod udp;\n+pub mod pipe;\n+pub mod helper_signal;\n+pub mod process;\n+pub mod timer;\n+pub mod tty;\n+\n+pub mod addrinfo {\n+    pub use sys_common::net::get_host_addresses;\n+}\n+\n+// FIXME: move these to c module\n+pub type sock_t = self::fs::fd_t;\n+pub type wrlen = libc::size_t;\n+pub type msglen_t = libc::size_t;\n+pub unsafe fn close_sock(sock: sock_t) { let _ = libc::close(sock); }\n+\n+pub fn last_error() -> IoError {\n+    decode_error_detailed(os::errno() as i32)\n+}\n+\n+pub fn last_net_error() -> IoError {\n+    last_error()\n+}\n+\n+extern \"system\" {\n+    fn gai_strerror(errcode: libc::c_int) -> *const libc::c_char;\n+}\n+\n+pub fn last_gai_error(s: libc::c_int) -> IoError {\n+    use c_str::CString;\n+\n+    let mut err = decode_error(s);\n+    err.detail = Some(unsafe {\n+        CString::new(gai_strerror(s), false).as_str().unwrap().to_string()\n+    });\n+    err\n+}\n+\n+/// Convert an `errno` value into a high-level error variant and description.\n+pub fn decode_error(errno: i32) -> IoError {\n+    // FIXME: this should probably be a bit more descriptive...\n+    let (kind, desc) = match errno {\n+        libc::EOF => (io::EndOfFile, \"end of file\"),\n+        libc::ECONNREFUSED => (io::ConnectionRefused, \"connection refused\"),\n+        libc::ECONNRESET => (io::ConnectionReset, \"connection reset\"),\n+        libc::EPERM | libc::EACCES =>\n+            (io::PermissionDenied, \"permission denied\"),\n+        libc::EPIPE => (io::BrokenPipe, \"broken pipe\"),\n+        libc::ENOTCONN => (io::NotConnected, \"not connected\"),\n+        libc::ECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n+        libc::EADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n+        libc::EADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n+        libc::ENOENT => (io::FileNotFound, \"no such file or directory\"),\n+        libc::EISDIR => (io::InvalidInput, \"illegal operation on a directory\"),\n+        libc::ENOSYS => (io::IoUnavailable, \"function not implemented\"),\n+        libc::EINVAL => (io::InvalidInput, \"invalid argument\"),\n+        libc::ENOTTY =>\n+            (io::MismatchedFileTypeForOperation,\n+             \"file descriptor is not a TTY\"),\n+        libc::ETIMEDOUT => (io::TimedOut, \"operation timed out\"),\n+        libc::ECANCELED => (io::TimedOut, \"operation aborted\"),\n+\n+        // These two constants can have the same value on some systems,\n+        // but different values on others, so we can't use a match\n+        // clause\n+        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n+            (io::ResourceUnavailable, \"resource temporarily unavailable\"),\n+\n+        _ => (io::OtherIoError, \"unknown error\")\n+    };\n+    IoError { kind: kind, desc: desc, detail: None }\n+}\n+\n+pub fn decode_error_detailed(errno: i32) -> IoError {\n+    let mut err = decode_error(errno);\n+    err.detail = Some(os::error_string(errno));\n+    err\n+}\n+\n+#[inline]\n+pub fn retry<I: PartialEq + num::One + Neg<I>> (f: || -> I) -> I {\n+    let minus_one = -num::one::<I>();\n+    loop {\n+        let n = f();\n+        if n == minus_one && os::errno() == libc::EINTR as int { }\n+        else { return n }\n+    }\n+}\n+\n+pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n+    libc::timeval {\n+        tv_sec: (ms / 1000) as libc::time_t,\n+        tv_usec: ((ms % 1000) * 1000) as libc::suseconds_t,\n+    }\n+}\n+\n+pub fn wouldblock() -> bool {\n+    let err = os::errno();\n+    err == libc::EWOULDBLOCK as int || err == libc::EAGAIN as int\n+}\n+\n+pub fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> {\n+    let set = nb as libc::c_int;\n+    mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) }))\n+}\n+\n+// nothing needed on unix platforms\n+pub fn init_net() {}"}, {"sha": "4e495f043bc63c8a04331b9e42f869946002c6b6", "filename": "src/libstd/sys/unix/os.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc;\n+use libc::{c_int, c_char};\n+use prelude::*;\n+use io::IoResult;\n+use sys::fs::FileDesc;\n+\n+use os::TMPBUF_SZ;\n+\n+/// Returns the platform-specific value of errno\n+pub fn errno() -> int {\n+    #[cfg(any(target_os = \"macos\",\n+              target_os = \"ios\",\n+              target_os = \"freebsd\"))]\n+    fn errno_location() -> *const c_int {\n+        extern {\n+            fn __error() -> *const c_int;\n+        }\n+        unsafe {\n+            __error()\n+        }\n+    }\n+\n+    #[cfg(target_os = \"dragonfly\")]\n+    fn errno_location() -> *const c_int {\n+        extern {\n+            fn __dfly_error() -> *const c_int;\n+        }\n+        unsafe {\n+            __dfly_error()\n+        }\n+    }\n+\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    fn errno_location() -> *const c_int {\n+        extern {\n+            fn __errno_location() -> *const c_int;\n+        }\n+        unsafe {\n+            __errno_location()\n+        }\n+    }\n+\n+    unsafe {\n+        (*errno_location()) as int\n+    }\n+}\n+\n+/// Get a detailed string description for the given error number\n+pub fn error_string(errno: i32) -> String {\n+    #[cfg(any(target_os = \"macos\",\n+              target_os = \"ios\",\n+              target_os = \"android\",\n+              target_os = \"freebsd\",\n+              target_os = \"dragonfly\"))]\n+    fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t)\n+                  -> c_int {\n+        extern {\n+            fn strerror_r(errnum: c_int, buf: *mut c_char,\n+                          buflen: libc::size_t) -> c_int;\n+        }\n+        unsafe {\n+            strerror_r(errnum, buf, buflen)\n+        }\n+    }\n+\n+    // GNU libc provides a non-compliant version of strerror_r by default\n+    // and requires macros to instead use the POSIX compliant variant.\n+    // So we just use __xpg_strerror_r which is always POSIX compliant\n+    #[cfg(target_os = \"linux\")]\n+    fn strerror_r(errnum: c_int, buf: *mut c_char,\n+                  buflen: libc::size_t) -> c_int {\n+        extern {\n+            fn __xpg_strerror_r(errnum: c_int,\n+                                buf: *mut c_char,\n+                                buflen: libc::size_t)\n+                                -> c_int;\n+        }\n+        unsafe {\n+            __xpg_strerror_r(errnum, buf, buflen)\n+        }\n+    }\n+\n+    let mut buf = [0 as c_char, ..TMPBUF_SZ];\n+\n+    let p = buf.as_mut_ptr();\n+    unsafe {\n+        if strerror_r(errno as c_int, p, buf.len() as libc::size_t) < 0 {\n+            panic!(\"strerror_r failure\");\n+        }\n+\n+        ::string::raw::from_buf(p as *const u8)\n+    }\n+}\n+\n+pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n+    let mut fds = [0, ..2];\n+    if libc::pipe(fds.as_mut_ptr()) == 0 {\n+        Ok((FileDesc::new(fds[0], true), FileDesc::new(fds[1], true)))\n+    } else {\n+        Err(super::last_error())\n+    }\n+}"}, {"sha": "67384848a9449af233eb00fee617fbbe2859dbcb", "filename": "src/libstd/sys/unix/pipe.rs", "status": "renamed", "additions": 64, "deletions": 82, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -10,19 +10,17 @@\n \n use alloc::arc::Arc;\n use libc;\n-use std::c_str::CString;\n-use std::mem;\n-use std::rt::mutex;\n-use std::rt::rtio;\n-use std::rt::rtio::{IoResult, IoError};\n-use std::sync::atomic;\n-\n-use super::retry;\n-use super::net;\n-use super::util;\n-use super::c;\n-use super::process;\n-use super::file::{fd_t, FileDesc};\n+use c_str::CString;\n+use mem;\n+use rt::mutex;\n+use sync::atomic;\n+use io::{mod, IoResult, IoError};\n+use prelude::*;\n+\n+use sys::{mod, timer, retry, c, set_nonblocking, wouldblock};\n+use sys::fs::{fd_t, FileDesc};\n+use sys_common::net::*;\n+use sys_common::{eof, mkerr_libc};\n \n fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> {\n     match unsafe { libc::socket(libc::AF_UNIX, ty, 0) } {\n@@ -41,12 +39,10 @@ fn addr_to_sockaddr_un(addr: &CString,\n \n     let len = addr.len();\n     if len > s.sun_path.len() - 1 {\n-        #[cfg(unix)] use libc::EINVAL as ERROR;\n-        #[cfg(windows)] use libc::WSAEINVAL as ERROR;\n         return Err(IoError {\n-            code: ERROR as uint,\n-            extra: 0,\n-            detail: Some(\"path must be smaller than SUN_LEN\".to_string()),\n+            kind: io::InvalidInput,\n+            desc: \"invalid argument: path must be smaller than SUN_LEN\",\n+            detail: None,\n         })\n     }\n     s.sun_family = libc::AF_UNIX as libc::sa_family_t;\n@@ -92,7 +88,7 @@ fn connect(addr: &CString, ty: libc::c_int,\n             }\n         }\n         Some(timeout_ms) => {\n-            try!(util::connect_timeout(inner.fd, addrp, len, timeout_ms));\n+            try!(connect_timeout(inner.fd, addrp, len, timeout_ms));\n             Ok(inner)\n         }\n     }\n@@ -143,18 +139,16 @@ impl UnixStream {\n     fn lock_nonblocking(&self) {}\n \n     #[cfg(not(target_os = \"linux\"))]\n-    fn lock_nonblocking<'a>(&'a self) -> net::Guard<'a> {\n-        let ret = net::Guard {\n+    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n+        let ret = Guard {\n             fd: self.fd(),\n             guard: unsafe { self.inner.lock.lock() },\n         };\n-        assert!(util::set_nonblocking(self.fd(), true).is_ok());\n+        assert!(set_nonblocking(self.fd(), true).is_ok());\n         ret\n     }\n-}\n \n-impl rtio::RtioPipe for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n         let doread = |nb| unsafe {\n@@ -164,10 +158,10 @@ impl rtio::RtioPipe for UnixStream {\n                        buf.len() as libc::size_t,\n                        flags) as libc::c_int\n         };\n-        net::read(fd, self.read_deadline, dolock, doread)\n+        read(fd, self.read_deadline, dolock, doread)\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n         let dowrite = |nb: bool, buf: *const u8, len: uint| unsafe {\n@@ -177,32 +171,38 @@ impl rtio::RtioPipe for UnixStream {\n                        len as libc::size_t,\n                        flags) as i64\n         };\n-        match net::write(fd, self.write_deadline, buf, true, dolock, dowrite) {\n+        match write(fd, self.write_deadline, buf, true, dolock, dowrite) {\n             Ok(_) => Ok(()),\n             Err(e) => Err(e)\n         }\n     }\n \n-    fn clone(&self) -> Box<rtio::RtioPipe + Send> {\n-        box UnixStream::new(self.inner.clone()) as Box<rtio::RtioPipe + Send>\n+    pub fn close_write(&mut self) -> IoResult<()> {\n+        mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_WR) })\n     }\n \n-    fn close_write(&mut self) -> IoResult<()> {\n-        super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_WR) })\n-    }\n-    fn close_read(&mut self) -> IoResult<()> {\n-        super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_RD) })\n+    pub fn close_read(&mut self) -> IoResult<()> {\n+        mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_RD) })\n     }\n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        let deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+\n+    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n         self.read_deadline = deadline;\n         self.write_deadline = deadline;\n     }\n-    fn set_read_timeout(&mut self, timeout: Option<u64>) {\n-        self.read_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+\n+    pub fn set_read_timeout(&mut self, timeout: Option<u64>) {\n+        self.read_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n+    }\n+\n+    pub fn set_write_timeout(&mut self, timeout: Option<u64>) {\n+        self.write_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }\n-    fn set_write_timeout(&mut self, timeout: Option<u64>) {\n-        self.write_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+}\n+\n+impl Clone for UnixStream {\n+    fn clone(&self) -> UnixStream {\n+        UnixStream::new(self.inner.clone())\n     }\n }\n \n@@ -224,16 +224,15 @@ impl UnixListener {\n \n     fn fd(&self) -> fd_t { self.inner.fd }\n \n-    pub fn native_listen(self, backlog: int) -> IoResult<UnixAcceptor> {\n-        match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n+    pub fn listen(self) -> IoResult<UnixAcceptor> {\n+        match unsafe { libc::listen(self.fd(), 128) } {\n             -1 => Err(super::last_error()),\n \n-            #[cfg(unix)]\n             _ => {\n-                let (reader, writer) = try!(process::pipe());\n-                try!(util::set_nonblocking(reader.fd(), true));\n-                try!(util::set_nonblocking(writer.fd(), true));\n-                try!(util::set_nonblocking(self.fd(), true));\n+                let (reader, writer) = try!(unsafe { sys::os::pipe() });\n+                try!(set_nonblocking(reader.fd(), true));\n+                try!(set_nonblocking(writer.fd(), true));\n+                try!(set_nonblocking(self.fd(), true));\n                 Ok(UnixAcceptor {\n                     inner: Arc::new(AcceptorInner {\n                         listener: self,\n@@ -248,21 +247,11 @@ impl UnixListener {\n     }\n }\n \n-impl rtio::RtioUnixListener for UnixListener {\n-    fn listen(self: Box<UnixListener>)\n-              -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n-        self.native_listen(128).map(|a| {\n-            box a as Box<rtio::RtioUnixAcceptor + Send>\n-        })\n-    }\n-}\n-\n pub struct UnixAcceptor {\n     inner: Arc<AcceptorInner>,\n     deadline: u64,\n }\n \n-#[cfg(unix)]\n struct AcceptorInner {\n     listener: UnixListener,\n     reader: FileDesc,\n@@ -273,7 +262,7 @@ struct AcceptorInner {\n impl UnixAcceptor {\n     fn fd(&self) -> fd_t { self.inner.listener.fd() }\n \n-    pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n+    pub fn accept(&mut self) -> IoResult<UnixStream> {\n         let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n \n         while !self.inner.closed.load(atomic::SeqCst) {\n@@ -287,46 +276,39 @@ impl UnixAcceptor {\n                                  storagep as *mut libc::sockaddr,\n                                  &mut size as *mut libc::socklen_t) as libc::c_int\n                 }) {\n-                    -1 if util::wouldblock() => {}\n+                    -1 if wouldblock() => {}\n                     -1 => return Err(super::last_error()),\n                     fd => return Ok(UnixStream::new(Arc::new(Inner::new(fd)))),\n                 }\n             }\n-            try!(util::await([self.fd(), self.inner.reader.fd()],\n-                             deadline, util::Readable));\n+            try!(await([self.fd(), self.inner.reader.fd()],\n+                             deadline, Readable));\n         }\n \n-        Err(util::eof())\n+        Err(eof())\n     }\n-}\n \n-impl rtio::RtioUnixAcceptor for UnixAcceptor {\n-    fn accept(&mut self) -> IoResult<Box<rtio::RtioPipe + Send>> {\n-        self.native_accept().map(|s| box s as Box<rtio::RtioPipe + Send>)\n-    }\n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        self.deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n+        self.deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }\n \n-    fn clone(&self) -> Box<rtio::RtioUnixAcceptor + Send> {\n-        box UnixAcceptor {\n-            inner: self.inner.clone(),\n-            deadline: 0,\n-        } as Box<rtio::RtioUnixAcceptor + Send>\n-    }\n-\n-    #[cfg(unix)]\n-    fn close_accept(&mut self) -> IoResult<()> {\n+    pub fn close_accept(&mut self) -> IoResult<()> {\n         self.inner.closed.store(true, atomic::SeqCst);\n-        let mut fd = FileDesc::new(self.inner.writer.fd(), false);\n-        match fd.inner_write([0]) {\n+        let fd = FileDesc::new(self.inner.writer.fd(), false);\n+        match fd.write([0]) {\n             Ok(..) => Ok(()),\n-            Err(..) if util::wouldblock() => Ok(()),\n+            Err(..) if wouldblock() => Ok(()),\n             Err(e) => Err(e),\n         }\n     }\n }\n \n+impl Clone for UnixAcceptor {\n+    fn clone(&self) -> UnixAcceptor {\n+        UnixAcceptor { inner: self.inner.clone(), deadline: 0 }\n+    }\n+}\n+\n impl Drop for UnixListener {\n     fn drop(&mut self) {\n         // Unlink the path to the socket to ensure that it doesn't linger. We're", "previous_filename": "src/libnative/io/pipe_unix.rs"}, {"sha": "0965d98d9b033e33fb1b34a380ad99e6bcbffbf6", "filename": "src/libstd/sys/unix/process.rs", "status": "added", "additions": 587, "deletions": 0, "changes": 587, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -0,0 +1,587 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::{mod, pid_t, c_void, c_int};\n+use c_str::CString;\n+use io::{mod, IoResult, IoError};\n+use mem;\n+use os;\n+use ptr;\n+use prelude::*;\n+use io::process::{ProcessExit, ExitStatus, ExitSignal};\n+use collections;\n+use path::BytesContainer;\n+use hash::Hash;\n+\n+use sys::{mod, retry, c, wouldblock, set_nonblocking, ms_to_timeval};\n+use sys::fs::FileDesc;\n+use sys_common::helper_thread::Helper;\n+use sys_common::{AsFileDesc, mkerr_libc, timeout};\n+\n+pub use sys_common::ProcessConfig;\n+\n+helper_init!(static HELPER: Helper<Req>)\n+\n+/// The unique id of the process (this should never be negative).\n+pub struct Process {\n+    pub pid: pid_t\n+}\n+\n+enum Req {\n+    NewChild(libc::pid_t, Sender<ProcessExit>, u64),\n+}\n+\n+impl Process {\n+    pub fn id(&self) -> pid_t {\n+        self.pid\n+    }\n+\n+    pub unsafe fn kill(&self, signal: int) -> IoResult<()> {\n+        Process::killpid(self.pid, signal)\n+    }\n+\n+    pub unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> {\n+        let r = libc::funcs::posix88::signal::kill(pid, signal as c_int);\n+        mkerr_libc(r)\n+    }\n+\n+    pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n+                              out_fd: Option<P>, err_fd: Option<P>)\n+                              -> IoResult<Process>\n+        where C: ProcessConfig<K, V>, P: AsFileDesc,\n+              K: BytesContainer + Eq + Hash, V: BytesContainer\n+    {\n+        use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n+        use libc::funcs::bsd44::getdtablesize;\n+\n+        mod rustrt {\n+            extern {\n+                pub fn rust_unset_sigprocmask();\n+            }\n+        }\n+\n+        #[cfg(target_os = \"macos\")]\n+        unsafe fn set_environ(envp: *const c_void) {\n+            extern { fn _NSGetEnviron() -> *mut *const c_void; }\n+\n+            *_NSGetEnviron() = envp;\n+        }\n+        #[cfg(not(target_os = \"macos\"))]\n+        unsafe fn set_environ(envp: *const c_void) {\n+            extern { static mut environ: *const c_void; }\n+            environ = envp;\n+        }\n+\n+        unsafe fn set_cloexec(fd: c_int) {\n+            let ret = c::ioctl(fd, c::FIOCLEX);\n+            assert_eq!(ret, 0);\n+        }\n+\n+        let dirp = cfg.cwd().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n+\n+        // temporary until unboxed closures land\n+        let cfg = unsafe {\n+            mem::transmute::<&ProcessConfig<K,V>,&'static ProcessConfig<K,V>>(cfg)\n+        };\n+\n+        with_envp(cfg.env(), proc(envp) {\n+            with_argv(cfg.program(), cfg.args(), proc(argv) unsafe {\n+                let (input, mut output) = try!(sys::os::pipe());\n+\n+                // We may use this in the child, so perform allocations before the\n+                // fork\n+                let devnull = \"/dev/null\".to_c_str();\n+\n+                set_cloexec(output.fd());\n+\n+                let pid = fork();\n+                if pid < 0 {\n+                    return Err(super::last_error())\n+                } else if pid > 0 {\n+                    drop(output);\n+                    let mut bytes = [0, ..4];\n+                    return match input.read(bytes) {\n+                        Ok(4) => {\n+                            let errno = (bytes[0] as i32 << 24) |\n+                                        (bytes[1] as i32 << 16) |\n+                                        (bytes[2] as i32 <<  8) |\n+                                        (bytes[3] as i32 <<  0);\n+                            Err(super::decode_error(errno))\n+                        }\n+                        Err(..) => Ok(Process { pid: pid }),\n+                        Ok(..) => panic!(\"short read on the cloexec pipe\"),\n+                    };\n+                }\n+\n+                // And at this point we've reached a special time in the life of the\n+                // child. The child must now be considered hamstrung and unable to\n+                // do anything other than syscalls really. Consider the following\n+                // scenario:\n+                //\n+                //      1. Thread A of process 1 grabs the malloc() mutex\n+                //      2. Thread B of process 1 forks(), creating thread C\n+                //      3. Thread C of process 2 then attempts to malloc()\n+                //      4. The memory of process 2 is the same as the memory of\n+                //         process 1, so the mutex is locked.\n+                //\n+                // This situation looks a lot like deadlock, right? It turns out\n+                // that this is what pthread_atfork() takes care of, which is\n+                // presumably implemented across platforms. The first thing that\n+                // threads to *before* forking is to do things like grab the malloc\n+                // mutex, and then after the fork they unlock it.\n+                //\n+                // Despite this information, libnative's spawn has been witnessed to\n+                // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n+                // all collected backtraces point at malloc/free traffic in the\n+                // child spawned process.\n+                //\n+                // For this reason, the block of code below should contain 0\n+                // invocations of either malloc of free (or their related friends).\n+                //\n+                // As an example of not having malloc/free traffic, we don't close\n+                // this file descriptor by dropping the FileDesc (which contains an\n+                // allocation). Instead we just close it manually. This will never\n+                // have the drop glue anyway because this code never returns (the\n+                // child will either exec() or invoke libc::exit)\n+                let _ = libc::close(input.fd());\n+\n+                fn fail(output: &mut FileDesc) -> ! {\n+                    let errno = sys::os::errno();\n+                    let bytes = [\n+                        (errno >> 24) as u8,\n+                        (errno >> 16) as u8,\n+                        (errno >>  8) as u8,\n+                        (errno >>  0) as u8,\n+                    ];\n+                    assert!(output.write(bytes).is_ok());\n+                    unsafe { libc::_exit(1) }\n+                }\n+\n+                rustrt::rust_unset_sigprocmask();\n+\n+                // If a stdio file descriptor is set to be ignored (via a -1 file\n+                // descriptor), then we don't actually close it, but rather open\n+                // up /dev/null into that file descriptor. Otherwise, the first file\n+                // descriptor opened up in the child would be numbered as one of the\n+                // stdio file descriptors, which is likely to wreak havoc.\n+                let setup = |src: Option<P>, dst: c_int| {\n+                    let src = match src {\n+                        None => {\n+                            let flags = if dst == libc::STDIN_FILENO {\n+                                libc::O_RDONLY\n+                            } else {\n+                                libc::O_RDWR\n+                            };\n+                            libc::open(devnull.as_ptr(), flags, 0)\n+                        }\n+                        Some(obj) => {\n+                            let fd = obj.as_fd().fd();\n+                            // Leak the memory and the file descriptor. We're in the\n+                            // child now an all our resources are going to be\n+                            // cleaned up very soon\n+                            mem::forget(obj);\n+                            fd\n+                        }\n+                    };\n+                    src != -1 && retry(|| dup2(src, dst)) != -1\n+                };\n+\n+                if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n+                if !setup(out_fd, libc::STDOUT_FILENO) { fail(&mut output) }\n+                if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }\n+\n+                // close all other fds\n+                for fd in range(3, getdtablesize()).rev() {\n+                    if fd != output.fd() {\n+                        let _ = close(fd as c_int);\n+                    }\n+                }\n+\n+                match cfg.gid() {\n+                    Some(u) => {\n+                        if libc::setgid(u as libc::gid_t) != 0 {\n+                            fail(&mut output);\n+                        }\n+                    }\n+                    None => {}\n+                }\n+                match cfg.uid() {\n+                    Some(u) => {\n+                        // When dropping privileges from root, the `setgroups` call\n+                        // will remove any extraneous groups. If we don't call this,\n+                        // then even though our uid has dropped, we may still have\n+                        // groups that enable us to do super-user things. This will\n+                        // fail if we aren't root, so don't bother checking the\n+                        // return value, this is just done as an optimistic\n+                        // privilege dropping function.\n+                        extern {\n+                            fn setgroups(ngroups: libc::c_int,\n+                                         ptr: *const libc::c_void) -> libc::c_int;\n+                        }\n+                        let _ = setgroups(0, 0 as *const libc::c_void);\n+\n+                        if libc::setuid(u as libc::uid_t) != 0 {\n+                            fail(&mut output);\n+                        }\n+                    }\n+                    None => {}\n+                }\n+                if cfg.detach() {\n+                    // Don't check the error of setsid because it fails if we're the\n+                    // process leader already. We just forked so it shouldn't return\n+                    // error, but ignore it anyway.\n+                    let _ = libc::setsid();\n+                }\n+                if !dirp.is_null() && chdir(dirp) == -1 {\n+                    fail(&mut output);\n+                }\n+                if !envp.is_null() {\n+                    set_environ(envp);\n+                }\n+                let _ = execvp(*argv, argv as *mut _);\n+                fail(&mut output);\n+            })\n+        })\n+    }\n+\n+    pub fn wait(&self, deadline: u64) -> IoResult<ProcessExit> {\n+        use std::cmp;\n+        use std::comm;\n+\n+        static mut WRITE_FD: libc::c_int = 0;\n+\n+        let mut status = 0 as c_int;\n+        if deadline == 0 {\n+            return match retry(|| unsafe { c::waitpid(self.pid, &mut status, 0) }) {\n+                -1 => panic!(\"unknown waitpid error: {}\", super::last_error()),\n+                _ => Ok(translate_status(status)),\n+            }\n+        }\n+\n+        // On unix, wait() and its friends have no timeout parameters, so there is\n+        // no way to time out a thread in wait(). From some googling and some\n+        // thinking, it appears that there are a few ways to handle timeouts in\n+        // wait(), but the only real reasonable one for a multi-threaded program is\n+        // to listen for SIGCHLD.\n+        //\n+        // With this in mind, the waiting mechanism with a timeout barely uses\n+        // waitpid() at all. There are a few times that waitpid() is invoked with\n+        // WNOHANG, but otherwise all the necessary blocking is done by waiting for\n+        // a SIGCHLD to arrive (and that blocking has a timeout). Note, however,\n+        // that waitpid() is still used to actually reap the child.\n+        //\n+        // Signal handling is super tricky in general, and this is no exception. Due\n+        // to the async nature of SIGCHLD, we use the self-pipe trick to transmit\n+        // data out of the signal handler to the rest of the application. The first\n+        // idea would be to have each thread waiting with a timeout to read this\n+        // output file descriptor, but a write() is akin to a signal(), not a\n+        // broadcast(), so it would only wake up one thread, and possibly the wrong\n+        // thread. Hence a helper thread is used.\n+        //\n+        // The helper thread here is responsible for farming requests for a\n+        // waitpid() with a timeout, and then processing all of the wait requests.\n+        // By guaranteeing that only this helper thread is reading half of the\n+        // self-pipe, we're sure that we'll never lose a SIGCHLD. This helper thread\n+        // is also responsible for select() to wait for incoming messages or\n+        // incoming SIGCHLD messages, along with passing an appropriate timeout to\n+        // select() to wake things up as necessary.\n+        //\n+        // The ordering of the following statements is also very purposeful. First,\n+        // we must be guaranteed that the helper thread is booted and available to\n+        // receive SIGCHLD signals, and then we must also ensure that we do a\n+        // nonblocking waitpid() at least once before we go ask the sigchld helper.\n+        // This prevents the race where the child exits, we boot the helper, and\n+        // then we ask for the child's exit status (never seeing a sigchld).\n+        //\n+        // The actual communication between the helper thread and this thread is\n+        // quite simple, just a channel moving data around.\n+\n+        unsafe { HELPER.boot(register_sigchld, waitpid_helper) }\n+\n+        match self.try_wait() {\n+            Some(ret) => return Ok(ret),\n+            None => {}\n+        }\n+\n+        let (tx, rx) = channel();\n+        unsafe { HELPER.send(NewChild(self.pid, tx, deadline)); }\n+        return match rx.recv_opt() {\n+            Ok(e) => Ok(e),\n+            Err(()) => Err(timeout(\"wait timed out\")),\n+        };\n+\n+        // Register a new SIGCHLD handler, returning the reading half of the\n+        // self-pipe plus the old handler registered (return value of sigaction).\n+        //\n+        // Be sure to set up the self-pipe first because as soon as we register a\n+        // handler we're going to start receiving signals.\n+        fn register_sigchld() -> (libc::c_int, c::sigaction) {\n+            unsafe {\n+                let mut pipes = [0, ..2];\n+                assert_eq!(libc::pipe(pipes.as_mut_ptr()), 0);\n+                set_nonblocking(pipes[0], true).ok().unwrap();\n+                set_nonblocking(pipes[1], true).ok().unwrap();\n+                WRITE_FD = pipes[1];\n+\n+                let mut old: c::sigaction = mem::zeroed();\n+                let mut new: c::sigaction = mem::zeroed();\n+                new.sa_handler = sigchld_handler;\n+                new.sa_flags = c::SA_NOCLDSTOP;\n+                assert_eq!(c::sigaction(c::SIGCHLD, &new, &mut old), 0);\n+                (pipes[0], old)\n+            }\n+        }\n+\n+        // Helper thread for processing SIGCHLD messages\n+        fn waitpid_helper(input: libc::c_int,\n+                          messages: Receiver<Req>,\n+                          (read_fd, old): (libc::c_int, c::sigaction)) {\n+            set_nonblocking(input, true).ok().unwrap();\n+            let mut set: c::fd_set = unsafe { mem::zeroed() };\n+            let mut tv: libc::timeval;\n+            let mut active = Vec::<(libc::pid_t, Sender<ProcessExit>, u64)>::new();\n+            let max = cmp::max(input, read_fd) + 1;\n+\n+            'outer: loop {\n+                // Figure out the timeout of our syscall-to-happen. If we're waiting\n+                // for some processes, then they'll have a timeout, otherwise we\n+                // wait indefinitely for a message to arrive.\n+                //\n+                // FIXME: sure would be nice to not have to scan the entire array\n+                let min = active.iter().map(|a| *a.ref2()).enumerate().min_by(|p| {\n+                    p.val1()\n+                });\n+                let (p, idx) = match min {\n+                    Some((idx, deadline)) => {\n+                        let now = sys::timer::now();\n+                        let ms = if now < deadline {deadline - now} else {0};\n+                        tv = ms_to_timeval(ms);\n+                        (&mut tv as *mut _, idx)\n+                    }\n+                    None => (ptr::null_mut(), -1),\n+                };\n+\n+                // Wait for something to happen\n+                c::fd_set(&mut set, input);\n+                c::fd_set(&mut set, read_fd);\n+                match unsafe { c::select(max, &mut set, ptr::null_mut(),\n+                                         ptr::null_mut(), p) } {\n+                    // interrupted, retry\n+                    -1 if os::errno() == libc::EINTR as uint => continue,\n+\n+                    // We read something, break out and process\n+                    1 | 2 => {}\n+\n+                    // Timeout, the pending request is removed\n+                    0 => {\n+                        drop(active.remove(idx));\n+                        continue\n+                    }\n+\n+                    n => panic!(\"error in select {} ({})\", os::errno(), n),\n+                }\n+\n+                // Process any pending messages\n+                if drain(input) {\n+                    loop {\n+                        match messages.try_recv() {\n+                            Ok(NewChild(pid, tx, deadline)) => {\n+                                active.push((pid, tx, deadline));\n+                            }\n+                            Err(comm::Disconnected) => {\n+                                assert!(active.len() == 0);\n+                                break 'outer;\n+                            }\n+                            Err(comm::Empty) => break,\n+                        }\n+                    }\n+                }\n+\n+                // If a child exited (somehow received SIGCHLD), then poll all\n+                // children to see if any of them exited.\n+                //\n+                // We also attempt to be responsible netizens when dealing with\n+                // SIGCHLD by invoking any previous SIGCHLD handler instead of just\n+                // ignoring any previous SIGCHLD handler. Note that we don't provide\n+                // a 1:1 mapping of our handler invocations to the previous handler\n+                // invocations because we drain the `read_fd` entirely. This is\n+                // probably OK because the kernel is already allowed to coalesce\n+                // simultaneous signals, we're just doing some extra coalescing.\n+                //\n+                // Another point of note is that this likely runs the signal handler\n+                // on a different thread than the one that received the signal. I\n+                // *think* this is ok at this time.\n+                //\n+                // The main reason for doing this is to allow stdtest to run native\n+                // tests as well. Both libgreen and libnative are running around\n+                // with process timeouts, but libgreen should get there first\n+                // (currently libuv doesn't handle old signal handlers).\n+                if drain(read_fd) {\n+                    let i: uint = unsafe { mem::transmute(old.sa_handler) };\n+                    if i != 0 {\n+                        assert!(old.sa_flags & c::SA_SIGINFO == 0);\n+                        (old.sa_handler)(c::SIGCHLD);\n+                    }\n+\n+                    // FIXME: sure would be nice to not have to scan the entire\n+                    //        array...\n+                    active.retain(|&(pid, ref tx, _)| {\n+                        let pr = Process { pid: pid };\n+                        match pr.try_wait() {\n+                            Some(msg) => { tx.send(msg); false }\n+                            None => true,\n+                        }\n+                    });\n+                }\n+            }\n+\n+            // Once this helper thread is done, we re-register the old sigchld\n+            // handler and close our intermediate file descriptors.\n+            unsafe {\n+                assert_eq!(c::sigaction(c::SIGCHLD, &old, ptr::null_mut()), 0);\n+                let _ = libc::close(read_fd);\n+                let _ = libc::close(WRITE_FD);\n+                WRITE_FD = -1;\n+            }\n+        }\n+\n+        // Drain all pending data from the file descriptor, returning if any data\n+        // could be drained. This requires that the file descriptor is in\n+        // nonblocking mode.\n+        fn drain(fd: libc::c_int) -> bool {\n+            let mut ret = false;\n+            loop {\n+                let mut buf = [0u8, ..1];\n+                match unsafe {\n+                    libc::read(fd, buf.as_mut_ptr() as *mut libc::c_void,\n+                               buf.len() as libc::size_t)\n+                } {\n+                    n if n > 0 => { ret = true; }\n+                    0 => return true,\n+                    -1 if wouldblock() => return ret,\n+                    n => panic!(\"bad read {} ({})\", os::last_os_error(), n),\n+                }\n+            }\n+        }\n+\n+        // Signal handler for SIGCHLD signals, must be async-signal-safe!\n+        //\n+        // This function will write to the writing half of the \"self pipe\" to wake\n+        // up the helper thread if it's waiting. Note that this write must be\n+        // nonblocking because if it blocks and the reader is the thread we\n+        // interrupted, then we'll deadlock.\n+        //\n+        // When writing, if the write returns EWOULDBLOCK then we choose to ignore\n+        // it. At that point we're guaranteed that there's something in the pipe\n+        // which will wake up the other end at some point, so we just allow this\n+        // signal to be coalesced with the pending signals on the pipe.\n+        extern fn sigchld_handler(_signum: libc::c_int) {\n+            let msg = 1i;\n+            match unsafe {\n+                libc::write(WRITE_FD, &msg as *const _ as *const libc::c_void, 1)\n+            } {\n+                1 => {}\n+                -1 if wouldblock() => {} // see above comments\n+                n => panic!(\"bad error on write fd: {} {}\", n, os::errno()),\n+            }\n+        }\n+    }\n+\n+    pub fn try_wait(&self) -> Option<ProcessExit> {\n+        let mut status = 0 as c_int;\n+        match retry(|| unsafe {\n+            c::waitpid(self.pid, &mut status, c::WNOHANG)\n+        }) {\n+            n if n == self.pid => Some(translate_status(status)),\n+            0 => None,\n+            n => panic!(\"unknown waitpid error `{}`: {}\", n,\n+                       super::last_error()),\n+        }\n+    }\n+}\n+\n+fn with_argv<T>(prog: &CString, args: &[CString],\n+                cb: proc(*const *const libc::c_char) -> T) -> T {\n+    let mut ptrs: Vec<*const libc::c_char> = Vec::with_capacity(args.len()+1);\n+\n+    // Convert the CStrings into an array of pointers. Note: the\n+    // lifetime of the various CStrings involved is guaranteed to be\n+    // larger than the lifetime of our invocation of cb, but this is\n+    // technically unsafe as the callback could leak these pointers\n+    // out of our scope.\n+    ptrs.push(prog.as_ptr());\n+    ptrs.extend(args.iter().map(|tmp| tmp.as_ptr()));\n+\n+    // Add a terminating null pointer (required by libc).\n+    ptrs.push(ptr::null());\n+\n+    cb(ptrs.as_ptr())\n+}\n+\n+fn with_envp<K, V, T>(env: Option<&collections::HashMap<K, V>>,\n+                      cb: proc(*const c_void) -> T) -> T\n+    where K: BytesContainer + Eq + Hash, V: BytesContainer\n+{\n+    // On posixy systems we can pass a char** for envp, which is a\n+    // null-terminated array of \"k=v\\0\" strings. Since we must create\n+    // these strings locally, yet expose a raw pointer to them, we\n+    // create a temporary vector to own the CStrings that outlives the\n+    // call to cb.\n+    match env {\n+        Some(env) => {\n+            let mut tmps = Vec::with_capacity(env.len());\n+\n+            for pair in env.iter() {\n+                let mut kv = Vec::new();\n+                kv.push_all(pair.ref0().container_as_bytes());\n+                kv.push('=' as u8);\n+                kv.push_all(pair.ref1().container_as_bytes());\n+                kv.push(0); // terminating null\n+                tmps.push(kv);\n+            }\n+\n+            // As with `with_argv`, this is unsafe, since cb could leak the pointers.\n+            let mut ptrs: Vec<*const libc::c_char> =\n+                tmps.iter()\n+                    .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n+                    .collect();\n+            ptrs.push(ptr::null());\n+\n+            cb(ptrs.as_ptr() as *const c_void)\n+        }\n+        _ => cb(ptr::null())\n+    }\n+}\n+\n+fn translate_status(status: c_int) -> ProcessExit {\n+    #![allow(non_snake_case)]\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    mod imp {\n+        pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }\n+        pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }\n+        pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }\n+    }\n+\n+    #[cfg(any(target_os = \"macos\",\n+              target_os = \"ios\",\n+              target_os = \"freebsd\",\n+              target_os = \"dragonfly\"))]\n+    mod imp {\n+        pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }\n+        pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }\n+        pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }\n+    }\n+\n+    if imp::WIFEXITED(status) {\n+        ExitStatus(imp::WEXITSTATUS(status) as int)\n+    } else {\n+        ExitSignal(imp::WTERMSIG(status) as int)\n+    }\n+}"}, {"sha": "962475e417719e05c7b68c1c20c9fe4c6f892676", "filename": "src/libstd/sys/unix/tcp.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -0,0 +1,157 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io::net::ip;\n+use io::IoResult;\n+use libc;\n+use mem;\n+use ptr;\n+use prelude::*;\n+use super::{last_error, last_net_error, retry, sock_t};\n+use sync::{Arc, atomic};\n+use sys::fs::FileDesc;\n+use sys::{set_nonblocking, wouldblock};\n+use sys;\n+use sys_common;\n+use sys_common::net::*;\n+\n+pub use sys_common::net::TcpStream;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// TCP listeners\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct TcpListener {\n+    pub inner: FileDesc,\n+}\n+\n+impl TcpListener {\n+    pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> {\n+        let fd = try!(socket(addr, libc::SOCK_STREAM));\n+        let ret = TcpListener { inner: FileDesc::new(fd, true) };\n+\n+        let mut storage = unsafe { mem::zeroed() };\n+        let len = addr_to_sockaddr(addr, &mut storage);\n+        let addrp = &storage as *const _ as *const libc::sockaddr;\n+\n+        // On platforms with Berkeley-derived sockets, this allows\n+        // to quickly rebind a socket, without needing to wait for\n+        // the OS to clean up the previous one.\n+        try!(setsockopt(fd, libc::SOL_SOCKET, libc::SO_REUSEADDR, 1 as libc::c_int));\n+\n+\n+        match unsafe { libc::bind(fd, addrp, len) } {\n+            -1 => Err(last_error()),\n+            _ => Ok(ret),\n+        }\n+    }\n+\n+    pub fn fd(&self) -> sock_t { self.inner.fd() }\n+\n+    pub fn listen(self, backlog: int) -> IoResult<TcpAcceptor> {\n+        match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n+            -1 => Err(last_net_error()),\n+            _ => {\n+                let (reader, writer) = try!(unsafe { sys::os::pipe() });\n+                try!(set_nonblocking(reader.fd(), true));\n+                try!(set_nonblocking(writer.fd(), true));\n+                try!(set_nonblocking(self.fd(), true));\n+                Ok(TcpAcceptor {\n+                    inner: Arc::new(AcceptorInner {\n+                        listener: self,\n+                        reader: reader,\n+                        writer: writer,\n+                        closed: atomic::AtomicBool::new(false),\n+                    }),\n+                    deadline: 0,\n+                })\n+            }\n+        }\n+    }\n+\n+    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd(), libc::getsockname)\n+    }\n+}\n+\n+pub struct TcpAcceptor {\n+    inner: Arc<AcceptorInner>,\n+    deadline: u64,\n+}\n+\n+struct AcceptorInner {\n+    listener: TcpListener,\n+    reader: FileDesc,\n+    writer: FileDesc,\n+    closed: atomic::AtomicBool,\n+}\n+\n+impl TcpAcceptor {\n+    pub fn fd(&self) -> sock_t { self.inner.listener.fd() }\n+\n+    pub fn accept(&mut self) -> IoResult<TcpStream> {\n+        // In implementing accept, the two main concerns are dealing with\n+        // close_accept() and timeouts. The unix implementation is based on a\n+        // nonblocking accept plus a call to select(). Windows ends up having\n+        // an entirely separate implementation than unix, which is explained\n+        // below.\n+        //\n+        // To implement timeouts, all blocking is done via select() instead of\n+        // accept() by putting the socket in non-blocking mode. Because\n+        // select() takes a timeout argument, we just pass through the timeout\n+        // to select().\n+        //\n+        // To implement close_accept(), we have a self-pipe to ourselves which\n+        // is passed to select() along with the socket being accepted on. The\n+        // self-pipe is never written to unless close_accept() is called.\n+        let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n+\n+        while !self.inner.closed.load(atomic::SeqCst) {\n+            match retry(|| unsafe {\n+                libc::accept(self.fd(), ptr::null_mut(), ptr::null_mut())\n+            }) {\n+                -1 if wouldblock() => {}\n+                -1 => return Err(last_net_error()),\n+                fd => return Ok(TcpStream::new(fd as sock_t)),\n+            }\n+            try!(await([self.fd(), self.inner.reader.fd()],\n+                             deadline, Readable));\n+        }\n+\n+        Err(sys_common::eof())\n+    }\n+\n+    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd(), libc::getsockname)\n+    }\n+\n+    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n+        self.deadline = timeout.map(|a| sys::timer::now() + a).unwrap_or(0);\n+    }\n+\n+    pub fn close_accept(&mut self) -> IoResult<()> {\n+        self.inner.closed.store(true, atomic::SeqCst);\n+        let fd = FileDesc::new(self.inner.writer.fd(), false);\n+        match fd.write([0]) {\n+            Ok(..) => Ok(()),\n+            Err(..) if wouldblock() => Ok(()),\n+            Err(e) => Err(e),\n+        }\n+    }\n+}\n+\n+impl Clone for TcpAcceptor {\n+    fn clone(&self) -> TcpAcceptor {\n+        TcpAcceptor {\n+            inner: self.inner.clone(),\n+            deadline: 0,\n+        }\n+    }\n+}"}, {"sha": "a1e6ac3db7e38b7287f1e0c06e8c1b73a6ead872", "filename": "src/libstd/sys/unix/timer.rs", "status": "renamed", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -47,27 +47,30 @@\n //! Note that all time units in this file are in *milliseconds*.\n \n use libc;\n-use std::mem;\n-use std::os;\n-use std::ptr;\n-use std::rt::rtio;\n-use std::rt::rtio::IoResult;\n-use std::sync::atomic;\n-use std::comm;\n-\n-use io::c;\n-use io::file::FileDesc;\n-use io::helper_thread::Helper;\n+use mem;\n+use os;\n+use ptr;\n+use sync::atomic;\n+use comm;\n+use sys::c;\n+use sys::fs::FileDesc;\n+use sys_common::helper_thread::Helper;\n+use prelude::*;\n+use io::IoResult;\n \n helper_init!(static HELPER: Helper<Req>)\n \n+pub trait Callback {\n+    fn call(&mut self);\n+}\n+\n pub struct Timer {\n     id: uint,\n     inner: Option<Box<Inner>>,\n }\n \n pub struct Inner {\n-    cb: Option<Box<rtio::Callback + Send>>,\n+    cb: Option<Box<Callback + Send>>,\n     interval: u64,\n     repeat: bool,\n     target: u64,\n@@ -190,11 +193,11 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n \n                 // drain the file descriptor\n                 let mut buf = [0];\n-                assert_eq!(fd.inner_read(buf).ok().unwrap(), 1);\n+                assert_eq!(fd.read(buf).ok().unwrap(), 1);\n             }\n \n-            -1 if os::errno() == libc::EINTR as int => {}\n-            n => panic!(\"helper thread panicked in select() with error: {} ({})\",\n+            -1 if os::errno() == libc::EINTR as uint => {}\n+            n => panic!(\"helper thread failed in select() with error: {} ({})\",\n                        n, os::last_os_error())\n         }\n     }\n@@ -220,7 +223,11 @@ impl Timer {\n         })\n     }\n \n-    pub fn sleep(ms: u64) {\n+    pub fn sleep(&mut self, ms: u64) {\n+        let mut inner = self.inner();\n+        inner.cb = None; // cancel any previous request\n+        self.inner = Some(inner);\n+\n         let mut to_sleep = libc::timespec {\n             tv_sec: (ms / 1000) as libc::time_t,\n             tv_nsec: ((ms % 1000) * 1000000) as libc::c_long,\n@@ -232,28 +239,7 @@ impl Timer {\n         }\n     }\n \n-    fn inner(&mut self) -> Box<Inner> {\n-        match self.inner.take() {\n-            Some(i) => i,\n-            None => {\n-                let (tx, rx) = channel();\n-                HELPER.send(RemoveTimer(self.id, tx));\n-                rx.recv()\n-            }\n-        }\n-    }\n-}\n-\n-impl rtio::RtioTimer for Timer {\n-    fn sleep(&mut self, msecs: u64) {\n-        let mut inner = self.inner();\n-        inner.cb = None; // cancel any previous request\n-        self.inner = Some(inner);\n-\n-        Timer::sleep(msecs);\n-    }\n-\n-    fn oneshot(&mut self, msecs: u64, cb: Box<rtio::Callback + Send>) {\n+    pub fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>) {\n         let now = now();\n         let mut inner = self.inner();\n \n@@ -265,7 +251,7 @@ impl rtio::RtioTimer for Timer {\n         HELPER.send(NewTimer(inner));\n     }\n \n-    fn period(&mut self, msecs: u64, cb: Box<rtio::Callback + Send>) {\n+    pub fn period(&mut self, msecs: u64, cb: Box<Callback + Send>) {\n         let now = now();\n         let mut inner = self.inner();\n \n@@ -276,6 +262,17 @@ impl rtio::RtioTimer for Timer {\n \n         HELPER.send(NewTimer(inner));\n     }\n+\n+    fn inner(&mut self) -> Box<Inner> {\n+        match self.inner.take() {\n+            Some(i) => i,\n+            None => {\n+                let (tx, rx) = channel();\n+                HELPER.send(RemoveTimer(self.id, tx));\n+                rx.recv()\n+            }\n+        }\n+    }\n }\n \n impl Drop for Timer {", "previous_filename": "src/libnative/io/timer_unix.rs"}, {"sha": "28c17fd4966c09468fe1df7f9570e67cd911ab6e", "filename": "src/libstd/sys/unix/tty.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftty.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use sys::fs::FileDesc;\n+use prelude::*;\n+use libc::{mod, c_int};\n+use io::{mod, IoResult, IoError};\n+use sys_common;\n+\n+pub struct TTY {\n+    pub fd: FileDesc,\n+}\n+\n+impl TTY {\n+    pub fn new(fd: c_int) -> IoResult<TTY> {\n+        if unsafe { libc::isatty(fd) } != 0 {\n+            Ok(TTY { fd: FileDesc::new(fd, true) })\n+        } else {\n+            Err(IoError {\n+                kind: io::MismatchedFileTypeForOperation,\n+                desc: \"file descriptor is not a TTY\",\n+                detail: None,\n+            })\n+        }\n+    }\n+\n+    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        self.fd.read(buf)\n+    }\n+    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.fd.write(buf)\n+    }\n+    pub fn set_raw(&mut self, _raw: bool) -> IoResult<()> {\n+        Err(sys_common::unimpl())\n+    }\n+    pub fn get_winsize(&mut self) -> IoResult<(int, int)> {\n+        Err(sys_common::unimpl())\n+    }\n+    pub fn isatty(&self) -> bool { false }\n+}"}, {"sha": "50f8fb828ad323572f17ef3972cbb0f9d5861996", "filename": "src/libstd/sys/unix/udp.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Funix%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fudp.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use sys_common::net::UdpSocket;"}, {"sha": "b8e9b1dca3abc7e11b45795135c9033725a4d9a4", "filename": "src/libstd/sys/windows/c.rs", "status": "renamed", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -11,8 +11,11 @@\n //! C definitions used by libnative that don't belong in liblibc\n \n #![allow(overflowing_literals)]\n+#![allow(dead_code)]\n+#![allow(non_camel_case_types)]\n \n use libc;\n+use prelude::*;\n \n pub const WSADESCRIPTION_LEN: uint = 256;\n pub const WSASYS_STATUS_LEN: uint = 128;\n@@ -127,9 +130,10 @@ extern \"system\" {\n }\n \n pub mod compat {\n-    use std::intrinsics::{atomic_store_relaxed, transmute};\n-    use std::iter::Iterator;\n+    use intrinsics::{atomic_store_relaxed, transmute};\n+    use iter::Iterator;\n     use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n+    use prelude::*;\n \n     extern \"system\" {\n         fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n@@ -174,17 +178,17 @@ pub mod compat {\n \n                 extern \"system\" fn thunk($($argname: $argtype),*) -> $rettype {\n                     unsafe {\n-                        ::io::c::compat::store_func(&mut ptr as *mut _ as *mut uint,\n+                        ::sys::c::compat::store_func(&mut ptr as *mut _ as *mut uint,\n                                                     stringify!($module),\n                                                     stringify!($symbol),\n                                                     fallback as uint);\n-                        ::std::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n+                        ::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n                     }\n                 }\n \n                 extern \"system\" fn fallback($($argname: $argtype),*) -> $rettype $fallback\n \n-                ::std::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n+                ::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n             }\n         );\n ", "previous_filename": "src/libnative/io/c_windows.rs"}, {"sha": "a07688b2fed03e0ece26ff4b01ab742620ec4368", "filename": "src/libstd/sys/windows/fs.rs", "status": "renamed", "additions": 155, "deletions": 218, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -12,42 +12,40 @@\n \n use alloc::arc::Arc;\n use libc::{mod, c_int};\n-use std::c_str::CString;\n-use std::mem;\n-use std::os::windows::fill_utf16_buf_and_decode;\n-use std::ptr;\n-use std::rt::rtio;\n-use std::rt::rtio::{IoResult, IoError};\n-use std::str;\n \n-pub type fd_t = libc::c_int;\n+use c_str::CString;\n+use mem;\n+use os::windows::fill_utf16_buf_and_decode;\n+use path;\n+use ptr;\n+use str;\n+use io;\n \n-struct Inner {\n-    fd: fd_t,\n-    close_on_drop: bool,\n-}\n+use prelude::*;\n+use sys;\n+use sys_common::{keep_going, eof, mkerr_libc};\n+\n+use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n+use io::{IoResult, IoError, FileStat, SeekStyle, Seek, Writer, Reader};\n+use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n+\n+pub use path::WindowsPath as Path;\n+pub type fd_t = libc::c_int;\n \n pub struct FileDesc {\n-    inner: Arc<Inner>\n+    /// The underlying C file descriptor.\n+    pub fd: fd_t,\n+\n+    /// Whether to close the file descriptor on drop.\n+    close_on_drop: bool,\n }\n \n impl FileDesc {\n-    /// Create a `FileDesc` from an open C file descriptor.\n-    ///\n-    /// The `FileDesc` will take ownership of the specified file descriptor and\n-    /// close it upon destruction if the `close_on_drop` flag is true, otherwise\n-    /// it will not close the file descriptor when this `FileDesc` is dropped.\n-    ///\n-    /// Note that all I/O operations done on this object will be *blocking*, but\n-    /// they do not require the runtime to be active.\n     pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n-        FileDesc { inner: Arc::new(Inner {\n-            fd: fd,\n-            close_on_drop: close_on_drop\n-        }) }\n+        FileDesc { fd: fd, close_on_drop: close_on_drop }\n     }\n \n-    pub fn inner_read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&self, buf: &mut [u8]) -> IoResult<uint> {\n         let mut read = 0;\n         let ret = unsafe {\n             libc::ReadFile(self.handle(), buf.as_ptr() as libc::LPVOID,\n@@ -60,7 +58,8 @@ impl FileDesc {\n             Err(super::last_error())\n         }\n     }\n-    pub fn inner_write(&mut self, buf: &[u8]) -> IoResult<()> {\n+\n+    pub fn write(&self, buf: &[u8]) -> IoResult<()> {\n         let mut cur = buf.as_ptr();\n         let mut remaining = buf.len();\n         while remaining > 0 {\n@@ -80,161 +79,75 @@ impl FileDesc {\n         Ok(())\n     }\n \n-    pub fn fd(&self) -> fd_t { self.inner.fd }\n+    pub fn fd(&self) -> fd_t { self.fd }\n \n     pub fn handle(&self) -> libc::HANDLE {\n         unsafe { libc::get_osfhandle(self.fd()) as libc::HANDLE }\n     }\n \n     // A version of seek that takes &self so that tell can call it\n     //   - the private seek should of course take &mut self.\n-    fn seek_common(&self, pos: i64, style: rtio::SeekStyle) -> IoResult<u64> {\n+    fn seek_common(&self, pos: i64, style: SeekStyle) -> IoResult<u64> {\n         let whence = match style {\n-            rtio::SeekSet => libc::FILE_BEGIN,\n-            rtio::SeekEnd => libc::FILE_END,\n-            rtio::SeekCur => libc::FILE_CURRENT,\n+            SeekSet => libc::FILE_BEGIN,\n+            SeekEnd => libc::FILE_END,\n+            SeekCur => libc::FILE_CURRENT,\n         };\n         unsafe {\n             let mut newpos = 0;\n-            match libc::SetFilePointerEx(self.handle(), pos, &mut newpos,\n-                                         whence) {\n+            match libc::SetFilePointerEx(self.handle(), pos, &mut newpos, whence) {\n                 0 => Err(super::last_error()),\n                 _ => Ok(newpos as u64),\n             }\n         }\n     }\n \n-}\n-\n-impl rtio::RtioFileStream for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> {\n-        self.inner_read(buf).map(|i| i as int)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner_write(buf)\n-    }\n-\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n-        let mut read = 0;\n-        let mut overlap: libc::OVERLAPPED = unsafe { mem::zeroed() };\n-        overlap.Offset = offset as libc::DWORD;\n-        overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n-        let ret = unsafe {\n-            libc::ReadFile(self.handle(), buf.as_ptr() as libc::LPVOID,\n-                           buf.len() as libc::DWORD, &mut read,\n-                           &mut overlap)\n-        };\n-        if ret != 0 {\n-            Ok(read as int)\n-        } else {\n-            Err(super::last_error())\n-        }\n-    }\n-    fn pwrite(&mut self, buf: &[u8], mut offset: u64) -> IoResult<()> {\n-        let mut cur = buf.as_ptr();\n-        let mut remaining = buf.len();\n-        let mut overlap: libc::OVERLAPPED = unsafe { mem::zeroed() };\n-        while remaining > 0 {\n-            overlap.Offset = offset as libc::DWORD;\n-            overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n-            let mut amt = 0;\n-            let ret = unsafe {\n-                libc::WriteFile(self.handle(), cur as libc::LPVOID,\n-                                remaining as libc::DWORD, &mut amt,\n-                                &mut overlap)\n-            };\n-            if ret != 0 {\n-                remaining -= amt as uint;\n-                cur = unsafe { cur.offset(amt as int) };\n-                offset += amt as u64;\n-            } else {\n-                return Err(super::last_error())\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    fn seek(&mut self, pos: i64, style: rtio::SeekStyle) -> IoResult<u64> {\n+    pub fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<u64> {\n         self.seek_common(pos, style)\n     }\n \n-    fn tell(&self) -> IoResult<u64> {\n-        self.seek_common(0, rtio::SeekCur)\n+    pub fn tell(&self) -> IoResult<u64> {\n+        self.seek_common(0, SeekCur)\n     }\n \n-    fn fsync(&mut self) -> IoResult<()> {\n+    pub fn fsync(&mut self) -> IoResult<()> {\n         super::mkerr_winbool(unsafe {\n             libc::FlushFileBuffers(self.handle())\n         })\n     }\n \n-    fn datasync(&mut self) -> IoResult<()> { return self.fsync(); }\n+    pub fn datasync(&mut self) -> IoResult<()> { return self.fsync(); }\n \n-    fn truncate(&mut self, offset: i64) -> IoResult<()> {\n+    pub fn truncate(&mut self, offset: i64) -> IoResult<()> {\n         let orig_pos = try!(self.tell());\n-        let _ = try!(self.seek(offset, rtio::SeekSet));\n+        let _ = try!(self.seek(offset, SeekSet));\n         let ret = unsafe {\n             match libc::SetEndOfFile(self.handle()) {\n                 0 => Err(super::last_error()),\n                 _ => Ok(())\n             }\n         };\n-        let _ = self.seek(orig_pos as i64, rtio::SeekSet);\n+        let _ = self.seek(orig_pos as i64, SeekSet);\n         return ret;\n     }\n \n-    fn fstat(&mut self) -> IoResult<rtio::FileStat> {\n+    pub fn fstat(&mut self) -> IoResult<io::FileStat> {\n         let mut stat: libc::stat = unsafe { mem::zeroed() };\n         match unsafe { libc::fstat(self.fd(), &mut stat) } {\n             0 => Ok(mkstat(&stat)),\n             _ => Err(super::last_error()),\n         }\n     }\n-}\n \n-impl rtio::RtioPipe for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.inner_read(buf)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner_write(buf)\n-    }\n-    fn clone(&self) -> Box<rtio::RtioPipe + Send> {\n-        box FileDesc { inner: self.inner.clone() } as Box<rtio::RtioPipe + Send>\n-    }\n-\n-    // Only supported on named pipes currently. Note that this doesn't have an\n-    // impact on the std::io primitives, this is never called via\n-    // std::io::PipeStream. If the functionality is exposed in the future, then\n-    // these methods will need to be implemented.\n-    fn close_read(&mut self) -> IoResult<()> {\n-        Err(super::unimpl())\n-    }\n-    fn close_write(&mut self) -> IoResult<()> {\n-        Err(super::unimpl())\n-    }\n-    fn set_timeout(&mut self, _t: Option<u64>) {}\n-    fn set_read_timeout(&mut self, _t: Option<u64>) {}\n-    fn set_write_timeout(&mut self, _t: Option<u64>) {}\n-}\n-\n-impl rtio::RtioTTY for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.inner_read(buf)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner_write(buf)\n+    /// Extract the actual filedescriptor without closing it.\n+    pub fn unwrap(self) -> fd_t {\n+        let fd = self.fd;\n+        unsafe { mem::forget(self) };\n+        fd\n     }\n-    fn set_raw(&mut self, _raw: bool) -> IoResult<()> {\n-        Err(super::unimpl())\n-    }\n-    fn get_winsize(&mut self) -> IoResult<(int, int)> {\n-        Err(super::unimpl())\n-    }\n-    fn isatty(&self) -> bool { false }\n }\n \n-impl Drop for Inner {\n+impl Drop for FileDesc {\n     fn drop(&mut self) {\n         // closing stdio file handles makes no sense, so never do it. Also, note\n         // that errors are ignored when closing a file descriptor. The reason\n@@ -251,39 +164,26 @@ impl Drop for Inner {\n     }\n }\n \n-pub fn to_utf16(s: &CString) -> IoResult<Vec<u16>> {\n-    match s.as_str() {\n-        Some(s) => Ok({\n-            let mut s = s.utf16_units().collect::<Vec<u16>>();\n-            s.push(0);\n-            s\n-        }),\n-        None => Err(IoError {\n-            code: libc::ERROR_INVALID_NAME as uint,\n-            extra: 0,\n-            detail: Some(\"valid unicode input required\".to_string()),\n-        })\n-    }\n+pub fn to_utf16(s: &Path) -> IoResult<Vec<u16>> {\n+    sys::to_utf16(s.as_str())\n }\n \n-pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n-        -> IoResult<FileDesc> {\n+pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> {\n     // Flags passed to open_osfhandle\n     let flags = match fm {\n-        rtio::Open => 0,\n-        rtio::Append => libc::O_APPEND,\n-        rtio::Truncate => libc::O_TRUNC,\n+        Open => 0,\n+        Append => libc::O_APPEND,\n+        Truncate => libc::O_TRUNC,\n     };\n     let flags = match fa {\n-        rtio::Read => flags | libc::O_RDONLY,\n-        rtio::Write => flags | libc::O_WRONLY | libc::O_CREAT,\n-        rtio::ReadWrite => flags | libc::O_RDWR | libc::O_CREAT,\n+        Read => flags | libc::O_RDONLY,\n+        Write => flags | libc::O_WRONLY | libc::O_CREAT,\n+        ReadWrite => flags | libc::O_RDWR | libc::O_CREAT,\n     };\n-\n     let mut dwDesiredAccess = match fa {\n-        rtio::Read => libc::FILE_GENERIC_READ,\n-        rtio::Write => libc::FILE_GENERIC_WRITE,\n-        rtio::ReadWrite => libc::FILE_GENERIC_READ | libc::FILE_GENERIC_WRITE\n+        Read => libc::FILE_GENERIC_READ,\n+        Write => libc::FILE_GENERIC_WRITE,\n+        ReadWrite => libc::FILE_GENERIC_READ | libc::FILE_GENERIC_WRITE\n     };\n \n     // libuv has a good comment about this, but the basic idea is what we try to\n@@ -293,15 +193,15 @@ pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n                       libc::FILE_SHARE_DELETE;\n \n     let dwCreationDisposition = match (fm, fa) {\n-        (rtio::Truncate, rtio::Read) => libc::TRUNCATE_EXISTING,\n-        (rtio::Truncate, _) => libc::CREATE_ALWAYS,\n-        (rtio::Open, rtio::Read) => libc::OPEN_EXISTING,\n-        (rtio::Open, _) => libc::OPEN_ALWAYS,\n-        (rtio::Append, rtio::Read) => {\n+        (Truncate, Read) => libc::TRUNCATE_EXISTING,\n+        (Truncate, _) => libc::CREATE_ALWAYS,\n+        (Open, Read) => libc::OPEN_EXISTING,\n+        (Open, _) => libc::OPEN_ALWAYS,\n+        (Append, Read) => {\n             dwDesiredAccess |= libc::FILE_APPEND_DATA;\n             libc::OPEN_EXISTING\n         }\n-        (rtio::Append, _) => {\n+        (Append, _) => {\n             dwDesiredAccess &= !libc::FILE_WRITE_DATA;\n             dwDesiredAccess |= libc::FILE_APPEND_DATA;\n             libc::OPEN_ALWAYS\n@@ -337,28 +237,23 @@ pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n     }\n }\n \n-pub fn mkdir(p: &CString, _mode: uint) -> IoResult<()> {\n+pub fn mkdir(p: &Path, _mode: uint) -> IoResult<()> {\n     let p = try!(to_utf16(p));\n     super::mkerr_winbool(unsafe {\n         // FIXME: turn mode into something useful? #2623\n         libc::CreateDirectoryW(p.as_ptr(), ptr::null_mut())\n     })\n }\n \n-pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n-    fn prune(root: &CString, dirs: Vec<Path>) -> Vec<CString> {\n-        let root = unsafe { CString::new(root.as_ptr(), false) };\n-        let root = Path::new(root);\n-\n+pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n+    fn prune(root: &Path, dirs: Vec<Path>) -> Vec<Path> {\n         dirs.into_iter().filter(|path| {\n             path.as_vec() != b\".\" && path.as_vec() != b\"..\"\n-        }).map(|path| root.join(path).to_c_str()).collect()\n+        }).map(|path| root.join(path)).collect()\n     }\n \n-    let star = Path::new(unsafe {\n-        CString::new(p.as_ptr(), false)\n-    }).join(\"*\");\n-    let path = try!(to_utf16(&star.to_c_str()));\n+    let star = p.join(\"*\");\n+    let path = try!(to_utf16(&star));\n \n     unsafe {\n         let mut wfd = mem::zeroed();\n@@ -374,8 +269,8 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n                         None => {\n                             assert!(libc::FindClose(find_handle) != 0);\n                             return Err(IoError {\n-                                code: super::c::ERROR_ILLEGAL_CHARACTER as uint,\n-                                extra: 0,\n+                                kind: io::InvalidInput,\n+                                desc: \"path was not valid UTF-16\",\n                                 detail: Some(format!(\"path was not valid UTF-16: {}\", filename)),\n                             })\n                         }, // FIXME #12056: Convert the UCS-2 to invalid utf-8 instead of erroring\n@@ -391,42 +286,74 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n     }\n }\n \n-pub fn unlink(p: &CString) -> IoResult<()> {\n-    let p = try!(to_utf16(p));\n-    super::mkerr_winbool(unsafe {\n-        libc::DeleteFileW(p.as_ptr())\n-    })\n+pub fn unlink(p: &Path) -> IoResult<()> {\n+    fn do_unlink(p_utf16: &Vec<u16>) -> IoResult<()> {\n+        super::mkerr_winbool(unsafe { libc::DeleteFileW(p_utf16.as_ptr()) })\n+    }\n+\n+    let p_utf16 = try!(to_utf16(p));\n+    let res = do_unlink(&p_utf16);\n+    match res {\n+        Ok(()) => Ok(()),\n+        Err(e) => {\n+            // FIXME: change the code below to use more direct calls\n+            // than `stat` and `chmod`, to avoid re-conversion to\n+            // utf16 etc.\n+\n+            // On unix, a readonly file can be successfully removed. On windows,\n+            // however, it cannot. To keep the two platforms in line with\n+            // respect to their behavior, catch this case on windows, attempt to\n+            // change it to read-write, and then remove the file.\n+            if e.kind == io::PermissionDenied {\n+                let stat = match stat(p) {\n+                    Ok(stat) => stat,\n+                    Err(..) => return Err(e),\n+                };\n+                if stat.perm.intersects(io::USER_WRITE) { return Err(e) }\n+\n+                match chmod(p, (stat.perm | io::USER_WRITE).bits() as uint) {\n+                    Ok(()) => do_unlink(&p_utf16),\n+                    Err(..) => {\n+                        // Try to put it back as we found it\n+                        let _ = chmod(p, stat.perm.bits() as uint);\n+                        Err(e)\n+                    }\n+                }\n+            } else {\n+                Err(e)\n+            }\n+        }\n+    }\n }\n \n-pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n+pub fn rename(old: &Path, new: &Path) -> IoResult<()> {\n     let old = try!(to_utf16(old));\n     let new = try!(to_utf16(new));\n     super::mkerr_winbool(unsafe {\n-        libc::MoveFileExW(old.as_ptr(), new.as_ptr(),\n-                          libc::MOVEFILE_REPLACE_EXISTING)\n+        libc::MoveFileExW(old.as_ptr(), new.as_ptr(), libc::MOVEFILE_REPLACE_EXISTING)\n     })\n }\n \n-pub fn chmod(p: &CString, mode: uint) -> IoResult<()> {\n+pub fn chmod(p: &Path, mode: uint) -> IoResult<()> {\n     let p = try!(to_utf16(p));\n-    super::mkerr_libc(unsafe {\n+    mkerr_libc(unsafe {\n         libc::wchmod(p.as_ptr(), mode as libc::c_int)\n     })\n }\n \n-pub fn rmdir(p: &CString) -> IoResult<()> {\n+pub fn rmdir(p: &Path) -> IoResult<()> {\n     let p = try!(to_utf16(p));\n-    super::mkerr_libc(unsafe { libc::wrmdir(p.as_ptr()) })\n+    mkerr_libc(unsafe { libc::wrmdir(p.as_ptr()) })\n }\n \n-pub fn chown(_p: &CString, _uid: int, _gid: int) -> IoResult<()> {\n+pub fn chown(_p: &Path, _uid: int, _gid: int) -> IoResult<()> {\n     // libuv has this as a no-op, so seems like this should as well?\n     Ok(())\n }\n \n-pub fn readlink(p: &CString) -> IoResult<CString> {\n+pub fn readlink(p: &Path) -> IoResult<Path> {\n     // FIXME: I have a feeling that this reads intermediate symlinks as well.\n-    use io::c::compat::kernel32::GetFinalPathNameByHandleW;\n+    use sys::c::compat::kernel32::GetFinalPathNameByHandleW;\n     let p = try!(to_utf16(p));\n     let handle = unsafe {\n         libc::CreateFileW(p.as_ptr(),\n@@ -449,55 +376,64 @@ pub fn readlink(p: &CString) -> IoResult<CString> {\n                                   libc::VOLUME_NAME_DOS)\n     });\n     let ret = match ret {\n-        Some(ref s) if s.as_slice().starts_with(r\"\\\\?\\\") => {\n-            Ok(Path::new(s.as_slice().slice_from(4)).to_c_str())\n+        Some(ref s) if s.as_slice().starts_with(r\"\\\\?\\\") => { // \"\n+            Ok(Path::new(s.as_slice().slice_from(4)))\n         }\n-        Some(s) => Ok(Path::new(s).to_c_str()),\n+        Some(s) => Ok(Path::new(s)),\n         None => Err(super::last_error()),\n     };\n     assert!(unsafe { libc::CloseHandle(handle) } != 0);\n     return ret;\n }\n \n-pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-    use io::c::compat::kernel32::CreateSymbolicLinkW;\n+pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n+    use sys::c::compat::kernel32::CreateSymbolicLinkW;\n     let src = try!(to_utf16(src));\n     let dst = try!(to_utf16(dst));\n     super::mkerr_winbool(unsafe {\n         CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), 0) as libc::BOOL\n     })\n }\n \n-pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n+pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n     let src = try!(to_utf16(src));\n     let dst = try!(to_utf16(dst));\n     super::mkerr_winbool(unsafe {\n         libc::CreateHardLinkW(dst.as_ptr(), src.as_ptr(), ptr::null_mut())\n     })\n }\n \n-fn mkstat(stat: &libc::stat) -> rtio::FileStat {\n-    rtio::FileStat {\n+fn mkstat(stat: &libc::stat) -> FileStat {\n+    FileStat {\n         size: stat.st_size as u64,\n-        kind: stat.st_mode as u64,\n-        perm: stat.st_mode as u64,\n+        kind: match (stat.st_mode as libc::c_int) & libc::S_IFMT {\n+            libc::S_IFREG => io::TypeFile,\n+            libc::S_IFDIR => io::TypeDirectory,\n+            libc::S_IFIFO => io::TypeNamedPipe,\n+            libc::S_IFBLK => io::TypeBlockSpecial,\n+            libc::S_IFLNK => io::TypeSymlink,\n+            _ => io::TypeUnknown,\n+        },\n+        perm: FilePermission::from_bits_truncate(stat.st_mode as u32),\n         created: stat.st_ctime as u64,\n         modified: stat.st_mtime as u64,\n         accessed: stat.st_atime as u64,\n-        device: stat.st_dev as u64,\n-        inode: stat.st_ino as u64,\n-        rdev: stat.st_rdev as u64,\n-        nlink: stat.st_nlink as u64,\n-        uid: stat.st_uid as u64,\n-        gid: stat.st_gid as u64,\n-        blksize: 0,\n-        blocks: 0,\n-        flags: 0,\n-        gen: 0,\n+        unstable: UnstableFileStat {\n+            device: stat.st_dev as u64,\n+            inode: stat.st_ino as u64,\n+            rdev: stat.st_rdev as u64,\n+            nlink: stat.st_nlink as u64,\n+            uid: stat.st_uid as u64,\n+            gid: stat.st_gid as u64,\n+            blksize:0,\n+            blocks: 0,\n+            flags: 0,\n+            gen: 0,\n+        },\n     }\n }\n \n-pub fn stat(p: &CString) -> IoResult<rtio::FileStat> {\n+pub fn stat(p: &Path) -> IoResult<FileStat> {\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n     let p = try!(to_utf16(p));\n     match unsafe { libc::wstat(p.as_ptr(), &mut stat) } {\n@@ -506,18 +442,19 @@ pub fn stat(p: &CString) -> IoResult<rtio::FileStat> {\n     }\n }\n \n-pub fn lstat(_p: &CString) -> IoResult<rtio::FileStat> {\n+// FIXME: move this to platform-specific modules (for now)?\n+pub fn lstat(_p: &Path) -> IoResult<FileStat> {\n     // FIXME: implementation is missing\n     Err(super::unimpl())\n }\n \n-pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n+pub fn utime(p: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n     let mut buf = libc::utimbuf {\n         actime: atime as libc::time64_t,\n         modtime: mtime as libc::time64_t,\n     };\n     let p = try!(to_utf16(p));\n-    super::mkerr_libc(unsafe {\n+    mkerr_libc(unsafe {\n         libc::wutime(p.as_ptr(), &mut buf)\n     })\n }", "previous_filename": "src/libnative/io/file_windows.rs"}, {"sha": "c547c79e83a13a5e75c66777e6c8b21226f22312", "filename": "src/libstd/sys/windows/helper_signal.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Fhelper_signal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Fhelper_signal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhelper_signal.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::{mod, BOOL, LPCSTR, HANDLE, LPSECURITY_ATTRIBUTES, CloseHandle};\n+use ptr;\n+\n+pub type signal = HANDLE;\n+\n+pub fn new() -> (HANDLE, HANDLE) {\n+    unsafe {\n+        let handle = CreateEventA(ptr::null_mut(), libc::FALSE, libc::FALSE,\n+                                  ptr::null());\n+        (handle, handle)\n+    }\n+}\n+\n+pub fn signal(handle: HANDLE) {\n+    assert!(unsafe { SetEvent(handle) != 0 });\n+}\n+\n+pub fn close(handle: HANDLE) {\n+    assert!(unsafe { CloseHandle(handle) != 0 });\n+}\n+\n+extern \"system\" {\n+    fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n+                    bManualReset: BOOL,\n+                    bInitialState: BOOL,\n+                    lpName: LPCSTR) -> HANDLE;\n+    fn SetEvent(hEvent: HANDLE) -> BOOL;\n+}"}, {"sha": "98da4d4e7633d13773d39149f6d09529f0f3f7e9", "filename": "src/libstd/sys/windows/mod.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -0,0 +1,190 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(missing_doc)]\n+#![allow(non_camel_case_types)]\n+#![allow(non_snake_case)]\n+#![allow(unused_imports)]\n+#![allow(dead_code)]\n+#![allow(unused_unsafe)]\n+#![allow(unused_mut)]\n+\n+extern crate libc;\n+\n+use num;\n+use mem;\n+use prelude::*;\n+use io::{mod, IoResult, IoError};\n+use sync::{Once, ONCE_INIT};\n+\n+macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n+    static $name: Helper<$m> = Helper {\n+        lock: ::rt::mutex::NATIVE_MUTEX_INIT,\n+        chan: ::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n+        signal: ::cell::UnsafeCell { value: 0 },\n+        initialized: ::cell::UnsafeCell { value: false },\n+    };\n+) )\n+\n+pub mod c;\n+pub mod fs;\n+pub mod os;\n+pub mod tcp;\n+pub mod udp;\n+pub mod pipe;\n+pub mod helper_signal;\n+pub mod process;\n+pub mod timer;\n+pub mod tty;\n+\n+pub mod addrinfo {\n+    pub use sys_common::net::get_host_addresses;\n+}\n+\n+// FIXME: move these to c module\n+pub type sock_t = libc::SOCKET;\n+pub type wrlen = libc::c_int;\n+pub type msglen_t = libc::c_int;\n+pub unsafe fn close_sock(sock: sock_t) { let _ = libc::closesocket(sock); }\n+\n+// windows has zero values as errors\n+fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> {\n+    if ret == 0 {\n+        Err(last_error())\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n+pub fn last_error() -> IoError {\n+    let errno = os::errno() as i32;\n+    let mut err = decode_error(errno);\n+    err.detail = Some(os::error_string(errno));\n+    err\n+}\n+\n+pub fn last_net_error() -> IoError {\n+    let errno = unsafe { c::WSAGetLastError() as i32 };\n+    let mut err = decode_error(errno);\n+    err.detail = Some(os::error_string(errno));\n+    err\n+}\n+\n+pub fn last_gai_error(_errno: i32) -> IoError {\n+    last_net_error()\n+}\n+\n+/// Convert an `errno` value into a high-level error variant and description.\n+pub fn decode_error(errno: i32) -> IoError {\n+    let (kind, desc) = match errno {\n+        libc::EOF => (io::EndOfFile, \"end of file\"),\n+        libc::ERROR_NO_DATA => (io::BrokenPipe, \"the pipe is being closed\"),\n+        libc::ERROR_FILE_NOT_FOUND => (io::FileNotFound, \"file not found\"),\n+        libc::ERROR_INVALID_NAME => (io::InvalidInput, \"invalid file name\"),\n+        libc::WSAECONNREFUSED => (io::ConnectionRefused, \"connection refused\"),\n+        libc::WSAECONNRESET => (io::ConnectionReset, \"connection reset\"),\n+        libc::ERROR_ACCESS_DENIED | libc::WSAEACCES =>\n+            (io::PermissionDenied, \"permission denied\"),\n+        libc::WSAEWOULDBLOCK => {\n+            (io::ResourceUnavailable, \"resource temporarily unavailable\")\n+        }\n+        libc::WSAENOTCONN => (io::NotConnected, \"not connected\"),\n+        libc::WSAECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n+        libc::WSAEADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n+        libc::WSAEADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n+        libc::ERROR_BROKEN_PIPE => (io::EndOfFile, \"the pipe has ended\"),\n+        libc::ERROR_OPERATION_ABORTED =>\n+            (io::TimedOut, \"operation timed out\"),\n+        libc::WSAEINVAL => (io::InvalidInput, \"invalid argument\"),\n+        libc::ERROR_CALL_NOT_IMPLEMENTED =>\n+            (io::IoUnavailable, \"function not implemented\"),\n+        libc::ERROR_INVALID_HANDLE =>\n+            (io::MismatchedFileTypeForOperation,\n+             \"invalid handle provided to function\"),\n+        libc::ERROR_NOTHING_TO_TERMINATE =>\n+            (io::InvalidInput, \"no process to kill\"),\n+\n+        // libuv maps this error code to EISDIR. we do too. if it is found\n+        // to be incorrect, we can add in some more machinery to only\n+        // return this message when ERROR_INVALID_FUNCTION after certain\n+        // Windows calls.\n+        libc::ERROR_INVALID_FUNCTION => (io::InvalidInput,\n+                                         \"illegal operation on a directory\"),\n+\n+        _ => (io::OtherIoError, \"unknown error\")\n+    };\n+    IoError { kind: kind, desc: desc, detail: None }\n+}\n+\n+pub fn decode_error_detailed(errno: i32) -> IoError {\n+    let mut err = decode_error(errno);\n+    err.detail = Some(os::error_string(errno));\n+    err\n+}\n+\n+#[inline]\n+pub fn retry<I> (f: || -> I) -> I { f() } // PR rust-lang/rust/#17020\n+\n+pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n+    libc::timeval {\n+        tv_sec: (ms / 1000) as libc::c_long,\n+        tv_usec: ((ms % 1000) * 1000) as libc::c_long,\n+    }\n+}\n+\n+pub fn wouldblock() -> bool {\n+    let err = os::errno();\n+    err == libc::WSAEWOULDBLOCK as uint\n+}\n+\n+pub fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> {\n+    let mut set = nb as libc::c_ulong;\n+    if unsafe { c::ioctlsocket(fd, c::FIONBIO, &mut set) != 0 } {\n+        Err(last_error())\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n+pub fn init_net() {\n+    unsafe {\n+        static START: Once = ONCE_INIT;\n+\n+        START.doit(|| {\n+            let mut data: c::WSADATA = mem::zeroed();\n+            let ret = c::WSAStartup(0x202, // version 2.2\n+                                    &mut data);\n+            assert_eq!(ret, 0);\n+        });\n+    }\n+}\n+\n+pub fn unimpl() -> IoError {\n+    IoError {\n+        kind: io::IoUnavailable,\n+        desc: \"operation is not implemented\",\n+        detail: None,\n+    }\n+}\n+\n+pub fn to_utf16(s: Option<&str>) -> IoResult<Vec<u16>> {\n+    match s {\n+        Some(s) => Ok({\n+            let mut s = s.utf16_units().collect::<Vec<u16>>();\n+            s.push(0);\n+            s\n+        }),\n+        None => Err(IoError {\n+            kind: io::InvalidInput,\n+            desc: \"valid unicode input required\",\n+            detail: None\n+        })\n+    }\n+}"}, {"sha": "aaa1aaf6327944a8514840a088003e664715f47c", "filename": "src/libstd/sys/windows/os.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -0,0 +1,103 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// FIXME: move various extern bindings from here into liblibc or\n+// something similar\n+\n+use libc;\n+use libc::{c_int, c_char, c_void};\n+use prelude::*;\n+use io::{IoResult, IoError};\n+use sys::fs::FileDesc;\n+use ptr;\n+\n+use os::TMPBUF_SZ;\n+\n+pub fn errno() -> uint {\n+    use libc::types::os::arch::extra::DWORD;\n+\n+    #[link_name = \"kernel32\"]\n+    extern \"system\" {\n+        fn GetLastError() -> DWORD;\n+    }\n+\n+    unsafe {\n+        GetLastError() as uint\n+    }\n+}\n+\n+/// Get a detailed string description for the given error number\n+pub fn error_string(errnum: i32) -> String {\n+    use libc::types::os::arch::extra::DWORD;\n+    use libc::types::os::arch::extra::LPWSTR;\n+    use libc::types::os::arch::extra::LPVOID;\n+    use libc::types::os::arch::extra::WCHAR;\n+\n+    #[link_name = \"kernel32\"]\n+    extern \"system\" {\n+        fn FormatMessageW(flags: DWORD,\n+                          lpSrc: LPVOID,\n+                          msgId: DWORD,\n+                          langId: DWORD,\n+                          buf: LPWSTR,\n+                          nsize: DWORD,\n+                          args: *const c_void)\n+                          -> DWORD;\n+    }\n+\n+    static FORMAT_MESSAGE_FROM_SYSTEM: DWORD = 0x00001000;\n+    static FORMAT_MESSAGE_IGNORE_INSERTS: DWORD = 0x00000200;\n+\n+    // This value is calculated from the macro\n+    // MAKELANGID(LANG_SYSTEM_DEFAULT, SUBLANG_SYS_DEFAULT)\n+    let langId = 0x0800 as DWORD;\n+\n+    let mut buf = [0 as WCHAR, ..TMPBUF_SZ];\n+\n+    unsafe {\n+        let res = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |\n+                                 FORMAT_MESSAGE_IGNORE_INSERTS,\n+                                 ptr::null_mut(),\n+                                 errnum as DWORD,\n+                                 langId,\n+                                 buf.as_mut_ptr(),\n+                                 buf.len() as DWORD,\n+                                 ptr::null());\n+        if res == 0 {\n+            // Sometimes FormatMessageW can fail e.g. system doesn't like langId,\n+            let fm_err = errno();\n+            return format!(\"OS Error {} (FormatMessageW() returned error {})\", errnum, fm_err);\n+        }\n+\n+        let msg = String::from_utf16(::str::truncate_utf16_at_nul(buf));\n+        match msg {\n+            Some(msg) => format!(\"OS Error {}: {}\", errnum, msg),\n+            None => format!(\"OS Error {} (FormatMessageW() returned invalid UTF-16)\", errnum),\n+        }\n+    }\n+}\n+\n+pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n+    // Windows pipes work subtly differently than unix pipes, and their\n+    // inheritance has to be handled in a different way that I do not\n+    // fully understand. Here we explicitly make the pipe non-inheritable,\n+    // which means to pass it to a subprocess they need to be duplicated\n+    // first, as in std::run.\n+    let mut fds = [0, ..2];\n+    match libc::pipe(fds.as_mut_ptr(), 1024 as ::libc::c_uint,\n+                     (libc::O_BINARY | libc::O_NOINHERIT) as c_int) {\n+        0 => {\n+            assert!(fds[0] != -1 && fds[0] != 0);\n+            assert!(fds[1] != -1 && fds[1] != 0);\n+            Ok((FileDesc::new(fds[0], true), FileDesc::new(fds[1], true)))\n+        }\n+        _ => Err(IoError::last_error()),\n+    }\n+}"}, {"sha": "f2f7994a0057ca7a06f583d6ef3d2eb7eaf5fb66", "filename": "src/libstd/sys/windows/pipe.rs", "status": "renamed", "additions": 73, "deletions": 91, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -86,18 +86,17 @@\n \n use alloc::arc::Arc;\n use libc;\n-use std::c_str::CString;\n-use std::mem;\n-use std::os;\n-use std::ptr;\n-use std::rt::rtio;\n-use std::rt::rtio::{IoResult, IoError};\n-use std::sync::atomic;\n-use std::rt::mutex;\n-\n-use super::c;\n-use super::util;\n-use super::file::to_utf16;\n+use c_str::CString;\n+use mem;\n+use ptr;\n+use sync::atomic;\n+use rt::mutex;\n+use io::{mod, IoError, IoResult};\n+use prelude::*;\n+\n+use sys_common::{mod, eof};\n+\n+use super::{c, os, timer, to_utf16, decode_error_detailed};\n \n struct Event(libc::HANDLE);\n \n@@ -177,7 +176,7 @@ pub fn await(handle: libc::HANDLE, deadline: u64,\n     let ms = if deadline == 0 {\n         libc::INFINITE as u64\n     } else {\n-        let now = ::io::timer::now();\n+        let now = timer::now();\n         if deadline < now {0} else {deadline - now}\n     };\n     let ret = unsafe {\n@@ -190,16 +189,16 @@ pub fn await(handle: libc::HANDLE, deadline: u64,\n         WAIT_FAILED => Err(super::last_error()),\n         WAIT_TIMEOUT => unsafe {\n             let _ = c::CancelIo(handle);\n-            Err(util::timeout(\"operation timed out\"))\n+            Err(sys_common::timeout(\"operation timed out\"))\n         },\n         n => Ok((n - WAIT_OBJECT_0) as uint)\n     }\n }\n \n fn epipe() -> IoError {\n     IoError {\n-        code: libc::ERROR_BROKEN_PIPE as uint,\n-        extra: 0,\n+        kind: io::EndOfFile,\n+        desc: \"the pipe has ended\",\n         detail: None,\n     }\n }\n@@ -268,8 +267,8 @@ impl UnixStream {\n     }\n \n     pub fn connect(addr: &CString, timeout: Option<u64>) -> IoResult<UnixStream> {\n-        let addr = try!(to_utf16(addr));\n-        let start = ::io::timer::now();\n+        let addr = try!(to_utf16(addr.as_str()));\n+        let start = timer::now();\n         loop {\n             match UnixStream::try_connect(addr.as_ptr()) {\n                 Some(handle) => {\n@@ -308,13 +307,13 @@ impl UnixStream {\n \n             match timeout {\n                 Some(timeout) => {\n-                    let now = ::io::timer::now();\n+                    let now = timer::now();\n                     let timed_out = (now - start) >= timeout || unsafe {\n                         let ms = (timeout - (now - start)) as libc::DWORD;\n                         libc::WaitNamedPipeW(addr.as_ptr(), ms) == 0\n                     };\n                     if timed_out {\n-                        return Err(util::timeout(\"connect timed out\"))\n+                        return Err(sys_common::timeout(\"connect timed out\"))\n                     }\n                 }\n \n@@ -349,10 +348,8 @@ impl UnixStream {\n             _ => Ok(())\n         }\n     }\n-}\n \n-impl rtio::RtioPipe for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         if self.read.is_none() {\n             self.read = Some(try!(Event::new(true, false)));\n         }\n@@ -368,7 +365,7 @@ impl rtio::RtioPipe for UnixStream {\n         // See comments in close_read() about why this lock is necessary.\n         let guard = unsafe { self.inner.lock.lock() };\n         if self.read_closed() {\n-            return Err(util::eof())\n+            return Err(eof())\n         }\n \n         // Issue a nonblocking requests, succeeding quickly if it happened to\n@@ -416,15 +413,15 @@ impl rtio::RtioPipe for UnixStream {\n             // If the reading half is now closed, then we're done. If we woke up\n             // because the writing half was closed, keep trying.\n             if wait_succeeded.is_err() {\n-                return Err(util::timeout(\"read timed out\"))\n+                return Err(sys_common::timeout(\"read timed out\"))\n             }\n             if self.read_closed() {\n-                return Err(util::eof())\n+                return Err(eof())\n             }\n         }\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         if self.write.is_none() {\n             self.write = Some(try!(Event::new(true, false)));\n         }\n@@ -458,11 +455,7 @@ impl rtio::RtioPipe for UnixStream {\n \n             if ret == 0 {\n                 if err != libc::ERROR_IO_PENDING as uint {\n-                    return Err(IoError {\n-                        code: err as uint,\n-                        extra: 0,\n-                        detail: Some(os::error_string(err as uint)),\n-                    })\n+                    return Err(decode_error_detailed(err as i32))\n                 }\n                 // Process a timeout if one is pending\n                 let wait_succeeded = await(self.handle(), self.write_deadline,\n@@ -484,12 +477,12 @@ impl rtio::RtioPipe for UnixStream {\n                         let amt = offset + bytes_written as uint;\n                         return if amt > 0 {\n                             Err(IoError {\n-                                code: libc::ERROR_OPERATION_ABORTED as uint,\n-                                extra: amt,\n-                                detail: Some(\"short write during write\".to_string()),\n+                                kind: io::ShortWrite(amt),\n+                                desc: \"short write during write\",\n+                                detail: None,\n                             })\n                         } else {\n-                            Err(util::timeout(\"write timed out\"))\n+                            Err(sys_common::timeout(\"write timed out\"))\n                         }\n                     }\n                     if self.write_closed() {\n@@ -503,17 +496,7 @@ impl rtio::RtioPipe for UnixStream {\n         Ok(())\n     }\n \n-    fn clone(&self) -> Box<rtio::RtioPipe + Send> {\n-        box UnixStream {\n-            inner: self.inner.clone(),\n-            read: None,\n-            write: None,\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        } as Box<rtio::RtioPipe + Send>\n-    }\n-\n-    fn close_read(&mut self) -> IoResult<()> {\n+    pub fn close_read(&mut self) -> IoResult<()> {\n         // On windows, there's no actual shutdown() method for pipes, so we're\n         // forced to emulate the behavior manually at the application level. To\n         // do this, we need to both cancel any pending requests, as well as\n@@ -536,23 +519,35 @@ impl rtio::RtioPipe for UnixStream {\n         self.cancel_io()\n     }\n \n-    fn close_write(&mut self) -> IoResult<()> {\n+    pub fn close_write(&mut self) -> IoResult<()> {\n         // see comments in close_read() for why this lock is necessary\n         let _guard = unsafe { self.inner.lock.lock() };\n         self.inner.write_closed.store(true, atomic::SeqCst);\n         self.cancel_io()\n     }\n \n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        let deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n         self.read_deadline = deadline;\n         self.write_deadline = deadline;\n     }\n-    fn set_read_timeout(&mut self, timeout: Option<u64>) {\n-        self.read_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    pub fn set_read_timeout(&mut self, timeout: Option<u64>) {\n+        self.read_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }\n-    fn set_write_timeout(&mut self, timeout: Option<u64>) {\n-        self.write_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    pub fn set_write_timeout(&mut self, timeout: Option<u64>) {\n+        self.write_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n+    }\n+}\n+\n+impl Clone for UnixStream {\n+    fn clone(&self) -> UnixStream {\n+        UnixStream {\n+            inner: self.inner.clone(),\n+            read: None,\n+            write: None,\n+            read_deadline: 0,\n+            write_deadline: 0,\n+        }\n     }\n }\n \n@@ -570,7 +565,7 @@ impl UnixListener {\n         // Although we technically don't need the pipe until much later, we\n         // create the initial handle up front to test the validity of the name\n         // and such.\n-        let addr_v = try!(to_utf16(addr));\n+        let addr_v = try!(to_utf16(addr.as_str()));\n         let ret = unsafe { pipe(addr_v.as_ptr(), true) };\n         if ret == libc::INVALID_HANDLE_VALUE {\n             Err(super::last_error())\n@@ -579,7 +574,7 @@ impl UnixListener {\n         }\n     }\n \n-    pub fn native_listen(self) -> IoResult<UnixAcceptor> {\n+    pub fn listen(self) -> IoResult<UnixAcceptor> {\n         Ok(UnixAcceptor {\n             listener: self,\n             event: try!(Event::new(true, false)),\n@@ -598,15 +593,6 @@ impl Drop for UnixListener {\n     }\n }\n \n-impl rtio::RtioUnixListener for UnixListener {\n-    fn listen(self: Box<UnixListener>)\n-              -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n-        self.native_listen().map(|a| {\n-            box a as Box<rtio::RtioUnixAcceptor + Send>\n-        })\n-    }\n-}\n-\n pub struct UnixAcceptor {\n     inner: Arc<AcceptorState>,\n     listener: UnixListener,\n@@ -620,7 +606,7 @@ struct AcceptorState {\n }\n \n impl UnixAcceptor {\n-    pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n+    pub fn accept(&mut self) -> IoResult<UnixStream> {\n         // This function has some funky implementation details when working with\n         // unix pipes. On windows, each server named pipe handle can be\n         // connected to a one or zero clients. To the best of my knowledge, a\n@@ -657,9 +643,9 @@ impl UnixAcceptor {\n \n         // If we've had an artificial call to close_accept, be sure to never\n         // proceed in accepting new clients in the future\n-        if self.inner.closed.load(atomic::SeqCst) { return Err(util::eof()) }\n+        if self.inner.closed.load(atomic::SeqCst) { return Err(eof()) }\n \n-        let name = try!(to_utf16(&self.listener.name));\n+        let name = try!(to_utf16(self.listener.name.as_str()));\n \n         // Once we've got a \"server handle\", we need to wait for a client to\n         // connect. The ConnectNamedPipe function will block this thread until\n@@ -691,7 +677,7 @@ impl UnixAcceptor {\n                     if wait_succeeded.is_ok() {\n                         err = unsafe { libc::GetLastError() };\n                     } else {\n-                        return Err(util::timeout(\"accept timed out\"))\n+                        return Err(sys_common::timeout(\"accept timed out\"))\n                     }\n                 } else {\n                     // we succeeded, bypass the check below\n@@ -727,19 +713,28 @@ impl UnixAcceptor {\n             write_deadline: 0,\n         })\n     }\n-}\n \n-impl rtio::RtioUnixAcceptor for UnixAcceptor {\n-    fn accept(&mut self) -> IoResult<Box<rtio::RtioPipe + Send>> {\n-        self.native_accept().map(|s| box s as Box<rtio::RtioPipe + Send>)\n+    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n+        self.deadline = timeout.map(|i| i + timer::now()).unwrap_or(0);\n     }\n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        self.deadline = timeout.map(|i| i + ::io::timer::now()).unwrap_or(0);\n+\n+    pub fn close_accept(&mut self) -> IoResult<()> {\n+        self.inner.closed.store(true, atomic::SeqCst);\n+        let ret = unsafe {\n+            c::SetEvent(self.inner.abort.handle())\n+        };\n+        if ret == 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n+        }\n     }\n+}\n \n-    fn clone(&self) -> Box<rtio::RtioUnixAcceptor + Send> {\n-        let name = to_utf16(&self.listener.name).ok().unwrap();\n-        box UnixAcceptor {\n+impl Clone for UnixAcceptor {\n+    fn clone(&self) -> UnixAcceptor {\n+        let name = to_utf16(self.listener.name.as_str()).ok().unwrap();\n+        UnixAcceptor {\n             inner: self.inner.clone(),\n             event: Event::new(true, false).ok().unwrap(),\n             deadline: 0,\n@@ -751,19 +746,6 @@ impl rtio::RtioUnixAcceptor for UnixAcceptor {\n                     p\n                 },\n             },\n-        } as Box<rtio::RtioUnixAcceptor + Send>\n-    }\n-\n-    fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.closed.store(true, atomic::SeqCst);\n-        let ret = unsafe {\n-            c::SetEvent(self.inner.abort.handle())\n-        };\n-        if ret == 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n         }\n     }\n }\n-", "previous_filename": "src/libnative/io/pipe_windows.rs"}, {"sha": "67e87841ed24dc56af11dc74bbb57b826b232415", "filename": "src/libstd/sys/windows/process.rs", "status": "added", "additions": 511, "deletions": 0, "changes": 511, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -0,0 +1,511 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::{pid_t, c_void, c_int};\n+use libc;\n+use c_str::CString;\n+use io;\n+use mem;\n+use os;\n+use ptr;\n+use prelude::*;\n+use io::process::{ProcessExit, ExitStatus, ExitSignal};\n+use collections;\n+use path::BytesContainer;\n+use hash::Hash;\n+use io::{IoResult, IoError};\n+\n+use sys::fs;\n+use sys::{mod, retry, c, wouldblock, set_nonblocking, ms_to_timeval, timer};\n+use sys::fs::FileDesc;\n+use sys_common::helper_thread::Helper;\n+use sys_common::{AsFileDesc, mkerr_libc, timeout};\n+\n+use io::fs::PathExtensions;\n+use string::String;\n+\n+pub use sys_common::ProcessConfig;\n+\n+/**\n+ * A value representing a child process.\n+ *\n+ * The lifetime of this value is linked to the lifetime of the actual\n+ * process - the Process destructor calls self.finish() which waits\n+ * for the process to terminate.\n+ */\n+pub struct Process {\n+    /// The unique id of the process (this should never be negative).\n+    pid: pid_t,\n+\n+    /// A HANDLE to the process, which will prevent the pid being\n+    /// re-used until the handle is closed.\n+    handle: *mut (),\n+}\n+\n+impl Drop for Process {\n+    fn drop(&mut self) {\n+        free_handle(self.handle);\n+    }\n+}\n+\n+impl Process {\n+    pub fn id(&self) -> pid_t {\n+        self.pid\n+    }\n+\n+    pub unsafe fn kill(&self, signal: int) -> IoResult<()> {\n+        Process::killpid(self.pid, signal)\n+    }\n+\n+    pub unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> {\n+        let handle = libc::OpenProcess(libc::PROCESS_TERMINATE |\n+                                       libc::PROCESS_QUERY_INFORMATION,\n+                                       libc::FALSE, pid as libc::DWORD);\n+        if handle.is_null() {\n+            return Err(super::last_error())\n+        }\n+        let ret = match signal {\n+            // test for existence on signal 0\n+            0 => {\n+                let mut status = 0;\n+                let ret = libc::GetExitCodeProcess(handle, &mut status);\n+                if ret == 0 {\n+                    Err(super::last_error())\n+                } else if status != libc::STILL_ACTIVE {\n+                    Err(IoError {\n+                        kind: io::InvalidInput,\n+                        desc: \"no process to kill\",\n+                        detail: None,\n+                    })\n+                } else {\n+                    Ok(())\n+                }\n+            }\n+            15 | 9 => { // sigterm or sigkill\n+                let ret = libc::TerminateProcess(handle, 1);\n+                super::mkerr_winbool(ret)\n+            }\n+            _ => Err(IoError {\n+                kind: io::IoUnavailable,\n+                desc: \"unsupported signal on windows\",\n+                detail: None,\n+            })\n+        };\n+        let _ = libc::CloseHandle(handle);\n+        return ret;\n+    }\n+\n+    pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n+                              out_fd: Option<P>, err_fd: Option<P>)\n+                              -> IoResult<Process>\n+        where C: ProcessConfig<K, V>, P: AsFileDesc,\n+              K: BytesContainer + Eq + Hash, V: BytesContainer\n+    {\n+        use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n+        use libc::consts::os::extra::{\n+            TRUE, FALSE,\n+            STARTF_USESTDHANDLES,\n+            INVALID_HANDLE_VALUE,\n+            DUPLICATE_SAME_ACCESS\n+        };\n+        use libc::funcs::extra::kernel32::{\n+            GetCurrentProcess,\n+            DuplicateHandle,\n+            CloseHandle,\n+            CreateProcessW\n+        };\n+        use libc::funcs::extra::msvcrt::get_osfhandle;\n+\n+        use mem;\n+        use iter::Iterator;\n+        use str::StrPrelude;\n+\n+        if cfg.gid().is_some() || cfg.uid().is_some() {\n+            return Err(IoError {\n+                kind: io::IoUnavailable,\n+                desc: \"unsupported gid/uid requested on windows\",\n+                detail: None,\n+            })\n+        }\n+\n+        // To have the spawning semantics of unix/windows stay the same, we need to\n+        // read the *child's* PATH if one is provided. See #15149 for more details.\n+        let program = cfg.env().and_then(|env| {\n+            for (key, v) in env.iter() {\n+                if b\"PATH\" != key.container_as_bytes() { continue }\n+\n+                // Split the value and test each path to see if the\n+                // program exists.\n+                for path in os::split_paths(v.container_as_bytes()).into_iter() {\n+                    let path = path.join(cfg.program().as_bytes_no_nul())\n+                                   .with_extension(os::consts::EXE_EXTENSION);\n+                    if path.exists() {\n+                        return Some(path.to_c_str())\n+                    }\n+                }\n+                break\n+            }\n+            None\n+        });\n+\n+        unsafe {\n+            let mut si = zeroed_startupinfo();\n+            si.cb = mem::size_of::<STARTUPINFO>() as DWORD;\n+            si.dwFlags = STARTF_USESTDHANDLES;\n+\n+            let cur_proc = GetCurrentProcess();\n+\n+            // Similarly to unix, we don't actually leave holes for the stdio file\n+            // descriptors, but rather open up /dev/null equivalents. These\n+            // equivalents are drawn from libuv's windows process spawning.\n+            let set_fd = |fd: &Option<P>, slot: &mut HANDLE,\n+                          is_stdin: bool| {\n+                match *fd {\n+                    None => {\n+                        let access = if is_stdin {\n+                            libc::FILE_GENERIC_READ\n+                        } else {\n+                            libc::FILE_GENERIC_WRITE | libc::FILE_READ_ATTRIBUTES\n+                        };\n+                        let size = mem::size_of::<libc::SECURITY_ATTRIBUTES>();\n+                        let mut sa = libc::SECURITY_ATTRIBUTES {\n+                            nLength: size as libc::DWORD,\n+                            lpSecurityDescriptor: ptr::null_mut(),\n+                            bInheritHandle: 1,\n+                        };\n+                        let mut filename: Vec<u16> = \"NUL\".utf16_units().collect();\n+                        filename.push(0);\n+                        *slot = libc::CreateFileW(filename.as_ptr(),\n+                                                  access,\n+                                                  libc::FILE_SHARE_READ |\n+                                                      libc::FILE_SHARE_WRITE,\n+                                                  &mut sa,\n+                                                  libc::OPEN_EXISTING,\n+                                                  0,\n+                                                  ptr::null_mut());\n+                        if *slot == INVALID_HANDLE_VALUE {\n+                            return Err(super::last_error())\n+                        }\n+                    }\n+                    Some(ref fd) => {\n+                        let orig = get_osfhandle(fd.as_fd().fd()) as HANDLE;\n+                        if orig == INVALID_HANDLE_VALUE {\n+                            return Err(super::last_error())\n+                        }\n+                        if DuplicateHandle(cur_proc, orig, cur_proc, slot,\n+                                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+                            return Err(super::last_error())\n+                        }\n+                    }\n+                }\n+                Ok(())\n+            };\n+\n+            try!(set_fd(&in_fd, &mut si.hStdInput, true));\n+            try!(set_fd(&out_fd, &mut si.hStdOutput, false));\n+            try!(set_fd(&err_fd, &mut si.hStdError, false));\n+\n+            let cmd_str = make_command_line(program.as_ref().unwrap_or(cfg.program()),\n+                                            cfg.args());\n+            let mut pi = zeroed_process_information();\n+            let mut create_err = None;\n+\n+            // stolen from the libuv code.\n+            let mut flags = libc::CREATE_UNICODE_ENVIRONMENT;\n+            if cfg.detach() {\n+                flags |= libc::DETACHED_PROCESS | libc::CREATE_NEW_PROCESS_GROUP;\n+            }\n+\n+            with_envp(cfg.env(), |envp| {\n+                with_dirp(cfg.cwd(), |dirp| {\n+                    let mut cmd_str: Vec<u16> = cmd_str.as_slice().utf16_units().collect();\n+                    cmd_str.push(0);\n+                    let created = CreateProcessW(ptr::null(),\n+                                                 cmd_str.as_mut_ptr(),\n+                                                 ptr::null_mut(),\n+                                                 ptr::null_mut(),\n+                                                 TRUE,\n+                                                 flags, envp, dirp,\n+                                                 &mut si, &mut pi);\n+                    if created == FALSE {\n+                        create_err = Some(super::last_error());\n+                    }\n+                })\n+            });\n+\n+            assert!(CloseHandle(si.hStdInput) != 0);\n+            assert!(CloseHandle(si.hStdOutput) != 0);\n+            assert!(CloseHandle(si.hStdError) != 0);\n+\n+            match create_err {\n+                Some(err) => return Err(err),\n+                None => {}\n+            }\n+\n+            // We close the thread handle because we don't care about keeping the\n+            // thread id valid, and we aren't keeping the thread handle around to be\n+            // able to close it later. We don't close the process handle however\n+            // because std::we want the process id to stay valid at least until the\n+            // calling code closes the process handle.\n+            assert!(CloseHandle(pi.hThread) != 0);\n+\n+            Ok(Process {\n+                pid: pi.dwProcessId as pid_t,\n+                handle: pi.hProcess as *mut ()\n+            })\n+        }\n+    }\n+\n+    /**\n+     * Waits for a process to exit and returns the exit code, failing\n+     * if there is no process with the specified id.\n+     *\n+     * Note that this is private to avoid race conditions on unix where if\n+     * a user calls waitpid(some_process.get_id()) then some_process.finish()\n+     * and some_process.destroy() and some_process.finalize() will then either\n+     * operate on a none-existent process or, even worse, on a newer process\n+     * with the same id.\n+     */\n+    pub fn wait(&self, deadline: u64) -> IoResult<ProcessExit> {\n+        use libc::types::os::arch::extra::DWORD;\n+        use libc::consts::os::extra::{\n+            SYNCHRONIZE,\n+            PROCESS_QUERY_INFORMATION,\n+            FALSE,\n+            STILL_ACTIVE,\n+            INFINITE,\n+            WAIT_TIMEOUT,\n+            WAIT_OBJECT_0,\n+        };\n+        use libc::funcs::extra::kernel32::{\n+            OpenProcess,\n+            GetExitCodeProcess,\n+            CloseHandle,\n+            WaitForSingleObject,\n+        };\n+\n+        unsafe {\n+            let process = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION,\n+                                      FALSE,\n+                                      self.pid as DWORD);\n+            if process.is_null() {\n+                return Err(super::last_error())\n+            }\n+\n+            loop {\n+                let mut status = 0;\n+                if GetExitCodeProcess(process, &mut status) == FALSE {\n+                    let err = Err(super::last_error());\n+                    assert!(CloseHandle(process) != 0);\n+                    return err;\n+                }\n+                if status != STILL_ACTIVE {\n+                    assert!(CloseHandle(process) != 0);\n+                    return Ok(ExitStatus(status as int));\n+                }\n+                let interval = if deadline == 0 {\n+                    INFINITE\n+                } else {\n+                    let now = timer::now();\n+                    if deadline < now {0} else {(deadline - now) as u32}\n+                };\n+                match WaitForSingleObject(process, interval) {\n+                    WAIT_OBJECT_0 => {}\n+                    WAIT_TIMEOUT => {\n+                        assert!(CloseHandle(process) != 0);\n+                        return Err(timeout(\"process wait timed out\"))\n+                    }\n+                    _ => {\n+                        let err = Err(super::last_error());\n+                        assert!(CloseHandle(process) != 0);\n+                        return err\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n+    libc::types::os::arch::extra::STARTUPINFO {\n+        cb: 0,\n+        lpReserved: ptr::null_mut(),\n+        lpDesktop: ptr::null_mut(),\n+        lpTitle: ptr::null_mut(),\n+        dwX: 0,\n+        dwY: 0,\n+        dwXSize: 0,\n+        dwYSize: 0,\n+        dwXCountChars: 0,\n+        dwYCountCharts: 0,\n+        dwFillAttribute: 0,\n+        dwFlags: 0,\n+        wShowWindow: 0,\n+        cbReserved2: 0,\n+        lpReserved2: ptr::null_mut(),\n+        hStdInput: libc::INVALID_HANDLE_VALUE,\n+        hStdOutput: libc::INVALID_HANDLE_VALUE,\n+        hStdError: libc::INVALID_HANDLE_VALUE,\n+    }\n+}\n+\n+fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION {\n+    libc::types::os::arch::extra::PROCESS_INFORMATION {\n+        hProcess: ptr::null_mut(),\n+        hThread: ptr::null_mut(),\n+        dwProcessId: 0,\n+        dwThreadId: 0\n+    }\n+}\n+\n+fn make_command_line(prog: &CString, args: &[CString]) -> String {\n+    let mut cmd = String::new();\n+    append_arg(&mut cmd, prog.as_str()\n+                             .expect(\"expected program name to be utf-8 encoded\"));\n+    for arg in args.iter() {\n+        cmd.push(' ');\n+        append_arg(&mut cmd, arg.as_str()\n+                                .expect(\"expected argument to be utf-8 encoded\"));\n+    }\n+    return cmd;\n+\n+    fn append_arg(cmd: &mut String, arg: &str) {\n+        // If an argument has 0 characters then we need to quote it to ensure\n+        // that it actually gets passed through on the command line or otherwise\n+        // it will be dropped entirely when parsed on the other end.\n+        let quote = arg.chars().any(|c| c == ' ' || c == '\\t') || arg.len() == 0;\n+        if quote {\n+            cmd.push('\"');\n+        }\n+        let argvec: Vec<char> = arg.chars().collect();\n+        for i in range(0u, argvec.len()) {\n+            append_char_at(cmd, argvec.as_slice(), i);\n+        }\n+        if quote {\n+            cmd.push('\"');\n+        }\n+    }\n+\n+    fn append_char_at(cmd: &mut String, arg: &[char], i: uint) {\n+        match arg[i] {\n+            '\"' => {\n+                // Escape quotes.\n+                cmd.push_str(\"\\\\\\\"\");\n+            }\n+            '\\\\' => {\n+                if backslash_run_ends_in_quote(arg, i) {\n+                    // Double all backslashes that are in runs before quotes.\n+                    cmd.push_str(\"\\\\\\\\\");\n+                } else {\n+                    // Pass other backslashes through unescaped.\n+                    cmd.push('\\\\');\n+                }\n+            }\n+            c => {\n+                cmd.push(c);\n+            }\n+        }\n+    }\n+\n+    fn backslash_run_ends_in_quote(s: &[char], mut i: uint) -> bool {\n+        while i < s.len() && s[i] == '\\\\' {\n+            i += 1;\n+        }\n+        return i < s.len() && s[i] == '\"';\n+    }\n+}\n+\n+fn with_envp<K, V, T>(env: Option<&collections::HashMap<K, V>>,\n+                      cb: |*mut c_void| -> T) -> T\n+    where K: BytesContainer + Eq + Hash, V: BytesContainer\n+{\n+    // On Windows we pass an \"environment block\" which is not a char**, but\n+    // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n+    // \\0 to terminate.\n+    match env {\n+        Some(env) => {\n+            let mut blk = Vec::new();\n+\n+            for pair in env.iter() {\n+                let kv = format!(\"{}={}\",\n+                                 pair.ref0().container_as_str().unwrap(),\n+                                 pair.ref1().container_as_str().unwrap());\n+                blk.extend(kv.as_slice().utf16_units());\n+                blk.push(0);\n+            }\n+\n+            blk.push(0);\n+\n+            cb(blk.as_mut_ptr() as *mut c_void)\n+        }\n+        _ => cb(ptr::null_mut())\n+    }\n+}\n+\n+fn with_dirp<T>(d: Option<&CString>, cb: |*const u16| -> T) -> T {\n+    match d {\n+      Some(dir) => {\n+          let dir_str = dir.as_str()\n+                           .expect(\"expected workingdirectory to be utf-8 encoded\");\n+          let mut dir_str: Vec<u16> = dir_str.utf16_units().collect();\n+          dir_str.push(0);\n+          cb(dir_str.as_ptr())\n+      },\n+      None => cb(ptr::null())\n+    }\n+}\n+\n+fn free_handle(handle: *mut ()) {\n+    assert!(unsafe {\n+        libc::CloseHandle(mem::transmute(handle)) != 0\n+    })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    fn test_make_command_line() {\n+        use prelude::*;\n+        use str;\n+        use c_str::CString;\n+        use super::make_command_line;\n+\n+        fn test_wrapper(prog: &str, args: &[&str]) -> String {\n+            make_command_line(&prog.to_c_str(),\n+                              args.iter()\n+                                  .map(|a| a.to_c_str())\n+                                  .collect::<Vec<CString>>()\n+                                  .as_slice())\n+        }\n+\n+        assert_eq!(\n+            test_wrapper(\"prog\", [\"aaa\", \"bbb\", \"ccc\"]),\n+            \"prog aaa bbb ccc\".to_string()\n+        );\n+\n+        assert_eq!(\n+            test_wrapper(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", [\"aaa\"]),\n+            \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\".to_string()\n+        );\n+        assert_eq!(\n+            test_wrapper(\"C:\\\\Program Files\\\\test\", [\"aa\\\"bb\"]),\n+            \"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\".to_string()\n+        );\n+        assert_eq!(\n+            test_wrapper(\"echo\", [\"a b c\"]),\n+            \"echo \\\"a b c\\\"\".to_string()\n+        );\n+        assert_eq!(\n+            test_wrapper(\"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\", []),\n+            \"\\u03c0\\u042f\\u97f3\\u00e6\\u221e\".to_string()\n+        );\n+    }\n+}"}, {"sha": "3baf2be08d238c12c0d4bea96580fbc3252512aa", "filename": "src/libstd/sys/windows/tcp.rs", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -0,0 +1,219 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io::net::ip;\n+use io::IoResult;\n+use libc;\n+use mem;\n+use ptr;\n+use prelude::*;\n+use super::{last_error, last_net_error, retry, sock_t};\n+use sync::{Arc, atomic};\n+use sys::fs::FileDesc;\n+use sys::{mod, c, set_nonblocking, wouldblock, timer};\n+use sys_common::{mod, timeout, eof};\n+use sys_common::net::*;\n+\n+pub use sys_common::net::TcpStream;\n+\n+pub struct Event(c::WSAEVENT);\n+\n+impl Event {\n+    pub fn new() -> IoResult<Event> {\n+        let event = unsafe { c::WSACreateEvent() };\n+        if event == c::WSA_INVALID_EVENT {\n+            Err(super::last_error())\n+        } else {\n+            Ok(Event(event))\n+        }\n+    }\n+\n+    pub fn handle(&self) -> c::WSAEVENT { let Event(handle) = *self; handle }\n+}\n+\n+impl Drop for Event {\n+    fn drop(&mut self) {\n+        unsafe { let _ = c::WSACloseEvent(self.handle()); }\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// TCP listeners\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct TcpListener {\n+    inner: FileDesc,\n+}\n+\n+impl TcpListener {\n+    pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> {\n+        sys::init_net();\n+\n+        let fd = try!(socket(addr, libc::SOCK_STREAM));\n+        let ret = TcpListener { inner: FileDesc::new(fd as libc::c_int, true) };\n+\n+        let mut storage = unsafe { mem::zeroed() };\n+        let len = addr_to_sockaddr(addr, &mut storage);\n+        let addrp = &storage as *const _ as *const libc::sockaddr;\n+\n+        match unsafe { libc::bind(fd, addrp, len) } {\n+            -1 => Err(last_net_error()),\n+            _ => Ok(ret),\n+        }\n+    }\n+\n+    pub fn fd(&self) -> sock_t { self.inner.fd as sock_t }\n+\n+    pub fn listen(self, backlog: int) -> IoResult<TcpAcceptor> {\n+        match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n+            -1 => Err(last_net_error()),\n+\n+            _ => {\n+                let accept = try!(Event::new());\n+                let ret = unsafe {\n+                    c::WSAEventSelect(self.fd(), accept.handle(), c::FD_ACCEPT)\n+                };\n+                if ret != 0 {\n+                    return Err(last_net_error())\n+                }\n+                Ok(TcpAcceptor {\n+                    inner: Arc::new(AcceptorInner {\n+                        listener: self,\n+                        abort: try!(Event::new()),\n+                        accept: accept,\n+                        closed: atomic::AtomicBool::new(false),\n+                    }),\n+                    deadline: 0,\n+                })\n+            }\n+        }\n+    }\n+\n+    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd(), libc::getsockname)\n+    }\n+}\n+\n+pub struct TcpAcceptor {\n+    inner: Arc<AcceptorInner>,\n+    deadline: u64,\n+}\n+\n+struct AcceptorInner {\n+    listener: TcpListener,\n+    abort: Event,\n+    accept: Event,\n+    closed: atomic::AtomicBool,\n+}\n+\n+impl TcpAcceptor {\n+    pub fn fd(&self) -> sock_t { self.inner.listener.fd() }\n+\n+    pub fn accept(&mut self) -> IoResult<TcpStream> {\n+        // Unlink unix, windows cannot invoke `select` on arbitrary file\n+        // descriptors like pipes, only sockets. Consequently, windows cannot\n+        // use the same implementation as unix for accept() when close_accept()\n+        // is considered.\n+        //\n+        // In order to implement close_accept() and timeouts, windows uses\n+        // event handles. An acceptor-specific abort event is created which\n+        // will only get set in close_accept(), and it will never be un-set.\n+        // Additionally, another acceptor-specific event is associated with the\n+        // FD_ACCEPT network event.\n+        //\n+        // These two events are then passed to WaitForMultipleEvents to see\n+        // which one triggers first, and the timeout passed to this function is\n+        // the local timeout for the acceptor.\n+        //\n+        // If the wait times out, then the accept timed out. If the wait\n+        // succeeds with the abort event, then we were closed, and if the wait\n+        // succeeds otherwise, then we do a nonblocking poll via `accept` to\n+        // see if we can accept a connection. The connection is candidate to be\n+        // stolen, so we do all of this in a loop as well.\n+        let events = [self.inner.abort.handle(), self.inner.accept.handle()];\n+\n+        while !self.inner.closed.load(atomic::SeqCst) {\n+            let ms = if self.deadline == 0 {\n+                c::WSA_INFINITE as u64\n+            } else {\n+                let now = timer::now();\n+                if self.deadline < now {0} else {self.deadline - now}\n+            };\n+            let ret = unsafe {\n+                c::WSAWaitForMultipleEvents(2, events.as_ptr(), libc::FALSE,\n+                                            ms as libc::DWORD, libc::FALSE)\n+            };\n+            match ret {\n+                c::WSA_WAIT_TIMEOUT => {\n+                    return Err(timeout(\"accept timed out\"))\n+                }\n+                c::WSA_WAIT_FAILED => return Err(last_net_error()),\n+                c::WSA_WAIT_EVENT_0 => break,\n+                n => assert_eq!(n, c::WSA_WAIT_EVENT_0 + 1),\n+            }\n+\n+            let mut wsaevents: c::WSANETWORKEVENTS = unsafe { mem::zeroed() };\n+            let ret = unsafe {\n+                c::WSAEnumNetworkEvents(self.fd(), events[1], &mut wsaevents)\n+            };\n+            if ret != 0 { return Err(last_net_error()) }\n+\n+            if wsaevents.lNetworkEvents & c::FD_ACCEPT == 0 { continue }\n+            match unsafe {\n+                libc::accept(self.fd(), ptr::null_mut(), ptr::null_mut())\n+            } {\n+                -1 if wouldblock() => {}\n+                -1 => return Err(last_net_error()),\n+\n+                // Accepted sockets inherit the same properties as the caller,\n+                // so we need to deregister our event and switch the socket back\n+                // to blocking mode\n+                fd => {\n+                    let stream = TcpStream::new(fd);\n+                    let ret = unsafe {\n+                        c::WSAEventSelect(fd, events[1], 0)\n+                    };\n+                    if ret != 0 { return Err(last_net_error()) }\n+                    try!(set_nonblocking(fd, false));\n+                    return Ok(stream)\n+                }\n+            }\n+        }\n+\n+        Err(eof())\n+    }\n+\n+    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd(), libc::getsockname)\n+    }\n+\n+    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n+        self.deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n+    }\n+\n+    pub fn close_accept(&mut self) -> IoResult<()> {\n+        self.inner.closed.store(true, atomic::SeqCst);\n+        let ret = unsafe { c::WSASetEvent(self.inner.abort.handle()) };\n+        if ret == libc::TRUE {\n+            Ok(())\n+        } else {\n+            Err(last_net_error())\n+        }\n+    }\n+}\n+\n+impl Clone for TcpAcceptor {\n+    fn clone(&self) -> TcpAcceptor {\n+        TcpAcceptor {\n+            inner: self.inner.clone(),\n+            deadline: 0,\n+        }\n+    }\n+}"}, {"sha": "f507be2a985dfed573913e5eb4eda883d33e195a", "filename": "src/libstd/sys/windows/timer.rs", "status": "renamed", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -21,15 +21,21 @@\n //! the other two implementations of timers with nothing *that* new showing up.\n \n use libc;\n-use std::ptr;\n-use std::rt::rtio;\n-use std::rt::rtio::{IoResult, Callback};\n-use std::comm;\n+use ptr;\n+use comm;\n \n-use io::helper_thread::Helper;\n+use sys::c;\n+use sys::fs::FileDesc;\n+use sys_common::helper_thread::Helper;\n+use prelude::*;\n+use io::IoResult;\n \n helper_init!(static HELPER: Helper<Req>)\n \n+pub trait Callback {\n+    fn call(&mut self);\n+}\n+\n pub struct Timer {\n     obj: libc::HANDLE,\n     on_worker: bool,\n@@ -116,12 +122,6 @@ impl Timer {\n         }\n     }\n \n-    pub fn sleep(ms: u64) {\n-        use std::rt::rtio::RtioTimer;\n-        let mut t = Timer::new().ok().expect(\"must allocate a timer!\");\n-        t.sleep(ms);\n-    }\n-\n     fn remove(&mut self) {\n         if !self.on_worker { return }\n \n@@ -131,10 +131,8 @@ impl Timer {\n \n         self.on_worker = false;\n     }\n-}\n \n-impl rtio::RtioTimer for Timer {\n-    fn sleep(&mut self, msecs: u64) {\n+    pub fn sleep(&mut self, msecs: u64) {\n         self.remove();\n \n         // there are 10^6 nanoseconds in a millisecond, and the parameter is in\n@@ -148,7 +146,7 @@ impl rtio::RtioTimer for Timer {\n         let _ = unsafe { imp::WaitForSingleObject(self.obj, libc::INFINITE) };\n     }\n \n-    fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>) {\n+    pub fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>) {\n         self.remove();\n \n         // see above for the calculation\n@@ -162,7 +160,7 @@ impl rtio::RtioTimer for Timer {\n         self.on_worker = true;\n     }\n \n-    fn period(&mut self, msecs: u64, cb: Box<Callback + Send>) {\n+    pub fn period(&mut self, msecs: u64, cb: Box<Callback + Send>) {\n         self.remove();\n \n         // see above for the calculation", "previous_filename": "src/libnative/io/timer_windows.rs"}, {"sha": "7d001e6394c30ff9752b64574ccb8d25a0f8e003", "filename": "src/libstd/sys/windows/tty.rs", "status": "renamed", "additions": 43, "deletions": 37, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -33,16 +33,16 @@ use super::c::{ENABLE_PROCESSED_INPUT, ENABLE_QUICK_EDIT_MODE};\n use libc::{c_int, HANDLE, LPDWORD, DWORD, LPVOID};\n use libc::{get_osfhandle, CloseHandle};\n use libc::types::os::arch::extra::LPCVOID;\n-use std::io::MemReader;\n-use std::ptr;\n-use std::rt::rtio::{IoResult, IoError, RtioTTY};\n-use std::str::from_utf8;\n+use io::{mod, IoError, IoResult, MemReader};\n+use prelude::*;\n+use ptr;\n+use str::from_utf8;\n \n fn invalid_encoding() -> IoError {\n     IoError {\n-        code: ERROR_ILLEGAL_CHARACTER as uint,\n-        extra: 0,\n-        detail: Some(\"text was not valid unicode\".to_string()),\n+        kind: io::InvalidInput,\n+        desc: \"text was not valid unicode\",\n+        detail: None,\n     }\n }\n \n@@ -56,40 +56,37 @@ pub fn is_tty(fd: c_int) -> bool {\n     }\n }\n \n-pub struct WindowsTTY {\n+pub struct TTY {\n     closeme: bool,\n     handle: HANDLE,\n     utf8: MemReader,\n }\n \n-impl WindowsTTY {\n-    pub fn new(fd: c_int) -> WindowsTTY {\n-        // If the file descriptor is one of stdin, stderr, or stdout\n-        // then it should not be closed by us\n-        let closeme = match fd {\n-            0...2 => false,\n-            _ => true,\n-        };\n-        let handle = unsafe { get_osfhandle(fd) as HANDLE };\n-        WindowsTTY {\n-            handle: handle,\n-            utf8: MemReader::new(Vec::new()),\n-            closeme: closeme,\n+impl TTY {\n+    pub fn new(fd: c_int) -> IoResult<TTY> {\n+        if is_tty(fd) {\n+            // If the file descriptor is one of stdin, stderr, or stdout\n+            // then it should not be closed by us\n+            let closeme = match fd {\n+                0...2 => false,\n+                _ => true,\n+            };\n+            let handle = unsafe { get_osfhandle(fd) as HANDLE };\n+            Ok(TTY {\n+                handle: handle,\n+                utf8: MemReader::new(Vec::new()),\n+                closeme: closeme,\n+            })\n+        } else {\n+            Err(IoError {\n+                kind: io::MismatchedFileTypeForOperation,\n+                desc: \"invalid handle provided to function\",\n+                detail: None,\n+            })\n         }\n     }\n-}\n \n-impl Drop for WindowsTTY {\n-    fn drop(&mut self) {\n-        if self.closeme {\n-            // Nobody cares about the return value\n-            let _ = unsafe { CloseHandle(self.handle) };\n-        }\n-    }\n-}\n-\n-impl RtioTTY for WindowsTTY {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         // Read more if the buffer is empty\n         if self.utf8.eof() {\n             let mut utf16 = Vec::from_elem(0x1000, 0u16);\n@@ -113,7 +110,7 @@ impl RtioTTY for WindowsTTY {\n         Ok(self.utf8.read(buf).unwrap())\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let utf16 = match from_utf8(buf) {\n             Some(utf8) => {\n                 utf8.as_slice().utf16_units().collect::<Vec<u16>>()\n@@ -131,7 +128,7 @@ impl RtioTTY for WindowsTTY {\n         }\n     }\n \n-    fn set_raw(&mut self, raw: bool) -> IoResult<()> {\n+    pub fn set_raw(&mut self, raw: bool) -> IoResult<()> {\n         // FIXME\n         // Somebody needs to decide on which of these flags we want\n         match unsafe { SetConsoleMode(self.handle,\n@@ -146,7 +143,7 @@ impl RtioTTY for WindowsTTY {\n         }\n     }\n \n-    fn get_winsize(&mut self) -> IoResult<(int, int)> {\n+    pub fn get_winsize(&mut self) -> IoResult<(int, int)> {\n         // FIXME\n         // Get console buffer via CreateFile with CONOUT$\n         // Make a CONSOLE_SCREEN_BUFFER_INFO\n@@ -156,5 +153,14 @@ impl RtioTTY for WindowsTTY {\n     }\n \n     // Let us magically declare this as a TTY\n-    fn isatty(&self) -> bool { true }\n+    pub fn isatty(&self) -> bool { true }\n+}\n+\n+impl Drop for TTY {\n+    fn drop(&mut self) {\n+        if self.closeme {\n+            // Nobody cares about the return value\n+            let _ = unsafe { CloseHandle(self.handle) };\n+        }\n+    }\n }", "previous_filename": "src/libnative/io/tty_windows.rs"}, {"sha": "50f8fb828ad323572f17ef3972cbb0f9d5861996", "filename": "src/libstd/sys/windows/udp.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Flibstd%2Fsys%2Fwindows%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fudp.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use sys_common::net::UdpSocket;"}, {"sha": "002671ff517a1ff3a93bf67b1a78bd13fbee4761", "filename": "src/test/run-pass/sepcomp-lib-lto.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Ftest%2Frun-pass%2Fsepcomp-lib-lto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d80de231abb2b1756f3951ffd4776d681035eb/src%2Ftest%2Frun-pass%2Fsepcomp-lib-lto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsepcomp-lib-lto.rs?ref=16d80de231abb2b1756f3951ffd4776d681035eb", "patch": "@@ -11,6 +11,7 @@\n // Check that we can use `-C lto` when linking against libraries that were\n // separately compiled.\n \n+// ignore-android linker weridness (see #18800)\n // aux-build:sepcomp_lib.rs\n // compile-flags: -C lto\n // no-prefer-dynamic"}, {"sha": "b2ef1a044db808e8e51b95b556fb05f415c170e2", "filename": "src/test/run-pass/unix-process-spawn-errno.rs", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Frun-pass%2Funix-process-spawn-errno.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Frun-pass%2Funix-process-spawn-errno.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funix-process-spawn-errno.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -1,95 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-windows\n-// ignore-macos\n-\n-#![feature(macro_rules)]\n-\n-extern crate native;\n-extern crate rustrt;\n-extern crate libc;\n-use libc::{c_char, c_int};\n-use native::io::process;\n-use rustrt::rtio;\n-use rustrt::c_str;\n-\n-macro_rules! c_string {\n-    ($s:expr) => { {\n-        let ptr = concat!($s, \"\\0\").as_ptr() as *const i8;\n-        unsafe { &c_str::CString::new(ptr, false) }\n-    } }\n-}\n-\n-static EXPECTED_ERRNO: c_int = 0x778899aa;\n-\n-#[no_mangle]\n-pub unsafe extern \"C\" fn chdir(_: *const c_char) -> c_int {\n-    // copied from std::os::errno()\n-    #[cfg(any(target_os = \"macos\",\n-              target_os = \"ios\",\n-              target_os = \"freebsd\"))]\n-    fn errno_location() -> *mut c_int {\n-        extern {\n-            fn __error() -> *mut c_int;\n-        }\n-        unsafe {\n-            __error()\n-        }\n-    }\n-\n-    #[cfg(target_os = \"dragonfly\")]\n-    fn errno_location() -> *mut c_int {\n-        extern {\n-            fn __dfly_error() -> *mut c_int;\n-        }\n-        unsafe {\n-            __dfly_error()\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    fn errno_location() -> *mut c_int {\n-        extern {\n-            fn __errno_location() -> *mut c_int;\n-        }\n-        unsafe {\n-            __errno_location()\n-        }\n-    }\n-\n-    *errno_location() = EXPECTED_ERRNO;\n-    return -1;\n-}\n-\n-fn main() {\n-    let program = c_string!(\"true\");\n-    let cwd = c_string!(\"whatever\");\n-    let cfg = rtio::ProcessConfig {\n-        program: program,\n-        args: &[],\n-        env: None,\n-        cwd: Some(cwd),\n-        stdin: rtio::Ignored,\n-        stdout: rtio::Ignored,\n-        stderr: rtio::Ignored,\n-        extra_io: &[],\n-        uid: None,\n-        gid: None,\n-        detach: false\n-    };\n-\n-    match process::Process::spawn(cfg) {\n-        Ok(_) => { panic!(\"spawn() should have panicked\"); }\n-        Err(rtio::IoError { code: err, ..}) => {\n-            assert_eq!(err as c_int, EXPECTED_ERRNO);\n-        }\n-    };\n-}"}]}