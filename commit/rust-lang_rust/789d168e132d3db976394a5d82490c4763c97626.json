{"sha": "789d168e132d3db976394a5d82490c4763c97626", "node_id": "C_kwDOAAsO6NoAKDc4OWQxNjhlMTMyZDNkYjk3NjM5NGE1ZDgyNDkwYzQ3NjNjOTc2MjY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-11-21T08:55:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-21T08:55:13Z"}, "message": "Rollup merge of #91008 - Urgau:float-minimum-maximum, r=scottmcm\n\nAdds IEEE 754-2019 minimun and maximum functions for f32/f64\n\nIEEE 754-2019 removed the `minNum` (`min` in Rust) and `maxNum` (`max` in Rust) operations in favor of the newly created `minimum` and `maximum` operations due to their [non-associativity](https://grouper.ieee.org/groups/msc/ANSI_IEEE-Std-754-2019/background/minNum_maxNum_Removal_Demotion_v3.pdf) that cannot be fix in a backwards compatible manner. This PR adds `fN::{minimun,maximum}` functions following the new rules.\n\n### IEEE 754-2019 Rules\n\n> **minimum(x, y)** is x if x < y, y if y < x, and a quiet NaN if either operand is a NaN, according to 6.2.\nFor this operation, \u22120 compares less than +0. Otherwise (i.e., when x = y and signs are the same)\nit is either x or y.\n\n> **maximum(x, y)** is x if x > y, y if y > x, and a quiet NaN if either operand is a NaN, according to 6.2.\nFor this operation, +0 compares greater than \u22120. Otherwise (i.e., when x = y and signs are the\nsame) it is either x or y.\n\n\"IEEE Standard for Floating-Point Arithmetic,\" in IEEE Std 754-2019 (Revision of IEEE 754-2008) , vol., no., pp.1-84, 22 July 2019, doi: 10.1109/IEEESTD.2019.8766229.\n\n### Implementation\n\nThis implementation is inspired by the one in [`glibc` ](https://github.com/bminor/glibc/blob/90f0ac10a74b2d43b5a65aab4be40565e359be43/math/s_fminimum_template.c) (it self derived from the C2X draft) expect that:\n - it doesn't use `copysign` because it's not available in `core` and also because `copysign` is unnecessary (we only want to check the sign, no need to create a new float)\n - it also prefer `other > self` instead of `self < other` like IEEE 754-2019 does\n\nI originally tried to implement them [using intrinsics](https://github.com/Urgau/rust/commit/1d8aa13bc39eeef1afba0524dc5ea10d073522e6) but LLVM [error out](https://godbolt.org/z/7sMrxW49a) when trying to lower them to machine intructions, GCC doesn't yet have built-ins for them, only cranelift support them nativelly (as it doesn't support the nativelly the old sementics).\n\nHelps with https://github.com/rust-lang/rust/issues/83984", "tree": {"sha": "11556f8a8a8e24973472d1306a3395bdde26de9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11556f8a8a8e24973472d1306a3395bdde26de9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/789d168e132d3db976394a5d82490c4763c97626", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhmglyCRBK7hj4Ov3rIwAA3pIIAAG71LM5sZgTgECHI7tP2aGY\nmZ3eA6oZgM5UAAn581tMBL6VmWG4rnP6gigCF/hP7tvJ++3u3tDBMtn31GJgzjCW\nV3Pb6EWM4LSrYNDhOHLhg6G9hW50FkvSO5Mn+wLXkOgGnCuTpzTPyTpgQI0eH8Pd\nUYEVBpTboiCtMI9RXTqIAmg3dgQMCeMWzP+Xo7ROpBsNajnt+Qu5i56DJ/cjhzId\n2h94OzzFw1Pb+pSTfC3A4dqTohgqziv94Y6QLEKb+Gt/mEk7UtvPrFERmWcSBR1j\nw+GbQ81yk230fO+wvpKZOaBPI9wePt61HGLrUr8lWOICzzwxtFmri335NDBblL8=\n=iehV\n-----END PGP SIGNATURE-----\n", "payload": "tree 11556f8a8a8e24973472d1306a3395bdde26de9e\nparent 02913c078849f940371eb9930754f2b0f1bc9fad\nparent e2ec3b1dd72357f7d91f04c14e040e6e698630fa\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1637484913 +0100\ncommitter GitHub <noreply@github.com> 1637484913 +0100\n\nRollup merge of #91008 - Urgau:float-minimum-maximum, r=scottmcm\n\nAdds IEEE 754-2019 minimun and maximum functions for f32/f64\n\nIEEE 754-2019 removed the `minNum` (`min` in Rust) and `maxNum` (`max` in Rust) operations in favor of the newly created `minimum` and `maximum` operations due to their [non-associativity](https://grouper.ieee.org/groups/msc/ANSI_IEEE-Std-754-2019/background/minNum_maxNum_Removal_Demotion_v3.pdf) that cannot be fix in a backwards compatible manner. This PR adds `fN::{minimun,maximum}` functions following the new rules.\n\n### IEEE 754-2019 Rules\n\n> **minimum(x, y)** is x if x < y, y if y < x, and a quiet NaN if either operand is a NaN, according to 6.2.\nFor this operation, \u22120 compares less than +0. Otherwise (i.e., when x = y and signs are the same)\nit is either x or y.\n\n> **maximum(x, y)** is x if x > y, y if y > x, and a quiet NaN if either operand is a NaN, according to 6.2.\nFor this operation, +0 compares greater than \u22120. Otherwise (i.e., when x = y and signs are the\nsame) it is either x or y.\n\n\"IEEE Standard for Floating-Point Arithmetic,\" in IEEE Std 754-2019 (Revision of IEEE 754-2008) , vol., no., pp.1-84, 22 July 2019, doi: 10.1109/IEEESTD.2019.8766229.\n\n### Implementation\n\nThis implementation is inspired by the one in [`glibc` ](https://github.com/bminor/glibc/blob/90f0ac10a74b2d43b5a65aab4be40565e359be43/math/s_fminimum_template.c) (it self derived from the C2X draft) expect that:\n - it doesn't use `copysign` because it's not available in `core` and also because `copysign` is unnecessary (we only want to check the sign, no need to create a new float)\n - it also prefer `other > self` instead of `self < other` like IEEE 754-2019 does\n\nI originally tried to implement them [using intrinsics](https://github.com/Urgau/rust/commit/1d8aa13bc39eeef1afba0524dc5ea10d073522e6) but LLVM [error out](https://godbolt.org/z/7sMrxW49a) when trying to lower them to machine intructions, GCC doesn't yet have built-ins for them, only cranelift support them nativelly (as it doesn't support the nativelly the old sementics).\n\nHelps with https://github.com/rust-lang/rust/issues/83984\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/789d168e132d3db976394a5d82490c4763c97626", "html_url": "https://github.com/rust-lang/rust/commit/789d168e132d3db976394a5d82490c4763c97626", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/789d168e132d3db976394a5d82490c4763c97626/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02913c078849f940371eb9930754f2b0f1bc9fad", "url": "https://api.github.com/repos/rust-lang/rust/commits/02913c078849f940371eb9930754f2b0f1bc9fad", "html_url": "https://github.com/rust-lang/rust/commit/02913c078849f940371eb9930754f2b0f1bc9fad"}, {"sha": "e2ec3b1dd72357f7d91f04c14e040e6e698630fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2ec3b1dd72357f7d91f04c14e040e6e698630fa", "html_url": "https://github.com/rust-lang/rust/commit/e2ec3b1dd72357f7d91f04c14e040e6e698630fa"}], "stats": {"total": 211, "additions": 211, "deletions": 0}, "files": [{"sha": "c4a232ef36c615c5010557afefa93358552a8adf", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/789d168e132d3db976394a5d82490c4763c97626/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789d168e132d3db976394a5d82490c4763c97626/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=789d168e132d3db976394a5d82490c4763c97626", "patch": "@@ -673,6 +673,9 @@ impl f32 {\n \n     /// Returns the maximum of the two numbers.\n     ///\n+    /// Follows the IEEE-754 2008 semantics for maxNum, except for handling of signaling NaNs.\n+    /// This matches the behavior of libm\u2019s fmin.\n+    ///\n     /// ```\n     /// let x = 1.0f32;\n     /// let y = 2.0f32;\n@@ -689,6 +692,9 @@ impl f32 {\n \n     /// Returns the minimum of the two numbers.\n     ///\n+    /// Follows the IEEE-754 2008 semantics for minNum, except for handling of signaling NaNs.\n+    /// This matches the behavior of libm\u2019s fmin.\n+    ///\n     /// ```\n     /// let x = 1.0f32;\n     /// let y = 2.0f32;\n@@ -703,6 +709,68 @@ impl f32 {\n         intrinsics::minnumf32(self, other)\n     }\n \n+    /// Returns the maximum of the two numbers, propagating NaNs.\n+    ///\n+    /// This returns NaN when *either* argument is NaN, as opposed to\n+    /// [`f32::max`] which only returns NaN when *both* arguments are NaN.\n+    ///\n+    /// ```\n+    /// #![feature(float_minimum_maximum)]\n+    /// let x = 1.0f32;\n+    /// let y = 2.0f32;\n+    ///\n+    /// assert_eq!(x.maximum(y), y);\n+    /// assert!(x.maximum(f32::NAN).is_nan());\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the greater\n+    /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n+    /// Note that this follows the semantics specified in IEEE 754-2019.\n+    #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n+    #[inline]\n+    pub fn maximum(self, other: f32) -> f32 {\n+        if self > other {\n+            self\n+        } else if other > self {\n+            other\n+        } else if self == other {\n+            if self.is_sign_positive() && other.is_sign_negative() { self } else { other }\n+        } else {\n+            self + other\n+        }\n+    }\n+\n+    /// Returns the minimum of the two numbers, propagating NaNs.\n+    ///\n+    /// This returns NaN when *either* argument is NaN, as opposed to\n+    /// [`f32::min`] which only returns NaN when *both* arguments are NaN.\n+    ///\n+    /// ```\n+    /// #![feature(float_minimum_maximum)]\n+    /// let x = 1.0f32;\n+    /// let y = 2.0f32;\n+    ///\n+    /// assert_eq!(x.minimum(y), x);\n+    /// assert!(x.minimum(f32::NAN).is_nan());\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the lesser\n+    /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n+    /// Note that this follows the semantics specified in IEEE 754-2019.\n+    #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n+    #[inline]\n+    pub fn minimum(self, other: f32) -> f32 {\n+        if self < other {\n+            self\n+        } else if other < self {\n+            other\n+        } else if self == other {\n+            if self.is_sign_negative() && other.is_sign_positive() { self } else { other }\n+        } else {\n+            self + other\n+        }\n+    }\n+\n     /// Rounds toward zero and converts to any primitive integer type,\n     /// assuming that the value is finite and fits in that type.\n     ///"}, {"sha": "85ee6aa2cb8c3399f6bd2787ad9696d72fbe5b82", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/789d168e132d3db976394a5d82490c4763c97626/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789d168e132d3db976394a5d82490c4763c97626/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=789d168e132d3db976394a5d82490c4763c97626", "patch": "@@ -689,6 +689,9 @@ impl f64 {\n \n     /// Returns the maximum of the two numbers.\n     ///\n+    /// Follows the IEEE-754 2008 semantics for maxNum, except for handling of signaling NaNs.\n+    /// This matches the behavior of libm\u2019s fmin.\n+    ///\n     /// ```\n     /// let x = 1.0_f64;\n     /// let y = 2.0_f64;\n@@ -705,6 +708,9 @@ impl f64 {\n \n     /// Returns the minimum of the two numbers.\n     ///\n+    /// Follows the IEEE-754 2008 semantics for minNum, except for handling of signaling NaNs.\n+    /// This matches the behavior of libm\u2019s fmin.\n+    ///\n     /// ```\n     /// let x = 1.0_f64;\n     /// let y = 2.0_f64;\n@@ -719,6 +725,68 @@ impl f64 {\n         intrinsics::minnumf64(self, other)\n     }\n \n+    /// Returns the maximum of the two numbers, propagating NaNs.\n+    ///\n+    /// This returns NaN when *either* argument is NaN, as opposed to\n+    /// [`f64::max`] which only returns NaN when *both* arguments are NaN.\n+    ///\n+    /// ```\n+    /// #![feature(float_minimum_maximum)]\n+    /// let x = 1.0_f64;\n+    /// let y = 2.0_f64;\n+    ///\n+    /// assert_eq!(x.maximum(y), y);\n+    /// assert!(x.maximum(f64::NAN).is_nan());\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the greater\n+    /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n+    /// Note that this follows the semantics specified in IEEE 754-2019.\n+    #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n+    #[inline]\n+    pub fn maximum(self, other: f64) -> f64 {\n+        if self > other {\n+            self\n+        } else if other > self {\n+            other\n+        } else if self == other {\n+            if self.is_sign_positive() && other.is_sign_negative() { self } else { other }\n+        } else {\n+            self + other\n+        }\n+    }\n+\n+    /// Returns the minimum of the two numbers, propagating NaNs.\n+    ///\n+    /// This returns NaN when *either* argument is NaN, as opposed to\n+    /// [`f64::min`] which only returns NaN when *both* arguments are NaN.\n+    ///\n+    /// ```\n+    /// #![feature(float_minimum_maximum)]\n+    /// let x = 1.0_f64;\n+    /// let y = 2.0_f64;\n+    ///\n+    /// assert_eq!(x.minimum(y), x);\n+    /// assert!(x.minimum(f64::NAN).is_nan());\n+    /// ```\n+    ///\n+    /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the lesser\n+    /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n+    /// Note that this follows the semantics specified in IEEE 754-2019.\n+    #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n+    #[inline]\n+    pub fn minimum(self, other: f64) -> f64 {\n+        if self < other {\n+            self\n+        } else if other < self {\n+            other\n+        } else if self == other {\n+            if self.is_sign_negative() && other.is_sign_positive() { self } else { other }\n+        } else {\n+            self + other\n+        }\n+    }\n+\n     /// Rounds toward zero and converts to any primitive integer type,\n     /// assuming that the value is finite and fits in that type.\n     ///"}, {"sha": "a56a1dbd17ae01df0cb35ed8e597c23f407be92e", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/789d168e132d3db976394a5d82490c4763c97626/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789d168e132d3db976394a5d82490c4763c97626/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=789d168e132d3db976394a5d82490c4763c97626", "patch": "@@ -27,6 +27,7 @@\n #![feature(extern_types)]\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n+#![feature(float_minimum_maximum)]\n #![feature(array_from_fn)]\n #![feature(hashmap_internals)]\n #![feature(try_find)]"}, {"sha": "4f773a824efd29a4aaa36d33a068675ca9324d61", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/789d168e132d3db976394a5d82490c4763c97626/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789d168e132d3db976394a5d82490c4763c97626/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=789d168e132d3db976394a5d82490c4763c97626", "patch": "@@ -715,6 +715,67 @@ macro_rules! test_float {\n                 assert!(($nan as $fty).max($nan).is_nan());\n             }\n             #[test]\n+            fn minimum() {\n+                assert_eq!((0.0 as $fty).minimum(0.0), 0.0);\n+                assert!((0.0 as $fty).minimum(0.0).is_sign_positive());\n+                assert_eq!((-0.0 as $fty).minimum(0.0), -0.0);\n+                assert!((-0.0 as $fty).minimum(0.0).is_sign_negative());\n+                assert_eq!((-0.0 as $fty).minimum(-0.0), -0.0);\n+                assert!((-0.0 as $fty).minimum(-0.0).is_sign_negative());\n+                assert_eq!((9.0 as $fty).minimum(9.0), 9.0);\n+                assert_eq!((-9.0 as $fty).minimum(0.0), -9.0);\n+                assert_eq!((0.0 as $fty).minimum(9.0), 0.0);\n+                assert!((0.0 as $fty).minimum(9.0).is_sign_positive());\n+                assert_eq!((-0.0 as $fty).minimum(9.0), -0.0);\n+                assert!((-0.0 as $fty).minimum(9.0).is_sign_negative());\n+                assert_eq!((-0.0 as $fty).minimum(-9.0), -9.0);\n+                assert_eq!(($inf as $fty).minimum(9.0), 9.0);\n+                assert_eq!((9.0 as $fty).minimum($inf), 9.0);\n+                assert_eq!(($inf as $fty).minimum(-9.0), -9.0);\n+                assert_eq!((-9.0 as $fty).minimum($inf), -9.0);\n+                assert_eq!(($neginf as $fty).minimum(9.0), $neginf);\n+                assert_eq!((9.0 as $fty).minimum($neginf), $neginf);\n+                assert_eq!(($neginf as $fty).minimum(-9.0), $neginf);\n+                assert_eq!((-9.0 as $fty).minimum($neginf), $neginf);\n+                assert!(($nan as $fty).minimum(9.0).is_nan());\n+                assert!(($nan as $fty).minimum(-9.0).is_nan());\n+                assert!((9.0 as $fty).minimum($nan).is_nan());\n+                assert!((-9.0 as $fty).minimum($nan).is_nan());\n+                assert!(($nan as $fty).minimum($nan).is_nan());\n+            }\n+            #[test]\n+            fn maximum() {\n+                assert_eq!((0.0 as $fty).maximum(0.0), 0.0);\n+                assert!((0.0 as $fty).maximum(0.0).is_sign_positive());\n+                assert_eq!((-0.0 as $fty).maximum(0.0), 0.0);\n+                assert!((-0.0 as $fty).maximum(0.0).is_sign_positive());\n+                assert_eq!((-0.0 as $fty).maximum(-0.0), -0.0);\n+                assert!((-0.0 as $fty).maximum(-0.0).is_sign_negative());\n+                assert_eq!((9.0 as $fty).maximum(9.0), 9.0);\n+                assert_eq!((-9.0 as $fty).maximum(0.0), 0.0);\n+                assert!((-9.0 as $fty).maximum(0.0).is_sign_positive());\n+                assert_eq!((-9.0 as $fty).maximum(-0.0), -0.0);\n+                assert!((-9.0 as $fty).maximum(-0.0).is_sign_negative());\n+                assert_eq!((0.0 as $fty).maximum(9.0), 9.0);\n+                assert_eq!((0.0 as $fty).maximum(-9.0), 0.0);\n+                assert!((0.0 as $fty).maximum(-9.0).is_sign_positive());\n+                assert_eq!((-0.0 as $fty).maximum(-9.0), -0.0);\n+                assert!((-0.0 as $fty).maximum(-9.0).is_sign_negative());\n+                assert_eq!(($inf as $fty).maximum(9.0), $inf);\n+                assert_eq!((9.0 as $fty).maximum($inf), $inf);\n+                assert_eq!(($inf as $fty).maximum(-9.0), $inf);\n+                assert_eq!((-9.0 as $fty).maximum($inf), $inf);\n+                assert_eq!(($neginf as $fty).maximum(9.0), 9.0);\n+                assert_eq!((9.0 as $fty).maximum($neginf), 9.0);\n+                assert_eq!(($neginf as $fty).maximum(-9.0), -9.0);\n+                assert_eq!((-9.0 as $fty).maximum($neginf), -9.0);\n+                assert!(($nan as $fty).maximum(9.0).is_nan());\n+                assert!(($nan as $fty).maximum(-9.0).is_nan());\n+                assert!((9.0 as $fty).maximum($nan).is_nan());\n+                assert!((-9.0 as $fty).maximum($nan).is_nan());\n+                assert!(($nan as $fty).maximum($nan).is_nan());\n+            }\n+            #[test]\n             fn rem_euclid() {\n                 let a: $fty = 42.0;\n                 assert!($inf.rem_euclid(a).is_nan());"}, {"sha": "69fa203ff4e70bb03c9f0a15615348345670a625", "filename": "library/std/src/f32/tests.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/789d168e132d3db976394a5d82490c4763c97626/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789d168e132d3db976394a5d82490c4763c97626/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs?ref=789d168e132d3db976394a5d82490c4763c97626", "patch": "@@ -19,6 +19,18 @@ fn test_max_nan() {\n     assert_eq!(2.0f32.max(f32::NAN), 2.0);\n }\n \n+#[test]\n+fn test_minimum() {\n+    assert!(f32::NAN.minimum(2.0).is_nan());\n+    assert!(2.0f32.minimum(f32::NAN).is_nan());\n+}\n+\n+#[test]\n+fn test_maximum() {\n+    assert!(f32::NAN.maximum(2.0).is_nan());\n+    assert!(2.0f32.maximum(f32::NAN).is_nan());\n+}\n+\n #[test]\n fn test_nan() {\n     let nan: f32 = f32::NAN;"}, {"sha": "afd8d8edaa169f8b41d1bed27fdb56f7a4eb6ad8", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/789d168e132d3db976394a5d82490c4763c97626/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/789d168e132d3db976394a5d82490c4763c97626/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=789d168e132d3db976394a5d82490c4763c97626", "patch": "@@ -287,6 +287,7 @@\n #![feature(exhaustive_patterns)]\n #![feature(extend_one)]\n #![feature(fn_traits)]\n+#![feature(float_minimum_maximum)]\n #![feature(format_args_nl)]\n #![feature(gen_future)]\n #![feature(generator_trait)]"}]}