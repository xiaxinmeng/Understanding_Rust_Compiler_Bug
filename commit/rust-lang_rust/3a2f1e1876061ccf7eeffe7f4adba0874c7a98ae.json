{"sha": "3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMmYxZTE4NzYwNjFjY2Y3ZWVmZmU3ZjRhZGJhMDg3NGM3YTk4YWU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-13T03:02:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-13T14:50:58Z"}, "message": "add serialization library; convert ebml lib to use u64 internally", "tree": {"sha": "0a1173b2b61bb0845e2adca46c9c2473e76c9f87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a1173b2b61bb0845e2adca46c9c2473e76c9f87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae", "html_url": "https://github.com/rust-lang/rust/commit/3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4eb52f69a9ebd39af4545fe7583f843edaa1a07d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eb52f69a9ebd39af4545fe7583f843edaa1a07d", "html_url": "https://github.com/rust-lang/rust/commit/4eb52f69a9ebd39af4545fe7583f843edaa1a07d"}], "stats": {"total": 326, "additions": 188, "deletions": 138}, "files": [{"sha": "95f1589d5d9dba46b6dbc8ede575f54c10adaf66", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae", "patch": "@@ -42,14 +42,14 @@ fn lookup_hash(d: ebml::doc, eq_fn: fn@([u8]) -> bool, hash: uint) ->\n     let index = ebml::get_doc(d, tag_index);\n     let table = ebml::get_doc(index, tag_index_table);\n     let hash_pos = table.start + hash % 256u * 4u;\n-    let pos = ebml::be_uint_from_bytes(d.data, hash_pos, 4u);\n+    let pos = ebml::be_u64_from_bytes(d.data, hash_pos, 4u) as uint;\n     let {tag:_, doc:bucket} = ebml::doc_at(d.data, pos);\n     // Awkward logic because we can't ret from foreach yet\n \n     let result: [ebml::doc] = [];\n     let belt = tag_index_buckets_bucket_elt;\n     ebml::tagged_docs(bucket, belt) {|elt|\n-        let pos = ebml::be_uint_from_bytes(elt.data, elt.start, 4u);\n+        let pos = ebml::be_u64_from_bytes(elt.data, elt.start, 4u) as uint;\n         if eq_fn(vec::slice::<u8>(*elt.data, elt.start + 4u, elt.end)) {\n             result += [ebml::doc_at(d.data, pos).doc];\n         }\n@@ -59,7 +59,7 @@ fn lookup_hash(d: ebml::doc, eq_fn: fn@([u8]) -> bool, hash: uint) ->\n \n fn maybe_find_item(item_id: int, items: ebml::doc) -> option<ebml::doc> {\n     fn eq_item(bytes: [u8], item_id: int) -> bool {\n-        ret ebml::be_uint_from_bytes(@bytes, 0u, 4u) as int == item_id;\n+        ret ebml::be_u64_from_bytes(@bytes, 0u, 4u) as int == item_id;\n     }\n     let eqer = bind eq_item(_, item_id);\n     let found = lookup_hash(items, eqer, hash_node_id(item_id));\n@@ -81,7 +81,7 @@ fn lookup_item(item_id: int, data: @[u8]) -> ebml::doc {\n \n fn item_family(item: ebml::doc) -> u8 {\n     let fam = ebml::get_doc(item, tag_items_data_item_family);\n-    ret ebml::doc_as_uint(fam) as u8;\n+    ret ebml::doc_as_u8(fam);\n }\n \n fn item_symbol(item: ebml::doc) -> str {\n@@ -183,7 +183,7 @@ fn item_path(item_doc: ebml::doc) -> ast_map::path {\n     let path_doc = ebml::get_doc(item_doc, tag_path);\n \n     let len_doc = ebml::get_doc(path_doc, tag_path_len);\n-    let len = ebml::doc_as_uint(len_doc);\n+    let len = ebml::doc_as_vuint(len_doc);\n \n     let result = [];\n     vec::reserve(result, len);\n@@ -355,7 +355,7 @@ fn family_names_type(fam_ch: u8) -> bool {\n \n fn read_path(d: ebml::doc) -> {path: str, pos: uint} {\n     let desc = ebml::doc_data(d);\n-    let pos = ebml::be_uint_from_bytes(@desc, 0u, 4u);\n+    let pos = ebml::be_u64_from_bytes(@desc, 0u, 4u) as uint;\n     let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n     let path = str::from_bytes(pathbytes);\n     ret {path: path, pos: pos};"}, {"sha": "793710b0b74a50cabe7472ab835c79cc77dccb6c", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae", "patch": "@@ -281,7 +281,7 @@ fn encode_path(ebml_w: ebml::writer,\n \n     ebml_w.wr_tag(tag_path) {||\n         ebml_w.wr_tag(tag_path_len) {||\n-            ebml_w.wr_uint(vec::len(path) + 1u);\n+            ebml_w.wr_vuint(vec::len(path) + 1u);\n         }\n         vec::iter(path) {|pe| encode_path_elt(ebml_w, pe); }\n         encode_path_elt(ebml_w, name);"}, {"sha": "45faf62cf7dca7e25c24b95bb96614695cb00e8f", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 62, "deletions": 36, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae", "patch": "@@ -19,35 +19,42 @@ type doc = {data: @[u8], start: uint, end: uint};\n \n type tagged_doc = {tag: uint, doc: doc};\n \n-fn vint_at(data: [u8], start: uint) -> {val: uint, next: uint} {\n+fn vu64_at(data: [u8], start: uint) -> {val: u64, next: uint} {\n     let a = data[start];\n     if a & 0x80u8 != 0u8 {\n-        ret {val: (a & 0x7fu8) as uint, next: start + 1u};\n+        ret {val: (a & 0x7fu8) as u64, next: start + 1u};\n     }\n     if a & 0x40u8 != 0u8 {\n-        ret {val: ((a & 0x3fu8) as uint) << 8u | (data[start + 1u] as uint),\n+        ret {val: ((a & 0x3fu8) as u64) << 8u64 |\n+                 (data[start + 1u] as u64),\n              next: start + 2u};\n     } else if a & 0x20u8 != 0u8 {\n-        ret {val: ((a & 0x1fu8) as uint) << 16u |\n-                 (data[start + 1u] as uint) << 8u |\n-                 (data[start + 2u] as uint),\n+        ret {val: ((a & 0x1fu8) as u64) << 16u64 |\n+                 (data[start + 1u] as u64) << 8u64 |\n+                 (data[start + 2u] as u64),\n              next: start + 3u};\n     } else if a & 0x10u8 != 0u8 {\n-        ret {val: ((a & 0x0fu8) as uint) << 24u |\n-                 (data[start + 1u] as uint) << 16u |\n-                 (data[start + 2u] as uint) << 8u |\n-                 (data[start + 3u] as uint),\n+        ret {val: ((a & 0x0fu8) as u64) << 24u64 |\n+                 (data[start + 1u] as u64) << 16u64 |\n+                 (data[start + 2u] as u64) << 8u64 |\n+                 (data[start + 3u] as u64),\n              next: start + 4u};\n     } else { #error(\"vint too big\"); fail; }\n }\n \n+fn vuint_at(data: [u8], start: uint) -> {val: uint, next: uint} {\n+    let {val, next} = vu64_at(data, start);\n+    ret {val: val as uint, next: next};\n+}\n+\n+\n fn new_doc(data: @[u8]) -> doc {\n     ret {data: data, start: 0u, end: vec::len::<u8>(*data)};\n }\n \n fn doc_at(data: @[u8], start: uint) -> tagged_doc {\n-    let elt_tag = vint_at(*data, start);\n-    let elt_size = vint_at(*data, elt_tag.next);\n+    let elt_tag = vuint_at(*data, start);\n+    let elt_size = vuint_at(*data, elt_tag.next);\n     let end = elt_size.next + elt_size.val;\n     ret {tag: elt_tag.val,\n          doc: {data: data, start: elt_size.next, end: end}};\n@@ -56,8 +63,8 @@ fn doc_at(data: @[u8], start: uint) -> tagged_doc {\n fn maybe_get_doc(d: doc, tg: uint) -> option<doc> {\n     let pos = d.start;\n     while pos < d.end {\n-        let elt_tag = vint_at(*d.data, pos);\n-        let elt_size = vint_at(*d.data, elt_tag.next);\n+        let elt_tag = vuint_at(*d.data, pos);\n+        let elt_size = vuint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n         if elt_tag.val == tg {\n             ret some::<doc>({data: d.data, start: elt_size.next, end: pos});\n@@ -79,8 +86,8 @@ fn get_doc(d: doc, tg: uint) -> doc {\n fn docs(d: doc, it: fn(uint, doc)) {\n     let pos = d.start;\n     while pos < d.end {\n-        let elt_tag = vint_at(*d.data, pos);\n-        let elt_size = vint_at(*d.data, elt_tag.next);\n+        let elt_tag = vuint_at(*d.data, pos);\n+        let elt_size = vuint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n         it(elt_tag.val, {data: d.data, start: elt_size.next, end: pos});\n     }\n@@ -89,8 +96,8 @@ fn docs(d: doc, it: fn(uint, doc)) {\n fn tagged_docs(d: doc, tg: uint, it: fn(doc)) {\n     let pos = d.start;\n     while pos < d.end {\n-        let elt_tag = vint_at(*d.data, pos);\n-        let elt_size = vint_at(*d.data, elt_tag.next);\n+        let elt_tag = vuint_at(*d.data, pos);\n+        let elt_size = vuint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n         if elt_tag.val == tg {\n             it({data: d.data, start: elt_size.next, end: pos});\n@@ -102,28 +109,36 @@ fn doc_data(d: doc) -> [u8] { ret vec::slice::<u8>(*d.data, d.start, d.end); }\n \n fn doc_str(d: doc) -> str { ret str::from_bytes(doc_data(d)); }\n \n-fn be_uint_from_bytes(data: @[u8], start: uint, size: uint) -> uint {\n+fn be_u64_from_bytes(data: @[u8], start: uint, size: uint) -> u64 {\n     let sz = size;\n     assert (sz <= 4u);\n-    let val = 0u;\n+    let val = 0_u64;\n     let pos = start;\n     while sz > 0u {\n         sz -= 1u;\n-        val += (data[pos] as uint) << sz * 8u;\n+        val += (data[pos] as u64) << ((sz * 8u) as u64);\n         pos += 1u;\n     }\n     ret val;\n }\n \n-fn doc_as_uint(d: doc) -> uint {\n-    ret be_uint_from_bytes(d.data, d.start, d.end - d.start);\n+fn doc_as_u8(d: doc) -> u8 {\n+    assert d.end == d.start + 1u;\n+    ret (*d.data)[d.start];\n+}\n+\n+fn doc_as_vu64(d: doc) -> u64 {\n+    ret vu64_at(*d.data, d.start).val;\n }\n \n+fn doc_as_vuint(d: doc) -> uint {\n+    ret vuint_at(*d.data, d.start).val;\n+}\n \n // ebml writing\n type writer = {writer: io::writer, mutable size_positions: [uint]};\n \n-fn write_sized_vint(w: io::writer, n: u64, size: uint) {\n+fn write_sized_vu64(w: io::writer, n: u64, size: uint) {\n     let buf: [u8];\n     alt size {\n       1u { buf = [0x80u8 | (n as u8)]; }\n@@ -141,11 +156,11 @@ fn write_sized_vint(w: io::writer, n: u64, size: uint) {\n     w.write(buf);\n }\n \n-fn write_vint(w: io::writer, n: u64) {\n-    if n < 0x7f_u64 { write_sized_vint(w, n, 1u); ret; }\n-    if n < 0x4000_u64 { write_sized_vint(w, n, 2u); ret; }\n-    if n < 0x200000_u64 { write_sized_vint(w, n, 3u); ret; }\n-    if n < 0x10000000_u64 { write_sized_vint(w, n, 4u); ret; }\n+fn write_vu64(w: io::writer, n: u64) {\n+    if n < 0x7f_u64 { write_sized_vu64(w, n, 1u); ret; }\n+    if n < 0x4000_u64 { write_sized_vu64(w, n, 2u); ret; }\n+    if n < 0x200000_u64 { write_sized_vu64(w, n, 3u); ret; }\n+    if n < 0x10000000_u64 { write_sized_vu64(w, n, 4u); ret; }\n     #error(\"vint to write too big\");\n     fail;\n }\n@@ -158,8 +173,10 @@ fn create_writer(w: io::writer) -> writer {\n \n // TODO: Provide a function to write the standard ebml header.\n fn start_tag(w: writer, tag_id: uint) {\n+    #debug[\"Start tag %u\", tag_id];\n+\n     // Write the enum ID:\n-    write_vint(w.writer, tag_id as u64);\n+    write_vu64(w.writer, tag_id as u64);\n \n     // Write a placeholder four-byte size.\n     w.size_positions += [w.writer.tell()];\n@@ -171,8 +188,11 @@ fn end_tag(w: writer) {\n     let last_size_pos = vec::pop::<uint>(w.size_positions);\n     let cur_pos = w.writer.tell();\n     w.writer.seek(last_size_pos as int, io::seek_set);\n-    write_sized_vint(w.writer, (cur_pos - last_size_pos - 4u) as u64, 4u);\n+    let size = (cur_pos - last_size_pos - 4u);\n+    write_sized_vu64(w.writer, size as u64, 4u);\n     w.writer.seek(cur_pos as int, io::seek_set);\n+\n+    #debug[\"End tag (size = %u)\", size];\n }\n \n impl writer_util for writer {\n@@ -182,20 +202,26 @@ impl writer_util for writer {\n         end_tag(self);\n     }\n \n-    fn wr_u64(id: u64) {\n-        write_vint(self.writer, id);\n+    fn wr_vu64(id: u64) {\n+        #debug[\"Write u64 0x%02x%02x\",\n+               (id >> 32u64) as uint,\n+               (id & 0xFFFFFFFFu64) as uint];\n+        write_vu64(self.writer, id);\n     }\n \n-    fn wr_uint(id: uint) {\n-        self.wr_u64(id as u64);\n+    fn wr_vuint(id: uint) {\n+        #debug[\"Write uint: %u\", id];\n+        write_vu64(self.writer, id as u64);\n     }\n \n     fn wr_bytes(b: [u8]) {\n+        #debug[\"Write %u bytes\", vec::len(b)];\n         self.writer.write(b);\n     }\n \n     fn wr_str(s: str) {\n-        self.wr_bytes(str::bytes(s));\n+        #debug[\"Write str: %?\", s];\n+        self.writer.write(str::bytes(s));\n     }\n }\n "}, {"sha": "1b91b34fe112e89e7ef3748ca2afdc8a30d93eb3", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 105, "deletions": 85, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae", "patch": "@@ -5,12 +5,13 @@ Support code for serialization.\n */\n \n import list::list;\n+import ebml::writer_util;\n \n iface serializer {\n     // Primitive types:\n     fn emit_nil();\n     fn emit_u64(v: u64);\n-    fn emit_i64(v: u64);\n+    fn emit_i64(v: i64);\n     fn emit_bool(v: bool);\n     fn emit_f64(v: f64);\n     fn emit_str(v: str);\n@@ -52,54 +53,8 @@ iface deserializer {\n     fn read_tup_elt<T:copy>(idx: uint, f: fn() -> T) -> T;\n }\n \n-/*\n-type ppserializer = {\n-    writer: io::writer\n-};\n-\n-impl serializer for ppserializer {\n-    fn emit_nil() { self.writer.write_str(\"()\") }\n-\n-    fn emit_u64(v: u64) { self.writer.write_str(#fmt[\"%lu\", v]); }\n-    fn emit_i64(v: u64) { ebml::write_vint(self, v as uint) }\n-    fn emit_bool(v: bool) { ebml::write_vint(self, v as uint) }\n-    fn emit_f64(v: f64) { fail \"float serialization not impl\"; }\n-    fn emit_str(v: str) {\n-        self.wr_tag(es_str as uint) {|| self.wr_str(v) }\n-    }\n-\n-    fn emit_enum(name: str, f: fn()) {\n-        self.wr_tag(es_enum as uint) {|| f() }\n-    }\n-    fn emit_enum_variant(v_name: str, v_id: uint, f: fn()) {\n-        self.wr_tag(es_enum_vid as uint) {|| self.write_vint(v_id) }\n-        self.wr_tag(es_enum_body as uint) {|| f() }\n-    }\n-\n-    fn emit_vec(len: uint, f: fn()) {\n-        self.wr_tag(es_vec as uint) {||\n-            self.wr_tag(es_vec_len as uint) {|| self.write_vint(len) }\n-            f()\n-        }\n-    }\n-\n-    fn emit_vec_elt(idx: uint, f: fn()) {\n-        self.wr_tag(es_vec_elt as uint) {|| f() }\n-    }\n-\n-    fn emit_vec_elt(idx: uint, f: fn()) {\n-        self.wr_tag(es_vec_elt as uint) {|| f() }\n-    }\n-\n-    fn emit_box(f: fn()) { f() }\n-    fn emit_uniq(f: fn()) { f() }\n-    fn emit_rec_field(f_name: str, f_idx: uint, f: fn()) { f() }\n-    fn emit_tup(sz: uint, f: fn()) { f() }\n-    fn emit_tup_elt(idx: uint, f: fn()) { f() }\n-}\n-*/\n-\n-enum ebml_serializer_tags {\n+enum ebml_serializer_tag {\n+    es_u64, es_i64, es_bool,\n     es_str,\n     es_enum, es_enum_vid, es_enum_body,\n     es_vec, es_vec_len, es_vec_elt\n@@ -108,100 +63,108 @@ enum ebml_serializer_tags {\n impl of serializer for ebml::writer {\n     fn emit_nil() {}\n \n-    fn emit_u64(v: u64) { ebml::write_vint(self, v) }\n-    fn emit_i64(v: u64) { ebml::write_vint(self, v as uint) }\n-    fn emit_bool(v: bool) { ebml::write_vint(self, v as uint) }\n-    fn emit_f64(v: f64) { fail \"float serialization not impl\"; }\n-    fn emit_str(v: str) {\n-        self.wr_tag(es_str as uint) {|| self.wr_str(v) }\n+    fn emit_num(tag: ebml_serializer_tag, v: u64) {\n+        self.wr_tag(tag as uint) {|| self.wr_vu64(v) }\n     }\n \n-    fn emit_enum(name: str, f: fn()) {\n+    fn emit_u64(v: u64) { self.emit_num(es_u64, v) }\n+    fn emit_i64(v: i64) { self.emit_num(es_i64, v as u64) }\n+    fn emit_bool(v: bool) { self.emit_num(es_bool, v as u64) }\n+    fn emit_f64(_v: f64) { fail \"TODO\"; }\n+    fn emit_str(v: str) { self.wr_tag(es_str as uint) {|| self.wr_str(v) } }\n+\n+    fn emit_enum(_name: str, f: fn()) {\n         self.wr_tag(es_enum as uint) {|| f() }\n     }\n-    fn emit_enum_variant(v_name: str, v_id: uint, f: fn()) {\n-        self.wr_tag(es_enum_vid as uint) {|| self.write_vint(v_id) }\n+    fn emit_enum_variant(_v_name: str, v_id: uint, _cnt: uint, f: fn()) {\n+        self.emit_num(es_enum_vid, v_id as u64);\n         self.wr_tag(es_enum_body as uint) {|| f() }\n     }\n-    fn emit_enum_variant_arg(idx: uint, f: fn()) { f() }\n+    fn emit_enum_variant_arg(_idx: uint, f: fn()) { f() }\n \n     fn emit_vec(len: uint, f: fn()) {\n         self.wr_tag(es_vec as uint) {||\n-            self.wr_tag(es_vec_len as uint) {|| self.write_vint(len) }\n+            self.emit_num(es_vec_len, len as u64);\n             f()\n         }\n     }\n \n-    fn emit_vec_elt(idx: uint, f: fn()) {\n+    fn emit_vec_elt(_idx: uint, f: fn()) {\n         self.wr_tag(es_vec_elt as uint) {|| f() }\n     }\n \n-    fn emit_vec_elt(idx: uint, f: fn()) {\n+    fn emit_vec_elt(_idx: uint, f: fn()) {\n         self.wr_tag(es_vec_elt as uint) {|| f() }\n     }\n \n     fn emit_box(f: fn()) { f() }\n     fn emit_uniq(f: fn()) { f() }\n     fn emit_rec(f: fn()) { f() }\n-    fn emit_rec_field(f_name: str, f_idx: uint, f: fn()) { f() }\n-    fn emit_tup(sz: uint, f: fn()) { f() }\n-    fn emit_tup_elt(idx: uint, f: fn()) { f() }\n+    fn emit_rec_field(_f_name: str, _f_idx: uint, f: fn()) { f() }\n+    fn emit_tup(_sz: uint, f: fn()) { f() }\n+    fn emit_tup_elt(_idx: uint, f: fn()) { f() }\n }\n \n type ebml_deserializer = {mutable parent: ebml::doc,\n                           mutable pos: uint};\n \n fn mk_ebml_deserializer(d: ebml::doc) -> ebml_deserializer {\n-    {mutable parent: d, mutable pos: 0u}\n+    {mutable parent: d, mutable pos: d.start}\n }\n \n impl of deserializer for ebml_deserializer {\n-    fn next_doc(exp_tag: uint) -> ebml::doc {\n+    fn next_doc(exp_tag: ebml_serializer_tag) -> ebml::doc {\n         if self.pos >= self.parent.end {\n             fail \"no more documents in current node!\";\n         }\n-        let (r_tag, r_doc) = ebml::doc_at(self.parent.data, self.pos);\n-        if r_tag != exp_tag {\n-            fail #fmt[\"expected EMBL doc with tag %u but found tag %u\",\n+        let {tag: r_tag, doc: r_doc} =\n+            ebml::doc_at(self.parent.data, self.pos);\n+        #debug[\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n+               self.parent.start, self.parent.end, self.pos,\n+               r_tag, r_doc.start, r_doc.end];\n+        if r_tag != (exp_tag as uint) {\n+            fail #fmt[\"expected EMBL doc with tag %? but found tag %?\",\n                       exp_tag, r_tag];\n         }\n-        if r_doc.end >= self.parent.end {\n+        if r_doc.end > self.parent.end {\n             fail #fmt[\"invalid EBML, child extends to 0x%x, parent to 0x%x\",\n                       r_doc.end, self.parent.end];\n         }\n-        self.pos = result.end;\n-        ret result;\n+        self.pos = r_doc.end;\n+        ret r_doc;\n     }\n \n     fn push_doc<T: copy>(d: ebml::doc, f: fn() -> T) -> T{\n         let old_parent = self.parent;\n         let old_pos = self.pos;\n         self.parent = d;\n-        self.pos = 0u;\n+        self.pos = d.start;\n         let r = f();\n         self.parent = old_parent;\n         self.pos = old_pos;\n         ret r;\n     }\n \n-    fn next_u64(exp_tag: uint) {\n-        ebml::doc_as_uint(self.next_doc(exp_tag))\n+    fn next_u64(exp_tag: ebml_serializer_tag) -> u64 {\n+        let r = ebml::doc_as_vu64(self.next_doc(exp_tag));\n+        #debug[\"next_u64 exp_tag=%? result=%?\", exp_tag, r];\n+        ret r;\n     }\n \n     fn read_nil() -> () { () }\n-    fn read_u64() -> u64 { next_u64(es_u64) }\n-    fn read_i64() -> i64 { next_u64(es_u64) as i64 }\n-    fn read_bool() -> bool { next_u64(es_u64) as bool }\n+    fn read_u64() -> u64 { self.next_u64(es_u64) }\n+    fn read_i64() -> i64 { self.next_u64(es_i64) as i64 }\n+    fn read_bool() -> bool { self.next_u64(es_bool) as bool }\n     fn read_f64() -> f64 { fail \"Float\"; }\n     fn read_str() -> str { ebml::doc_str(self.next_doc(es_str)) }\n \n     // Compound types:\n-    fn read_enum<T:copy>(name: str, f: fn() -> T) -> T {\n+    fn read_enum<T:copy>(_name: str, f: fn() -> T) -> T {\n         self.push_doc(self.next_doc(es_enum), f)\n     }\n \n     fn read_enum_variant<T:copy>(f: fn(uint) -> T) -> T {\n-        let idx = self.next_u64(es_enum_vid);\n+        let idx = self.next_u64(es_enum_vid) as uint;\n         self.push_doc(self.next_doc(es_enum_body)) {||\n             f(idx)\n         }\n@@ -218,7 +181,7 @@ impl of deserializer for ebml_deserializer {\n         }\n     }\n \n-    fn read_vec_elt<T:copy>(idx: uint, f: fn() -> T) -> T {\n+    fn read_vec_elt<T:copy>(_idx: uint, f: fn() -> T) -> T {\n         self.push_doc(self.next_doc(es_vec_elt), f)\n     }\n \n@@ -234,19 +197,76 @@ impl of deserializer for ebml_deserializer {\n         f()\n     }\n \n-    fn read_rec_field<T:copy>(f_name: str, f_idx: uint, f: fn() -> T) -> T {\n+    fn read_rec_field<T:copy>(_f_name: str, _f_idx: uint, f: fn() -> T) -> T {\n         f()\n     }\n \n-    fn read_tup<T:copy>(sz: uint, f: fn() -> T) -> T {\n+    fn read_tup<T:copy>(_sz: uint, f: fn() -> T) -> T {\n         f()\n     }\n \n-    fn read_tup_elt<T:copy>(idx: uint, f: fn() -> T) -> T {\n+    fn read_tup_elt<T:copy>(_idx: uint, f: fn() -> T) -> T {\n         f()\n     }\n }\n \n // ___________________________________________________________________________\n // Testing\n \n+#[test]\n+fn test_option_int() {\n+    fn serialize_1<S: serializer>(s: S, v: int) {\n+        s.emit_i64(v as i64);\n+    }\n+\n+    fn serialize_0<S: serializer>(s: S, v: option<int>) {\n+        s.emit_enum(\"core::option::t\") {||\n+            alt v {\n+              none {\n+                s.emit_enum_variant(\"core::option::none\", 0u, 0u) {||}\n+              }\n+              some(v0) {\n+                s.emit_enum_variant(\"core::option::some\", 1u, 1u) {||\n+                    s.emit_enum_variant_arg(0u) {|| serialize_1(s, v0) }\n+                }\n+              }\n+            }\n+        }\n+    }\n+\n+    fn deserialize_1<S: deserializer>(s: S) -> int {\n+        s.read_i64() as int\n+    }\n+\n+    fn deserialize_0<S: deserializer>(s: S) -> option<int> {\n+        s.read_enum(\"option\") {||\n+            s.read_enum_variant {|i|\n+                alt i {\n+                  0u { none }\n+                  1u {\n+                    let v0 = s.read_enum_variant_arg(0u) {||\n+                        deserialize_1(s)\n+                    };\n+                    some(v0)\n+                  }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn test_v(v: option<int>) {\n+        #debug[\"v == %?\", v];\n+        let mbuf = io::mk_mem_buffer();\n+        let ebml_w = ebml::create_writer(io::mem_buffer_writer(mbuf));\n+        serialize_0(ebml_w, v);\n+        let ebml_doc = ebml::new_doc(@io::mem_buffer_buf(mbuf));\n+        let deser = mk_ebml_deserializer(ebml_doc);\n+        let v1 = deserialize_0(deser);\n+        #debug[\"v1 == %?\", v1];\n+        assert v == v1;\n+    }\n+\n+    test_v(some(22));\n+    test_v(none);\n+    test_v(some(3));\n+}"}, {"sha": "695a45f9be7e3263e76842f6f5dc5f72b8afbf48", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae", "patch": "@@ -70,7 +70,7 @@ mod unicode;\n // Compiler support modules\n \n mod test;\n-\n+mod serialization;\n \n // Target-os module.\n "}, {"sha": "5604ff2a883b5039a6961c4b63fd26e69ad84ea3", "filename": "src/serializer/serializer.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae/src%2Fserializer%2Fserializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae/src%2Fserializer%2Fserializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fserializer%2Fserializer.rs?ref=3a2f1e1876061ccf7eeffe7f4adba0874c7a98ae", "patch": "@@ -232,6 +232,7 @@ impl serialize_ctx for serialize_ctx {\n                       tps: [ty::t]) -> ast_expr {\n         let variants = ty::substd_enum_variants(self.tcx, id, tps);\n \n+        let idx = 0u;\n         let arms = vec::map(variants) {|variant|\n             let item_path = ty::item_path(self.tcx, variant.id);\n             let v_path = ast_map::path_to_str(item_path);\n@@ -245,19 +246,22 @@ impl serialize_ctx for serialize_ctx {\n                 }\n             };\n \n-            let v_ident = ast_map::path_to_str_with_sep(item_path, \"_\");\n-            let v_const = #fmt[\"at_%s\", v_ident];\n+            let v_id = idx;\n+            idx += 1u;\n \n             #fmt[\"%s { \\\n-                    start_variant(cx, %s); \\\n-                    %s \\\n-                    end_variant(cx, %s); \\\n-                  }\", v_pat, v_const, self.blk(stmts), v_const]\n+                    s.emit_enum_variant(\\\"%s\\\", %uu, %uu) {||\\\n+                      %s \\\n+                    } \\\n+                  }\", v_pat, v_path, v_id, n_args, self.blk(stmts)]\n         };\n \n-        #fmt[\"alt %s { \\\n-                %s \\\n-              }\", v, str::connect(arms, \"\\n\")]\n+        let enum_name = ast_map::path_to_str(ty::item_path(self.tcx, id));\n+        #fmt[\"s.emit_enum(\\\"%s\\\") {||\\\n+                alt %s { \\\n+                  %s \\\n+                }\\\n+              }\", enum_name, v, str::connect(arms, \"\\n\")]\n     }\n \n     fn serialize_arm(v_path: str, emit_fn: str, args: [ty::t])"}]}