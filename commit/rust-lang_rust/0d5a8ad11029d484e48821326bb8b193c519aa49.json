{"sha": "0d5a8ad11029d484e48821326bb8b193c519aa49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNWE4YWQxMTAyOWQ0ODRlNDg4MjEzMjZiYjhiMTkzYzUxOWFhNDk=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-20T01:19:19Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:04:43Z"}, "message": "Move get_landing_pad onto DropVal.", "tree": {"sha": "1d8fba2304f1a19d00adf83b00b1a27f7ce67b55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d8fba2304f1a19d00adf83b00b1a27f7ce67b55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d5a8ad11029d484e48821326bb8b193c519aa49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d5a8ad11029d484e48821326bb8b193c519aa49", "html_url": "https://github.com/rust-lang/rust/commit/0d5a8ad11029d484e48821326bb8b193c519aa49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d5a8ad11029d484e48821326bb8b193c519aa49/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f368e6da045b0ac179ac3fb02423c4d7db3c62c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f368e6da045b0ac179ac3fb02423c4d7db3c62c", "html_url": "https://github.com/rust-lang/rust/commit/6f368e6da045b0ac179ac3fb02423c4d7db3c62c"}], "stats": {"total": 149, "additions": 69, "deletions": 80}, "files": [{"sha": "6dd8d8b2247b02dd574ce57a8af2c794bb70cff1", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 69, "deletions": 80, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/0d5a8ad11029d484e48821326bb8b193c519aa49/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5a8ad11029d484e48821326bb8b193c519aa49/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=0d5a8ad11029d484e48821326bb8b193c519aa49", "patch": "@@ -46,6 +46,74 @@ impl<'tcx> DropValue<'tcx> {\n     fn trans<'a>(&self, funclet: Option<&'a Funclet>, bcx: &BlockAndBuilder<'a, 'tcx>) {\n         glue::call_drop_glue(bcx, self.val, self.ty, self.skip_dtor, funclet)\n     }\n+\n+    /// Creates a landing pad for the top scope. The landing pad will perform all cleanups necessary\n+    /// for an unwind and then `resume` to continue error propagation:\n+    ///\n+    ///     landing_pad -> ... cleanups ... -> [resume]\n+    ///\n+    /// This should only be called once per function, as it creates an alloca for the landingpad.\n+    fn get_landing_pad<'a>(&self, fcx: &FunctionContext<'a, 'tcx>) -> BasicBlockRef {\n+        debug!(\"get_landing_pad\");\n+\n+        let mut pad_bcx = fcx.build_new_block(\"unwind_custom_\");\n+\n+        let llpersonality = pad_bcx.fcx().eh_personality();\n+\n+        let resume_bcx = fcx.build_new_block(\"resume\");\n+        let val = if base::wants_msvc_seh(fcx.ccx.sess()) {\n+            // A cleanup pad requires a personality function to be specified, so\n+            // we do that here explicitly (happens implicitly below through\n+            // creation of the landingpad instruction). We then create a\n+            // cleanuppad instruction which has no filters to run cleanup on all\n+            // exceptions.\n+            pad_bcx.set_personality_fn(llpersonality);\n+            let llretval = pad_bcx.cleanup_pad(None, &[]);\n+            resume_bcx.cleanup_ret(resume_bcx.cleanup_pad(None, &[]), None);\n+            UnwindKind::CleanupPad(llretval)\n+        } else {\n+            // The landing pad return type (the type being propagated). Not sure\n+            // what this represents but it's determined by the personality\n+            // function and this is what the EH proposal example uses.\n+            let llretty = Type::struct_(fcx.ccx, &[Type::i8p(fcx.ccx), Type::i32(fcx.ccx)], false);\n+\n+            // The only landing pad clause will be 'cleanup'\n+            let llretval = pad_bcx.landing_pad(llretty, llpersonality, 1, pad_bcx.fcx().llfn);\n+\n+            // The landing pad block is a cleanup\n+            pad_bcx.set_cleanup(llretval);\n+\n+            let addr = pad_bcx.fcx().alloca(common::val_ty(llretval), \"\");\n+            Lifetime::Start.call(&pad_bcx, addr);\n+            pad_bcx.store(llretval, addr);\n+            let lp = resume_bcx.load(addr);\n+            Lifetime::End.call(&resume_bcx, addr);\n+            if !resume_bcx.sess().target.target.options.custom_unwind_resume {\n+                resume_bcx.resume(lp);\n+            } else {\n+                let exc_ptr = resume_bcx.extract_value(lp, 0);\n+                resume_bcx.call(fcx.eh_unwind_resume().reify(fcx.ccx), &[exc_ptr], None);\n+            }\n+            UnwindKind::LandingPad\n+        };\n+\n+        let mut cleanup = fcx.build_new_block(\"clean_custom_\");\n+\n+        // Insert cleanup instructions into the cleanup block\n+        let funclet = match val {\n+            UnwindKind::CleanupPad(_) => Some(Funclet::new(cleanup.cleanup_pad(None, &[]))),\n+            UnwindKind::LandingPad => None,\n+        };\n+        self.trans(funclet.as_ref(), &cleanup);\n+\n+        // Insert instruction into cleanup block to branch to the exit\n+        val.branch(&mut cleanup, resume_bcx.llbb());\n+\n+        // Branch into the cleanup block\n+        val.branch(&mut pad_bcx, cleanup.llbb());\n+\n+        pad_bcx.llbb()\n+    }\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -73,16 +141,6 @@ impl UnwindKind {\n     }\n }\n \n-impl PartialEq for UnwindKind {\n-    fn eq(&self, label: &UnwindKind) -> bool {\n-        match (*self, *label) {\n-            (UnwindKind::LandingPad, UnwindKind::LandingPad) |\n-            (UnwindKind::CleanupPad(..), UnwindKind::CleanupPad(..)) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     /// Schedules a (deep) drop of `val`, which is a pointer to an instance of `ty`\n     pub fn schedule_drop_mem(&self, val: ValueRef, ty: Ty<'tcx>) -> CleanupScope<'tcx> {\n@@ -126,7 +184,7 @@ impl<'tcx> CleanupScope<'tcx> {\n         CleanupScope {\n             cleanup: Some(drop_val),\n             landing_pad: if !fcx.ccx.sess().no_landing_pads() {\n-                Some(CleanupScope::get_landing_pad(fcx, &drop_val))\n+                Some(drop_val.get_landing_pad(fcx))\n             } else {\n                 None\n             },\n@@ -145,73 +203,4 @@ impl<'tcx> CleanupScope<'tcx> {\n             cleanup.trans(None, &bcx);\n         }\n     }\n-\n-    /// Creates a landing pad for the top scope. The landing pad will perform all cleanups necessary\n-    /// for an unwind and then `resume` to continue error propagation:\n-    ///\n-    ///     landing_pad -> ... cleanups ... -> [resume]\n-    ///\n-    /// This should only be called once per function, as it creates an alloca for the landingpad.\n-    fn get_landing_pad<'a>(fcx: &FunctionContext<'a, 'tcx>, drop_val: &DropValue<'tcx>)\n-        -> BasicBlockRef {\n-        debug!(\"get_landing_pad\");\n-\n-        let mut pad_bcx = fcx.build_new_block(\"unwind_custom_\");\n-\n-        let llpersonality = pad_bcx.fcx().eh_personality();\n-\n-        let resume_bcx = fcx.build_new_block(\"resume\");\n-        let val = if base::wants_msvc_seh(fcx.ccx.sess()) {\n-            // A cleanup pad requires a personality function to be specified, so\n-            // we do that here explicitly (happens implicitly below through\n-            // creation of the landingpad instruction). We then create a\n-            // cleanuppad instruction which has no filters to run cleanup on all\n-            // exceptions.\n-            pad_bcx.set_personality_fn(llpersonality);\n-            let llretval = pad_bcx.cleanup_pad(None, &[]);\n-            resume_bcx.cleanup_ret(resume_bcx.cleanup_pad(None, &[]), None);\n-            UnwindKind::CleanupPad(llretval)\n-        } else {\n-            // The landing pad return type (the type being propagated). Not sure\n-            // what this represents but it's determined by the personality\n-            // function and this is what the EH proposal example uses.\n-            let llretty = Type::struct_(fcx.ccx, &[Type::i8p(fcx.ccx), Type::i32(fcx.ccx)], false);\n-\n-            // The only landing pad clause will be 'cleanup'\n-            let llretval = pad_bcx.landing_pad(llretty, llpersonality, 1, pad_bcx.fcx().llfn);\n-\n-            // The landing pad block is a cleanup\n-            pad_bcx.set_cleanup(llretval);\n-\n-            let addr = pad_bcx.fcx().alloca(common::val_ty(llretval), \"\");\n-            Lifetime::Start.call(&pad_bcx, addr);\n-            pad_bcx.store(llretval, addr);\n-            let lp = resume_bcx.load(addr);\n-            Lifetime::End.call(&resume_bcx, addr);\n-            if !resume_bcx.sess().target.target.options.custom_unwind_resume {\n-                resume_bcx.resume(lp);\n-            } else {\n-                let exc_ptr = resume_bcx.extract_value(lp, 0);\n-                resume_bcx.call(fcx.eh_unwind_resume().reify(fcx.ccx), &[exc_ptr], None);\n-            }\n-            UnwindKind::LandingPad\n-        };\n-\n-        let mut cleanup = fcx.build_new_block(\"clean_custom_\");\n-\n-        // Insert cleanup instructions into the cleanup block\n-        let funclet = match val {\n-            UnwindKind::CleanupPad(_) => Some(Funclet::new(cleanup.cleanup_pad(None, &[]))),\n-            UnwindKind::LandingPad => None,\n-        };\n-        drop_val.trans(funclet.as_ref(), &cleanup);\n-\n-        // Insert instruction into cleanup block to branch to the exit\n-        val.branch(&mut cleanup, resume_bcx.llbb());\n-\n-        // Branch into the cleanup block\n-        val.branch(&mut pad_bcx, cleanup.llbb());\n-\n-        return pad_bcx.llbb();\n-    }\n }"}]}