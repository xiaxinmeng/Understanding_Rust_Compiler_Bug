{"sha": "715c178f0b52117c4c689c39a0921012bfbb2386", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxNWMxNzhmMGI1MjExN2M0YzY4OWMzOWEwOTIxMDEyYmZiYjIzODY=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-04T10:55:47Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-04T11:16:39Z"}, "message": "Move TyBuilder to its own module", "tree": {"sha": "63d578f6ed6d84bf98a2c368ea80b1e159746ab4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63d578f6ed6d84bf98a2c368ea80b1e159746ab4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/715c178f0b52117c4c689c39a0921012bfbb2386", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/715c178f0b52117c4c689c39a0921012bfbb2386", "html_url": "https://github.com/rust-lang/rust/commit/715c178f0b52117c4c689c39a0921012bfbb2386", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/715c178f0b52117c4c689c39a0921012bfbb2386/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "584d1c9e5bc39402e2855d0ffa9394ae5a066060", "url": "https://api.github.com/repos/rust-lang/rust/commits/584d1c9e5bc39402e2855d0ffa9394ae5a066060", "html_url": "https://github.com/rust-lang/rust/commit/584d1c9e5bc39402e2855d0ffa9394ae5a066060"}], "stats": {"total": 425, "additions": 221, "deletions": 204}, "files": [{"sha": "ba158a74925c8df0d0b2913ae17389777035e811", "filename": "crates/hir_ty/src/builder.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/715c178f0b52117c4c689c39a0921012bfbb2386/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/715c178f0b52117c4c689c39a0921012bfbb2386/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fbuilder.rs?ref=715c178f0b52117c4c689c39a0921012bfbb2386", "patch": "@@ -0,0 +1,211 @@\n+//! `TyBuilder`, a helper for building instances of `Ty` and related types.\n+\n+use std::iter;\n+\n+use chalk_ir::{\n+    cast::{Cast, CastTo, Caster},\n+    interner::HasInterner,\n+    AdtId, BoundVar, DebruijnIndex, Safety, Scalar,\n+};\n+use hir_def::{builtin_type::BuiltinType, GenericDefId, TraitId, TypeAliasId};\n+use smallvec::SmallVec;\n+\n+use crate::{\n+    db::HirDatabase, primitive, to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders,\n+    CallableSig, FnPointer, FnSig, GenericArg, Interner, ProjectionTy, Substitution, TraitRef, Ty,\n+    TyDefId, TyKind, TypeWalk, ValueTyDefId,\n+};\n+\n+pub struct TyBuilder<D> {\n+    data: D,\n+    vec: SmallVec<[GenericArg; 2]>,\n+    param_count: usize,\n+}\n+\n+impl<D> TyBuilder<D> {\n+    fn new(data: D, param_count: usize) -> TyBuilder<D> {\n+        TyBuilder { data, param_count, vec: SmallVec::with_capacity(param_count) }\n+    }\n+\n+    fn build_internal(self) -> (D, Substitution) {\n+        assert_eq!(self.vec.len(), self.param_count);\n+        // FIXME: would be good to have a way to construct a chalk_ir::Substitution from the interned form\n+        let subst = Substitution(self.vec);\n+        (self.data, subst)\n+    }\n+\n+    pub fn push(mut self, arg: impl CastTo<GenericArg>) -> Self {\n+        self.vec.push(arg.cast(&Interner));\n+        self\n+    }\n+\n+    pub fn remaining(&self) -> usize {\n+        self.param_count - self.vec.len()\n+    }\n+\n+    pub fn fill_with_bound_vars(self, debruijn: DebruijnIndex, starting_from: usize) -> Self {\n+        self.fill(\n+            (starting_from..)\n+                .map(|idx| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(&Interner)),\n+        )\n+    }\n+\n+    pub fn fill_with_unknown(self) -> Self {\n+        self.fill(iter::repeat(TyKind::Unknown.intern(&Interner)))\n+    }\n+\n+    pub fn fill(mut self, filler: impl Iterator<Item = impl CastTo<GenericArg>>) -> Self {\n+        self.vec.extend(filler.take(self.remaining()).casted(&Interner));\n+        assert_eq!(self.remaining(), 0);\n+        self\n+    }\n+\n+    pub fn use_parent_substs(mut self, parent_substs: &Substitution) -> Self {\n+        assert!(self.vec.is_empty());\n+        assert!(parent_substs.len(&Interner) <= self.param_count);\n+        self.vec.extend(parent_substs.iter(&Interner).cloned());\n+        self\n+    }\n+}\n+\n+impl TyBuilder<()> {\n+    pub fn unit() -> Ty {\n+        TyKind::Tuple(0, Substitution::empty(&Interner)).intern(&Interner)\n+    }\n+\n+    pub fn fn_ptr(sig: CallableSig) -> Ty {\n+        TyKind::Function(FnPointer {\n+            num_args: sig.params().len(),\n+            sig: FnSig { abi: (), safety: Safety::Safe, variadic: sig.is_varargs },\n+            substs: Substitution::from_iter(&Interner, sig.params_and_return.iter().cloned()),\n+        })\n+        .intern(&Interner)\n+    }\n+\n+    pub fn builtin(builtin: BuiltinType) -> Ty {\n+        match builtin {\n+            BuiltinType::Char => TyKind::Scalar(Scalar::Char).intern(&Interner),\n+            BuiltinType::Bool => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n+            BuiltinType::Str => TyKind::Str.intern(&Interner),\n+            BuiltinType::Int(t) => {\n+                TyKind::Scalar(Scalar::Int(primitive::int_ty_from_builtin(t))).intern(&Interner)\n+            }\n+            BuiltinType::Uint(t) => {\n+                TyKind::Scalar(Scalar::Uint(primitive::uint_ty_from_builtin(t))).intern(&Interner)\n+            }\n+            BuiltinType::Float(t) => {\n+                TyKind::Scalar(Scalar::Float(primitive::float_ty_from_builtin(t))).intern(&Interner)\n+            }\n+        }\n+    }\n+\n+    pub fn subst_for_def(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> TyBuilder<()> {\n+        let def = def.into();\n+        let params = generics(db.upcast(), def);\n+        let param_count = params.len();\n+        TyBuilder::new((), param_count)\n+    }\n+\n+    pub fn build(self) -> Substitution {\n+        let ((), subst) = self.build_internal();\n+        subst\n+    }\n+}\n+\n+impl TyBuilder<hir_def::AdtId> {\n+    pub fn adt(db: &dyn HirDatabase, adt: hir_def::AdtId) -> TyBuilder<hir_def::AdtId> {\n+        let generics = generics(db.upcast(), adt.into());\n+        let param_count = generics.len();\n+        TyBuilder::new(adt, param_count)\n+    }\n+\n+    pub fn fill_with_defaults(\n+        mut self,\n+        db: &dyn HirDatabase,\n+        mut fallback: impl FnMut() -> Ty,\n+    ) -> Self {\n+        let defaults = db.generic_defaults(self.data.into());\n+        for default_ty in defaults.iter().skip(self.vec.len()) {\n+            if default_ty.skip_binders().is_unknown() {\n+                self.vec.push(fallback().cast(&Interner));\n+            } else {\n+                // each default can depend on the previous parameters\n+                let subst_so_far = Substitution(self.vec.clone());\n+                self.vec.push(default_ty.clone().subst(&subst_so_far).cast(&Interner));\n+            }\n+        }\n+        self\n+    }\n+\n+    pub fn build(self) -> Ty {\n+        let (adt, subst) = self.build_internal();\n+        TyKind::Adt(AdtId(adt), subst).intern(&Interner)\n+    }\n+}\n+\n+pub struct Tuple(usize);\n+impl TyBuilder<Tuple> {\n+    pub fn tuple(size: usize) -> TyBuilder<Tuple> {\n+        TyBuilder::new(Tuple(size), size)\n+    }\n+\n+    pub fn build(self) -> Ty {\n+        let (Tuple(size), subst) = self.build_internal();\n+        TyKind::Tuple(size, subst).intern(&Interner)\n+    }\n+}\n+\n+impl TyBuilder<TraitId> {\n+    pub fn trait_ref(db: &dyn HirDatabase, trait_id: TraitId) -> TyBuilder<TraitId> {\n+        let generics = generics(db.upcast(), trait_id.into());\n+        let param_count = generics.len();\n+        TyBuilder::new(trait_id, param_count)\n+    }\n+\n+    pub fn build(self) -> TraitRef {\n+        let (trait_id, substitution) = self.build_internal();\n+        TraitRef { trait_id: to_chalk_trait_id(trait_id), substitution }\n+    }\n+}\n+\n+impl TyBuilder<TypeAliasId> {\n+    pub fn assoc_type_projection(\n+        db: &dyn HirDatabase,\n+        type_alias: TypeAliasId,\n+    ) -> TyBuilder<TypeAliasId> {\n+        let generics = generics(db.upcast(), type_alias.into());\n+        let param_count = generics.len();\n+        TyBuilder::new(type_alias, param_count)\n+    }\n+\n+    pub fn build(self) -> ProjectionTy {\n+        let (type_alias, substitution) = self.build_internal();\n+        ProjectionTy { associated_ty_id: to_assoc_type_id(type_alias), substitution }\n+    }\n+}\n+\n+impl<T: TypeWalk + HasInterner<Interner = Interner>> TyBuilder<Binders<T>> {\n+    fn subst_binders(b: Binders<T>) -> Self {\n+        let param_count = b.num_binders;\n+        TyBuilder::new(b, param_count)\n+    }\n+\n+    pub fn build(self) -> T {\n+        let (b, subst) = self.build_internal();\n+        b.subst(&subst)\n+    }\n+}\n+\n+impl TyBuilder<Binders<Ty>> {\n+    pub fn def_ty(db: &dyn HirDatabase, def: TyDefId) -> TyBuilder<Binders<Ty>> {\n+        TyBuilder::subst_binders(db.ty(def.into()))\n+    }\n+\n+    pub fn impl_self_ty(db: &dyn HirDatabase, def: hir_def::ImplId) -> TyBuilder<Binders<Ty>> {\n+        TyBuilder::subst_binders(db.impl_self_ty(def))\n+    }\n+\n+    pub fn value_ty(db: &dyn HirDatabase, def: ValueTyDefId) -> TyBuilder<Binders<Ty>> {\n+        TyBuilder::subst_binders(db.value_ty(def))\n+    }\n+}"}, {"sha": "ebdcc4804fb3c3a61f49a268f59f856467cdf7c4", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 10, "deletions": 204, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/715c178f0b52117c4c689c39a0921012bfbb2386/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/715c178f0b52117c4c689c39a0921012bfbb2386/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=715c178f0b52117c4c689c39a0921012bfbb2386", "patch": "@@ -14,6 +14,8 @@ mod lower;\n pub(crate) mod infer;\n pub(crate) mod utils;\n mod chalk_cast;\n+mod chalk_ext;\n+mod builder;\n \n pub mod display;\n pub mod db;\n@@ -23,21 +25,18 @@ pub mod diagnostics;\n mod tests;\n #[cfg(test)]\n mod test_db;\n-mod chalk_ext;\n \n-use std::{iter, mem, sync::Arc};\n+use std::{mem, sync::Arc};\n+\n+use chalk_ir::cast::{CastTo, Caster};\n+use itertools::Itertools;\n+use smallvec::SmallVec;\n \n use base_db::salsa;\n-use chalk_ir::{\n-    cast::{CastTo, Caster},\n-    interner::HasInterner,\n-};\n use hir_def::{\n-    builtin_type::BuiltinType, expr::ExprId, type_ref::Rawness, AssocContainerId, FunctionId,\n-    GenericDefId, HasModule, LifetimeParamId, Lookup, TraitId, TypeAliasId, TypeParamId,\n+    expr::ExprId, type_ref::Rawness, AssocContainerId, FunctionId, GenericDefId, HasModule,\n+    LifetimeParamId, Lookup, TraitId, TypeAliasId, TypeParamId,\n };\n-use itertools::Itertools;\n-use smallvec::SmallVec;\n \n use crate::{\n     db::HirDatabase,\n@@ -46,6 +45,7 @@ use crate::{\n };\n \n pub use autoderef::autoderef;\n+pub use builder::TyBuilder;\n pub use chalk_ext::TyExt;\n pub use infer::{could_unify, InferenceResult, InferenceVar};\n pub use lower::{\n@@ -744,200 +744,6 @@ impl TypeWalk for CallableSig {\n     }\n }\n \n-pub struct TyBuilder<D> {\n-    data: D,\n-    vec: SmallVec<[GenericArg; 2]>,\n-    param_count: usize,\n-}\n-\n-impl<D> TyBuilder<D> {\n-    fn new(data: D, param_count: usize) -> TyBuilder<D> {\n-        TyBuilder { data, param_count, vec: SmallVec::with_capacity(param_count) }\n-    }\n-\n-    fn build_internal(self) -> (D, Substitution) {\n-        assert_eq!(self.vec.len(), self.param_count);\n-        // FIXME: would be good to have a way to construct a chalk_ir::Substitution from the interned form\n-        let subst = Substitution(self.vec);\n-        (self.data, subst)\n-    }\n-\n-    pub fn push(mut self, arg: impl CastTo<GenericArg>) -> Self {\n-        self.vec.push(arg.cast(&Interner));\n-        self\n-    }\n-\n-    fn remaining(&self) -> usize {\n-        self.param_count - self.vec.len()\n-    }\n-\n-    pub fn fill_with_bound_vars(self, debruijn: DebruijnIndex, starting_from: usize) -> Self {\n-        self.fill(\n-            (starting_from..)\n-                .map(|idx| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(&Interner)),\n-        )\n-    }\n-\n-    pub fn fill_with_unknown(self) -> Self {\n-        self.fill(iter::repeat(TyKind::Unknown.intern(&Interner)))\n-    }\n-\n-    pub fn fill(mut self, filler: impl Iterator<Item = impl CastTo<GenericArg>>) -> Self {\n-        self.vec.extend(filler.take(self.remaining()).casted(&Interner));\n-        assert_eq!(self.remaining(), 0);\n-        self\n-    }\n-\n-    pub fn use_parent_substs(mut self, parent_substs: &Substitution) -> Self {\n-        assert!(self.vec.is_empty());\n-        assert!(parent_substs.len(&Interner) <= self.param_count);\n-        self.vec.extend(parent_substs.iter(&Interner).cloned());\n-        self\n-    }\n-}\n-\n-impl TyBuilder<()> {\n-    pub fn unit() -> Ty {\n-        TyKind::Tuple(0, Substitution::empty(&Interner)).intern(&Interner)\n-    }\n-\n-    pub fn fn_ptr(sig: CallableSig) -> Ty {\n-        TyKind::Function(FnPointer {\n-            num_args: sig.params().len(),\n-            sig: FnSig { abi: (), safety: Safety::Safe, variadic: sig.is_varargs },\n-            substs: Substitution::from_iter(&Interner, sig.params_and_return.iter().cloned()),\n-        })\n-        .intern(&Interner)\n-    }\n-\n-    pub fn builtin(builtin: BuiltinType) -> Ty {\n-        match builtin {\n-            BuiltinType::Char => TyKind::Scalar(Scalar::Char).intern(&Interner),\n-            BuiltinType::Bool => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n-            BuiltinType::Str => TyKind::Str.intern(&Interner),\n-            BuiltinType::Int(t) => {\n-                TyKind::Scalar(Scalar::Int(primitive::int_ty_from_builtin(t))).intern(&Interner)\n-            }\n-            BuiltinType::Uint(t) => {\n-                TyKind::Scalar(Scalar::Uint(primitive::uint_ty_from_builtin(t))).intern(&Interner)\n-            }\n-            BuiltinType::Float(t) => {\n-                TyKind::Scalar(Scalar::Float(primitive::float_ty_from_builtin(t))).intern(&Interner)\n-            }\n-        }\n-    }\n-\n-    pub fn subst_for_def(db: &dyn HirDatabase, def: impl Into<GenericDefId>) -> TyBuilder<()> {\n-        let def = def.into();\n-        let params = generics(db.upcast(), def);\n-        let param_count = params.len();\n-        TyBuilder::new((), param_count)\n-    }\n-\n-    pub fn build(self) -> Substitution {\n-        let ((), subst) = self.build_internal();\n-        subst\n-    }\n-}\n-\n-impl TyBuilder<hir_def::AdtId> {\n-    pub fn adt(db: &dyn HirDatabase, adt: hir_def::AdtId) -> TyBuilder<hir_def::AdtId> {\n-        let generics = generics(db.upcast(), adt.into());\n-        let param_count = generics.len();\n-        TyBuilder::new(adt, param_count)\n-    }\n-\n-    pub fn fill_with_defaults(\n-        mut self,\n-        db: &dyn HirDatabase,\n-        mut fallback: impl FnMut() -> Ty,\n-    ) -> Self {\n-        let defaults = db.generic_defaults(self.data.into());\n-        for default_ty in defaults.iter().skip(self.vec.len()) {\n-            if default_ty.skip_binders().is_unknown() {\n-                self.vec.push(fallback().cast(&Interner));\n-            } else {\n-                // each default can depend on the previous parameters\n-                let subst_so_far = Substitution(self.vec.clone());\n-                self.vec.push(default_ty.clone().subst(&subst_so_far).cast(&Interner));\n-            }\n-        }\n-        self\n-    }\n-\n-    pub fn build(self) -> Ty {\n-        let (adt, subst) = self.build_internal();\n-        TyKind::Adt(AdtId(adt), subst).intern(&Interner)\n-    }\n-}\n-\n-struct Tuple(usize);\n-impl TyBuilder<Tuple> {\n-    pub fn tuple(size: usize) -> TyBuilder<Tuple> {\n-        TyBuilder::new(Tuple(size), size)\n-    }\n-\n-    pub fn build(self) -> Ty {\n-        let (Tuple(size), subst) = self.build_internal();\n-        TyKind::Tuple(size, subst).intern(&Interner)\n-    }\n-}\n-\n-impl TyBuilder<TraitId> {\n-    pub fn trait_ref(db: &dyn HirDatabase, trait_id: TraitId) -> TyBuilder<TraitId> {\n-        let generics = generics(db.upcast(), trait_id.into());\n-        let param_count = generics.len();\n-        TyBuilder::new(trait_id, param_count)\n-    }\n-\n-    pub fn build(self) -> TraitRef {\n-        let (trait_id, substitution) = self.build_internal();\n-        TraitRef { trait_id: to_chalk_trait_id(trait_id), substitution }\n-    }\n-}\n-\n-impl TyBuilder<TypeAliasId> {\n-    pub fn assoc_type_projection(\n-        db: &dyn HirDatabase,\n-        type_alias: TypeAliasId,\n-    ) -> TyBuilder<TypeAliasId> {\n-        let generics = generics(db.upcast(), type_alias.into());\n-        let param_count = generics.len();\n-        TyBuilder::new(type_alias, param_count)\n-    }\n-\n-    pub fn build(self) -> ProjectionTy {\n-        let (type_alias, substitution) = self.build_internal();\n-        ProjectionTy { associated_ty_id: to_assoc_type_id(type_alias), substitution }\n-    }\n-}\n-\n-impl<T: TypeWalk + HasInterner<Interner = Interner>> TyBuilder<Binders<T>> {\n-    fn subst_binders(b: Binders<T>) -> Self {\n-        let param_count = b.num_binders;\n-        TyBuilder::new(b, param_count)\n-    }\n-\n-    pub fn build(self) -> T {\n-        let (b, subst) = self.build_internal();\n-        b.subst(&subst)\n-    }\n-}\n-\n-impl TyBuilder<Binders<Ty>> {\n-    pub fn def_ty(db: &dyn HirDatabase, def: TyDefId) -> TyBuilder<Binders<Ty>> {\n-        TyBuilder::subst_binders(db.ty(def.into()))\n-    }\n-\n-    pub fn impl_self_ty(db: &dyn HirDatabase, def: hir_def::ImplId) -> TyBuilder<Binders<Ty>> {\n-        TyBuilder::subst_binders(db.impl_self_ty(def))\n-    }\n-\n-    pub fn value_ty(db: &dyn HirDatabase, def: ValueTyDefId) -> TyBuilder<Binders<Ty>> {\n-        TyBuilder::subst_binders(db.value_ty(def))\n-    }\n-}\n-\n impl Ty {\n     pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n         match self.kind(&Interner) {"}]}