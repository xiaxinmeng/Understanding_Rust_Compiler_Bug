{"sha": "1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhODk2OWY2NGJlMGE3ZTdhMmNkNjFmMDRkNmM0ZDk0YWJlMzVjNzU=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-06-12T21:22:17Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-06-20T22:42:16Z"}, "message": "Get cross crate default methods working.\n\nThis fixes the large number of problems that prevented cross crate\nmethods from ever working. It also fixes a couple lingering bugs with\npolymorphic default methods and cleans up some of the code paths.\n\nCloses #4102. Closes #4103.", "tree": {"sha": "2dd808aae1099d69578f601eb566ee91a3ce0e10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dd808aae1099d69578f601eb566ee91a3ce0e10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75", "html_url": "https://github.com/rust-lang/rust/commit/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6759ce4fd2083595193c93c3fd72383d24a73a5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6759ce4fd2083595193c93c3fd72383d24a73a5e", "html_url": "https://github.com/rust-lang/rust/commit/6759ce4fd2083595193c93c3fd72383d24a73a5e"}], "stats": {"total": 472, "additions": 255, "deletions": 217}, "files": [{"sha": "e1cd7caa19c1e4adae2962487754934cf9ae3a9f", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75", "patch": "@@ -229,7 +229,7 @@ pub fn get_impl_trait(tcx: ty::ctxt,\n pub fn get_impl_method(cstore: @mut cstore::CStore,\n                        def: ast::def_id,\n                        mname: ast::ident)\n-                    -> ast::def_id {\n+                    -> Option<ast::def_id> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impl_method(cstore.intr, cdata, def.node, mname)\n }"}, {"sha": "7f06953663b3c552a25d7f1bdf769d417ef59ca1", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 34, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75", "patch": "@@ -415,7 +415,7 @@ pub fn get_impl_trait(cdata: cmd,\n }\n \n pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n-                       name: ast::ident) -> ast::def_id {\n+                       name: ast::ident) -> Option<ast::def_id> {\n     let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n     for reader::tagged_docs(find_item(id, items), tag_item_impl_method)\n@@ -425,7 +425,7 @@ pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                 found = Some(translate_def_id(cdata, m_did));\n             }\n         }\n-    found.get()\n+    found\n }\n \n pub fn get_symbol(data: @~[u8], id: ast::node_id) -> ~str {\n@@ -755,40 +755,13 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n \n-    for reader::tagged_docs(item, tag_item_trait_method) |mth| {\n-        if item_method_sort(mth) != 'p' { loop; }\n-\n-        let did = item_def_id(mth, cdata);\n-\n-        let type_param_defs =\n-            item_ty_param_defs(mth, tcx, cdata,\n-                               tag_items_data_item_ty_param_bounds);\n-        let name = item_name(intr, mth);\n-        let ty = doc_type(mth, tcx, cdata);\n+    for reader::tagged_docs(item, tag_item_trait_method) |mth_id| {\n+        let did = item_def_id(mth_id, cdata);\n+        let mth = lookup_item(did.node, data);\n \n-        let fty = match ty::get(ty).sty {\n-            ty::ty_bare_fn(ref f) => copy *f,\n-            _ => {\n-                tcx.diag.handler().bug(\"get_provided_trait_methods(): id \\\n-                                        has non-function type\");\n-            }\n-        };\n+        if item_method_sort(mth) != 'p' { loop; }\n \n-        let transformed_self_ty = doc_transformed_self_ty(mth, tcx, cdata);\n-        let explicit_self = get_explicit_self(mth);\n-\n-        let ty_method = ty::Method::new(\n-            name,\n-            ty::Generics {\n-                type_param_defs: type_param_defs,\n-                region_param: None\n-            },\n-            transformed_self_ty,\n-            fty,\n-            explicit_self,\n-            ast::public,\n-            did\n-        );\n+        let ty_method = get_method(intr, cdata, did.node, tcx);\n         let provided_trait_method_info = ProvidedTraitMethodInfo {\n             ty: ty_method,\n             def_id: did"}, {"sha": "7fab21b4156cb5d395e1cd702cc5b1a0279bc6bc", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75", "patch": "@@ -42,6 +42,7 @@ use middle::trans::type_of;\n use middle::ty;\n use middle::subst::Subst;\n use middle::typeck;\n+use middle::typeck::coherence::make_substs_for_receiver_types;\n use util::ppaux::Repr;\n \n use core::vec;\n@@ -253,50 +254,24 @@ pub fn trans_fn_ref_with_vtables(\n             // So, what we need to do is find this substitution and\n             // compose it with the one we already have.\n \n-            // In order to find the substitution for the trait params,\n-            // we look up the impl in the ast map, find its trait_ref\n-            // id, then look up its trait ref. I feel like there\n-            // should be a better way.\n-            let map_node = session::expect(\n-                ccx.sess,\n-                ccx.tcx.items.find_copy(&source.impl_id.node),\n-                || fmt!(\"couldn't find node while monomorphizing \\\n-                         default method: %?\", source.impl_id.node));\n-            let item = match map_node {\n-                ast_map::node_item(item, _) => item,\n-                _ => ccx.tcx.sess.bug(\"Not an item\")\n-            };\n-            let ast_trait_ref = match copy item.node {\n-                ast::item_impl(_, Some(tr), _, _) => tr,\n-                _ => ccx.tcx.sess.bug(\"Not an impl with trait_ref\")\n-            };\n-            let trait_ref = ccx.tcx.trait_refs.get(&ast_trait_ref.ref_id);\n-\n-            // The substs from the trait_ref only substitues for the\n-            // trait parameters. Our substitution also needs to be\n-            // able to substitute for the actual method type\n-            // params. To do this, we figure out how many method\n-            // parameters there are and pad out the substitution with\n-            // substitution for the variables.\n-            let item_ty = ty::lookup_item_type(tcx, source.method_id);\n-            let num_params = item_ty.generics.type_param_defs.len() -\n-                trait_ref.substs.tps.len();\n-            let id_subst = do vec::from_fn(num_params) |i| {\n-                ty::mk_param(tcx, i, ast::def_id {crate: 0, node: 0})\n-            };\n-            // Merge the two substitions together now.\n-            let first_subst = ty::substs {tps: trait_ref.substs.tps + id_subst,\n-                                          .. trait_ref.substs};\n+            let trait_ref = ty::impl_trait_ref(tcx, source.impl_id)\n+                .expect(\"could not find trait_ref for impl with \\\n+                         default methods\");\n+            let method = ty::method(tcx, source.method_id);\n \n-            // And compose them.\n+            // Compute the first substitution\n+            let first_subst = make_substs_for_receiver_types(\n+                tcx, source.impl_id, trait_ref, method);\n+\n+            // And compose them\n             let new_substs = first_subst.subst(tcx, &substs);\n             debug!(\"trans_fn_with_vtables - default method: \\\n-                    substs = %s, id_subst = %s, trait_subst = %s, \\\n+                    substs = %s, trait_subst = %s, \\\n                     first_subst = %s, new_subst = %s\",\n-                   substs.repr(tcx),\n-                   id_subst.repr(tcx), trait_ref.substs.repr(tcx),\n+                   substs.repr(tcx), trait_ref.substs.repr(tcx),\n                    first_subst.repr(tcx), new_substs.repr(tcx));\n \n+\n             (source.method_id, Some(source.impl_id), new_substs)\n         }\n     };"}, {"sha": "00afece91979f6133b78908f505d3e29ba7be477", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75", "patch": "@@ -93,11 +93,16 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::def_id,\n         csearch::found(ast::ii_method(impl_did, mth)) => {\n           ccx.stats.n_inlines += 1;\n           ccx.external.insert(fn_id, Some(mth.id));\n-          let impl_tpt = ty::lookup_item_type(ccx.tcx, impl_did);\n-          let num_type_params =\n-              impl_tpt.generics.type_param_defs.len() +\n-              mth.generics.ty_params.len();\n-          if translate && num_type_params == 0 {\n+          // If this is a default method, we can't look up the\n+          // impl type. But we aren't going to translate anyways, so don't.\n+          if !translate { return local_def(mth.id); }\n+\n+            let impl_tpt = ty::lookup_item_type(ccx.tcx, impl_did);\n+            let num_type_params =\n+                impl_tpt.generics.type_param_defs.len() +\n+                mth.generics.ty_params.len();\n+\n+          if num_type_params == 0 {\n               let llfn = get_item_val(ccx, mth.id);\n               let path = vec::append(\n                   ty::item_path(ccx.tcx, impl_did),"}, {"sha": "bd79cb1cfeba645f37312a79c02489be9a965410", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 33, "deletions": 56, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75", "patch": "@@ -383,71 +383,48 @@ pub fn method_with_name_or_default(ccx: @mut CrateContext,\n                                    name: ast::ident) -> ast::def_id {\n     let imp = ccx.impl_method_cache.find_copy(&(impl_id, name));\n     match imp {\n-        Some(m) => m,\n-        None => {\n-            let imp = if impl_id.crate == ast::local_crate {\n-                match ccx.tcx.items.get_copy(&impl_id.node) {\n-                    ast_map::node_item(@ast::item {\n-                                       node: ast::item_impl(_, _, _, ref ms), _\n-                                       }, _) => {\n-                        let did = method_from_methods(*ms, name);\n-                        if did.is_some() {\n-                            did.get()\n-                        } else {\n-                            // Look for a default method\n-                            let pmm = ccx.tcx.provided_methods;\n-                            match pmm.find(&impl_id) {\n-                                Some(pmis) => {\n-                                    for pmis.each |pmi| {\n-                                        if pmi.method_info.ident == name {\n-                                            debug!(\"pmi.method_info.did = %?\", pmi.method_info.did);\n-                                            return pmi.method_info.did;\n-                                        }\n-                                    }\n-                                    fail!()\n-                                }\n-                                None => fail!()\n-                            }\n-                        }\n-                    }\n-                    _ => fail!(\"method_with_name\")\n-                }\n-            } else {\n-                csearch::get_impl_method(ccx.sess.cstore, impl_id, name)\n-            };\n+        Some(m) => return m,\n+        None => {}\n+    }\n \n-            ccx.impl_method_cache.insert((impl_id, name), imp);\n+    // None of this feels like it should be the best way to do this.\n+    let mut did = if impl_id.crate == ast::local_crate {\n+        match ccx.tcx.items.get_copy(&impl_id.node) {\n+            ast_map::node_item(@ast::item {\n+                node: ast::item_impl(_, _, _, ref ms), _\n+            }, _) => { method_from_methods(*ms, name) },\n+            _ => fail!(\"method_with_name\")\n+        }\n+    } else {\n+        csearch::get_impl_method(ccx.sess.cstore, impl_id, name)\n+    };\n \n-            imp\n+    if did.is_none() {\n+        // Look for a default method\n+        let pmm = ccx.tcx.provided_methods;\n+        match pmm.find(&impl_id) {\n+            Some(pmis) => {\n+                for pmis.each |pmi| {\n+                    if pmi.method_info.ident == name {\n+                        debug!(\"pmi.method_info.did = %?\",\n+                               pmi.method_info.did);\n+                        did = Some(pmi.method_info.did);\n+                    }\n+                }\n+            }\n+            None => {}\n         }\n     }\n+\n+    let imp = did.expect(\"could not find method while translating\");\n+    ccx.impl_method_cache.insert((impl_id, name), imp);\n+    imp\n }\n \n pub fn method_ty_param_count(ccx: &CrateContext, m_id: ast::def_id,\n                              i_id: ast::def_id) -> uint {\n     debug!(\"method_ty_param_count: m_id: %?, i_id: %?\", m_id, i_id);\n-    if m_id.crate == ast::local_crate {\n-        match ccx.tcx.items.find(&m_id.node) {\n-            Some(&ast_map::node_method(m, _, _)) => m.generics.ty_params.len(),\n-            None => {\n-                match ccx.tcx.provided_method_sources.find(&m_id) {\n-                    Some(source) => {\n-                        method_ty_param_count(\n-                            ccx, source.method_id, source.impl_id)\n-                    }\n-                    None => fail!()\n-                }\n-            }\n-            Some(&ast_map::node_trait_method(@ast::provided(@ref m),\n-                                            _, _)) => {\n-                m.generics.ty_params.len()\n-            }\n-            ref e => fail!(\"method_ty_param_count %?\", *e)\n-        }\n-    } else {\n-        csearch::get_type_param_count(ccx.sess.cstore, m_id) -\n-            csearch::get_type_param_count(ccx.sess.cstore, i_id)\n-    }\n+    ty::method(ccx.tcx, m_id).generics.type_param_defs.len()\n }\n \n pub fn trans_monomorphized_callee(bcx: block,"}, {"sha": "7fc1728a720bc0fcf5d42048b94317c9debb08af", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75", "patch": "@@ -541,6 +541,10 @@ impl<'self> LookupContext<'self> {\n         if !self.impl_dups.insert(impl_info.did) {\n             return; // already visited\n         }\n+        debug!(\"push_candidates_from_impl: %s %s %s\",\n+               self.m_name.repr(self.tcx()),\n+               impl_info.ident.repr(self.tcx()),\n+               impl_info.methods.map(|m| m.ident).repr(self.tcx()));\n \n         let idx = {\n             match impl_info.methods.position(|m| m.ident == self.m_name) {"}, {"sha": "d404ac39a15182bcd758670cb4db962c2459f902", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 80, "deletions": 83, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75", "patch": "@@ -279,7 +279,7 @@ impl CoherenceChecker {\n                    trait_ref.repr(self.crate_context.tcx),\n                    self.crate_context.tcx.sess.str_of(item.ident));\n \n-            self.instantiate_default_methods(item.id, trait_ref);\n+            self.instantiate_default_methods(local_def(item.id), trait_ref);\n \n             let implementation;\n             if implementation_opt.is_none() {\n@@ -327,13 +327,13 @@ impl CoherenceChecker {\n     // and trait pair. Then, for each provided method in the trait, inserts a\n     // `ProvidedMethodInfo` instance into the `provided_method_sources` map.\n     pub fn instantiate_default_methods(&self,\n-                                       impl_id: ast::node_id,\n+                                       impl_id: ast::def_id,\n                                        trait_ref: &ty::TraitRef) {\n         let tcx = self.crate_context.tcx;\n         debug!(\"instantiate_default_methods(impl_id=%?, trait_ref=%s)\",\n                impl_id, trait_ref.repr(tcx));\n \n-        let impl_poly_type = ty::lookup_item_type(tcx, local_def(impl_id));\n+        let impl_poly_type = ty::lookup_item_type(tcx, impl_id);\n \n         for self.each_provided_trait_method(trait_ref.def_id) |trait_method| {\n             // Synthesize an ID.\n@@ -375,7 +375,7 @@ impl CoherenceChecker {\n             // ID of the method.\n             let source = ProvidedMethodSource {\n                 method_id: trait_method.def_id,\n-                impl_id: local_def(impl_id)\n+                impl_id: impl_id\n             };\n \n             self.crate_context.tcx.provided_method_sources.insert(new_did,\n@@ -393,7 +393,7 @@ impl CoherenceChecker {\n                 };\n \n             let pmm = self.crate_context.tcx.provided_methods;\n-            match pmm.find(&local_def(impl_id)) {\n+            match pmm.find(&impl_id) {\n                 Some(&mis) => {\n                     // If the trait already has an entry in the\n                     // provided_methods_map, we just need to add this\n@@ -410,7 +410,7 @@ impl CoherenceChecker {\n                             for method `%s`\",\n                             self.crate_context.tcx.sess.str_of(\n                                 provided_method_info.method_info.ident));\n-                    pmm.insert(local_def(impl_id),\n+                    pmm.insert(impl_id,\n                                @mut ~[provided_method_info]);\n                 }\n             }\n@@ -733,10 +733,12 @@ impl CoherenceChecker {\n         }\n         // Default methods\n         for ty::provided_trait_methods(tcx, trait_did).each |ident| {\n+            debug!(\"inserting provided method %s\", ident.repr(tcx));\n             provided_names.insert(*ident);\n         }\n \n         for (*ty::trait_methods(tcx, trait_did)).each |method| {\n+            debug!(\"checking for %s\", method.ident.repr(tcx));\n             if provided_names.contains(&method.ident) { loop; }\n \n             tcx.sess.span_err(trait_ref_span,\n@@ -785,19 +787,41 @@ impl CoherenceChecker {\n         }\n     }\n \n-    // Converts an implementation in the AST to an Impl structure.\n-    pub fn create_impl_from_item(&self, item: @item) -> @Impl {\n-        fn add_provided_methods(all_methods: &mut ~[@MethodInfo],\n-                            all_provided_methods: &mut ~[@ProvidedMethodInfo],\n-                            sess: driver::session::Session) {\n-            for all_provided_methods.each |provided_method| {\n-                debug!(\n-                    \"(creating impl) adding provided method `%s` to impl\",\n-                    sess.str_of(provided_method.method_info.ident));\n-                vec::push(all_methods, provided_method.method_info);\n+    fn add_provided_methods_to_impl(\n+        &self,\n+        all_methods: &mut ~[@MethodInfo],\n+        trait_did: &ast::def_id,\n+        impl_id: &ast::def_id) {\n+\n+\n+        match self.crate_context.tcx\n+            .provided_methods\n+            .find(impl_id) {\n+                None => {\n+                    debug!(\"(creating impl) trait with node_id `%d` \\\n+                            has no provided methods\", trait_did.node);\n+                    /* fall through */\n+                }\n+                Some(&all_provided_methods) => {\n+                    debug!(\"(creating impl) trait with node_id `%d` \\\n+                            has provided methods\", trait_did.node);\n+                    // Add all provided methods.\n+                    for all_provided_methods.each |provided_method| {\n+                        debug!(\n+                            \"(creating impl) adding provided method \\\n+                             `%s` to impl\",\n+                            provided_method.method_info\n+                            .ident.repr(self.crate_context.tcx));\n+                        vec::push(all_methods, provided_method.method_info);\n+                    }\n+                }\n             }\n-        }\n \n+\n+    }\n+\n+    // Converts an implementation in the AST to an Impl structure.\n+    pub fn create_impl_from_item(&self, item: @item) -> @Impl {\n         match item.node {\n             item_impl(_, ref trait_refs, _, ref ast_methods) => {\n                 let mut methods = ~[];\n@@ -820,27 +844,11 @@ impl CoherenceChecker {\n                 // if a method of that name is not inherent to the\n                 // impl, use the provided definition in the trait.\n                 for trait_refs.iter().advance |trait_ref| {\n-                    let trait_did =\n-                        self.trait_ref_to_trait_def_id(*trait_ref);\n-\n-                    match self.crate_context.tcx\n-                              .provided_methods\n-                              .find(&local_def(item.id)) {\n-                        None => {\n-                            debug!(\"(creating impl) trait with node_id `%d` \\\n-                                    has no provided methods\", trait_did.node);\n-                            /* fall through */\n-                        }\n-                        Some(&all_provided) => {\n-                            debug!(\"(creating impl) trait with node_id `%d` \\\n-                                    has provided methods\", trait_did.node);\n-                            // Add all provided methods.\n-                            add_provided_methods(\n-                                &mut methods,\n-                                all_provided,\n-                                self.crate_context.tcx.sess);\n-                        }\n-                    }\n+                    let trait_did = self.trait_ref_to_trait_def_id(*trait_ref);\n+                    self.add_provided_methods_to_impl(\n+                        &mut methods,\n+                        &trait_did,\n+                        &local_def(item.id));\n                 }\n \n                 return @Impl {\n@@ -917,9 +925,23 @@ impl CoherenceChecker {\n                 }\n             }\n \n+            let mut implementation = *implementation;\n+\n             // Record all the trait methods.\n             for associated_traits.iter().advance |trait_ref| {\n-                self.add_trait_method(trait_ref.def_id, *implementation);\n+                self.instantiate_default_methods(implementation.did,\n+                                                 &**trait_ref);\n+                // Could we avoid these copies when we don't need them?\n+                let mut methods = /*bad?*/ copy implementation.methods;\n+                self.add_provided_methods_to_impl(\n+                    &mut methods,\n+                    &trait_ref.def_id,\n+                    &implementation.did);\n+                implementation = @Impl { methods: methods,\n+                                        .. *implementation };\n+\n+\n+                self.add_trait_method(trait_ref.def_id, implementation);\n             }\n \n             // Add the implementation to the mapping from\n@@ -937,7 +959,7 @@ impl CoherenceChecker {\n                     // `impl Trait for Type`:\n                     if associated_traits.is_none() {\n                         self.add_inherent_method(base_type_def_id,\n-                                                 *implementation);\n+                                                 implementation);\n                     }\n \n                     self.base_type_def_ids.insert(implementation.did,\n@@ -947,38 +969,6 @@ impl CoherenceChecker {\n         }\n     }\n \n-    pub fn add_default_methods_for_external_trait(&self,\n-                                                  trait_def_id: ast::def_id) {\n-        let tcx = self.crate_context.tcx;\n-        let pmm = tcx.provided_methods;\n-\n-        if pmm.contains_key(&trait_def_id) { return; }\n-\n-        debug!(\"(adding default methods for trait) processing trait\");\n-\n-        for csearch::get_provided_trait_methods(tcx, trait_def_id).each\n-                                                |trait_method_info| {\n-            debug!(\"(adding default methods for trait) found default method\");\n-\n-            // Create a new def ID for this provided method.\n-            let parse_sess = &self.crate_context.tcx.sess.parse_sess;\n-            let new_did = local_def(parse::next_node_id(*parse_sess));\n-\n-            let provided_method_info =\n-                @ProvidedMethodInfo {\n-                    method_info: @MethodInfo {\n-                        did: new_did,\n-                        n_tps: trait_method_info.ty.generics.type_param_defs.len(),\n-                        ident: trait_method_info.ty.ident,\n-                        explicit_self: trait_method_info.ty.explicit_self\n-                    },\n-                    trait_method_def_id: trait_method_info.def_id\n-                };\n-\n-            pmm.insert(trait_def_id, @mut ~[provided_method_info]);\n-        }\n-    }\n-\n     // Adds implementations and traits from external crates to the coherence\n     // info.\n     pub fn add_external_crates(&self) {\n@@ -998,9 +988,6 @@ impl CoherenceChecker {\n                                                   crate_store,\n                                                   def_id);\n                     }\n-                    dl_def(def_trait(def_id)) => {\n-                        self.add_default_methods_for_external_trait(def_id);\n-                    }\n                     dl_def(_) | dl_impl(_) | dl_field => {\n                         // Skip this.\n                         loop;\n@@ -1063,12 +1050,11 @@ impl CoherenceChecker {\n     }\n }\n \n-fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n-                                     impl_id: ast::node_id,\n-                                     trait_ref: &ty::TraitRef,\n-                                     new_def_id: ast::def_id,\n-                                     method: &ty::Method)\n-                                     -> ty::Method {\n+pub fn make_substs_for_receiver_types(tcx: ty::ctxt,\n+                                      impl_id: ast::def_id,\n+                                      trait_ref: &ty::TraitRef,\n+                                      method: &ty::Method)\n+                                      -> ty::substs {\n     /*!\n      * Substitutes the values for the receiver's type parameters\n      * that are found in method, leaving the method's type parameters\n@@ -1079,7 +1065,7 @@ fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n \n     // determine how many type parameters were declared on the impl\n     let num_impl_type_parameters = {\n-        let impl_polytype = ty::lookup_item_type(tcx, local_def(impl_id));\n+        let impl_polytype = ty::lookup_item_type(tcx, impl_id);\n         impl_polytype.generics.type_param_defs.len()\n     };\n \n@@ -1105,11 +1091,22 @@ fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n         }\n     });\n \n-    let combined_substs = ty::substs {\n+    return ty::substs {\n         self_r: trait_ref.substs.self_r,\n         self_ty: trait_ref.substs.self_ty,\n         tps: combined_tps\n     };\n+}\n+\n+fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n+                                     impl_id: ast::def_id,\n+                                     trait_ref: &ty::TraitRef,\n+                                     new_def_id: ast::def_id,\n+                                     method: &ty::Method)\n+                                     -> ty::Method {\n+\n+    let combined_substs = make_substs_for_receiver_types(\n+        tcx, impl_id, trait_ref, method);\n \n     ty::Method::new(\n         method.ident,"}, {"sha": "5ee243179df8b55d70b040a89230b8bbcea9fd66", "filename": "src/test/auxiliary/trait_default_method_xc_aux.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs?ref=1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75", "patch": "@@ -0,0 +1,34 @@\n+#[allow(default_methods)];\n+\n+pub trait A {\n+    fn f(&self) -> int;\n+    fn g(&self) -> int { 10 }\n+    fn h(&self) -> int { 10 }\n+}\n+\n+\n+impl A for int {\n+    fn f(&self) -> int { 10 }\n+}\n+\n+trait B<T> {\n+    fn thing<U>(&self, x: T, y: U) -> (T, U) { (x, y) }\n+}\n+\n+impl<T> B<T> for int { }\n+impl B<float> for bool { }\n+\n+\n+\n+pub trait TestEquality {\n+    fn test_eq(&self, rhs: &Self) -> bool;\n+    fn test_neq(&self, rhs: &Self) -> bool {\n+        !self.test_eq(rhs)\n+    }\n+}\n+\n+impl TestEquality for int {\n+    fn test_eq(&self, rhs: &int) -> bool {\n+        *self == *rhs\n+    }\n+}"}, {"sha": "9dbbcee0f770777468a208769808eede8f6f65f0", "filename": "src/test/run-pass/trait-default-method-bound-subst.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-bound-subst.rs?ref=1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75", "patch": "@@ -15,11 +15,13 @@ trait A<T> {\n }\n \n impl A<int> for int { }\n+impl<T> A<T> for uint { }\n \n fn f<T, U, V: A<T>>(i: V, j: T, k: U) -> (T, U) {\n     i.g(j, k)\n }\n \n pub fn main () {\n     assert_eq!(f(0, 1, 2), (1, 2));\n+    assert_eq!(f(0u, 1, 2), (1, 2));\n }"}, {"sha": "e6e5b8605a1616350d1cfca468bac0d419052b46", "filename": "src/test/run-pass/trait-default-method-xc.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs?ref=1a8969f64be0a7e7a2cd61f04d6c4d94abe35c75", "patch": "@@ -0,0 +1,71 @@\n+// xfail-fast\n+// aux-build:trait_default_method_xc_aux.rs\n+\n+#[allow(default_methods)];\n+\n+extern mod aux(name = \"trait_default_method_xc_aux\");\n+use aux::{A, B, TestEquality};\n+\n+\n+fn f<T: aux::A>(i: T) {\n+    assert_eq!(i.g(), 10);\n+}\n+\n+\n+pub struct thing { x: int }\n+impl A for thing {\n+    fn f(&self) -> int { 10 }\n+}\n+\n+fn g<T, U, V: B<T>>(i: V, j: T, k: U) -> (T, U) {\n+    i.thing(j, k)\n+}\n+\n+fn eq<T: TestEquality>(lhs: &T, rhs: &T) -> bool {\n+    lhs.test_eq(rhs)\n+}\n+fn neq<T: TestEquality>(lhs: &T, rhs: &T) -> bool {\n+    lhs.test_neq(rhs)\n+}\n+\n+\n+impl TestEquality for thing {\n+    fn test_eq(&self, rhs: &thing) -> bool {\n+        //self.x.test_eq(&rhs.x)\n+        eq(&self.x, &rhs.x)\n+    }\n+}\n+\n+\n+fn main () {\n+    // Some tests of random things\n+    f(0);\n+\n+    let a = thing { x: 0 };\n+    let b = thing { x: 1 };\n+\n+    assert_eq!(0i.g(), 10);\n+    assert_eq!(a.g(), 10);\n+    assert_eq!(a.h(), 10);\n+\n+\n+    assert_eq!(0i.thing(3.14, 1), (3.14, 1));\n+\n+    assert_eq!(g(0i, 3.14, 1), (3.14, 1));\n+    assert_eq!(g(false, 3.14, 1), (3.14, 1));\n+\n+    let obj = @0i as @A;\n+    assert_eq!(obj.h(), 10);\n+\n+\n+    // Trying out a real one\n+    assert!(12.test_neq(&10));\n+    assert!(!10.test_neq(&10));\n+    assert!(a.test_neq(&b));\n+    assert!(!a.test_neq(&a));\n+\n+    assert!(neq(&12, &10));\n+    assert!(!neq(&10, &10));\n+    assert!(neq(&a, &b));\n+    assert!(!neq(&a, &a));\n+}"}]}