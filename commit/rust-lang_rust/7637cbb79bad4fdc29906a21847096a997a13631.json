{"sha": "7637cbb79bad4fdc29906a21847096a997a13631", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2MzdjYmI3OWJhZDRmZGMyOTkwNmEyMTg0NzA5NmE5OTdhMTM2MzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-03T03:37:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-03T03:37:33Z"}, "message": "Auto merge of #75055 - cjgillot:clean-cache, r=oli-obk\n\nIntroduce an abstraction for EvaluationCache and SelectionCache\n\nThe small duplicated code has been moved to librustc_query_system.\n\nThe remaining changes are some cleanups of structural impls.", "tree": {"sha": "020935e9fc59a2e819e022bc4a7f9583cfd0e4fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/020935e9fc59a2e819e022bc4a7f9583cfd0e4fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7637cbb79bad4fdc29906a21847096a997a13631", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7637cbb79bad4fdc29906a21847096a997a13631", "html_url": "https://github.com/rust-lang/rust/commit/7637cbb79bad4fdc29906a21847096a997a13631", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7637cbb79bad4fdc29906a21847096a997a13631/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8244b1b11488a336a485f07fd6550b973009a931", "url": "https://api.github.com/repos/rust-lang/rust/commits/8244b1b11488a336a485f07fd6550b973009a931", "html_url": "https://github.com/rust-lang/rust/commit/8244b1b11488a336a485f07fd6550b973009a931"}, {"sha": "058e02145786ce50c86dd590d792271839907642", "url": "https://api.github.com/repos/rust-lang/rust/commits/058e02145786ce50c86dd590d792271839907642", "html_url": "https://github.com/rust-lang/rust/commit/058e02145786ce50c86dd590d792271839907642"}], "stats": {"total": 512, "additions": 145, "deletions": 367}, "files": [{"sha": "c904cd83a78bc2b0437ae557826858bebd173ee0", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7637cbb79bad4fdc29906a21847096a997a13631/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7637cbb79bad4fdc29906a21847096a997a13631/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=7637cbb79bad4fdc29906a21847096a997a13631", "patch": "@@ -27,7 +27,7 @@ pub enum ErrorHandled {\n     TooGeneric,\n }\n \n-CloneTypeFoldableImpls! {\n+CloneTypeFoldableAndLiftImpls! {\n     ErrorHandled,\n }\n "}, {"sha": "585f29386a8e0e15c06f2595c2213dd72829c9a3", "filename": "src/librustc_middle/traits/mod.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7637cbb79bad4fdc29906a21847096a997a13631/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7637cbb79bad4fdc29906a21847096a997a13631/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fmod.rs?ref=7637cbb79bad4fdc29906a21847096a997a13631", "patch": "@@ -30,7 +30,6 @@ pub type ChalkCanonicalGoal<'tcx> = Canonical<'tcx, ChalkEnvironmentAndGoal<'tcx\n \n pub use self::ImplSource::*;\n pub use self::ObligationCauseCode::*;\n-pub use self::SelectionError::*;\n \n pub use self::chalk::{\n     ChalkEnvironmentAndGoal, ChalkEnvironmentClause, RustInterner as ChalkRustInterner,\n@@ -86,7 +85,7 @@ pub enum Reveal {\n ///\n /// We do not want to intern this as there are a lot of obligation causes which\n /// only live for a short period of time.\n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash, Lift)]\n pub struct ObligationCause<'tcx> {\n     /// `None` for `ObligationCause::dummy`, `Some` otherwise.\n     data: Option<Rc<ObligationCauseData<'tcx>>>,\n@@ -111,7 +110,7 @@ impl Deref for ObligationCause<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct ObligationCauseData<'tcx> {\n     pub span: Span,\n \n@@ -169,14 +168,14 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct UnifyReceiverContext<'tcx> {\n     pub assoc_item: ty::AssocItem,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub substs: SubstsRef<'tcx>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from the span.\n     MiscObligation,\n@@ -343,7 +342,7 @@ impl ObligationCauseCode<'_> {\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(ObligationCauseCode<'_>, 32);\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct MatchExpressionArmCause<'tcx> {\n     pub arm_span: Span,\n     pub source: hir::MatchSource,\n@@ -359,7 +358,7 @@ pub struct IfExpressionCause {\n     pub semicolon: Option<Span>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct DerivedObligationCause<'tcx> {\n     /// The trait reference of the parent obligation that led to the\n     /// current obligation. Note that only trait obligations lead to\n@@ -371,7 +370,7 @@ pub struct DerivedObligationCause<'tcx> {\n     pub parent_code: Rc<ObligationCauseCode<'tcx>>,\n }\n \n-#[derive(Clone, Debug, TypeFoldable)]\n+#[derive(Clone, Debug, TypeFoldable, Lift)]\n pub enum SelectionError<'tcx> {\n     Unimplemented,\n     OutputTypeParameterMismatch(\n@@ -427,7 +426,7 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// ### The type parameter `N`\n ///\n /// See explanation on `ImplSourceUserDefinedData`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub enum ImplSource<'tcx, N> {\n     /// ImplSource identifying a particular impl.\n     ImplSourceUserDefined(ImplSourceUserDefinedData<'tcx, N>),\n@@ -558,14 +557,14 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n /// is `Obligation`, as one might expect. During codegen, however, this\n /// is `()`, because codegen only requires a shallow resolution of an\n /// impl, and nested obligations are satisfied later.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceUserDefinedData<'tcx, N> {\n     pub impl_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceGeneratorData<'tcx, N> {\n     pub generator_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -574,7 +573,7 @@ pub struct ImplSourceGeneratorData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceClosureData<'tcx, N> {\n     pub closure_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -583,18 +582,18 @@ pub struct ImplSourceClosureData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceAutoImplData<N> {\n     pub trait_def_id: DefId,\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceBuiltinData<N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceObjectData<'tcx, N> {\n     /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n     pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -607,17 +606,17 @@ pub struct ImplSourceObjectData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceFnPointerData<'tcx, N> {\n     pub fn_ty: Ty<'tcx>,\n     pub nested: Vec<N>,\n }\n \n // FIXME(@lcnr): This should be  refactored and merged with other builtin vtables.\n-#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ImplSourceDiscriminantKindData;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceTraitAliasData<'tcx, N> {\n     pub alias_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,"}, {"sha": "6ad514c6be21b93dd79c3ef546ae2636ed980096", "filename": "src/librustc_middle/traits/select.rs", "status": "modified", "additions": 8, "deletions": 91, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/7637cbb79bad4fdc29906a21847096a997a13631/src%2Flibrustc_middle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7637cbb79bad4fdc29906a21847096a997a13631/src%2Flibrustc_middle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fselect.rs?ref=7637cbb79bad4fdc29906a21847096a997a13631", "patch": "@@ -6,29 +6,18 @@ use self::EvaluationResult::*;\n \n use super::{SelectionError, SelectionResult};\n \n-use crate::dep_graph::DepNodeIndex;\n-use crate::ty::{self, TyCtxt};\n+use crate::ty;\n \n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lock;\n use rustc_hir::def_id::DefId;\n+use rustc_query_system::cache::Cache;\n \n-#[derive(Clone, Default)]\n-pub struct SelectionCache<'tcx> {\n-    pub hashmap: Lock<\n-        FxHashMap<\n-            ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>,\n-            WithDepNode<SelectionResult<'tcx, SelectionCandidate<'tcx>>>,\n-        >,\n-    >,\n-}\n+pub type SelectionCache<'tcx> = Cache<\n+    ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>,\n+    SelectionResult<'tcx, SelectionCandidate<'tcx>>,\n+>;\n \n-impl<'tcx> SelectionCache<'tcx> {\n-    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n-    pub fn clear(&self) {\n-        *self.hashmap.borrow_mut() = Default::default();\n-    }\n-}\n+pub type EvaluationCache<'tcx> =\n+    Cache<ty::ParamEnvAnd<'tcx, ty::PolyTraitRef<'tcx>>, EvaluationResult>;\n \n /// The selection process begins by considering all impls, where\n /// clauses, and so forth that might resolve an obligation. Sometimes\n@@ -264,75 +253,3 @@ impl<'tcx> From<OverflowError> for SelectionError<'tcx> {\n         SelectionError::Overflow\n     }\n }\n-\n-#[derive(Clone, Default)]\n-pub struct EvaluationCache<'tcx> {\n-    pub hashmap: Lock<\n-        FxHashMap<ty::ParamEnvAnd<'tcx, ty::PolyTraitRef<'tcx>>, WithDepNode<EvaluationResult>>,\n-    >,\n-}\n-\n-impl<'tcx> EvaluationCache<'tcx> {\n-    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n-    pub fn clear(&self) {\n-        *self.hashmap.borrow_mut() = Default::default();\n-    }\n-}\n-\n-#[derive(Clone, Eq, PartialEq)]\n-pub struct WithDepNode<T> {\n-    dep_node: DepNodeIndex,\n-    cached_value: T,\n-}\n-\n-impl<T: Clone> WithDepNode<T> {\n-    pub fn new(dep_node: DepNodeIndex, cached_value: T) -> Self {\n-        WithDepNode { dep_node, cached_value }\n-    }\n-\n-    pub fn get(&self, tcx: TyCtxt<'_>) -> T {\n-        tcx.dep_graph.read_index(self.dep_node);\n-        self.cached_value.clone()\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-pub enum IntercrateAmbiguityCause {\n-    DownstreamCrate { trait_desc: String, self_desc: Option<String> },\n-    UpstreamCrateUpdate { trait_desc: String, self_desc: Option<String> },\n-    ReservationImpl { message: String },\n-}\n-\n-impl IntercrateAmbiguityCause {\n-    /// Emits notes when the overlap is caused by complex intercrate ambiguities.\n-    /// See #23980 for details.\n-    pub fn add_intercrate_ambiguity_hint(&self, err: &mut rustc_errors::DiagnosticBuilder<'_>) {\n-        err.note(&self.intercrate_ambiguity_hint());\n-    }\n-\n-    pub fn intercrate_ambiguity_hint(&self) -> String {\n-        match self {\n-            &IntercrateAmbiguityCause::DownstreamCrate { ref trait_desc, ref self_desc } => {\n-                let self_desc = if let &Some(ref ty) = self_desc {\n-                    format!(\" for type `{}`\", ty)\n-                } else {\n-                    String::new()\n-                };\n-                format!(\"downstream crates may implement trait `{}`{}\", trait_desc, self_desc)\n-            }\n-            &IntercrateAmbiguityCause::UpstreamCrateUpdate { ref trait_desc, ref self_desc } => {\n-                let self_desc = if let &Some(ref ty) = self_desc {\n-                    format!(\" for type `{}`\", ty)\n-                } else {\n-                    String::new()\n-                };\n-                format!(\n-                    \"upstream crates may add a new impl of trait `{}`{} \\\n-                     in future versions\",\n-                    trait_desc, self_desc\n-                )\n-            }\n-            &IntercrateAmbiguityCause::ReservationImpl { ref message } => message.clone(),\n-        }\n-    }\n-}"}, {"sha": "d73fc628ceb70af2ddfef6740c4ea6b7878e980a", "filename": "src/librustc_middle/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 220, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/7637cbb79bad4fdc29906a21847096a997a13631/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7637cbb79bad4fdc29906a21847096a997a13631/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs?ref=7637cbb79bad4fdc29906a21847096a997a13631", "patch": "@@ -1,8 +1,6 @@\n use crate::traits;\n-use crate::ty::{Lift, TyCtxt};\n \n use std::fmt;\n-use std::rc::Rc;\n \n // Structural impls for the structs in `traits`.\n \n@@ -107,222 +105,7 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitAliasData<'tcx,\n ///////////////////////////////////////////////////////////////////////////\n // Lift implementations\n \n-impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n-    type Lifted = traits::SelectionError<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            super::Unimplemented => Some(super::Unimplemented),\n-            super::OutputTypeParameterMismatch(a, b, ref err) => {\n-                tcx.lift(&(a, b)).and_then(|(a, b)| {\n-                    tcx.lift(err).map(|err| super::OutputTypeParameterMismatch(a, b, err))\n-                })\n-            }\n-            super::TraitNotObjectSafe(def_id) => Some(super::TraitNotObjectSafe(def_id)),\n-            super::ConstEvalFailure(err) => Some(super::ConstEvalFailure(err)),\n-            super::Overflow => Some(super::Overflow),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n-    type Lifted = traits::ObligationCauseCode<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            super::ReturnNoExpression => Some(super::ReturnNoExpression),\n-            super::MiscObligation => Some(super::MiscObligation),\n-            super::SliceOrArrayElem => Some(super::SliceOrArrayElem),\n-            super::TupleElem => Some(super::TupleElem),\n-            super::ProjectionWf(proj) => tcx.lift(&proj).map(super::ProjectionWf),\n-            super::ItemObligation(def_id) => Some(super::ItemObligation(def_id)),\n-            super::BindingObligation(def_id, span) => Some(super::BindingObligation(def_id, span)),\n-            super::ReferenceOutlivesReferent(ty) => {\n-                tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n-            }\n-            super::ObjectTypeBound(ty, r) => {\n-                tcx.lift(&ty).and_then(|ty| tcx.lift(&r).map(|r| super::ObjectTypeBound(ty, r)))\n-            }\n-            super::ObjectCastObligation(ty) => tcx.lift(&ty).map(super::ObjectCastObligation),\n-            super::Coercion { source, target } => {\n-                Some(super::Coercion { source: tcx.lift(&source)?, target: tcx.lift(&target)? })\n-            }\n-            super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n-            super::TupleInitializerSized => Some(super::TupleInitializerSized),\n-            super::StructInitializerSized => Some(super::StructInitializerSized),\n-            super::VariableType(id) => Some(super::VariableType(id)),\n-            super::ReturnValue(id) => Some(super::ReturnValue(id)),\n-            super::ReturnType => Some(super::ReturnType),\n-            super::SizedArgumentType(sp) => Some(super::SizedArgumentType(sp)),\n-            super::SizedReturnType => Some(super::SizedReturnType),\n-            super::SizedYieldType => Some(super::SizedYieldType),\n-            super::InlineAsmSized => Some(super::InlineAsmSized),\n-            super::RepeatVec(suggest_flag) => Some(super::RepeatVec(suggest_flag)),\n-            super::FieldSized { adt_kind, span, last } => {\n-                Some(super::FieldSized { adt_kind, span, last })\n-            }\n-            super::ConstSized => Some(super::ConstSized),\n-            super::ConstPatternStructural => Some(super::ConstPatternStructural),\n-            super::SharedStatic => Some(super::SharedStatic),\n-            super::BuiltinDerivedObligation(ref cause) => {\n-                tcx.lift(cause).map(super::BuiltinDerivedObligation)\n-            }\n-            super::ImplDerivedObligation(ref cause) => {\n-                tcx.lift(cause).map(super::ImplDerivedObligation)\n-            }\n-            super::DerivedObligation(ref cause) => tcx.lift(cause).map(super::DerivedObligation),\n-            super::CompareImplConstObligation => Some(super::CompareImplConstObligation),\n-            super::CompareImplMethodObligation {\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            } => Some(super::CompareImplMethodObligation {\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            }),\n-            super::CompareImplTypeObligation { item_name, impl_item_def_id, trait_item_def_id } => {\n-                Some(super::CompareImplTypeObligation {\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                })\n-            }\n-            super::ExprAssignable => Some(super::ExprAssignable),\n-            super::MatchExpressionArm(box super::MatchExpressionArmCause {\n-                arm_span,\n-                source,\n-                ref prior_arms,\n-                last_ty,\n-                scrut_hir_id,\n-            }) => tcx.lift(&last_ty).map(|last_ty| {\n-                super::MatchExpressionArm(box super::MatchExpressionArmCause {\n-                    arm_span,\n-                    source,\n-                    prior_arms: prior_arms.clone(),\n-                    last_ty,\n-                    scrut_hir_id,\n-                })\n-            }),\n-            super::Pattern { span, root_ty, origin_expr } => {\n-                tcx.lift(&root_ty).map(|root_ty| super::Pattern { span, root_ty, origin_expr })\n-            }\n-            super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }) => {\n-                Some(super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }))\n-            }\n-            super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n-            super::MainFunctionType => Some(super::MainFunctionType),\n-            super::StartFunctionType => Some(super::StartFunctionType),\n-            super::IntrinsicType => Some(super::IntrinsicType),\n-            super::MethodReceiver => Some(super::MethodReceiver),\n-            super::UnifyReceiver(ref ctxt) => tcx.lift(ctxt).map(|ctxt| super::UnifyReceiver(ctxt)),\n-            super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n-            super::TrivialBound => Some(super::TrivialBound),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::UnifyReceiverContext<'a> {\n-    type Lifted = traits::UnifyReceiverContext<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.param_env).and_then(|param_env| {\n-            tcx.lift(&self.substs).map(|substs| traits::UnifyReceiverContext {\n-                assoc_item: self.assoc_item,\n-                param_env,\n-                substs,\n-            })\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n-    type Lifted = traits::DerivedObligationCause<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.parent_trait_ref).and_then(|trait_ref| {\n-            tcx.lift(&*self.parent_code).map(|code| traits::DerivedObligationCause {\n-                parent_trait_ref: trait_ref,\n-                parent_code: Rc::new(code),\n-            })\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n-    type Lifted = traits::ObligationCause<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.code).map(|code| traits::ObligationCause::new(self.span, self.body_id, code))\n-    }\n-}\n-\n-// For codegen only.\n-impl<'a, 'tcx> Lift<'tcx> for traits::ImplSource<'a, ()> {\n-    type Lifted = traits::ImplSource<'tcx, ()>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self.clone() {\n-            traits::ImplSourceUserDefined(traits::ImplSourceUserDefinedData {\n-                impl_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::ImplSourceUserDefined(traits::ImplSourceUserDefinedData {\n-                    impl_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            }),\n-            traits::ImplSourceAutoImpl(t) => Some(traits::ImplSourceAutoImpl(t)),\n-            traits::ImplSourceGenerator(traits::ImplSourceGeneratorData {\n-                generator_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::ImplSourceGenerator(traits::ImplSourceGeneratorData {\n-                    generator_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            }),\n-            traits::ImplSourceClosure(traits::ImplSourceClosureData {\n-                closure_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::ImplSourceClosure(traits::ImplSourceClosureData {\n-                    closure_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            }),\n-            traits::ImplSourceFnPointer(traits::ImplSourceFnPointerData { fn_ty, nested }) => {\n-                tcx.lift(&fn_ty).map(|fn_ty| {\n-                    traits::ImplSourceFnPointer(traits::ImplSourceFnPointerData { fn_ty, nested })\n-                })\n-            }\n-            traits::ImplSourceDiscriminantKind(traits::ImplSourceDiscriminantKindData) => {\n-                Some(traits::ImplSourceDiscriminantKind(traits::ImplSourceDiscriminantKindData))\n-            }\n-            traits::ImplSourceParam(n) => Some(traits::ImplSourceParam(n)),\n-            traits::ImplSourceBuiltin(n) => Some(traits::ImplSourceBuiltin(n)),\n-            traits::ImplSourceObject(traits::ImplSourceObjectData {\n-                upcast_trait_ref,\n-                vtable_base,\n-                nested,\n-            }) => tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n-                traits::ImplSourceObject(traits::ImplSourceObjectData {\n-                    upcast_trait_ref: trait_ref,\n-                    vtable_base,\n-                    nested,\n-                })\n-            }),\n-            traits::ImplSourceTraitAlias(traits::ImplSourceTraitAliasData {\n-                alias_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::ImplSourceTraitAlias(traits::ImplSourceTraitAliasData {\n-                    alias_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            }),\n-        }\n-    }\n+CloneTypeFoldableAndLiftImpls! {\n+    super::IfExpressionCause,\n+    super::ImplSourceDiscriminantKindData,\n }"}, {"sha": "dfa9e38a466ebe2151005687d798b6ab70483a31", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7637cbb79bad4fdc29906a21847096a997a13631/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7637cbb79bad4fdc29906a21847096a997a13631/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=7637cbb79bad4fdc29906a21847096a997a13631", "patch": "@@ -282,6 +282,7 @@ CloneTypeFoldableAndLiftImpls! {\n     ::rustc_hir::def::Res,\n     ::rustc_hir::def_id::DefId,\n     ::rustc_hir::def_id::LocalDefId,\n+    ::rustc_hir::HirId,\n     ::rustc_hir::LlvmInlineAsmInner,\n     ::rustc_hir::MatchSource,\n     ::rustc_hir::Mutability,\n@@ -298,6 +299,7 @@ CloneTypeFoldableAndLiftImpls! {\n     // really meant to be folded. In general, we can only fold a fully\n     // general `Region`.\n     crate::ty::BoundRegion,\n+    crate::ty::AssocItem,\n     crate::ty::Placeholder<crate::ty::BoundRegion>,\n     crate::ty::ClosureKind,\n     crate::ty::FreeRegion,"}, {"sha": "be3d3607728547c995dac174fdbb2b8c98db0921", "filename": "src/librustc_query_system/cache.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7637cbb79bad4fdc29906a21847096a997a13631/src%2Flibrustc_query_system%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7637cbb79bad4fdc29906a21847096a997a13631/src%2Flibrustc_query_system%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fcache.rs?ref=7637cbb79bad4fdc29906a21847096a997a13631", "patch": "@@ -0,0 +1,62 @@\n+//! Cache for candidate selection.\n+\n+use crate::dep_graph::DepNodeIndex;\n+use crate::query::QueryContext;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::HashMapExt;\n+use rustc_data_structures::sync::Lock;\n+\n+use std::hash::Hash;\n+\n+#[derive(Clone)]\n+pub struct Cache<Key, Value> {\n+    hashmap: Lock<FxHashMap<Key, WithDepNode<Value>>>,\n+}\n+\n+impl<Key, Value> Default for Cache<Key, Value> {\n+    fn default() -> Self {\n+        Self { hashmap: Default::default() }\n+    }\n+}\n+\n+impl<Key, Value> Cache<Key, Value> {\n+    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n+    pub fn clear(&self) {\n+        *self.hashmap.borrow_mut() = Default::default();\n+    }\n+}\n+\n+impl<Key: Eq + Hash, Value: Clone> Cache<Key, Value> {\n+    pub fn get<CTX: QueryContext>(&self, key: &Key, tcx: CTX) -> Option<Value> {\n+        Some(self.hashmap.borrow().get(key)?.get(tcx))\n+    }\n+\n+    pub fn insert(&self, key: Key, dep_node: DepNodeIndex, value: Value) {\n+        self.hashmap.borrow_mut().insert(key, WithDepNode::new(dep_node, value));\n+    }\n+\n+    pub fn insert_same(&self, key: Key, dep_node: DepNodeIndex, value: Value)\n+    where\n+        Value: Eq,\n+    {\n+        self.hashmap.borrow_mut().insert_same(key, WithDepNode::new(dep_node, value));\n+    }\n+}\n+\n+#[derive(Clone, Eq, PartialEq)]\n+pub struct WithDepNode<T> {\n+    dep_node: DepNodeIndex,\n+    cached_value: T,\n+}\n+\n+impl<T: Clone> WithDepNode<T> {\n+    pub fn new(dep_node: DepNodeIndex, cached_value: T) -> Self {\n+        WithDepNode { dep_node, cached_value }\n+    }\n+\n+    pub fn get<CTX: QueryContext>(&self, tcx: CTX) -> T {\n+        tcx.dep_graph().read_index(self.dep_node);\n+        self.cached_value.clone()\n+    }\n+}"}, {"sha": "4bbba7befe93f00363e03a8b458cca79f19f6e0d", "filename": "src/librustc_query_system/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7637cbb79bad4fdc29906a21847096a997a13631/src%2Flibrustc_query_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7637cbb79bad4fdc29906a21847096a997a13631/src%2Flibrustc_query_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Flib.rs?ref=7637cbb79bad4fdc29906a21847096a997a13631", "patch": "@@ -11,5 +11,6 @@ extern crate log;\n #[macro_use]\n extern crate rustc_data_structures;\n \n+pub mod cache;\n pub mod dep_graph;\n pub mod query;"}, {"sha": "75e11619924308ae39053483c9cd144d7ef3bd59", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 51, "deletions": 37, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7637cbb79bad4fdc29906a21847096a997a13631/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7637cbb79bad4fdc29906a21847096a997a13631/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=7637cbb79bad4fdc29906a21847096a997a13631", "patch": "@@ -51,6 +51,47 @@ pub use rustc_middle::traits::select::*;\n mod candidate_assembly;\n mod confirmation;\n \n+#[derive(Clone, Debug)]\n+pub enum IntercrateAmbiguityCause {\n+    DownstreamCrate { trait_desc: String, self_desc: Option<String> },\n+    UpstreamCrateUpdate { trait_desc: String, self_desc: Option<String> },\n+    ReservationImpl { message: String },\n+}\n+\n+impl IntercrateAmbiguityCause {\n+    /// Emits notes when the overlap is caused by complex intercrate ambiguities.\n+    /// See #23980 for details.\n+    pub fn add_intercrate_ambiguity_hint(&self, err: &mut rustc_errors::DiagnosticBuilder<'_>) {\n+        err.note(&self.intercrate_ambiguity_hint());\n+    }\n+\n+    pub fn intercrate_ambiguity_hint(&self) -> String {\n+        match self {\n+            &IntercrateAmbiguityCause::DownstreamCrate { ref trait_desc, ref self_desc } => {\n+                let self_desc = if let &Some(ref ty) = self_desc {\n+                    format!(\" for type `{}`\", ty)\n+                } else {\n+                    String::new()\n+                };\n+                format!(\"downstream crates may implement trait `{}`{}\", trait_desc, self_desc)\n+            }\n+            &IntercrateAmbiguityCause::UpstreamCrateUpdate { ref trait_desc, ref self_desc } => {\n+                let self_desc = if let &Some(ref ty) = self_desc {\n+                    format!(\" for type `{}`\", ty)\n+                } else {\n+                    String::new()\n+                };\n+                format!(\n+                    \"upstream crates may add a new impl of trait `{}`{} \\\n+                     in future versions\",\n+                    trait_desc, self_desc\n+                )\n+            }\n+            &IntercrateAmbiguityCause::ReservationImpl { ref message } => message.clone(),\n+        }\n+    }\n+}\n+\n pub struct SelectionContext<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n \n@@ -833,17 +874,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Option<EvaluationResult> {\n         let tcx = self.tcx();\n         if self.can_use_global_caches(param_env) {\n-            let cache = tcx.evaluation_cache.hashmap.borrow();\n-            if let Some(cached) = cache.get(&param_env.and(trait_ref)) {\n-                return Some(cached.get(tcx));\n+            if let Some(res) = tcx.evaluation_cache.get(&param_env.and(trait_ref), tcx) {\n+                return Some(res);\n             }\n         }\n-        self.infcx\n-            .evaluation_cache\n-            .hashmap\n-            .borrow()\n-            .get(&param_env.and(trait_ref))\n-            .map(|v| v.get(tcx))\n+        self.infcx.evaluation_cache.get(&param_env.and(trait_ref), tcx)\n     }\n \n     fn insert_evaluation_cache(\n@@ -869,21 +904,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // FIXME: Due to #50507 this overwrites the different values\n                 // This should be changed to use HashMapExt::insert_same\n                 // when that is fixed\n-                self.tcx()\n-                    .evaluation_cache\n-                    .hashmap\n-                    .borrow_mut()\n-                    .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, result));\n+                self.tcx().evaluation_cache.insert(param_env.and(trait_ref), dep_node, result);\n                 return;\n             }\n         }\n \n         debug!(\"insert_evaluation_cache(trait_ref={:?}, candidate={:?})\", trait_ref, result,);\n-        self.infcx\n-            .evaluation_cache\n-            .hashmap\n-            .borrow_mut()\n-            .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, result));\n+        self.infcx.evaluation_cache.insert(param_env.and(trait_ref), dep_node, result);\n     }\n \n     /// For various reasons, it's possible for a subobligation\n@@ -1180,17 +1207,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let tcx = self.tcx();\n         let trait_ref = &cache_fresh_trait_pred.skip_binder().trait_ref;\n         if self.can_use_global_caches(param_env) {\n-            let cache = tcx.selection_cache.hashmap.borrow();\n-            if let Some(cached) = cache.get(&param_env.and(*trait_ref)) {\n-                return Some(cached.get(tcx));\n+            if let Some(res) = tcx.selection_cache.get(&param_env.and(*trait_ref), tcx) {\n+                return Some(res);\n             }\n         }\n-        self.infcx\n-            .selection_cache\n-            .hashmap\n-            .borrow()\n-            .get(&param_env.and(*trait_ref))\n-            .map(|v| v.get(tcx))\n+        self.infcx.selection_cache.get(&param_env.and(*trait_ref), tcx)\n     }\n \n     /// Determines whether can we safely cache the result\n@@ -1248,10 +1269,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         trait_ref, candidate,\n                     );\n                     // This may overwrite the cache with the same value.\n-                    tcx.selection_cache\n-                        .hashmap\n-                        .borrow_mut()\n-                        .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, candidate));\n+                    tcx.selection_cache.insert(param_env.and(trait_ref), dep_node, candidate);\n                     return;\n                 }\n             }\n@@ -1261,11 +1279,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             \"insert_candidate_cache(trait_ref={:?}, candidate={:?}) local\",\n             trait_ref, candidate,\n         );\n-        self.infcx\n-            .selection_cache\n-            .hashmap\n-            .borrow_mut()\n-            .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, candidate));\n+        self.infcx.selection_cache.insert(param_env.and(trait_ref), dep_node, candidate);\n     }\n \n     fn match_projection_obligation_against_definition_bounds("}]}