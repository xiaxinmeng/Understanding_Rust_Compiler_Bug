{"sha": "de5ea80437fbeb5fe0c80547f53bc5a48bc129be", "node_id": "C_kwDOAAsO6NoAKGRlNWVhODA0MzdmYmViNWZlMGM4MDU0N2Y1M2JjNWE0OGJjMTI5YmU", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-12-03T21:55:59Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-12-03T22:05:42Z"}, "message": "Remove a Clean impl for a tuple (8)", "tree": {"sha": "c7a380a1d3e4e3b1ce0b1a06fa1606f65ccf0f0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7a380a1d3e4e3b1ce0b1a06fa1606f65ccf0f0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de5ea80437fbeb5fe0c80547f53bc5a48bc129be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de5ea80437fbeb5fe0c80547f53bc5a48bc129be", "html_url": "https://github.com/rust-lang/rust/commit/de5ea80437fbeb5fe0c80547f53bc5a48bc129be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de5ea80437fbeb5fe0c80547f53bc5a48bc129be/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38c6b13c3a1d390edd248d04ac40eb491b65cf92", "url": "https://api.github.com/repos/rust-lang/rust/commits/38c6b13c3a1d390edd248d04ac40eb491b65cf92", "html_url": "https://github.com/rust-lang/rust/commit/38c6b13c3a1d390edd248d04ac40eb491b65cf92"}], "stats": {"total": 175, "additions": 89, "deletions": 86}, "files": [{"sha": "bd2a69acfb07a1d6e62e0141446440bda6deaa38", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 89, "deletions": 86, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/de5ea80437fbeb5fe0c80547f53bc5a48bc129be/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de5ea80437fbeb5fe0c80547f53bc5a48bc129be/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=de5ea80437fbeb5fe0c80547f53bc5a48bc129be", "patch": "@@ -54,7 +54,11 @@ impl Clean<Item> for DocModule<'_> {\n         let mut items: Vec<Item> = vec![];\n         items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n-        items.extend(self.items.iter().map(|x| x.clean(cx)).flatten());\n+        items.extend(\n+            self.items\n+                .iter()\n+                .flat_map(|(item, renamed)| clean_maybe_renamed_item(cx, item, *renamed)),\n+        );\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n@@ -1726,94 +1730,93 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     }\n }\n \n-impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Vec<Item> {\n-        use hir::ItemKind;\n-\n-        let (item, renamed) = self;\n-        let def_id = item.def_id.to_def_id();\n-        let mut name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));\n-        cx.with_param_env(def_id, |cx| {\n-            let kind = match item.kind {\n-                ItemKind::Static(ty, mutability, body_id) => {\n-                    StaticItem(Static { type_: ty.clean(cx), mutability, expr: Some(body_id) })\n-                }\n-                ItemKind::Const(ty, body_id) => ConstantItem(Constant {\n-                    type_: ty.clean(cx),\n-                    kind: ConstantKind::Local { body: body_id, def_id },\n-                }),\n-                ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n-                    bounds: ty.bounds.iter().map(|x| x.clean(cx)).collect(),\n-                    generics: ty.generics.clean(cx),\n-                }),\n-                ItemKind::TyAlias(hir_ty, ref generics) => {\n-                    let rustdoc_ty = hir_ty.clean(cx);\n-                    let ty = hir_ty_to_ty(cx.tcx, hir_ty).clean(cx);\n-                    TypedefItem(\n-                        Typedef {\n-                            type_: rustdoc_ty,\n-                            generics: generics.clean(cx),\n-                            item_type: Some(ty),\n-                        },\n-                        false,\n-                    )\n-                }\n-                ItemKind::Enum(ref def, ref generics) => EnumItem(Enum {\n-                    variants: def.variants.iter().map(|v| v.clean(cx)).collect(),\n-                    generics: generics.clean(cx),\n-                    variants_stripped: false,\n-                }),\n-                ItemKind::TraitAlias(ref generics, bounds) => TraitAliasItem(TraitAlias {\n+fn clean_maybe_renamed_item(\n+    cx: &mut DocContext<'_>,\n+    item: &hir::Item<'_>,\n+    renamed: Option<Symbol>,\n+) -> Vec<Item> {\n+    use hir::ItemKind;\n+\n+    let def_id = item.def_id.to_def_id();\n+    let mut name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));\n+    cx.with_param_env(def_id, |cx| {\n+        let kind = match item.kind {\n+            ItemKind::Static(ty, mutability, body_id) => {\n+                StaticItem(Static { type_: ty.clean(cx), mutability, expr: Some(body_id) })\n+            }\n+            ItemKind::Const(ty, body_id) => ConstantItem(Constant {\n+                type_: ty.clean(cx),\n+                kind: ConstantKind::Local { body: body_id, def_id },\n+            }),\n+            ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n+                bounds: ty.bounds.iter().map(|x| x.clean(cx)).collect(),\n+                generics: ty.generics.clean(cx),\n+            }),\n+            ItemKind::TyAlias(hir_ty, ref generics) => {\n+                let rustdoc_ty = hir_ty.clean(cx);\n+                let ty = hir_ty_to_ty(cx.tcx, hir_ty).clean(cx);\n+                TypedefItem(\n+                    Typedef {\n+                        type_: rustdoc_ty,\n+                        generics: generics.clean(cx),\n+                        item_type: Some(ty),\n+                    },\n+                    false,\n+                )\n+            }\n+            ItemKind::Enum(ref def, ref generics) => EnumItem(Enum {\n+                variants: def.variants.iter().map(|v| v.clean(cx)).collect(),\n+                generics: generics.clean(cx),\n+                variants_stripped: false,\n+            }),\n+            ItemKind::TraitAlias(ref generics, bounds) => TraitAliasItem(TraitAlias {\n+                generics: generics.clean(cx),\n+                bounds: bounds.iter().map(|x| x.clean(cx)).collect(),\n+            }),\n+            ItemKind::Union(ref variant_data, ref generics) => UnionItem(Union {\n+                generics: generics.clean(cx),\n+                fields: variant_data.fields().iter().map(|x| x.clean(cx)).collect(),\n+                fields_stripped: false,\n+            }),\n+            ItemKind::Struct(ref variant_data, ref generics) => StructItem(Struct {\n+                struct_type: CtorKind::from_hir(variant_data),\n+                generics: generics.clean(cx),\n+                fields: variant_data.fields().iter().map(|x| x.clean(cx)).collect(),\n+                fields_stripped: false,\n+            }),\n+            ItemKind::Impl(ref impl_) => return clean_impl(impl_, item.hir_id(), cx),\n+            // proc macros can have a name set by attributes\n+            ItemKind::Fn(ref sig, ref generics, body_id) => {\n+                clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n+            }\n+            ItemKind::Macro(ref macro_def) => {\n+                let ty_vis = cx.tcx.visibility(def_id).clean(cx);\n+                MacroItem(Macro {\n+                    source: display_macro_source(cx, name, macro_def, def_id, ty_vis),\n+                })\n+            }\n+            ItemKind::Trait(is_auto, unsafety, ref generics, bounds, item_ids) => {\n+                let items =\n+                    item_ids.iter().map(|ti| cx.tcx.hir().trait_item(ti.id).clean(cx)).collect();\n+                TraitItem(Trait {\n+                    unsafety,\n+                    items,\n                     generics: generics.clean(cx),\n                     bounds: bounds.iter().map(|x| x.clean(cx)).collect(),\n-                }),\n-                ItemKind::Union(ref variant_data, ref generics) => UnionItem(Union {\n-                    generics: generics.clean(cx),\n-                    fields: variant_data.fields().iter().map(|x| x.clean(cx)).collect(),\n-                    fields_stripped: false,\n-                }),\n-                ItemKind::Struct(ref variant_data, ref generics) => StructItem(Struct {\n-                    struct_type: CtorKind::from_hir(variant_data),\n-                    generics: generics.clean(cx),\n-                    fields: variant_data.fields().iter().map(|x| x.clean(cx)).collect(),\n-                    fields_stripped: false,\n-                }),\n-                ItemKind::Impl(ref impl_) => return clean_impl(impl_, item.hir_id(), cx),\n-                // proc macros can have a name set by attributes\n-                ItemKind::Fn(ref sig, ref generics, body_id) => {\n-                    clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n-                }\n-                ItemKind::Macro(ref macro_def) => {\n-                    let ty_vis = cx.tcx.visibility(def_id).clean(cx);\n-                    MacroItem(Macro {\n-                        source: display_macro_source(cx, name, macro_def, def_id, ty_vis),\n-                    })\n-                }\n-                ItemKind::Trait(is_auto, unsafety, ref generics, bounds, item_ids) => {\n-                    let items = item_ids\n-                        .iter()\n-                        .map(|ti| cx.tcx.hir().trait_item(ti.id).clean(cx))\n-                        .collect();\n-                    TraitItem(Trait {\n-                        unsafety,\n-                        items,\n-                        generics: generics.clean(cx),\n-                        bounds: bounds.iter().map(|x| x.clean(cx)).collect(),\n-                        is_auto: is_auto.clean(cx),\n-                    })\n-                }\n-                ItemKind::ExternCrate(orig_name) => {\n-                    return clean_extern_crate(item, name, orig_name, cx);\n-                }\n-                ItemKind::Use(path, kind) => {\n-                    return clean_use_statement(item, name, path, kind, cx);\n-                }\n-                _ => unreachable!(\"not yet converted\"),\n-            };\n+                    is_auto: is_auto.clean(cx),\n+                })\n+            }\n+            ItemKind::ExternCrate(orig_name) => {\n+                return clean_extern_crate(item, name, orig_name, cx);\n+            }\n+            ItemKind::Use(path, kind) => {\n+                return clean_use_statement(item, name, path, kind, cx);\n+            }\n+            _ => unreachable!(\"not yet converted\"),\n+        };\n \n-            vec![Item::from_def_id_and_parts(def_id, Some(name), kind, cx)]\n-        })\n-    }\n+        vec![Item::from_def_id_and_parts(def_id, Some(name), kind, cx)]\n+    })\n }\n \n impl Clean<Item> for hir::Variant<'_> {"}]}