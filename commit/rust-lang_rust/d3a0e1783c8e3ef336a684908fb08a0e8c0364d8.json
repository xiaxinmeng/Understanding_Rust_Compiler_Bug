{"sha": "d3a0e1783c8e3ef336a684908fb08a0e8c0364d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYTBlMTc4M2M4ZTNlZjMzNmE2ODQ5MDhmYjA4YTBlOGMwMzY0ZDg=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-16T04:42:57Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-26T23:54:05Z"}, "message": "Move cfg_attr processing and stmt/expr attribute gated feature checking into `StripUnconfigured`", "tree": {"sha": "75ce61ffb45849ad00b5416c9a993852a5658d72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75ce61ffb45849ad00b5416c9a993852a5658d72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3a0e1783c8e3ef336a684908fb08a0e8c0364d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3a0e1783c8e3ef336a684908fb08a0e8c0364d8", "html_url": "https://github.com/rust-lang/rust/commit/d3a0e1783c8e3ef336a684908fb08a0e8c0364d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3a0e1783c8e3ef336a684908fb08a0e8c0364d8/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a306f85df9f75c35c88395be756dc09c73cab891", "url": "https://api.github.com/repos/rust-lang/rust/commits/a306f85df9f75c35c88395be756dc09c73cab891", "html_url": "https://github.com/rust-lang/rust/commit/a306f85df9f75c35c88395be756dc09c73cab891"}], "stats": {"total": 334, "additions": 86, "deletions": 248}, "files": [{"sha": "62c922a4dbfdf036fa9d76c7089029d4dcdb3022", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 86, "deletions": 248, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/d3a0e1783c8e3ef336a684908fb08a0e8c0364d8/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3a0e1783c8e3ef336a684908fb08a0e8c0364d8/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=d3a0e1783c8e3ef336a684908fb08a0e8c0364d8", "patch": "@@ -13,14 +13,14 @@ use errors::Handler;\n use feature_gate::GatedCfgAttr;\n use fold::Folder;\n use {ast, fold, attr};\n-use visit;\n use codemap::{Spanned, respan};\n use ptr::P;\n \n use util::small_vector::SmallVector;\n \n pub trait CfgFolder: fold::Folder {\n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T>;\n+    fn visit_stmt_or_expr_attrs(&mut self, _attrs: &[ast::Attribute]) {}\n     fn visit_unconfigurable_expr(&mut self, _expr: &ast::Expr) {}\n }\n \n@@ -31,14 +31,78 @@ pub struct StripUnconfigured<'a> {\n     config: &'a ast::CrateConfig,\n }\n \n-impl<'a> CfgFolder for StripUnconfigured<'a> {\n-    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n-        if in_cfg(self.config, node.attrs(), &mut self.diag) {\n-            Some(node)\n+impl<'a> StripUnconfigured<'a> {\n+    // Determine if an item should be translated in the current crate\n+    // configuration based on the item's attributes\n+    fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool {\n+        attrs.iter().all(|attr| {\n+            let mis = match attr.node.value.node {\n+                ast::MetaItemKind::List(_, ref mis) if is_cfg(&attr) => mis,\n+                _ => return true\n+            };\n+\n+            if mis.len() != 1 {\n+                self.diag.emit_error(|diagnostic| {\n+                    diagnostic.span_err(attr.span, \"expected 1 cfg-pattern\");\n+                });\n+                return true;\n+            }\n+\n+            attr::cfg_matches(self.config, &mis[0], &mut self.diag)\n+        })\n+    }\n+\n+    fn process_cfg_attrs(&mut self, attrs: Vec<ast::Attribute>) -> Vec<ast::Attribute> {\n+        attrs.into_iter().filter_map(|attr| self.process_cfg_attr(attr)).collect()\n+    }\n+\n+    fn process_cfg_attr(&mut self, attr: ast::Attribute) -> Option<ast::Attribute> {\n+        if !attr.check_name(\"cfg_attr\") {\n+            return Some(attr);\n+        }\n+\n+        let attr_list = match attr.meta_item_list() {\n+            Some(attr_list) => attr_list,\n+            None => {\n+                let msg = \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\";\n+                self.diag.diag.span_err(attr.span, msg);\n+                return None;\n+            }\n+        };\n+        let (cfg, mi) = match (attr_list.len(), attr_list.get(0), attr_list.get(1)) {\n+            (2, Some(cfg), Some(mi)) => (cfg, mi),\n+            _ => {\n+                let msg = \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\";\n+                self.diag.diag.span_err(attr.span, msg);\n+                return None;\n+            }\n+        };\n+\n+        if attr::cfg_matches(self.config, &cfg, &mut self.diag) {\n+            Some(respan(mi.span, ast::Attribute_ {\n+                id: attr::mk_attr_id(),\n+                style: attr.node.style,\n+                value: mi.clone(),\n+                is_sugared_doc: false,\n+            }))\n         } else {\n             None\n         }\n     }\n+}\n+\n+impl<'a> CfgFolder for StripUnconfigured<'a> {\n+    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n+        let node = node.map_attrs(|attrs| self.process_cfg_attrs(attrs));\n+        if self.in_cfg(node.attrs()) { Some(node) } else { None }\n+    }\n+\n+    fn visit_stmt_or_expr_attrs(&mut self, attrs: &[ast::Attribute]) {\n+        // flag the offending attributes\n+        for attr in attrs.iter() {\n+            self.diag.feature_gated_cfgs.push(GatedCfgAttr::GatedAttr(attr.span));\n+        }\n+    }\n \n     fn visit_unconfigurable_expr(&mut self, expr: &ast::Expr) {\n         if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a)) {\n@@ -54,11 +118,6 @@ pub fn strip_unconfigured_items(diagnostic: &Handler, krate: ast::Crate,\n                                 feature_gated_cfgs: &mut Vec<GatedCfgAttr>)\n                                 -> ast::Crate\n {\n-    // Need to do this check here because cfg runs before feature_gates\n-    check_for_gated_stmt_expr_attributes(&krate, feature_gated_cfgs);\n-\n-    let krate = process_cfg_attr(diagnostic, krate, feature_gated_cfgs);\n-\n     StripUnconfigured {\n         config: &krate.config.clone(),\n         diag: CfgDiagReal {\n@@ -72,7 +131,9 @@ impl<T: CfgFolder> fold::Folder for T {\n     fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n         ast::ForeignMod {\n             abi: foreign_mod.abi,\n-            items: foreign_mod.items.into_iter().filter_map(|item| self.configure(item)).collect(),\n+            items: foreign_mod.items.into_iter().filter_map(|item| {\n+                self.configure(item).map(|item| fold::noop_fold_foreign_item(item, self))\n+            }).collect(),\n         }\n     }\n \n@@ -126,6 +187,7 @@ impl<T: CfgFolder> fold::Folder for T {\n     }\n \n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n+        self.visit_stmt_or_expr_attrs(expr.attrs());\n         // If an expr is valid to cfg away it will have been removed by the\n         // outer stmt or expression folder before descending in here.\n         // Anything else is always required, and thus has to error out\n@@ -142,6 +204,19 @@ impl<T: CfgFolder> fold::Folder for T {\n     }\n \n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n+        let is_item = match stmt.node {\n+            ast::StmtKind::Decl(ref decl, _) => match decl.node {\n+                ast::DeclKind::Item(_) => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        };\n+\n+        // avoid calling `visit_stmt_or_expr_attrs` on items\n+        if !is_item {\n+            self.visit_stmt_or_expr_attrs(stmt.attrs());\n+        }\n+\n         self.configure(stmt).map(|stmt| fold::noop_fold_stmt(stmt, self))\n                             .unwrap_or(SmallVector::zero())\n     }\n@@ -178,205 +253,6 @@ fn is_cfg(attr: &ast::Attribute) -> bool {\n     attr.check_name(\"cfg\")\n }\n \n-// Determine if an item should be translated in the current crate\n-// configuration based on the item's attributes\n-fn in_cfg<T: CfgDiag>(cfg: &[P<ast::MetaItem>],\n-                      attrs: &[ast::Attribute],\n-                      diag: &mut T) -> bool {\n-    attrs.iter().all(|attr| {\n-        let mis = match attr.node.value.node {\n-            ast::MetaItemKind::List(_, ref mis) if is_cfg(&attr) => mis,\n-            _ => return true\n-        };\n-\n-        if mis.len() != 1 {\n-            diag.emit_error(|diagnostic| {\n-                diagnostic.span_err(attr.span, \"expected 1 cfg-pattern\");\n-            });\n-            return true;\n-        }\n-\n-        attr::cfg_matches(cfg, &mis[0], diag)\n-    })\n-}\n-\n-struct CfgAttrFolder<'a, T> {\n-    diag: T,\n-    config: &'a ast::CrateConfig,\n-}\n-\n-// Process `#[cfg_attr]`.\n-fn process_cfg_attr(diagnostic: &Handler, krate: ast::Crate,\n-                    feature_gated_cfgs: &mut Vec<GatedCfgAttr>) -> ast::Crate {\n-    let mut fld = CfgAttrFolder {\n-        diag: CfgDiagReal {\n-            diag: diagnostic,\n-            feature_gated_cfgs: feature_gated_cfgs,\n-        },\n-        config: &krate.config.clone(),\n-    };\n-    fld.fold_crate(krate)\n-}\n-\n-impl<'a, T: CfgDiag> fold::Folder for CfgAttrFolder<'a, T> {\n-    fn fold_attribute(&mut self, attr: ast::Attribute) -> Option<ast::Attribute> {\n-        if !attr.check_name(\"cfg_attr\") {\n-            return fold::noop_fold_attribute(attr, self);\n-        }\n-\n-        let attr_list = match attr.meta_item_list() {\n-            Some(attr_list) => attr_list,\n-            None => {\n-                self.diag.emit_error(|diag| {\n-                    diag.span_err(attr.span,\n-                        \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n-                });\n-                return None;\n-            }\n-        };\n-        let (cfg, mi) = match (attr_list.len(), attr_list.get(0), attr_list.get(1)) {\n-            (2, Some(cfg), Some(mi)) => (cfg, mi),\n-            _ => {\n-                self.diag.emit_error(|diag| {\n-                    diag.span_err(attr.span,\n-                        \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n-                });\n-                return None;\n-            }\n-        };\n-\n-        if attr::cfg_matches(&self.config[..], &cfg, &mut self.diag) {\n-            Some(respan(mi.span, ast::Attribute_ {\n-                id: attr::mk_attr_id(),\n-                style: attr.node.style,\n-                value: mi.clone(),\n-                is_sugared_doc: false,\n-            }))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    // Need the ability to run pre-expansion.\n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(mac, self)\n-    }\n-}\n-\n-fn check_for_gated_stmt_expr_attributes(krate: &ast::Crate,\n-                                        discovered: &mut Vec<GatedCfgAttr>) {\n-    let mut v = StmtExprAttrFeatureVisitor {\n-        config: &krate.config,\n-        discovered: discovered,\n-    };\n-    visit::walk_crate(&mut v, krate);\n-}\n-\n-/// To cover this feature, we need to discover all attributes\n-/// so we need to run before cfg.\n-struct StmtExprAttrFeatureVisitor<'a, 'b> {\n-    config: &'a ast::CrateConfig,\n-    discovered: &'b mut Vec<GatedCfgAttr>,\n-}\n-\n-// Runs the cfg_attr and cfg folders locally in \"silent\" mode\n-// to discover attribute use on stmts or expressions ahead of time\n-impl<'v, 'a, 'b> visit::Visitor<'v> for StmtExprAttrFeatureVisitor<'a, 'b> {\n-    fn visit_stmt(&mut self, s: &'v ast::Stmt) {\n-        // check if there even are any attributes on this node\n-        let stmt_attrs = s.node.attrs();\n-        if stmt_attrs.len() > 0 {\n-            // attributes on items are fine\n-            if let ast::StmtKind::Decl(ref decl, _) = s.node {\n-                if let ast::DeclKind::Item(_) = decl.node {\n-                    visit::walk_stmt(self, s);\n-                    return;\n-                }\n-            }\n-\n-            // flag the offending attributes\n-            for attr in stmt_attrs {\n-                self.discovered.push(GatedCfgAttr::GatedAttr(attr.span));\n-            }\n-\n-            // if the node does not end up being cfg-d away, walk down\n-            if node_survives_cfg(stmt_attrs, self.config) {\n-                visit::walk_stmt(self, s);\n-            }\n-        } else {\n-            visit::walk_stmt(self, s);\n-        }\n-    }\n-\n-    fn visit_expr(&mut self, ex: &'v ast::Expr) {\n-        // check if there even are any attributes on this node\n-        let expr_attrs = ex.attrs();\n-        if expr_attrs.len() > 0 {\n-\n-            // flag the offending attributes\n-            for attr in expr_attrs {\n-                self.discovered.push(GatedCfgAttr::GatedAttr(attr.span));\n-            }\n-\n-            // if the node does not end up being cfg-d away, walk down\n-            if node_survives_cfg(expr_attrs, self.config) {\n-                visit::walk_expr(self, ex);\n-            }\n-        } else {\n-            visit::walk_expr(self, ex);\n-        }\n-    }\n-\n-    fn visit_foreign_item(&mut self, i: &'v ast::ForeignItem) {\n-        if node_survives_cfg(&i.attrs, self.config) {\n-            visit::walk_foreign_item(self, i);\n-        }\n-    }\n-\n-    fn visit_item(&mut self, i: &'v ast::Item) {\n-        if node_survives_cfg(&i.attrs, self.config) {\n-            visit::walk_item(self, i);\n-        }\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n-        if node_survives_cfg(&ii.attrs, self.config) {\n-            visit::walk_impl_item(self, ii);\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'v ast::TraitItem) {\n-        if node_survives_cfg(&ti.attrs, self.config) {\n-            visit::walk_trait_item(self, ti);\n-        }\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &'v ast::StructField) {\n-        if node_survives_cfg(&s.attrs, self.config) {\n-            visit::walk_struct_field(self, s);\n-        }\n-    }\n-\n-    fn visit_variant(&mut self, v: &'v ast::Variant,\n-                     g: &'v ast::Generics, item_id: ast::NodeId) {\n-        if node_survives_cfg(&v.node.attrs, self.config) {\n-            visit::walk_variant(self, v, g, item_id);\n-        }\n-    }\n-\n-    fn visit_arm(&mut self, a: &'v ast::Arm) {\n-        if node_survives_cfg(&a.attrs, self.config) {\n-            visit::walk_arm(self, a);\n-        }\n-    }\n-\n-    // This visitor runs pre expansion, so we need to prevent\n-    // the default panic here\n-    fn visit_mac(&mut self, mac: &'v ast::Mac) {\n-        visit::walk_mac(self, mac)\n-    }\n-}\n-\n pub trait CfgDiag {\n     fn emit_error<F>(&mut self, f: F) where F: FnMut(&Handler);\n     fn flag_gated<F>(&mut self, f: F) where F: FnMut(&mut Vec<GatedCfgAttr>);\n@@ -395,41 +271,3 @@ impl<'a, 'b> CfgDiag for CfgDiagReal<'a, 'b> {\n         f(self.feature_gated_cfgs)\n     }\n }\n-\n-struct CfgDiagSilent {\n-    error: bool,\n-}\n-\n-impl CfgDiag for CfgDiagSilent {\n-    fn emit_error<F>(&mut self, _: F) where F: FnMut(&Handler) {\n-        self.error = true;\n-    }\n-    fn flag_gated<F>(&mut self, _: F) where F: FnMut(&mut Vec<GatedCfgAttr>) {}\n-}\n-\n-fn node_survives_cfg(attrs: &[ast::Attribute],\n-                     config: &ast::CrateConfig) -> bool {\n-    let mut survives_cfg = true;\n-\n-    for attr in attrs {\n-        let mut fld = CfgAttrFolder {\n-            diag: CfgDiagSilent { error: false },\n-            config: config,\n-        };\n-        let attr = fld.fold_attribute(attr.clone());\n-\n-        // In case of error we can just return true,\n-        // since the actual cfg folders will end compilation anyway.\n-\n-        if fld.diag.error { return true; }\n-\n-        survives_cfg &= attr.map(|attr| {\n-            let mut diag = CfgDiagSilent { error: false };\n-            let r = in_cfg(config, &[attr], &mut diag);\n-            if diag.error { return true; }\n-            r\n-        }).unwrap_or(true)\n-    }\n-\n-    survives_cfg\n-}"}]}