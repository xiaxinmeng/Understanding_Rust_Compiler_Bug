{"sha": "8a6518427e11e6dd13d6f39663b82eb4f810ca05", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNjUxODQyN2UxMWU2ZGQxM2Q2ZjM5NjYzYjgyZWI0ZjgxMGNhMDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-16T20:26:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-16T20:26:20Z"}, "message": "Auto merge of #81089 - m-ou-se:rollup-z7iac6i, r=m-ou-se\n\nRollup of 17 pull requests\n\nSuccessful merges:\n\n - #78455 (Introduce {Ref, RefMut}::try_map for optional projections in RefCell)\n - #80144 (Remove giant badge in README)\n - #80614 (Explain why borrows can't be held across yield point in async blocks)\n - #80670 (TrustedRandomAaccess specialization composes incorrectly for nested iter::Zips)\n - #80681 (Clarify what the effects of a 'logic error' are)\n - #80764 (Re-stabilize Weak::as_ptr and friends for unsized T)\n - #80901 (Make `x.py --color always` apply to logging too)\n - #80902 (Add a regression test for #76281)\n - #80941 (Do not suggest invalid code in pattern with loop)\n - #80968 (Stabilize the poll_map feature)\n - #80971 (Put all feature gate tests under `feature-gates/`)\n - #81021 (Remove doctree::Import)\n - #81040 (doctest: Reset errors before dropping the parse session)\n - #81060 (Add a regression test for #50041)\n - #81065 (codegen_cranelift: Fix redundant semicolon warn)\n - #81069 (Add sample code for Rc::new_cyclic)\n - #81081 (Add test for #34792)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b7487576e23b1c326ba764b9dff7231dc45ba671", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7487576e23b1c326ba764b9dff7231dc45ba671"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a6518427e11e6dd13d6f39663b82eb4f810ca05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a6518427e11e6dd13d6f39663b82eb4f810ca05", "html_url": "https://github.com/rust-lang/rust/commit/8a6518427e11e6dd13d6f39663b82eb4f810ca05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a6518427e11e6dd13d6f39663b82eb4f810ca05/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "492b83c6971c390af7a42932869502224ef55ef7", "url": "https://api.github.com/repos/rust-lang/rust/commits/492b83c6971c390af7a42932869502224ef55ef7", "html_url": "https://github.com/rust-lang/rust/commit/492b83c6971c390af7a42932869502224ef55ef7"}, {"sha": "a6b2e1f0462e2b765edbd554c21b51adb495c997", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6b2e1f0462e2b765edbd554c21b51adb495c997", "html_url": "https://github.com/rust-lang/rust/commit/a6b2e1f0462e2b765edbd554c21b51adb495c997"}], "stats": {"total": 831, "additions": 606, "deletions": 225}, "files": [{"sha": "6ab11e7e2be6d78180cd53d19e025be1ac8b36bf", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -1,6 +1,4 @@\n-<a href = \"https://www.rust-lang.org/\">\n-<img width = \"90%\" height = \"auto\" src = \"https://img.shields.io/badge/Rust-Programming%20Language-black?style=flat&logo=rust\" alt = \"The Rust Programming Language\">\n-</a>\n+# The Rust Programming Language\n \n This is the main source code repository for [Rust]. It contains the compiler,\n standard library, and documentation."}, {"sha": "8946ac43bc65a386966c8069f090ef535e9784f8", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -824,7 +824,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                     }\n                     ty => unreachable!(\"bswap {}\", ty),\n                 }\n-            };\n+            }\n             let res = CValue::by_val(swap(&mut fx.bcx, arg), fx.layout_of(T));\n             ret.write_cvalue(fx, res);\n         };"}, {"sha": "effa597aad9182840ed68f81c14e99d5c4f457f8", "filename": "compiler/rustc_error_codes/src/error_codes/E0373.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0373.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0373.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0373.md?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -50,3 +50,24 @@ fn foo() -> Box<Fn(u32) -> u32> {\n \n Now that the closure has its own copy of the data, there's no need to worry\n about safety.\n+\n+This error may also be encountered while using `async` blocks:\n+\n+```compile_fail,E0373,edition2018\n+use std::future::Future;\n+\n+async fn f() {\n+    let v = vec![1, 2, 3i32];\n+    spawn(async { //~ ERROR E0373\n+        println!(\"{:?}\", v)\n+    });\n+}\n+\n+fn spawn<F: Future + Send + 'static>(future: F) {\n+    unimplemented!()\n+}\n+```\n+\n+Similarly to closures, `async` blocks are not executed immediately and may\n+capture closed-over data by reference. For more information, see\n+https://rust-lang.github.io/async-book/03_async_await/01_chapter.html."}, {"sha": "a5fb8a1cbe8b78dd6d4537abcadcaba39b862c43", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -141,6 +141,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             self.add_moved_or_invoked_closure_note(location, used_place, &mut err);\n \n             let mut is_loop_move = false;\n+            let mut in_pattern = false;\n \n             for move_site in &move_site_vec {\n                 let move_out = self.move_data.moves[(*move_site).moi];\n@@ -256,6 +257,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         \"ref \".to_string(),\n                         Applicability::MachineApplicable,\n                     );\n+                    in_pattern = true;\n                 }\n \n                 if let Some(DesugaringKind::ForLoop(_)) = move_span.desugaring_kind() {\n@@ -302,7 +304,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let place = &self.move_data.move_paths[mpi].place;\n             let ty = place.ty(self.body, self.infcx.tcx).ty;\n \n-            if is_loop_move {\n+            // If we're in pattern, we do nothing in favor of the previous suggestion (#80913).\n+            if is_loop_move & !in_pattern {\n                 if let ty::Ref(_, _, hir::Mutability::Mut) = ty.kind() {\n                     // We have a `&mut` ref, we need to reborrow on each iteration (#62112).\n                     err.span_suggestion_verbose(\n@@ -1318,21 +1321,30 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             Applicability::MachineApplicable,\n         );\n \n-        let msg = match category {\n+        match category {\n             ConstraintCategory::Return(_) | ConstraintCategory::OpaqueType => {\n-                format!(\"{} is returned here\", kind)\n+                let msg = format!(\"{} is returned here\", kind);\n+                err.span_note(constraint_span, &msg);\n             }\n             ConstraintCategory::CallArgument => {\n                 fr_name.highlight_region_name(&mut err);\n-                format!(\"function requires argument type to outlive `{}`\", fr_name)\n+                if matches!(use_span.generator_kind(), Some(GeneratorKind::Async(_))) {\n+                    err.note(\n+                        \"async blocks are not executed immediately and must either take a \\\n+                    reference or ownership of outside variables they use\",\n+                    );\n+                } else {\n+                    let msg = format!(\"function requires argument type to outlive `{}`\", fr_name);\n+                    err.span_note(constraint_span, &msg);\n+                }\n             }\n             _ => bug!(\n                 \"report_escaping_closure_capture called with unexpected constraint \\\n                  category: `{:?}`\",\n                 category\n             ),\n-        };\n-        err.span_note(constraint_span, &msg);\n+        }\n+\n         err\n     }\n "}, {"sha": "3c515af71f5ff1db1398f5ec14a79325dfa897b5", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -161,7 +161,10 @@ use super::SpecExtend;\n /// It is a logic error for an item to be modified in such a way that the\n /// item's ordering relative to any other item, as determined by the `Ord`\n /// trait, changes while it is in the heap. This is normally only possible\n-/// through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n+/// through `Cell`, `RefCell`, global state, I/O, or unsafe code. The\n+/// behavior resulting from such a logic error is not specified, but will\n+/// not result in undefined behavior. This could include panics, incorrect\n+/// results, aborts, memory leaks, and non-termination.\n ///\n /// # Examples\n ///"}, {"sha": "5e63a303d22c3bb6682483dd0c05b14377687caa", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -51,6 +51,9 @@ pub(super) const MIN_LEN: usize = node::MIN_LEN_AFTER_SPLIT;\n /// It is a logic error for a key to be modified in such a way that the key's ordering relative to\n /// any other key, as determined by the [`Ord`] trait, changes while it is in the map. This is\n /// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n+/// The behavior resulting from such a logic error is not specified, but will not result in\n+/// undefined behavior. This could include panics, incorrect results, aborts, memory leaks, and\n+/// non-termination.\n ///\n /// [`Cell`]: core::cell::Cell\n /// [`RefCell`]: core::cell::RefCell"}, {"sha": "c2a96dd8ef471b46a00130d7f7b67e755bd2f21a", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -22,6 +22,9 @@ use super::Recover;\n /// It is a logic error for an item to be modified in such a way that the item's ordering relative\n /// to any other item, as determined by the [`Ord`] trait, changes while it is in the set. This is\n /// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n+/// The behavior resulting from such a logic error is not specified, but will not result in\n+/// undefined behavior. This could include panics, incorrect results, aborts, memory leaks, and\n+/// non-termination.\n ///\n /// [`Ord`]: core::cmp::Ord\n /// [`Cell`]: core::cell::Cell"}, {"sha": "d0bfa038aa13dd412e7717b6c61eb5912e714c62", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -120,6 +120,7 @@\n #![feature(receiver_trait)]\n #![cfg_attr(bootstrap, feature(min_const_generics))]\n #![feature(min_specialization)]\n+#![feature(set_ptr_value)]\n #![feature(slice_ptr_get)]\n #![feature(slice_ptr_len)]\n #![feature(staged_api)]"}, {"sha": "ee03f15eece3f94225f630cc326efb242bc2336a", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 56, "deletions": 49, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -353,6 +353,26 @@ impl<T> Rc<T> {\n     /// to upgrade the weak reference before this function returns will result\n     /// in a `None` value. However, the weak reference may be cloned freely and\n     /// stored for use at a later time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(arc_new_cyclic)]\n+    /// #![allow(dead_code)]\n+    /// use std::rc::{Rc, Weak};\n+    ///\n+    /// struct Gadget {\n+    ///     self_weak: Weak<Self>,\n+    ///     // ... more fields\n+    /// }\n+    /// impl Gadget {\n+    ///     pub fn new() -> Rc<Self> {\n+    ///         Rc::new_cyclic(|self_weak| {\n+    ///             Gadget { self_weak: self_weak.clone(), /* ... */ }\n+    ///         })\n+    ///     }\n+    /// }\n+    /// ```\n     #[unstable(feature = \"arc_new_cyclic\", issue = \"75861\")]\n     pub fn new_cyclic(data_fn: impl FnOnce(&Weak<T>) -> T) -> Rc<T> {\n         // Construct the inner in the \"uninitialized\" state with a single\n@@ -829,8 +849,8 @@ impl<T: ?Sized> Rc<T> {\n         let offset = unsafe { data_offset(ptr) };\n \n         // Reverse the offset to find the original RcBox.\n-        let fake_ptr = ptr as *mut RcBox<T>;\n-        let rc_ptr = unsafe { set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset)) };\n+        let rc_ptr =\n+            unsafe { (ptr as *mut RcBox<T>).set_ptr_value((ptr as *mut u8).offset(-offset)) };\n \n         unsafe { Self::from_ptr(rc_ptr) }\n     }\n@@ -850,7 +870,7 @@ impl<T: ?Sized> Rc<T> {\n     pub fn downgrade(this: &Self) -> Weak<T> {\n         this.inner().inc_weak();\n         // Make sure we do not create a dangling Weak\n-        debug_assert!(!is_dangling(this.ptr));\n+        debug_assert!(!is_dangling(this.ptr.as_ptr()));\n         Weak { ptr: this.ptr }\n     }\n \n@@ -1164,7 +1184,7 @@ impl<T: ?Sized> Rc<T> {\n             Self::allocate_for_layout(\n                 Layout::for_value(&*ptr),\n                 |layout| Global.allocate(layout),\n-                |mem| set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>,\n+                |mem| (ptr as *mut RcBox<T>).set_ptr_value(mem),\n             )\n         }\n     }\n@@ -1203,20 +1223,7 @@ impl<T> Rc<[T]> {\n             )\n         }\n     }\n-}\n-\n-/// Sets the data pointer of a `?Sized` raw pointer.\n-///\n-/// For a slice/trait object, this sets the `data` field and leaves the rest\n-/// unchanged. For a sized raw pointer, this simply sets the pointer.\n-unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n-    unsafe {\n-        ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n-    }\n-    ptr\n-}\n \n-impl<T> Rc<[T]> {\n     /// Copy elements from slice into newly allocated Rc<\\[T\\]>\n     ///\n     /// Unsafe because the caller must either take ownership or bind `T: Copy`\n@@ -1860,8 +1867,8 @@ impl<T> Weak<T> {\n     }\n }\n \n-pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n-    let address = ptr.as_ptr() as *mut () as usize;\n+pub(crate) fn is_dangling<T: ?Sized>(ptr: *mut T) -> bool {\n+    let address = ptr as *mut () as usize;\n     address == usize::MAX\n }\n \n@@ -1872,7 +1879,7 @@ struct WeakInner<'a> {\n     strong: &'a Cell<usize>,\n }\n \n-impl<T> Weak<T> {\n+impl<T: ?Sized> Weak<T> {\n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n     ///\n     /// The pointer is valid only if there are some strong references. The pointer may be dangling,\n@@ -1902,15 +1909,15 @@ impl<T> Weak<T> {\n     pub fn as_ptr(&self) -> *const T {\n         let ptr: *mut RcBox<T> = NonNull::as_ptr(self.ptr);\n \n-        // SAFETY: we must offset the pointer manually, and said pointer may be\n-        // a dangling weak (usize::MAX) if T is sized. data_offset is safe to call,\n-        // because we know that a pointer to unsized T was derived from a real\n-        // unsized T, as dangling weaks are only created for sized T. wrapping_offset\n-        // is used so that we can use the same code path for the non-dangling\n-        // unsized case and the potentially dangling sized case.\n-        unsafe {\n-            let offset = data_offset(ptr as *mut T);\n-            set_data_ptr(ptr as *mut T, (ptr as *mut u8).wrapping_offset(offset))\n+        if is_dangling(ptr) {\n+            // If the pointer is dangling, we return the sentinel directly. This cannot be\n+            // a valid payload address, as the payload is at least as aligned as RcBox (usize).\n+            ptr as *const T\n+        } else {\n+            // SAFETY: if is_dangling returns false, then the pointer is dereferencable.\n+            // The payload may be dropped at this point, and we have to maintain provenance,\n+            // so use raw pointer manipulation.\n+            unsafe { &raw const (*ptr).value }\n         }\n     }\n \n@@ -1992,22 +1999,24 @@ impl<T> Weak<T> {\n     /// [`new`]: Weak::new\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        // SAFETY: data_offset is safe to call, because this pointer originates from a Weak.\n         // See Weak::as_ptr for context on how the input pointer is derived.\n-        let offset = unsafe { data_offset(ptr) };\n \n-        // Reverse the offset to find the original RcBox.\n-        // SAFETY: we use wrapping_offset here because the pointer may be dangling (but only if T: Sized).\n-        let ptr = unsafe {\n-            set_data_ptr(ptr as *mut RcBox<T>, (ptr as *mut u8).wrapping_offset(-offset))\n+        let ptr = if is_dangling(ptr as *mut T) {\n+            // This is a dangling Weak.\n+            ptr as *mut RcBox<T>\n+        } else {\n+            // Otherwise, we're guaranteed the pointer came from a nondangling Weak.\n+            // SAFETY: data_offset is safe to call, as ptr references a real (potentially dropped) T.\n+            let offset = unsafe { data_offset(ptr) };\n+            // Thus, we reverse the offset to get the whole RcBox.\n+            // SAFETY: the pointer originated from a Weak, so this offset is safe.\n+            unsafe { (ptr as *mut RcBox<T>).set_ptr_value((ptr as *mut u8).offset(-offset)) }\n         };\n \n         // SAFETY: we now have recovered the original Weak pointer, so can create the Weak.\n         Weak { ptr: unsafe { NonNull::new_unchecked(ptr) } }\n     }\n-}\n \n-impl<T: ?Sized> Weak<T> {\n     /// Attempts to upgrade the `Weak` pointer to an [`Rc`], delaying\n     /// dropping of the inner value if successful.\n     ///\n@@ -2070,7 +2079,7 @@ impl<T: ?Sized> Weak<T> {\n     /// (i.e., when this `Weak` was created by `Weak::new`).\n     #[inline]\n     fn inner(&self) -> Option<WeakInner<'_>> {\n-        if is_dangling(self.ptr) {\n+        if is_dangling(self.ptr.as_ptr()) {\n             None\n         } else {\n             // We are careful to *not* create a reference covering the \"data\" field, as\n@@ -2325,21 +2334,19 @@ impl<T: ?Sized> AsRef<T> for Rc<T> {\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Rc<T> {}\n \n-/// Get the offset within an `RcBox` for\n-/// a payload of type described by a pointer.\n+/// Get the offset within an `RcBox` for the payload behind a pointer.\n ///\n /// # Safety\n ///\n-/// This has the same safety requirements as `align_of_val_raw`. In effect:\n-///\n-/// - This function is safe for any argument if `T` is sized, and\n-/// - if `T` is unsized, the pointer must have appropriate pointer metadata\n-///   acquired from the real instance that you are getting this offset for.\n+/// The pointer must point to (and have valid metadata for) a previously\n+/// valid instance of T, but the T is allowed to be dropped.\n unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n-    // Align the unsized value to the end of the `RcBox`.\n-    // Because it is ?Sized, it will always be the last field in memory.\n-    // Note: This is a detail of the current implementation of the compiler,\n-    // and is not a guaranteed language detail. Do not rely on it outside of std.\n+    // Align the unsized value to the end of the RcBox.\n+    // Because RcBox is repr(C), it will always be the last field in memory.\n+    // SAFETY: since the only unsized types possible are slices, trait objects,\n+    // and extern types, the input safety requirement is currently enough to\n+    // satisfy the requirements of align_of_val_raw; this is an implementation\n+    // detail of the language that may not be relied upon outside of std.\n     unsafe { data_offset_align(align_of_val_raw(ptr)) }\n }\n "}, {"sha": "843a9b07fa93448ef99c84197b25718d82a95db2", "filename": "library/alloc/src/rc/tests.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Falloc%2Fsrc%2Frc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Falloc%2Fsrc%2Frc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc%2Ftests.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -208,6 +208,30 @@ fn into_from_weak_raw() {\n     }\n }\n \n+#[test]\n+fn test_into_from_weak_raw_unsized() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let arc: Rc<str> = Rc::from(\"foo\");\n+    let weak: Weak<str> = Rc::downgrade(&arc);\n+\n+    let ptr = Weak::into_raw(weak.clone());\n+    let weak2 = unsafe { Weak::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }, \"foo\");\n+    assert!(weak.ptr_eq(&weak2));\n+\n+    let arc: Rc<dyn Display> = Rc::new(123);\n+    let weak: Weak<dyn Display> = Rc::downgrade(&arc);\n+\n+    let ptr = Weak::into_raw(weak.clone());\n+    let weak2 = unsafe { Weak::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n+    assert!(weak.ptr_eq(&weak2));\n+}\n+\n #[test]\n fn get_mut() {\n     let mut x = Rc::new(3);\n@@ -294,6 +318,23 @@ fn test_unsized() {\n     assert_eq!(foo, foo.clone());\n }\n \n+#[test]\n+fn test_maybe_thin_unsized() {\n+    // If/when custom thin DSTs exist, this test should be updated to use one\n+    use std::ffi::{CStr, CString};\n+\n+    let x: Rc<CStr> = Rc::from(CString::new(\"swordfish\").unwrap().into_boxed_c_str());\n+    assert_eq!(format!(\"{:?}\", x), \"\\\"swordfish\\\"\");\n+    let y: Weak<CStr> = Rc::downgrade(&x);\n+    drop(x);\n+\n+    // At this point, the weak points to a dropped DST\n+    assert!(y.upgrade().is_none());\n+    // But we still need to be able to get the alloc layout to drop.\n+    // CStr has no drop glue, but custom DSTs might, and need to work.\n+    drop(y);\n+}\n+\n #[test]\n fn test_from_owned() {\n     let foo = 123;"}, {"sha": "c0d684fbb45730a0e307f944e48f7a0999c83e45", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 34, "deletions": 46, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -846,8 +846,7 @@ impl<T: ?Sized> Arc<T> {\n             let offset = data_offset(ptr);\n \n             // Reverse the offset to find the original ArcInner.\n-            let fake_ptr = ptr as *mut ArcInner<T>;\n-            let arc_ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+            let arc_ptr = (ptr as *mut ArcInner<T>).set_ptr_value((ptr as *mut u8).offset(-offset));\n \n             Self::from_ptr(arc_ptr)\n         }\n@@ -888,7 +887,7 @@ impl<T: ?Sized> Arc<T> {\n             match this.inner().weak.compare_exchange_weak(cur, cur + 1, Acquire, Relaxed) {\n                 Ok(_) => {\n                     // Make sure we do not create a dangling Weak\n-                    debug_assert!(!is_dangling(this.ptr));\n+                    debug_assert!(!is_dangling(this.ptr.as_ptr()));\n                     return Weak { ptr: this.ptr };\n                 }\n                 Err(old) => cur = old,\n@@ -1131,7 +1130,7 @@ impl<T: ?Sized> Arc<T> {\n             Self::allocate_for_layout(\n                 Layout::for_value(&*ptr),\n                 |layout| Global.allocate(layout),\n-                |mem| set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>,\n+                |mem| (ptr as *mut ArcInner<T>).set_ptr_value(mem) as *mut ArcInner<T>,\n             )\n         }\n     }\n@@ -1170,20 +1169,7 @@ impl<T> Arc<[T]> {\n             )\n         }\n     }\n-}\n-\n-/// Sets the data pointer of a `?Sized` raw pointer.\n-///\n-/// For a slice/trait object, this sets the `data` field and leaves the rest\n-/// unchanged. For a sized raw pointer, this simply sets the pointer.\n-unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n-    unsafe {\n-        ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n-    }\n-    ptr\n-}\n \n-impl<T> Arc<[T]> {\n     /// Copy elements from slice into newly allocated Arc<\\[T\\]>\n     ///\n     /// Unsafe because the caller must either take ownership or bind `T: Copy`.\n@@ -1653,7 +1639,7 @@ struct WeakInner<'a> {\n     strong: &'a atomic::AtomicUsize,\n }\n \n-impl<T> Weak<T> {\n+impl<T: ?Sized> Weak<T> {\n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n     ///\n     /// The pointer is valid only if there are some strong references. The pointer may be dangling,\n@@ -1683,15 +1669,15 @@ impl<T> Weak<T> {\n     pub fn as_ptr(&self) -> *const T {\n         let ptr: *mut ArcInner<T> = NonNull::as_ptr(self.ptr);\n \n-        // SAFETY: we must offset the pointer manually, and said pointer may be\n-        // a dangling weak (usize::MAX) if T is sized. data_offset is safe to call,\n-        // because we know that a pointer to unsized T was derived from a real\n-        // unsized T, as dangling weaks are only created for sized T. wrapping_offset\n-        // is used so that we can use the same code path for the non-dangling\n-        // unsized case and the potentially dangling sized case.\n-        unsafe {\n-            let offset = data_offset(ptr as *mut T);\n-            set_data_ptr(ptr as *mut T, (ptr as *mut u8).wrapping_offset(offset))\n+        if is_dangling(ptr) {\n+            // If the pointer is dangling, we return the sentinel directly. This cannot be\n+            // a valid payload address, as the payload is at least as aligned as ArcInner (usize).\n+            ptr as *const T\n+        } else {\n+            // SAFETY: if is_dangling returns false, then the pointer is dereferencable.\n+            // The payload may be dropped at this point, and we have to maintain provenance,\n+            // so use raw pointer manipulation.\n+            unsafe { &raw mut (*ptr).data }\n         }\n     }\n \n@@ -1773,18 +1759,22 @@ impl<T> Weak<T> {\n     /// [`forget`]: std::mem::forget\n     #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        // SAFETY: data_offset is safe to call, because this pointer originates from a Weak.\n         // See Weak::as_ptr for context on how the input pointer is derived.\n-        let offset = unsafe { data_offset(ptr) };\n \n-        // Reverse the offset to find the original ArcInner.\n-        // SAFETY: we use wrapping_offset here because the pointer may be dangling (but only if T: Sized)\n-        let ptr = unsafe {\n-            set_data_ptr(ptr as *mut ArcInner<T>, (ptr as *mut u8).wrapping_offset(-offset))\n+        let ptr = if is_dangling(ptr as *mut T) {\n+            // This is a dangling Weak.\n+            ptr as *mut ArcInner<T>\n+        } else {\n+            // Otherwise, we're guaranteed the pointer came from a nondangling Weak.\n+            // SAFETY: data_offset is safe to call, as ptr references a real (potentially dropped) T.\n+            let offset = unsafe { data_offset(ptr) };\n+            // Thus, we reverse the offset to get the whole RcBox.\n+            // SAFETY: the pointer originated from a Weak, so this offset is safe.\n+            unsafe { (ptr as *mut ArcInner<T>).set_ptr_value((ptr as *mut u8).offset(-offset)) }\n         };\n \n         // SAFETY: we now have recovered the original Weak pointer, so can create the Weak.\n-        unsafe { Weak { ptr: NonNull::new_unchecked(ptr) } }\n+        Weak { ptr: unsafe { NonNull::new_unchecked(ptr) } }\n     }\n }\n \n@@ -1889,7 +1879,7 @@ impl<T: ?Sized> Weak<T> {\n     /// (i.e., when this `Weak` was created by `Weak::new`).\n     #[inline]\n     fn inner(&self) -> Option<WeakInner<'_>> {\n-        if is_dangling(self.ptr) {\n+        if is_dangling(self.ptr.as_ptr()) {\n             None\n         } else {\n             // We are careful to *not* create a reference covering the \"data\" field, as\n@@ -2469,21 +2459,19 @@ impl<T: ?Sized> AsRef<T> for Arc<T> {\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Arc<T> {}\n \n-/// Get the offset within an `ArcInner` for\n-/// a payload of type described by a pointer.\n+/// Get the offset within an `ArcInner` for the payload behind a pointer.\n ///\n /// # Safety\n ///\n-/// This has the same safety requirements as `align_of_val_raw`. In effect:\n-///\n-/// - This function is safe for any argument if `T` is sized, and\n-/// - if `T` is unsized, the pointer must have appropriate pointer metadata\n-///   acquired from the real instance that you are getting this offset for.\n+/// The pointer must point to (and have valid metadata for) a previously\n+/// valid instance of T, but the T is allowed to be dropped.\n unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n-    // Align the unsized value to the end of the `ArcInner`.\n-    // Because it is `?Sized`, it will always be the last field in memory.\n-    // Note: This is a detail of the current implementation of the compiler,\n-    // and is not a guaranteed language detail. Do not rely on it outside of std.\n+    // Align the unsized value to the end of the ArcInner.\n+    // Because RcBox is repr(C), it will always be the last field in memory.\n+    // SAFETY: since the only unsized types possible are slices, trait objects,\n+    // and extern types, the input safety requirement is currently enough to\n+    // satisfy the requirements of align_of_val_raw; this is an implementation\n+    // detail of the language that may not be relied upon outside of std.\n     unsafe { data_offset_align(align_of_val_raw(ptr)) }\n }\n "}, {"sha": "4ccb32fbbf63d3e5f131b304196834a36a29f2eb", "filename": "library/alloc/src/sync/tests.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -158,6 +158,30 @@ fn into_from_weak_raw() {\n     }\n }\n \n+#[test]\n+fn test_into_from_weak_raw_unsized() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let arc: Arc<str> = Arc::from(\"foo\");\n+    let weak: Weak<str> = Arc::downgrade(&arc);\n+\n+    let ptr = Weak::into_raw(weak.clone());\n+    let weak2 = unsafe { Weak::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }, \"foo\");\n+    assert!(weak.ptr_eq(&weak2));\n+\n+    let arc: Arc<dyn Display> = Arc::new(123);\n+    let weak: Weak<dyn Display> = Arc::downgrade(&arc);\n+\n+    let ptr = Weak::into_raw(weak.clone());\n+    let weak2 = unsafe { Weak::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n+    assert!(weak.ptr_eq(&weak2));\n+}\n+\n #[test]\n fn test_cowarc_clone_make_mut() {\n     let mut cow0 = Arc::new(75);\n@@ -329,6 +353,23 @@ fn test_unsized() {\n     assert!(y.upgrade().is_none());\n }\n \n+#[test]\n+fn test_maybe_thin_unsized() {\n+    // If/when custom thin DSTs exist, this test should be updated to use one\n+    use std::ffi::{CStr, CString};\n+\n+    let x: Arc<CStr> = Arc::from(CString::new(\"swordfish\").unwrap().into_boxed_c_str());\n+    assert_eq!(format!(\"{:?}\", x), \"\\\"swordfish\\\"\");\n+    let y: Weak<CStr> = Arc::downgrade(&x);\n+    drop(x);\n+\n+    // At this point, the weak points to a dropped DST\n+    assert!(y.upgrade().is_none());\n+    // But we still need to be able to get the alloc layout to drop.\n+    // CStr has no drop glue, but custom DSTs might, and need to work.\n+    drop(y);\n+}\n+\n #[test]\n fn test_from_owned() {\n     let foo = 123;"}, {"sha": "fa0fbaa35c95c68b6437af2d83a232dbacc86005", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -1261,6 +1261,40 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         Ref { value: f(orig.value), borrow: orig.borrow }\n     }\n \n+    /// Makes a new `Ref` for an optional component of the borrowed data. The\n+    /// original guard is returned as an `Err(..)` if the closure returns\n+    /// `None`.\n+    ///\n+    /// The `RefCell` is already immutably borrowed, so this cannot fail.\n+    ///\n+    /// This is an associated function that needs to be used as\n+    /// `Ref::filter_map(...)`. A method would interfere with methods of the same\n+    /// name on the contents of a `RefCell` used through `Deref`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cell_filter_map)]\n+    ///\n+    /// use std::cell::{RefCell, Ref};\n+    ///\n+    /// let c = RefCell::new(vec![1, 2, 3]);\n+    /// let b1: Ref<Vec<u32>> = c.borrow();\n+    /// let b2: Result<Ref<u32>, _> = Ref::filter_map(b1, |v| v.get(1));\n+    /// assert_eq!(*b2.unwrap(), 2);\n+    /// ```\n+    #[unstable(feature = \"cell_filter_map\", reason = \"recently added\", issue = \"81061\")]\n+    #[inline]\n+    pub fn filter_map<U: ?Sized, F>(orig: Ref<'b, T>, f: F) -> Result<Ref<'b, U>, Self>\n+    where\n+        F: FnOnce(&T) -> Option<&U>,\n+    {\n+        match f(orig.value) {\n+            Some(value) => Ok(Ref { value, borrow: orig.borrow }),\n+            None => Err(orig),\n+        }\n+    }\n+\n     /// Splits a `Ref` into multiple `Ref`s for different components of the\n     /// borrowed data.\n     ///\n@@ -1372,6 +1406,58 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n         RefMut { value: f(value), borrow }\n     }\n \n+    /// Makes a new `RefMut` for an optional component of the borrowed data. The\n+    /// original guard is returned as an `Err(..)` if the closure returns\n+    /// `None`.\n+    ///\n+    /// The `RefCell` is already mutably borrowed, so this cannot fail.\n+    ///\n+    /// This is an associated function that needs to be used as\n+    /// `RefMut::filter_map(...)`. A method would interfere with methods of the\n+    /// same name on the contents of a `RefCell` used through `Deref`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cell_filter_map)]\n+    ///\n+    /// use std::cell::{RefCell, RefMut};\n+    ///\n+    /// let c = RefCell::new(vec![1, 2, 3]);\n+    ///\n+    /// {\n+    ///     let b1: RefMut<Vec<u32>> = c.borrow_mut();\n+    ///     let mut b2: Result<RefMut<u32>, _> = RefMut::filter_map(b1, |v| v.get_mut(1));\n+    ///\n+    ///     if let Ok(mut b2) = b2 {\n+    ///         *b2 += 2;\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(*c.borrow(), vec![1, 4, 3]);\n+    /// ```\n+    #[unstable(feature = \"cell_filter_map\", reason = \"recently added\", issue = \"81061\")]\n+    #[inline]\n+    pub fn filter_map<U: ?Sized, F>(orig: RefMut<'b, T>, f: F) -> Result<RefMut<'b, U>, Self>\n+    where\n+        F: FnOnce(&mut T) -> Option<&mut U>,\n+    {\n+        // FIXME(nll-rfc#40): fix borrow-check\n+        let RefMut { value, borrow } = orig;\n+        let value = value as *mut T;\n+        // SAFETY: function holds onto an exclusive reference for the duration\n+        // of its call through `orig`, and the pointer is only de-referenced\n+        // inside of the function call never allowing the exclusive reference to\n+        // escape.\n+        match f(unsafe { &mut *value }) {\n+            Some(value) => Ok(RefMut { value, borrow }),\n+            None => {\n+                // SAFETY: same as above.\n+                Err(RefMut { value: unsafe { &mut *value }, borrow })\n+            }\n+        }\n+    }\n+\n     /// Splits a `RefMut` into multiple `RefMut`s for different components of the\n     /// borrowed data.\n     ///"}, {"sha": "98b8dca961407e9c3f0ab8d980e74155c91aa5bd", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -286,6 +286,7 @@ where\n \n     #[inline]\n     unsafe fn get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item {\n+        let idx = self.index + idx;\n         // SAFETY: the caller must uphold the contract for\n         // `Iterator::__iterator_get_unchecked`.\n         unsafe { (self.a.__iterator_get_unchecked(idx), self.b.__iterator_get_unchecked(idx)) }"}, {"sha": "42c9d9f0cc03953379d14357857cd53ffbb2e43f", "filename": "library/core/src/task/poll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -84,7 +84,7 @@ impl<T, E> Poll<Result<T, E>> {\n \n impl<T, E> Poll<Option<Result<T, E>>> {\n     /// Changes the success value of this `Poll` with the closure provided.\n-    #[unstable(feature = \"poll_map\", issue = \"63514\")]\n+    #[stable(feature = \"poll_map\", since = \"1.51.0\")]\n     pub fn map_ok<U, F>(self, f: F) -> Poll<Option<Result<U, E>>>\n     where\n         F: FnOnce(T) -> U,\n@@ -98,7 +98,7 @@ impl<T, E> Poll<Option<Result<T, E>>> {\n     }\n \n     /// Changes the error value of this `Poll` with the closure provided.\n-    #[unstable(feature = \"poll_map\", issue = \"63514\")]\n+    #[stable(feature = \"poll_map\", since = \"1.51.0\")]\n     pub fn map_err<U, F>(self, f: F) -> Poll<Option<Result<T, U>>>\n     where\n         F: FnOnce(E) -> U,"}, {"sha": "bc5421bfb5f8f5e9702b817e6a26871019738f02", "filename": "library/core/tests/iter.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Fcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Fcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -2,6 +2,7 @@\n \n use core::cell::Cell;\n use core::convert::TryFrom;\n+use core::iter::TrustedRandomAccess;\n use core::iter::*;\n \n /// An iterator wrapper that panics whenever `next` or `next_back` is called\n@@ -601,6 +602,26 @@ fn test_zip_nth_back_side_effects_exhausted() {\n     assert_eq!(b, vec![200, 300, 400]);\n }\n \n+#[test]\n+fn test_zip_trusted_random_access_composition() {\n+    let a = [0, 1, 2, 3, 4];\n+    let b = a;\n+    let c = a;\n+\n+    let a = a.iter().copied();\n+    let b = b.iter().copied();\n+    let mut c = c.iter().copied();\n+    c.next();\n+\n+    let mut z1 = a.zip(b);\n+    assert_eq!(z1.next().unwrap(), (0, 0));\n+\n+    let mut z2 = z1.zip(c);\n+    fn assert_trusted_random_access<T: TrustedRandomAccess>(_a: &T) {}\n+    assert_trusted_random_access(&z2);\n+    assert_eq!(z2.next().unwrap(), ((1, 1), 1));\n+}\n+\n #[test]\n fn test_iterator_step_by() {\n     // Identity"}, {"sha": "98f5982fbb2c17de42cc68e5680d61822b7924c9", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -75,6 +75,7 @@\n #![feature(const_option)]\n #![feature(integer_atomics)]\n #![feature(slice_group_by)]\n+#![feature(trusted_random_access)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n extern crate test;"}, {"sha": "829fc3817af2de6cfc434a521331f76abf270438", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -52,6 +52,9 @@ use crate::sys;\n /// hash, as determined by the [`Hash`] trait, or its equality, as determined by\n /// the [`Eq`] trait, changes while it is in the map. This is normally only\n /// possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n+/// The behavior resulting from such a logic error is not specified, but will\n+/// not result in undefined behavior. This could include panics, incorrect results,\n+/// aborts, memory leaks, and non-termination.\n ///\n /// The hash table implementation is a Rust port of Google's [SwissTable].\n /// The original C++ version of SwissTable can be found [here], and this"}, {"sha": "baa3026ff7514d2d4ed3dfd608131990aacc9ca9", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -37,7 +37,9 @@ use super::map::{map_try_reserve_error, RandomState};\n /// item's hash, as determined by the [`Hash`] trait, or its equality, as\n /// determined by the [`Eq`] trait, changes while it is in the set. This is\n /// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or\n-/// unsafe code.\n+/// unsafe code. The behavior resulting from such a logic error is not\n+/// specified, but will not result in undefined behavior. This could include\n+/// panics, incorrect results, aborts, memory leaks, and non-termination.\n ///\n /// # Examples\n ///"}, {"sha": "62065e27dd9667a8f999845672a0515f15da758f", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -814,12 +814,22 @@ impl<'a> Builder<'a> {\n             cargo.env(\"REAL_LIBRARY_PATH\", e);\n         }\n \n+        // Found with `rg \"init_env_logger\\(\"`. If anyone uses `init_env_logger`\n+        // from out of tree it shouldn't matter, since x.py is only used for\n+        // building in-tree.\n+        let color_logs = [\"RUSTDOC_LOG_COLOR\", \"RUSTC_LOG_COLOR\", \"RUST_LOG_COLOR\"];\n         match self.build.config.color {\n             Color::Always => {\n                 cargo.arg(\"--color=always\");\n+                for log in &color_logs {\n+                    cargo.env(log, \"always\");\n+                }\n             }\n             Color::Never => {\n                 cargo.arg(\"--color=never\");\n+                for log in &color_logs {\n+                    cargo.env(log, \"never\");\n+                }\n             }\n             Color::Auto => {} // nothing to do\n         }"}, {"sha": "cafb65bc7f9cb03e8b512684f130398e7d3da74b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 85, "deletions": 91, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -219,7 +219,6 @@ impl Clean<ExternalCrate> for CrateNum {\n impl Clean<Item> for doctree::Module<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let mut items: Vec<Item> = vec![];\n-        items.extend(self.imports.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n         items.extend(self.items.iter().map(|x| x.clean(cx)).flatten());\n@@ -2015,7 +2014,7 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                 ItemKind::Fn(ref sig, ref generics, body_id) => {\n                     clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n                 }\n-                hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n+                ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n                     let items = item_ids\n                         .iter()\n                         .map(|ti| cx.tcx.hir().trait_item(ti.id).clean(cx))\n@@ -2034,6 +2033,9 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                 ItemKind::ExternCrate(orig_name) => {\n                     return clean_extern_crate(item, name, orig_name, cx);\n                 }\n+                ItemKind::Use(path, kind) => {\n+                    return clean_use_statement(item, name, path, kind, cx);\n+                }\n                 _ => unreachable!(\"not yet converted\"),\n             };\n \n@@ -2155,105 +2157,97 @@ fn clean_extern_crate(\n     }]\n }\n \n-impl Clean<Vec<Item>> for doctree::Import<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n-        // We need this comparison because some imports (for std types for example)\n-        // are \"inserted\" as well but directly by the compiler and they should not be\n-        // taken into account.\n-        if self.span.ctxt().outer_expn_data().kind == ExpnKind::AstPass(AstPass::StdImports) {\n-            return Vec::new();\n-        }\n-\n-        let (doc_meta_item, please_inline) = self.attrs.lists(sym::doc).get_word_attr(sym::inline);\n-        let pub_underscore = self.vis.node.is_pub() && self.name == kw::Underscore;\n-\n-        if pub_underscore && please_inline {\n-            rustc_errors::struct_span_err!(\n-                cx.tcx.sess,\n-                doc_meta_item.unwrap().span(),\n-                E0780,\n-                \"anonymous imports cannot be inlined\"\n-            )\n-            .span_label(self.span, \"anonymous import\")\n-            .emit();\n-        }\n+fn clean_use_statement(\n+    import: &hir::Item<'_>,\n+    name: Symbol,\n+    path: &hir::Path<'_>,\n+    kind: hir::UseKind,\n+    cx: &DocContext<'_>,\n+) -> Vec<Item> {\n+    // We need this comparison because some imports (for std types for example)\n+    // are \"inserted\" as well but directly by the compiler and they should not be\n+    // taken into account.\n+    if import.span.ctxt().outer_expn_data().kind == ExpnKind::AstPass(AstPass::StdImports) {\n+        return Vec::new();\n+    }\n+\n+    let (doc_meta_item, please_inline) = import.attrs.lists(sym::doc).get_word_attr(sym::inline);\n+    let pub_underscore = import.vis.node.is_pub() && name == kw::Underscore;\n+\n+    if pub_underscore && please_inline {\n+        rustc_errors::struct_span_err!(\n+            cx.tcx.sess,\n+            doc_meta_item.unwrap().span(),\n+            E0780,\n+            \"anonymous imports cannot be inlined\"\n+        )\n+        .span_label(import.span, \"anonymous import\")\n+        .emit();\n+    }\n \n-        // We consider inlining the documentation of `pub use` statements, but we\n-        // forcefully don't inline if this is not public or if the\n-        // #[doc(no_inline)] attribute is present.\n-        // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n-        let mut denied = !self.vis.node.is_pub()\n-            || pub_underscore\n-            || self.attrs.iter().any(|a| {\n-                a.has_name(sym::doc)\n-                    && match a.meta_item_list() {\n-                        Some(l) => {\n-                            attr::list_contains_name(&l, sym::no_inline)\n-                                || attr::list_contains_name(&l, sym::hidden)\n-                        }\n-                        None => false,\n+    // We consider inlining the documentation of `pub use` statements, but we\n+    // forcefully don't inline if this is not public or if the\n+    // #[doc(no_inline)] attribute is present.\n+    // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n+    let mut denied = !import.vis.node.is_pub()\n+        || pub_underscore\n+        || import.attrs.iter().any(|a| {\n+            a.has_name(sym::doc)\n+                && match a.meta_item_list() {\n+                    Some(l) => {\n+                        attr::list_contains_name(&l, sym::no_inline)\n+                            || attr::list_contains_name(&l, sym::hidden)\n                     }\n-            });\n-        // Also check whether imports were asked to be inlined, in case we're trying to re-export a\n-        // crate in Rust 2018+\n-        let path = self.path.clean(cx);\n-        let inner = if self.glob {\n-            if !denied {\n-                let mut visited = FxHashSet::default();\n-                if let Some(items) = inline::try_inline_glob(cx, path.res, &mut visited) {\n-                    return items;\n+                    None => false,\n                 }\n+        });\n+\n+    // Also check whether imports were asked to be inlined, in case we're trying to re-export a\n+    // crate in Rust 2018+\n+    let def_id = cx.tcx.hir().local_def_id(import.hir_id).to_def_id();\n+    let path = path.clean(cx);\n+    let inner = if kind == hir::UseKind::Glob {\n+        if !denied {\n+            let mut visited = FxHashSet::default();\n+            if let Some(items) = inline::try_inline_glob(cx, path.res, &mut visited) {\n+                return items;\n             }\n-            Import::new_glob(resolve_use_source(cx, path), true)\n-        } else {\n-            let name = self.name;\n-            if !please_inline {\n-                if let Res::Def(DefKind::Mod, did) = path.res {\n-                    if !did.is_local() && did.index == CRATE_DEF_INDEX {\n-                        // if we're `pub use`ing an extern crate root, don't inline it unless we\n-                        // were specifically asked for it\n-                        denied = true;\n-                    }\n+        }\n+        Import::new_glob(resolve_use_source(cx, path), true)\n+    } else {\n+        if !please_inline {\n+            if let Res::Def(DefKind::Mod, did) = path.res {\n+                if !did.is_local() && did.index == CRATE_DEF_INDEX {\n+                    // if we're `pub use`ing an extern crate root, don't inline it unless we\n+                    // were specifically asked for it\n+                    denied = true;\n                 }\n             }\n-            if !denied {\n-                let mut visited = FxHashSet::default();\n+        }\n+        if !denied {\n+            let mut visited = FxHashSet::default();\n \n-                if let Some(mut items) = inline::try_inline(\n+            if let Some(mut items) = inline::try_inline(\n+                cx,\n+                cx.tcx.parent_module(import.hir_id).to_def_id(),\n+                path.res,\n+                name,\n+                Some(import.attrs),\n+                &mut visited,\n+            ) {\n+                items.push(Item::from_def_id_and_parts(\n+                    def_id,\n+                    None,\n+                    ImportItem(Import::new_simple(name, resolve_use_source(cx, path), false)),\n                     cx,\n-                    cx.tcx.parent_module(self.id).to_def_id(),\n-                    path.res,\n-                    name,\n-                    Some(self.attrs),\n-                    &mut visited,\n-                ) {\n-                    items.push(Item {\n-                        name: None,\n-                        attrs: box self.attrs.clean(cx),\n-                        source: self.span.clean(cx),\n-                        def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-                        visibility: self.vis.clean(cx),\n-                        kind: box ImportItem(Import::new_simple(\n-                            self.name,\n-                            resolve_use_source(cx, path),\n-                            false,\n-                        )),\n-                    });\n-                    return items;\n-                }\n+                ));\n+                return items;\n             }\n-            Import::new_simple(name, resolve_use_source(cx, path), true)\n-        };\n+        }\n+        Import::new_simple(name, resolve_use_source(cx, path), true)\n+    };\n \n-        vec![Item {\n-            name: None,\n-            attrs: box self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            kind: box ImportItem(inner),\n-        }]\n-    }\n+    vec![Item::from_def_id_and_parts(def_id, None, ImportItem(inner), cx)]\n }\n \n impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {"}, {"sha": "3de97f2dd2e59375b817e02bf8aa5dbcdec900c8", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -500,6 +500,12 @@ crate fn make_test(\n                 }\n             }\n \n+            // Reset errors so that they won't be reported as compiler bugs when dropping the\n+            // handler. Any errors in the tests will be reported when the test file is compiled,\n+            // Note that we still need to cancel the errors above otherwise `DiagnosticBuilder`\n+            // will panic on drop.\n+            sess.span_diagnostic.reset_err_count();\n+\n             (found_main, found_extern_crate, found_macro)\n         })\n     });"}, {"sha": "f90623c03118b6ef8b462589a1888e1b38782327", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -2,7 +2,6 @@\n //! manner (and with prettier names) before cleaning.\n crate use self::StructType::*;\n \n-use rustc_ast as ast;\n use rustc_span::{self, Span, Symbol};\n \n use rustc_hir as hir;\n@@ -11,7 +10,6 @@ crate struct Module<'hir> {\n     crate name: Option<Symbol>,\n     crate where_outer: Span,\n     crate where_inner: Span,\n-    crate imports: Vec<Import<'hir>>,\n     crate mods: Vec<Module<'hir>>,\n     crate id: hir::HirId,\n     // (item, renamed)\n@@ -28,7 +26,6 @@ impl Module<'hir> {\n             id: hir::CRATE_HIR_ID,\n             where_outer: rustc_span::DUMMY_SP,\n             where_inner: rustc_span::DUMMY_SP,\n-            imports: Vec::new(),\n             mods: Vec::new(),\n             items: Vec::new(),\n             foreigns: Vec::new(),\n@@ -48,17 +45,6 @@ crate enum StructType {\n     Unit,\n }\n \n-#[derive(Debug)]\n-crate struct Import<'hir> {\n-    crate name: Symbol,\n-    crate id: hir::HirId,\n-    crate vis: &'hir hir::Visibility<'hir>,\n-    crate attrs: &'hir [ast::Attribute],\n-    crate path: &'hir hir::Path<'hir>,\n-    crate glob: bool,\n-    crate span: Span,\n-}\n-\n crate fn struct_type_from_def(vdata: &hir::VariantData<'_>) -> StructType {\n     match *vdata {\n         hir::VariantData::Struct(..) => Plain,"}, {"sha": "7d161ca3648ccabfd5630d597e0803f145212f7c", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -316,15 +316,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     }\n                 }\n \n-                om.imports.push(Import {\n-                    name,\n-                    id: item.hir_id,\n-                    vis: &item.vis,\n-                    attrs: &item.attrs,\n-                    path,\n-                    glob: is_glob,\n-                    span: item.span,\n-                });\n+                om.items.push((item, renamed))\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 om.mods.push(self.visit_mod_contents("}, {"sha": "6a921266336e0add8cd8604af5058d8e8530c3ba", "filename": "src/test/rustdoc-json/compare.py", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Frustdoc-json%2Fcompare.py", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Frustdoc-json%2Fcompare.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fcompare.py?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -7,6 +7,9 @@\n # and then create `yourtest.expected` by stripping unnecessary details from `yourtest.json`. If\n # you're on windows, replace `\\` with `/`.\n \n+# WARNING: The error messages produced by this may be misleading, in the case of list re-ordering\n+#          it may point to apparently unrelated keys.\n+\n import copy\n import sys\n import json"}, {"sha": "80070e75f1e5eae657ae68a5a33495d93bc67abe", "filename": "src/test/rustdoc-json/nested.expected", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Frustdoc-json%2Fnested.expected", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Frustdoc-json%2Fnested.expected", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fnested.expected?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -41,8 +41,8 @@\n       \"inner\": {\n         \"is_crate\": false,\n         \"items\": [\n-          \"0:7\",\n-          \"0:4\"\n+          \"0:4\",\n+          \"0:7\"\n         ]\n       },\n       \"kind\": \"module\","}, {"sha": "8983439bb64d35a215ac1fe523e73a15389296e2", "filename": "src/test/rustdoc-ui/issue-80992.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Frustdoc-ui%2Fissue-80992.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Frustdoc-ui%2Fissue-80992.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-80992.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+// compile-flags:--test\n+// normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n+// normalize-stdout-test \"finished in \\d+\\.\\d+s\" -> \"finished in $$TIME\"\n+\n+pub fn test() -> Result<(), ()> {\n+    //! ```compile_fail\n+    //! fn test() -> Result< {}\n+    //! ```\n+    Ok(())\n+}"}, {"sha": "1dd19f468274c4d162b270545868e292464d2511", "filename": "src/test/rustdoc-ui/issue-80992.stdout", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Frustdoc-ui%2Fissue-80992.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Frustdoc-ui%2Fissue-80992.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-80992.stdout?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -0,0 +1,6 @@\n+\n+running 1 test\n+test $DIR/issue-80992.rs - test (line 7) ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in $TIME\n+"}, {"sha": "25b0d5a56bfb3e49a836f73930f4c61d5f370ea8", "filename": "src/test/ui/associated-item/associated-item-two-bounds.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Fassociated-item%2Fassociated-item-two-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Fassociated-item%2Fassociated-item-two-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-item%2Fassociated-item-two-bounds.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -0,0 +1,16 @@\n+// This test is a regression test for #34792\n+\n+// check-pass\n+\n+pub struct A;\n+pub struct B;\n+\n+pub trait Foo {\n+    type T: PartialEq<A> + PartialEq<B>;\n+}\n+\n+pub fn generic<F: Foo>(t: F::T, a: A, b: B) -> bool {\n+    t == a && t == b\n+}\n+\n+pub fn main() {}"}, {"sha": "36f7160198526d66a3cda0b3b63b457c2235379b", "filename": "src/test/ui/async-await/issues/issue-78938-async-block.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78938-async-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78938-async-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78938-async-block.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -0,0 +1,33 @@\n+// edition:2018\n+\n+use std::{sync::Arc, future::Future, pin::Pin, task::{Context, Poll}};\n+\n+async fn f() {\n+    let room_ref = Arc::new(Vec::new());\n+\n+    let gameloop_handle = spawn(async { //~ ERROR E0373\n+        game_loop(Arc::clone(&room_ref))\n+    });\n+    gameloop_handle.await;\n+}\n+\n+fn game_loop(v: Arc<Vec<usize>>) {}\n+\n+fn spawn<F>(future: F) -> JoinHandle\n+where\n+    F: Future + Send + 'static,\n+    F::Output: Send + 'static,\n+{\n+    loop {}\n+}\n+\n+struct JoinHandle;\n+\n+impl Future for JoinHandle {\n+    type Output = ();\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        loop {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "01ffc48d6542ec83af40d35ed438dae39ae41469", "filename": "src/test/ui/async-await/issues/issue-78938-async-block.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78938-async-block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78938-async-block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78938-async-block.stderr?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -0,0 +1,21 @@\n+error[E0373]: async block may outlive the current function, but it borrows `room_ref`, which is owned by the current function\n+  --> $DIR/issue-78938-async-block.rs:8:39\n+   |\n+LL |       let gameloop_handle = spawn(async {\n+   |  _______________________________________^\n+LL | |         game_loop(Arc::clone(&room_ref))\n+   | |                               -------- `room_ref` is borrowed here\n+LL | |     });\n+   | |_____^ may outlive borrowed value `room_ref`\n+   |\n+   = note: async blocks are not executed immediately and must either take a reference or ownership of outside variables they use\n+help: to force the async block to take ownership of `room_ref` (and any other referenced variables), use the `move` keyword\n+   |\n+LL |     let gameloop_handle = spawn(async move {\n+LL |         game_loop(Arc::clone(&room_ref))\n+LL |     });\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0373`."}, {"sha": "4b42f9d4cd58009c7e22614dae3396354b2bcca8", "filename": "src/test/ui/borrowck/move-in-pattern-mut-in-loop.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut-in-loop.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -0,0 +1,10 @@\n+// Regression test for #80913.\n+\n+fn main() {\n+    let mut x = 42_i32;\n+    let mut opt = Some(&mut x);\n+    for _ in 0..5 {\n+        if let Some(mut _x) = opt {}\n+        //~^ ERROR: use of moved value\n+    }\n+}"}, {"sha": "9373e4d95fccdd83c88df95d2e30c7050870206f", "filename": "src/test/ui/borrowck/move-in-pattern-mut-in-loop.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut-in-loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut-in-loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-in-pattern-mut-in-loop.stderr?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -0,0 +1,15 @@\n+error[E0382]: use of moved value\n+  --> $DIR/move-in-pattern-mut-in-loop.rs:7:21\n+   |\n+LL |         if let Some(mut _x) = opt {}\n+   |                     ^^^^^^ value moved here, in previous iteration of loop\n+   |\n+   = note: move occurs because value has type `&mut i32`, which does not implement the `Copy` trait\n+help: borrow this field in the pattern to avoid moving `opt.0`\n+   |\n+LL |         if let Some(ref mut _x) = opt {}\n+   |                     ^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "63159ed05532fb77cf64493ebe2c9dff300d5131", "filename": "src/test/ui/feature-gates/feature-gate-const_refs_to_cell.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_refs_to_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_refs_to_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_refs_to_cell.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "previous_filename": "src/test/ui/feature-gate/feature-gate-const_refs_to_cell.rs"}, {"sha": "bd8a21ea36acd6212df2ed7b6759a53bc0148378", "filename": "src/test/ui/feature-gates/feature-gate-edition_macro_pats.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-edition_macro_pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-edition_macro_pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-edition_macro_pats.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "previous_filename": "src/test/ui/feature-gate-edition_macro_pats.rs"}, {"sha": "89bfb239d9ecaa7d99507b5bfc5a3016f668eb27", "filename": "src/test/ui/feature-gates/feature-gate-edition_macro_pats.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-edition_macro_pats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-edition_macro_pats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-edition_macro_pats.stderr?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "previous_filename": "src/test/ui/feature-gate-edition_macro_pats.stderr"}, {"sha": "c818f2976e1cf21899ed685eba16037de9125da7", "filename": "src/test/ui/mir/ssa-analysis-regression-50041.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Fmir%2Fssa-analysis-regression-50041.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Fmir%2Fssa-analysis-regression-50041.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fssa-analysis-regression-50041.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -0,0 +1,34 @@\n+// build-pass\n+// compile-flags: -Z mir-opt-level=3\n+\n+#![crate_type=\"lib\"]\n+#![feature(lang_items)]\n+#![no_std]\n+\n+#[lang = \"owned_box\"]\n+pub struct Box<T: ?Sized>(*mut T);\n+\n+impl<T: ?Sized> Drop for Box<T> {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+#[lang = \"box_free\"]\n+#[inline(always)]\n+unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n+    dealloc(ptr)\n+}\n+\n+#[inline(never)]\n+fn dealloc<T: ?Sized>(_: *mut T) {\n+}\n+\n+pub struct Foo<T>(T);\n+\n+pub fn foo(a: Option<Box<Foo<usize>>>) -> usize {\n+    let f = match a {\n+        None => Foo(0),\n+        Some(vec) => *vec,\n+    };\n+    f.0\n+}"}, {"sha": "a4adfa6d0446171d4a6e602170e4319177fff39d", "filename": "src/test/ui/wasm/wasm-hang-issue-76281.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Fwasm%2Fwasm-hang-issue-76281.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6518427e11e6dd13d6f39663b82eb4f810ca05/src%2Ftest%2Fui%2Fwasm%2Fwasm-hang-issue-76281.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwasm%2Fwasm-hang-issue-76281.rs?ref=8a6518427e11e6dd13d6f39663b82eb4f810ca05", "patch": "@@ -0,0 +1,12 @@\n+// only-wasm32\n+// compile-flags: -C opt-level=2\n+// build-pass\n+\n+// Regression test for #76281.\n+// This seems like an issue related to LLVM rather than\n+// libs-impl so place here.\n+\n+fn main() {\n+    let mut v: Vec<&()> = Vec::new();\n+    v.sort_by_key(|&r| r as *const ());\n+}"}]}