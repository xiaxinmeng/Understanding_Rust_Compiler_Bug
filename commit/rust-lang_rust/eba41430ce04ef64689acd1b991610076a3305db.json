{"sha": "eba41430ce04ef64689acd1b991610076a3305db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViYTQxNDMwY2UwNGVmNjQ2ODlhY2QxYjk5MTYxMDA3NmEzMzA1ZGI=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-03-11T21:14:43Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-03-11T21:14:43Z"}, "message": "Merge branch 'aochagavia-indexing_slicing'", "tree": {"sha": "082e4e885e84d1625c352591f72cf34fe59c654b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/082e4e885e84d1625c352591f72cf34fe59c654b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eba41430ce04ef64689acd1b991610076a3305db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eba41430ce04ef64689acd1b991610076a3305db", "html_url": "https://github.com/rust-lang/rust/commit/eba41430ce04ef64689acd1b991610076a3305db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eba41430ce04ef64689acd1b991610076a3305db/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f255734bae43e4d9769308439b3881aeb70fa854", "url": "https://api.github.com/repos/rust-lang/rust/commits/f255734bae43e4d9769308439b3881aeb70fa854", "html_url": "https://github.com/rust-lang/rust/commit/f255734bae43e4d9769308439b3881aeb70fa854"}, {"sha": "2f13c3bdefefb7947049ed51edde8db341994164", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f13c3bdefefb7947049ed51edde8db341994164", "html_url": "https://github.com/rust-lang/rust/commit/2f13c3bdefefb7947049ed51edde8db341994164"}], "stats": {"total": 171, "additions": 141, "deletions": 30}, "files": [{"sha": "48a106e3591d3a8b6f8d8c573eccef5efc6fc26a", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eba41430ce04ef64689acd1b991610076a3305db/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/eba41430ce04ef64689acd1b991610076a3305db/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=eba41430ce04ef64689acd1b991610076a3305db", "patch": "@@ -11,7 +11,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to link with clippy-service](#link-with-clippy-service)\n \n ##Lints\n-There are 133 lints included in this crate:\n+There are 134 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -58,6 +58,7 @@ name\n [if_not_else](https://github.com/Manishearth/rust-clippy/wiki#if_not_else)                                           | warn    | finds if branches that could be swapped so no negation operation is necessary on the condition\n [if_same_then_else](https://github.com/Manishearth/rust-clippy/wiki#if_same_then_else)                               | warn    | if with the same *then* and *else* blocks\n [ifs_same_cond](https://github.com/Manishearth/rust-clippy/wiki#ifs_same_cond)                                       | warn    | consecutive `ifs` with the same condition\n+[indexing_slicing](https://github.com/Manishearth/rust-clippy/wiki#indexing_slicing)                                 | allow   | indexing/slicing usage\n [ineffective_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask)                         | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n [inline_always](https://github.com/Manishearth/rust-clippy/wiki#inline_always)                                       | warn    | `#[inline(always)]` is a bad idea in most cases\n [invalid_regex](https://github.com/Manishearth/rust-clippy/wiki#invalid_regex)                                       | deny    | finds invalid regular expressions in `Regex::new(_)` invocations\n@@ -234,7 +235,7 @@ And, in your `main.rs` or `lib.rs`:\n \n Both projects are independent and maintained by different people (even if some `clippy-service`'s contributions are authored by some `rust-clippy` members).\n \n-You can check it out this great service at [clippy.bashy.io](https://clippy.bashy.io/)\n+You can check it out this great service at [clippy.bashy.io](https://clippy.bashy.io/).\n \n ##License\n Licensed under [MPL](https://www.mozilla.org/MPL/2.0/). If you're having issues with the license, let me know and I'll try to change it to something more permissive."}, {"sha": "274491b7c963bd7a6e940933da9b6fb611d0bcc6", "filename": "src/array_indexing.rs", "status": "modified", "additions": 95, "deletions": 7, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/eba41430ce04ef64689acd1b991610076a3305db/src%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba41430ce04ef64689acd1b991610076a3305db/src%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farray_indexing.rs?ref=eba41430ce04ef64689acd1b991610076a3305db", "patch": "@@ -3,7 +3,8 @@ use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n use rustc::middle::const_eval::{eval_const_expr_partial, ConstVal};\n use rustc::middle::ty::TyArray;\n use rustc_front::hir::*;\n-use utils::span_lint;\n+use syntax::ast::RangeLimits;\n+use utils;\n \n /// **What it does:** Check for out of bounds array indexing with a constant index.\n ///\n@@ -17,35 +18,122 @@ use utils::span_lint;\n /// let x = [1,2,3,4];\n /// ...\n /// x[9];\n+/// &x[2..9];\n /// ```\n declare_lint! {\n     pub OUT_OF_BOUNDS_INDEXING,\n     Deny,\n     \"out of bound constant indexing\"\n }\n \n+/// **What it does:** Check for usage of indexing or slicing.\n+///\n+/// **Why is this bad?** Usually, this can be safely allowed. However,\n+/// in some domains such as kernel development, a panic can cause the\n+/// whole operating system to crash.\n+///\n+/// **Known problems:** Hopefully none.\n+///\n+/// **Example:**\n+///\n+/// ```\n+/// ...\n+/// x[2];\n+/// &x[0..2];\n+/// ```\n+declare_lint! {\n+    pub INDEXING_SLICING,\n+    Allow,\n+    \"indexing/slicing usage\"\n+}\n+\n #[derive(Copy,Clone)]\n pub struct ArrayIndexing;\n \n impl LintPass for ArrayIndexing {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(OUT_OF_BOUNDS_INDEXING)\n+        lint_array!(INDEXING_SLICING, OUT_OF_BOUNDS_INDEXING)\n     }\n }\n \n impl LateLintPass for ArrayIndexing {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprIndex(ref array, ref index) = e.node {\n+            // Array with known size can be checked statically\n             let ty = cx.tcx.expr_ty(array);\n-\n             if let TyArray(_, size) = ty.sty {\n-                let index = eval_const_expr_partial(cx.tcx, &index, ExprTypeChecked, None);\n-                if let Ok(ConstVal::Uint(index)) = index {\n-                    if size as u64 <= index {\n-                        span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"const index-expr is out of bounds\");\n+                let size = size as u64;\n+\n+                // Index is a constant uint\n+                let const_index = eval_const_expr_partial(cx.tcx, &index, ExprTypeChecked, None);\n+                if let Ok(ConstVal::Uint(const_index)) = const_index {\n+                    if size <= const_index {\n+                        utils::span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"const index is out of bounds\");\n+                    }\n+\n+                    return;\n+                }\n+\n+                // Index is a constant range\n+                if let Some(range) = utils::unsugar_range(index) {\n+                    let start = range.start.map(|start|\n+                        eval_const_expr_partial(cx.tcx, start, ExprTypeChecked, None)).map(|v| v.ok());\n+                    let end = range.end.map(|end|\n+                        eval_const_expr_partial(cx.tcx, end, ExprTypeChecked, None)).map(|v| v.ok());\n+\n+                    if let Some((start, end)) = to_const_range(start, end, range.limits, size) {\n+                        if start >= size || end >= size {\n+                            utils::span_lint(cx,\n+                                             OUT_OF_BOUNDS_INDEXING,\n+                                             e.span,\n+                                             \"range is out of bounds\");\n+                        }\n+                        return;\n                     }\n                 }\n             }\n+\n+            if let Some(range) = utils::unsugar_range(index) {\n+                // Full ranges are always valid\n+                if range.start.is_none() && range.end.is_none() {\n+                    return;\n+                }\n+\n+                // Impossible to know if indexing or slicing is correct\n+                utils::span_lint(cx, INDEXING_SLICING, e.span, \"slicing may panic\");\n+            } else {\n+                utils::span_lint(cx, INDEXING_SLICING, e.span, \"indexing may panic\");\n+            }\n         }\n     }\n }\n+\n+/// Returns an option containing a tuple with the start and end (exclusive) of the range\n+///\n+/// Note: we assume the start and the end of the range are unsigned, since array slicing\n+/// works only on usize\n+fn to_const_range(start: Option<Option<ConstVal>>,\n+                    end: Option<Option<ConstVal>>,\n+                    limits: RangeLimits,\n+                    array_size: u64)\n+                    -> Option<(u64, u64)> {\n+    let start = match start {\n+        Some(Some(ConstVal::Uint(x))) => x,\n+        Some(_) => return None,\n+        None => 0,\n+    };\n+\n+    let end = match end {\n+        Some(Some(ConstVal::Uint(x))) => {\n+            if limits == RangeLimits::Closed {\n+                x\n+            } else {\n+                x - 1\n+            }\n+        }\n+        Some(_) => return None,\n+        None => array_size - 1,\n+    };\n+\n+    Some((start, end))\n+}"}, {"sha": "4b9d5d8c9c4a4832c9e20bb6e7f5e2dcf8fbdb82", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eba41430ce04ef64689acd1b991610076a3305db/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba41430ce04ef64689acd1b991610076a3305db/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=eba41430ce04ef64689acd1b991610076a3305db", "patch": "@@ -2,7 +2,7 @@\n #![feature(rustc_private, collections)]\n #![feature(iter_arith)]\n #![feature(custom_attribute)]\n-#![allow(unknown_lints)]\n+#![allow(indexing_slicing, shadow_reuse, unknown_lints)]\n \n // this only exists to allow the \"dogfood\" integration test to work\n #[allow(dead_code)]\n@@ -181,6 +181,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box new_without_default::NewWithoutDefault);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n+        array_indexing::INDEXING_SLICING,\n         enum_glob_use::ENUM_GLOB_USE,\n         matches::SINGLE_MATCH_ELSE,\n         methods::OPTION_UNWRAP_USED,"}, {"sha": "625e8da197d573b2c93a14e44ae622a32b5d6c2e", "filename": "src/utils/mod.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/eba41430ce04ef64689acd1b991610076a3305db/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba41430ce04ef64689acd1b991610076a3305db/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=eba41430ce04ef64689acd1b991610076a3305db", "patch": "@@ -681,6 +681,7 @@ pub fn camel_case_from(s: &str) -> usize {\n }\n \n /// Represents a range akin to `ast::ExprKind::Range`.\n+#[derive(Debug, Copy, Clone)]\n pub struct UnsugaredRange<'a> {\n     pub start: Option<&'a Expr>,\n     pub end: Option<&'a Expr>,\n@@ -711,24 +712,30 @@ pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n         Some(unwrap_unstable(expr))\n     }\n \n-    if let ExprStruct(ref path, ref fields, None) = unwrap_unstable(&expr).node {\n-        if match_path(path, &RANGE_FROM_PATH) {\n-            Some(UnsugaredRange { start: get_field(\"start\", fields), end: None, limits: RangeLimits::HalfOpen })\n-        } else if match_path(path, &RANGE_FULL_PATH) {\n-            Some(UnsugaredRange { start: None, end: None, limits: RangeLimits::HalfOpen })\n-        } else if match_path(path, &RANGE_INCLUSIVE_NON_EMPTY_PATH) {\n-            Some(UnsugaredRange { start: get_field(\"start\", fields), end: get_field(\"end\", fields), limits: RangeLimits::Closed })\n-        } else if match_path(path, &RANGE_PATH) {\n-            Some(UnsugaredRange { start: get_field(\"start\", fields), end: get_field(\"end\", fields), limits: RangeLimits::HalfOpen })\n-        } else if match_path(path, &RANGE_TO_INCLUSIVE_PATH) {\n-            Some(UnsugaredRange { start: None, end: get_field(\"end\", fields), limits: RangeLimits::Closed })\n-        } else if match_path(path, &RANGE_TO_PATH) {\n-            Some(UnsugaredRange { start: None, end: get_field(\"end\", fields), limits: RangeLimits::HalfOpen })\n-        } else {\n-            None\n+    match unwrap_unstable(&expr).node {\n+        ExprPath(None, ref path) => {\n+            if match_path(path, &RANGE_FULL_PATH) {\n+                Some(UnsugaredRange { start: None, end: None, limits: RangeLimits::HalfOpen })\n+            } else {\n+                None\n+            }\n         }\n-    } else {\n-        None\n+        ExprStruct(ref path, ref fields, None) => {\n+            if match_path(path, &RANGE_FROM_PATH) {\n+                Some(UnsugaredRange { start: get_field(\"start\", fields), end: None, limits: RangeLimits::HalfOpen })\n+            } else if match_path(path, &RANGE_INCLUSIVE_NON_EMPTY_PATH) {\n+                Some(UnsugaredRange { start: get_field(\"start\", fields), end: get_field(\"end\", fields), limits: RangeLimits::Closed })\n+            } else if match_path(path, &RANGE_PATH) {\n+                Some(UnsugaredRange { start: get_field(\"start\", fields), end: get_field(\"end\", fields), limits: RangeLimits::HalfOpen })\n+            } else if match_path(path, &RANGE_TO_INCLUSIVE_PATH) {\n+                Some(UnsugaredRange { start: None, end: get_field(\"end\", fields), limits: RangeLimits::Closed })\n+            } else if match_path(path, &RANGE_TO_PATH) {\n+                Some(UnsugaredRange { start: None, end: get_field(\"end\", fields), limits: RangeLimits::HalfOpen })\n+            } else {\n+                None\n+            }\n+        }\n+        _ => None,\n     }\n }\n "}, {"sha": "14f3448a9f671b24aebc10625adc3c4696ed612a", "filename": "tests/compile-fail/array_indexing.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/eba41430ce04ef64689acd1b991610076a3305db/tests%2Fcompile-fail%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eba41430ce04ef64689acd1b991610076a3305db/tests%2Fcompile-fail%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Farray_indexing.rs?ref=eba41430ce04ef64689acd1b991610076a3305db", "patch": "@@ -1,13 +1,27 @@\n-#![feature(plugin)]\n+#![feature(inclusive_range_syntax, plugin)]\n #![plugin(clippy)]\n \n+#![deny(indexing_slicing)]\n #![deny(out_of_bounds_indexing)]\n #![allow(no_effect)]\n \n fn main() {\n     let x = [1,2,3,4];\n     x[0];\n     x[3];\n-    x[4]; //~ERROR: const index-expr is out of bounds\n-    x[1 << 3]; //~ERROR: const index-expr is out of bounds\n+    x[4]; //~ERROR: const index is out of bounds\n+    x[1 << 3]; //~ERROR: const index is out of bounds\n+    &x[1..5]; //~ERROR: range is out of bounds\n+    &x[0..3];\n+    &x[0...4]; //~ERROR: range is out of bounds\n+    &x[..];\n+    &x[1..];\n+    &x[..4];\n+    &x[..5]; //~ERROR: range is out of bounds\n+\n+    let y = &x;\n+    y[0]; //~ERROR: indexing may panic\n+    &y[1..2]; //~ERROR: slicing may panic\n+    &y[..];\n+    &y[0...4]; //~ERROR: slicing may panic\n }"}]}