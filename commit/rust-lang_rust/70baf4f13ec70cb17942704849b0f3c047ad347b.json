{"sha": "70baf4f13ec70cb17942704849b0f3c047ad347b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwYmFmNGYxM2VjNzBjYjE3OTQyNzA0ODQ5YjBmM2MwNDdhZDM0N2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-28T00:48:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-28T00:48:57Z"}, "message": "Auto merge of #41591 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 7 pull requests\n\n- Successful merges: #41438, #41523, #41526, #41546, #41556, #41572, #41578\n- Failed merges:", "tree": {"sha": "2adcdc1b2e40a51daac40728615a44bb2c222ee7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2adcdc1b2e40a51daac40728615a44bb2c222ee7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70baf4f13ec70cb17942704849b0f3c047ad347b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70baf4f13ec70cb17942704849b0f3c047ad347b", "html_url": "https://github.com/rust-lang/rust/commit/70baf4f13ec70cb17942704849b0f3c047ad347b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70baf4f13ec70cb17942704849b0f3c047ad347b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8ebd083fcc7120f8fffffa061525bb225a3e17b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8ebd083fcc7120f8fffffa061525bb225a3e17b", "html_url": "https://github.com/rust-lang/rust/commit/a8ebd083fcc7120f8fffffa061525bb225a3e17b"}, {"sha": "1cd3d2f1c40ddf88351af96891f9ab7035130a9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cd3d2f1c40ddf88351af96891f9ab7035130a9a", "html_url": "https://github.com/rust-lang/rust/commit/1cd3d2f1c40ddf88351af96891f9ab7035130a9a"}], "stats": {"total": 465, "additions": 395, "deletions": 70}, "files": [{"sha": "659feef80a4b9a276d7554a01b92089733c82063", "filename": "src/Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -269,7 +269,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.0.19\"\n+version = \"0.0.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"clap 2.22.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -425,7 +425,7 @@ name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n  \"clap 2.22.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"mdbook 0.0.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"mdbook 0.0.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1001,7 +1001,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum lazy_static 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4732c563b9a21a406565c4747daa7b46742f082911ae4753f390dc9ec7ee1a97\"\n \"checksum libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"88ee81885f9f04bff991e306fea7c1c60a5f0f9e409e99f6b40e3311a3363135\"\n \"checksum log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5141eca02775a762cc6cd564d8d2c50f67c0ea3a372cbf1c51592b3e029e10ad\"\n-\"checksum mdbook 0.0.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2598843aeda0c5bb2e8e4d714564f1c3fc40f7844157e34563bf96ae3866b56e\"\n+\"checksum mdbook 0.0.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f1e2e9d848514dcfad4195788d0d42ae5153a477c191d75d5b84fab10f222fbd\"\n \"checksum memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1dbccc0e46f1ea47b9f17e6d67c5a96bd27030519c519c9c91327e31275a47b4\"\n \"checksum num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e1cbfa3781f3fe73dc05321bed52a06d2d491eaa764c52335cf4399f046ece99\"\n \"checksum num_cpus 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca313f1862c7ec3e0dfe8ace9fa91b1d9cb5c84ace3d00f5ec4216238e93c167\""}, {"sha": "9db6dffb0e8cc5964eaea14c66f09683feb6274e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -451,7 +451,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 // So peel off one-level, turning the &T into T.\n                 match base_ty.builtin_deref(false, ty::NoPreference) {\n                     Some(t) => t.ty,\n-                    None => { return Err(()); }\n+                    None => {\n+                        debug!(\"By-ref binding of non-derefable type {:?}\", base_ty);\n+                        return Err(());\n+                    }\n                 }\n             }\n             _ => base_ty,\n@@ -1039,6 +1042,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 match base_cmt.ty.builtin_index() {\n                     Some(ty) => (ty, ElementKind::VecElement),\n                     None => {\n+                        debug!(\"Explicit index of non-indexable type {:?}\", base_cmt);\n                         return Err(());\n                     }\n                 }\n@@ -1154,7 +1158,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n             PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n                 match path.def {\n-                    Def::Err => return Err(()),\n+                    Def::Err => {\n+                        debug!(\"access to unresolvable pattern {:?}\", pat);\n+                        return Err(())\n+                    }\n                     Def::Variant(variant_did) |\n                     Def::VariantCtor(variant_did, ..) => {\n                         // univariant enums do not need downcasts"}, {"sha": "ebe2de584095461acf5e9fcdaac5734e479c3738", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -11,6 +11,7 @@\n use borrowck::BorrowckCtxt;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n+use rustc::middle::mem_categorization::NoteClosureEnv;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::ty;\n use syntax::ast;\n@@ -71,10 +72,12 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         let mut err = report_cannot_move_out_of(bccx, error.move_from.clone());\n         let mut is_first_note = true;\n         for move_to in &error.move_to_places {\n-            err = note_move_destination(err, move_to.span,\n-                                  move_to.name, is_first_note);\n+            err = note_move_destination(err, move_to.span, move_to.name, is_first_note);\n             is_first_note = false;\n         }\n+        if let NoteClosureEnv(upvar_id) = error.move_from.note {\n+            err.span_label(bccx.tcx.hir.span(upvar_id.var_id), &\"captured outer variable\");\n+        }\n         err.emit();\n     }\n }"}, {"sha": "cc8012d965a76a347ac3dcdb9407976122a9063c", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -375,6 +375,9 @@ impl Handler {\n         panic!(ExplicitBug);\n     }\n     pub fn delay_span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n+        if self.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n         let mut delayed = self.delayed_span_bug.borrow_mut();\n         *delayed = Some((sp.into(), msg.to_string()));\n     }"}, {"sha": "e81805b96609b2c2333f360e56c41bd4247707b2", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -516,6 +516,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     };\n \n                     let index_expr_ty = self.node_ty(index_expr.id);\n+                    let adjusted_base_ty = self.resolve_type_vars_if_possible(&adjusted_base_ty);\n+                    let index_expr_ty = self.resolve_type_vars_if_possible(&index_expr_ty);\n \n                     let result = self.try_index_step(ty::MethodCall::expr(expr.id),\n                                                      expr,\n@@ -531,6 +533,15 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n                         let expr_ty = self.node_ty(expr.id);\n                         self.demand_suptype(expr.span, expr_ty, return_ty);\n+                    } else {\n+                        // We could not perform a mutable index. Re-apply the\n+                        // immutable index adjustments - borrowck will detect\n+                        // this as an error.\n+                        if let Some(adjustment) = adjustment {\n+                            self.apply_adjustment(expr.id, adjustment);\n+                        }\n+                        self.tcx.sess.delay_span_bug(\n+                            expr.span, \"convert_lvalue_derefs_to_mutable failed\");\n                     }\n                 }\n                 hir::ExprUnary(hir::UnDeref, ref base_expr) => {"}, {"sha": "34229f80769aba8108f10553346af51b271cab35", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -72,24 +72,23 @@ pub struct TcpStream(net_imp::TcpStream);\n ///\n /// # Examples\n ///\n-/// ```no_run\n+/// ```\n+/// # use std::io;\n /// use std::net::{TcpListener, TcpStream};\n ///\n-/// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n-///\n /// fn handle_client(stream: TcpStream) {\n ///     // ...\n /// }\n ///\n+/// # fn process() -> io::Result<()> {\n+/// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+///\n /// // accept connections and process them serially\n /// for stream in listener.incoming() {\n-///     match stream {\n-///         Ok(stream) => {\n-///             handle_client(stream);\n-///         }\n-///         Err(e) => { /* connection failed */ }\n-///     }\n+///     handle_client(stream?);\n /// }\n+/// # Ok(())\n+/// # }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct TcpListener(net_imp::TcpListener);"}, {"sha": "2cb649ce67b9c0c1cc8e26b8d5b5d8c533a12680", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 254, "deletions": 29, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -297,12 +297,14 @@ mod sync;\n mod mpsc_queue;\n mod spsc_queue;\n \n-/// The receiving-half of Rust's channel type. This half can only be owned by\n-/// one thread.\n+/// The receiving half of Rust's [`channel`][] (or [`sync_channel`]) type.\n+/// This half can only be owned by one thread.\n ///\n /// Messages sent to the channel can be retrieved using [`recv`].\n ///\n-/// [`recv`]: ../../../std/sync/mpsc/struct.Receiver.html#method.recv\n+/// [`channel`]: fn.channel.html\n+/// [`sync_channel`]: fn.sync_channel.html\n+/// [`recv`]: struct.Receiver.html#method.recv\n ///\n /// # Examples\n ///\n@@ -336,51 +338,128 @@ unsafe impl<T: Send> Send for Receiver<T> { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> !Sync for Receiver<T> { }\n \n-/// An iterator over messages on a receiver, this iterator will block whenever\n-/// [`next`] is called, waiting for a new message, and [`None`] will be returned\n+/// An iterator over messages on a [`Receiver`], created by [`iter`].\n+///\n+/// This iterator will block whenever [`next`] is called,\n+/// waiting for a new message, and [`None`] will be returned\n /// when the corresponding channel has hung up.\n ///\n+/// [`iter`]: struct.Receiver.html#method.iter\n+/// [`Receiver`]: struct.Receiver.html\n /// [`next`]: ../../../std/iter/trait.Iterator.html#tymethod.next\n /// [`None`]: ../../../std/option/enum.Option.html#variant.None\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// use std::sync::mpsc::channel;\n+/// use std::thread;\n+///\n+/// let (send, recv) = channel();\n+///\n+/// thread::spawn(move || {\n+///     send.send(1u8).unwrap();\n+///     send.send(2u8).unwrap();\n+///     send.send(3u8).unwrap();\n+/// });\n+///\n+/// for x in recv.iter() {\n+///     println!(\"Got: {}\", x);\n+/// }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Iter<'a, T: 'a> {\n     rx: &'a Receiver<T>\n }\n \n-/// An iterator that attempts to yield all pending values for a receiver.\n-/// [`None`] will be returned when there are no pending values remaining or if\n-/// the corresponding channel has hung up.\n+/// An iterator that attempts to yield all pending values for a [`Receiver`],\n+/// created by [`try_iter`].\n+///\n+/// [`None`] will be returned when there are no pending values remaining or\n+/// if the corresponding channel has hung up.\n ///\n-/// This Iterator will never block the caller in order to wait for data to\n+/// This iterator will never block the caller in order to wait for data to\n /// become available. Instead, it will return [`None`].\n ///\n+/// [`Receiver`]: struct.Receiver.html\n+/// [`try_iter`]: struct.Receiver.html#method.try_iter\n /// [`None`]: ../../../std/option/enum.Option.html#variant.None\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// use std::sync::mpsc::channel;\n+/// use std::thread;\n+/// use std::time::Duration;\n+///\n+/// let (sender, receiver) = channel();\n+///\n+/// // Nothing is in the buffer yet\n+/// assert!(receiver.try_iter().next().is_none());\n+/// println!(\"Nothing in the buffer...\");\n+///\n+/// thread::spawn(move || {\n+///     sender.send(1).unwrap();\n+///     sender.send(2).unwrap();\n+///     sender.send(3).unwrap();\n+/// });\n+///\n+/// println!(\"Going to sleep...\");\n+/// thread::sleep(Duration::from_secs(2)); // block for two seconds\n+///\n+/// for x in receiver.try_iter() {\n+///     println!(\"Got: {}\", x);\n+/// }\n+/// ```\n #[stable(feature = \"receiver_try_iter\", since = \"1.15.0\")]\n #[derive(Debug)]\n pub struct TryIter<'a, T: 'a> {\n     rx: &'a Receiver<T>\n }\n \n-/// An owning iterator over messages on a receiver, this iterator will block\n-/// whenever [`next`] is called, waiting for a new message, and [`None`] will be\n-/// returned when the corresponding channel has hung up.\n+/// An owning iterator over messages on a [`Receiver`],\n+/// created by **Receiver::into_iter**.\n+///\n+/// This iterator will block whenever [`next`]\n+/// is called, waiting for a new message, and [`None`] will be\n+/// returned if the corresponding channel has hung up.\n ///\n+/// [`Receiver`]: struct.Receiver.html\n /// [`next`]: ../../../std/iter/trait.Iterator.html#tymethod.next\n /// [`None`]: ../../../std/option/enum.Option.html#variant.None\n ///\n+/// # Examples\n+///\n+/// ```rust\n+/// use std::sync::mpsc::channel;\n+/// use std::thread;\n+///\n+/// let (send, recv) = channel();\n+///\n+/// thread::spawn(move || {\n+///     send.send(1u8).unwrap();\n+///     send.send(2u8).unwrap();\n+///     send.send(3u8).unwrap();\n+/// });\n+///\n+/// for x in recv.into_iter() {\n+///     println!(\"Got: {}\", x);\n+/// }\n+/// ```\n #[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n #[derive(Debug)]\n pub struct IntoIter<T> {\n     rx: Receiver<T>\n }\n \n-/// The sending-half of Rust's asynchronous channel type. This half can only be\n+/// The sending-half of Rust's asynchronous [`channel`] type. This half can only be\n /// owned by one thread, but it can be cloned to send to other threads.\n ///\n /// Messages can be sent through this channel with [`send`].\n ///\n-/// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n+/// [`channel`]: fn.channel.html\n+/// [`send`]: struct.Sender.html#method.send\n ///\n /// # Examples\n ///\n@@ -419,12 +498,55 @@ unsafe impl<T: Send> Send for Sender<T> { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> !Sync for Sender<T> { }\n \n-/// The sending-half of Rust's synchronous channel type. This half can only be\n-/// owned by one thread, but it can be cloned to send to other threads.\n+/// The sending-half of Rust's synchronous [`sync_channel`] type.\n+/// This half can only be owned by one thread, but it can be cloned\n+/// to send to other threads.\n+///\n+/// Messages can be sent through this channel with [`send`] or [`try_send`].\n+///\n+/// [`send`] will block if there is no space in the internal buffer.\n+///\n+/// [`sync_channel`]: fn.sync_channel.html\n+/// [`send`]: struct.SyncSender.html#method.send\n+/// [`try_send`]: struct.SyncSender.html#method.try_send\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// use std::sync::mpsc::sync_channel;\n+/// use std::thread;\n ///\n-/// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n-/// [`SyncSender::send`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.send\n+/// // Create a sync_channel with buffer size 2\n+/// let (sync_sender, receiver) = sync_channel(2);\n+/// let sync_sender2 = sync_sender.clone();\n ///\n+/// // First thread owns sync_sender\n+/// thread::spawn(move || {\n+///     sync_sender.send(1).unwrap();\n+///     sync_sender.send(2).unwrap();\n+/// });\n+///\n+/// // Second thread owns sync_sender2\n+/// thread::spawn(move || {\n+///     sync_sender2.send(3).unwrap();\n+///     // thread will now block since the buffer is full\n+///     println!(\"Thread unblocked!\");\n+/// });\n+///\n+/// let mut msg;\n+///\n+/// msg = receiver.recv().unwrap();\n+/// println!(\"message {} received\", msg);\n+///\n+/// // \"Thread unblocked!\" will be printed now\n+///\n+/// msg = receiver.recv().unwrap();\n+/// println!(\"message {} received\", msg);\n+///\n+/// msg = receiver.recv().unwrap();\n+///\n+/// println!(\"message {} received\", msg);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SyncSender<T> {\n     inner: Arc<sync::Packet<T>>,\n@@ -823,15 +945,37 @@ impl<T> SyncSender<T> {\n     /// Note that a successful send does *not* guarantee that the receiver will\n     /// ever see the data if there is a buffer on this channel. Items may be\n     /// enqueued in the internal buffer for the receiver to receive at a later\n-    /// time. If the buffer size is 0, however, it can be guaranteed that the\n-    /// receiver has indeed received the data if this function returns success.\n+    /// time. If the buffer size is 0, however, the channel becomes a rendezvous\n+    /// channel and it guarantees that the receiver has indeed received\n+    /// the data if this function returns success.\n     ///\n     /// This function will never panic, but it may return [`Err`] if the\n     /// [`Receiver`] has disconnected and is no longer able to receive\n     /// information.\n     ///\n     /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n     /// [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::sync::mpsc::sync_channel;\n+    /// use std::thread;\n+    ///\n+    /// // Create a rendezvous sync_channel with buffer size 0\n+    /// let (sync_sender, receiver) = sync_channel(0);\n+    ///\n+    /// thread::spawn(move || {\n+    ///    println!(\"sending message...\");\n+    ///    sync_sender.send(1).unwrap();\n+    ///    // Thread is now blocked until the message is received\n+    ///\n+    ///    println!(\"...message received!\");\n+    /// });\n+    ///\n+    /// let msg = receiver.recv().unwrap();\n+    /// assert_eq!(1, msg);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n         self.inner.send(t).map_err(SendError)\n@@ -844,11 +988,48 @@ impl<T> SyncSender<T> {\n     /// data. Compared with [`send`], this function has two failure cases\n     /// instead of one (one for disconnection, one for a full buffer).\n     ///\n-    /// See [`SyncSender::send`] for notes about guarantees of whether the\n+    /// See [`send`] for notes about guarantees of whether the\n     /// receiver has received the data or not if this function is successful.\n     ///\n-    /// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n-    /// [`SyncSender::send`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.send\n+    /// [`send`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.send\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::sync::mpsc::sync_channel;\n+    /// use std::thread;\n+    ///\n+    /// // Create a sync_channel with buffer size 1\n+    /// let (sync_sender, receiver) = sync_channel(1);\n+    /// let sync_sender2 = sync_sender.clone();\n+    ///\n+    /// // First thread owns sync_sender\n+    /// thread::spawn(move || {\n+    ///     sync_sender.send(1).unwrap();\n+    ///     sync_sender.send(2).unwrap();\n+    ///     // Thread blocked\n+    /// });\n+    ///\n+    /// // Second thread owns sync_sender2\n+    /// thread::spawn(move || {\n+    ///     // This will return an error and send\n+    ///     // no message if the buffer is full\n+    ///     sync_sender2.try_send(3).is_err();\n+    /// });\n+    ///\n+    /// let mut msg;\n+    /// msg = receiver.recv().unwrap();\n+    /// println!(\"message {} received\", msg);\n+    ///\n+    /// msg = receiver.recv().unwrap();\n+    /// println!(\"message {} received\", msg);\n+    ///\n+    /// // Third message may have never been sent\n+    /// match receiver.try_recv() {\n+    ///     Ok(msg) => println!(\"message {} received\", msg),\n+    ///     Err(_) => println!(\"the third message was never sent\"),\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n         self.inner.try_send(t)\n@@ -894,6 +1075,21 @@ impl<T> Receiver<T> {\n     ///\n     /// This is useful for a flavor of \"optimistic check\" before deciding to\n     /// block on a receiver.\n+    ///\n+    /// Compared with [`recv`], this function has two failure cases instead of one\n+    /// (one for disconnection, one for an empty buffer).\n+    ///\n+    /// [`recv`]: struct.Receiver.html#method.recv\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::sync::mpsc::{Receiver, channel};\n+    ///\n+    /// let (_, receiver): (_, Receiver<i32>) = channel();\n+    ///\n+    /// assert!(receiver.try_recv().is_err());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n         loop {\n@@ -949,16 +1145,17 @@ impl<T> Receiver<T> {\n     ///\n     /// This function will always block the current thread if there is no data\n     /// available and it's possible for more data to be sent. Once a message is\n-    /// sent to the corresponding [`Sender`], then this receiver will wake up and\n-    /// return that message.\n+    /// sent to the corresponding [`Sender`][] (or [`SyncSender`]), then this\n+    /// receiver will wake up and return that message.\n     ///\n     /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n     /// this call is blocking, this call will wake up and return [`Err`] to\n     /// indicate that no more messages can ever be received on this channel.\n     /// However, since channels are buffered, messages sent before the disconnect\n     /// will still be properly received.\n     ///\n-    /// [`Sender`]: ../../../std/sync/mpsc/struct.Sender.html\n+    /// [`Sender`]: struct.Sender.html\n+    /// [`SyncSender`]: struct.SyncSender.html\n     /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n     ///\n     /// # Examples\n@@ -1040,16 +1237,17 @@ impl<T> Receiver<T> {\n     ///\n     /// This function will always block the current thread if there is no data\n     /// available and it's possible for more data to be sent. Once a message is\n-    /// sent to the corresponding [`Sender`], then this receiver will wake up and\n-    /// return that message.\n+    /// sent to the corresponding [`Sender`][] (or [`SyncSender`]), then this\n+    /// receiver will wake up and return that message.\n     ///\n     /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n     /// this call is blocking, this call will wake up and return [`Err`] to\n     /// indicate that no more messages can ever be received on this channel.\n     /// However, since channels are buffered, messages sent before the disconnect\n     /// will still be properly received.\n     ///\n-    /// [`Sender`]: ../../../std/sync/mpsc/struct.Sender.html\n+    /// [`Sender`]: struct.Sender.html\n+    /// [`SyncSender`]: struct.SyncSender.html\n     /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n     ///\n     /// # Examples\n@@ -1163,6 +1361,33 @@ impl<T> Receiver<T> {\n     /// user by waiting for values.\n     ///\n     /// [`panic!`]: ../../../std/macro.panic.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::sync::mpsc::channel;\n+    /// use std::thread;\n+    /// use std::time::Duration;\n+    ///\n+    /// let (sender, receiver) = channel();\n+    ///\n+    /// // Nothing is in the buffer yet\n+    /// assert!(receiver.try_iter().next().is_none());\n+    /// println!(\"Nothing in the buffer...\");\n+    ///\n+    /// thread::spawn(move || {\n+    ///     sender.send(1).unwrap();\n+    ///     sender.send(2).unwrap();\n+    ///     sender.send(3).unwrap();\n+    /// });\n+    ///\n+    /// println!(\"Going to sleep...\");\n+    /// thread::sleep(Duration::from_secs(2)); // block for two seconds\n+    ///\n+    /// for x in receiver.try_iter() {\n+    ///     println!(\"Got: {}\", x);\n+    /// }\n+    /// ```\n     #[stable(feature = \"receiver_try_iter\", since = \"1.15.0\")]\n     pub fn try_iter(&self) -> TryIter<T> {\n         TryIter { rx: self }"}, {"sha": "15745af7683844e43bdec966072b8e7b44772450", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -1 +1 @@\n-Subproject commit 878af191434cd716eeb13c2be7a2b1e21abf2749\n+Subproject commit 15745af7683844e43bdec966072b8e7b44772450"}, {"sha": "1006445ade6a1036cc3a4f71678e65b7ca3565b9", "filename": "src/rustllvm/llvm-rebuild-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Frustllvm%2Fllvm-rebuild-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Frustllvm%2Fllvm-rebuild-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-rebuild-trigger?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be (optionally) cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2017-04-25\n+2017-04-26"}, {"sha": "66fd30bdbbbe49616150c2f76fe47d229c616205", "filename": "src/test/run-pass/issue-41498.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftest%2Frun-pass%2Fissue-41498.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftest%2Frun-pass%2Fissue-41498.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41498.rs?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// regression test for issue #41498.\n+\n+struct S;\n+impl S {\n+    fn mutate(&mut self) {}\n+}\n+\n+fn call_and_ref<T, F: FnOnce() -> T>(x: &mut Option<T>, f: F) -> &mut T {\n+    *x = Some(f());\n+    x.as_mut().unwrap()\n+}\n+\n+fn main() {\n+    let mut n = None;\n+    call_and_ref(&mut n, || [S])[0].mutate();\n+}"}, {"sha": "9244c12347d952280cf449b80b14ce821fb49ef8", "filename": "src/test/ui/borrowck/borrowck-in-static.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-in-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-in-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-in-static.rs?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -11,7 +11,7 @@\n // check that borrowck looks inside consts/statics\n \n static FN : &'static (Fn() -> (Box<Fn()->Box<i32>>) + Sync) = &|| {\n-    let x = Box::new(0);\n+    let x = Box::new(0); //~ NOTE moved\n     Box::new(|| x) //~ ERROR cannot move out of captured outer variable\n };\n ", "previous_filename": "src/test/compile-fail/borrowck/borrowck-in-static.rs"}, {"sha": "6083a82b1b6de29eb926114b8b6a37a58b31884c", "filename": "src/test/ui/borrowck/borrowck-in-static.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-in-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-in-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-in-static.stderr?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -0,0 +1,10 @@\n+error[E0507]: cannot move out of captured outer variable in an `Fn` closure\n+  --> $DIR/borrowck-in-static.rs:15:17\n+   |\n+14 |     let x = Box::new(0); //~ NOTE moved\n+   |         - captured outer variable\n+15 |     Box::new(|| x) //~ ERROR cannot move out of captured outer variable\n+   |                 ^ cannot move out of captured outer variable in an `Fn` closure\n+\n+error: aborting due to previous error\n+"}, {"sha": "9c89c26de006a4a49ccd27c484391cf46190c8b1", "filename": "src/test/ui/borrowck/unboxed-closures-move-upvar-from-non-once-ref-closure.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftest%2Fui%2Fborrowck%2Funboxed-closures-move-upvar-from-non-once-ref-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftest%2Fui%2Fborrowck%2Funboxed-closures-move-upvar-from-non-once-ref-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Funboxed-closures-move-upvar-from-non-once-ref-closure.rs?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -16,7 +16,7 @@ fn call<F>(f: F) where F : Fn() {\n }\n \n fn main() {\n-    let y = vec![format!(\"World\")];\n+    let y = vec![format!(\"World\")];  //~ NOTE moved\n     call(|| {\n         y.into_iter();\n         //~^ ERROR cannot move out of captured outer variable in an `Fn` closure", "previous_filename": "src/test/compile-fail/unboxed-closures-move-upvar-from-non-once-ref-closure.rs"}, {"sha": "dbfcb2e0c2f95fbef0c71d52e7ed596c37c334eb", "filename": "src/test/ui/borrowck/unboxed-closures-move-upvar-from-non-once-ref-closure.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftest%2Fui%2Fborrowck%2Funboxed-closures-move-upvar-from-non-once-ref-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftest%2Fui%2Fborrowck%2Funboxed-closures-move-upvar-from-non-once-ref-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Funboxed-closures-move-upvar-from-non-once-ref-closure.stderr?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -0,0 +1,11 @@\n+error[E0507]: cannot move out of captured outer variable in an `Fn` closure\n+  --> $DIR/unboxed-closures-move-upvar-from-non-once-ref-closure.rs:21:9\n+   |\n+19 |     let y = vec![format!(\"World\")];  //~ NOTE moved\n+   |         - captured outer variable\n+20 |     call(|| {\n+21 |         y.into_iter();\n+   |         ^ cannot move out of captured outer variable in an `Fn` closure\n+\n+error: aborting due to previous error\n+"}, {"sha": "29fea052b06c2f0c447dde602dbf40d001f0a33c", "filename": "src/test/ui/span/borrowck-call-is-borrow-issue-12224.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.rs?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -21,8 +21,11 @@ struct Test<'a> {\n fn call<F>(mut f: F) where F: FnMut(Fn) {\n     f(Box::new(|| {\n     //~^ ERROR: cannot borrow `f` as mutable more than once\n+    //~| NOTE first mutable borrow occurs here\n+    //~| NOTE second mutable borrow occurs here\n         f((Box::new(|| {})))\n     }));\n+    //~^ NOTE first borrow ends here\n }\n \n fn test1() {\n@@ -32,15 +35,21 @@ fn test1() {\n }\n \n fn test2<F>(f: &F) where F: FnMut() {\n-    (*f)(); //~ ERROR: cannot borrow immutable borrowed content `*f` as mutable\n+    //~^ NOTE use `&mut F` here to make mutable\n+    (*f)();\n+    //~^ ERROR cannot borrow immutable borrowed content `*f` as mutable\n+    //~| NOTE cannot borrow as mutable\n }\n \n fn test3<F>(f: &mut F) where F: FnMut() {\n     (*f)();\n }\n \n fn test4(f: &Test) {\n-    f.f.call_mut(()) //~ ERROR: cannot borrow immutable `Box` content `*f.f` as mutable\n+    //~^ NOTE use `&mut Test` here to make mutable\n+    f.f.call_mut(())\n+    //~^ ERROR: cannot borrow immutable `Box` content `*f.f` as mutable\n+    //~| NOTE cannot borrow as mutable\n }\n \n fn test5(f: &mut Test) {\n@@ -57,10 +66,14 @@ fn test6() {\n fn test7() {\n     fn foo<F>(_: F) where F: FnMut(Box<FnMut(isize)>, isize) {}\n     let mut f = |g: Box<FnMut(isize)>, b: isize| {};\n+    //~^ NOTE moved\n     f(Box::new(|a| {\n+    //~^ NOTE borrow of `f` occurs here\n         foo(f);\n         //~^ ERROR cannot move `f` into closure because it is borrowed\n         //~| ERROR cannot move out of captured outer variable in an `FnMut` closure\n+        //~| NOTE move into closure occurs here\n+        //~| NOTE cannot move out of captured outer variable in an `FnMut` closure\n     }), 3);\n }\n "}, {"sha": "4ece8bc6af10fb06867356f608244c382ff823a5", "filename": "src/test/ui/span/borrowck-call-is-borrow-issue-12224.stderr", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.stderr?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -5,40 +5,46 @@ error[E0499]: cannot borrow `f` as mutable more than once at a time\n    |     -          ^^ second mutable borrow occurs here\n    |     |\n    |     first mutable borrow occurs here\n-23 |     //~^ ERROR: cannot borrow `f` as mutable more than once\n-24 |         f((Box::new(|| {})))\n+...\n+26 |         f((Box::new(|| {})))\n    |         - borrow occurs due to use of `f` in closure\n-25 |     }));\n+27 |     }));\n    |       - first borrow ends here\n \n error: cannot borrow immutable borrowed content `*f` as mutable\n-  --> $DIR/borrowck-call-is-borrow-issue-12224.rs:35:5\n+  --> $DIR/borrowck-call-is-borrow-issue-12224.rs:39:5\n    |\n-34 | fn test2<F>(f: &F) where F: FnMut() {\n+37 | fn test2<F>(f: &F) where F: FnMut() {\n    |                -- use `&mut F` here to make mutable\n-35 |     (*f)(); //~ ERROR: cannot borrow immutable borrowed content `*f` as mutable\n+38 |     //~^ NOTE use `&mut F` here to make mutable\n+39 |     (*f)();\n    |     ^^^^ cannot borrow as mutable\n \n error: cannot borrow immutable `Box` content `*f.f` as mutable\n-  --> $DIR/borrowck-call-is-borrow-issue-12224.rs:43:5\n+  --> $DIR/borrowck-call-is-borrow-issue-12224.rs:50:5\n    |\n-42 | fn test4(f: &Test) {\n+48 | fn test4(f: &Test) {\n    |             ----- use `&mut Test` here to make mutable\n-43 |     f.f.call_mut(()) //~ ERROR: cannot borrow immutable `Box` content `*f.f` as mutable\n+49 |     //~^ NOTE use `&mut Test` here to make mutable\n+50 |     f.f.call_mut(())\n    |     ^^^ cannot borrow as mutable\n \n error[E0504]: cannot move `f` into closure because it is borrowed\n-  --> $DIR/borrowck-call-is-borrow-issue-12224.rs:61:13\n+  --> $DIR/borrowck-call-is-borrow-issue-12224.rs:72:13\n    |\n-60 |     f(Box::new(|a| {\n+70 |     f(Box::new(|a| {\n    |     - borrow of `f` occurs here\n-61 |         foo(f);\n+71 |     //~^ NOTE borrow of `f` occurs here\n+72 |         foo(f);\n    |             ^ move into closure occurs here\n \n error[E0507]: cannot move out of captured outer variable in an `FnMut` closure\n-  --> $DIR/borrowck-call-is-borrow-issue-12224.rs:61:13\n+  --> $DIR/borrowck-call-is-borrow-issue-12224.rs:72:13\n    |\n-61 |         foo(f);\n+68 |     let mut f = |g: Box<FnMut(isize)>, b: isize| {};\n+   |         ----- captured outer variable\n+...\n+72 |         foo(f);\n    |             ^ cannot move out of captured outer variable in an `FnMut` closure\n \n error: aborting due to 5 previous errors"}, {"sha": "2d5d163d4030533a56a0b848c93c8f510da87bfe", "filename": "src/tools/rustbook/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftools%2Frustbook%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftools%2Frustbook%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2FCargo.toml?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -8,5 +8,5 @@ license = \"MIT/Apache-2.0\"\n clap = \"2.19.3\"\n \n [dependencies.mdbook]\n-version = \"0.0.19\"\n+version = \"0.0.21\"\n default-features = false"}, {"sha": "33326de9c1cc3f630ac7c8672d76e1b18a816e2f", "filename": "src/tools/rustbook/src/main.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70baf4f13ec70cb17942704849b0f3c047ad347b/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fsrc%2Fmain.rs?ref=70baf4f13ec70cb17942704849b0f3c047ad347b", "patch": "@@ -53,8 +53,7 @@ fn main() {\n \n // Build command implementation\n fn build(args: &ArgMatches) -> Result<(), Box<Error>> {\n-    let book_dir = get_book_dir(args);\n-    let book = MDBook::new(&book_dir).read_config();\n+    let book = build_mdbook_struct(args);\n \n     let mut book = match args.value_of(\"dest-dir\") {\n         Some(dest_dir) => book.set_dest(Path::new(dest_dir)),\n@@ -67,14 +66,26 @@ fn build(args: &ArgMatches) -> Result<(), Box<Error>> {\n }\n \n fn test(args: &ArgMatches) -> Result<(), Box<Error>> {\n-    let book_dir = get_book_dir(args);\n-    let mut book = MDBook::new(&book_dir).read_config();\n+    let mut book = build_mdbook_struct(args);\n \n     try!(book.test());\n \n     Ok(())\n }\n \n+fn build_mdbook_struct(args: &ArgMatches) -> mdbook::MDBook {\n+    let book_dir = get_book_dir(args);\n+    let mut book = MDBook::new(&book_dir).read_config();\n+\n+    // By default mdbook will attempt to create non-existent files referenced\n+    // from SUMMARY.md files. This is problematic on CI where we mount the\n+    // source directory as readonly. To avoid any issues, we'll disabled\n+    // mdbook's implicit file creation feature.\n+    book.create_missing = false;\n+\n+    book\n+}\n+\n fn get_book_dir(args: &ArgMatches) -> PathBuf {\n     if let Some(dir) = args.value_of(\"dir\") {\n         // Check if path is relative from current dir, or absolute..."}]}