{"sha": "4d44abd52aa03b5c896849d4785d387538fbb51e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNDRhYmQ1MmFhMDNiNWM4OTY4NDlkNDc4NWQzODc1MzhmYmI1MWU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-09T17:22:26Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-17T04:54:03Z"}, "message": "Change lints to indicate exactly where the level was set", "tree": {"sha": "3f173ff7af2856665747071d5ba649bad96dca72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f173ff7af2856665747071d5ba649bad96dca72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d44abd52aa03b5c896849d4785d387538fbb51e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d44abd52aa03b5c896849d4785d387538fbb51e", "html_url": "https://github.com/rust-lang/rust/commit/4d44abd52aa03b5c896849d4785d387538fbb51e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d44abd52aa03b5c896849d4785d387538fbb51e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1daaf785ab26f801d5003ad057f590d0886a5203", "url": "https://api.github.com/repos/rust-lang/rust/commits/1daaf785ab26f801d5003ad057f590d0886a5203", "html_url": "https://github.com/rust-lang/rust/commit/1daaf785ab26f801d5003ad057f590d0886a5203"}], "stats": {"total": 137, "additions": 86, "deletions": 51}, "files": [{"sha": "6fba5ec8d3a82b9c6c34a6fd922a56e52a3b516b", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4d44abd52aa03b5c896849d4785d387538fbb51e/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d44abd52aa03b5c896849d4785d387538fbb51e/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=4d44abd52aa03b5c896849d4785d387538fbb51e", "patch": "@@ -223,15 +223,6 @@ pub impl Session_ {\n     fn unimpl(@self, msg: &str) -> ! {\n         self.span_diagnostic.handler().unimpl(msg)\n     }\n-    fn span_lint_level(@self, level: lint::level, sp: span, msg: &str) {\n-        match level {\n-          lint::allow => { },\n-          lint::warn => self.span_warn(sp, msg),\n-          lint::deny | lint::forbid => {\n-            self.span_err(sp, msg);\n-          }\n-        }\n-    }\n     fn add_lint(@self, lint: lint::lint, id: ast::node_id, sp: span, msg: ~str) {\n         match self.lints.find_mut(&id) {\n             Some(arr) => { arr.push((lint, sp, msg)); return; }"}, {"sha": "aecbcb626e92b46b29c2e63febff55433959dffe", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 85, "deletions": 36, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/4d44abd52aa03b5c896849d4785d387538fbb51e/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d44abd52aa03b5c896849d4785d387538fbb51e/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=4d44abd52aa03b5c896849d4785d387538fbb51e", "patch": "@@ -32,20 +32,29 @@ use syntax::{ast, visit, ast_util};\n  * added via the `add_lint` method on the Session structure. This requires a\n  * span and an id of the node that the lint is being added to. The lint isn't\n  * actually emitted at that time because it is unknown what the actual lint\n- * level for the particular attribute is.\n+ * level at that location is.\n  *\n- * To actually emit lint warnings/errors, a context keeps track of the current\n- * state of all lint levels. Upon entering a node of the ast which can modify\n- * the lint settings, the previous lint state is pushed onto a stack and the ast\n- * is then recursed upon. Once the lint state has been altered, all of the known\n- * lint passes are run on the node of the ast.\n+ * To actually emit lint warnings/errors, a separate pass is used just before\n+ * translation. A context keeps track of the current state of all lint levels.\n+ * Upon entering a node of the ast which can modify the lint settings, the\n+ * previous lint state is pushed onto a stack and the ast is then recursed upon.\n+ * As the ast is traversed, this keeps track of the current lint level for all\n+ * lint attributes.\n  *\n- * Each lint pass is a visit::vt<()> structure. These visitors are constructed\n- * via the lint_*() functions below. There are also some lint checks which\n- * operate directly on ast nodes (such as @ast::item), and those are organized\n- * as check_item_*(). Each visitor added to the lint context is modified to stop\n- * once it reaches a node which could alter the lint levels. This means that\n- * everything is looked at once and only once by every lint pass.\n+ * At each node of the ast which can modify lint attributes, all known lint\n+ * passes are also applied.  Each lint pass is a visit::vt<()> structure. These\n+ * visitors are constructed via the lint_*() functions below. There are also\n+ * some lint checks which operate directly on ast nodes (such as @ast::item),\n+ * and those are organized as check_item_*(). Each visitor added to the lint\n+ * context is modified to stop once it reaches a node which could alter the lint\n+ * levels. This means that everything is looked at once and only once by every\n+ * lint pass.\n+ *\n+ * With this all in place, to add a new lint warning, all you need to do is to\n+ * either invoke `add_lint` on the session at the appropriate time, or write a\n+ * lint pass in this module which is just an ast visitor. The context used when\n+ * traversing the ast has a `span_lint` method which only needs the span of the\n+ * item that's being warned about.\n  */\n \n #[deriving(Eq)]\n@@ -100,6 +109,13 @@ enum AttributedNode<'self> {\n     Crate(@ast::crate),\n }\n \n+#[deriving(Eq)]\n+enum LintSource {\n+    Node(span),\n+    Default,\n+    CommandLine\n+}\n+\n static lint_table: &'static [(&'static str, LintSpec)] = &[\n     (\"ctypes\",\n      LintSpec {\n@@ -240,29 +256,17 @@ pub fn get_lint_dict() -> LintDict {\n     return map;\n }\n \n-pub fn get_lint_name(lint_mode: lint) -> ~str {\n-    for lint_table.each |&(name, spec)| {\n-        if spec.lint == lint_mode {\n-            return name.to_str();\n-        }\n-    }\n-    fail!();\n-}\n-// This is a highly not-optimal set of data structure decisions.\n-type LintModes = SmallIntMap<level>;\n-type LintModeMap = HashMap<ast::node_id, LintModes>;\n-\n struct Context {\n     // All known lint modes (string versions)\n     dict: @LintDict,\n     // Current levels of each lint warning\n-    curr: LintModes,\n+    curr: SmallIntMap<(level, LintSource)>,\n     // context we're checking in (used to access fields like sess)\n     tcx: ty::ctxt,\n     // When recursing into an attributed node of the ast which modifies lint\n     // levels, this stack keeps track of the previous lint levels of whatever\n     // was modified.\n-    lint_stack: ~[(lint, level)],\n+    lint_stack: ~[(lint, level, LintSource)],\n     // Each of these visitors represents a lint pass. A number of the lint\n     // attributes are registered by adding a visitor to iterate over the ast.\n     // Others operate directly on @ast::item structures (or similar). Finally,\n@@ -274,21 +278,65 @@ struct Context {\n impl Context {\n     fn get_level(&self, lint: lint) -> level {\n         match self.curr.find(&(lint as uint)) {\n-          Some(&c) => c,\n+          Some(&(lvl, _)) => lvl,\n           None => allow\n         }\n     }\n \n-    fn set_level(&mut self, lint: lint, level: level) {\n+    fn get_source(&self, lint: lint) -> LintSource {\n+        match self.curr.find(&(lint as uint)) {\n+          Some(&(_, src)) => src,\n+          None => Default\n+        }\n+    }\n+\n+    fn set_level(&mut self, lint: lint, level: level, src: LintSource) {\n         if level == allow {\n             self.curr.remove(&(lint as uint));\n         } else {\n-            self.curr.insert(lint as uint, level);\n+            self.curr.insert(lint as uint, (level, src));\n         }\n     }\n \n+    fn lint_to_str(&self, lint: lint) -> ~str {\n+        for self.dict.each |k, v| {\n+            if v.lint == lint {\n+                return copy *k;\n+            }\n+        }\n+        fail!(\"unregistered lint %?\", lint);\n+    }\n+\n     fn span_lint(&self, lint: lint, span: span, msg: &str) {\n-        self.tcx.sess.span_lint_level(self.get_level(lint), span, msg);\n+        let (level, src) = match self.curr.find(&(lint as uint)) {\n+            Some(&pair) => pair,\n+            None => { return; }\n+        };\n+        if level == allow { return; }\n+\n+        let mut note = None;\n+        let msg = match src {\n+            Default | CommandLine => {\n+                fmt!(\"%s [-%c %s%s]\", msg, match level {\n+                        warn => 'W', deny => 'D', forbid => 'F',\n+                        allow => fail!()\n+                    }, str::replace(self.lint_to_str(lint), \"_\", \"-\"),\n+                    if src == Default { \" (default)\" } else { \"\" })\n+            },\n+            Node(src) => {\n+                note = Some(src);\n+                msg.to_str()\n+            }\n+        };\n+        match level {\n+            warn =>          { self.tcx.sess.span_warn(span, msg); }\n+            deny | forbid => { self.tcx.sess.span_err(span, msg);  }\n+            allow => fail!(),\n+        }\n+\n+        for note.each |&span| {\n+            self.tcx.sess.span_note(span, \"lint level defined here\");\n+        }\n     }\n \n     /**\n@@ -325,18 +373,19 @@ impl Context {\n             }\n \n             if now != level {\n-                self.lint_stack.push((lint, now));\n+                let src = self.get_source(lint);\n+                self.lint_stack.push((lint, now, src));\n                 pushed += 1;\n-                self.set_level(lint, level);\n+                self.set_level(lint, level, Node(meta.span));\n             }\n         }\n \n         f();\n \n         // rollback\n         for pushed.times {\n-            let (lint, level) = self.lint_stack.pop();\n-            self.set_level(lint, level);\n+            let (lint, lvl, src) = self.lint_stack.pop();\n+            self.set_level(lint, lvl, src);\n         }\n     }\n \n@@ -874,12 +923,12 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n \n     // Install defaults.\n     for cx.dict.each_value |spec| {\n-        cx.set_level(spec.lint, spec.default);\n+        cx.set_level(spec.lint, spec.default, Default);\n     }\n \n     // Install command-line options, overriding defaults.\n     for tcx.sess.opts.lint_opts.each |&(lint, level)| {\n-        cx.set_level(lint, level);\n+        cx.set_level(lint, level, CommandLine);\n     }\n \n     // Register each of the lint passes with the context"}, {"sha": "713132b12fc1932a161cad11f51d6beb5dd28af3", "filename": "src/librustc/middle/resolve_stage0.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4d44abd52aa03b5c896849d4785d387538fbb51e/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d44abd52aa03b5c896849d4785d387538fbb51e/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs?ref=4d44abd52aa03b5c896849d4785d387538fbb51e", "patch": "@@ -5229,12 +5229,7 @@ pub impl Resolver {\n                     !import_resolution.state.warned &&\n                     import_resolution.span != dummy_sp() &&\n                     import_resolution.privacy != Public {\n-                import_resolution.state.warned = true;\n-                let span = import_resolution.span;\n-                self.session.span_lint_level(\n-                    self.unused_import_lint_level(module_),\n-                    span,\n-                    ~\"unused import\");\n+                // I swear I work in not(stage0)!\n             }\n         }\n     }"}]}