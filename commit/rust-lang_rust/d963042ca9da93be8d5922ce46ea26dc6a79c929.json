{"sha": "d963042ca9da93be8d5922ce46ea26dc6a79c929", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5NjMwNDJjYTlkYTkzYmU4ZDU5MjJjZTQ2ZWEyNmRjNmE3OWM5Mjk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-27T17:07:21Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-27T17:07:21Z"}, "message": "introduce hir::Name", "tree": {"sha": "76f7bfc934dda4e9dfc956fc86fe73379d86a332", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76f7bfc934dda4e9dfc956fc86fe73379d86a332"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d963042ca9da93be8d5922ce46ea26dc6a79c929", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d963042ca9da93be8d5922ce46ea26dc6a79c929", "html_url": "https://github.com/rust-lang/rust/commit/d963042ca9da93be8d5922ce46ea26dc6a79c929", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d963042ca9da93be8d5922ce46ea26dc6a79c929/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b820bcca3a66660d0c5960f2a5c8f765095333e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b820bcca3a66660d0c5960f2a5c8f765095333e", "html_url": "https://github.com/rust-lang/rust/commit/3b820bcca3a66660d0c5960f2a5c8f765095333e"}], "stats": {"total": 172, "additions": 121, "deletions": 51}, "files": [{"sha": "3028db17c2d05f0f56270cba909ae6e140c460f7", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=d963042ca9da93be8d5922ce46ea26dc6a79c929", "patch": "@@ -14,7 +14,7 @@ pub use crate::{\n     cancelation::{Canceled, Cancelable},\n     syntax_ptr::LocalSyntaxPtr,\n     input::{\n-        FilesDatabase, FileId, CrateId, SourceRoot, SourceRootId, CrateGraph,\n+        FilesDatabase, FileId, CrateId, SourceRoot, SourceRootId, CrateGraph, Dependency,\n         FileTextQuery, FileSourceRootQuery, SourceRootQuery, LocalRootsQuery, LibraryRootsQuery, CrateGraphQuery,\n         FileRelativePathQuery\n     },"}, {"sha": "89b1e639efdd1daf2d9964c96ceee0a8d557e0f9", "filename": "crates/ra_hir/src/krate.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fkrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fkrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fkrate.rs?ref=d963042ca9da93be8d5922ce46ea26dc6a79c929", "patch": "@@ -1,7 +1,6 @@\n-use ra_syntax::SmolStr;\n pub use ra_db::CrateId;\n \n-use crate::{HirDatabase, Module, Cancelable};\n+use crate::{HirDatabase, Module, Cancelable, Name, AsName};\n \n /// hir::Crate describes a single crate. It's the main inteface with which\n /// crate's dependencies interact. Mostly, it should be just a proxy for the\n@@ -14,7 +13,7 @@ pub struct Crate {\n #[derive(Debug)]\n pub struct CrateDependency {\n     pub krate: Crate,\n-    pub name: SmolStr,\n+    pub name: Name,\n }\n \n impl Crate {\n@@ -27,7 +26,7 @@ impl Crate {\n             .dependencies(self.crate_id)\n             .map(|dep| {\n                 let krate = Crate::new(dep.crate_id());\n-                let name = dep.name.clone();\n+                let name = dep.as_name();\n                 CrateDependency { krate, name }\n             })\n             .collect()"}, {"sha": "bf43cd0ae4d4f6a93e1b5777e487bba0c1c09aed", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=d963042ca9da93be8d5922ce46ea26dc6a79c929", "patch": "@@ -22,6 +22,7 @@ mod path;\n mod arena;\n pub mod source_binder;\n \n+mod name;\n mod krate;\n mod module;\n mod function;\n@@ -37,10 +38,12 @@ use ra_db::{LocationIntener, SourceRootId, FileId, Cancelable};\n use crate::{\n     db::HirDatabase,\n     arena::{Arena, Id},\n+    name::AsName,\n };\n \n pub use self::{\n     path::{Path, PathKind},\n+    name::Name,\n     krate::Crate,\n     module::{Module, ModuleId, Problem, nameres::{ItemMap, PerNs, Namespace}, ModuleScope, Resolution},\n     function::{Function, FnScopes},"}, {"sha": "43413acb8b9125ac6f0423c2a01e18ea61f3f2d2", "filename": "crates/ra_hir/src/module.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule.rs?ref=d963042ca9da93be8d5922ce46ea26dc6a79c929", "patch": "@@ -7,13 +7,14 @@ use log;\n use ra_syntax::{\n     algo::generate,\n     ast::{self, AstNode, NameOwner},\n-    SmolStr, SyntaxNode,\n+    SyntaxNode,\n };\n use ra_db::{SourceRootId, FileId, Cancelable};\n use relative_path::RelativePathBuf;\n \n use crate::{\n     DefKind, DefLoc, DefId, Path, PathKind, HirDatabase, SourceItemId, SourceFileItemId, Crate,\n+    Name,\n     arena::{Arena, Id},\n };\n \n@@ -84,7 +85,7 @@ impl Module {\n     }\n \n     /// `name` is `None` for the crate's root module\n-    pub fn name(&self) -> Option<SmolStr> {\n+    pub fn name(&self) -> Option<&Name> {\n         let link = self.module_id.parent_link(&self.tree)?;\n         Some(link.name(&self.tree))\n     }\n@@ -100,7 +101,7 @@ impl Module {\n     }\n \n     /// Finds a child module with the specified name.\n-    pub fn child(&self, name: &str) -> Option<Module> {\n+    pub fn child(&self, name: &Name) -> Option<Module> {\n         let child_id = self.module_id.child(&self.tree, name)?;\n         Some(Module {\n             module_id: child_id,\n@@ -230,15 +231,15 @@ impl ModuleId {\n             .last()\n             .unwrap()\n     }\n-    fn child(self, tree: &ModuleTree, name: &str) -> Option<ModuleId> {\n+    fn child(self, tree: &ModuleTree, name: &Name) -> Option<ModuleId> {\n         let link = tree.mods[self]\n             .children\n             .iter()\n             .map(|&it| &tree.links[it])\n-            .find(|it| it.name == name)?;\n+            .find(|it| it.name == *name)?;\n         Some(*link.points_to.first()?)\n     }\n-    fn children<'a>(self, tree: &'a ModuleTree) -> impl Iterator<Item = (SmolStr, ModuleId)> + 'a {\n+    fn children<'a>(self, tree: &'a ModuleTree) -> impl Iterator<Item = (Name, ModuleId)> + 'a {\n         tree.mods[self].children.iter().filter_map(move |&it| {\n             let link = &tree.links[it];\n             let module = *link.points_to.first()?;\n@@ -263,8 +264,8 @@ impl LinkId {\n     fn owner(self, tree: &ModuleTree) -> ModuleId {\n         tree.links[self].owner\n     }\n-    fn name(self, tree: &ModuleTree) -> SmolStr {\n-        tree.links[self].name.clone()\n+    fn name(self, tree: &ModuleTree) -> &Name {\n+        &tree.links[self].name\n     }\n     fn bind_source<'a>(self, tree: &ModuleTree, db: &impl HirDatabase) -> ast::ModuleNode {\n         let owner = self.owner(tree);\n@@ -328,7 +329,7 @@ impl ModuleSource {\n #[derive(Hash, Debug, PartialEq, Eq)]\n struct LinkData {\n     owner: ModuleId,\n-    name: SmolStr,\n+    name: Name,\n     points_to: Vec<ModuleId>,\n     problem: Option<Problem>,\n }"}, {"sha": "eded85a63399481b7d1fb0527cf9a324a7ea61a2", "filename": "crates/ra_hir/src/module/imp.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs?ref=d963042ca9da93be8d5922ce46ea26dc6a79c929", "patch": "@@ -1,16 +1,13 @@\n use std::sync::Arc;\n \n-use ra_syntax::{\n-    ast::{self, NameOwner},\n-    SmolStr,\n-};\n+use ra_syntax::ast::{self, NameOwner};\n use relative_path::RelativePathBuf;\n use rustc_hash::{FxHashMap, FxHashSet};\n use arrayvec::ArrayVec;\n use ra_db::{SourceRoot, SourceRootId, Cancelable, FileId};\n \n use crate::{\n-    HirDatabase,\n+    HirDatabase, Name, AsName,\n };\n \n use super::{\n@@ -20,12 +17,12 @@ use super::{\n \n #[derive(Clone, Hash, PartialEq, Eq, Debug)]\n pub enum Submodule {\n-    Declaration(SmolStr),\n-    Definition(SmolStr, ModuleSource),\n+    Declaration(Name),\n+    Definition(Name, ModuleSource),\n }\n \n impl Submodule {\n-    fn name(&self) -> &SmolStr {\n+    fn name(&self) -> &Name {\n         match self {\n             Submodule::Declaration(name) => name,\n             Submodule::Definition(name, _) => name,\n@@ -35,14 +32,14 @@ impl Submodule {\n \n pub(crate) fn modules<'a>(\n     root: impl ast::ModuleItemOwner<'a>,\n-) -> impl Iterator<Item = (SmolStr, ast::Module<'a>)> {\n+) -> impl Iterator<Item = (Name, ast::Module<'a>)> {\n     root.items()\n         .filter_map(|item| match item {\n             ast::ModuleItem::Module(m) => Some(m),\n             _ => None,\n         })\n         .filter_map(|module| {\n-            let name = module.name()?.text();\n+            let name = module.name()?.as_name();\n             Some((name, module))\n         })\n }\n@@ -155,7 +152,7 @@ fn build_subtree(\n fn resolve_submodule(\n     db: &impl HirDatabase,\n     source: ModuleSource,\n-    name: &SmolStr,\n+    name: &Name,\n ) -> (Vec<FileId>, Option<Problem>) {\n     // FIXME: handle submodules of inline modules properly\n     let file_id = source.file_id();"}, {"sha": "68eb02a980a0490740e2b5e66a5247b08dca9d7c", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=d963042ca9da93be8d5922ce46ea26dc6a79c929", "patch": "@@ -14,14 +14,12 @@\n //! modifications (that is, typing inside a function shold not change IMIs),\n //! such that the results of name resolution can be preserved unless the module\n //! structure itself is modified.\n-use std::{\n-    sync::Arc,\n-};\n+use std::sync::Arc;\n \n use rustc_hash::FxHashMap;\n use ra_syntax::{\n     TextRange,\n-    SmolStr, SyntaxKind::{self, *},\n+    SyntaxKind::{self, *},\n     ast::{self, AstNode}\n };\n use ra_db::SourceRootId;\n@@ -32,6 +30,7 @@ use crate::{\n     SourceItemId, SourceFileItemId, SourceFileItems,\n     Path, PathKind,\n     HirDatabase, Crate,\n+    Name, AsName,\n     module::{Module, ModuleId, ModuleTree},\n };\n \n@@ -45,14 +44,14 @@ pub struct ItemMap {\n \n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct ModuleScope {\n-    items: FxHashMap<SmolStr, Resolution>,\n+    items: FxHashMap<Name, Resolution>,\n }\n \n impl ModuleScope {\n-    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a SmolStr, &'a Resolution)> + 'a {\n+    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, &'a Resolution)> + 'a {\n         self.items.iter()\n     }\n-    pub fn get(&self, name: &SmolStr) -> Option<&Resolution> {\n+    pub fn get(&self, name: &Name) -> Option<&Resolution> {\n         self.items.get(name)\n     }\n }\n@@ -72,7 +71,7 @@ pub struct InputModuleItems {\n #[derive(Debug, PartialEq, Eq)]\n struct ModuleItem {\n     id: SourceFileItemId,\n-    name: SmolStr,\n+    name: Name,\n     kind: SyntaxKind,\n     vis: Vis,\n }\n@@ -260,7 +259,7 @@ impl InputModuleItems {\n \n impl ModuleItem {\n     fn new<'a>(file_items: &SourceFileItems, item: impl ast::NameOwner<'a>) -> Option<ModuleItem> {\n-        let name = item.name()?.text();\n+        let name = item.name()?.as_name();\n         let kind = item.syntax().kind();\n         let vis = Vis::Other;\n         let id = file_items.id_of_unchecked(item.syntax());\n@@ -328,7 +327,11 @@ where\n                 for dep in krate.dependencies(self.db) {\n                     if let Some(module) = dep.krate.root_module(self.db)? {\n                         let def_id = module.def_id(self.db);\n-                        self.add_module_item(&mut module_items, dep.name, PerNs::types(def_id));\n+                        self.add_module_item(\n+                            &mut module_items,\n+                            dep.name.clone(),\n+                            PerNs::types(def_id),\n+                        );\n                     }\n                 }\n             };\n@@ -389,7 +392,7 @@ where\n         Ok(())\n     }\n \n-    fn add_module_item(&self, module_items: &mut ModuleScope, name: SmolStr, def_id: PerNs<DefId>) {\n+    fn add_module_item(&self, module_items: &mut ModuleScope, name: Name, def_id: PerNs<DefId>) {\n         let resolution = Resolution {\n             def_id,\n             import: None,"}, {"sha": "165ac81c827a888b0a1846afe9a3c2d5e1beff43", "filename": "crates/ra_hir/src/module/nameres/tests.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs?ref=d963042ca9da93be8d5922ce46ea26dc6a79c929", "patch": "@@ -9,6 +9,7 @@ use crate::{\n     self as hir,\n     db::HirDatabase,\n     mock::MockDatabase,\n+    Name,\n };\n \n fn item_map(fixture: &str) -> (Arc<hir::ItemMap>, hir::ModuleId) {\n@@ -38,7 +39,7 @@ fn item_map_smoke_test() {\n         pub struct Baz;\n     \",\n     );\n-    let name = SmolStr::from(\"Baz\");\n+    let name = Name::new(SmolStr::from(\"Baz\"));\n     let resolution = &item_map.per_module[&module_id].items[&name];\n     assert!(resolution.def_id.take_types().is_some());\n }\n@@ -57,7 +58,7 @@ fn test_self() {\n             pub struct Baz;\n         \",\n     );\n-    let name = SmolStr::from(\"Baz\");\n+    let name = Name::new(SmolStr::from(\"Baz\"));\n     let resolution = &item_map.per_module[&module_id].items[&name];\n     assert!(resolution.def_id.take_types().is_some());\n }\n@@ -90,7 +91,7 @@ fn item_map_across_crates() {\n     let module_id = module.module_id;\n     let item_map = db.item_map(source_root).unwrap();\n \n-    let name = SmolStr::from(\"Baz\");\n+    let name = Name::new(SmolStr::from(\"Baz\"));\n     let resolution = &item_map.per_module[&module_id].items[&name];\n     assert!(resolution.def_id.take_types().is_some());\n }"}, {"sha": "7f42c9f04185fada484f07c44684261bc7df9279", "filename": "crates/ra_hir/src/name.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=d963042ca9da93be8d5922ce46ea26dc6a79c929", "patch": "@@ -0,0 +1,56 @@\n+use std::fmt;\n+\n+use ra_syntax::{ast, SmolStr};\n+\n+/// `Name` is a wrapper around string, which is used in hir for both references\n+/// and declarations. In theory, names should also carry hygene info, but we are\n+/// not there yet!\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Name {\n+    text: SmolStr,\n+}\n+\n+impl fmt::Display for Name {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.text, f)\n+    }\n+}\n+\n+impl Name {\n+    // TODO: get rid of this?\n+    pub(crate) fn as_str(&self) -> &str {\n+        self.text.as_str()\n+    }\n+\n+    #[cfg(not(test))]\n+    fn new(text: SmolStr) -> Name {\n+        Name { text }\n+    }\n+\n+    #[cfg(test)]\n+    pub(crate) fn new(text: SmolStr) -> Name {\n+        Name { text }\n+    }\n+}\n+\n+pub(crate) trait AsName {\n+    fn as_name(&self) -> Name;\n+}\n+\n+impl AsName for ast::NameRef<'_> {\n+    fn as_name(&self) -> Name {\n+        Name::new(self.text())\n+    }\n+}\n+\n+impl AsName for ast::Name<'_> {\n+    fn as_name(&self) -> Name {\n+        Name::new(self.text())\n+    }\n+}\n+\n+impl AsName for ra_db::Dependency {\n+    fn as_name(&self) -> Name {\n+        Name::new(self.name.clone())\n+    }\n+}"}, {"sha": "93f7203fe26587388c8392689da2d9464f62f57f", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=d963042ca9da93be8d5922ce46ea26dc6a79c929", "patch": "@@ -1,9 +1,11 @@\n-use ra_syntax::{SmolStr, ast, AstNode, TextRange};\n+use ra_syntax::{ast, AstNode, TextRange};\n+\n+use crate::{Name, AsName};\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n     pub kind: PathKind,\n-    pub segments: Vec<SmolStr>,\n+    pub segments: Vec<Name>,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -29,7 +31,7 @@ impl Path {\n         loop {\n             let segment = path.segment()?;\n             match segment.kind()? {\n-                ast::PathSegmentKind::Name(name) => segments.push(name.text()),\n+                ast::PathSegmentKind::Name(name) => segments.push(name.as_name()),\n                 ast::PathSegmentKind::CrateKw => {\n                     kind = PathKind::Crate;\n                     break;\n@@ -67,6 +69,14 @@ impl Path {\n     pub fn is_ident(&self) -> bool {\n         self.kind == PathKind::Plain && self.segments.len() == 1\n     }\n+\n+    /// If this path is a single identifier, like `foo`, return its name.\n+    pub fn as_ident(&self) -> Option<&Name> {\n+        if self.kind != PathKind::Plain || self.segments.len() > 1 {\n+            return None;\n+        }\n+        self.segments.first()\n+    }\n }\n \n fn expand_use_tree(\n@@ -130,7 +140,7 @@ fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n                 kind: PathKind::Plain,\n                 segments: Vec::with_capacity(1),\n             });\n-            res.segments.push(name.text());\n+            res.segments.push(name.as_name());\n             res\n         }\n         ast::PathSegmentKind::CrateKw => {"}, {"sha": "e6241342acd8c599c1608b9022c0bc5e61942491", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=d963042ca9da93be8d5922ce46ea26dc6a79c929", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n use ra_db::{SourceRootId, FileId, Cancelable,};\n \n use crate::{\n-    SourceFileItems, SourceItemId, DefKind, Function, DefId,\n+    SourceFileItems, SourceItemId, DefKind, Function, DefId, Name, AsName,\n     db::HirDatabase,\n     function::{FnScopes, FnId},\n     module::{\n@@ -130,14 +130,14 @@ pub(crate) fn submodules(\n \n pub(crate) fn modules<'a>(\n     root: impl ast::ModuleItemOwner<'a>,\n-) -> impl Iterator<Item = (SmolStr, ast::Module<'a>)> {\n+) -> impl Iterator<Item = (Name, ast::Module<'a>)> {\n     root.items()\n         .filter_map(|item| match item {\n             ast::ModuleItem::Module(m) => Some(m),\n             _ => None,\n         })\n         .filter_map(|module| {\n-            let name = module.name()?.text();\n+            let name = module.name()?.as_name();\n             Some((name, module))\n         })\n }"}, {"sha": "dc3323b1a372411f07161062b509cbbe51ceb8f0", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d963042ca9da93be8d5922ce46ea26dc6a79c929/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=d963042ca9da93be8d5922ce46ea26dc6a79c929", "patch": "@@ -179,13 +179,13 @@ impl Ty {\n         module: &Module,\n         path: &Path,\n     ) -> Cancelable<Self> {\n-        if path.is_ident() {\n-            let name = &path.segments[0];\n-            if let Some(int_ty) = primitive::IntTy::from_string(&name) {\n+        if let Some(name) = path.as_ident() {\n+            let name = name.as_str(); // :-(\n+            if let Some(int_ty) = primitive::IntTy::from_string(name) {\n                 return Ok(Ty::Int(int_ty));\n-            } else if let Some(uint_ty) = primitive::UintTy::from_string(&name) {\n+            } else if let Some(uint_ty) = primitive::UintTy::from_string(name) {\n                 return Ok(Ty::Uint(uint_ty));\n-            } else if let Some(float_ty) = primitive::FloatTy::from_string(&name) {\n+            } else if let Some(float_ty) = primitive::FloatTy::from_string(name) {\n                 return Ok(Ty::Float(float_ty));\n             }\n         }"}]}