{"sha": "81b3e7096bbcfff6e991346aa9d42f1298d56301", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxYjNlNzA5NmJiY2ZmZjZlOTkxMzQ2YWE5ZDQyZjEyOThkNTYzMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-14T19:58:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-14T19:58:17Z"}, "message": "Auto merge of #5449 - phansch:diagnostic-items, r=matthiaskrgr\n\nMake use of more diagnostic items\n\nThis makes use of some (not all) already existing diagnostic items. Specifically:\n\n* 79982a2: `core::mem::uninitialized`, `core::mem::zeroed`, `alloc::sync::Arc`, `alloc::sync::Rc`\n* 83874d0: `Option` and `Result`\n\ncc #5393\n\nchangelog: none", "tree": {"sha": "b4ddb29612b906a1a3654d1f49ee970266d861cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4ddb29612b906a1a3654d1f49ee970266d861cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81b3e7096bbcfff6e991346aa9d42f1298d56301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81b3e7096bbcfff6e991346aa9d42f1298d56301", "html_url": "https://github.com/rust-lang/rust/commit/81b3e7096bbcfff6e991346aa9d42f1298d56301", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81b3e7096bbcfff6e991346aa9d42f1298d56301/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c77188c0478c66f0f3611f69adb623a37b8fa27", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c77188c0478c66f0f3611f69adb623a37b8fa27", "html_url": "https://github.com/rust-lang/rust/commit/3c77188c0478c66f0f3611f69adb623a37b8fa27"}, {"sha": "a524be6df505598dabb27902eb9d9fc31b61cab0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a524be6df505598dabb27902eb9d9fc31b61cab0", "html_url": "https://github.com/rust-lang/rust/commit/a524be6df505598dabb27902eb9d9fc31b61cab0"}], "stats": {"total": 132, "additions": 64, "deletions": 68}, "files": [{"sha": "f16d10fde9297aaeca9cd4e3bf8b3fc1d2021f0c", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=81b3e7096bbcfff6e991346aa9d42f1298d56301", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{\n-    get_trait_def_id, implements_trait, in_macro, match_type, paths, snippet_opt, span_lint_and_sugg,\n+    get_trait_def_id, implements_trait, in_macro, is_type_diagnostic_item, paths, snippet_opt, span_lint_and_sugg,\n     span_lint_and_then, SpanlessEq,\n };\n use if_chain::if_chain;\n@@ -249,7 +249,9 @@ fn simplify_not(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<String> {\n         },\n         ExprKind::MethodCall(path, _, args) if args.len() == 1 => {\n             let type_of_receiver = cx.tables.expr_ty(&args[0]);\n-            if !match_type(cx, type_of_receiver, &paths::OPTION) && !match_type(cx, type_of_receiver, &paths::RESULT) {\n+            if !is_type_diagnostic_item(cx, type_of_receiver, sym!(option_type))\n+                && !is_type_diagnostic_item(cx, type_of_receiver, sym!(result_type))\n+            {\n                 return None;\n             }\n             METHODS_WITH_NEGATION"}, {"sha": "93a394b79e55b29663b260d4ca769429c8c9d390", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=81b3e7096bbcfff6e991346aa9d42f1298d56301", "patch": "@@ -9,7 +9,7 @@ use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_span::BytePos;\n \n-use crate::utils::{match_type, paths, snippet_opt, span_lint_and_help, LimitStack};\n+use crate::utils::{is_type_diagnostic_item, snippet_opt, span_lint_and_help, LimitStack};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for methods with high cognitive complexity.\n@@ -61,7 +61,7 @@ impl CognitiveComplexity {\n         helper.visit_expr(expr);\n         let CCHelper { cc, returns } = helper;\n         let ret_ty = cx.tables.node_type(expr.hir_id);\n-        let ret_adjust = if match_type(cx, ret_ty, &paths::RESULT) {\n+        let ret_adjust = if is_type_diagnostic_item(cx, ret_ty, sym!(result_type)) {\n             returns\n         } else {\n             #[allow(clippy::integer_division)]"}, {"sha": "926bd8ed001f631130ddcdd63eaa7a5b61f868ab", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=81b3e7096bbcfff6e991346aa9d42f1298d56301", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{implements_trait, is_entrypoint_fn, match_type, paths, return_ty, span_lint};\n+use crate::utils::{implements_trait, is_entrypoint_fn, is_type_diagnostic_item, return_ty, span_lint};\n use if_chain::if_chain;\n use itertools::Itertools;\n use rustc_ast::ast::{AttrKind, Attribute};\n@@ -217,7 +217,7 @@ fn lint_for_missing_headers<'a, 'tcx>(\n         );\n     }\n     if !headers.errors {\n-        if match_type(cx, return_ty(cx, hir_id), &paths::RESULT) {\n+        if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym!(result_type)) {\n             span_lint(\n                 cx,\n                 MISSING_ERRORS_DOC,\n@@ -235,7 +235,7 @@ fn lint_for_missing_headers<'a, 'tcx>(\n                 if let ty::Opaque(_, subs) = ret_ty.kind;\n                 if let Some(gen) = subs.types().next();\n                 if let ty::Generator(_, subs, _) = gen.kind;\n-                if match_type(cx, subs.as_generator().return_ty(), &paths::RESULT);\n+                if is_type_diagnostic_item(cx, subs.as_generator().return_ty(), sym!(result_type));\n                 then {\n                     span_lint(\n                         cx,"}, {"sha": "8e45a09b489e384beea9302497a97ae76cacffcd", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=81b3e7096bbcfff6e991346aa9d42f1298d56301", "patch": "@@ -1,10 +1,12 @@\n-use crate::utils::paths::{BEGIN_PANIC, BEGIN_PANIC_FMT, FROM_TRAIT, OPTION, RESULT};\n-use crate::utils::{is_expn_of, match_def_path, method_chain_args, span_lint_and_then, walk_ptrs_ty};\n+use crate::utils::paths::{BEGIN_PANIC, BEGIN_PANIC_FMT, FROM_TRAIT};\n+use crate::utils::{\n+    is_expn_of, is_type_diagnostic_item, match_def_path, method_chain_args, span_lint_and_then, walk_ptrs_ty,\n+};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n \n@@ -76,7 +78,9 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n             // check for `unwrap`\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n                 let reciever_ty = walk_ptrs_ty(self.tables.expr_ty(&arglists[0][0]));\n-                if match_type(self.lcx, reciever_ty, &OPTION) || match_type(self.lcx, reciever_ty, &RESULT) {\n+                if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type))\n+                    || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type))\n+                {\n                     self.result.push(expr.span);\n                 }\n             }\n@@ -124,10 +128,3 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n         }\n     }\n }\n-\n-fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n-    match ty.kind {\n-        ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n-        _ => false,\n-    }\n-}"}, {"sha": "9b13f7609247a26f122252b9d97ac34dbd1c8b08", "filename": "clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=81b3e7096bbcfff6e991346aa9d42f1298d56301", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{match_type, method_chain_args, paths, snippet_with_applicability, span_lint_and_sugg};\n+use crate::utils::{is_type_diagnostic_item, method_chain_args, snippet_with_applicability, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, MatchSource, PatKind, QPath};\n@@ -45,8 +45,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OkIfLet {\n             if let ExprKind::MethodCall(_, ok_span, ref result_types) = op.kind; //check is expr.ok() has type Result<T,E>.ok()\n             if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pat.kind; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n-            let is_result_type = match_type(cx, cx.tables.expr_ty(&result_types[0]), &paths::RESULT);\n-            if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\" && is_result_type;\n+            if is_type_diagnostic_item(cx, cx.tables.expr_ty(&result_types[0]), sym!(result_type));\n+            if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";\n \n             then {\n                 let mut applicability = Applicability::MachineApplicable;"}, {"sha": "66bc1cb3dc420a62b2e278386ad0ae8c5b7eb583", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=81b3e7096bbcfff6e991346aa9d42f1298d56301", "patch": "@@ -1392,7 +1392,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>, e\n /// Checks for `for` loops over `Option`s and `Result`s.\n fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n     let ty = cx.tables.expr_ty(arg);\n-    if match_type(cx, ty, &paths::OPTION) {\n+    if is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n         span_lint_and_help(\n             cx,\n             FOR_LOOP_OVER_OPTION,\n@@ -1408,7 +1408,7 @@ fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n                 snippet(cx, arg.span, \"_\")\n             ),\n         );\n-    } else if match_type(cx, ty, &paths::RESULT) {\n+    } else if is_type_diagnostic_item(cx, ty, sym!(result_type)) {\n         span_lint_and_help(\n             cx,\n             FOR_LOOP_OVER_RESULT,"}, {"sha": "5c5cf8015f408e256d05dd66e90842e04fab53bd", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=81b3e7096bbcfff6e991346aa9d42f1298d56301", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::paths;\n use crate::utils::{\n-    is_copy, match_trait_method, match_type, remove_blocks, snippet_with_applicability, span_lint_and_sugg,\n+    is_copy, is_type_diagnostic_item, match_trait_method, remove_blocks, snippet_with_applicability, span_lint_and_sugg,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::Ident;\n@@ -52,7 +52,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapClone {\n             if args.len() == 2;\n             if method.ident.as_str() == \"map\";\n             let ty = cx.tables.expr_ty(&args[0]);\n-            if match_type(cx, ty, &paths::OPTION) || match_trait_method(cx, e, &paths::ITERATOR);\n+            if is_type_diagnostic_item(cx, ty, sym!(option_type)) || match_trait_method(cx, e, &paths::ITERATOR);\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].kind;\n             let closure_body = cx.tcx.hir().body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);"}, {"sha": "ba10319ff46101bdbd2a47faa62c4f4228f80552", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=81b3e7096bbcfff6e991346aa9d42f1298d56301", "patch": "@@ -1,5 +1,4 @@\n-use crate::utils::paths;\n-use crate::utils::{iter_input_pats, match_type, method_chain_args, snippet, span_lint_and_then};\n+use crate::utils::{is_type_diagnostic_item, iter_input_pats, method_chain_args, snippet, span_lint_and_then};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -206,9 +205,9 @@ fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n fn lint_map_unit_fn(cx: &LateContext<'_, '_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr<'_>, map_args: &[hir::Expr<'_>]) {\n     let var_arg = &map_args[0];\n \n-    let (map_type, variant, lint) = if match_type(cx, cx.tables.expr_ty(var_arg), &paths::OPTION) {\n+    let (map_type, variant, lint) = if is_type_diagnostic_item(cx, cx.tables.expr_ty(var_arg), sym!(option_type)) {\n         (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n-    } else if match_type(cx, cx.tables.expr_ty(var_arg), &paths::RESULT) {\n+    } else if is_type_diagnostic_item(cx, cx.tables.expr_ty(var_arg), sym!(result_type)) {\n         (\"Result\", \"Ok\", RESULT_MAP_UNIT_FN)\n     } else {\n         return;"}, {"sha": "206a842d21ca9f82a29c45da71dda075ba5d0b9b", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=81b3e7096bbcfff6e991346aa9d42f1298d56301", "patch": "@@ -3,10 +3,10 @@ use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n use crate::utils::usage::is_unused;\n use crate::utils::{\n-    expr_block, get_arg_name, get_parent_expr, in_macro, indent_of, is_allowed, is_expn_of, is_refutable, is_wild,\n-    match_qpath, match_type, match_var, multispan_sugg, remove_blocks, snippet, snippet_block,\n-    snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n-    walk_ptrs_ty,\n+    expr_block, get_arg_name, get_parent_expr, in_macro, indent_of, is_allowed, is_expn_of, is_refutable,\n+    is_type_diagnostic_item, is_wild, match_qpath, match_type, match_var, multispan_sugg, remove_blocks, snippet,\n+    snippet_block, snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg,\n+    span_lint_and_then, walk_ptrs_ty,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n@@ -642,7 +642,7 @@ fn check_overlapping_arms<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ex: &'tcx Expr<'\n \n fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n     let ex_ty = walk_ptrs_ty(cx.tables.expr_ty(ex));\n-    if match_type(cx, ex_ty, &paths::RESULT) {\n+    if is_type_diagnostic_item(cx, ex_ty, sym!(result_type)) {\n         for arm in arms {\n             if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pat.kind {\n                 let path_str = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false));"}, {"sha": "0bd4c4805b34c3d2f4d285a0963d136a720271c0", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=81b3e7096bbcfff6e991346aa9d42f1298d56301", "patch": "@@ -9,6 +9,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::symbol::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `mem::replace()` on an `Option` with\n@@ -141,15 +142,15 @@ fn check_replace_with_uninit(cx: &LateContext<'_, '_>, src: &Expr<'_>, expr_span\n             if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n             if let Some(repl_def_id) = cx.tables.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n             then {\n-                if match_def_path(cx, repl_def_id, &paths::MEM_UNINITIALIZED) {\n+                if cx.tcx.is_diagnostic_item(sym::mem_uninitialized, repl_def_id) {\n                     span_lint_and_help(\n                         cx,\n                         MEM_REPLACE_WITH_UNINIT,\n                         expr_span,\n                         \"replacing with `mem::uninitialized()`\",\n                         \"consider using the `take_mut` crate instead\",\n                     );\n-                } else if match_def_path(cx, repl_def_id, &paths::MEM_ZEROED) &&\n+                } else if cx.tcx.is_diagnostic_item(sym::mem_zeroed, repl_def_id) &&\n                         !cx.tables.expr_ty(src).is_primitive() {\n                     span_lint_and_help(\n                         cx,"}, {"sha": "5255fec2cec5f4677fbbf17887f1016255d29404", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=81b3e7096bbcfff6e991346aa9d42f1298d56301", "patch": "@@ -1858,9 +1858,9 @@ fn lint_expect_fun_call(\n     }\n \n     let receiver_type = cx.tables.expr_ty_adjusted(&args[0]);\n-    let closure_args = if match_type(cx, receiver_type, &paths::OPTION) {\n+    let closure_args = if is_type_diagnostic_item(cx, receiver_type, sym!(option_type)) {\n         \"||\"\n-    } else if match_type(cx, receiver_type, &paths::RESULT) {\n+    } else if is_type_diagnostic_item(cx, receiver_type, sym!(result_type)) {\n         \"|_|\"\n     } else {\n         return;\n@@ -2020,9 +2020,9 @@ fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, arg: &h\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(arg));\n \n     if let ty::Adt(_, subst) = obj_ty.kind {\n-        let caller_type = if match_type(cx, obj_ty, &paths::RC) {\n+        let caller_type = if is_type_diagnostic_item(cx, obj_ty, sym::Rc) {\n             \"Rc\"\n-        } else if match_type(cx, obj_ty, &paths::ARC) {\n+        } else if is_type_diagnostic_item(cx, obj_ty, sym::Arc) {\n             \"Arc\"\n         } else if match_type(cx, obj_ty, &paths::WEAK_RC) || match_type(cx, obj_ty, &paths::WEAK_ARC) {\n             \"Weak\"\n@@ -2089,7 +2089,7 @@ fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, source: &\n     if_chain! {\n         let source_type = cx.tables.expr_ty(source);\n         if let ty::Adt(def, substs) = source_type.kind;\n-        if match_def_path(cx, def.did, &paths::RESULT);\n+        if cx.tcx.is_diagnostic_item(sym!(result_type), def.did);\n         if match_type(cx, substs.type_at(0), &paths::CSTRING);\n         then {\n             span_lint_and_then(\n@@ -2417,9 +2417,9 @@ fn derefs_to_slice<'a, 'tcx>(\n fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&unwrap_args[0]));\n \n-    let mess = if match_type(cx, obj_ty, &paths::OPTION) {\n+    let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n         Some((OPTION_UNWRAP_USED, \"an Option\", \"None\"))\n-    } else if match_type(cx, obj_ty, &paths::RESULT) {\n+    } else if is_type_diagnostic_item(cx, obj_ty, sym!(result_type)) {\n         Some((RESULT_UNWRAP_USED, \"a Result\", \"Err\"))\n     } else {\n         None\n@@ -2444,9 +2444,9 @@ fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, unwrap_args: &[hi\n fn lint_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&expect_args[0]));\n \n-    let mess = if match_type(cx, obj_ty, &paths::OPTION) {\n+    let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n         Some((OPTION_EXPECT_USED, \"an Option\", \"None\"))\n-    } else if match_type(cx, obj_ty, &paths::RESULT) {\n+    } else if is_type_diagnostic_item(cx, obj_ty, sym!(result_type)) {\n         Some((RESULT_EXPECT_USED, \"a Result\", \"Err\"))\n     } else {\n         None\n@@ -2467,7 +2467,7 @@ fn lint_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, expect_args: &[hi\n fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, ok_args: &[hir::Expr<'_>]) {\n     if_chain! {\n         // lint if the caller of `ok()` is a `Result`\n-        if match_type(cx, cx.tables.expr_ty(&ok_args[0]), &paths::RESULT);\n+        if is_type_diagnostic_item(cx, cx.tables.expr_ty(&ok_args[0]), sym!(result_type));\n         let result_type = cx.tables.expr_ty(&ok_args[0]);\n         if let Some(error_type) = get_error_type(cx, result_type);\n         if has_debug_impl(error_type, cx);\n@@ -2513,8 +2513,8 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n     unwrap_args: &'tcx [hir::Expr<'_>],\n ) {\n     // lint if the caller of `map()` is an `Option`\n-    let is_option = match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION);\n-    let is_result = match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::RESULT);\n+    let is_option = is_type_diagnostic_item(cx, cx.tables.expr_ty(&map_args[0]), sym!(option_type));\n+    let is_result = is_type_diagnostic_item(cx, cx.tables.expr_ty(&map_args[0]), sym!(result_type));\n \n     if is_option || is_result {\n         // Don't make a suggestion that may fail to compile due to mutably borrowing\n@@ -2581,8 +2581,8 @@ fn lint_map_or_none<'a, 'tcx>(\n     expr: &'tcx hir::Expr<'_>,\n     map_or_args: &'tcx [hir::Expr<'_>],\n ) {\n-    let is_option = match_type(cx, cx.tables.expr_ty(&map_or_args[0]), &paths::OPTION);\n-    let is_result = match_type(cx, cx.tables.expr_ty(&map_or_args[0]), &paths::RESULT);\n+    let is_option = is_type_diagnostic_item(cx, cx.tables.expr_ty(&map_or_args[0]), sym!(option_type));\n+    let is_result = is_type_diagnostic_item(cx, cx.tables.expr_ty(&map_or_args[0]), sym!(result_type));\n \n     // There are two variants of this `map_or` lint:\n     // (1) using `map_or` as an adapter from `Result<T,E>` to `Option<T>`\n@@ -3231,10 +3231,7 @@ fn is_maybe_uninit_ty_valid(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n     match ty.kind {\n         ty::Array(ref component, _) => is_maybe_uninit_ty_valid(cx, component),\n         ty::Tuple(ref types) => types.types().all(|ty| is_maybe_uninit_ty_valid(cx, ty)),\n-        ty::Adt(ref adt, _) => {\n-            // needs to be a MaybeUninit\n-            match_def_path(cx, adt.did, &paths::MEM_MAYBEUNINIT)\n-        },\n+        ty::Adt(ref adt, _) => match_def_path(cx, adt.did, &paths::MEM_MAYBEUNINIT),\n         _ => false,\n     }\n }\n@@ -3348,7 +3345,7 @@ fn lint_option_as_ref_deref<'a, 'tcx>(\n /// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext<'_, '_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n     match ty.kind {\n-        ty::Adt(_, substs) if match_type(cx, ty, &paths::RESULT) => substs.types().nth(1),\n+        ty::Adt(_, substs) if is_type_diagnostic_item(cx, ty, sym!(result_type)) => substs.types().nth(1),\n         _ => None,\n     }\n }"}, {"sha": "35d481cf666e2d3926f704834b7e17a04bb62730", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=81b3e7096bbcfff6e991346aa9d42f1298d56301", "patch": "@@ -1,5 +1,5 @@\n-use crate::utils::{differing_macro_contexts, paths, snippet_with_applicability, span_lint_and_then};\n-use crate::utils::{is_copy, match_type};\n+use crate::utils::{differing_macro_contexts, snippet_with_applicability, span_lint_and_then};\n+use crate::utils::{is_copy, is_type_diagnostic_item};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_path, NestedVisitorMap, Visitor};\n@@ -20,7 +20,7 @@ pub(super) fn lint<'a, 'tcx>(\n     map_span: Span,\n ) {\n     // lint if the caller of `map()` is an `Option`\n-    if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) {\n+    if is_type_diagnostic_item(cx, cx.tables.expr_ty(&map_args[0]), sym!(option_type)) {\n         if !is_copy(cx, cx.tables.expr_ty(&unwrap_args[1])) {\n             // Do not lint if the `map` argument uses identifiers in the `map`\n             // argument that are also used in the `unwrap_or` argument"}, {"sha": "28c1d97530938b2a37f9c0c99f0f03fa85241ede", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=81b3e7096bbcfff6e991346aa9d42f1298d56301", "patch": "@@ -5,10 +5,10 @@ use rustc_hir::{def, BindingAnnotation, Block, Expr, ExprKind, MatchSource, PatK\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n-use crate::utils::paths::{OPTION, OPTION_NONE};\n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    higher, match_def_path, match_qpath, match_type, snippet_with_applicability, span_lint_and_sugg, SpanlessEq,\n+    higher, is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet_with_applicability,\n+    span_lint_and_sugg, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -141,7 +141,7 @@ impl QuestionMark {\n     fn is_option(cx: &LateContext<'_, '_>, expression: &Expr<'_>) -> bool {\n         let expr_ty = cx.tables.expr_ty(expression);\n \n-        match_type(cx, expr_ty, &OPTION)\n+        is_type_diagnostic_item(cx, expr_ty, sym!(option_type))\n     }\n \n     fn expression_returns_none(cx: &LateContext<'_, '_>, expression: &Expr<'_>) -> bool {\n@@ -158,7 +158,7 @@ impl QuestionMark {\n                 if let Res::Def(DefKind::Ctor(def::CtorOf::Variant, def::CtorKind::Const), def_id) =\n                     cx.tables.qpath_res(qp, expression.hir_id)\n                 {\n-                    return match_def_path(cx, def_id, &OPTION_NONE);\n+                    return match_def_path(cx, def_id, &paths::OPTION_NONE);\n                 }\n \n                 false"}, {"sha": "14f4ea154ebbf9a0c0a2cc8c7d8fbbed06ee45d0", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=81b3e7096bbcfff6e991346aa9d42f1298d56301", "patch": "@@ -420,7 +420,7 @@ impl Types {\n                                 return; // don't recurse into the type\n                             }\n                         }\n-                    } else if match_def_path(cx, def_id, &paths::OPTION) {\n+                    } else if cx.tcx.is_diagnostic_item(sym!(option_type), def_id) {\n                         if match_type_parameter(cx, qpath, &paths::OPTION).is_some() {\n                             span_lint(\n                                 cx,"}, {"sha": "98dc29507c2e98e6b050da07c81e98eebb0db81a", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=81b3e7096bbcfff6e991346aa9d42f1298d56301", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{higher::if_block, match_type, paths, span_lint_and_then, usage::is_potentially_mutated};\n+use crate::utils::{higher::if_block, is_type_diagnostic_item, span_lint_and_then, usage::is_potentially_mutated};\n use if_chain::if_chain;\n use rustc_hir::intravisit::{walk_expr, walk_fn, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{BinOpKind, Body, Expr, ExprKind, FnDecl, HirId, Path, QPath, UnOp};\n@@ -100,7 +100,7 @@ fn collect_unwrap_info<'a, 'tcx>(\n             if let ExprKind::MethodCall(method_name, _, args) = &expr.kind;\n             if let ExprKind::Path(QPath::Resolved(None, path)) = &args[0].kind;\n             let ty = cx.tables.expr_ty(&args[0]);\n-            if match_type(cx, ty, &paths::OPTION) || match_type(cx, ty, &paths::RESULT);\n+            if is_type_diagnostic_item(cx, ty, sym!(option_type)) || is_type_diagnostic_item(cx, ty, sym!(result_type));\n             let name = method_name.ident.as_str();\n             if [\"is_some\", \"is_none\", \"is_ok\", \"is_err\"].contains(&&*name);\n             then {"}, {"sha": "d93f8a1e5609c47379daac3b54a2cb3c6476124d", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81b3e7096bbcfff6e991346aa9d42f1298d56301/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=81b3e7096bbcfff6e991346aa9d42f1298d56301", "patch": "@@ -1,8 +1,10 @@\n //! This module contains paths to types and functions Clippy needs to know\n //! about.\n+//!\n+//! Whenever possible, please consider diagnostic items over hardcoded paths.\n+//! See <https://github.com/rust-lang/rust-clippy/issues/5393> for more information.\n \n pub const ANY_TRAIT: [&str; 3] = [\"std\", \"any\", \"Any\"];\n-pub const ARC: [&str; 3] = [\"alloc\", \"sync\", \"Arc\"];\n pub const ARC_PTR_EQ: [&str; 4] = [\"alloc\", \"sync\", \"Arc\", \"ptr_eq\"];\n pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n@@ -59,8 +61,6 @@ pub const MEM_FORGET: [&str; 3] = [\"core\", \"mem\", \"forget\"];\n pub const MEM_MAYBEUNINIT: [&str; 4] = [\"core\", \"mem\", \"maybe_uninit\", \"MaybeUninit\"];\n pub const MEM_MAYBEUNINIT_UNINIT: [&str; 5] = [\"core\", \"mem\", \"maybe_uninit\", \"MaybeUninit\", \"uninit\"];\n pub const MEM_REPLACE: [&str; 3] = [\"core\", \"mem\", \"replace\"];\n-pub const MEM_UNINITIALIZED: [&str; 3] = [\"core\", \"mem\", \"uninitialized\"];\n-pub const MEM_ZEROED: [&str; 3] = [\"core\", \"mem\", \"zeroed\"];\n pub const MUTEX: [&str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n pub const MUTEX_GUARD: [&str; 4] = [\"std\", \"sync\", \"mutex\", \"MutexGuard\"];\n pub const OPEN_OPTIONS: [&str; 3] = [\"std\", \"fs\", \"OpenOptions\"];"}]}