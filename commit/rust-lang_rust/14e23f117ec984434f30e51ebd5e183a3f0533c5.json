{"sha": "14e23f117ec984434f30e51ebd5e183a3f0533c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ZTIzZjExN2VjOTg0NDM0ZjMwZTUxZWJkNWUxODNhM2YwNTMzYzU=", "commit": {"author": {"name": "Fran\u00e7ois Mockers", "email": "mockersf@gmail.com", "date": "2021-03-09T20:26:07Z"}, "committer": {"name": "Fran\u00e7ois Mockers", "email": "mockersf@gmail.com", "date": "2021-03-09T20:26:07Z"}, "message": "convert slice doc link to intra-doc links", "tree": {"sha": "b0cc3763e5f5867973f16df894bd5bacdf7ba7df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0cc3763e5f5867973f16df894bd5bacdf7ba7df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14e23f117ec984434f30e51ebd5e183a3f0533c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14e23f117ec984434f30e51ebd5e183a3f0533c5", "html_url": "https://github.com/rust-lang/rust/commit/14e23f117ec984434f30e51ebd5e183a3f0533c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14e23f117ec984434f30e51ebd5e183a3f0533c5/comments", "author": {"login": "mockersf", "id": 8672791, "node_id": "MDQ6VXNlcjg2NzI3OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/8672791?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mockersf", "html_url": "https://github.com/mockersf", "followers_url": "https://api.github.com/users/mockersf/followers", "following_url": "https://api.github.com/users/mockersf/following{/other_user}", "gists_url": "https://api.github.com/users/mockersf/gists{/gist_id}", "starred_url": "https://api.github.com/users/mockersf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mockersf/subscriptions", "organizations_url": "https://api.github.com/users/mockersf/orgs", "repos_url": "https://api.github.com/users/mockersf/repos", "events_url": "https://api.github.com/users/mockersf/events{/privacy}", "received_events_url": "https://api.github.com/users/mockersf/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mockersf", "id": 8672791, "node_id": "MDQ6VXNlcjg2NzI3OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/8672791?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mockersf", "html_url": "https://github.com/mockersf", "followers_url": "https://api.github.com/users/mockersf/followers", "following_url": "https://api.github.com/users/mockersf/following{/other_user}", "gists_url": "https://api.github.com/users/mockersf/gists{/gist_id}", "starred_url": "https://api.github.com/users/mockersf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mockersf/subscriptions", "organizations_url": "https://api.github.com/users/mockersf/orgs", "repos_url": "https://api.github.com/users/mockersf/repos", "events_url": "https://api.github.com/users/mockersf/events{/privacy}", "received_events_url": "https://api.github.com/users/mockersf/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f349be27815d43d462a32faeb270a22a68486b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f349be27815d43d462a32faeb270a22a68486b6", "html_url": "https://github.com/rust-lang/rust/commit/8f349be27815d43d462a32faeb270a22a68486b6"}], "stats": {"total": 117, "additions": 58, "deletions": 59}, "files": [{"sha": "8cd4ef7a14e8153f9ed712e0b6a8759cd1e96435", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14e23f117ec984434f30e51ebd5e183a3f0533c5/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e23f117ec984434f30e51ebd5e183a3f0533c5/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=14e23f117ec984434f30e51ebd5e183a3f0533c5", "patch": "@@ -231,7 +231,7 @@ impl<T> [T] {\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n-    /// See [`sort_unstable`](#method.sort_unstable).\n+    /// See [`sort_unstable`](slice::sort_unstable).\n     ///\n     /// # Current implementation\n     ///\n@@ -282,7 +282,7 @@ impl<T> [T] {\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n-    /// See [`sort_unstable_by`](#method.sort_unstable_by).\n+    /// See [`sort_unstable_by`](slice::sort_unstable_by).\n     ///\n     /// # Current implementation\n     ///\n@@ -320,12 +320,12 @@ impl<T> [T] {\n     /// worst-case, where the key function is *O*(*m*).\n     ///\n     /// For expensive key functions (e.g. functions that are not simple property accesses or\n-    /// basic operations), [`sort_by_cached_key`](#method.sort_by_cached_key) is likely to be\n+    /// basic operations), [`sort_by_cached_key`](slice::sort_by_cached_key) is likely to be\n     /// significantly faster, as it does not recompute element keys.\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n-    /// See [`sort_unstable_by_key`](#method.sort_unstable_by_key).\n+    /// See [`sort_unstable_by_key`](slice::sort_unstable_by_key).\n     ///\n     /// # Current implementation\n     ///\n@@ -363,7 +363,7 @@ impl<T> [T] {\n     /// worst-case, where the key function is *O*(*m*).\n     ///\n     /// For simple key functions (e.g., functions that are property accesses or\n-    /// basic operations), [`sort_by_key`](#method.sort_by_key) is likely to be\n+    /// basic operations), [`sort_by_key`](slice::sort_by_key) is likely to be\n     /// faster.\n     ///\n     /// # Current implementation"}, {"sha": "674780a170ecc95b9328d5fe3c649592c22376dd", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 53, "deletions": 54, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/14e23f117ec984434f30e51ebd5e183a3f0533c5/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e23f117ec984434f30e51ebd5e183a3f0533c5/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=14e23f117ec984434f30e51ebd5e183a3f0533c5", "patch": "@@ -308,7 +308,7 @@ impl<T> [T] {\n     /// Returns a mutable reference to an element or subslice depending on the\n     /// type of index (see [`get`]) or `None` if the index is out of bounds.\n     ///\n-    /// [`get`]: #method.get\n+    /// [`get`]: slice::get\n     ///\n     /// # Examples\n     ///\n@@ -339,7 +339,7 @@ impl<T> [T] {\n     /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n     /// even if the resulting reference is not used.\n     ///\n-    /// [`get`]: #method.get\n+    /// [`get`]: slice::get\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n     /// # Examples\n@@ -373,7 +373,7 @@ impl<T> [T] {\n     /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n     /// even if the resulting reference is not used.\n     ///\n-    /// [`get_mut`]: #method.get_mut\n+    /// [`get_mut`]: slice::get_mut\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n     /// # Examples\n@@ -424,7 +424,7 @@ impl<T> [T] {\n     /// }\n     /// ```\n     ///\n-    /// [`as_mut_ptr`]: #method.as_mut_ptr\n+    /// [`as_mut_ptr`]: slice::as_mut_ptr\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_slice_as_ptr\", since = \"1.32.0\")]\n     #[inline]\n@@ -487,7 +487,7 @@ impl<T> [T] {\n     /// assert!(!a.as_ptr_range().contains(&y));\n     /// ```\n     ///\n-    /// [`as_ptr`]: #method.as_ptr\n+    /// [`as_ptr`]: slice::as_ptr\n     #[stable(feature = \"slice_ptr_range\", since = \"1.48.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n@@ -529,7 +529,7 @@ impl<T> [T] {\n     /// use two pointers to refer to a range of elements in memory, as is\n     /// common in C++.\n     ///\n-    /// [`as_mut_ptr`]: #method.as_mut_ptr\n+    /// [`as_mut_ptr`]: slice::as_mut_ptr\n     #[stable(feature = \"slice_ptr_range\", since = \"1.48.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n@@ -780,8 +780,8 @@ impl<T> [T] {\n     /// assert!(iter.next().is_none());\n     /// ```\n     ///\n-    /// [`chunks_exact`]: #method.chunks_exact\n-    /// [`rchunks`]: #method.rchunks\n+    /// [`chunks_exact`]: slice::chunks_exact\n+    /// [`rchunks`]: slice::rchunks\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks(&self, chunk_size: usize) -> Chunks<'_, T> {\n@@ -818,8 +818,8 @@ impl<T> [T] {\n     /// assert_eq!(v, &[1, 1, 2, 2, 3]);\n     /// ```\n     ///\n-    /// [`chunks_exact_mut`]: #method.chunks_exact_mut\n-    /// [`rchunks_mut`]: #method.rchunks_mut\n+    /// [`chunks_exact_mut`]: slice::chunks_exact_mut\n+    /// [`rchunks_mut`]: slice::rchunks_mut\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<'_, T> {\n@@ -855,8 +855,8 @@ impl<T> [T] {\n     /// assert_eq!(iter.remainder(), &['m']);\n     /// ```\n     ///\n-    /// [`chunks`]: #method.chunks\n-    /// [`rchunks_exact`]: #method.rchunks_exact\n+    /// [`chunks`]: slice::chunks\n+    /// [`rchunks_exact`]: slice::rchunks_exact\n     #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n     #[inline]\n     pub fn chunks_exact(&self, chunk_size: usize) -> ChunksExact<'_, T> {\n@@ -897,8 +897,8 @@ impl<T> [T] {\n     /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n     /// ```\n     ///\n-    /// [`chunks_mut`]: #method.chunks_mut\n-    /// [`rchunks_exact_mut`]: #method.rchunks_exact_mut\n+    /// [`chunks_mut`]: slice::chunks_mut\n+    /// [`rchunks_exact_mut`]: slice::rchunks_exact_mut\n     #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n     #[inline]\n     pub fn chunks_exact_mut(&mut self, chunk_size: usize) -> ChunksExactMut<'_, T> {\n@@ -1032,7 +1032,7 @@ impl<T> [T] {\n     /// assert_eq!(iter.remainder(), &['m']);\n     /// ```\n     ///\n-    /// [`chunks_exact`]: #method.chunks_exact\n+    /// [`chunks_exact`]: slice::chunks_exact\n     #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n     #[inline]\n     pub fn array_chunks<const N: usize>(&self) -> ArrayChunks<'_, T, N> {\n@@ -1182,7 +1182,7 @@ impl<T> [T] {\n     /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n     /// ```\n     ///\n-    /// [`chunks_exact_mut`]: #method.chunks_exact_mut\n+    /// [`chunks_exact_mut`]: slice::chunks_exact_mut\n     #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n     #[inline]\n     pub fn array_chunks_mut<const N: usize>(&mut self) -> ArrayChunksMut<'_, T, N> {\n@@ -1214,7 +1214,7 @@ impl<T> [T] {\n     /// assert!(iter.next().is_none());\n     /// ```\n     ///\n-    /// [`windows`]: #method.windows\n+    /// [`windows`]: slice::windows\n     #[unstable(feature = \"array_windows\", issue = \"75027\")]\n     #[inline]\n     pub fn array_windows<const N: usize>(&self) -> ArrayWindows<'_, T, N> {\n@@ -1247,8 +1247,8 @@ impl<T> [T] {\n     /// assert!(iter.next().is_none());\n     /// ```\n     ///\n-    /// [`rchunks_exact`]: #method.rchunks_exact\n-    /// [`chunks`]: #method.chunks\n+    /// [`rchunks_exact`]: slice::rchunks_exact\n+    /// [`chunks`]: slice::chunks\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n     #[inline]\n     pub fn rchunks(&self, chunk_size: usize) -> RChunks<'_, T> {\n@@ -1285,8 +1285,8 @@ impl<T> [T] {\n     /// assert_eq!(v, &[3, 2, 2, 1, 1]);\n     /// ```\n     ///\n-    /// [`rchunks_exact_mut`]: #method.rchunks_exact_mut\n-    /// [`chunks_mut`]: #method.chunks_mut\n+    /// [`rchunks_exact_mut`]: slice::rchunks_exact_mut\n+    /// [`chunks_mut`]: slice::chunks_mut\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n     #[inline]\n     pub fn rchunks_mut(&mut self, chunk_size: usize) -> RChunksMut<'_, T> {\n@@ -1323,9 +1323,9 @@ impl<T> [T] {\n     /// assert_eq!(iter.remainder(), &['l']);\n     /// ```\n     ///\n-    /// [`chunks`]: #method.chunks\n-    /// [`rchunks`]: #method.rchunks\n-    /// [`chunks_exact`]: #method.chunks_exact\n+    /// [`chunks`]: slice::chunks\n+    /// [`rchunks`]: slice::rchunks\n+    /// [`chunks_exact`]: slice::chunks_exact\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n     #[inline]\n     pub fn rchunks_exact(&self, chunk_size: usize) -> RChunksExact<'_, T> {\n@@ -1366,9 +1366,9 @@ impl<T> [T] {\n     /// assert_eq!(v, &[0, 2, 2, 1, 1]);\n     /// ```\n     ///\n-    /// [`chunks_mut`]: #method.chunks_mut\n-    /// [`rchunks_mut`]: #method.rchunks_mut\n-    /// [`chunks_exact_mut`]: #method.chunks_exact_mut\n+    /// [`chunks_mut`]: slice::chunks_mut\n+    /// [`rchunks_mut`]: slice::rchunks_mut\n+    /// [`chunks_exact_mut`]: slice::chunks_exact_mut\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n     #[inline]\n     pub fn rchunks_exact_mut(&mut self, chunk_size: usize) -> RChunksExactMut<'_, T> {\n@@ -1552,7 +1552,7 @@ impl<T> [T] {\n     /// even if the resulting reference is not used. The caller has to ensure that\n     /// `0 <= mid <= self.len()`.\n     ///\n-    /// [`split_at`]: #method.split_at\n+    /// [`split_at`]: slice::split_at\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n     /// # Examples\n@@ -1601,7 +1601,7 @@ impl<T> [T] {\n     /// even if the resulting reference is not used. The caller has to ensure that\n     /// `0 <= mid <= self.len()`.\n     ///\n-    /// [`split_at_mut`]: #method.split_at_mut\n+    /// [`split_at_mut`]: slice::split_at_mut\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n     /// # Examples\n@@ -2103,9 +2103,9 @@ impl<T> [T] {\n     ///\n     /// See also [`binary_search_by`], [`binary_search_by_key`], and [`partition_point`].\n     ///\n-    /// [`binary_search_by`]: #method.binary_search_by\n-    /// [`binary_search_by_key`]: #method.binary_search_by_key\n-    /// [`partition_point`]: #method.partition_point\n+    /// [`binary_search_by`]: slice::binary_search_by\n+    /// [`binary_search_by_key`]: slice::binary_search_by_key\n+    /// [`partition_point`]: slice::partition_point\n     ///\n     /// # Examples\n     ///\n@@ -2156,9 +2156,9 @@ impl<T> [T] {\n     ///\n     /// See also [`binary_search`], [`binary_search_by_key`], and [`partition_point`].\n     ///\n-    /// [`binary_search`]: #method.binary_search\n-    /// [`binary_search_by_key`]: #method.binary_search_by_key\n-    /// [`partition_point`]: #method.partition_point\n+    /// [`binary_search`]: slice::binary_search\n+    /// [`binary_search_by_key`]: slice::binary_search_by_key\n+    /// [`partition_point`]: slice::partition_point\n     ///\n     /// # Examples\n     ///\n@@ -2215,7 +2215,7 @@ impl<T> [T] {\n     /// Binary searches this sorted slice with a key extraction function.\n     ///\n     /// Assumes that the slice is sorted by the key, for instance with\n-    /// [`sort_by_key`] using the same key extraction function.\n+    /// `sort_by_key` using the same key extraction function.\n     ///\n     /// If the value is found then [`Result::Ok`] is returned, containing the\n     /// index of the matching element. If there are multiple matches, then any\n@@ -2225,10 +2225,9 @@ impl<T> [T] {\n     ///\n     /// See also [`binary_search`], [`binary_search_by`], and [`partition_point`].\n     ///\n-    /// [`sort_by_key`]: #method.sort_by_key\n-    /// [`binary_search`]: #method.binary_search\n-    /// [`binary_search_by`]: #method.binary_search_by\n-    /// [`partition_point`]: #method.partition_point\n+    /// [`binary_search`]: slice::binary_search\n+    /// [`binary_search_by`]: slice::binary_search_by\n+    /// [`partition_point`]: slice::partition_point\n     ///\n     /// # Examples\n     ///\n@@ -2446,7 +2445,7 @@ impl<T> [T] {\n     /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n     /// used for [`sort_unstable`].\n     ///\n-    /// [`sort_unstable`]: #method.sort_unstable\n+    /// [`sort_unstable`]: slice::sort_unstable\n     ///\n     /// # Panics\n     ///\n@@ -2494,7 +2493,7 @@ impl<T> [T] {\n     /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n     /// used for [`sort_unstable`].\n     ///\n-    /// [`sort_unstable`]: #method.sort_unstable\n+    /// [`sort_unstable`]: slice::sort_unstable\n     ///\n     /// # Panics\n     ///\n@@ -2546,7 +2545,7 @@ impl<T> [T] {\n     /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n     /// used for [`sort_unstable`].\n     ///\n-    /// [`sort_unstable`]: #method.sort_unstable\n+    /// [`sort_unstable`]: slice::sort_unstable\n     ///\n     /// # Panics\n     ///\n@@ -2883,7 +2882,7 @@ impl<T> [T] {\n     /// trait to generate values, you can pass [`Default::default`] as the\n     /// argument.\n     ///\n-    /// [`fill`]: #method.fill\n+    /// [`fill`]: slice::fill\n     ///\n     /// # Examples\n     ///\n@@ -2956,8 +2955,8 @@ impl<T> [T] {\n     /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n     /// ```\n     ///\n-    /// [`copy_from_slice`]: #method.copy_from_slice\n-    /// [`split_at_mut`]: #method.split_at_mut\n+    /// [`copy_from_slice`]: slice::copy_from_slice\n+    /// [`split_at_mut`]: slice::split_at_mut\n     #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n     pub fn clone_from_slice(&mut self, src: &[T])\n     where\n@@ -3018,8 +3017,8 @@ impl<T> [T] {\n     /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n     /// ```\n     ///\n-    /// [`clone_from_slice`]: #method.clone_from_slice\n-    /// [`split_at_mut`]: #method.split_at_mut\n+    /// [`clone_from_slice`]: slice::clone_from_slice\n+    /// [`split_at_mut`]: slice::split_at_mut\n     #[doc(alias = \"memcpy\")]\n     #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n     pub fn copy_from_slice(&mut self, src: &[T])\n@@ -3136,7 +3135,7 @@ impl<T> [T] {\n     /// assert_eq!(slice, [4, 5, 3, 1, 2]);\n     /// ```\n     ///\n-    /// [`split_at_mut`]: #method.split_at_mut\n+    /// [`split_at_mut`]: slice::split_at_mut\n     #[stable(feature = \"swap_with_slice\", since = \"1.27.0\")]\n     pub fn swap_with_slice(&mut self, other: &mut [T]) {\n         assert!(self.len() == other.len(), \"destination and source slices have different lengths\");\n@@ -3380,7 +3379,7 @@ impl<T> [T] {\n     /// function to determine the ordering of two elements. Apart from that, it's equivalent to\n     /// [`is_sorted`]; see its documentation for more information.\n     ///\n-    /// [`is_sorted`]: #method.is_sorted\n+    /// [`is_sorted`]: slice::is_sorted\n     #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n     pub fn is_sorted_by<F>(&self, mut compare: F) -> bool\n     where\n@@ -3395,7 +3394,7 @@ impl<T> [T] {\n     /// elements, as determined by `f`. Apart from that, it's equivalent to [`is_sorted`]; see its\n     /// documentation for more information.\n     ///\n-    /// [`is_sorted`]: #method.is_sorted\n+    /// [`is_sorted`]: slice::is_sorted\n     ///\n     /// # Examples\n     ///\n@@ -3429,9 +3428,9 @@ impl<T> [T] {\n     ///\n     /// See also [`binary_search`], [`binary_search_by`], and [`binary_search_by_key`].\n     ///\n-    /// [`binary_search`]: #method.binary_search\n-    /// [`binary_search_by`]: #method.binary_search_by\n-    /// [`binary_search_by_key`]: #method.binary_search_by_key\n+    /// [`binary_search`]: slice::binary_search\n+    /// [`binary_search_by`]: slice::binary_search_by\n+    /// [`binary_search_by_key`]: slice::binary_search_by_key\n     ///\n     /// # Examples\n     ///"}]}