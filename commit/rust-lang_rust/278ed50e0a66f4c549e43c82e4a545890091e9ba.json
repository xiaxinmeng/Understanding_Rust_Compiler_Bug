{"sha": "278ed50e0a66f4c549e43c82e4a545890091e9ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3OGVkNTBlMGE2NmY0YzU0OWU0M2M4MmU0YTU0NTg5MDA5MWU5YmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-11T16:34:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-11T16:34:40Z"}, "message": "auto merge of #7455 : nikomatsakis/rust/issue-7336-constrain-closure-lifetimes, r=pnkfelix\n\nConstrain maximum lifetime of stack closures that capture variables to be limited by the innermost repeating scope.\r\n\r\nFixes #7336.\r\n\r\nr? whomever.", "tree": {"sha": "829c2795aec6fb44c680343e65e09f79e7b18d0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/829c2795aec6fb44c680343e65e09f79e7b18d0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/278ed50e0a66f4c549e43c82e4a545890091e9ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/278ed50e0a66f4c549e43c82e4a545890091e9ba", "html_url": "https://github.com/rust-lang/rust/commit/278ed50e0a66f4c549e43c82e4a545890091e9ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/278ed50e0a66f4c549e43c82e4a545890091e9ba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e95fcfafc7a2349217096bc1ed8b8c273b6a0e2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e95fcfafc7a2349217096bc1ed8b8c273b6a0e2b", "html_url": "https://github.com/rust-lang/rust/commit/e95fcfafc7a2349217096bc1ed8b8c273b6a0e2b"}, {"sha": "3b8c5a1a3772a5c4d64d202db8b0af94651b08ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b8c5a1a3772a5c4d64d202db8b0af94651b08ff", "html_url": "https://github.com/rust-lang/rust/commit/3b8c5a1a3772a5c4d64d202db8b0af94651b08ff"}], "stats": {"total": 248, "additions": 209, "deletions": 39}, "files": [{"sha": "d2953f8913e29e4cd83d7bbfd14ce0fa4aa1f541", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/278ed50e0a66f4c549e43c82e4a545890091e9ba/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278ed50e0a66f4c549e43c82e4a545890091e9ba/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=278ed50e0a66f4c549e43c82e4a545890091e9ba", "patch": "@@ -220,16 +220,24 @@ pub fn store_environment(bcx: block,\n     // compute the type of the closure\n     let cdata_ty = mk_closure_tys(tcx, bound_values);\n \n-    // allocate closure in the heap\n-    let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, sigil, cdata_ty);\n-\n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n     // tuple.  This could be a ptr in uniq or a box or on stack,\n     // whatever.\n     let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n     let cboxptr_ty = ty::mk_ptr(tcx, ty::mt {ty:cbox_ty, mutbl:ast::m_imm});\n+    let llboxptr_ty = type_of(ccx, cboxptr_ty);\n+\n+    // If there are no bound values, no point in allocating anything.\n+    if bound_values.is_empty() {\n+        return ClosureResult {llbox: C_null(llboxptr_ty),\n+                              cdata_ty: cdata_ty,\n+                              bcx: bcx};\n+    }\n \n-    let llbox = PointerCast(bcx, llbox, type_of(ccx, cboxptr_ty));\n+    // allocate closure in the heap\n+    let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, sigil, cdata_ty);\n+\n+    let llbox = PointerCast(bcx, llbox, llboxptr_ty);\n     debug!(\"tuplify_box_ty = %s\", ty_to_str(tcx, cbox_ty));\n \n     // Copy expr values into boxed bindings.\n@@ -268,6 +276,7 @@ pub fn build_closure(bcx0: block,\n                      sigil: ast::Sigil,\n                      include_ret_handle: Option<ValueRef>) -> ClosureResult {\n     let _icx = push_ctxt(\"closure::build_closure\");\n+\n     // If we need to, package up the iterator body to call\n     let bcx = bcx0;\n "}, {"sha": "6e3f0a208430a46bbf2520e5c4c530a6984e5e29", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 99, "deletions": 12, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/278ed50e0a66f4c549e43c82e4a545890091e9ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278ed50e0a66f4c549e43c82e4a545890091e9ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=278ed50e0a66f4c549e43c82e4a545890091e9ba", "patch": "@@ -48,7 +48,10 @@ use syntax::visit;\n \n pub struct Rcx {\n     fcx: @mut FnCtxt,\n-    errors_reported: uint\n+    errors_reported: uint,\n+\n+    // id of innermost fn or loop\n+    repeating_scope: ast::node_id,\n }\n \n pub type rvt = visit::vt<@mut Rcx>;\n@@ -78,6 +81,12 @@ impl Rcx {\n         self.fcx.ccx.tcx\n     }\n \n+    pub fn set_repeating_scope(&mut self, scope: ast::node_id) -> ast::node_id {\n+        let old_scope = self.repeating_scope;\n+        self.repeating_scope = scope;\n+        old_scope\n+    }\n+\n     pub fn resolve_type(&mut self, unresolved_ty: ty::t) -> ty::t {\n         /*!\n          * Try to resolve the type for the given node, returning\n@@ -134,7 +143,8 @@ impl Rcx {\n }\n \n pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::expr) {\n-    let rcx = @mut Rcx { fcx: fcx, errors_reported: 0 };\n+    let rcx = @mut Rcx { fcx: fcx, errors_reported: 0,\n+                         repeating_scope: e.id };\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n         let v = regionck_visitor();\n@@ -144,7 +154,8 @@ pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::expr) {\n }\n \n pub fn regionck_fn(fcx: @mut FnCtxt, blk: &ast::blk) {\n-    let rcx = @mut Rcx { fcx: fcx, errors_reported: 0 };\n+    let rcx = @mut Rcx { fcx: fcx, errors_reported: 0,\n+                         repeating_scope: blk.node.id };\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n         let v = regionck_visitor();\n@@ -231,7 +242,8 @@ fn constrain_bindings_in_pat(pat: @ast::pat, rcx: @mut Rcx) {\n }\n \n fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n-    debug!(\"regionck::visit_expr(e=?)\");\n+    debug!(\"regionck::visit_expr(e=%s, repeating_scope=%?)\",\n+           expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n     let has_method_map = rcx.fcx.inh.method_map.contains_key(&expr.id);\n \n@@ -274,6 +286,9 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n                 }\n             }\n         }\n+        ast::expr_loop(ref body, _) => {\n+            tcx.region_maps.record_cleanup_scope(body.node.id);\n+        }\n         ast::expr_while(cond, ref body) => {\n             tcx.region_maps.record_cleanup_scope(cond.id);\n             tcx.region_maps.record_cleanup_scope(body.node.id);\n@@ -313,10 +328,14 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n         ast::expr_call(callee, ref args, _) => {\n             constrain_callee(rcx, callee.id, expr, callee);\n             constrain_call(rcx, callee.id, expr, None, *args, false);\n+\n+            visit::visit_expr(expr, (rcx, v));\n         }\n \n         ast::expr_method_call(callee_id, arg0, _, _, ref args, _) => {\n             constrain_call(rcx, callee_id, expr, Some(arg0), *args, false);\n+\n+            visit::visit_expr(expr, (rcx, v));\n         }\n \n         ast::expr_index(callee_id, lhs, rhs) |\n@@ -327,23 +346,31 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n             // implicit \"by ref\" sort of passing style here.  This\n             // should be converted to an adjustment!\n             constrain_call(rcx, callee_id, expr, Some(lhs), [rhs], true);\n+\n+            visit::visit_expr(expr, (rcx, v));\n         }\n \n         ast::expr_unary(callee_id, _, lhs) if has_method_map => {\n             // As above.\n             constrain_call(rcx, callee_id, expr, Some(lhs), [], true);\n+\n+            visit::visit_expr(expr, (rcx, v));\n         }\n \n         ast::expr_unary(_, ast::deref, base) => {\n             // For *a, the lifetime of a must enclose the deref\n             let base_ty = rcx.resolve_node_type(base.id);\n             constrain_derefs(rcx, expr, 1, base_ty);\n+\n+            visit::visit_expr(expr, (rcx, v));\n         }\n \n         ast::expr_index(_, vec_expr, _) => {\n             // For a[b], the lifetime of a must enclose the deref\n             let vec_type = rcx.resolve_expr_type_adjusted(vec_expr);\n             constrain_index(rcx, expr, vec_type);\n+\n+            visit::visit_expr(expr, (rcx, v));\n         }\n \n         ast::expr_cast(source, _) => {\n@@ -372,6 +399,8 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n                 }\n                 _ => ()\n             }\n+\n+            visit::visit_expr(expr, (rcx, v));\n         }\n \n         ast::expr_addr_of(_, base) => {\n@@ -387,29 +416,87 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n             let ty0 = rcx.resolve_node_type(expr.id);\n             constrain_regions_in_type(rcx, ty::re_scope(expr.id),\n                                       infer::AddrOf(expr.span), ty0);\n+            visit::visit_expr(expr, (rcx, v));\n         }\n \n         ast::expr_match(discr, ref arms) => {\n             guarantor::for_match(rcx, discr, *arms);\n+\n+            visit::visit_expr(expr, (rcx, v));\n+        }\n+\n+        ast::expr_loop_body(subexpr) => {\n+            check_expr_fn_block(rcx, subexpr, v, true);\n         }\n \n         ast::expr_fn_block(*) => {\n-            // The lifetime of a block fn must not outlive the variables\n-            // it closes over\n+            check_expr_fn_block(rcx, expr, v, false);\n+        }\n+\n+        ast::expr_loop(ref body, _) => {\n+            let repeating_scope = rcx.set_repeating_scope(body.node.id);\n+            visit::visit_expr(expr, (rcx, v));\n+            rcx.set_repeating_scope(repeating_scope);\n+        }\n+\n+        ast::expr_while(cond, ref body) => {\n+            let repeating_scope = rcx.set_repeating_scope(cond.id);\n+            (v.visit_expr)(cond, (rcx, v));\n+\n+            rcx.set_repeating_scope(body.node.id);\n+            (v.visit_block)(body, (rcx, v));\n+\n+            rcx.set_repeating_scope(repeating_scope);\n+        }\n+\n+        _ => {\n+            visit::visit_expr(expr, (rcx, v));\n+        }\n+    }\n+}\n+\n+fn check_expr_fn_block(rcx: @mut Rcx,\n+                       expr: @ast::expr,\n+                       v: rvt,\n+                       is_loop_body: bool) {\n+    let tcx = rcx.fcx.tcx();\n+    match expr.node {\n+        ast::expr_fn_block(_, ref body) => {\n             let function_type = rcx.resolve_node_type(expr.id);\n             match ty::get(function_type).sty {\n-                ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n-                                              region: region, _}) => {\n-                    constrain_free_variables(rcx, region, expr);\n+                ty::ty_closure(\n+                    ty::ClosureTy {\n+                        sigil: ast::BorrowedSigil, region: region, _}) => {\n+                    if get_freevars(tcx, expr.id).is_empty() && !is_loop_body {\n+                        // No free variables means that the environment\n+                        // will be NULL at runtime and hence the closure\n+                        // has static lifetime.\n+                    } else {\n+                        // Otherwise, the closure must not outlive the\n+                        // variables it closes over, nor can it\n+                        // outlive the innermost repeating scope\n+                        // (since otherwise that would require\n+                        // infinite stack).\n+                        constrain_free_variables(rcx, region, expr);\n+                        let repeating_scope = ty::re_scope(rcx.repeating_scope);\n+                        rcx.fcx.mk_subr(true, infer::InfStackClosure(expr.span),\n+                                        region, repeating_scope);\n+                    }\n                 }\n                 _ => ()\n             }\n+\n+            let repeating_scope = rcx.set_repeating_scope(body.node.id);\n+            visit::visit_expr(expr, (rcx, v));\n+            rcx.set_repeating_scope(repeating_scope);\n         }\n \n-        _ => ()\n+        _ => {\n+            tcx.sess.span_bug(\n+                expr.span,\n+                \"Expected expr_fn_block\");\n+        }\n     }\n-\n-    visit::visit_expr(expr, (rcx, v));\n }\n \n fn constrain_callee(rcx: @mut Rcx,"}, {"sha": "ae8cab4c4dbd19348abd63b23c11e96c6fec891b", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/278ed50e0a66f4c549e43c82e4a545890091e9ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278ed50e0a66f4c549e43c82e4a545890091e9ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=278ed50e0a66f4c549e43c82e4a545890091e9ba", "patch": "@@ -231,6 +231,21 @@ impl ErrorReporting for InferCtxt {\n                     sup,\n                     \"\");\n             }\n+            infer::InfStackClosure(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"closure outlives stack frame\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"...the closure must be valid for \",\n+                    sub,\n+                    \"...\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"...but the closure's stack frame is only valid for \",\n+                    sup,\n+                    \"\");\n+            }\n             infer::InvokeClosure(span) => {\n                 self.tcx.sess.span_err(\n                     span,"}, {"sha": "2a8d68c9e671c322c51d5a50f778275166b8f9f7", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/278ed50e0a66f4c549e43c82e4a545890091e9ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278ed50e0a66f4c549e43c82e4a545890091e9ba/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=278ed50e0a66f4c549e43c82e4a545890091e9ba", "patch": "@@ -141,6 +141,10 @@ pub enum SubregionOrigin {\n     // Arose from a subtyping relation\n     Subtype(TypeTrace),\n \n+    // Stack-allocated closures cannot outlive innermost loop\n+    // or function so as to ensure we only require finite stack\n+    InfStackClosure(span),\n+\n     // Invocation of closure must be within its lifetime\n     InvokeClosure(span),\n \n@@ -829,6 +833,7 @@ impl SubregionOrigin {\n     pub fn span(&self) -> span {\n         match *self {\n             Subtype(a) => a.span(),\n+            InfStackClosure(a) => a,\n             InvokeClosure(a) => a,\n             DerefPointer(a) => a,\n             FreeVariable(a) => a,\n@@ -850,6 +855,7 @@ impl Repr for SubregionOrigin {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n             Subtype(a) => fmt!(\"Subtype(%s)\", a.repr(tcx)),\n+            InfStackClosure(a) => fmt!(\"InfStackClosure(%s)\", a.repr(tcx)),\n             InvokeClosure(a) => fmt!(\"InvokeClosure(%s)\", a.repr(tcx)),\n             DerefPointer(a) => fmt!(\"DerefPointer(%s)\", a.repr(tcx)),\n             FreeVariable(a) => fmt!(\"FreeVariable(%s)\", a.repr(tcx)),"}, {"sha": "604b324cbbd43777aeb3ec5d65a09bb349714e96", "filename": "src/test/compile-fail/regionck-closure-lifetimes.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/278ed50e0a66f4c549e43c82e4a545890091e9ba/src%2Ftest%2Fcompile-fail%2Fregionck-closure-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/278ed50e0a66f4c549e43c82e4a545890091e9ba/src%2Ftest%2Fcompile-fail%2Fregionck-closure-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregionck-closure-lifetimes.rs?ref=278ed50e0a66f4c549e43c82e4a545890091e9ba", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn env<'a>(_: &'a uint, blk: &fn(p: &'a fn())) {\n+    // Test that the closure here cannot be assigned\n+    // the lifetime `'a`, which outlives the current\n+    // block.\n+    //\n+    // FIXME(#4846): The `&'a uint` parameter is needed to ensure that `'a`\n+    // is a free and not bound region name.\n+\n+    let mut state = 0;\n+    let statep = &mut state;\n+    blk(|| *statep = 1); //~ ERROR cannot infer an appropriate lifetime\n+}\n+\n+fn no_env_no_for<'a>(_: &'a uint, blk: &fn(p: &'a fn())) {\n+    // Test that a closure with no free variables CAN\n+    // outlive the block in which it is created.\n+    //\n+    // FIXME(#4846): The `&'a uint` parameter is needed to ensure that `'a`\n+    // is a free and not bound region name.\n+\n+    blk(|| ())\n+}\n+\n+fn no_env_but_for<'a>(_: &'a uint, blk: &fn(p: &'a fn() -> bool) -> bool) {\n+    // Test that a `for` loop is considered to hvae\n+    // implicit free variables.\n+    //\n+    // FIXME(#4846): The `&'a uint` parameter is needed to ensure that `'a`\n+    // is a free and not bound region name.\n+\n+    for blk { } //~ ERROR cannot infer an appropriate lifetime\n+}\n+\n+fn repeating_loop() {\n+    // Test that the closure cannot be created within `loop` loop and\n+    // called without, even though the state that it closes over is\n+    // external to the loop.\n+\n+    let closure;\n+    let state = 0;\n+\n+    loop {\n+        closure = || state; //~ ERROR cannot infer an appropriate lifetime\n+        break;\n+    }\n+\n+    closure();\n+}\n+\n+fn repeating_while() {\n+    // Test that the closure cannot be created within `while` loop and\n+    // called without, even though the state that it closes over is\n+    // external to the loop.\n+\n+    let closure;\n+    let state = 0;\n+\n+    while true {\n+        closure = || state; //~ ERROR cannot infer an appropriate lifetime\n+        break;\n+    }\n+\n+    closure();\n+}\n+\n+fn main() {}"}, {"sha": "2341ee8d100c1805b967962ec4b5762870f0a83e", "filename": "src/test/run-pass/unconstrained-region.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e95fcfafc7a2349217096bc1ed8b8c273b6a0e2b/src%2Ftest%2Frun-pass%2Funconstrained-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95fcfafc7a2349217096bc1ed8b8c273b6a0e2b/src%2Ftest%2Frun-pass%2Funconstrained-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funconstrained-region.rs?ref=e95fcfafc7a2349217096bc1ed8b8c273b6a0e2b", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-test\n-// FIXME: #7336: codegen bug makes this segfault on Linux x86_64\n-\n-fn foo<'a>(blk: &fn(p: &'a fn() -> &'a fn())) {\n-    let mut state = 0;\n-    let statep = &mut state;\n-    do blk {\n-        || { *statep = 1; }\n-    }\n-}\n-fn main() {\n-    do foo |p| { p()() }\n-}"}]}