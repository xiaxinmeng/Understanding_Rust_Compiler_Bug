{"sha": "7bb106fe633872de703af46381843057f8cd384f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYjEwNmZlNjMzODcyZGU3MDNhZjQ2MzgxODQzMDU3ZjhjZDM4NGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-16T13:23:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-16T13:23:46Z"}, "message": "Auto merge of #76786 - Dylan-DPC:rollup-x6p60m6, r=Dylan-DPC\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #76669 (Prefer asm! over llvm_asm! in core)\n - #76675 (Small improvements to asm documentation)\n - #76681 (remove orphaned files)\n - #76694 (Introduce a PartitioningCx struct)\n - #76695 (fix syntax error in suggesting generic constraint in trait parameter)\n - #76699 (improve const infer error)\n - #76707 (Simplify iter flatten struct doc)\n - #76710 (:arrow_up: rust-analyzer)\n - #76714 (Small docs improvements)\n - #76717 (Fix generating rustc docs with non-default lib directory.)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "05487dfb7b864c32f3391dcd8d964e7f86459a39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05487dfb7b864c32f3391dcd8d964e7f86459a39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bb106fe633872de703af46381843057f8cd384f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bb106fe633872de703af46381843057f8cd384f", "html_url": "https://github.com/rust-lang/rust/commit/7bb106fe633872de703af46381843057f8cd384f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bb106fe633872de703af46381843057f8cd384f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fae56971d8487088c0099c82c0a5ce1638b5f62", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fae56971d8487088c0099c82c0a5ce1638b5f62", "html_url": "https://github.com/rust-lang/rust/commit/5fae56971d8487088c0099c82c0a5ce1638b5f62"}, {"sha": "f63129356537822c3c108ecea8cda4bc741557b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f63129356537822c3c108ecea8cda4bc741557b5", "html_url": "https://github.com/rust-lang/rust/commit/f63129356537822c3c108ecea8cda4bc741557b5"}], "stats": {"total": 445, "additions": 290, "deletions": 155}, "files": [{"sha": "f87406c2ce469c97f15da28c3d9950abb90942d6", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -6,9 +6,10 @@ use rustc_hir::def::{DefKind, Namespace};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{Body, Expr, ExprKind, FnRetTy, HirId, Local, Pat};\n use rustc_middle::hir::map::Map;\n+use rustc_middle::infer::unify_key::ConstVariableOriginKind;\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, DefIdTree, Ty};\n+use rustc_middle::ty::{self, DefIdTree, InferConst, Ty};\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n@@ -569,14 +570,26 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             local_visitor.visit_expr(expr);\n         }\n \n+        let mut param_name = None;\n+        let span = if let ty::ConstKind::Infer(InferConst::Var(vid)) = ct.val {\n+            let origin = self.inner.borrow_mut().const_unification_table().probe_value(vid).origin;\n+            if let ConstVariableOriginKind::ConstParameterDefinition(param) = origin.kind {\n+                param_name = Some(param);\n+            }\n+            origin.span\n+        } else {\n+            local_visitor.target_span\n+        };\n+\n         let error_code = error_code.into();\n-        let mut err = self.tcx.sess.struct_span_err_with_code(\n-            local_visitor.target_span,\n-            \"type annotations needed\",\n-            error_code,\n-        );\n+        let mut err =\n+            self.tcx.sess.struct_span_err_with_code(span, \"type annotations needed\", error_code);\n \n-        err.note(\"unable to infer the value of a const parameter\");\n+        if let Some(param_name) = param_name {\n+            err.note(&format!(\"cannot infer the value of the const parameter `{}`\", param_name));\n+        } else {\n+            err.note(\"unable to infer the value of a const parameter\");\n+        }\n \n         err\n     }"}, {"sha": "a60a17befeffdce2b344112e4508b5910445d03e", "filename": "compiler/rustc_middle/src/infer/unify_key.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -124,6 +124,7 @@ pub struct ConstVariableOrigin {\n pub enum ConstVariableOriginKind {\n     MiscVariable,\n     ConstInference,\n+    // FIXME(const_generics): Consider storing the `DefId` of the param here.\n     ConstParameterDefinition(Symbol),\n     SubstitutionPlaceholder,\n }"}, {"sha": "29daf7e9309aa36716a15ad9e430b5e5f3926580", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -2285,8 +2285,8 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n /// Constants\n ///\n /// Two constants are equal if they are the same constant. Note that\n-/// this does not necessarily mean that they are \"==\" in Rust -- in\n-/// particular one must be wary of `NaN`!\n+/// this does not necessarily mean that they are `==` in Rust -- in\n+/// particular, one must be wary of `NaN`!\n \n #[derive(Clone, Copy, PartialEq, TyEncodable, TyDecodable, HashStable)]\n pub struct Constant<'tcx> {"}, {"sha": "56746666e2f1fea12c9e2e1171b8a08201c08068", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -66,8 +66,8 @@ use std::mem;\n use std::ops::{Bound, Deref};\n use std::sync::Arc;\n \n-/// A type that is not publicly constructable. This prevents people from making `TyKind::Error`\n-/// except through `tcx.err*()`, which are in this module.\n+/// A type that is not publicly constructable. This prevents people from making [`TyKind::Error`]s\n+/// except through the error-reporting functions on a [`tcx`][TyCtxt].\n #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\n #[derive(TyEncodable, TyDecodable, HashStable)]\n pub struct DelaySpanBugEmitted(());"}, {"sha": "715319747e3900adf34732b690bc1e93a05ee94c", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 46, "deletions": 20, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -202,33 +202,59 @@ pub fn suggest_constraining_type_param(\n         //    Suggestion:\n         //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n         //                                          - insert: `, T: Zar`\n+        //\n+        // Additionally, there may be no `where` clause whatsoever in the case that this was\n+        // reached because the generic parameter has a default:\n+        //\n+        //    Message:\n+        //      trait Foo<T=()> {... }\n+        //             - help: consider further restricting this type parameter with `where T: Zar`\n+        //\n+        //    Suggestion:\n+        //      trait Foo<T=()> where T: Zar {... }\n+        //                     - insert: `where T: Zar`\n \n-        let mut param_spans = Vec::new();\n+        if matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n+            && generics.where_clause.predicates.len() == 0\n+        {\n+            // Suggest a bound, but there is no existing `where` clause *and* the type param has a\n+            // default (`<T=Foo>`), so we suggest adding `where T: Bar`.\n+            err.span_suggestion_verbose(\n+                generics.where_clause.tail_span_for_suggestion(),\n+                &msg_restrict_type_further,\n+                format!(\" where {}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            let mut param_spans = Vec::new();\n \n-        for predicate in generics.where_clause.predicates {\n-            if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                span, bounded_ty, ..\n-            }) = predicate\n-            {\n-                if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n-                    if let Some(segment) = path.segments.first() {\n-                        if segment.ident.to_string() == param_name {\n-                            param_spans.push(span);\n+            for predicate in generics.where_clause.predicates {\n+                if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n+                    span,\n+                    bounded_ty,\n+                    ..\n+                }) = predicate\n+                {\n+                    if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n+                        if let Some(segment) = path.segments.first() {\n+                            if segment.ident.to_string() == param_name {\n+                                param_spans.push(span);\n+                            }\n                         }\n                     }\n                 }\n             }\n-        }\n \n-        match &param_spans[..] {\n-            &[&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n-            _ => {\n-                err.span_suggestion_verbose(\n-                    generics.where_clause.tail_span_for_suggestion(),\n-                    &msg_restrict_type_further,\n-                    format!(\", {}: {}\", param_name, constraint),\n-                    Applicability::MachineApplicable,\n-                );\n+            match &param_spans[..] {\n+                &[&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n+                _ => {\n+                    err.span_suggestion_verbose(\n+                        generics.where_clause.tail_span_for_suggestion(),\n+                        &msg_restrict_type_further,\n+                        format!(\", {}: {}\", param_name, constraint),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n             }\n         }\n "}, {"sha": "d4c8ba082751e89a13abeb1a95c9fc7e0ce6239e", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -1233,13 +1233,13 @@ rustc_index::newtype_index! {\n     /// particular, imagine a type like this:\n     ///\n     ///     for<'a> fn(for<'b> fn(&'b isize, &'a isize), &'a char)\n-    ///     ^          ^            |        |         |\n-    ///     |          |            |        |         |\n-    ///     |          +------------+ 0      |         |\n-    ///     |                                |         |\n-    ///     +--------------------------------+ 1       |\n-    ///     |                                          |\n-    ///     +------------------------------------------+ 0\n+    ///     ^          ^            |          |           |\n+    ///     |          |            |          |           |\n+    ///     |          +------------+ 0        |           |\n+    ///     |                                  |           |\n+    ///     +----------------------------------+ 1         |\n+    ///     |                                              |\n+    ///     +----------------------------------------------+ 0\n     ///\n     /// In this type, there are two binders (the outer fn and the inner\n     /// fn). We need to be able to determine, for any given region, which"}, {"sha": "827d037f3198888888f36188d4470fbb122b2544", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/default.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fdefault.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -11,6 +11,7 @@ use rustc_middle::ty::print::characteristic_def_id_of_type;\n use rustc_middle::ty::{self, DefIdTree, InstanceDef, TyCtxt};\n use rustc_span::symbol::Symbol;\n \n+use super::PartitioningCx;\n use crate::monomorphize::collector::InliningMap;\n use crate::monomorphize::partitioning::merging;\n use crate::monomorphize::partitioning::{\n@@ -22,35 +23,36 @@ pub struct DefaultPartitioning;\n impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n     fn place_root_mono_items(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         mono_items: &mut dyn Iterator<Item = MonoItem<'tcx>>,\n     ) -> PreInliningPartitioning<'tcx> {\n         let mut roots = FxHashSet::default();\n         let mut codegen_units = FxHashMap::default();\n-        let is_incremental_build = tcx.sess.opts.incremental.is_some();\n+        let is_incremental_build = cx.tcx.sess.opts.incremental.is_some();\n         let mut internalization_candidates = FxHashSet::default();\n \n         // Determine if monomorphizations instantiated in this crate will be made\n         // available to downstream crates. This depends on whether we are in\n         // share-generics mode and whether the current crate can even have\n         // downstream crates.\n-        let export_generics = tcx.sess.opts.share_generics() && tcx.local_crate_exports_generics();\n+        let export_generics =\n+            cx.tcx.sess.opts.share_generics() && cx.tcx.local_crate_exports_generics();\n \n-        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n         let cgu_name_cache = &mut FxHashMap::default();\n \n         for mono_item in mono_items {\n-            match mono_item.instantiation_mode(tcx) {\n+            match mono_item.instantiation_mode(cx.tcx) {\n                 InstantiationMode::GloballyShared { .. } => {}\n                 InstantiationMode::LocalCopy => continue,\n             }\n \n-            let characteristic_def_id = characteristic_def_id_of_mono_item(tcx, mono_item);\n+            let characteristic_def_id = characteristic_def_id_of_mono_item(cx.tcx, mono_item);\n             let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n \n             let codegen_unit_name = match characteristic_def_id {\n                 Some(def_id) => compute_codegen_unit_name(\n-                    tcx,\n+                    cx.tcx,\n                     cgu_name_builder,\n                     def_id,\n                     is_volatile,\n@@ -65,7 +67,7 @@ impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n \n             let mut can_be_internalized = true;\n             let (linkage, visibility) = mono_item_linkage_and_visibility(\n-                tcx,\n+                cx.tcx,\n                 &mono_item,\n                 &mut can_be_internalized,\n                 export_generics,\n@@ -97,17 +99,16 @@ impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n \n     fn merge_codegen_units(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-        target_cgu_count: usize,\n     ) {\n-        merging::merge_codegen_units(tcx, initial_partitioning, target_cgu_count);\n+        merging::merge_codegen_units(cx, initial_partitioning);\n     }\n \n     fn place_inlined_mono_items(\n         &mut self,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         initial_partitioning: PreInliningPartitioning<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n     ) -> PostInliningPartitioning<'tcx> {\n         let mut new_partitioning = Vec::new();\n         let mut mono_item_placements = FxHashMap::default();\n@@ -124,7 +125,7 @@ impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n             // Collect all items that need to be available in this codegen unit.\n             let mut reachable = FxHashSet::default();\n             for root in old_codegen_unit.items().keys() {\n-                follow_inlining(*root, inlining_map, &mut reachable);\n+                follow_inlining(*root, cx.inlining_map, &mut reachable);\n             }\n \n             let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n@@ -198,9 +199,8 @@ impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n \n     fn internalize_symbols(\n         &mut self,\n-        _tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         partitioning: &mut PostInliningPartitioning<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n     ) {\n         if partitioning.codegen_units.len() == 1 {\n             // Fast path for when there is only one codegen unit. In this case we\n@@ -218,7 +218,7 @@ impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n         // Build a map from every monomorphization to all the monomorphizations that\n         // reference it.\n         let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n-        inlining_map.iter_accesses(|accessor, accessees| {\n+        cx.inlining_map.iter_accesses(|accessor, accessees| {\n             for accessee in accessees {\n                 accessor_map.entry(*accessee).or_default().push(accessor);\n             }"}, {"sha": "5107e6972632c2d2a295c6e4e8a2608697bacd97", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/merging.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmerging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmerging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmerging.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -3,17 +3,16 @@ use std::cmp;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder};\n-use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{Symbol, SymbolStr};\n \n+use super::PartitioningCx;\n use crate::monomorphize::partitioning::PreInliningPartitioning;\n \n pub fn merge_codegen_units<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+    cx: &PartitioningCx<'_, 'tcx>,\n     initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-    target_cgu_count: usize,\n ) {\n-    assert!(target_cgu_count >= 1);\n+    assert!(cx.target_cgu_count >= 1);\n     let codegen_units = &mut initial_partitioning.codegen_units;\n \n     // Note that at this point in time the `codegen_units` here may not be in a\n@@ -32,7 +31,7 @@ pub fn merge_codegen_units<'tcx>(\n         codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name().as_str()])).collect();\n \n     // Merge the two smallest codegen units until the target size is reached.\n-    while codegen_units.len() > target_cgu_count {\n+    while codegen_units.len() > cx.target_cgu_count {\n         // Sort small cgus to the back\n         codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n         let mut smallest = codegen_units.pop().unwrap();\n@@ -56,9 +55,9 @@ pub fn merge_codegen_units<'tcx>(\n         );\n     }\n \n-    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n \n-    if tcx.sess.opts.incremental.is_some() {\n+    if cx.tcx.sess.opts.incremental.is_some() {\n         // If we are doing incremental compilation, we want CGU names to\n         // reflect the path of the source level module they correspond to.\n         // For CGUs that contain the code of multiple modules because of the\n@@ -84,7 +83,7 @@ pub fn merge_codegen_units<'tcx>(\n \n         for cgu in codegen_units.iter_mut() {\n             if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n-                if tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n+                if cx.tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n                     cgu.set_name(Symbol::intern(&new_cgu_name));\n                 } else {\n                     // If we don't require CGU names to be human-readable, we"}, {"sha": "b60beca688068c8494e5e4211e92bcfd01543463", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/mod.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmod.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -108,31 +108,35 @@ use rustc_span::symbol::Symbol;\n use crate::monomorphize::collector::InliningMap;\n use crate::monomorphize::collector::{self, MonoItemCollectionMode};\n \n+pub struct PartitioningCx<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    target_cgu_count: usize,\n+    inlining_map: &'a InliningMap<'tcx>,\n+}\n+\n trait Partitioner<'tcx> {\n     fn place_root_mono_items(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         mono_items: &mut dyn Iterator<Item = MonoItem<'tcx>>,\n     ) -> PreInliningPartitioning<'tcx>;\n \n     fn merge_codegen_units(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-        target_cgu_count: usize,\n     );\n \n     fn place_inlined_mono_items(\n         &mut self,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         initial_partitioning: PreInliningPartitioning<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n     ) -> PostInliningPartitioning<'tcx>;\n \n     fn internalize_symbols(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n+        cx: &PartitioningCx<'_, 'tcx>,\n         partitioning: &mut PostInliningPartitioning<'tcx>,\n-        inlining_map: &InliningMap<'tcx>,\n     );\n }\n \n@@ -157,12 +161,13 @@ pub fn partition<'tcx>(\n     let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning\");\n \n     let mut partitioner = get_partitioner(tcx);\n+    let cx = &PartitioningCx { tcx, target_cgu_count: max_cgu_count, inlining_map };\n     // In the first step, we place all regular monomorphizations into their\n     // respective 'home' codegen unit. Regular monomorphizations are all\n     // functions and statics defined in the local crate.\n     let mut initial_partitioning = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n-        partitioner.place_root_mono_items(tcx, mono_items)\n+        partitioner.place_root_mono_items(cx, mono_items)\n     };\n \n     initial_partitioning.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(tcx));\n@@ -172,7 +177,7 @@ pub fn partition<'tcx>(\n     // Merge until we have at most `max_cgu_count` codegen units.\n     {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n-        partitioner.merge_codegen_units(tcx, &mut initial_partitioning, max_cgu_count);\n+        partitioner.merge_codegen_units(cx, &mut initial_partitioning);\n         debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n \n@@ -182,7 +187,7 @@ pub fn partition<'tcx>(\n     // local functions the definition of which is marked with `#[inline]`.\n     let mut post_inlining = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n-        partitioner.place_inlined_mono_items(initial_partitioning, inlining_map)\n+        partitioner.place_inlined_mono_items(cx, initial_partitioning)\n     };\n \n     post_inlining.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(tcx));\n@@ -193,7 +198,7 @@ pub fn partition<'tcx>(\n     // more freedom to optimize.\n     if !tcx.sess.link_dead_code() {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n-        partitioner.internalize_symbols(tcx, &mut post_inlining, inlining_map);\n+        partitioner.internalize_symbols(cx, &mut post_inlining);\n     }\n \n     // Finally, sort by codegen unit name, so that we get deterministic results."}, {"sha": "1192b9e164a1450efb5ec71bf4bf59798f5649dd", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -111,7 +111,7 @@ pub fn spin_loop() {\n #[inline]\n #[unstable(feature = \"test\", issue = \"50297\")]\n #[allow(unreachable_code)] // this makes #[cfg] a bit easier below.\n-pub fn black_box<T>(dummy: T) -> T {\n+pub fn black_box<T>(mut dummy: T) -> T {\n     // We need to \"use\" the argument in some way LLVM can't introspect, and on\n     // targets that support it we can typically leverage inline assembly to do\n     // this. LLVM's interpretation of inline assembly is that it's, well, a black\n@@ -121,7 +121,8 @@ pub fn black_box<T>(dummy: T) -> T {\n     #[cfg(not(miri))] // This is just a hint, so it is fine to skip in Miri.\n     // SAFETY: the inline assembly is a no-op.\n     unsafe {\n-        llvm_asm!(\"\" : : \"r\"(&dummy));\n+        // FIXME: Cannot use `asm!` because it doesn't support MIPS and other architectures.\n+        llvm_asm!(\"\" : : \"r\"(&mut dummy) : \"memory\" : \"volatile\");\n     }\n \n     dummy"}, {"sha": "ddb1aaebc1f3ecd3fd1869e9360badc273fe4845", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -7,11 +7,8 @@ use super::Map;\n /// An iterator that maps each element to an iterator, and yields the elements\n /// of the produced iterators.\n ///\n-/// This `struct` is created by the [`flat_map`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`flat_map`]: trait.Iterator.html#method.flat_map\n-/// [`Iterator`]: trait.Iterator.html\n+/// This `struct` is created by [`Iterator::flat_map`]. See its documentation\n+/// for more.\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct FlatMap<I, U: IntoIterator, F> {"}, {"sha": "a5fbdc6ee2d4802528349acde70af9ff94e994f3", "filename": "library/core/src/num/dec2flt/algorithm.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -60,12 +60,19 @@ mod fpu_precision {\n     fn set_cw(cw: u16) {\n         // SAFETY: the `fldcw` instruction has been audited to be able to work correctly with\n         // any `u16`\n-        unsafe { llvm_asm!(\"fldcw $0\" :: \"m\" (cw) :: \"volatile\") }\n+        unsafe {\n+            asm!(\n+                \"fldcw ({})\",\n+                in(reg) &cw,\n+                // FIXME: We are using ATT syntax to support LLVM 8 and LLVM 9.\n+                options(att_syntax, nostack),\n+            )\n+        }\n     }\n \n     /// Sets the precision field of the FPU to `T` and returns a `FPUControlWord`.\n     pub fn set_precision<T>() -> FPUControlWord {\n-        let cw = 0u16;\n+        let mut cw = 0_u16;\n \n         // Compute the value for the Precision Control field that is appropriate for `T`.\n         let cw_precision = match size_of::<T>() {\n@@ -78,7 +85,14 @@ mod fpu_precision {\n         // `FPUControlWord` structure is dropped\n         // SAFETY: the `fnstcw` instruction has been audited to be able to work correctly with\n         // any `u16`\n-        unsafe { llvm_asm!(\"fnstcw $0\" : \"=*m\" (&cw) ::: \"volatile\") }\n+        unsafe {\n+            asm!(\n+                \"fnstcw ({})\",\n+                in(reg) &mut cw,\n+                // FIXME: We are using ATT syntax to support LLVM 8 and LLVM 9.\n+                options(att_syntax, nostack),\n+            )\n+        }\n \n         // Set the control word to the desired precision. This is achieved by masking away the old\n         // precision (bits 8 and 9, 0x300) and replacing it with the precision flag computed above."}, {"sha": "140507eab66e66bf2786d2957638111e96e3d559", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -683,15 +683,15 @@ impl<'a> Builder<'a> {\n \n     /// Adds the compiler's directory of dynamic libraries to `cmd`'s dynamic\n     /// library lookup path.\n-    pub fn add_rustc_lib_path(&self, compiler: Compiler, cmd: &mut Cargo) {\n+    pub fn add_rustc_lib_path(&self, compiler: Compiler, cmd: &mut Command) {\n         // Windows doesn't need dylib path munging because the dlls for the\n         // compiler live next to the compiler and the system will find them\n         // automatically.\n         if cfg!(windows) {\n             return;\n         }\n \n-        add_dylib_path(vec![self.rustc_libdir(compiler)], &mut cmd.command);\n+        add_dylib_path(vec![self.rustc_libdir(compiler)], cmd);\n     }\n \n     /// Gets a path to the compiler specified.\n@@ -1488,6 +1488,10 @@ impl Cargo {\n         self.command.env(key.as_ref(), value.as_ref());\n         self\n     }\n+\n+    pub fn add_rustc_lib_path(&mut self, builder: &Builder<'_>, compiler: Compiler) {\n+        builder.add_rustc_lib_path(compiler, &mut self.command);\n+    }\n }\n \n impl From<Cargo> for Command {"}, {"sha": "f90e76a4f4ea68f8a8ee331a125bc9c5c0f56f3c", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -766,6 +766,10 @@ impl Step for RustcBook {\n         if builder.config.verbose() {\n             cmd.arg(\"--verbose\");\n         }\n+        // If the lib directories are in an unusual location (changed in\n+        // config.toml), then this needs to explicitly update the dylib search\n+        // path.\n+        builder.add_rustc_lib_path(self.compiler, &mut cmd);\n         builder.run(&mut cmd);\n         // Run rustbook/mdbook to generate the HTML pages.\n         builder.ensure(RustbookSrc {"}, {"sha": "ba5f75c49ac7769e2de63b3686afc88ec98ee89e", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -270,7 +270,7 @@ impl Step for Rls {\n             &[],\n         );\n \n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n+        cargo.add_rustc_lib_path(builder, compiler);\n         cargo.arg(\"--\").args(builder.config.cmd.test_args());\n \n         if try_run(builder, &mut cargo.into()) {\n@@ -328,7 +328,7 @@ impl Step for Rustfmt {\n         t!(fs::create_dir_all(&dir));\n         cargo.env(\"RUSTFMT_TEST_DIR\", dir);\n \n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n+        cargo.add_rustc_lib_path(builder, compiler);\n \n         if try_run(builder, &mut cargo.into()) {\n             builder.save_toolstate(\"rustfmt\", ToolState::TestPass);\n@@ -449,7 +449,7 @@ impl Step for Miri {\n \n             cargo.arg(\"--\").args(builder.config.cmd.test_args());\n \n-            builder.add_rustc_lib_path(compiler, &mut cargo);\n+            cargo.add_rustc_lib_path(builder, compiler);\n \n             if !try_run(builder, &mut cargo.into()) {\n                 return;\n@@ -554,7 +554,7 @@ impl Step for Clippy {\n \n         cargo.arg(\"--\").args(builder.config.cmd.test_args());\n \n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n+        cargo.add_rustc_lib_path(builder, compiler);\n \n         builder.run(&mut cargo.into());\n     }"}, {"sha": "38fea2a8094b981317fbb565092439bd6ae8d9d4", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-git.sh", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-git.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-git.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-git.sh?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -1,15 +0,0 @@\n-#!/usr/bin/env bash\n-\n-set -ex\n-source shared.sh\n-\n-curl -L https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz | tar xzf -\n-\n-cd git-2.10.0\n-make configure\n-hide_output ./configure --prefix=/rustroot\n-hide_output make -j10\n-hide_output make install\n-\n-cd ..\n-rm -rf git-2.10.0"}, {"sha": "b623e53583b5e6c92fcfb92a751864781c286710", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-headers.sh", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-headers.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-headers.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-headers.sh?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -1,16 +0,0 @@\n-#!/usr/bin/env bash\n-\n-set -ex\n-source shared.sh\n-\n-curl https://cdn.kernel.org/pub/linux/kernel/v3.x/linux-3.2.84.tar.xz | unxz | tar x\n-\n-cd linux-3.2.84\n-hide_output make mrproper\n-hide_output make INSTALL_HDR_PATH=dest headers_install\n-\n-find dest/include \\( -name .install -o -name ..install.cmd \\) -delete\n-yes | cp -fr dest/include/* /usr/include\n-\n-cd ..\n-rm -rf linux-3.2.84"}, {"sha": "a678d353d52f5881f69ffde98d10dfac6ceeb465", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-perl.sh", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-perl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5fae56971d8487088c0099c82c0a5ce1638b5f62/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-perl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-perl.sh?ref=5fae56971d8487088c0099c82c0a5ce1638b5f62", "patch": "@@ -1,21 +0,0 @@\n-#!/usr/bin/env bash\n-\n-set -ex\n-source shared.sh\n-\n-curl https://www.cpan.org/src/5.0/perl-5.28.0.tar.gz | \\\n-  tar xzf -\n-\n-cd perl-5.28.0\n-\n-# Gotta do some hackery to tell python about our custom OpenSSL build, but other\n-# than that fairly normal.\n-CC=gcc \\\n-CFLAGS='-I /rustroot/include -fgnu89-inline' \\\n-LDFLAGS='-L /rustroot/lib -L /rustroot/lib64' \\\n-    hide_output ./configure.gnu\n-hide_output make -j10\n-hide_output make install\n-\n-cd ..\n-rm -rf perl-5.28.0"}, {"sha": "df113f0f1613c3fd33d37a13ae1fa9fb992350b7", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -345,6 +345,25 @@ The `h` modifier will emit the register name for the high byte of that register\n \n If you use a smaller data type (e.g. `u16`) with an operand and forget the use template modifiers, the compiler will emit a warning and suggest the correct modifier to use.\n \n+## Memory address operands\n+\n+Sometimes assembly instructions require operands passed via memory addresses/memory locations.\n+You have to manually use the memory address syntax specified by the respectively architectures.\n+For example, in x86/x86_64 and intel assembly syntax, you should wrap inputs/outputs in `[]`\n+to indicate they are memory operands:\n+\n+```rust,allow_fail\n+# #![feature(asm, llvm_asm)]\n+# fn load_fpu_control_word(control: u16) {\n+unsafe {\n+    asm!(\"fldcw [{}]\", in(reg) &control, options(nostack));\n+\n+    // Previously this would have been written with the deprecated `llvm_asm!` like this\n+    llvm_asm!(\"fldcw $0\" :: \"m\" (control) :: \"volatile\");\n+}\n+# }\n+```\n+\n ## Options\n \n By default, an inline assembly block is treated the same way as an external FFI function call with a custom calling convention: it may read/write memory, have observable side effects, etc. However in many cases, it is desirable to give the compiler more information about what the assembly code is actually doing so that it can optimize better."}, {"sha": "a2f029db2916551e68afe12b388612747ce573b0", "filename": "src/doc/unstable-book/src/library-features/llvm-asm.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fllvm-asm.md", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fllvm-asm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fllvm-asm.md?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -159,12 +159,12 @@ specify some extra info about the inline assembly:\n \n Current valid options are:\n \n-1. *volatile* - specifying this is analogous to\n+1. `volatile` - specifying this is analogous to\n    `__asm__ __volatile__ (...)` in gcc/clang.\n-2. *alignstack* - certain instructions expect the stack to be\n+2. `alignstack` - certain instructions expect the stack to be\n    aligned a certain way (i.e. SSE) and specifying this indicates to\n    the compiler to insert its usual stack alignment code\n-3. *intel* - use intel syntax instead of the default AT&T.\n+3. `intel` - use intel syntax instead of the default AT&T.\n \n ```rust\n # #![feature(llvm_asm)]"}, {"sha": "84e75cc3764167ca8b3975039a06967e72beb156", "filename": "src/test/ui/const-generics/infer/cannot-infer-const-args.full.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.full.stderr?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -4,7 +4,7 @@ error[E0282]: type annotations needed\n LL |     foo();\n    |     ^^^\n    |\n-   = note: unable to infer the value of a const parameter\n+   = note: cannot infer the value of the const parameter `X`\n \n error: aborting due to previous error\n ", "previous_filename": "src/test/ui/const-generics/cannot-infer-const-args.full.stderr"}, {"sha": "84e75cc3764167ca8b3975039a06967e72beb156", "filename": "src/test/ui/const-generics/infer/cannot-infer-const-args.min.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.min.stderr?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -4,7 +4,7 @@ error[E0282]: type annotations needed\n LL |     foo();\n    |     ^^^\n    |\n-   = note: unable to infer the value of a const parameter\n+   = note: cannot infer the value of the const parameter `X`\n \n error: aborting due to previous error\n ", "previous_filename": "src/test/ui/const-generics/cannot-infer-const-args.min.stderr"}, {"sha": "2d74b4788bf4b61c4eab058198a1f4930bfcc891", "filename": "src/test/ui/const-generics/infer/cannot-infer-const-args.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fcannot-infer-const-args.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "previous_filename": "src/test/ui/const-generics/cannot-infer-const-args.rs"}, {"sha": "e65bc3f109681227c401e5010a61956cfcfbb29f", "filename": "src/test/ui/const-generics/infer/method-chain.full.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.full.stderr?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -0,0 +1,11 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/method-chain.rs:21:33\n+   |\n+LL |     Foo.bar().bar().bar().bar().baz();\n+   |                                 ^^^\n+   |\n+   = note: cannot infer the value of the const parameter `N`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "e65bc3f109681227c401e5010a61956cfcfbb29f", "filename": "src/test/ui/const-generics/infer/method-chain.min.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.min.stderr?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -0,0 +1,11 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/method-chain.rs:21:33\n+   |\n+LL |     Foo.bar().bar().bar().bar().baz();\n+   |                                 ^^^\n+   |\n+   = note: cannot infer the value of the const parameter `N`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "9389ca20d106fd7d54e3c7dc1dc2cfb6bf3bad9b", "filename": "src/test/ui/const-generics/infer/method-chain.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fmethod-chain.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -0,0 +1,22 @@\n+// revisions: full min\n+\n+#![cfg_attr(full, feature(const_generics))]\n+#![cfg_attr(full, allow(incomplete_features))]\n+#![cfg_attr(min, feature(min_const_generics))]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn bar(self) -> Foo {\n+        Foo\n+    }\n+\n+    fn baz<const N: usize>(self) -> Foo {\n+        println!(\"baz: {}\", N);\n+        Foo\n+    }\n+}\n+\n+fn main() {\n+    Foo.bar().bar().bar().bar().baz(); //~ ERROR type annotations needed\n+}"}, {"sha": "e47b6bd5dc691f49dc65c0a5cdd6db608ed97f35", "filename": "src/test/ui/const-generics/infer/uninferred-consts.full.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.full.stderr?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -1,10 +1,10 @@\n error[E0282]: type annotations needed\n-  --> $DIR/uninferred-consts.rs:14:5\n+  --> $DIR/uninferred-consts.rs:14:9\n    |\n LL |     Foo.foo();\n-   |     ^^^^^^^^^\n+   |         ^^^\n    |\n-   = note: unable to infer the value of a const parameter\n+   = note: cannot infer the value of the const parameter `N`\n \n error: aborting due to previous error\n ", "previous_filename": "src/test/ui/const-generics/uninferred-consts.full.stderr"}, {"sha": "e47b6bd5dc691f49dc65c0a5cdd6db608ed97f35", "filename": "src/test/ui/const-generics/infer/uninferred-consts.min.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.min.stderr?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -1,10 +1,10 @@\n error[E0282]: type annotations needed\n-  --> $DIR/uninferred-consts.rs:14:5\n+  --> $DIR/uninferred-consts.rs:14:9\n    |\n LL |     Foo.foo();\n-   |     ^^^^^^^^^\n+   |         ^^^\n    |\n-   = note: unable to infer the value of a const parameter\n+   = note: cannot infer the value of the const parameter `N`\n \n error: aborting due to previous error\n ", "previous_filename": "src/test/ui/const-generics/uninferred-consts.min.stderr"}, {"sha": "ec5b3ffe5440bca973d7657e38d86ceed9562c71", "filename": "src/test/ui/const-generics/infer/uninferred-consts.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Funinferred-consts.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "previous_filename": "src/test/ui/const-generics/uninferred-consts.rs"}, {"sha": "db3a95f5c4f611bb14a3ce4b869c7e6973c9db73", "filename": "src/test/ui/trait-impl-bound-suggestions.fixed", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Ftrait-impl-bound-suggestions.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Ftrait-impl-bound-suggestions.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-impl-bound-suggestions.fixed?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -0,0 +1,20 @@\n+// run-rustfix\n+\n+#[allow(unused)]\n+use std::fmt::Debug;\n+// Rustfix should add this, or use `std::fmt::Debug` instead.\n+\n+#[allow(dead_code)]\n+struct ConstrainedStruct<X: Copy> {\n+    x: X\n+}\n+\n+#[allow(dead_code)]\n+trait InsufficientlyConstrainedGeneric<X=()> where X: Copy {\n+    fn return_the_constrained_type(&self, x: X) -> ConstrainedStruct<X> {\n+        //~^ ERROR the trait bound `X: Copy` is not satisfied\n+        ConstrainedStruct { x }\n+    }\n+}\n+\n+pub fn main() { }"}, {"sha": "bf75175179efdc733cc012394b484d46fc9f4651", "filename": "src/test/ui/trait-impl-bound-suggestions.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Ftrait-impl-bound-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Ftrait-impl-bound-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-impl-bound-suggestions.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -0,0 +1,20 @@\n+// run-rustfix\n+\n+#[allow(unused)]\n+use std::fmt::Debug;\n+// Rustfix should add this, or use `std::fmt::Debug` instead.\n+\n+#[allow(dead_code)]\n+struct ConstrainedStruct<X: Copy> {\n+    x: X\n+}\n+\n+#[allow(dead_code)]\n+trait InsufficientlyConstrainedGeneric<X=()> {\n+    fn return_the_constrained_type(&self, x: X) -> ConstrainedStruct<X> {\n+        //~^ ERROR the trait bound `X: Copy` is not satisfied\n+        ConstrainedStruct { x }\n+    }\n+}\n+\n+pub fn main() { }"}, {"sha": "3a21e9c6b2ad4fb65caad675ef22ed0c398e6215", "filename": "src/test/ui/trait-impl-bound-suggestions.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Ftrait-impl-bound-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Ftrait-impl-bound-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-impl-bound-suggestions.stderr?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -0,0 +1,17 @@\n+error[E0277]: the trait bound `X: Copy` is not satisfied\n+  --> $DIR/trait-impl-bound-suggestions.rs:14:52\n+   |\n+LL | struct ConstrainedStruct<X: Copy> {\n+   |                             ---- required by this bound in `ConstrainedStruct`\n+...\n+LL |     fn return_the_constrained_type(&self, x: X) -> ConstrainedStruct<X> {\n+   |                                                    ^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `X`\n+   |\n+help: consider further restricting type parameter `X`\n+   |\n+LL | trait InsufficientlyConstrainedGeneric<X=()> where X: Copy {\n+   |                                              ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "d8c7f595e62efcdf03555cd975d71761e7a7e586", "filename": "src/test/ui/type/type-check-defaults.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Ftype%2Ftype-check-defaults.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Ftest%2Fui%2Ftype%2Ftype-check-defaults.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check-defaults.stderr?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -56,8 +56,8 @@ LL | trait Base<T = String>: Super<T> { }\n    |\n help: consider further restricting type parameter `T`\n    |\n-LL | trait Base<T = String>: Super<T>, T: Copy { }\n-   |                                 ^^^^^^^^^\n+LL | trait Base<T = String>: Super<T> where T: Copy { }\n+   |                                  ^^^^^^^^^^^^^\n \n error[E0277]: cannot add `u8` to `i32`\n   --> $DIR/type-check-defaults.rs:24:66"}, {"sha": "92b3d186fa141a6294cf22f70a5a5649af9417ec", "filename": "src/tools/lint-docs/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bb106fe633872de703af46381843057f8cd384f/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bb106fe633872de703af46381843057f8cd384f/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -402,9 +402,12 @@ fn generate_lint_output(\n                 None => {\n                     let rendered: Vec<&str> =\n                         msgs.iter().filter_map(|msg| msg[\"rendered\"].as_str()).collect();\n+                    let non_json: Vec<&str> =\n+                        stderr.lines().filter(|line| !line.starts_with('{')).collect();\n                     Err(format!(\n-                        \"did not find lint `{}` in output of example, got:\\n{}\",\n+                        \"did not find lint `{}` in output of example, got:\\n{}\\n{}\",\n                         name,\n+                        non_json.join(\"\\n\"),\n                         rendered.join(\"\\n\")\n                     )\n                     .into())"}, {"sha": "0d03fe6ef57d3956e92382e0e1f1a916015191cb", "filename": "src/tools/rust-analyzer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer?ref=7bb106fe633872de703af46381843057f8cd384f", "patch": "@@ -1 +1 @@\n-Subproject commit 0275b08d1521606fa733f76fe5d5707717456fb4\n+Subproject commit 0d03fe6ef57d3956e92382e0e1f1a916015191cb"}]}