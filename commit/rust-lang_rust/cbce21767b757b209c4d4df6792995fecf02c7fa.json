{"sha": "cbce21767b757b209c4d4df6792995fecf02c7fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiY2UyMTc2N2I3NTdiMjA5YzRkNGRmNjc5Mjk5NWZlY2YwMmM3ZmE=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-02-26T01:20:33Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-03-09T13:50:40Z"}, "message": "Remove the need for `no_force`", "tree": {"sha": "9bc05490c45c20b7fd9f5ccfb45294fca070f641", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bc05490c45c20b7fd9f5ccfb45294fca070f641"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbce21767b757b209c4d4df6792995fecf02c7fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbce21767b757b209c4d4df6792995fecf02c7fa", "html_url": "https://github.com/rust-lang/rust/commit/cbce21767b757b209c4d4df6792995fecf02c7fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbce21767b757b209c4d4df6792995fecf02c7fa/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67012158a379dbf58318346e87a631e7eb310bd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/67012158a379dbf58318346e87a631e7eb310bd5", "html_url": "https://github.com/rust-lang/rust/commit/67012158a379dbf58318346e87a631e7eb310bd5"}], "stats": {"total": 301, "additions": 148, "deletions": 153}, "files": [{"sha": "bcb270ff0a64e7a3d72cb08de27b80228eae7e97", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cbce21767b757b209c4d4df6792995fecf02c7fa/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbce21767b757b209c4d4df6792995fecf02c7fa/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=cbce21767b757b209c4d4df6792995fecf02c7fa", "patch": "@@ -362,29 +362,7 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     [] CompileCodegenUnit(Symbol),\n ]);\n \n-pub trait RecoverKey<'tcx>: Sized {\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self>;\n-}\n-\n-impl RecoverKey<'tcx> for CrateNum {\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        dep_node.extract_def_id(tcx).map(|id| id.krate)\n-    }\n-}\n-\n-impl RecoverKey<'tcx> for DefId {\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        dep_node.extract_def_id(tcx)\n-    }\n-}\n-\n-impl RecoverKey<'tcx> for DefIndex {\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        dep_node.extract_def_id(tcx).map(|id| id.index)\n-    }\n-}\n-\n-trait DepNodeParams<'tcx>: fmt::Debug {\n+pub(crate) trait DepNodeParams<'tcx>: fmt::Debug + Sized {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool;\n \n     /// This method turns the parameters of a DepNodeConstructor into an opaque\n@@ -398,6 +376,8 @@ trait DepNodeParams<'tcx>: fmt::Debug {\n     fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n         format!(\"{:?}\", self)\n     }\n+\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self>;\n }\n \n impl<'tcx, T> DepNodeParams<'tcx> for T\n@@ -418,6 +398,10 @@ where\n     default fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n         format!(\"{:?}\", *self)\n     }\n+\n+    default fn recover(_: TyCtxt<'tcx>, _: &DepNode) -> Option<Self> {\n+        None\n+    }\n }\n \n impl<'tcx> DepNodeParams<'tcx> for DefId {\n@@ -430,6 +414,10 @@ impl<'tcx> DepNodeParams<'tcx> for DefId {\n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         tcx.def_path_str(*self)\n     }\n+\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n+        dep_node.extract_def_id(tcx)\n+    }\n }\n \n impl<'tcx> DepNodeParams<'tcx> for DefIndex {\n@@ -442,6 +430,10 @@ impl<'tcx> DepNodeParams<'tcx> for DefIndex {\n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         tcx.def_path_str(DefId::local(*self))\n     }\n+\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n+        dep_node.extract_def_id(tcx).map(|id| id.index)\n+    }\n }\n \n impl<'tcx> DepNodeParams<'tcx> for CrateNum {\n@@ -455,6 +447,10 @@ impl<'tcx> DepNodeParams<'tcx> for CrateNum {\n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         tcx.crate_name(*self).to_string()\n     }\n+\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n+        dep_node.extract_def_id(tcx).map(|id| id.krate)\n+    }\n }\n \n impl<'tcx> DepNodeParams<'tcx> for (DefId, DefId) {"}, {"sha": "1fbd90743f402e764212ab57b8cfdca142f4f36b", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbce21767b757b209c4d4df6792995fecf02c7fa/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbce21767b757b209c4d4df6792995fecf02c7fa/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=cbce21767b757b209c4d4df6792995fecf02c7fa", "patch": "@@ -6,7 +6,8 @@ mod query;\n mod safe;\n mod serialized;\n \n-pub use self::dep_node::{label_strs, DepConstructor, DepKind, DepNode, RecoverKey, WorkProductId};\n+pub(crate) use self::dep_node::DepNodeParams;\n+pub use self::dep_node::{label_strs, DepConstructor, DepKind, DepNode, WorkProductId};\n pub use self::graph::WorkProductFileKind;\n pub use self::graph::{hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, WorkProduct};\n pub use self::prev::PreviousDepGraph;"}, {"sha": "c8155005480ffd0e244276fcd5041ceaa1c05a2a", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbce21767b757b209c4d4df6792995fecf02c7fa/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbce21767b757b209c4d4df6792995fecf02c7fa/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=cbce21767b757b209c4d4df6792995fecf02c7fa", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{DepKind, DepNode, RecoverKey, SerializedDepNodeIndex};\n+use crate::dep_graph::SerializedDepNodeIndex;\n use crate::mir;\n use crate::mir::interpret::{GlobalId, LitToConstInput};\n use crate::traits;"}, {"sha": "8adb828fbebc4467876a0f7de758bea32ad4ebb0", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 103, "deletions": 2, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/cbce21767b757b209c4d4df6792995fecf02c7fa/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbce21767b757b209c4d4df6792995fecf02c7fa/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=cbce21767b757b209c4d4df6792995fecf02c7fa", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{self, DepConstructor, DepNode};\n+use crate::dep_graph::{self, DepConstructor, DepNode, DepNodeParams};\n use crate::hir::exports::Export;\n use crate::infer::canonical::{self, Canonical};\n use crate::lint::LintLevelMap;\n@@ -60,8 +60,8 @@ use std::sync::Arc;\n \n #[macro_use]\n mod plumbing;\n+pub use self::plumbing::CycleError;\n use self::plumbing::*;\n-pub use self::plumbing::{force_from_dep_node, CycleError};\n \n mod stats;\n pub use self::stats::print_stats;\n@@ -105,3 +105,104 @@ pub use self::profiling_support::{IntoSelfProfilingString, QueryKeyStringBuilder\n // as they will raise an fatal error on query cycles instead.\n \n rustc_query_append! { [define_queries!][<'tcx>] }\n+\n+/// The red/green evaluation system will try to mark a specific DepNode in the\n+/// dependency graph as green by recursively trying to mark the dependencies of\n+/// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n+/// where we don't know if it is red or green and we therefore actually have\n+/// to recompute its value in order to find out. Since the only piece of\n+/// information that we have at that point is the `DepNode` we are trying to\n+/// re-evaluate, we need some way to re-run a query from just that. This is what\n+/// `force_from_dep_node()` implements.\n+///\n+/// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n+/// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n+/// is usually constructed by computing a stable hash of the query-key that the\n+/// `DepNode` corresponds to. Consequently, it is not in general possible to go\n+/// back from hash to query-key (since hash functions are not reversible). For\n+/// this reason `force_from_dep_node()` is expected to fail from time to time\n+/// because we just cannot find out, from the `DepNode` alone, what the\n+/// corresponding query-key is and therefore cannot re-run the query.\n+///\n+/// The system deals with this case letting `try_mark_green` fail which forces\n+/// the root query to be re-evaluated.\n+///\n+/// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n+/// Fortunately, we can use some contextual information that will allow us to\n+/// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n+/// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n+/// valid `DefPathHash`. Since we also always build a huge table that maps every\n+/// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n+/// everything we need to re-run the query.\n+///\n+/// Take the `mir_validated` query as an example. Like many other queries, it\n+/// just has a single parameter: the `DefId` of the item it will compute the\n+/// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n+/// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n+/// is actually a `DefPathHash`, and can therefore just look up the corresponding\n+/// `DefId` in `tcx.def_path_hash_to_def_id`.\n+///\n+/// When you implement a new query, it will likely have a corresponding new\n+/// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n+/// a rule of thumb, if your query takes a `DefId` or `DefIndex` as sole parameter,\n+/// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n+/// add it to the \"We don't have enough information to reconstruct...\" group in\n+/// the match below.\n+pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool {\n+    use crate::dep_graph::DepKind;\n+\n+    // We must avoid ever having to call `force_from_dep_node()` for a\n+    // `DepNode::codegen_unit`:\n+    // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n+    // would always end up having to evaluate the first caller of the\n+    // `codegen_unit` query that *is* reconstructible. This might very well be\n+    // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n+    // to re-trigger calling the `codegen_unit` query with the right key. At\n+    // that point we would already have re-done all the work we are trying to\n+    // avoid doing in the first place.\n+    // The solution is simple: Just explicitly call the `codegen_unit` query for\n+    // each CGU, right after partitioning. This way `try_mark_green` will always\n+    // hit the cache instead of having to go through `force_from_dep_node`.\n+    // This assertion makes sure, we actually keep applying the solution above.\n+    debug_assert!(\n+        dep_node.kind != DepKind::codegen_unit,\n+        \"calling force_from_dep_node() on DepKind::codegen_unit\"\n+    );\n+\n+    if !dep_node.kind.can_reconstruct_query_key() {\n+        return false;\n+    }\n+\n+    rustc_dep_node_force!([dep_node, tcx]\n+        // These are inputs that are expected to be pre-allocated and that\n+        // should therefore always be red or green already.\n+        DepKind::AllLocalTraitImpls |\n+        DepKind::CrateMetadata |\n+        DepKind::HirBody |\n+        DepKind::Hir |\n+\n+        // These are anonymous nodes.\n+        DepKind::TraitSelect |\n+\n+        // We don't have enough information to reconstruct the query key of\n+        // these.\n+        DepKind::CompileCodegenUnit => {\n+            bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n+        }\n+    );\n+\n+    false\n+}\n+\n+impl DepNode {\n+    /// Check whether the query invocation corresponding to the given\n+    /// DepNode is eligible for on-disk-caching. If so, this is method\n+    /// will execute the query corresponding to the given DepNode.\n+    /// Also, as a sanity check, it expects that the corresponding query\n+    /// invocation has been marked as green already.\n+    pub fn try_load_from_on_disk_cache<'tcx>(&self, tcx: TyCtxt<'tcx>) {\n+        use crate::dep_graph::DepKind;\n+\n+        rustc_dep_node_try_load_from_on_disk_cache!(self, tcx)\n+    }\n+}"}, {"sha": "acf67f52dceaa94ebe9bb50ebd6a4979e78cf73c", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 90, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/cbce21767b757b209c4d4df6792995fecf02c7fa/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbce21767b757b209c4d4df6792995fecf02c7fa/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=cbce21767b757b209c4d4df6792995fecf02c7fa", "patch": "@@ -2,7 +2,7 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepKind, DepNode, DepNodeIndex, SerializedDepNodeIndex};\n+use crate::dep_graph::{DepNode, DepNodeIndex, SerializedDepNodeIndex};\n use crate::ty::query::caches::QueryCache;\n use crate::ty::query::config::{QueryAccessors, QueryDescription};\n use crate::ty::query::job::{QueryInfo, QueryJob, QueryJobId, QueryShardJobId};\n@@ -720,7 +720,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[allow(dead_code)]\n-    fn force_query<Q: QueryDescription<'tcx> + 'tcx>(\n+    pub(super) fn force_query<Q: QueryDescription<'tcx> + 'tcx>(\n         self,\n         key: Q::Key,\n         span: Span,\n@@ -1162,91 +1162,3 @@ macro_rules! define_provider_struct {\n         }\n     };\n }\n-\n-/// The red/green evaluation system will try to mark a specific DepNode in the\n-/// dependency graph as green by recursively trying to mark the dependencies of\n-/// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n-/// where we don't know if it is red or green and we therefore actually have\n-/// to recompute its value in order to find out. Since the only piece of\n-/// information that we have at that point is the `DepNode` we are trying to\n-/// re-evaluate, we need some way to re-run a query from just that. This is what\n-/// `force_from_dep_node()` implements.\n-///\n-/// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n-/// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n-/// is usually constructed by computing a stable hash of the query-key that the\n-/// `DepNode` corresponds to. Consequently, it is not in general possible to go\n-/// back from hash to query-key (since hash functions are not reversible). For\n-/// this reason `force_from_dep_node()` is expected to fail from time to time\n-/// because we just cannot find out, from the `DepNode` alone, what the\n-/// corresponding query-key is and therefore cannot re-run the query.\n-///\n-/// The system deals with this case letting `try_mark_green` fail which forces\n-/// the root query to be re-evaluated.\n-///\n-/// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n-/// Fortunately, we can use some contextual information that will allow us to\n-/// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n-/// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n-/// valid `DefPathHash`. Since we also always build a huge table that maps every\n-/// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n-/// everything we need to re-run the query.\n-///\n-/// Take the `mir_validated` query as an example. Like many other queries, it\n-/// just has a single parameter: the `DefId` of the item it will compute the\n-/// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n-/// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n-/// is actually a `DefPathHash`, and can therefore just look up the corresponding\n-/// `DefId` in `tcx.def_path_hash_to_def_id`.\n-///\n-/// When you implement a new query, it will likely have a corresponding new\n-/// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n-/// a rule of thumb, if your query takes a `DefId` or `DefIndex` as sole parameter,\n-/// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n-/// add it to the \"We don't have enough information to reconstruct...\" group in\n-/// the match below.\n-pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n-    use crate::dep_graph::RecoverKey;\n-\n-    // We must avoid ever having to call `force_from_dep_node()` for a\n-    // `DepNode::codegen_unit`:\n-    // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n-    // would always end up having to evaluate the first caller of the\n-    // `codegen_unit` query that *is* reconstructible. This might very well be\n-    // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n-    // to re-trigger calling the `codegen_unit` query with the right key. At\n-    // that point we would already have re-done all the work we are trying to\n-    // avoid doing in the first place.\n-    // The solution is simple: Just explicitly call the `codegen_unit` query for\n-    // each CGU, right after partitioning. This way `try_mark_green` will always\n-    // hit the cache instead of having to go through `force_from_dep_node`.\n-    // This assertion makes sure, we actually keep applying the solution above.\n-    debug_assert!(\n-        dep_node.kind != DepKind::codegen_unit,\n-        \"calling force_from_dep_node() on DepKind::codegen_unit\"\n-    );\n-\n-    if !dep_node.kind.can_reconstruct_query_key() {\n-        return false;\n-    }\n-\n-    rustc_dep_node_force!([dep_node, tcx]\n-        // These are inputs that are expected to be pre-allocated and that\n-        // should therefore always be red or green already.\n-        DepKind::AllLocalTraitImpls |\n-        DepKind::CrateMetadata |\n-        DepKind::HirBody |\n-        DepKind::Hir |\n-\n-        // These are anonymous nodes.\n-        DepKind::TraitSelect |\n-\n-        // We don't have enough information to reconstruct the query key of\n-        // these.\n-        DepKind::CompileCodegenUnit => {\n-            bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n-        }\n-    );\n-\n-    true\n-}"}, {"sha": "c23095968fb3e9563df1241c3ecf0c48862e8ded", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 21, "deletions": 36, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cbce21767b757b209c4d4df6792995fecf02c7fa/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbce21767b757b209c4d4df6792995fecf02c7fa/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=cbce21767b757b209c4d4df6792995fecf02c7fa", "patch": "@@ -425,7 +425,6 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     let mut dep_node_def_stream = quote! {};\n     let mut dep_node_force_stream = quote! {};\n     let mut try_load_from_on_disk_cache_stream = quote! {};\n-    let mut no_force_queries = Vec::new();\n     let mut cached_queries = quote! {};\n \n     for group in groups.0 {\n@@ -444,19 +443,19 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 cached_queries.extend(quote! {\n                     #name,\n                 });\n-            }\n \n-            if modifiers.cache.is_some() && !modifiers.no_force {\n                 try_load_from_on_disk_cache_stream.extend(quote! {\n                     DepKind::#name => {\n-                        debug_assert!(tcx.dep_graph\n-                                         .node_color(self)\n-                                         .map(|c| c.is_green())\n-                                         .unwrap_or(false));\n-\n-                        let key = RecoverKey::recover(tcx, self).unwrap();\n-                        if queries::#name::cache_on_disk(tcx, key, None) {\n-                            let _ = tcx.#name(key);\n+                        if <#arg as DepNodeParams>::CAN_RECONSTRUCT_QUERY_KEY {\n+                            debug_assert!($tcx.dep_graph\n+                                            .node_color($dep_node)\n+                                            .map(|c| c.is_green())\n+                                            .unwrap_or(false));\n+\n+                            let key = <#arg as DepNodeParams>::recover($tcx, $dep_node).unwrap();\n+                            if queries::#name::cache_on_disk($tcx, key, None) {\n+                                let _ = $tcx.#name(key);\n+                            }\n                         }\n                     }\n                 });\n@@ -501,24 +500,21 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 [#attribute_stream] #name(#arg),\n             });\n \n-            if modifiers.no_force {\n-                no_force_queries.push(name.clone());\n-            } else {\n-                // Add a match arm to force the query given the dep node\n-                dep_node_force_stream.extend(quote! {\n-                    DepKind::#name => {\n-                        if let Some(key) = RecoverKey::recover($tcx, $dep_node) {\n+            // Add a match arm to force the query given the dep node\n+            dep_node_force_stream.extend(quote! {\n+                DepKind::#name => {\n+                    if <#arg as DepNodeParams>::CAN_RECONSTRUCT_QUERY_KEY {\n+                        if let Some(key) = <#arg as DepNodeParams>::recover($tcx, $dep_node) {\n                             $tcx.force_query::<crate::ty::query::queries::#name<'_>>(\n                                 key,\n                                 DUMMY_SP,\n                                 *$dep_node\n                             );\n-                        } else {\n-                            return false;\n+                            return true;\n                         }\n                     }\n-                });\n-            }\n+                }\n+            });\n \n             add_query_description_impl(&query, modifiers, &mut query_description_stream);\n         }\n@@ -528,12 +524,6 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n         });\n     }\n \n-    // Add an arm for the no force queries to panic when trying to force them\n-    for query in no_force_queries {\n-        dep_node_force_stream.extend(quote! {\n-            DepKind::#query |\n-        });\n-    }\n     dep_node_force_stream.extend(quote! {\n         DepKind::Null => {\n             bug!(\"Cannot force dep node: {:?}\", $dep_node)\n@@ -577,14 +567,9 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n \n         #query_description_stream\n \n-        impl DepNode {\n-            /// Check whether the query invocation corresponding to the given\n-            /// DepNode is eligible for on-disk-caching. If so, this is method\n-            /// will execute the query corresponding to the given DepNode.\n-            /// Also, as a sanity check, it expects that the corresponding query\n-            /// invocation has been marked as green already.\n-            pub fn try_load_from_on_disk_cache(&self, tcx: TyCtxt<'_>) {\n-                match self.kind {\n+        macro_rules! rustc_dep_node_try_load_from_on_disk_cache {\n+            ($dep_node:expr, $tcx:expr) => {\n+                match $dep_node.kind {\n                     #try_load_from_on_disk_cache_stream\n                     _ => (),\n                 }"}]}