{"sha": "ccc91d7b4873a50678b3f65c895290915c54f6f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjYzkxZDdiNDg3M2E1MDY3OGIzZjY1Yzg5NTI5MDkxNWM1NGY2ZjU=", "commit": {"author": {"name": "Diggory Blake", "email": "diggsey@googlemail.com", "date": "2017-12-17T15:21:47Z"}, "committer": {"name": "Diggory Blake", "email": "diggsey@googlemail.com", "date": "2017-12-24T14:24:31Z"}, "message": "Capture environment at spawn", "tree": {"sha": "5884d3c794a88178b6853df2dde3bcb3ee67de1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5884d3c794a88178b6853df2dde3bcb3ee67de1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccc91d7b4873a50678b3f65c895290915c54f6f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccc91d7b4873a50678b3f65c895290915c54f6f5", "html_url": "https://github.com/rust-lang/rust/commit/ccc91d7b4873a50678b3f65c895290915c54f6f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccc91d7b4873a50678b3f65c895290915c54f6f5/comments", "author": {"login": "Diggsey", "id": 451321, "node_id": "MDQ6VXNlcjQ1MTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/451321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Diggsey", "html_url": "https://github.com/Diggsey", "followers_url": "https://api.github.com/users/Diggsey/followers", "following_url": "https://api.github.com/users/Diggsey/following{/other_user}", "gists_url": "https://api.github.com/users/Diggsey/gists{/gist_id}", "starred_url": "https://api.github.com/users/Diggsey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Diggsey/subscriptions", "organizations_url": "https://api.github.com/users/Diggsey/orgs", "repos_url": "https://api.github.com/users/Diggsey/repos", "events_url": "https://api.github.com/users/Diggsey/events{/privacy}", "received_events_url": "https://api.github.com/users/Diggsey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Diggsey", "id": 451321, "node_id": "MDQ6VXNlcjQ1MTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/451321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Diggsey", "html_url": "https://github.com/Diggsey", "followers_url": "https://api.github.com/users/Diggsey/followers", "following_url": "https://api.github.com/users/Diggsey/following{/other_user}", "gists_url": "https://api.github.com/users/Diggsey/gists{/gist_id}", "starred_url": "https://api.github.com/users/Diggsey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Diggsey/subscriptions", "organizations_url": "https://api.github.com/users/Diggsey/orgs", "repos_url": "https://api.github.com/users/Diggsey/repos", "events_url": "https://api.github.com/users/Diggsey/events{/privacy}", "received_events_url": "https://api.github.com/users/Diggsey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b058dc0107b734b0a1a664ca0209366bb59eb3e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b058dc0107b734b0a1a664ca0209366bb59eb3e9", "html_url": "https://github.com/rust-lang/rust/commit/b058dc0107b734b0a1a664ca0209366bb59eb3e9"}], "stats": {"total": 488, "additions": 321, "deletions": 167}, "files": [{"sha": "1f6ddde00272c95f898b282bed1ba90f22872503", "filename": "src/libstd/process.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=ccc91d7b4873a50678b3f65c895290915c54f6f5", "patch": "@@ -513,7 +513,7 @@ impl Command {\n     pub fn env<K, V>(&mut self, key: K, val: V) -> &mut Command\n         where K: AsRef<OsStr>, V: AsRef<OsStr>\n     {\n-        self.inner.env(key.as_ref(), val.as_ref());\n+        self.inner.env_mut().set(key.as_ref(), val.as_ref());\n         self\n     }\n \n@@ -546,7 +546,7 @@ impl Command {\n         where I: IntoIterator<Item=(K, V)>, K: AsRef<OsStr>, V: AsRef<OsStr>\n     {\n         for (ref key, ref val) in vars {\n-            self.inner.env(key.as_ref(), val.as_ref());\n+            self.inner.env_mut().set(key.as_ref(), val.as_ref());\n         }\n         self\n     }\n@@ -567,7 +567,7 @@ impl Command {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn env_remove<K: AsRef<OsStr>>(&mut self, key: K) -> &mut Command {\n-        self.inner.env_remove(key.as_ref());\n+        self.inner.env_mut().remove(key.as_ref());\n         self\n     }\n \n@@ -587,7 +587,7 @@ impl Command {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn env_clear(&mut self) -> &mut Command {\n-        self.inner.env_clear();\n+        self.inner.env_mut().clear();\n         self\n     }\n \n@@ -1715,6 +1715,27 @@ mod tests {\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n     }\n \n+    #[test]\n+    fn test_capture_env_at_spawn() {\n+        use env;\n+\n+        let mut cmd = env_cmd();\n+        cmd.env(\"RUN_TEST_NEW_ENV1\", \"123\");\n+\n+        // This variable will not be present if the environment has already\n+        // been captured above.\n+        env::set_var(\"RUN_TEST_NEW_ENV2\", \"456\");\n+        let result = cmd.output().unwrap();\n+        env::remove_var(\"RUN_TEST_NEW_ENV2\");\n+\n+        let output = String::from_utf8_lossy(&result.stdout).to_string();\n+\n+        assert!(output.contains(\"RUN_TEST_NEW_ENV1=123\"),\n+                \"didn't find RUN_TEST_NEW_ENV1 inside of:\\n\\n{}\", output);\n+        assert!(output.contains(\"RUN_TEST_NEW_ENV2=456\"),\n+                \"didn't find RUN_TEST_NEW_ENV2 inside of:\\n\\n{}\", output);\n+    }\n+\n     // Regression tests for #30858.\n     #[test]\n     fn test_interior_nul_in_progname_is_error() {"}, {"sha": "3fd54973896977cef0e348035df8a1a1c5f9ce55", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=ccc91d7b4873a50678b3f65c895290915c54f6f5", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use collections::hash_map::HashMap;\n-use env::{self, split_paths};\n+use env::{split_paths};\n use ffi::OsStr;\n use os::unix::ffi::OsStrExt;\n use fmt;\n@@ -19,6 +18,7 @@ use sys::fd::FileDesc;\n use sys::fs::{File, OpenOptions};\n use sys::pipe::{self, AnonPipe};\n use sys::{cvt, syscall};\n+use sys_common::process::{CommandEnv, DefaultEnvKey};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n@@ -44,7 +44,7 @@ pub struct Command {\n     // other keys.\n     program: String,\n     args: Vec<String>,\n-    env: HashMap<String, String>,\n+    env: CommandEnv<DefaultEnvKey>,\n \n     cwd: Option<String>,\n     uid: Option<u32>,\n@@ -90,7 +90,7 @@ impl Command {\n         Command {\n             program: program.to_str().unwrap().to_owned(),\n             args: Vec::new(),\n-            env: HashMap::new(),\n+            env: Default::default(),\n             cwd: None,\n             uid: None,\n             gid: None,\n@@ -106,16 +106,8 @@ impl Command {\n         self.args.push(arg.to_str().unwrap().to_owned());\n     }\n \n-    pub fn env(&mut self, key: &OsStr, val: &OsStr) {\n-        self.env.insert(key.to_str().unwrap().to_owned(), val.to_str().unwrap().to_owned());\n-    }\n-\n-    pub fn env_remove(&mut self, key: &OsStr) {\n-        self.env.remove(key.to_str().unwrap());\n-    }\n-\n-    pub fn env_clear(&mut self) {\n-        self.env.clear();\n+    pub fn env_mut(&mut self) -> &mut CommandEnv<DefaultEnvKey> {\n+        &mut self.env\n     }\n \n     pub fn cwd(&mut self, dir: &OsStr) {\n@@ -309,9 +301,7 @@ impl Command {\n             args.push([arg.as_ptr() as usize, arg.len()]);\n         }\n \n-        for (key, val) in self.env.iter() {\n-            env::set_var(key, val);\n-        }\n+        self.env.apply();\n \n         let program = if self.program.contains(':') || self.program.contains('/') {\n             Some(PathBuf::from(&self.program))"}, {"sha": "c53bcdbf8e36f228bf060a0aa5410ca3157093e2", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 60, "deletions": 83, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=ccc91d7b4873a50678b3f65c895290915c54f6f5", "patch": "@@ -10,8 +10,6 @@\n \n use os::unix::prelude::*;\n \n-use collections::hash_map::{HashMap, Entry};\n-use env;\n use ffi::{OsString, OsStr, CString, CStr};\n use fmt;\n use io;\n@@ -20,6 +18,8 @@ use ptr;\n use sys::fd::FileDesc;\n use sys::fs::{File, OpenOptions};\n use sys::pipe::{self, AnonPipe};\n+use sys_common::process::{CommandEnv, DefaultEnvKey};\n+use collections::BTreeMap;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n@@ -45,9 +45,8 @@ pub struct Command {\n     // other keys.\n     program: CString,\n     args: Vec<CString>,\n-    env: Option<HashMap<OsString, (usize, CString)>>,\n     argv: Vec<*const c_char>,\n-    envp: Option<Vec<*const c_char>>,\n+    env: CommandEnv<DefaultEnvKey>,\n \n     cwd: Option<CString>,\n     uid: Option<uid_t>,\n@@ -96,8 +95,7 @@ impl Command {\n             argv: vec![program.as_ptr(), ptr::null()],\n             program,\n             args: Vec::new(),\n-            env: None,\n-            envp: None,\n+            env: Default::default(),\n             cwd: None,\n             uid: None,\n             gid: None,\n@@ -121,68 +119,6 @@ impl Command {\n         self.args.push(arg);\n     }\n \n-    fn init_env_map(&mut self) -> (&mut HashMap<OsString, (usize, CString)>,\n-                                   &mut Vec<*const c_char>) {\n-        if self.env.is_none() {\n-            let mut map = HashMap::new();\n-            let mut envp = Vec::new();\n-            for (k, v) in env::vars_os() {\n-                let s = pair_to_key(&k, &v, &mut self.saw_nul);\n-                envp.push(s.as_ptr());\n-                map.insert(k, (envp.len() - 1, s));\n-            }\n-            envp.push(ptr::null());\n-            self.env = Some(map);\n-            self.envp = Some(envp);\n-        }\n-        (self.env.as_mut().unwrap(), self.envp.as_mut().unwrap())\n-    }\n-\n-    pub fn env(&mut self, key: &OsStr, val: &OsStr) {\n-        let new_key = pair_to_key(key, val, &mut self.saw_nul);\n-        let (map, envp) = self.init_env_map();\n-\n-        // If `key` is already present then we just update `envp` in place\n-        // (and store the owned value), but if it's not there we override the\n-        // trailing NULL pointer, add a new NULL pointer, and store where we\n-        // were located.\n-        match map.entry(key.to_owned()) {\n-            Entry::Occupied(mut e) => {\n-                let (i, ref mut s) = *e.get_mut();\n-                envp[i] = new_key.as_ptr();\n-                *s = new_key;\n-            }\n-            Entry::Vacant(e) => {\n-                let len = envp.len();\n-                envp[len - 1] = new_key.as_ptr();\n-                envp.push(ptr::null());\n-                e.insert((len - 1, new_key));\n-            }\n-        }\n-    }\n-\n-    pub fn env_remove(&mut self, key: &OsStr) {\n-        let (map, envp) = self.init_env_map();\n-\n-        // If we actually ended up removing a key, then we need to update the\n-        // position of all keys that come after us in `envp` because they're all\n-        // one element sooner now.\n-        if let Some((i, _)) = map.remove(key) {\n-            envp.remove(i);\n-\n-            for (_, &mut (ref mut j, _)) in map.iter_mut() {\n-                if *j >= i {\n-                    *j -= 1;\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn env_clear(&mut self) {\n-        self.env = Some(HashMap::new());\n-        self.envp = Some(vec![ptr::null()]);\n-    }\n-\n     pub fn cwd(&mut self, dir: &OsStr) {\n         self.cwd = Some(os2c(dir, &mut self.saw_nul));\n     }\n@@ -196,9 +132,6 @@ impl Command {\n     pub fn saw_nul(&self) -> bool {\n         self.saw_nul\n     }\n-    pub fn get_envp(&self) -> &Option<Vec<*const c_char>> {\n-        &self.envp\n-    }\n     pub fn get_argv(&self) -> &Vec<*const c_char> {\n         &self.argv\n     }\n@@ -237,6 +170,15 @@ impl Command {\n         self.stderr = Some(stderr);\n     }\n \n+    pub fn env_mut(&mut self) -> &mut CommandEnv<DefaultEnvKey> {\n+        &mut self.env\n+    }\n+\n+    pub fn capture_env(&mut self) -> Option<CStringArray> {\n+        let maybe_env = self.env.capture_if_changed();\n+        maybe_env.map(|env| construct_envp(env, &mut self.saw_nul))\n+    }\n+\n     pub fn setup_io(&self, default: Stdio, needs_stdin: bool)\n                 -> io::Result<(StdioPipes, ChildPipes)> {\n         let null = Stdio::Null;\n@@ -268,6 +210,53 @@ fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n     })\n }\n \n+// Helper type to manage ownership of the strings within a C-style array.\n+pub struct CStringArray {\n+    items: Vec<CString>,\n+    ptrs: Vec<*const c_char>\n+}\n+\n+impl CStringArray {\n+    pub fn with_capacity(capacity: usize) -> Self {\n+        let mut result = CStringArray {\n+            items: Vec::with_capacity(capacity),\n+            ptrs: Vec::with_capacity(capacity+1)\n+        };\n+        result.ptrs.push(ptr::null());\n+        result\n+    }\n+    pub fn push(&mut self, item: CString) {\n+        let l = self.ptrs.len();\n+        self.ptrs[l-1] = item.as_ptr();\n+        self.ptrs.push(ptr::null());\n+        self.items.push(item);\n+    }\n+    pub fn as_ptr(&self) -> *const *const c_char {\n+        self.ptrs.as_ptr()\n+    }\n+}\n+\n+fn construct_envp(env: BTreeMap<DefaultEnvKey, OsString>, saw_nul: &mut bool) -> CStringArray {\n+    let mut result = CStringArray::with_capacity(env.len());\n+    for (k, v) in env {\n+        let mut k: OsString = k.into();\n+\n+        // Reserve additional space for '=' and null terminator\n+        k.reserve_exact(v.len() + 2);\n+        k.push(\"=\");\n+        k.push(&v);\n+\n+        // Add the new entry into the array\n+        if let Ok(item) = CString::new(k.into_vec()) {\n+            result.push(item);\n+        } else {\n+            *saw_nul = true;\n+        }\n+    }\n+\n+    result\n+}\n+\n impl Stdio {\n     pub fn to_child_stdio(&self, readable: bool)\n                       -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n@@ -337,18 +326,6 @@ impl ChildStdio {\n     }\n }\n \n-fn pair_to_key(key: &OsStr, value: &OsStr, saw_nul: &mut bool) -> CString {\n-    let (key, value) = (key.as_bytes(), value.as_bytes());\n-    let mut v = Vec::with_capacity(key.len() + value.len() + 1);\n-    v.extend(key);\n-    v.push(b'=');\n-    v.extend(value);\n-    CString::new(v).unwrap_or_else(|_e| {\n-        *saw_nul = true;\n-        CString::new(\"foo=bar\").unwrap()\n-    })\n-}\n-\n impl fmt::Debug for Command {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{:?}\", self.program)?;"}, {"sha": "06c0540fec0d7811253df5a5170b57afdbce13ca", "filename": "src/libstd/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=ccc91d7b4873a50678b3f65c895290915c54f6f5", "patch": "@@ -23,14 +23,16 @@ use sys::process::process_common::*;\n impl Command {\n     pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n                  -> io::Result<(Process, StdioPipes)> {\n+        let envp = self.capture_env();\n+\n         if self.saw_nul() {\n             return Err(io::Error::new(io::ErrorKind::InvalidInput,\n                                       \"nul byte found in provided data\"));\n         }\n \n         let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n \n-        let process_handle = unsafe { self.do_exec(theirs)? };\n+        let process_handle = unsafe { self.do_exec(theirs, envp.as_ref())? };\n \n         Ok((Process { handle: Handle::new(process_handle) }, ours))\n     }\n@@ -50,13 +52,13 @@ impl Command {\n         }\n     }\n \n-    unsafe fn do_exec(&mut self, stdio: ChildPipes)\n+    unsafe fn do_exec(&mut self, stdio: ChildPipes, maybe_envp: Option<&CStringArray>)\n                       -> io::Result<zx_handle_t> {\n         use sys::process::zircon::*;\n \n         let job_handle = zx_job_default();\n-        let envp = match *self.get_envp() {\n-            Some(ref envp) => envp.as_ptr(),\n+        let envp = match maybe_envp {\n+            Some(envp) => envp.as_ptr(),\n             None => ptr::null(),\n         };\n "}, {"sha": "189280a4ba9a8e89fd13eef0f29352e9686355ea", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=ccc91d7b4873a50678b3f65c895290915c54f6f5", "patch": "@@ -26,6 +26,8 @@ impl Command {\n \n         const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n \n+        let envp = self.capture_env();\n+\n         if self.saw_nul() {\n             return Err(io::Error::new(ErrorKind::InvalidInput,\n                                       \"nul byte found in provided data\"));\n@@ -38,7 +40,7 @@ impl Command {\n             match cvt(libc::fork())? {\n                 0 => {\n                     drop(input);\n-                    let err = self.do_exec(theirs);\n+                    let err = self.do_exec(theirs, envp.as_ref());\n                     let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n                     let bytes = [\n                         (errno >> 24) as u8,\n@@ -99,13 +101,15 @@ impl Command {\n     }\n \n     pub fn exec(&mut self, default: Stdio) -> io::Error {\n+        let envp = self.capture_env();\n+\n         if self.saw_nul() {\n             return io::Error::new(ErrorKind::InvalidInput,\n                                   \"nul byte found in provided data\")\n         }\n \n         match self.setup_io(default, true) {\n-            Ok((_, theirs)) => unsafe { self.do_exec(theirs) },\n+            Ok((_, theirs)) => unsafe { self.do_exec(theirs, envp.as_ref()) },\n             Err(e) => e,\n         }\n     }\n@@ -140,7 +144,11 @@ impl Command {\n     // allocation). Instead we just close it manually. This will never\n     // have the drop glue anyway because this code never returns (the\n     // child will either exec() or invoke libc::exit)\n-    unsafe fn do_exec(&mut self, stdio: ChildPipes) -> io::Error {\n+    unsafe fn do_exec(\n+        &mut self,\n+        stdio: ChildPipes,\n+        maybe_envp: Option<&CStringArray>\n+    ) -> io::Error {\n         use sys::{self, cvt_r};\n \n         macro_rules! t {\n@@ -180,7 +188,7 @@ impl Command {\n         if let Some(ref cwd) = *self.get_cwd() {\n             t!(cvt(libc::chdir(cwd.as_ptr())));\n         }\n-        if let Some(ref envp) = *self.get_envp() {\n+        if let Some(envp) = maybe_envp {\n             *sys::os::environ() = envp.as_ptr();\n         }\n "}, {"sha": "f3f5de350f176bdb2f71f15a5422a8737ab9d39e", "filename": "src/libstd/sys/wasm/process.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs?ref=ccc91d7b4873a50678b3f65c895290915c54f6f5", "patch": "@@ -14,12 +14,14 @@ use io;\n use sys::fs::File;\n use sys::pipe::AnonPipe;\n use sys::{unsupported, Void};\n+use sys_common::process::{CommandEnv, DefaultEnvKey};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct Command {\n+    env: CommandEnv<DefaultEnvKey>\n }\n \n // passed back to std::process with the pipes connected to the child, if any\n@@ -38,19 +40,16 @@ pub enum Stdio {\n \n impl Command {\n     pub fn new(_program: &OsStr) -> Command {\n-        Command {}\n+        Command {\n+            env: Default::default()\n+        }\n     }\n \n     pub fn arg(&mut self, _arg: &OsStr) {\n     }\n \n-    pub fn env(&mut self, _key: &OsStr, _val: &OsStr) {\n-    }\n-\n-    pub fn env_remove(&mut self, _key: &OsStr) {\n-    }\n-\n-    pub fn env_clear(&mut self) {\n+    pub fn env_mut(&mut self) -> &mut CommandEnv<DefaultEnvKey> {\n+        &mut self.env\n     }\n \n     pub fn cwd(&mut self, _dir: &OsStr) {"}, {"sha": "414c9c5418e45dbeb0966b4dc97a834690b75036", "filename": "src/libstd/sys/windows/os_str.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs?ref=ccc91d7b4873a50678b3f65c895290915c54f6f5", "patch": "@@ -17,7 +17,7 @@ use sys_common::wtf8::{Wtf8, Wtf8Buf};\n use mem;\n use rc::Rc;\n use sync::Arc;\n-use sys_common::{AsInner, IntoInner};\n+use sys_common::{AsInner, IntoInner, FromInner};\n \n #[derive(Clone, Hash)]\n pub struct Buf {\n@@ -30,6 +30,12 @@ impl IntoInner<Wtf8Buf> for Buf {\n     }\n }\n \n+impl FromInner<Wtf8Buf> for Buf {\n+    fn from_inner(inner: Wtf8Buf) -> Self {\n+        Buf { inner }\n+    }\n+}\n+\n impl AsInner<Wtf8> for Buf {\n     fn as_inner(&self) -> &Wtf8 {\n         &self.inner"}, {"sha": "c93179869a6511786b9771d6e519a22a23cf99d2", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 52, "deletions": 46, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=ccc91d7b4873a50678b3f65c895290915c54f6f5", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable(feature = \"process_internals\", issue = \"0\")]\n+\n use ascii::AsciiExt;\n-use collections::HashMap;\n-use collections;\n+use collections::BTreeMap;\n use env::split_paths;\n use env;\n use ffi::{OsString, OsStr};\n@@ -28,19 +29,42 @@ use sys::fs::{OpenOptions, File};\n use sys::handle::Handle;\n use sys::pipe::{self, AnonPipe};\n use sys::stdio;\n-use sys::{self, cvt};\n-use sys_common::{AsInner, FromInner};\n+use sys::cvt;\n+use sys_common::{AsInner, FromInner, IntoInner};\n+use sys_common::process::{CommandEnv, EnvKey};\n+use alloc::borrow::Borrow;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n ////////////////////////////////////////////////////////////////////////////////\n \n-fn mk_key(s: &OsStr) -> OsString {\n-    FromInner::from_inner(sys::os_str::Buf {\n-        inner: s.as_inner().inner.to_ascii_uppercase()\n-    })\n+#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]\n+#[doc(hidden)]\n+pub struct WindowsEnvKey(OsString);\n+\n+impl From<OsString> for WindowsEnvKey {\n+    fn from(k: OsString) -> Self {\n+        let mut buf = k.into_inner().into_inner();\n+        buf.make_ascii_uppercase();\n+        WindowsEnvKey(FromInner::from_inner(FromInner::from_inner(buf)))\n+    }\n+}\n+\n+impl From<WindowsEnvKey> for OsString {\n+    fn from(k: WindowsEnvKey) -> Self { k.0 }\n }\n \n+impl Borrow<OsStr> for WindowsEnvKey {\n+    fn borrow(&self) -> &OsStr { &self.0 }\n+}\n+\n+impl AsRef<OsStr> for WindowsEnvKey {\n+    fn as_ref(&self) -> &OsStr { &self.0 }\n+}\n+\n+impl EnvKey for WindowsEnvKey {}\n+\n+\n fn ensure_no_nuls<T: AsRef<OsStr>>(str: T) -> io::Result<T> {\n     if str.as_ref().encode_wide().any(|b| b == 0) {\n         Err(io::Error::new(ErrorKind::InvalidInput, \"nul byte found in provided data\"))\n@@ -52,7 +76,7 @@ fn ensure_no_nuls<T: AsRef<OsStr>>(str: T) -> io::Result<T> {\n pub struct Command {\n     program: OsString,\n     args: Vec<OsString>,\n-    env: Option<HashMap<OsString, OsString>>,\n+    env: CommandEnv<WindowsEnvKey>,\n     cwd: Option<OsString>,\n     flags: u32,\n     detach: bool, // not currently exposed in std::process\n@@ -83,7 +107,7 @@ impl Command {\n         Command {\n             program: program.to_os_string(),\n             args: Vec::new(),\n-            env: None,\n+            env: Default::default(),\n             cwd: None,\n             flags: 0,\n             detach: false,\n@@ -96,23 +120,8 @@ impl Command {\n     pub fn arg(&mut self, arg: &OsStr) {\n         self.args.push(arg.to_os_string())\n     }\n-    fn init_env_map(&mut self){\n-        if self.env.is_none() {\n-            self.env = Some(env::vars_os().map(|(key, val)| {\n-                (mk_key(&key), val)\n-            }).collect());\n-        }\n-    }\n-    pub fn env(&mut self, key: &OsStr, val: &OsStr) {\n-        self.init_env_map();\n-        self.env.as_mut().unwrap().insert(mk_key(key), val.to_os_string());\n-    }\n-    pub fn env_remove(&mut self, key: &OsStr) {\n-        self.init_env_map();\n-        self.env.as_mut().unwrap().remove(&mk_key(key));\n-    }\n-    pub fn env_clear(&mut self) {\n-        self.env = Some(HashMap::new())\n+    pub fn env_mut(&mut self) -> &mut CommandEnv<WindowsEnvKey> {\n+        &mut self.env\n     }\n     pub fn cwd(&mut self, dir: &OsStr) {\n         self.cwd = Some(dir.to_os_string())\n@@ -132,13 +141,12 @@ impl Command {\n \n     pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n                  -> io::Result<(Process, StdioPipes)> {\n+        let maybe_env = self.env.capture_if_changed();\n         // To have the spawning semantics of unix/windows stay the same, we need\n         // to read the *child's* PATH if one is provided. See #15149 for more\n         // details.\n-        let program = self.env.as_ref().and_then(|env| {\n-            for (key, v) in env {\n-                if OsStr::new(\"PATH\") != &**key { continue }\n-\n+        let program = maybe_env.as_ref().and_then(|env| {\n+            if let Some(v) = env.get(OsStr::new(\"PATH\")) {\n                 // Split the value and test each path to see if the\n                 // program exists.\n                 for path in split_paths(&v) {\n@@ -148,7 +156,6 @@ impl Command {\n                         return Some(path.into_os_string())\n                     }\n                 }\n-                break\n             }\n             None\n         });\n@@ -167,7 +174,7 @@ impl Command {\n             flags |= c::DETACHED_PROCESS | c::CREATE_NEW_PROCESS_GROUP;\n         }\n \n-        let (envp, _data) = make_envp(self.env.as_ref())?;\n+        let (envp, _data) = make_envp(maybe_env)?;\n         let (dirp, _data) = make_dirp(self.cwd.as_ref())?;\n         let mut pi = zeroed_process_information();\n \n@@ -488,25 +495,24 @@ fn make_command_line(prog: &OsStr, args: &[OsString]) -> io::Result<Vec<u16>> {\n     }\n }\n \n-fn make_envp(env: Option<&collections::HashMap<OsString, OsString>>)\n+fn make_envp(maybe_env: Option<BTreeMap<WindowsEnvKey, OsString>>)\n              -> io::Result<(*mut c_void, Vec<u16>)> {\n     // On Windows we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n-    match env {\n-        Some(env) => {\n-            let mut blk = Vec::new();\n-\n-            for pair in env {\n-                blk.extend(ensure_no_nuls(pair.0)?.encode_wide());\n-                blk.push('=' as u16);\n-                blk.extend(ensure_no_nuls(pair.1)?.encode_wide());\n-                blk.push(0);\n-            }\n+    if let Some(env) = maybe_env {\n+        let mut blk = Vec::new();\n+\n+        for (k, v) in env {\n+            blk.extend(ensure_no_nuls(k.0)?.encode_wide());\n+            blk.push('=' as u16);\n+            blk.extend(ensure_no_nuls(v)?.encode_wide());\n             blk.push(0);\n-            Ok((blk.as_mut_ptr() as *mut c_void, blk))\n         }\n-        _ => Ok((ptr::null_mut(), Vec::new()))\n+        blk.push(0);\n+        Ok((blk.as_mut_ptr() as *mut c_void, blk))\n+    } else {\n+        Ok((ptr::null_mut(), Vec::new()))\n     }\n }\n "}, {"sha": "b16299a1d636017f19fe60c62a7b9391d01d839c", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=ccc91d7b4873a50678b3f65c895290915c54f6f5", "patch": "@@ -44,6 +44,7 @@ pub mod thread_local;\n pub mod util;\n pub mod wtf8;\n pub mod bytestring;\n+pub mod process;\n \n cfg_if! {\n     if #[cfg(any(target_os = \"redox\", target_os = \"l4re\"))] {"}, {"sha": "fd1a5fdb4109b01333980860ff988cc6e5fa1aed", "filename": "src/libstd/sys_common/process.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys_common%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys_common%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fprocess.rs?ref=ccc91d7b4873a50678b3f65c895290915c54f6f5", "patch": "@@ -0,0 +1,124 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![unstable(feature = \"process_internals\", issue = \"0\")]\n+\n+use ffi::{OsStr, OsString};\n+use env;\n+use collections::BTreeMap;\n+use alloc::borrow::Borrow;\n+\n+pub trait EnvKey:\n+    From<OsString> + Into<OsString> +\n+    Borrow<OsStr> + Borrow<Self> + AsRef<OsStr> +\n+    Ord + Clone {}\n+\n+// Implement a case-sensitive environment variable key\n+#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]\n+pub struct DefaultEnvKey(OsString);\n+\n+impl From<OsString> for DefaultEnvKey {\n+    fn from(k: OsString) -> Self { DefaultEnvKey(k) }\n+}\n+\n+impl From<DefaultEnvKey> for OsString {\n+    fn from(k: DefaultEnvKey) -> Self { k.0 }\n+}\n+\n+impl Borrow<OsStr> for DefaultEnvKey {\n+    fn borrow(&self) -> &OsStr { &self.0 }\n+}\n+\n+impl AsRef<OsStr> for DefaultEnvKey {\n+    fn as_ref(&self) -> &OsStr { &self.0 }\n+}\n+\n+impl EnvKey for DefaultEnvKey {}\n+\n+// Stores a set of changes to an environment\n+#[derive(Clone, Debug)]\n+pub struct CommandEnv<K> {\n+    clear: bool,\n+    vars: BTreeMap<K, Option<OsString>>\n+}\n+\n+impl<K: EnvKey> Default for CommandEnv<K> {\n+    fn default() -> Self {\n+        CommandEnv {\n+            clear: false,\n+            vars: Default::default()\n+        }\n+    }\n+}\n+\n+impl<K: EnvKey> CommandEnv<K> {\n+    // Capture the current environment with these changes applied\n+    pub fn capture(&self) -> BTreeMap<K, OsString> {\n+        let mut result = BTreeMap::<K, OsString>::new();\n+        if !self.clear {\n+            for (k, v) in env::vars_os() {\n+                result.insert(k.into(), v);\n+            }\n+        }\n+        for (k, maybe_v) in &self.vars {\n+            if let &Some(ref v) = maybe_v {\n+                result.insert(k.clone(), v.clone());\n+            } else {\n+                result.remove(k);\n+            }\n+        }\n+        result\n+    }\n+\n+    // Apply these changes directly to the current environment\n+    pub fn apply(&self) {\n+        if self.clear {\n+            for (k, _) in env::vars_os() {\n+                env::remove_var(k);\n+            }\n+        }\n+        for (key, maybe_val) in self.vars.iter() {\n+            if let &Some(ref val) = maybe_val {\n+                env::set_var(key, val);\n+            } else {\n+                env::remove_var(key);\n+            }\n+        }\n+    }\n+\n+    pub fn is_unchanged(&self) -> bool {\n+        !self.clear && self.vars.is_empty()\n+    }\n+\n+    pub fn capture_if_changed(&self) -> Option<BTreeMap<K, OsString>> {\n+        if self.is_unchanged() {\n+            None\n+        } else {\n+            Some(self.capture())\n+        }\n+    }\n+\n+    // The following functions build up changes\n+    pub fn set(&mut self, key: &OsStr, value: &OsStr) {\n+        self.vars.insert(key.to_owned().into(), Some(value.to_owned()));\n+    }\n+    pub fn remove(&mut self, key: &OsStr) {\n+        if self.clear {\n+            self.vars.remove(key);\n+        } else {\n+            self.vars.insert(key.to_owned().into(), None);\n+        }\n+    }\n+    pub fn clear(&mut self) {\n+        self.clear = true;\n+        self.vars.clear();\n+    }\n+}"}, {"sha": "46d554d6411be3beb99ee250cef1910eb8c18443", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc91d7b4873a50678b3f65c895290915c54f6f5/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=ccc91d7b4873a50678b3f65c895290915c54f6f5", "patch": "@@ -134,6 +134,12 @@ impl ops::Deref for Wtf8Buf {\n     }\n }\n \n+impl ops::DerefMut for Wtf8Buf {\n+    fn deref_mut(&mut self) -> &mut Wtf8 {\n+        self.as_mut_slice()\n+    }\n+}\n+\n /// Format the string with double quotes,\n /// and surrogates as `\\u` followed by four hexadecimal digits.\n /// Example: `\"a\\u{D800}\"` for a string with code points [U+0061, U+D800]\n@@ -221,6 +227,11 @@ impl Wtf8Buf {\n         unsafe { Wtf8::from_bytes_unchecked(&self.bytes) }\n     }\n \n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &mut Wtf8 {\n+        unsafe { Wtf8::from_mut_bytes_unchecked(&mut self.bytes) }\n+    }\n+\n     /// Reserves capacity for at least `additional` more bytes to be inserted\n     /// in the given `Wtf8Buf`.\n     /// The collection may reserve more space to avoid frequent reallocations.\n@@ -486,6 +497,15 @@ impl Wtf8 {\n         mem::transmute(value)\n     }\n \n+    /// Creates a mutable WTF-8 slice from a mutable WTF-8 byte slice.\n+    ///\n+    /// Since the byte slice is not checked for valid WTF-8, this functions is\n+    /// marked unsafe.\n+    #[inline]\n+    unsafe fn from_mut_bytes_unchecked(value: &mut [u8]) -> &mut Wtf8 {\n+        mem::transmute(value)\n+    }\n+\n     /// Returns the length, in WTF-8 bytes.\n     #[inline]\n     pub fn len(&self) -> usize {"}]}