{"sha": "201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMWYwNjk4OGZiNzdjOTg2NWIwZGRjNjBhOGQ3YjU3MDFjNmRiYmU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-06-15T14:08:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-06-21T14:16:43Z"}, "message": "Integrate jobserver support to parallel codegen\n\nThis commit integrates the `jobserver` crate into the compiler. The crate was\npreviously integrated in to Cargo as part of rust-lang/cargo#4110. The purpose\nhere is to two-fold:\n\n* Primarily the compiler can cooperate with Cargo on parallelism. When you run\n  `cargo build -j4` then this'll make sure that the entire build process between\n  Cargo/rustc won't use more than 4 cores, whereas today you'd get 4 rustc\n  instances which may all try to spawn lots of threads.\n\n* Secondarily rustc/Cargo can now integrate with a foreign GNU `make` jobserver.\n  This means that if you call cargo/rustc from `make` or another\n  jobserver-compatible implementation it'll use foreign parallelism settings\n  instead of creating new ones locally.\n\nAs the number of parallel codegen instances in the compiler continues to grow\nover time with the advent of incremental compilation it's expected that this'll\nbecome more of a problem, so this is intended to nip concurrent concerns in the\nbud by having all the tools to cooperate!\n\nNote that while rustc has support for itself creating a jobserver it's far more\nlikely that rustc will always use the jobserver configured by Cargo. Cargo today\nwill now set a jobserver unconditionally for rustc to use.", "tree": {"sha": "41eec8d6919522506e874ba924203b18f5a537b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41eec8d6919522506e874ba924203b18f5a537b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "html_url": "https://github.com/rust-lang/rust/commit/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03198da2add75a0bcec792ffd84fcc8d94e8637e", "url": "https://api.github.com/repos/rust-lang/rust/commits/03198da2add75a0bcec792ffd84fcc8d94e8637e", "html_url": "https://github.com/rust-lang/rust/commit/03198da2add75a0bcec792ffd84fcc8d94e8637e"}], "stats": {"total": 825, "additions": 514, "deletions": 311}, "files": [{"sha": "7e969ce9b846290f382f4265673dbaba144bf785", "filename": "src/Cargo.lock", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -293,6 +293,9 @@ dependencies = [\n [[package]]\n name = \"core\"\n version = \"0.0.0\"\n+dependencies = [\n+ \"rand 0.0.0\",\n+]\n \n [[package]]\n name = \"crates-io\"\n@@ -1099,6 +1102,7 @@ dependencies = [\n  \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n+ \"jobserver 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_back 0.0.0\",\n@@ -1394,8 +1398,10 @@ dependencies = [\n name = \"rustc_trans\"\n version = \"0.0.0\"\n dependencies = [\n+ \"crossbeam 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"jobserver 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\","}, {"sha": "178df02ccdde33e5e4c97a130a961f6f5c91ddc6", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -9,6 +9,9 @@ path = \"lib.rs\"\n test = false\n bench = false\n \n+[dev-dependencies]\n+rand = { path = \"../librand\" }\n+\n [[test]]\n name = \"coretests\"\n path = \"../libcore/tests/lib.rs\""}, {"sha": "89169548bbb9509cf50fa48f66b39d0b1125b968", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -12,6 +12,7 @@ crate-type = [\"dylib\"]\n arena = { path = \"../libarena\" }\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n+jobserver = \"0.1\"\n log = \"0.3\"\n owning_ref = \"0.3.3\"\n rustc_back = { path = \"../librustc_back\" }"}, {"sha": "b81c56e5ee8e4320503dcd66e89323aa40490689", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -61,6 +61,7 @@ extern crate rustc_errors as errors;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n+extern crate jobserver;\n \n extern crate serialize as rustc_serialize; // used by deriving\n "}, {"sha": "70c07982f83cb9154e7a0b6c638c170ed0c7115f", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -38,14 +38,16 @@ use syntax_pos::{Span, MultiSpan};\n use rustc_back::{LinkerFlavor, PanicStrategy};\n use rustc_back::target::Target;\n use rustc_data_structures::flock;\n+use jobserver::Client;\n \n-use std::path::{Path, PathBuf};\n use std::cell::{self, Cell, RefCell};\n use std::collections::HashMap;\n use std::env;\n+use std::fmt;\n use std::io::Write;\n+use std::path::{Path, PathBuf};\n use std::rc::Rc;\n-use std::fmt;\n+use std::sync::{Once, ONCE_INIT};\n use std::time::Duration;\n \n mod code_stats;\n@@ -134,6 +136,10 @@ pub struct Session {\n     pub print_fuel_crate: Option<String>,\n     /// Always set to zero and incremented so that we can print fuel expended by a crate.\n     pub print_fuel: Cell<u64>,\n+\n+    /// Loaded up early on in the initialization of this `Session` to avoid\n+    /// false positives about a job server in our environment.\n+    pub jobserver_from_env: Option<Client>,\n }\n \n pub struct PerfStats {\n@@ -697,6 +703,24 @@ pub fn build_session_(sopts: config::Options,\n         print_fuel_crate: print_fuel_crate,\n         print_fuel: print_fuel,\n         out_of_fuel: Cell::new(false),\n+\n+        // Note that this is unsafe because it may misinterpret file descriptors\n+        // on Unix as jobserver file descriptors. We hopefully execute this near\n+        // the beginning of the process though to ensure we don't get false\n+        // positives, or in other words we try to execute this before we open\n+        // any file descriptors ourselves.\n+        //\n+        // Also note that we stick this in a global because there could be\n+        // multiple `Session` instances in this process, and the jobserver is\n+        // per-process.\n+        jobserver_from_env: unsafe {\n+            static mut GLOBAL_JOBSERVER: *mut Option<Client> = 0 as *mut _;\n+            static INIT: Once = ONCE_INIT;\n+            INIT.call_once(|| {\n+                GLOBAL_JOBSERVER = Box::into_raw(Box::new(Client::from_env()));\n+            });\n+            (*GLOBAL_JOBSERVER).clone()\n+        },\n     };\n \n     sess"}, {"sha": "86590bff4ff7da3e5f7856d9cd5a5bca95a5097c", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -10,7 +10,9 @@ crate-type = [\"dylib\"]\n test = false\n \n [dependencies]\n+crossbeam = \"0.2\"\n flate2 = \"0.2\"\n+jobserver = \"0.1.5\"\n log = \"0.3\"\n owning_ref = \"0.3.3\"\n rustc = { path = \"../librustc\" }"}, {"sha": "1f88f90dbbb28048a2ead7f92146f1e4f2b948da", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -329,34 +329,38 @@ pub fn filename_for_input(sess: &Session,\n }\n \n pub fn each_linked_rlib(sess: &Session,\n-                        f: &mut FnMut(CrateNum, &Path)) {\n+                        f: &mut FnMut(CrateNum, &Path)) -> Result<(), String> {\n     let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic).into_iter();\n     let fmts = sess.dependency_formats.borrow();\n     let fmts = fmts.get(&config::CrateTypeExecutable)\n                    .or_else(|| fmts.get(&config::CrateTypeStaticlib))\n                    .or_else(|| fmts.get(&config::CrateTypeCdylib))\n                    .or_else(|| fmts.get(&config::CrateTypeProcMacro));\n-    let fmts = fmts.unwrap_or_else(|| {\n-        bug!(\"could not find formats for rlibs\");\n-    });\n+    let fmts = match fmts {\n+        Some(f) => f,\n+        None => return Err(format!(\"could not find formats for rlibs\"))\n+    };\n     for (cnum, path) in crates {\n-        match fmts[cnum.as_usize() - 1] {\n-            Linkage::NotLinked | Linkage::IncludedFromDylib => continue,\n-            _ => {}\n+        match fmts.get(cnum.as_usize() - 1) {\n+            Some(&Linkage::NotLinked) |\n+            Some(&Linkage::IncludedFromDylib) => continue,\n+            Some(_) => {}\n+            None => return Err(format!(\"could not find formats for rlibs\"))\n         }\n         let name = sess.cstore.crate_name(cnum).clone();\n         let path = match path {\n             LibSource::Some(p) => p,\n             LibSource::MetadataOnly => {\n-                sess.fatal(&format!(\"could not find rlib for: `{}`, found rmeta (metadata) file\",\n-                                    name));\n+                return Err(format!(\"could not find rlib for: `{}`, found rmeta (metadata) file\",\n+                                   name))\n             }\n             LibSource::None => {\n-                sess.fatal(&format!(\"could not find rlib for: `{}`\", name));\n+                return Err(format!(\"could not find rlib for: `{}`\", name))\n             }\n         };\n         f(cnum, &path);\n     }\n+    Ok(())\n }\n \n fn out_filename(sess: &Session,\n@@ -669,7 +673,7 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n     let mut ab = link_rlib(sess, None, objects, out_filename, tempdir);\n     let mut all_native_libs = vec![];\n \n-    each_linked_rlib(sess, &mut |cnum, path| {\n+    let res = each_linked_rlib(sess, &mut |cnum, path| {\n         let name = sess.cstore.crate_name(cnum);\n         let native_libs = sess.cstore.native_libraries(cnum);\n \n@@ -694,6 +698,9 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n \n         all_native_libs.extend(sess.cstore.native_libraries(cnum));\n     });\n+    if let Err(e) = res {\n+        sess.fatal(&e);\n+    }\n \n     ab.update_symbols();\n     ab.build();"}, {"sha": "906815583bf0983cfe4defc0d5e5f0e03de73199", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -10,15 +10,16 @@\n \n use back::link;\n use back::write;\n-use back::symbol_export::{self, ExportedSymbols};\n-use rustc::session::{self, config};\n+use back::symbol_export;\n+use rustc::session::config;\n+use errors::FatalError;\n use llvm;\n use llvm::archive_ro::ArchiveRO;\n use llvm::{ModuleRef, TargetMachineRef, True, False};\n use rustc::util::common::time;\n use rustc::util::common::path2cstr;\n use rustc::hir::def_id::LOCAL_CRATE;\n-use back::write::{ModuleConfig, with_llvm_pmb};\n+use back::write::{ModuleConfig, with_llvm_pmb, CodegenContext};\n \n use libc;\n use flate2::read::ZlibDecoder;\n@@ -39,30 +40,31 @@ pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n     }\n }\n \n-pub fn run(sess: &session::Session,\n+pub fn run(cgcx: &CodegenContext,\n            llmod: ModuleRef,\n            tm: TargetMachineRef,\n-           exported_symbols: &ExportedSymbols,\n            config: &ModuleConfig,\n-           temp_no_opt_bc_filename: &Path) {\n-    if sess.opts.cg.prefer_dynamic {\n-        sess.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n+           temp_no_opt_bc_filename: &Path) -> Result<(), FatalError> {\n+    let handler = cgcx.handler;\n+    if cgcx.opts.cg.prefer_dynamic {\n+        handler.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n             .note(\"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n                    supported with LTO\")\n             .emit();\n-        sess.abort_if_errors();\n+        return Err(FatalError)\n     }\n \n     // Make sure we actually can run LTO\n-    for crate_type in sess.crate_types.borrow().iter() {\n+    for crate_type in cgcx.crate_types.iter() {\n         if !crate_type_allows_lto(*crate_type) {\n-            sess.fatal(\"lto can only be run for executables, cdylibs and \\\n-                            static library outputs\");\n+            let e = handler.fatal(\"lto can only be run for executables, cdylibs and \\\n+                                   static library outputs\");\n+            return Err(e)\n         }\n     }\n \n     let export_threshold =\n-        symbol_export::crates_export_threshold(&sess.crate_types.borrow());\n+        symbol_export::crates_export_threshold(&cgcx.crate_types);\n \n     let symbol_filter = &|&(ref name, level): &(String, _)| {\n         if symbol_export::is_below_threshold(level, export_threshold) {\n@@ -74,7 +76,7 @@ pub fn run(sess: &session::Session,\n         }\n     };\n \n-    let mut symbol_white_list: Vec<CString> = exported_symbols\n+    let mut symbol_white_list: Vec<CString> = cgcx.exported_symbols\n         .exported_symbols(LOCAL_CRATE)\n         .iter()\n         .filter_map(symbol_filter)\n@@ -83,16 +85,11 @@ pub fn run(sess: &session::Session,\n     // For each of our upstream dependencies, find the corresponding rlib and\n     // load the bitcode from the archive. Then merge it into the current LLVM\n     // module that we've got.\n-    link::each_linked_rlib(sess, &mut |cnum, path| {\n-        // `#![no_builtins]` crates don't participate in LTO.\n-        if sess.cstore.is_no_builtins(cnum) {\n-            return;\n-        }\n-\n+    for &(cnum, ref path) in cgcx.each_linked_rlib_for_lto.iter() {\n         symbol_white_list.extend(\n-            exported_symbols.exported_symbols(cnum)\n-                            .iter()\n-                            .filter_map(symbol_filter));\n+            cgcx.exported_symbols.exported_symbols(cnum)\n+                                 .iter()\n+                                 .filter_map(symbol_filter));\n \n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let bytecodes = archive.iter().filter_map(|child| {\n@@ -102,7 +99,7 @@ pub fn run(sess: &session::Session,\n             let bc_encoded = data.data();\n \n             let bc_decoded = if is_versioned_bytecode_format(bc_encoded) {\n-                time(sess.time_passes(), &format!(\"decode {}\", name), || {\n+                time(cgcx.time_passes, &format!(\"decode {}\", name), || {\n                     // Read the version\n                     let version = extract_bytecode_format_version(bc_encoded);\n \n@@ -117,44 +114,49 @@ pub fn run(sess: &session::Session,\n                         let res = ZlibDecoder::new(compressed_data)\n                             .read_to_end(&mut inflated);\n                         if res.is_err() {\n-                            sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n-                                               name))\n+                            let msg = format!(\"failed to decompress bc of `{}`\",\n+                                              name);\n+                            Err(handler.fatal(&msg))\n+                        } else {\n+                            Ok(inflated)\n                         }\n-                        inflated\n                     } else {\n-                        sess.fatal(&format!(\"Unsupported bytecode format version {}\",\n-                                           version))\n+                        Err(handler.fatal(&format!(\"Unsupported bytecode format version {}\",\n+                                                   version)))\n                     }\n-                })\n+                })?\n             } else {\n-                time(sess.time_passes(), &format!(\"decode {}\", name), || {\n+                time(cgcx.time_passes, &format!(\"decode {}\", name), || {\n                     // the object must be in the old, pre-versioning format, so\n                     // simply inflate everything and let LLVM decide if it can\n                     // make sense of it\n                     let mut inflated = Vec::new();\n                     let res = ZlibDecoder::new(bc_encoded)\n                         .read_to_end(&mut inflated);\n                     if res.is_err() {\n-                        sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n-                                           name))\n+                        let msg = format!(\"failed to decompress bc of `{}`\",\n+                                          name);\n+                        Err(handler.fatal(&msg))\n+                    } else {\n+                        Ok(inflated)\n                     }\n-                    inflated\n-                })\n+                })?\n             };\n \n             let ptr = bc_decoded.as_ptr();\n             debug!(\"linking {}\", name);\n-            time(sess.time_passes(), &format!(\"ll link {}\", name), || unsafe {\n-                if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n-                                                        ptr as *const libc::c_char,\n-                                                        bc_decoded.len() as libc::size_t) {\n-                    write::llvm_err(sess.diagnostic(),\n-                                    format!(\"failed to load bc of `{}`\",\n-                                            name));\n+            time(cgcx.time_passes, &format!(\"ll link {}\", name), || unsafe {\n+                if llvm::LLVMRustLinkInExternalBitcode(llmod,\n+                                                       ptr as *const libc::c_char,\n+                                                       bc_decoded.len() as libc::size_t) {\n+                    Ok(())\n+                } else {\n+                    let msg = format!(\"failed to load bc of `{}`\", name);\n+                    Err(write::llvm_err(handler, msg))\n                 }\n-            });\n+            })?;\n         }\n-    });\n+    }\n \n     // Internalize everything but the exported symbols of the current module\n     let arr: Vec<*const libc::c_char> = symbol_white_list.iter()\n@@ -167,13 +169,13 @@ pub fn run(sess: &session::Session,\n                                          arr.len() as libc::size_t);\n     }\n \n-    if sess.no_landing_pads() {\n+    if cgcx.no_landing_pads {\n         unsafe {\n             llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n         }\n     }\n \n-    if sess.opts.cg.save_temps {\n+    if cgcx.opts.cg.save_temps {\n         let cstr = path2cstr(temp_no_opt_bc_filename);\n         unsafe {\n             llvm::LLVMWriteBitcodeToFile(llmod, cstr.as_ptr());\n@@ -203,12 +205,13 @@ pub fn run(sess: &session::Session,\n         assert!(!pass.is_null());\n         llvm::LLVMRustAddPass(pm, pass);\n \n-        time(sess.time_passes(), \"LTO passes\", ||\n+        time(cgcx.time_passes, \"LTO passes\", ||\n              llvm::LLVMRunPassManager(pm, llmod));\n \n         llvm::LLVMDisposePassManager(pm);\n     }\n     debug!(\"lto done\");\n+    Ok(())\n }\n \n fn is_versioned_bytecode_format(bc: &[u8]) -> bool {"}, {"sha": "549cb2567cfbb793bbcde207ebe2e18de2cd6a15", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 344, "deletions": 232, "changes": 576, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use back::lto;\n-use back::link::{get_linker, remove};\n+use back::link::{self, get_linker, remove};\n use back::symbol_export::ExportedSymbols;\n use rustc_incremental::{save_trans_partition, in_incr_comp_dir};\n use rustc::session::config::{self, OutputFilenames, OutputType, OutputTypes, Passes, SomePasses,\n@@ -19,21 +19,24 @@ use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef, ContextRef};\n use llvm::SMDiagnosticRef;\n use {CrateTranslation, ModuleLlvm, ModuleSource, ModuleTranslation};\n+use rustc::hir::def_id::CrateNum;\n use rustc::util::common::{time, time_depth, set_time_depth, path2cstr};\n use rustc::util::fs::link_or_copy;\n-use errors::{self, Handler, Level, DiagnosticBuilder};\n+use errors::{self, Handler, Level, DiagnosticBuilder, FatalError};\n use errors::emitter::Emitter;\n+use syntax::ext::hygiene::Mark;\n use syntax_pos::MultiSpan;\n use context::{is_pie_binary, get_reloc_model};\n+use jobserver::{Client, Acquired};\n+use crossbeam::{scope, Scope};\n \n use std::cmp;\n use std::ffi::CString;\n use std::fs;\n+use std::io;\n use std::path::{Path, PathBuf};\n use std::str;\n-use std::sync::{Arc, Mutex};\n-use std::sync::mpsc::channel;\n-use std::thread;\n+use std::sync::mpsc::{channel, Sender};\n use libc::{c_uint, c_void};\n \n pub const RELOC_MODEL_ARGS : [(&'static str, llvm::RelocMode); 7] = [\n@@ -54,10 +57,10 @@ pub const CODE_GEN_MODEL_ARGS : [(&'static str, llvm::CodeModel); 5] = [\n     (\"large\", llvm::CodeModel::Large),\n ];\n \n-pub fn llvm_err(handler: &errors::Handler, msg: String) -> ! {\n+pub fn llvm_err(handler: &errors::Handler, msg: String) -> FatalError {\n     match llvm::last_error() {\n-        Some(err) => panic!(handler.fatal(&format!(\"{}: {}\", msg, err))),\n-        None => panic!(handler.fatal(&msg)),\n+        Some(err) => handler.fatal(&format!(\"{}: {}\", msg, err)),\n+        None => handler.fatal(&msg),\n     }\n }\n \n@@ -67,73 +70,16 @@ pub fn write_output_file(\n         pm: llvm::PassManagerRef,\n         m: ModuleRef,\n         output: &Path,\n-        file_type: llvm::FileType) {\n+        file_type: llvm::FileType) -> Result<(), FatalError> {\n     unsafe {\n         let output_c = path2cstr(output);\n         let result = llvm::LLVMRustWriteOutputFile(\n                 target, pm, m, output_c.as_ptr(), file_type);\n         if result.into_result().is_err() {\n-            llvm_err(handler, format!(\"could not write output to {}\", output.display()));\n-        }\n-    }\n-}\n-\n-\n-struct Diagnostic {\n-    msg: String,\n-    code: Option<String>,\n-    lvl: Level,\n-}\n-\n-// We use an Arc instead of just returning a list of diagnostics from the\n-// child thread because we need to make sure that the messages are seen even\n-// if the child thread panics (for example, when `fatal` is called).\n-#[derive(Clone)]\n-struct SharedEmitter {\n-    buffer: Arc<Mutex<Vec<Diagnostic>>>,\n-}\n-\n-impl SharedEmitter {\n-    fn new() -> SharedEmitter {\n-        SharedEmitter {\n-            buffer: Arc::new(Mutex::new(Vec::new())),\n-        }\n-    }\n-\n-    fn dump(&mut self, handler: &Handler) {\n-        let mut buffer = self.buffer.lock().unwrap();\n-        for diag in &*buffer {\n-            match diag.code {\n-                Some(ref code) => {\n-                    handler.emit_with_code(&MultiSpan::new(),\n-                                           &diag.msg,\n-                                           &code,\n-                                           diag.lvl);\n-                },\n-                None => {\n-                    handler.emit(&MultiSpan::new(),\n-                                 &diag.msg,\n-                                 diag.lvl);\n-                },\n-            }\n-        }\n-        buffer.clear();\n-    }\n-}\n-\n-impl Emitter for SharedEmitter {\n-    fn emit(&mut self, db: &DiagnosticBuilder) {\n-        self.buffer.lock().unwrap().push(Diagnostic {\n-            msg: db.message(),\n-            code: db.code.clone(),\n-            lvl: db.level,\n-        });\n-        for child in &db.children {\n-            self.buffer.lock().unwrap().push(Diagnostic {\n-                msg: child.message(),\n-                code: None,\n-                lvl: child.level,\n-            });\n+            let msg = format!(\"could not write output to {}\", output.display());\n+            Err(llvm_err(handler, msg))\n+        } else {\n+            Ok(())\n         }\n     }\n }\n@@ -231,9 +177,9 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     };\n \n     if tm.is_null() {\n-        llvm_err(sess.diagnostic(),\n-                 format!(\"Could not create LLVM TargetMachine for triple: {}\",\n-                         triple).to_string());\n+        let msg = format!(\"Could not create LLVM TargetMachine for triple: {}\",\n+                          triple);\n+        panic!(llvm_err(sess.diagnostic(), msg));\n     } else {\n         return tm;\n     };\n@@ -333,36 +279,28 @@ impl ModuleConfig {\n }\n \n /// Additional resources used by optimize_and_codegen (not module specific)\n-struct CodegenContext<'a> {\n-    // Extra resources used for LTO: (sess, reachable).  This will be `None`\n-    // when running in a worker thread.\n-    lto_ctxt: Option<(&'a Session, &'a ExportedSymbols)>,\n+pub struct CodegenContext<'a> {\n+    // Resouces needed when running LTO\n+    pub time_passes: bool,\n+    pub lto: bool,\n+    pub no_landing_pads: bool,\n+    pub exported_symbols: &'a ExportedSymbols,\n+    pub opts: &'a config::Options,\n+    pub crate_types: Vec<config::CrateType>,\n+    pub each_linked_rlib_for_lto: Vec<(CrateNum, PathBuf)>,\n     // Handler to use for diagnostics produced during codegen.\n-    handler: &'a Handler,\n+    pub handler: &'a Handler,\n     // LLVM passes added by plugins.\n-    plugin_passes: Vec<String>,\n+    pub plugin_passes: Vec<String>,\n     // LLVM optimizations for which we want to print remarks.\n-    remark: Passes,\n+    pub remark: Passes,\n     // Worker thread number\n-    worker: usize,\n+    pub worker: usize,\n     // The incremental compilation session directory, or None if we are not\n     // compiling incrementally\n-    incr_comp_session_dir: Option<PathBuf>\n-}\n-\n-impl<'a> CodegenContext<'a> {\n-    fn new_with_session(sess: &'a Session,\n-                        exported_symbols: &'a ExportedSymbols)\n-                        -> CodegenContext<'a> {\n-        CodegenContext {\n-            lto_ctxt: Some((sess, exported_symbols)),\n-            handler: sess.diagnostic(),\n-            plugin_passes: sess.plugin_llvm_passes.borrow().clone(),\n-            remark: sess.opts.cg.remark.clone(),\n-            worker: 0,\n-            incr_comp_session_dir: sess.incr_comp_session_dir_opt().map(|r| r.clone())\n-        }\n-    }\n+    pub incr_comp_session_dir: Option<PathBuf>,\n+    // Channel back to the main control thread to send messages to\n+    pub tx: Sender<Message>,\n }\n \n struct HandlerFreeVars<'a> {\n@@ -373,22 +311,7 @@ struct HandlerFreeVars<'a> {\n unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext<'a>,\n                                                msg: &'b str,\n                                                cookie: c_uint) {\n-    use syntax::ext::hygiene::Mark;\n-\n-    match cgcx.lto_ctxt {\n-        Some((sess, _)) => {\n-            match Mark::from_u32(cookie).expn_info() {\n-                Some(ei) => sess.span_err(ei.call_site, msg),\n-                None     => sess.err(msg),\n-            };\n-        }\n-\n-        None => {\n-            cgcx.handler.struct_err(msg)\n-                        .note(\"build without -C codegen-units for more exact errors\")\n-                        .emit();\n-        }\n-    }\n+    drop(cgcx.tx.send(Message::InlineAsmError(cookie as u32, msg.to_string())));\n }\n \n unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n@@ -437,7 +360,9 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                                mtrans: ModuleTranslation,\n                                mllvm: ModuleLlvm,\n                                config: ModuleConfig,\n-                               output_names: OutputFilenames) {\n+                               output_names: OutputFilenames)\n+    -> Result<(), FatalError>\n+{\n     let llmod = mllvm.llmod;\n     let llcx = mllvm.llcx;\n     let tm = config.tm;\n@@ -525,25 +450,21 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         llvm::LLVMDisposePassManager(fpm);\n         llvm::LLVMDisposePassManager(mpm);\n \n-        match cgcx.lto_ctxt {\n-            Some((sess, exported_symbols)) if sess.lto() =>  {\n-                time(sess.time_passes(), \"all lto passes\", || {\n-                    let temp_no_opt_bc_filename =\n-                        output_names.temp_path_ext(\"no-opt.lto.bc\", module_name);\n-                    lto::run(sess,\n-                             llmod,\n-                             tm,\n-                             exported_symbols,\n-                             &config,\n-                             &temp_no_opt_bc_filename);\n-                });\n-                if config.emit_lto_bc {\n-                    let out = output_names.temp_path_ext(\"lto.bc\", module_name);\n-                    let out = path2cstr(&out);\n-                    llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n-                }\n-            },\n-            _ => {},\n+        if cgcx.lto {\n+            time(cgcx.time_passes, \"all lto passes\", || {\n+                let temp_no_opt_bc_filename =\n+                    output_names.temp_path_ext(\"no-opt.lto.bc\", module_name);\n+                lto::run(cgcx,\n+                         llmod,\n+                         tm,\n+                         &config,\n+                         &temp_no_opt_bc_filename)\n+            })?;\n+            if config.emit_lto_bc {\n+                let out = output_names.temp_path_ext(\"lto.bc\", module_name);\n+                let out = path2cstr(&out);\n+                llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n+            }\n         }\n     }\n \n@@ -555,16 +476,16 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     // pass manager passed to the closure should be ensured to not\n     // escape the closure itself, and the manager should only be\n     // used once.\n-    unsafe fn with_codegen<F>(tm: TargetMachineRef,\n-                              llmod: ModuleRef,\n-                              no_builtins: bool,\n-                              f: F) where\n-        F: FnOnce(PassManagerRef),\n+    unsafe fn with_codegen<F, R>(tm: TargetMachineRef,\n+                                 llmod: ModuleRef,\n+                                 no_builtins: bool,\n+                                 f: F) -> R\n+        where F: FnOnce(PassManagerRef) -> R,\n     {\n         let cpm = llvm::LLVMCreatePassManager();\n         llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n         llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);\n-        f(cpm);\n+        f(cpm)\n     }\n \n     // Change what we write and cleanup based on whether obj files are\n@@ -584,7 +505,8 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         llvm::LLVMWriteBitcodeToFile(llmod, bc_out_c.as_ptr());\n     }\n \n-    time(config.time_passes, &format!(\"codegen passes [{}]\", cgcx.worker), || {\n+    time(config.time_passes, &format!(\"codegen passes [{}]\", cgcx.worker),\n+         || -> Result<(), FatalError> {\n         if config.emit_ir {\n             let out = output_names.temp_path(OutputType::LlvmAssembly, module_name);\n             let out = path2cstr(&out);\n@@ -607,8 +529,8 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             };\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path,\n-                                  llvm::FileType::AssemblyFile);\n-            });\n+                                  llvm::FileType::AssemblyFile)\n+            })?;\n             if config.emit_obj {\n                 llvm::LLVMDisposeModule(llmod);\n             }\n@@ -617,10 +539,12 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         if write_obj {\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &obj_out,\n-                                  llvm::FileType::ObjectFile);\n-            });\n+                                  llvm::FileType::ObjectFile)\n+            })?;\n         }\n-    });\n+\n+        Ok(())\n+    })?;\n \n     if copy_bc_to_obj {\n         debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n@@ -637,6 +561,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     }\n \n     llvm::LLVMRustDisposeTargetMachine(tm);\n+    Ok(())\n }\n \n \n@@ -781,19 +706,16 @@ pub fn run_passes(sess: &Session,\n         dump_incremental_data(&trans);\n     }\n \n-    // Process the work items, optionally using worker threads.\n-    // NOTE: We are hardcoding a limit of worker threads for now. With\n-    //       incremental compilation we can run into situations where we would\n-    //       open hundreds of threads otherwise -- which can make things slower\n-    //       if things don't fit into memory anymore, or can cause the compiler\n-    //       to crash because of too many open file handles. See #39280 for\n-    //       some discussion on how to improve this in the future.\n-    let num_workers = cmp::min(work_items.len() - 1, 32);\n-    if num_workers <= 1 {\n-        run_work_singlethreaded(sess, &trans.exported_symbols, work_items);\n-    } else {\n-        run_work_multithreaded(sess, work_items, num_workers);\n-    }\n+    let client = sess.jobserver_from_env.clone().unwrap_or_else(|| {\n+        // Pick a \"reasonable maximum\" if we don't otherwise have a jobserver in\n+        // our environment, capping out at 32 so we don't take everything down\n+        // by hogging the process run queue.\n+        let num_workers = cmp::min(work_items.len() - 1, 32);\n+        Client::new(num_workers).expect(\"failed to create jobserver\")\n+    });\n+    scope(|scope| {\n+        execute_work(sess, work_items, client, &trans.exported_symbols, scope);\n+    });\n \n     // If in incr. comp. mode, preserve the `.o` files for potential re-use\n     for mtrans in trans.modules.iter() {\n@@ -995,8 +917,9 @@ fn build_work_item(sess: &Session,\n     }\n }\n \n-fn execute_work_item(cgcx: &CodegenContext,\n-                     work_item: WorkItem) {\n+fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n+    -> Result<(), FatalError>\n+{\n     unsafe {\n         match work_item.mtrans.source {\n             ModuleSource::Translated(mllvm) => {\n@@ -1005,7 +928,7 @@ fn execute_work_item(cgcx: &CodegenContext,\n                                      work_item.mtrans,\n                                      mllvm,\n                                      work_item.config,\n-                                     work_item.output_names);\n+                                     work_item.output_names)?;\n             }\n             ModuleSource::Preexisting(wp) => {\n                 let incr_comp_session_dir = cgcx.incr_comp_session_dir\n@@ -1033,94 +956,283 @@ fn execute_work_item(cgcx: &CodegenContext,\n             }\n         }\n     }\n+\n+    Ok(())\n }\n \n-fn run_work_singlethreaded(sess: &Session,\n-                           exported_symbols: &ExportedSymbols,\n-                           work_items: Vec<WorkItem>) {\n-    let cgcx = CodegenContext::new_with_session(sess, exported_symbols);\n+pub enum Message {\n+    Token(io::Result<Acquired>),\n+    Diagnostic(Diagnostic),\n+    Done { success: bool },\n+    InlineAsmError(u32, String),\n+    AbortIfErrors,\n+}\n \n-    // Since we're running single-threaded, we can pass the session to\n-    // the proc, allowing `optimize_and_codegen` to perform LTO.\n-    for work in work_items.into_iter().rev() {\n-        execute_work_item(&cgcx, work);\n-    }\n+pub struct Diagnostic {\n+    msg: String,\n+    code: Option<String>,\n+    lvl: Level,\n }\n \n-fn run_work_multithreaded(sess: &Session,\n-                          work_items: Vec<WorkItem>,\n-                          num_workers: usize) {\n-    assert!(num_workers > 0);\n-\n-    // Run some workers to process the work items.\n-    let work_items_arc = Arc::new(Mutex::new(work_items));\n-    let mut diag_emitter = SharedEmitter::new();\n-    let mut futures = Vec::with_capacity(num_workers);\n-\n-    for i in 0..num_workers {\n-        let work_items_arc = work_items_arc.clone();\n-        let diag_emitter = diag_emitter.clone();\n-        let plugin_passes = sess.plugin_llvm_passes.borrow().clone();\n-        let remark = sess.opts.cg.remark.clone();\n-\n-        let (tx, rx) = channel();\n-        let mut tx = Some(tx);\n-        futures.push(rx);\n-\n-        let incr_comp_session_dir = sess.incr_comp_session_dir_opt().map(|r| r.clone());\n-\n-        let depth = time_depth();\n-        thread::Builder::new().name(format!(\"codegen-{}\", i)).spawn(move || {\n-            set_time_depth(depth);\n-\n-            let diag_handler = Handler::with_emitter(true, false, box diag_emitter);\n-\n-            // Must construct cgcx inside the proc because it has non-Send\n-            // fields.\n-            let cgcx = CodegenContext {\n-                lto_ctxt: None,\n-                handler: &diag_handler,\n-                plugin_passes: plugin_passes,\n-                remark: remark,\n-                worker: i,\n-                incr_comp_session_dir: incr_comp_session_dir\n-            };\n+fn execute_work<'a>(sess: &'a Session,\n+                    mut work_items: Vec<WorkItem>,\n+                    jobserver: Client,\n+                    exported_symbols: &'a ExportedSymbols,\n+                    scope: &Scope<'a>) {\n+    let (tx, rx) = channel();\n+    let tx2 = tx.clone();\n+\n+    // First up, convert our jobserver into a helper thread so we can use normal\n+    // mpsc channels to manage our messages and such. Once we've got the helper\n+    // thread then request `n-1` tokens because all of our work items are ready\n+    // to go.\n+    //\n+    // Note that the `n-1` is here because we ourselves have a token (our\n+    // process) and we'll use that token to execute at least one unit of work.\n+    //\n+    // After we've requested all these tokens then we'll, when we can, get\n+    // tokens on `rx` above which will get managed in the main loop below.\n+    let helper = jobserver.into_helper_thread(move |token| {\n+        drop(tx2.send(Message::Token(token)));\n+    }).expect(\"failed to spawn helper thread\");\n+    for _ in 0..work_items.len() - 1 {\n+        helper.request_token();\n+    }\n+\n+    // This is the \"main loop\" of parallel work happening for parallel codegen.\n+    // It's here that we manage parallelism, schedule work, and work with\n+    // messages coming from clients.\n+    //\n+    // Our channel `rx` created above is a channel of messages coming from our\n+    // various worker threads. This includes the jobserver helper thread above\n+    // as well as the work we'll spawn off here. Each turn of this loop starts\n+    // off by trying to spawn as much work as possible. After we've done that we\n+    // then wait for an event and dispatch accordingly once the event is\n+    // received. We're only done once all our work items have been drained and\n+    // nothing is running, at which point we return back up the stack.\n+    //\n+    // ## Parallelism management\n+    //\n+    // It's worth also touching on the management of parallelism here. We don't\n+    // want to just spawn a thread per work item because while that's optimal\n+    // parallelism it may overload a system with too many threads or violate our\n+    // configuration for the maximum amount of cpu to use for this process. To\n+    // manage this we use the `jobserver` crate.\n+    //\n+    // Job servers are an artifact of GNU make and are used to manage\n+    // parallelism between processes. A jobserver is a glorified IPC semaphore\n+    // basically. Whenever we want to run some work we acquire the semaphore,\n+    // and whenever we're done with that work we release the semaphore. In this\n+    // manner we can ensure that the maximum number of parallel workers is\n+    // capped at any one point in time.\n+    //\n+    // The jobserver protocol is a little unique, however. We, as a running\n+    // process, already have an ephemeral token assigned to us. We're not going\n+    // to be doing any productive work in this thread though so we're going to\n+    // give this token to a worker thread (there's no actual token to give, this\n+    // is just conceptually). As a result you'll see a few `+1` and `-1`\n+    // instances below, and it's about working with this ephemeral token.\n+    //\n+    // To acquire tokens we have our `helper` thread above which is just in a\n+    // loop acquiring tokens and sending them to us. We then store all tokens\n+    // locally in a `tokens` vector once they're acquired. Currently we don't\n+    // literally send a token to a worker thread to assist with management of\n+    // our \"ephemeral token\".\n+    //\n+    // As a result, our \"spawn as much work as possible\" basically means that we\n+    // fill up the `running` counter up to the limit of the `tokens` list.\n+    // Whenever we get a new token this'll mean a new unit of work is spawned,\n+    // and then whenever a unit of work finishes we relinquish a token, if we\n+    // had one, to maybe get re-acquired later.\n+    //\n+    // Note that there's a race which may mean that we acquire more tokens than\n+    // we originally anticipated. For example let's say we have 2 units of work.\n+    // First we request one token from the helper thread and then we\n+    // immediately spawn one unit of work with our ephemeral token after. We may\n+    // then finish the first piece of work before the token is acquired, but we\n+    // can continue to spawn the second piece of work with our ephemeral token.\n+    // Before that work finishes, however, we may acquire a token. In that case\n+    // we actually wastefully acquired the token, so we relinquish it back to\n+    // the jobserver.\n+    let mut tokens = Vec::new();\n+    let mut running = 0;\n+    while work_items.len() > 0 || running > 0 {\n+\n+        // Spin up what work we can, only doing this while we've got available\n+        // parallelism slots and work left to spawn.\n+        while work_items.len() > 0 && running < tokens.len() + 1 {\n+            let item = work_items.pop().unwrap();\n+            let index = work_items.len();\n+            spawn_work(sess, exported_symbols, scope, tx.clone(), item, index);\n+            running += 1;\n+        }\n+\n+        // Relinquish accidentally acquired extra tokens\n+        tokens.truncate(running.saturating_sub(1));\n+\n+        match rx.recv().unwrap() {\n+            // Save the token locally and the next turn of the loop will use\n+            // this to spawn a new unit of work, or it may get dropped\n+            // immediately if we have no more work to spawn.\n+            Message::Token(token) => {\n+                tokens.push(token.expect(\"failed to acquire jobserver token\"));\n+            }\n \n-            loop {\n-                // Avoid holding the lock for the entire duration of the match.\n-                let maybe_work = work_items_arc.lock().unwrap().pop();\n-                match maybe_work {\n-                    Some(work) => {\n-                        execute_work_item(&cgcx, work);\n+            // If a thread exits successfully then we drop a token associated\n+            // with that worker and update our `running` count. We may later\n+            // re-acquire a token to continue running more work. We may also not\n+            // actually drop a token here if the worker was running with an\n+            // \"ephemeral token\"\n+            //\n+            // Note that if the thread failed that means it panicked, so we\n+            // abort immediately.\n+            Message::Done { success: true } => {\n+                drop(tokens.pop());\n+                running -= 1;\n+            }\n+            Message::Done { success: false } => {\n+                sess.fatal(\"aborting due to worker thread panic\");\n+            }\n \n-                        // Make sure to fail the worker so the main thread can\n-                        // tell that there were errors.\n-                        cgcx.handler.abort_if_errors();\n+            // Our worker wants us to emit an error message, so get ahold of our\n+            // `sess` and print it out\n+            Message::Diagnostic(diag) => {\n+                let handler = sess.diagnostic();\n+                match diag.code {\n+                    Some(ref code) => {\n+                        handler.emit_with_code(&MultiSpan::new(),\n+                                               &diag.msg,\n+                                               &code,\n+                                               diag.lvl);\n+                    }\n+                    None => {\n+                        handler.emit(&MultiSpan::new(),\n+                                     &diag.msg,\n+                                     diag.lvl);\n                     }\n-                    None => break,\n+                }\n+            }\n+            Message::InlineAsmError(cookie, msg) => {\n+                match Mark::from_u32(cookie).expn_info() {\n+                    Some(ei) => sess.span_err(ei.call_site, &msg),\n+                    None     => sess.err(&msg),\n                 }\n             }\n \n-            tx.take().unwrap().send(()).unwrap();\n-        }).unwrap();\n+            // Sent to us after a worker sends us a batch of error messages, and\n+            // it's the point at which we check for errors.\n+            Message::AbortIfErrors => sess.diagnostic().abort_if_errors(),\n+        }\n     }\n \n-    let mut panicked = false;\n-    for rx in futures {\n-        match rx.recv() {\n-            Ok(()) => {},\n-            Err(_) => {\n-                panicked = true;\n-            },\n+    // Just in case, check this on the way out.\n+    sess.diagnostic().abort_if_errors();\n+}\n+\n+struct SharedEmitter {\n+    tx: Sender<Message>,\n+}\n+\n+impl Emitter for SharedEmitter {\n+    fn emit(&mut self, db: &DiagnosticBuilder) {\n+        drop(self.tx.send(Message::Diagnostic(Diagnostic {\n+            msg: db.message(),\n+            code: db.code.clone(),\n+            lvl: db.level,\n+        })));\n+        for child in &db.children {\n+            drop(self.tx.send(Message::Diagnostic(Diagnostic {\n+                msg: child.message(),\n+                code: None,\n+                lvl: child.level,\n+            })));\n         }\n-        // Display any new diagnostics.\n-        diag_emitter.dump(sess.diagnostic());\n-    }\n-    if panicked {\n-        sess.fatal(\"aborting due to worker thread panic\");\n+        drop(self.tx.send(Message::AbortIfErrors));\n     }\n }\n \n+fn spawn_work<'a>(sess: &'a Session,\n+                  exported_symbols: &'a ExportedSymbols,\n+                  scope: &Scope<'a>,\n+                  tx: Sender<Message>,\n+                  work: WorkItem,\n+                  idx: usize) {\n+    let plugin_passes = sess.plugin_llvm_passes.borrow().clone();\n+    let remark = sess.opts.cg.remark.clone();\n+    let incr_comp_session_dir = sess.incr_comp_session_dir_opt().map(|r| r.clone());\n+    let depth = time_depth();\n+    let lto = sess.lto();\n+    let crate_types = sess.crate_types.borrow().clone();\n+    let mut each_linked_rlib_for_lto = Vec::new();\n+    drop(link::each_linked_rlib(sess, &mut |cnum, path| {\n+        // `#![no_builtins]` crates don't participate in LTO.\n+        if sess.cstore.is_no_builtins(cnum) {\n+            return\n+        }\n+        each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n+    }));\n+    let time_passes = sess.time_passes();\n+    let no_landing_pads = sess.no_landing_pads();\n+    let opts = &sess.opts;\n+\n+    scope.spawn(move || {\n+        set_time_depth(depth);\n+\n+        // Set up a destructor which will fire off a message that we're done as\n+        // we exit.\n+        struct Bomb {\n+            tx: Sender<Message>,\n+            success: bool,\n+        }\n+        impl Drop for Bomb {\n+            fn drop(&mut self) {\n+                drop(self.tx.send(Message::Done { success: self.success }));\n+            }\n+        }\n+        let mut bomb = Bomb {\n+            tx: tx.clone(),\n+            success: false,\n+        };\n+\n+        // Set up our non-`Send` `CodegenContext` now that we're in a helper\n+        // thread and have all our info available to us.\n+        let emitter = SharedEmitter { tx: tx.clone() };\n+        let diag_handler = Handler::with_emitter(true, false, Box::new(emitter));\n+\n+        let cgcx = CodegenContext {\n+            crate_types: crate_types,\n+            each_linked_rlib_for_lto: each_linked_rlib_for_lto,\n+            lto: lto,\n+            no_landing_pads: no_landing_pads,\n+            opts: opts,\n+            time_passes: time_passes,\n+            exported_symbols: exported_symbols,\n+            handler: &diag_handler,\n+            plugin_passes: plugin_passes,\n+            remark: remark,\n+            worker: idx,\n+            incr_comp_session_dir: incr_comp_session_dir,\n+            tx: tx.clone(),\n+        };\n+\n+        // Execute the work itself, and if it finishes successfully then flag\n+        // ourselves as a success as well.\n+        //\n+        // Note that we ignore the result coming out of `execute_work_item`\n+        // which will tell us if the worker failed with a `FatalError`. If that\n+        // has happened, however, then a diagnostic was sent off to the main\n+        // thread, along with an `AbortIfErrors` message. In that case the main\n+        // thread is already exiting anyway most likely.\n+        //\n+        // In any case, there's no need for us to take further action here, so\n+        // we just ignore the result and then send off our message saying that\n+        // we're done, which if `execute_work_item` failed is unlikely to be\n+        // seen by the main thread, but hey we might as well try anyway.\n+        drop(execute_work_item(&cgcx, work).is_err());\n+        bomb.success = true;\n+    });\n+}\n+\n pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     let (pname, mut cmd, _) = get_linker(sess);\n "}, {"sha": "859c6574787acdba8c39dfca2cd554601557f032", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -40,6 +40,7 @@ use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n \n extern crate flate2;\n+extern crate crossbeam;\n extern crate libc;\n extern crate owning_ref;\n #[macro_use] extern crate rustc;\n@@ -52,6 +53,7 @@ extern crate rustc_const_math;\n #[macro_use]\n #[no_link]\n extern crate rustc_bitflags;\n+extern crate jobserver;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "1e97cb07f8960c3aeb6a9541a6e302b6fed9bf8b", "filename": "src/test/compile-fail-fulldeps/derive-no-std-not-supported.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Fcompile-fail-fulldeps%2Fderive-no-std-not-supported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Fcompile-fail-fulldeps%2Fderive-no-std-not-supported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fderive-no-std-not-supported.rs?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -10,7 +10,6 @@\n \n #![no_std]\n \n-extern crate rand;\n extern crate serialize as rustc_serialize;\n \n #[derive(RustcEncodable)]  //~ ERROR this trait cannot be derived"}, {"sha": "6c5c5b00776d84a97431642d243ac4a7266e7ac3", "filename": "src/test/compile-fail/asm-src-loc-codegen-units.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Fcompile-fail%2Fasm-src-loc-codegen-units.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Fcompile-fail%2Fasm-src-loc-codegen-units.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-src-loc-codegen-units.rs?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -7,17 +7,16 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-//\n+\n // WONTFIX(#20184) Needs landing pads (not present in stage1) or the compiler hangs.\n // ignore-stage1\n // compile-flags: -C codegen-units=2\n-// error-pattern: build without -C codegen-units for more exact errors\n // ignore-emscripten\n \n #![feature(asm)]\n \n fn main() {\n     unsafe {\n-        asm!(\"nowayisthisavalidinstruction\");\n+        asm!(\"nowayisthisavalidinstruction\"); //~ ERROR instruction\n     }\n }"}, {"sha": "33ac11feb2db694620a903d56b24b72c3d69aa47", "filename": "src/test/compile-fail/auxiliary/issue-36881-aux.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fissue-36881-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fissue-36881-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fissue-36881-aux.rs?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Foo {}"}, {"sha": "b61667cfd882ce02e3a44b5141adea3352a211f1", "filename": "src/test/compile-fail/auxiliary/lint_unused_extern_crate2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_unused_extern_crate2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_unused_extern_crate2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_unused_extern_crate2.rs?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn foo() {}"}, {"sha": "b61667cfd882ce02e3a44b5141adea3352a211f1", "filename": "src/test/compile-fail/auxiliary/lint_unused_extern_crate3.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_unused_extern_crate3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_unused_extern_crate3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_unused_extern_crate3.rs?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn foo() {}"}, {"sha": "fc4bca865c932e390fd8898f1ad3d3d1b93391d4", "filename": "src/test/compile-fail/auxiliary/lint_unused_extern_crate4.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_unused_extern_crate4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_unused_extern_crate4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_unused_extern_crate4.rs?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms."}, {"sha": "e05dc06619969015e26a4da65a8906d9dc695eed", "filename": "src/test/compile-fail/issue-36881.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Fcompile-fail%2Fissue-36881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Fcompile-fail%2Fissue-36881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-36881.rs?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rand)]\n+// aux-build:issue-36881-aux.rs\n \n fn main() {\n-    extern crate rand;\n-    use rand::Rng; //~ ERROR unresolved import\n+    extern crate issue_36881_aux;\n+    use issue_36881_aux::Foo; //~ ERROR unresolved import\n }"}, {"sha": "b12ef6277bb4b5135f896661834efe9d8abadeee", "filename": "src/test/compile-fail/lint-unused-extern-crate.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -9,34 +9,34 @@\n // except according to those terms.\n \n // aux-build:lint_unused_extern_crate.rs\n+// aux-build:lint_unused_extern_crate2.rs\n+// aux-build:lint_unused_extern_crate3.rs\n+// aux-build:lint_unused_extern_crate4.rs\n \n #![deny(unused_extern_crates)]\n #![allow(unused_variables)]\n #![allow(deprecated)]\n-#![feature(alloc)]\n-#![feature(libc)]\n-#![feature(rand)]\n \n-extern crate libc; //~ ERROR: unused extern crate\n+extern crate lint_unused_extern_crate4; //~ ERROR: unused extern crate\n \n-extern crate alloc as collecs; // no error, it is used\n+extern crate lint_unused_extern_crate3; // no error, it is used\n \n-extern crate rand; // no error, the use marks it as used\n-                   // even if imported objects aren't used\n+extern crate lint_unused_extern_crate2; // no error, the use marks it as used\n+                                        // even if imported objects aren't used\n \n extern crate lint_unused_extern_crate as other; // no error, the use * marks it as used\n \n #[allow(unused_imports)]\n-use rand::isaac::IsaacRng;\n+use lint_unused_extern_crate2::foo as bar;\n \n use other::*;\n \n mod foo {\n-    // Test that this is unused even though an earler `extern crate rand` is used.\n-    extern crate rand; //~ ERROR unused extern crate\n+    // Test that this is unused even though an earler `extern crate` is used.\n+    extern crate lint_unused_extern_crate2; //~ ERROR unused extern crate\n }\n \n fn main() {\n-    let x: collecs::vec::Vec<usize> = Vec::new();\n+    lint_unused_extern_crate3::foo();\n     let y = foo();\n }"}, {"sha": "f4a32a93dfb71ee4ade576b636bab246cedf69c8", "filename": "src/test/run-pass/auxiliary/allocator-dummy.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Frun-pass%2Fauxiliary%2Fallocator-dummy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201f06988fb77c9865b0ddc60a8d7b5701c6dbbe/src%2Ftest%2Frun-pass%2Fauxiliary%2Fallocator-dummy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fallocator-dummy.rs?ref=201f06988fb77c9865b0ddc60a8d7b5701c6dbbe", "patch": "@@ -10,11 +10,13 @@\n \n // no-prefer-dynamic\n \n-#![feature(allocator, core_intrinsics)]\n+#![feature(allocator, core_intrinsics, panic_unwind)]\n #![allocator]\n #![crate_type = \"rlib\"]\n #![no_std]\n \n+extern crate unwind;\n+\n pub static mut HITS: usize = 0;\n \n type size_t = usize;"}]}