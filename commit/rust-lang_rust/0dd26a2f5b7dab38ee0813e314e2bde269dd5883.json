{"sha": "0dd26a2f5b7dab38ee0813e314e2bde269dd5883", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkZDI2YTJmNWI3ZGFiMzhlZTA4MTNlMzE0ZTJiZGUyNjlkZDU4ODM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-20T14:08:40Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-20T14:08:40Z"}, "message": "Use OO module API in completion", "tree": {"sha": "de392fdaa24e02ec8852da460dceecad7b624997", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de392fdaa24e02ec8852da460dceecad7b624997"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dd26a2f5b7dab38ee0813e314e2bde269dd5883", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dd26a2f5b7dab38ee0813e314e2bde269dd5883", "html_url": "https://github.com/rust-lang/rust/commit/0dd26a2f5b7dab38ee0813e314e2bde269dd5883", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dd26a2f5b7dab38ee0813e314e2bde269dd5883/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21508cfb2f5452c6f19ab0e615a6c61cb28154c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/21508cfb2f5452c6f19ab0e615a6c61cb28154c8", "html_url": "https://github.com/rust-lang/rust/commit/21508cfb2f5452c6f19ab0e615a6c61cb28154c8"}], "stats": {"total": 99, "additions": 31, "deletions": 68}, "files": [{"sha": "5e3ee79dd8734914907b1fe35516b477fc508e1c", "filename": "crates/ra_analysis/src/completion/mod.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0dd26a2f5b7dab38ee0813e314e2bde269dd5883/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd26a2f5b7dab38ee0813e314e2bde269dd5883/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs?ref=0dd26a2f5b7dab38ee0813e314e2bde269dd5883", "patch": "@@ -2,7 +2,6 @@ mod reference_completion;\n \n use ra_editor::find_node_at_offset;\n use ra_syntax::{\n-    algo::find_leaf_at_offset,\n     algo::visit::{visitor_ctx, VisitorCtx},\n     ast,\n     AstNode, AtomEdit,\n@@ -12,8 +11,9 @@ use rustc_hash::{FxHashMap};\n \n use crate::{\n     db::{self, SyntaxDatabase},\n-    descriptors::{DescriptorDatabase, module::ModuleSource},\n-    input::{FilesDatabase},\n+    descriptors::{\n+        module::{ModuleDescriptor}\n+    },\n     Cancelable, FilePosition\n };\n \n@@ -38,14 +38,7 @@ pub(crate) fn completions(\n         original_file.reparse(&edit)\n     };\n \n-    let leaf = match find_leaf_at_offset(original_file.syntax(), position.offset).left_biased() {\n-        None => return Ok(None),\n-        Some(it) => it,\n-    };\n-    let source_root_id = db.file_source_root(position.file_id);\n-    let module_tree = db.module_tree(source_root_id)?;\n-    let module_source = ModuleSource::for_node(position.file_id, leaf);\n-    let module_id = match module_tree.any_module_for_source(module_source) {\n+    let module = match ModuleDescriptor::guess_from_position(db, position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -55,15 +48,7 @@ pub(crate) fn completions(\n     // First, let's try to complete a reference to some declaration.\n     if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n         has_completions = true;\n-        reference_completion::completions(\n-            &mut res,\n-            db,\n-            source_root_id,\n-            &module_tree,\n-            module_id,\n-            &file,\n-            name_ref,\n-        )?;\n+        reference_completion::completions(&mut res, db, &module, &file, name_ref)?;\n         // special case, `trait T { fn foo(i_am_a_name_ref) {} }`\n         if is_node::<ast::Param>(name_ref.syntax()) {\n             param_completions(name_ref.syntax(), &mut res);"}, {"sha": "c94d9af75ac157bfbe1701645318679d9c557c18", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0dd26a2f5b7dab38ee0813e314e2bde269dd5883/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd26a2f5b7dab38ee0813e314e2bde269dd5883/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=0dd26a2f5b7dab38ee0813e314e2bde269dd5883", "patch": "@@ -9,20 +9,16 @@ use ra_syntax::{\n \n use crate::{\n     db::RootDatabase,\n-    input::{SourceRootId},\n     completion::CompletionItem,\n-    descriptors::module::{ModuleId, ModuleTree},\n+    descriptors::module::{ModuleDescriptor},\n     descriptors::function::FnScopes,\n-    descriptors::DescriptorDatabase,\n     Cancelable\n };\n \n pub(super) fn completions(\n     acc: &mut Vec<CompletionItem>,\n     db: &RootDatabase,\n-    source_root_id: SourceRootId,\n-    module_tree: &ModuleTree,\n-    module_id: ModuleId,\n+    module: &ModuleDescriptor,\n     file: &SourceFileNode,\n     name_ref: ast::NameRef,\n ) -> Cancelable<()> {\n@@ -40,7 +36,7 @@ pub(super) fn completions(\n                 complete_expr_snippets(acc);\n             }\n \n-            let module_scope = db.module_scope(source_root_id, module_id)?;\n+            let module_scope = module.scope(db)?;\n             acc.extend(\n                 module_scope\n                     .entries()\n@@ -56,9 +52,7 @@ pub(super) fn completions(\n                     }),\n             );\n         }\n-        NameRefKind::CratePath(path) => {\n-            complete_path(acc, db, source_root_id, module_tree, module_id, path)?\n-        }\n+        NameRefKind::CratePath(path) => complete_path(acc, db, module, path)?,\n         NameRefKind::BareIdentInMod => {\n             let name_range = name_ref.syntax().range();\n             let top_node = name_ref\n@@ -171,16 +165,14 @@ fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<Completi\n fn complete_path(\n     acc: &mut Vec<CompletionItem>,\n     db: &RootDatabase,\n-    source_root_id: SourceRootId,\n-    module_tree: &ModuleTree,\n-    module_id: ModuleId,\n+    module: &ModuleDescriptor,\n     crate_path: Vec<ast::NameRef>,\n ) -> Cancelable<()> {\n-    let target_module_id = match find_target_module(module_tree, module_id, crate_path) {\n+    let target_module = match find_target_module(module, crate_path) {\n         None => return Ok(()),\n         Some(it) => it,\n     };\n-    let module_scope = db.module_scope(source_root_id, target_module_id)?;\n+    let module_scope = target_module.scope(db)?;\n     let completions = module_scope.entries().iter().map(|entry| CompletionItem {\n         label: entry.name().to_string(),\n         lookup: None,\n@@ -191,14 +183,13 @@ fn complete_path(\n }\n \n fn find_target_module(\n-    module_tree: &ModuleTree,\n-    module_id: ModuleId,\n+    module: &ModuleDescriptor,\n     mut crate_path: Vec<ast::NameRef>,\n-) -> Option<ModuleId> {\n+) -> Option<ModuleDescriptor> {\n     crate_path.pop();\n-    let mut target_module = module_id.root(&module_tree);\n+    let mut target_module = module.crate_root();\n     for name in crate_path {\n-        target_module = target_module.child(module_tree, name.text().as_str())?;\n+        target_module = target_module.child(name.text().as_str())?;\n     }\n     Some(target_module)\n }"}, {"sha": "a894025eda9d806423bbc016aae3054ee38f29bd", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 15, "deletions": 28, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0dd26a2f5b7dab38ee0813e314e2bde269dd5883/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dd26a2f5b7dab38ee0813e314e2bde269dd5883/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=0dd26a2f5b7dab38ee0813e314e2bde269dd5883", "patch": "@@ -15,6 +15,7 @@ use relative_path::RelativePathBuf;\n use crate::{\n     db::SyntaxDatabase, syntax_ptr::SyntaxPtr, FileId, FilePosition, Cancelable,\n     descriptors::DescriptorDatabase,\n+    input::SourceRootId\n };\n \n pub(crate) use self::scope::ModuleScope;\n@@ -24,6 +25,7 @@ pub(crate) use self::scope::ModuleScope;\n #[derive(Debug, Clone)]\n pub(crate) struct ModuleDescriptor {\n     tree: Arc<ModuleTree>,\n+    source_root_id: SourceRootId,\n     module_id: ModuleId,\n }\n \n@@ -59,13 +61,14 @@ impl ModuleDescriptor {\n         file_id: FileId,\n         module_source: ModuleSource,\n     ) -> Cancelable<Option<ModuleDescriptor>> {\n-        let source_root = db.file_source_root(file_id);\n-        let module_tree = db.module_tree(source_root)?;\n+        let source_root_id = db.file_source_root(file_id);\n+        let module_tree = db.module_tree(source_root_id)?;\n \n         let res = match module_tree.any_module_for_source(module_source) {\n             None => None,\n             Some(module_id) => Some(ModuleDescriptor {\n                 tree: module_tree,\n+                source_root_id,\n                 module_id,\n             }),\n         };\n@@ -92,8 +95,8 @@ impl ModuleDescriptor {\n     pub fn parent(&self) -> Option<ModuleDescriptor> {\n         let parent_id = self.module_id.parent(&self.tree)?;\n         Some(ModuleDescriptor {\n-            tree: Arc::clone(&self.tree),\n             module_id: parent_id,\n+            ..self.clone()\n         })\n     }\n \n@@ -109,13 +112,20 @@ impl ModuleDescriptor {\n         let link = self.module_id.parent_link(&self.tree)?;\n         Some(link.name(&self.tree))\n     }\n+\n+    /// Finds a child module with the specified name.\n     pub fn child(&self, name: &str) -> Option<ModuleDescriptor> {\n         let child_id = self.module_id.child(&self.tree, name)?;\n         Some(ModuleDescriptor {\n-            tree: Arc::clone(&self.tree),\n             module_id: child_id,\n+            ..self.clone()\n         })\n     }\n+\n+    /// Returns a `ModuleScope`: a set of items, visible in this module.\n+    pub fn scope(&self, db: &impl DescriptorDatabase) -> Cancelable<Arc<ModuleScope>> {\n+        db.module_scope(self.source_root_id, self.module_id)\n+    }\n }\n \n /// Phisically, rust source is organized as a set of files, but logically it is\n@@ -190,20 +200,7 @@ impl ModuleId {\n         let link = self.parent_link(tree)?;\n         Some(tree.link(link).owner)\n     }\n-    pub(crate) fn root(self, tree: &ModuleTree) -> ModuleId {\n-        let mut curr = self;\n-        let mut i = 0;\n-        while let Some(next) = curr.parent(tree) {\n-            curr = next;\n-            i += 1;\n-            // simplistic cycle detection\n-            if i > 100 {\n-                return self;\n-            }\n-        }\n-        curr\n-    }\n-    pub(crate) fn child(self, tree: &ModuleTree, name: &str) -> Option<ModuleId> {\n+    fn child(self, tree: &ModuleTree, name: &str) -> Option<ModuleId> {\n         let link = tree\n             .module(self)\n             .children\n@@ -260,16 +257,6 @@ struct ModuleData {\n }\n \n impl ModuleSource {\n-    pub(crate) fn for_node(file_id: FileId, node: SyntaxNodeRef) -> ModuleSource {\n-        for node in node.ancestors() {\n-            if let Some(m) = ast::Module::cast(node) {\n-                if !m.has_semi() {\n-                    return ModuleSource::new_inline(file_id, m);\n-                }\n-            }\n-        }\n-        ModuleSource::SourceFile(file_id)\n-    }\n     pub(crate) fn new_inline(file_id: FileId, module: ast::Module) -> ModuleSource {\n         assert!(!module.has_semi());\n         let ptr = SyntaxPtr::new(file_id, module.syntax());"}]}