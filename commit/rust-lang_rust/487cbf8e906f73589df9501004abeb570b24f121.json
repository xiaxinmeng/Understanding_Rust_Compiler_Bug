{"sha": "487cbf8e906f73589df9501004abeb570b24f121", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4N2NiZjhlOTA2ZjczNTg5ZGY5NTAxMDA0YWJlYjU3MGIyNGYxMjE=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-24T22:09:57Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-24T22:09:57Z"}, "message": "Remove resources\n\nAlso fixed shapes for classes with dtors, as well as handling\noffsets for classes with dtors correctly in take glue.\n\nCloses #2485", "tree": {"sha": "7203f78ddc8930c8627966e2d292d7237c1a4a6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7203f78ddc8930c8627966e2d292d7237c1a4a6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/487cbf8e906f73589df9501004abeb570b24f121", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/487cbf8e906f73589df9501004abeb570b24f121", "html_url": "https://github.com/rust-lang/rust/commit/487cbf8e906f73589df9501004abeb570b24f121", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/487cbf8e906f73589df9501004abeb570b24f121/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60a748a1d8e9631df9b04235881917c0a80c9e03", "url": "https://api.github.com/repos/rust-lang/rust/commits/60a748a1d8e9631df9b04235881917c0a80c9e03", "html_url": "https://github.com/rust-lang/rust/commit/60a748a1d8e9631df9b04235881917c0a80c9e03"}], "stats": {"total": 873, "additions": 145, "deletions": 728}, "files": [{"sha": "fd7c3aa9e71dc47fcbe4fd8ac63d81c4e579c9a3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -670,9 +670,6 @@ enum item_ {\n     item_native_mod(native_mod),\n     item_ty(@ty, [ty_param], region_param),\n     item_enum([variant], [ty_param], region_param),\n-    item_res(fn_decl /* dtor */, [ty_param], blk /* dtor body */,\n-             node_id /* dtor id */, node_id /* ctor id */,\n-             region_param),\n     item_class([ty_param], /* ty params for class */\n                [@iface_ref],   /* ifaces this class implements */\n                [@class_member], /* methods, etc. */"}, {"sha": "219769dd28cf056ef6e913aabbb4b7c888b5782c", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -43,18 +43,14 @@ enum ast_node {\n     // order they are introduced.\n     node_arg(arg, uint),\n     node_local(uint),\n-    // Constructor for either a resource or a class\n-    node_ctor(ident, [ty_param], a_ctor, @path),\n+    // Constructor for a class\n+    // def_id is parent id\n+    node_ctor(ident, [ty_param], @class_ctor, def_id, @path),\n     // Destructor for a class\n     node_dtor([ty_param], @class_dtor, def_id, @path),\n     node_block(blk),\n }\n \n-enum a_ctor {\n-  res_ctor(fn_decl, node_id, codemap::span),\n-  class_ctor(@class_ctor, def_id /* ID for parent class */),\n-}\n-\n type map = std::map::hashmap<node_id, ast_node>;\n type ctx = {map: map, mut path: path,\n             mut local_id: uint, diag: span_handler};\n@@ -138,7 +134,7 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n                     span: sp};\n           cx.map.insert(id, node_ctor(/* FIXME (#2543) */ copy nm,\n                                       /* FIXME (#2543) */ copy tps,\n-                                      class_ctor(ct, parent_id),\n+                                      ct, parent_id,\n                                       @/* FIXME (#2543) */ copy cx.path));\n        }\n       visit::fk_dtor(tps, self_id, parent_id) {\n@@ -199,15 +195,6 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n                        cx);\n         }\n       }\n-      item_res(decl, tps, _, dtor_id, ctor_id, _) {\n-        cx.map.insert(ctor_id, node_ctor(/* FIXME (#2543) */ copy i.ident,\n-                                         /* FIXME (#2543) */ copy tps,\n-                                         res_ctor(/* FIXME (#2543) */\n-                                                  copy decl,\n-                                                  ctor_id, i.span),\n-                                         item_path));\n-        cx.map.insert(dtor_id, node_item(i, item_path));\n-      }\n       item_enum(vs, _, _) {\n         for vs.each {|v|\n             cx.map.insert(v.node.id, node_variant("}, {"sha": "f402e1f6ab599bb8a802006e62923b48aac716b5", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -425,7 +425,6 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         visit_item: fn@(i: @item) {\n             vfn(i.id);\n             alt i.node {\n-              item_res(_, _, _, d_id, c_id, _) { vfn(d_id); vfn(c_id); }\n               item_enum(vs, _, _) { for vs.each {|v| vfn(v.node.id); } }\n               _ {}\n             }\n@@ -497,8 +496,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n                 vfn(self_id);\n                 vfn(parent_id.node);\n               }\n-              visit::fk_item_fn(_, tps) |\n-              visit::fk_res(_, tps, _) {\n+              visit::fk_item_fn(_, tps) {\n                 vec::iter(tps) {|tp| vfn(tp.id)}\n               }\n               visit::fk_method(_, tps, m) {"}, {"sha": "492210a55b84fe0186ae79346db4e6fd43f29988", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -281,14 +281,6 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                        rp,\n                        /* FIXME (#2543) */ copy methods)\n           }\n-          item_res(decl, typms, body, did, cid, rp) {\n-            item_res(fold_fn_decl(decl, fld),\n-                     fold_ty_params(typms, fld),\n-                     fld.fold_block(body),\n-                     fld.new_id(did),\n-                     fld.new_id(cid),\n-                     rp)\n-          }\n         };\n }\n "}, {"sha": "2196ae9d4be357368abf1c7797558bf5ade09e14", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -1917,29 +1917,6 @@ class parser {\n         (ident, item_impl(tps, rp, ifce, ty, meths), none)\n     }\n \n-    fn parse_item_res() -> item_info {\n-        let ident = self.parse_value_ident();\n-        let rp = self.parse_region_param();\n-        let ty_params = self.parse_ty_params();\n-        self.expect(token::LPAREN);\n-        let arg_ident = self.parse_value_ident();\n-        self.expect(token::COLON);\n-        let t = self.parse_ty(false);\n-        self.expect(token::RPAREN);\n-        let dtor = self.parse_block_no_value();\n-        let decl = {\n-            inputs: [{mode: expl(by_ref), ty: t,\n-                      ident: arg_ident, id: self.get_id()}],\n-            output: @{id: self.get_id(), node: ty_nil,\n-                      span: ast_util::dummy_sp()},\n-            purity: impure_fn,\n-            cf: return_val,\n-            constraints: []\n-        };\n-        (ident, item_res(decl, ty_params, dtor,\n-                         self.get_id(), self.get_id(), rp), none)\n-    }\n-\n     // Instantiates ident <i> with references to <typarams> as arguments.\n     // Used to create a path that refers to a class which will be defined as\n     // the return type of the ctor function.\n@@ -2341,8 +2318,6 @@ class parser {\n             self.parse_item_iface()\n         } else if self.eat_keyword(\"impl\") {\n             self.parse_item_impl()\n-        } else if self.eat_keyword(\"resource\") {\n-            self.parse_item_res()\n         } else if self.eat_keyword(\"class\") {\n             self.parse_item_class()\n         } else { ret none; };"}, {"sha": "478d7f5365817215372d18715163b975b464ada9", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -293,8 +293,7 @@ fn restricted_keyword_table() -> hashmap<str, ()> {\n         \"let\", \"log\", \"loop\",\n         \"mod\", \"mut\",\n         \"native\", \"new\",\n-        \"pure\",\n-        \"resource\", \"ret\",\n+        \"pure\", \"ret\",\n         \"true\", \"trait\", \"type\",\n         \"unchecked\", \"unsafe\",\n         \"while\""}, {"sha": "54864c287ae8c48af7abf065df35e01a7227deac", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -130,38 +130,6 @@ fn test_fun_to_str() {\n     assert fun_to_str(decl, \"a\", []) == \"fn a()\";\n }\n \n-fn res_to_str(decl: ast::fn_decl, name: ast::ident,\n-              params: [ast::ty_param], rp: ast::region_param) -> str {\n-    let buffer = io::mem_buffer();\n-    let s = rust_printer(io::mem_buffer_writer(buffer));\n-    print_res(s, decl, name, params, rp);\n-    end(s); // Close the head box\n-    end(s); // Close the outer box\n-    eof(s.s);\n-    io::mem_buffer_str(buffer)\n-}\n-\n-#[test]\n-fn test_res_to_str() {\n-    let decl: ast::fn_decl = {\n-        inputs: [{\n-            mode: ast::expl(ast::by_val),\n-            ty: @{id: 0,\n-                  node: ast::ty_nil,\n-                  span: ast_util::dummy_sp()},\n-            ident: \"b\",\n-            id: 0\n-        }],\n-        output: @{id: 0,\n-                  node: ast::ty_nil,\n-                  span: ast_util::dummy_sp()},\n-        purity: ast::impure_fn,\n-        cf: ast::return_val,\n-        constraints: []\n-    };\n-    assert res_to_str(decl, \"a\", []) == \"resource a(b: ())\";\n-}\n-\n fn block_to_str(blk: ast::blk) -> str {\n     let buffer = io::mem_buffer();\n     let s = rust_printer(io::mem_buffer_writer(buffer));\n@@ -615,27 +583,10 @@ fn print_item(s: ps, &&item: @ast::item) {\n         for methods.each {|meth| print_ty_method(s, meth); }\n         bclose(s, item.span);\n       }\n-      ast::item_res(decl, tps, body, dt_id, ct_id, rp) {\n-        print_res(s, decl, item.ident, tps, rp);\n-        print_block(s, body);\n-      }\n     }\n     s.ann.post(ann_node);\n }\n \n-fn print_res(s: ps, decl: ast::fn_decl, name: ast::ident,\n-             typarams: [ast::ty_param], rp: ast::region_param) {\n-    head(s, \"resource\");\n-    word(s.s, *name);\n-    print_region_param(s, rp);\n-    print_type_params(s, typarams);\n-    popen(s);\n-    word_space(s, *decl.inputs[0].ident + \":\");\n-    print_type(s, decl.inputs[0].ty);\n-    pclose(s);\n-    space(s.s);\n-}\n-\n fn print_variant(s: ps, v: ast::variant) {\n     word(s.s, *v.node.name);\n     if vec::len(v.node.args) > 0u {"}, {"sha": "714097d356da5dd44f612be0c0bf785dc3a1f265", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -15,7 +15,6 @@ enum vt<E> { mk_vt(visitor<E>), }\n enum fn_kind {\n     fk_item_fn(ident, [ty_param]), //< an item declared with fn()\n     fk_method(ident, [ty_param], @method),\n-    fk_res(ident, [ty_param], region_param),\n     fk_anon(proto, capture_clause),  //< an anonymous function like fn@(...)\n     fk_fn_block(capture_clause),     //< a block {||...}\n     fk_ctor(ident, [ty_param], node_id /* self id */,\n@@ -27,7 +26,7 @@ enum fn_kind {\n \n fn name_of_fn(fk: fn_kind) -> ident {\n     alt fk {\n-      fk_item_fn(name, _) | fk_method(name, _, _) | fk_res(name, _, _)\n+      fk_item_fn(name, _) | fk_method(name, _, _)\n           | fk_ctor(name, _, _, _) { /* FIXME (#2543) */ copy name }\n       fk_anon(*) | fk_fn_block(*) { @\"anon\" }\n       fk_dtor(*)                  { @\"drop\" }\n@@ -36,7 +35,7 @@ fn name_of_fn(fk: fn_kind) -> ident {\n \n fn tps_of_fn(fk: fn_kind) -> [ty_param] {\n     alt fk {\n-      fk_item_fn(_, tps) | fk_method(_, tps, _) | fk_res(_, tps, _)\n+      fk_item_fn(_, tps) | fk_method(_, tps, _)\n               | fk_ctor(_, tps, _, _) | fk_dtor(tps, _, _) {\n           /* FIXME (#2543) */ copy tps\n       }\n@@ -130,12 +129,6 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         v.visit_ty(t, e, v);\n         v.visit_ty_params(tps, e, v);\n       }\n-      item_res(decl, tps, body, dtor_id, _, rp) {\n-        v.visit_fn(fk_res(/* FIXME (#2543) */ copy i.ident,\n-                          /* FIXME (#2543) */ copy tps,\n-                          rp),\n-                   decl, body, i.span, dtor_id, e, v);\n-      }\n       item_enum(variants, tps, _) {\n         v.visit_ty_params(tps, e, v);\n         for variants.each {|vr|"}, {"sha": "1ac0ac78ca7fc493cdae606ca7386be903feb3c3", "filename": "src/rt/rust_box_annihilator.cpp", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frt%2Frust_box_annihilator.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frt%2Frust_box_annihilator.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_box_annihilator.cpp?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -138,15 +138,14 @@ class annihilator : public shape::data<annihilator,shape::ptr> {\n         void *data;\n     };\n \n-    typedef void (*dtor)(void **retptr, void *env, void *dptr);\n+    typedef void (*dtor)(void **retptr, void *dptr);\n \n     static void run_dtor(run_dtor_args *args) {\n         dtor f = (dtor)args->dtor;\n-        f(NULL, args->dtor->env, args->data);\n+        f(NULL, args->data);\n     }\n \n-    void walk_res2(const shape::rust_fn *dtor, const uint8_t *end_sp,\n-                   bool live) {\n+    void walk_res2(const shape::rust_fn *dtor, const uint8_t *end_sp) {\n         void *data = (void*)(uintptr_t)dp;\n         // Switch back to the Rust stack to run the destructor\n         run_dtor_args args = {dtor, data};"}, {"sha": "1d3ae3ccccf2007b5b42e8ce6cfa26c686f9bd43", "filename": "src/rt/rust_cc.cpp", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frt%2Frust_cc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frt%2Frust_cc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cc.cpp?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -147,8 +147,7 @@ class irc : public shape::data<irc,shape::ptr> {\n     void walk_tydesc2(char) {\n     }\n \n-    void walk_res2(const shape::rust_fn *dtor, const uint8_t *end_sp,\n-                   bool live) {\n+    void walk_res2(const shape::rust_fn *dtor, const uint8_t *end_sp) {\n         while (this->sp != end_sp) {\n             this->walk();\n             align = true;\n@@ -394,8 +393,7 @@ class mark : public shape::data<mark,shape::ptr> {\n         }\n     }\n \n-    void walk_res2(const shape::rust_fn *dtor, const uint8_t *end_sp,\n-                   bool live) {\n+    void walk_res2(const shape::rust_fn *dtor, const uint8_t *end_sp) {\n         while (this->sp != end_sp) {\n             this->walk();\n             align = true;"}, {"sha": "b0f6f1f77a48ddea8b66fea1674a0d997ac06400", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -304,8 +304,7 @@ class cmp : public data<cmp,ptr_pair> {\n     void walk_tag2(tag_info &tinfo,\n                    const data_pair<tag_variant_t> &tag_variants);\n     void walk_struct2(const uint8_t *end_sp);\n-    void walk_res2(const rust_fn *dtor, const uint8_t *end_sp,\n-                   const data_pair<uintptr_t> &live);\n+    void walk_res2(const rust_fn *dtor, const uint8_t *end_sp);\n     void walk_variant2(tag_info &tinfo,\n                        tag_variant_t variant_id,\n                        const std::pair<const uint8_t *,const uint8_t *>\n@@ -356,8 +355,7 @@ cmp::walk_struct2(const uint8_t *end_sp) {\n }\n \n void\n-cmp::walk_res2(const rust_fn *dtor, const uint8_t *end_sp,\n-              const data_pair<uintptr_t> &live) {\n+cmp::walk_res2(const rust_fn *dtor, const uint8_t *end_sp) {\n     abort();    // TODO\n }\n \n@@ -463,7 +461,7 @@ log::walk_variant2(tag_info &tinfo,\n }\n \n void\n-log::walk_res2(const rust_fn *dtor, const uint8_t *end_sp, bool live) {\n+log::walk_res2(const rust_fn *dtor, const uint8_t *end_sp) {\n     out << prefix << \"res\";\n \n     if (this->sp == end_sp)"}, {"sha": "26f775c9fac195671e199c7d4edcd1d852e63dfb", "filename": "src/rt/rust_shape.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frt%2Frust_shape.h", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frt%2Frust_shape.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.h?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -950,9 +950,8 @@ class data : public ctxt< data<T,U> > {\n     }\n \n     void walk_res1(const rust_fn *dtor, const uint8_t *end_sp) {\n-        typename U::template data<uintptr_t>::t live = bump_dp<uintptr_t>(dp);\n         // Delegate to the implementation.\n-        static_cast<T *>(this)->walk_res2(dtor, end_sp, live);\n+        static_cast<T *>(this)->walk_res2(dtor, end_sp);\n     }\n \n     template<typename WN>\n@@ -1287,7 +1286,7 @@ class log : public data<log,ptr> {\n                        const std::pair<const uint8_t *,const uint8_t *>\n                        variant_ptr_and_end);\n     void walk_string2(const std::pair<ptr,ptr> &data);\n-    void walk_res2(const rust_fn *dtor, const uint8_t *end_sp, bool live);\n+    void walk_res2(const rust_fn *dtor, const uint8_t *end_sp);\n \n     template<typename T>\n     inline void walk_number2() {"}, {"sha": "7f2474e57ca97cc329bf294d5704ca065e5bc629", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -186,17 +186,6 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n               encode_name_and_def_id(ebml_w, it.ident, it.id);\n             }\n           }\n-          item_res(_, tps, _, _, ctor_id, _) {\n-            ebml_w.wr_tag(tag_paths_data_item) {||\n-                encode_name_and_def_id(ebml_w, it.ident, ctor_id);\n-            }\n-            // The same ident has to be added twice (with different positions)\n-            // because it's for both the ctor and the dtor.\n-            add_to_index(ebml_w, path, index, it.ident);\n-            ebml_w.wr_tag(tag_paths_data_item) {||\n-                encode_name_and_def_id(ebml_w, it.ident, it.id);\n-            }\n-          }\n           item_class(_, _, items, ctor, m_dtor, _) {\n             ebml_w.wr_tag(tag_paths_data_item) {||\n                 encode_name_and_def_id(ebml_w, it.ident, it.id);\n@@ -698,34 +687,6 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_index(ebml_w, bkts, write_int);\n         ebml_w.end_tag();\n       }\n-      item_res(_, tps, _, _, ctor_id, rp) {\n-        add_to_index();\n-        let fn_ty = node_id_to_type(tcx, ctor_id);\n-\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(ctor_id));\n-        encode_family(ebml_w, 'y');\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, ty::ty_fn_ret(fn_ty));\n-        encode_name(ebml_w, item.ident);\n-        ecx.encode_inlined_item(ecx, ebml_w, path, ii_item(item));\n-        if (tps.len() == 0u) {\n-            encode_symbol(ecx, ebml_w, item.id);\n-        }\n-        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-        encode_region_param(ebml_w, rp);\n-        ebml_w.end_tag();\n-\n-        *index += [{val: ctor_id, pos: ebml_w.writer.tell()}];\n-        ebml_w.start_tag(tag_items_data_item);\n-        encode_def_id(ebml_w, local_def(ctor_id));\n-        encode_family(ebml_w, 'f');\n-        encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, fn_ty);\n-        encode_parent_item(ebml_w, local_def(item.id));\n-        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n-        ebml_w.end_tag();\n-      }\n       item_impl(tps, rp, ifce, _, methods) {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);"}, {"sha": "794af5577e772cf7ab3ee0c320a966a105ed859a", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -338,14 +338,6 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       'f' {\n         parse_ty_rust_fn(st, conv)\n       }\n-      'r' {\n-        assert next(st) == '[';\n-        let def = parse_def(st, conv);\n-        let inner = parse_ty(st, conv);\n-        let substs = parse_substs(st, conv);\n-        assert next(st) == ']';\n-        ret ty::mk_res(st.tcx, def, inner, substs);\n-      }\n       'X' {\n         ret ty::mk_var(st.tcx, ty::tv_vid(parse_int(st) as uint));\n       }"}, {"sha": "dc1cbac434bf96e9b5ec3c944b0ce69993b179ca", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -265,14 +265,6 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       ty::ty_fn(f) {\n         enc_ty_fn(w, cx, f);\n       }\n-      ty::ty_res(def, ty, substs) {\n-        w.write_str(\"r[\"/&);\n-        w.write_str(cx.ds(def));\n-        w.write_char('|');\n-        enc_ty(w, cx, ty);\n-        enc_substs(w, cx, substs);\n-        w.write_char(']');\n-      }\n       ty::ty_var(id) {\n         w.write_char('X');\n         w.write_uint(id.to_uint());"}, {"sha": "7ce20dbd82f3765f565dfcce65d345537fbf84f7", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -249,7 +249,6 @@ enum ptr_kind {uniq_ptr, gc_ptr, region_ptr, unsafe_ptr}\n // structure accessible without a dereference\":\n enum comp_kind {\n     comp_tuple,                  // elt in a tuple\n-    comp_res,                    // data for a resource\n     comp_variant(ast::def_id),   // internals to a variant of given enum\n     comp_field(ast::ident,       // name of field\n                ast::mutability), // declared mutability of field\n@@ -423,7 +422,6 @@ impl to_str_methods for borrowck_ctxt {\n           comp_field(fld, _) { *fld }\n           comp_index(*) { \"[]\" }\n           comp_tuple { \"()\" }\n-          comp_res { \"<res>\" }\n           comp_variant(_) { \"<enum>\" }\n         }\n     }\n@@ -483,7 +481,6 @@ impl to_str_methods for borrowck_ctxt {\n           }\n           cat_comp(_, comp_field(*)) { mut_str + \" field\" }\n           cat_comp(_, comp_tuple) { \"tuple content\" }\n-          cat_comp(_, comp_res) { \"resource content\" }\n           cat_comp(_, comp_variant(_)) { \"enum content\" }\n           cat_comp(_, comp_index(t, _)) {\n             alt ty::get(t).struct {\n@@ -530,7 +527,7 @@ impl to_str_methods for borrowck_ctxt {\n // mutable structure.\n fn inherent_mutability(ck: comp_kind) -> mutability {\n     alt ck {\n-      comp_tuple | comp_res | comp_variant(_) {m_imm}\n+      comp_tuple | comp_variant(_)        {m_imm}\n       comp_field(_, m) | comp_index(_, m) {m}\n     }\n }"}, {"sha": "9e8ac411a1ff406b933d802e021b9c6d7aaf365f", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -71,10 +71,6 @@ fn opt_deref_kind(t: ty::t) -> option<deref_kind> {\n         some(deref_comp(comp_variant(did)))\n       }\n \n-      ty::ty_res(*) {\n-        some(deref_comp(comp_res))\n-      }\n-\n       ty::ty_evec(mt, ty::vstore_fixed(_)) {\n         some(deref_comp(comp_index(t, mt.mutbl)))\n       }"}, {"sha": "af5055368c831557501c0b1b2033d634bf55cf70", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -532,7 +532,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                   }\n                   visit::fk_anon(*) | visit::fk_fn_block(*) |\n                   visit::fk_method(*) | visit::fk_item_fn(*) |\n-                  visit::fk_res(*) | visit::fk_dtor(*) {\n+                  visit::fk_dtor(*) {\n                     self.in_ctor = false;\n                     self.declared_purity = decl.purity;\n                     self.fn_args = @decl.inputs.map({|i| i.id});"}, {"sha": "84f7f5a9d1597eae1afeb5164415174b7043a372", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -57,8 +57,7 @@ impl loan_methods for loan_ctxt {\n           }\n           cat_comp(cmt_base, comp_field(*)) |\n           cat_comp(cmt_base, comp_index(*)) |\n-          cat_comp(cmt_base, comp_tuple) |\n-          cat_comp(cmt_base, comp_res) {\n+          cat_comp(cmt_base, comp_tuple) {\n             // For most components, the type of the embedded data is\n             // stable.  Therefore, the base structure need only be\n             // const---unless the component must be immutable.  In"}, {"sha": "7ec2520cd59d2c3db19d591cfece6d1ba7e1e84c", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -43,8 +43,7 @@ impl public_methods for borrowck_ctxt {\n           }\n           cat_comp(cmt_base, comp_field(*)) |\n           cat_comp(cmt_base, comp_index(*)) |\n-          cat_comp(cmt_base, comp_tuple) |\n-          cat_comp(cmt_base, comp_res) {\n+          cat_comp(cmt_base, comp_tuple) {\n             // Most embedded components: if the base is stable, the\n             // type never changes.\n             self.preserve(cmt_base, opt_scope_id)"}, {"sha": "465799c850c6983828a88b422dc21fd7703e181e", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -22,8 +22,8 @@ import lint::{non_implicitly_copyable_typarams,implicit_copies};\n //  const: Things thare are deeply immutable. They are guaranteed never to\n //    change, and can be safely shared without copying between tasks.\n //\n-// Send includes scalar types, resources and unique types containing only\n-// sendable types.\n+// Send includes scalar types as well as classes and unique types containing\n+// only sendable types.\n //\n // Copy includes boxes, closure and unique types containing copyable types.\n //\n@@ -160,7 +160,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n         let cap_clause = alt fk {\n           visit::fk_anon(_, cc) | visit::fk_fn_block(cc) { cc }\n           visit::fk_item_fn(*) | visit::fk_method(*) |\n-          visit::fk_res(*) | visit::fk_ctor(*) | visit::fk_dtor(*) { @[] }\n+          visit::fk_ctor(*) | visit::fk_dtor(*) { @[] }\n         };\n         let captured_vars = (*cap_clause).map { |cap_item|\n             let cap_def = cx.tcx.def_map.get(cap_item.id);"}, {"sha": "e17343a0b9eddc92c2d110308feca56a30110e6e", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -359,7 +359,7 @@ fn resolve_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n               visitor: visit::vt<ctxt>) {\n \n     let fn_cx = alt fk {\n-      visit::fk_item_fn(*) | visit::fk_method(*) | visit::fk_res(*) |\n+      visit::fk_item_fn(*) | visit::fk_method(*) |\n       visit::fk_ctor(*) | visit::fk_dtor(*) {\n         // Top-level functions are a root scope.\n         {parent: some(id) with cx}"}, {"sha": "b693d83e19367e045807c18ec08e71eebb02bf10", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -639,9 +639,8 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n     // for f's constrs in the table.\n     for decl.constraints.each {|c| resolve_constr(e, c, sc, v); }\n     let scope = alt fk {\n-      visit::fk_item_fn(_, tps) | visit::fk_res(_, tps, _) |\n-      visit::fk_method(_, tps, _) | visit::fk_ctor(_, tps, _, _)  |\n-      visit::fk_dtor(tps, _, _) {\n+      visit::fk_item_fn(_, tps) | visit::fk_method(_, tps, _)\n+      | visit::fk_ctor(_, tps, _, _) | visit::fk_dtor(tps, _, _) {\n         scope_bare_fn(decl, id, tps) }\n       visit::fk_anon(ast::proto_bare, _) {\n         scope_bare_fn(decl, id, []) }\n@@ -1333,15 +1332,6 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n       ast::item_ty(*) | item_iface(*) | item_enum(*) {\n         if ns == ns_type { ret some(ast::def_ty(local_def(i.id))); }\n       }\n-      ast::item_res(_, _, _, _, ctor_id, _) {\n-        alt ns {\n-          ns_val {\n-            ret some(ast::def_fn(local_def(ctor_id), ast::impure_fn));\n-          }\n-          ns_type { ret some(ast::def_ty(local_def(i.id))); }\n-          _ { }\n-        }\n-      }\n       ast::item_class(_, _, _members, ct, _, _) {\n           alt ns {\n              ns_type {\n@@ -1644,7 +1634,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n         alt it.node {\n           ast::item_const(_, _) | ast::item_fn(_, _, _) | ast::item_mod(_) |\n           ast::item_native_mod(_) | ast::item_ty(_, _, _) |\n-          ast::item_res(*) | ast::item_impl(*) | ast::item_iface(*) {\n+          ast::item_impl(*) | ast::item_iface(*) {\n             add_to_index(index, it.ident, mie_item(it));\n           }\n           ast::item_enum(variants, _, _) {\n@@ -1868,10 +1858,6 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n                   ast::item_ty(*) | ast::item_iface(*) {\n                     add_name(types, it.span, it.ident);\n                   }\n-                  ast::item_res(*) {\n-                    add_name(types, it.span, it.ident);\n-                    add_name(values, it.span, it.ident);\n-                  }\n                   _ { }\n                 }\n               }"}, {"sha": "13201d4e6735aa571cf17724a4a05fe24d648194", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 33, "deletions": 169, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -50,7 +50,7 @@ import type_of::type_of; // Issue #1873\n import syntax::ast_map::{path, path_mod, path_name};\n \n import std::smallintmap;\n-import option::is_none;\n+import option::{is_none, is_some};\n \n // Destinations\n \n@@ -758,8 +758,7 @@ fn trans_class_drop(bcx: block, v0: ValueRef, dtor_did: ast::def_id,\n       // We have to cast v0\n      let classptr = GEPi(bcx, v0, [0u, 1u]);\n      // Find and call the actual destructor\n-     let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, some(class_did),\n-                                  substs.tps);\n+     let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did, class_did, substs.tps);\n      // The second argument is the \"self\" argument for drop\n      let params = lib::llvm::fn_ty_param_tys\n          (llvm::LLVMGetElementType\n@@ -799,9 +798,6 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       ty::ty_unboxed_vec(_) {\n         tvec::make_drop_glue_unboxed(bcx, v0, t)\n       }\n-      ty::ty_res(did, inner, substs) {\n-        trans_res_drop(bcx, v0, did, inner, substs.tps)\n-      }\n       ty::ty_class(did, substs) {\n         let tcx = bcx.tcx();\n         alt ty::ty_dtor(tcx, did) {\n@@ -835,10 +831,7 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n }\n \n fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n-                // Parent ID is an option because resources don't\n-                // have one. We can make this a def_id when\n-                // resources get removed.\n-                opt_id: option<ast::def_id>, substs: [ty::t])\n+                parent_id: ast::def_id, substs: [ty::t])\n    -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"trans_res_dtor\");\n     if (substs.len() > 0u) {\n@@ -850,54 +843,13 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n     } else if did.crate == ast::local_crate {\n         get_item_val(ccx, did.node)\n     } else {\n-        alt opt_id {\n-           some(parent_id) {\n-             let tcx = ccx.tcx;\n-             let name = csearch::get_symbol(ccx.sess.cstore, did);\n-             let class_ty = ty::subst_tps(tcx, substs,\n-                              ty::lookup_item_type(tcx, parent_id).ty);\n-             let llty = type_of_dtor(ccx, class_ty);\n-             get_extern_fn(ccx.externs, ccx.llmod, name, lib::llvm::CCallConv,\n-                           llty)\n-           }\n-           none {\n-             let fty = ty::mk_fn(ccx.tcx, {purity: ast::impure_fn,\n-                                       proto: ast::proto_bare,\n-                                     inputs: [{mode: ast::expl(ast::by_ref),\n-                                                ty: ty::mk_nil_ptr(ccx.tcx)}],\n-                                      output: ty::mk_nil(ccx.tcx),\n-                                      ret_style: ast::return_val,\n-                                      constraints: []});\n-             trans_external_path(ccx, did, fty)\n-           }\n-      }\n-    }\n-}\n-\n-fn trans_res_drop(bcx: block, rs: ValueRef, did: ast::def_id,\n-                  inner_t: ty::t, tps: [ty::t]) -> block {\n-    let _icx = bcx.insn_ctxt(\"trans_res_drop\");\n-    let ccx = bcx.ccx();\n-    let inner_t_s = ty::subst_tps(ccx.tcx, tps, inner_t);\n-\n-    let drop_flag = GEPi(bcx, rs, [0u, 0u]);\n-    with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) {|bcx|\n-        let valptr = GEPi(bcx, rs, [0u, 1u]);\n-        // Find and call the actual destructor.\n-        let dtor_addr = get_res_dtor(ccx, did, none, tps);\n-        let args = [bcx.fcx.llretptr, null_env_ptr(bcx)];\n-        // Kludge to work around the fact that we know the precise type of the\n-        // value here, but the dtor expects a type that might have opaque\n-        // boxes and such.\n-        let val_llty = lib::llvm::fn_ty_param_tys\n-            (llvm::LLVMGetElementType\n-             (llvm::LLVMTypeOf(dtor_addr)))[args.len()];\n-        let val_cast = BitCast(bcx, valptr, val_llty);\n-        Call(bcx, dtor_addr, args + [val_cast]);\n-\n-        let bcx = drop_ty(bcx, valptr, inner_t_s);\n-        Store(bcx, C_u8(0u), drop_flag);\n-        bcx\n+        let tcx = ccx.tcx;\n+        let name = csearch::get_symbol(ccx.sess.cstore, did);\n+        let class_ty = ty::subst_tps(tcx, substs,\n+                          ty::lookup_item_type(tcx, parent_id).ty);\n+        let llty = type_of_dtor(ccx, class_ty);\n+        get_extern_fn(ccx.externs, ccx.llmod, name, lib::llvm::CCallConv,\n+                      llty)\n     }\n }\n \n@@ -1086,12 +1038,6 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n             cx = f(cx, llfld_a, arg);\n         }\n       }\n-      ty::ty_res(_, inner, substs) {\n-        let tcx = cx.tcx();\n-        let inner1 = ty::subst(tcx, substs, inner);\n-        let llfld_a = GEPi(cx, av, [0u, 1u]);\n-        ret f(cx, llfld_a, inner1);\n-      }\n       ty::ty_enum(tid, substs) {\n         let variants = ty::enum_variants(cx.tcx(), tid);\n         let n_variants = (*variants).len();\n@@ -1130,10 +1076,15 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         ret next_cx;\n       }\n       ty::ty_class(did, substs) {\n+          // Take the drop bit into account\n+          let classptr = if is_some(ty::ty_dtor(cx.tcx(), did)) {\n+                  GEPi(cx, av, [0u, 1u])\n+              }\n+          else { av };\n         for vec::eachi(ty::class_items_as_mutable_fields(cx.tcx(), did,\n                                                          substs))\n            {|i, fld|\n-               let llfld_a = GEPi(cx, av, [0u, i]);\n+               let llfld_a = GEPi(cx, classptr, [0u, i]);\n                cx = f(cx, llfld_a, fld.mt.ty);\n            }\n       }\n@@ -1895,10 +1846,6 @@ fn autoderef(cx: block, e_id: ast::node_id,\n             t1 = mt.ty;\n             v1 = v;\n           }\n-          ty::ty_res(did, inner, substs) {\n-            t1 = ty::subst(ccx.tcx, substs, inner);\n-            v1 = GEPi(cx, v1, [0u, 1u]);\n-          }\n           ty::ty_enum(did, substs) {\n             let variants = ty::enum_variants(ccx.tcx, did);\n             if (*variants).len() != 1u || variants[0].args.len() != 1u {\n@@ -2221,15 +2168,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n         crate?)\", fn_id)});\n     // Get the path so that we can create a symbol\n     let (pt, name, span) = alt map_node {\n-      ast_map::node_item(i, pt) {\n-        alt i.node {\n-          ast::item_res(_, _, _, dtor_id, _, _) {\n-            item_ty = ty::node_id_to_type(ccx.tcx, dtor_id);\n-          }\n-          _ {}\n-        }\n-        (pt, i.ident, i.span)\n-      }\n+      ast_map::node_item(i, pt) { (pt, i.ident, i.span) }\n       ast_map::node_variant(v, enm, pt) { (pt, v.node.name, enm.span) }\n       ast_map::node_method(m, _, pt) { (pt, m.ident, m.span) }\n       ast_map::node_native_item(i, ast::native_abi_rust_intrinsic, pt)\n@@ -2239,9 +2178,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n         ret {val: get_item_val(ccx, fn_id.node),\n              must_cast: true};\n       }\n-      ast_map::node_ctor(nm, _, ct, pt) { (pt, nm, alt ct {\n-                  ast_map::res_ctor(_, _, sp) { sp }\n-                  ast_map::class_ctor(ct_, _) { ct_.span }}) }\n+      ast_map::node_ctor(nm, _, ct, _, pt) { (pt, nm, ct.span) }\n       ast_map::node_dtor(_, dtor, _, pt) {(pt, @\"drop\", dtor.span)}\n       ast_map::node_expr(*) { ccx.tcx.sess.bug(\"Can't monomorphize an expr\") }\n       ast_map::node_export(*) {\n@@ -2285,12 +2222,6 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n         trans_fn(ccx, pt, decl, body, d, no_self, psubsts, fn_id.node);\n         d\n       }\n-      ast_map::node_item(\n-          @{node: ast::item_res(dt, _, body, d_id, _, _), _}, _) {\n-          let d = mk_lldecl();\n-          trans_fn(ccx, pt, dt, body, d, no_self, psubsts, d_id);\n-          d\n-      }\n       ast_map::node_item(*) {\n           ccx.tcx.sess.bug(\"Can't monomorphize this kind of item\")\n       }\n@@ -2319,24 +2250,15 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n                  impl_self(selfty), psubsts, fn_id.node);\n         d\n       }\n-      ast_map::node_ctor(nm, tps, ct, _) {\n+      ast_map::node_ctor(nm, tps, ctor, parent_id, _) {\n+        // ctors don't have attrs, at least not right now\n         let d = mk_lldecl();\n-        alt ct {\n-          ast_map::res_ctor(decl,_, _) {\n-            set_inline_hint(d);\n-            trans_res_ctor(ccx, pt, decl, fn_id.node, psubsts, d);\n-            d\n-          }\n-          ast_map::class_ctor(ctor, parent_id) {\n-            // ctors don't have attrs, at least not right now\n-            let tp_tys: [ty::t] = ty::ty_params_to_tys(ccx.tcx, tps);\n-            trans_class_ctor(ccx, pt, ctor.node.dec, ctor.node.body, d,\n-                 option::get_default(psubsts,\n-                   {tys:tp_tys, vtables: none, bounds: @[]}),\n-              fn_id.node, parent_id, ctor.span);\n-            d\n-          }\n-        }\n+        let tp_tys: [ty::t] = ty::ty_params_to_tys(ccx.tcx, tps);\n+        trans_class_ctor(ccx, pt, ctor.node.dec, ctor.node.body, d,\n+               option::get_default(psubsts,\n+                        {tys:tp_tys, vtables: none, bounds: @[]}),\n+                         fn_id.node, parent_id, ctor.span);\n+        d\n       }\n       ast_map::node_dtor(_, dtor, _, pt) {\n         let parent_id = alt ty::ty_to_def_id(ty::node_id_to_type(ccx.tcx,\n@@ -2412,9 +2334,6 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n                     ccx.external.insert(there.id, some(here.id.node));\n                 }\n               }\n-              ast::item_res(_, _, _, _, ctor_id, _) {\n-                my_id = ctor_id;\n-              }\n             }\n             trans_item(ccx, *item);\n             local_def(my_id)\n@@ -2639,8 +2558,13 @@ fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n        _ { bcx.tcx().sess.span_bug(sp, \"trans_rec_field:\\\n                  base expr has non-record type\"); }\n     };\n+    // seems wrong? Doesn't take into account the field\n+    // sizes\n+\n     let ix = field_idx_strict(bcx.tcx(), sp, field, fields);\n \n+    #debug(\"val = %s ix = %u\", bcx.val_str(val), ix);\n+\n     /* self is a class with a dtor, which means we\n        have to select out the object itself\n        (If any other code does the same thing, that's\n@@ -2789,9 +2713,6 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n                 let non_gc_val = non_gc_box_cast(sub.bcx, sub.val);\n                 GEPi(sub.bcx, non_gc_val, [0u, abi::box_field_body])\n               }\n-              ty::ty_res(_, _, _) {\n-                GEPi(sub.bcx, sub.val, [0u, 1u])\n-              }\n               ty::ty_enum(_, _) {\n                 let ety = expr_ty(cx, e);\n                 let ellty = T_ptr(type_of(ccx, ety));\n@@ -4683,34 +4604,6 @@ fn trans_fn(ccx: @crate_ctxt,\n     }\n }\n \n-fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n-                  ctor_id: ast::node_id,\n-                  param_substs: option<param_substs>, llfndecl: ValueRef) {\n-    let _icx = ccx.insn_ctxt(\"trans_res_ctor\");\n-    // Create a function for the constructor\n-    let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, ctor_id, param_substs,\n-                               none);\n-    create_llargs_for_fn_args(fcx, no_self, dtor.inputs);\n-    let mut bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n-    let fty = node_id_type(bcx, ctor_id);\n-    let arg_t = ty::ty_fn_args(fty)[0].ty;\n-    let arg = alt fcx.llargs.find(dtor.inputs[0].id) {\n-      some(local_mem(x)) { x }\n-      _ { ccx.sess.bug(\"Someone forgot to document an invariant \\\n-            in trans_res_ctor\"); }\n-    };\n-    let llretptr = fcx.llretptr;\n-\n-    let dst = GEPi(bcx, llretptr, [0u, 1u]);\n-    memmove_ty(bcx, dst, arg, arg_t);\n-    let flag = GEPi(bcx, llretptr, [0u, 0u]);\n-    let one = C_u8(1u);\n-    Store(bcx, one, flag);\n-    build_return(bcx);\n-    finish_fn(fcx, lltop);\n-}\n-\n-\n fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n                       variant: ast::variant, disr: int, is_degen: bool,\n                       param_substs: option<param_substs>,\n@@ -5029,16 +4922,6 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n       ast::item_impl(tps, _rp, _, _, ms) {\n         impl::trans_impl(ccx, *path, item.ident, ms, tps);\n       }\n-      ast::item_res(decl, tps, body, dtor_id, ctor_id, _) {\n-        if tps.len() == 0u {\n-            let llctor_decl = get_item_val(ccx, ctor_id);\n-            trans_res_ctor(ccx, *path, decl, ctor_id, none, llctor_decl);\n-\n-            let lldtor_decl = get_item_val(ccx, item.id);\n-            trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n-                     lldtor_decl, no_self, none, dtor_id);\n-        }\n-      }\n       ast::item_mod(m) {\n         trans_mod(ccx, m);\n       }\n@@ -5293,16 +5176,6 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                 set_inline_hint_if_appr(i.attrs, llfn);\n                 llfn\n               }\n-              ast::item_res(_, _, _, dtor_id, _, _) {\n-                // Note that the destructor is associated with the item's id,\n-                // not the dtor_id. This is a bit counter-intuitive, but\n-                // simplifies ty_res, which would have to carry around two\n-                // def_ids otherwise -- one to identify the type, and one to\n-                // find the dtor symbol.\n-                let t = ty::node_id_to_type(ccx.tcx, dtor_id);\n-                register_fn_full(ccx, i.span, my_path + [path_name(@\"dtor\")],\n-                                 i.id, t)\n-              }\n             }\n           }\n           ast_map::node_method(m, impl_id, pth) {\n@@ -5318,18 +5191,9 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n             exprt = true;\n             register_fn(ccx, ni.span, *pth + [path_name(ni.ident)], ni.id)\n           }\n-          ast_map::node_ctor(nm, tps, ct, pt) {\n+          ast_map::node_ctor(nm, tps, ctor, _, pt) {\n             let my_path = *pt + [path_name(nm)];\n-            alt ct {\n-              ast_map::res_ctor(_,_,sp) {\n-                let llctor = register_fn(ccx, sp, my_path, id);\n-                set_inline_hint(llctor);\n-                llctor\n-              }\n-              ast_map::class_ctor(ctor, _) {\n-                register_fn(ccx, ctor.span, my_path, ctor.node.id)\n-              }\n-            }\n+            register_fn(ccx, ctor.span, my_path, ctor.node.id)\n           }\n           ast_map::node_dtor(tps, dt, parent_id, pt) {\n             /*"}, {"sha": "48a087d0c279a6adf67fbb41da0a05919b190ee5", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -743,7 +743,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let (ident, ret_ty, id) = alt cx.tcx.items.get(fcx.id) {\n       ast_map::node_item(item, _) {\n         alt item.node {\n-          ast::item_fn(decl, _, _) | ast::item_res(decl, _, _, _, _, _) {\n+          ast::item_fn(decl, _, _) {\n             (item.ident, decl.output, item.id)\n           }\n           _ { fcx.ccx.sess.span_bug(item.span, \"create_function: item \\\n@@ -753,16 +753,9 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n       ast_map::node_method(method, _, _) {\n           (method.ident, method.decl.output, method.id)\n       }\n-      ast_map::node_ctor(nm, _, ct, _) {\n-        alt ct {\n-          ast_map::res_ctor(decl, ctor_id, _) {\n-            (nm, decl.output, ctor_id)\n-          }\n-          ast_map::class_ctor(ctor,_) {\n-            // FIXME: output type may be wrong (#2194)\n-            (nm, ctor.node.dec.output, ctor.node.id)\n-          }\n-        }\n+      ast_map::node_ctor(nm, _, ctor, _, _) {\n+        // FIXME: output type may be wrong (#2194)\n+        (nm, ctor.node.dec.output, ctor.node.id)\n       }\n       ast_map::node_expr(expr) {\n         alt expr.node {"}, {"sha": "86da0c72eccd6ce40751eef1dae274927f9ca7aa", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -69,8 +69,8 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n       ast_map::node_method(_, impl_id, _) { traverse_def_id(cx, impl_id); }\n       ast_map::node_native_item(item, _, _) { cx.rmap.insert(item.id, ()); }\n       ast_map::node_variant(v, _, _) { cx.rmap.insert(v.node.id, ()); }\n-      // If it's a class ctor, consider the parent reachable\n-      ast_map::node_ctor(_, _, ast_map::class_ctor(_, parent_id), _) {\n+      // If it's a ctor, consider the parent reachable\n+      ast_map::node_ctor(_, _, _, parent_id, _) {\n         traverse_def_id(cx, parent_id);\n       }\n       _ {}\n@@ -94,10 +94,6 @@ fn traverse_public_item(cx: ctx, item: @item) {\n               for vec::each(nm.items) {|item| cx.rmap.insert(item.id, ()); }\n           }\n       }\n-      item_res(_, tps, blk, _, _, _) {\n-        // resources seem to be unconditionally inlined\n-        traverse_inline_body(cx, blk);\n-      }\n       item_fn(_, tps, blk) {\n         if tps.len() > 0u ||\n            attr::find_inline_attr(item.attrs) != attr::ia_none {\n@@ -209,10 +205,6 @@ fn traverse_all_resources(cx: ctx, crate_mod: _mod) {\n         visit_item: {|i, cx, v|\n             visit::visit_item(i, cx, v);\n             alt i.node {\n-              item_res(*) {\n-                traverse_public_item(cx, i);\n-              }\n-              // Classes with dtors too!\n               item_class(_, _, _, _, some(_), _) {\n                 traverse_public_item(cx, i);\n               }"}, {"sha": "0ca89ac6a94e9b544a354f508377f15c75a20504", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -255,7 +255,6 @@ impl methods for reflector {\n \n           // Miscallaneous extra types\n           ty::ty_iface(_, _) { self.leaf(\"iface\") }\n-          ty::ty_res(_, t, _) { self.bracketed_t(\"res\", t, []) }\n           ty::ty_var(_) { self.leaf(\"var\") }\n           ty::ty_var_integral(_) { self.leaf(\"var_integral\") }\n           ty::ty_param(n, _) { self.visit(\"param\", [self.c_uint(n)]) }"}, {"sha": "d7e7020f20d574652659c4adc44f8f1be9cec639", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -335,7 +335,6 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n             [shape_res]\n           }\n           else { [shape_struct] };\n-        let mut sub = [];\n         option::iter(m_dtor_did) {|dtor_did|\n           let ri = @{did: dtor_did, parent_id: some(did), tps: tps};\n           let id = interner::intern(ccx.shape_cx.resources, ri);\n@@ -346,35 +345,15 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n           add_u16(s, 0_u16);\n         };\n         for ty::class_items_as_mutable_fields(ccx.tcx, did, substs).each {|f|\n-            sub += shape_of(ccx, f.mt.ty);\n+           add_substr(s, shape_of(ccx, f.mt.ty));\n         }\n-        add_substr(s, sub);\n         s\n       }\n       ty::ty_rptr(_, mt) {\n         let mut s = [shape_rptr];\n         add_substr(s, shape_of(ccx, mt.ty));\n         s\n       }\n-      ty::ty_res(did, raw_subt, substs) {\n-        #debug[\"ty_res(%?, %?, %?)\",\n-               did,\n-               ty_to_str(ccx.tcx, raw_subt),\n-               substs.tps.map({|t| ty_to_str(ccx.tcx, t) })];\n-        for substs.tps.each() {|t| assert !ty::type_has_params(t); }\n-        let subt = ty::subst(ccx.tcx, substs, raw_subt);\n-        let tps = substs.tps;\n-        let ri = @{did: did, parent_id: none, tps: tps};\n-        let id = interner::intern(ccx.shape_cx.resources, ri);\n-\n-        let mut s = [shape_res];\n-        add_u16(s, id as u16);\n-        // Hack: always encode 0 tps, since the shape glue format\n-        // hasn't changed since we started monomorphizing.\n-        add_u16(s, 0_u16);\n-        add_substr(s, shape_of(ccx, subt));\n-        s\n-      }\n       ty::ty_param(*) {\n         ccx.tcx.sess.bug(\"non-monomorphized type parameter\");\n       }\n@@ -599,8 +578,9 @@ fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n     for uint::range(0u, len) {|i|\n         let ri = interner::get(ccx.shape_cx.resources, i);\n         for ri.tps.each() {|s| assert !ty::type_has_params(s); }\n-        dtors += [trans::base::get_res_dtor(ccx, ri.did, ri.parent_id,\n-                                            ri.tps)];\n+        option::iter(ri.parent_id) {|id|\n+            dtors += [trans::base::get_res_dtor(ccx, ri.did, id, ri.tps)];\n+        }\n     }\n     ret mk_global(ccx, \"resource_shapes\", C_struct(dtors), true);\n }\n@@ -744,10 +724,6 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n           ty::ty_estr(ty::vstore_uniq) | ty::ty_estr(ty::vstore_box) |\n           ty::ty_ptr(_) | ty::ty_rptr(_,_) { nilptr(tcx) }\n           ty::ty_fn(_) { ty::mk_tup(tcx, [nilptr(tcx), nilptr(tcx)]) }\n-          ty::ty_res(_, sub, substs) {\n-            let sub1 = ty::subst(tcx, substs, sub);\n-            ty::mk_tup(tcx, [ty::mk_int(tcx), simplify_type(tcx, sub1)])\n-          }\n           ty::ty_evec(_, ty::vstore_slice(_)) |\n           ty::ty_estr(ty::vstore_slice(_)) {\n             ty::mk_tup(tcx, [nilptr(tcx), ty::mk_int(tcx)])"}, {"sha": "2b610a996621d8e67a69fa4537728da60efb13a1", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -141,10 +141,6 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n           }\n           ty::ty_fn(_) { T_fn_pair(cx, type_of_fn_from_ty(cx, t)) }\n           ty::ty_iface(_, _) { T_opaque_iface(cx) }\n-          ty::ty_res(_, sub, substs) {\n-            let sub1 = ty::subst(cx.tcx, substs, sub);\n-            ret T_struct([T_i8(), type_of(cx, sub1)]);\n-          }\n           ty::ty_type { T_ptr(cx.tydesc_type) }\n           ty::ty_tup(elts) {\n             let mut tys = [];"}, {"sha": "fb0b983ae65c71bbdb90ac96e9468e9b22fce3ad", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -66,11 +66,9 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     };\n     alt check map_node {\n       ast_map::node_item(@{node: item_fn(_, _, body), _}, _) |\n-      ast_map::node_item(@{node: item_res(_, _, body, _, _, _), _}, _) |\n       ast_map::node_method(@{body, _}, _, _) {\n         handle_body(cx, body);\n       }\n-      ast_map::node_ctor(_, _, ast_map::res_ctor(_, _, _), _) |\n       ast_map::node_variant(_, _, _) {\n         for uint::range(0u, n_tps) {|n| cx.uses[n] |= use_repr;}\n       }\n@@ -88,7 +86,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n             for uint::range(0u, n_tps) {|n| cx.uses[n] |= flags;}\n         }\n       }\n-      ast_map::node_ctor(_, _, ast_map::class_ctor(ctor, _), _){\n+      ast_map::node_ctor(_, _, ctor, _, _){\n         handle_body(cx, ctor.node.body);\n       }\n       ast_map::node_dtor(_, dtor, _, _){"}, {"sha": "aa7a3d6e344400d83231ed8ad654d77bff654a4b", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -49,14 +49,6 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n       item_mod(m) { find_pre_post_mod(m); }\n       item_native_mod(nm) { find_pre_post_native_mod(nm); }\n       item_ty(*) | item_enum(*) | item_iface(*) { ret; }\n-      item_res(_, _, body, dtor_id, _, _) {\n-        let fcx =\n-            {enclosing: ccx.fm.get(dtor_id),\n-             id: dtor_id,\n-             name: i.ident,\n-             ccx: ccx};\n-        find_pre_post_fn(fcx, body);\n-      }\n       item_class(*) {\n           fail \"find_pre_post_item: shouldn't be called on item_class\";\n       }"}, {"sha": "1c0f5ed053c563e597607b200df9bbe2c4eb1584", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 62, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -93,7 +93,6 @@ export ty_unboxed_vec, mk_unboxed_vec, mk_mut_unboxed_vec;\n export vstore, vstore_fixed, vstore_uniq, vstore_box, vstore_slice;\n export ty_nil, mk_nil, type_is_nil;\n export ty_iface, mk_iface;\n-export ty_res, mk_res;\n export ty_param, mk_param, ty_params_to_tys;\n export ty_ptr, mk_ptr, mk_mut_ptr, mk_imm_ptr, mk_nil_ptr, type_is_unsafe_ptr;\n export ty_rptr, mk_rptr;\n@@ -366,7 +365,6 @@ enum sty {\n     ty_fn(fn_ty),\n     ty_iface(def_id, substs),\n     ty_class(def_id, substs),\n-    ty_res(def_id, t, substs),\n     ty_tup([t]),\n \n     ty_var(tv_vid), // type variable during typechecking\n@@ -598,11 +596,6 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n         for f.inputs.each {|a| flags |= get(a.ty).flags; }\n         flags |= get(f.output).flags;\n       }\n-      ty_res(_, tt, substs) {\n-        flags |= (has_resources as uint);\n-        flags |= get(tt).flags;\n-        flags |= sflags(substs);\n-      }\n       ty_constr(tt, _) {\n         flags |= get(tt).flags;\n       }\n@@ -716,11 +709,6 @@ fn mk_class(cx: ctxt, class_id: ast::def_id, substs: substs) -> t {\n     mk_t(cx, ty_class(class_id, substs))\n }\n \n-fn mk_res(cx: ctxt, did: ast::def_id,\n-          inner: t, substs: substs) -> t {\n-    mk_t(cx, ty_res(did, inner, substs))\n-}\n-\n fn mk_var(cx: ctxt, v: tv_vid) -> t { mk_t(cx, ty_var(v)) }\n \n fn mk_var_integral(cx: ctxt, v: tvi_vid) -> t {\n@@ -795,10 +783,6 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n         for ft.inputs.each {|a| maybe_walk_ty(a.ty, f); }\n         maybe_walk_ty(ft.output, f);\n       }\n-      ty_res(_, sub, substs) {\n-        maybe_walk_ty(sub, f);\n-        for substs.tps.each {|tp| maybe_walk_ty(tp, f); }\n-      }\n       ty_constr(sub, _) { maybe_walk_ty(sub, f); }\n       ty_uniq(tm) { maybe_walk_ty(tm.ty, f); }\n     }\n@@ -860,10 +844,6 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n         let new_output = fldop(f.output);\n         ty_fn({inputs: new_args, output: new_output with f})\n       }\n-      ty_res(did, subty, substs) {\n-        ty_res(did, fldop(subty),\n-               fold_substs(substs, fldop))\n-      }\n       ty_rptr(r, tm) {\n         ty_rptr(r, {ty: fldop(tm.ty), mutbl: tm.mutbl})\n       }\n@@ -944,10 +924,6 @@ fn fold_regions_and_ty(\n       ty_iface(def_id, substs) {\n         ty::mk_iface(cx, def_id, fold_substs(substs, fldr, fldt))\n       }\n-      ty_res(def_id, t, substs) {\n-        ty::mk_res(cx, def_id, fldt(t),\n-                   fold_substs(substs, fldr, fldt))\n-      }\n       sty @ ty_fn(_) {\n         fold_sty_to_ty(cx, sty) {|t|\n             fldfnt(t)\n@@ -1100,8 +1076,8 @@ fn type_is_bool(ty: t) -> bool { get(ty).struct == ty_bool }\n \n fn type_is_structural(ty: t) -> bool {\n     alt get(ty).struct {\n-      ty_rec(_) | ty_class(_, _) | ty_tup(_) | ty_enum(_, _) | ty_fn(_) |\n-      ty_iface(_, _) | ty_res(_, _, _) | ty_evec(_, vstore_fixed(_))\n+      ty_rec(_) | ty_class(*) | ty_tup(_) | ty_enum(*) | ty_fn(_) |\n+      ty_iface(*) | ty_evec(_, vstore_fixed(_))\n       | ty_estr(vstore_fixed(_)) { true }\n       _ { false }\n     }\n@@ -1318,7 +1294,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n             }\n             !needs_unwind_cleanup\n           }\n-          ty_uniq(_) | ty_str | ty_vec(_) | ty_res(_, _, _) |\n+          ty_uniq(_) | ty_str | ty_vec(_) |\n           ty_estr(vstore_uniq) |\n           ty_estr(vstore_box) |\n           ty_evec(_, vstore_uniq) |\n@@ -1605,10 +1581,6 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         }\n         lowest\n       }\n-      ty_res(did, inner, tps) {\n-        let inner = subst(cx, tps, inner);\n-        (kind_const() | kind_send_only()) & type_kind(cx, inner)\n-      }\n       ty_param(_, did) {\n         param_bounds_to_kind(cx.ty_param_bounds.get(did.node))\n       }\n@@ -1713,18 +1685,6 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             r\n           }\n \n-          ty_res(did, _, _) if vec::contains(*seen, did) {\n-            false\n-          }\n-\n-          ty_res(did, sub, substs) {\n-            vec::push(*seen, did);\n-            let sty = subst(cx, substs, sub);\n-            let r = type_requires(cx, seen, r_ty, sty);\n-            vec::pop(*seen);\n-            r\n-          }\n-\n           ty_tup(ts) {\n             vec::any(ts) {|t|\n                 type_requires(cx, seen, r_ty, t)\n@@ -1787,10 +1747,6 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n         }\n         ret false;\n       }\n-      ty_res(_, sub, substs) {\n-        let sty = subst(cx, substs, sub);\n-        ret type_structurally_contains(cx, sty, test);\n-      }\n       ty_evec(mt, vstore_fixed(_)) {\n         ret type_structurally_contains(cx, mt.ty, test);\n       }\n@@ -1895,9 +1851,6 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_evec(mt, vstore_fixed(_)) | ty_unboxed_vec(mt) {\n         result = type_is_pod(cx, mt.ty);\n       }\n-      ty_res(_, inner, substs) {\n-        result = type_is_pod(cx, subst(cx, substs, inner));\n-      }\n       ty_constr(subt, _) { result = type_is_pod(cx, subt); }\n       ty_param(_, _) { result = false; }\n       ty_opaque_closure_ptr(_) { result = true; }\n@@ -1966,11 +1919,6 @@ fn deref_sty(cx: ctxt, sty: sty, expl: bool) -> option<mt> {\n         some(mt)\n       }\n \n-      ty_res(_, inner, substs) {\n-        let inner = subst(cx, substs, inner);\n-        some({ty: inner, mutbl: ast::m_imm})\n-      }\n-\n       ty_enum(did, substs) {\n         let variants = enum_variants(cx, did);\n         if vec::len(*variants) == 1u && vec::len(variants[0].args) == 1u {\n@@ -2111,10 +2059,6 @@ fn hash_type_structure(st: sty) -> uint {\n         h\n       }\n       ty_uniq(mt) { hash_subty(37u, mt.ty) }\n-      ty_res(did, sub, substs) {\n-        let mut h = hash_subty(hash_def(38u, did), sub);\n-        hash_substs(h, substs)\n-      }\n       ty_iface(did, substs) {\n         let mut h = hash_def(40u, did);\n         hash_substs(h, substs)\n@@ -2452,7 +2396,6 @@ fn ty_sort_str(cx: ctxt, t: t) -> str {\n       ty_fn(_) { \"fn\" }\n       ty_iface(id, _) { #fmt[\"iface %s\", item_path_str(cx, id)] }\n       ty_class(id, _) { #fmt[\"class %s\", item_path_str(cx, id)] }\n-      ty_res(id, _, _) { #fmt[\"resource %s\", item_path_str(cx, id)] }\n       ty_tup(_) { \"tuple\" }\n       ty_var(_) { \"variable\" }\n       ty_var_integral(_) { \"integral variable\" }\n@@ -2606,7 +2549,7 @@ fn impl_iface(cx: ctxt, id: ast::def_id) -> option<t> {\n \n fn ty_to_def_id(ty: t) -> option<ast::def_id> {\n     alt get(ty).struct {\n-      ty_iface(id, _) | ty_class(id, _) | ty_res(id, _, _) | ty_enum(id, _) {\n+      ty_iface(id, _) | ty_class(id, _) | ty_enum(id, _) {\n         some(id)\n       }\n       _ { none }\n@@ -2685,7 +2628,7 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n             vec::init(*path) + [ast_map::path_name(variant.node.name)]\n           }\n \n-          ast_map::node_ctor(nm, _, _, path) {\n+          ast_map::node_ctor(nm, _, _, _, path) {\n               *path + [ast_map::path_name(nm)]\n           }\n           ast_map::node_dtor(_, _, _, path) {"}, {"sha": "86d105adb990069ea08571f0971f829f89c54564", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -354,10 +354,6 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       ast::item_fn(decl, tps, body) {\n         check_bare_fn(ccx, decl, body, it.id, none);\n       }\n-      ast::item_res(decl, tps, body, dtor_id, _, rp) {\n-        check_instantiable(ccx.tcx, it.span, it.id);\n-        check_bare_fn(ccx, decl, body, dtor_id, none);\n-      }\n       ast::item_impl(tps, rp, _, ty, ms) {\n         let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n         for ms.each {|m| check_method(ccx, m, self_ty);}"}, {"sha": "ea04fd96b2763adbeabcfc58154abfe045d5c3db", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 50, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -261,11 +261,6 @@ fn convert_class_item(ccx: @crate_ctxt,\n                       rp: ast::region_param,\n                       bounds: @[ty::param_bounds],\n                       v: ast_util::ivar) {\n-    /* we want to do something here, b/c within the\n-    scope of the class, it's ok to refer to fields &\n-    methods unqualified */\n-    /* they have these types *within the scope* of the\n-    class. outside the class, it's done with expr_field */\n     let tt = ccx.to_ty(type_rscope(rp), v.ty);\n     write_ty_to_tcx(ccx.tcx, v.id, tt);\n     /* add the field to the tcache */\n@@ -322,37 +317,6 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n             check_methods_against_iface(ccx, tps, rp, selfty, t, cms);\n         }\n       }\n-      ast::item_res(decl, tps, _, dtor_id, ctor_id, rp) {\n-        let {bounds, substs} = mk_substs(ccx, tps, rp);\n-        let def_id = local_def(it.id);\n-        let t_arg = ty_of_arg(ccx, type_rscope(rp),\n-                                       decl.inputs[0], none);\n-        let t_res = ty::mk_res(tcx, def_id, t_arg.ty, substs);\n-\n-        let t_ctor = ty::mk_fn(tcx, {\n-            purity: ast::pure_fn,\n-            proto: ast::proto_box,\n-            inputs: [{mode: ast::expl(ast::by_copy), ty: t_arg.ty}],\n-            output: t_res,\n-            ret_style: ast::return_val, constraints: []\n-        });\n-        let t_dtor = ty::mk_fn(tcx, {\n-            purity: ast::impure_fn,\n-            proto: ast::proto_box,\n-            inputs: [t_arg], output: ty::mk_nil(tcx),\n-            ret_style: ast::return_val, constraints: []\n-        });\n-        write_ty_to_tcx(tcx, it.id, t_res);\n-        write_ty_to_tcx(tcx, ctor_id, t_ctor);\n-        tcx.tcache.insert(local_def(ctor_id),\n-                          {bounds: bounds,\n-                           rp: rp,\n-                           ty: t_ctor});\n-        tcx.tcache.insert(def_id, {bounds: bounds,\n-                                   rp: rp,\n-                                   ty: t_res});\n-        write_ty_to_tcx(tcx, dtor_id, t_dtor);\n-      }\n       ast::item_iface(*) {\n         let tpt = ty_of_item(ccx, it);\n         #debug[\"item_iface(it.id=%d, tpt.ty=%s)\",\n@@ -366,11 +330,21 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         tcx.tcache.insert(local_def(it.id), tpt);\n         // Write the ctor type\n-        let t_ctor =\n-            ty::mk_fn(\n-                tcx,\n-                ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_any,\n-                              ctor.node.dec, none));\n+        let t_args = ctor.node.dec.inputs.map {|a|\n+                           ty_of_arg(ccx, type_rscope(rp), a, none)};\n+        let t_res = ty::mk_class(tcx, local_def(it.id),\n+                                 {self_r: alt rp {\n+                       ast::rp_none { none }\n+                       ast::rp_self { some(ty::re_bound(ty::br_self)) }\n+                                     },\n+                                  self_ty: none,\n+                                  tps: ty::ty_params_to_tys(tcx, tps)});\n+        let t_ctor = ty::mk_fn(tcx, {purity: ast::impure_fn,\n+              proto: ast::proto_any,\n+              inputs: t_args,\n+              output: t_res,\n+              ret_style: ast::return_val,\n+              constraints: []}); // tjc TODO\n         write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n         tcx.tcache.insert(local_def(ctor.node.id),\n                           {bounds: tpt.bounds,\n@@ -538,15 +512,6 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n-      ast::item_res(decl, tps, _, _, _, rp) {\n-        let {bounds, substs} = mk_substs(ccx, tps, rp);\n-        let t_arg = ty_of_arg(ccx, type_rscope(rp),\n-                                       decl.inputs[0], none);\n-        let t = ty::mk_res(tcx, local_def(it.id), t_arg.ty, substs);\n-        let t_res = {bounds: bounds, rp: rp, ty: t};\n-        tcx.tcache.insert(local_def(it.id), t_res);\n-        ret t_res;\n-      }\n       ast::item_enum(_, tps, rp) {\n         // Create a new generic polytype.\n         let {bounds, substs} = mk_substs(ccx, tps, rp);"}, {"sha": "1225908abb8466a56ef70633577c5923e0ea1ab2", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -1851,16 +1851,6 @@ fn super_tys<C:combine>(\n         }\n       }\n \n-      (ty::ty_res(a_id, a_t, a_substs),\n-       ty::ty_res(b_id, b_t, b_substs))\n-      if a_id == b_id {\n-        self.tys(a_t, b_t).chain {|t|\n-            self.substs(a_substs, b_substs).chain {|substs|\n-                ok(ty::mk_res(tcx, a_id, t, substs))\n-            }\n-        }\n-      }\n-\n       (ty::ty_rec(as), ty::ty_rec(bs)) {\n         if check vec::same_length(as, bs) {\n             map_vec2(as, bs) {|a,b|"}, {"sha": "f44d43d35ede6fa4c038729175b3cbeefd4012b1", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -6,7 +6,7 @@ import middle::ty::{mt, re_bound, re_free, re_scope, re_var, region, t};\n import middle::ty::{ty_bool, ty_bot, ty_box, ty_class, ty_constr, ty_enum};\n import middle::ty::{ty_estr, ty_evec, ty_float, ty_fn, ty_iface, ty_int};\n import middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n-import middle::ty::{ty_ptr, ty_rec, ty_res, ty_rptr, ty_self, ty_str, ty_tup};\n+import middle::ty::{ty_ptr, ty_rec, ty_rptr, ty_self, ty_str, ty_tup};\n import middle::ty::{ty_type, ty_uniq, ty_uint, ty_var, ty_var_integral};\n import middle::ty::{ty_vec, ty_unboxed_vec, vid};\n import metadata::encoder;\n@@ -208,7 +208,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         \"'\" + str::from_bytes([('a' as u8) + (id as u8)])\n       }\n       ty_self { \"self\" }\n-      ty_enum(did, substs) | ty_res(did, _, substs) | ty_class(did, substs) {\n+      ty_enum(did, substs) | ty_class(did, substs) {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path);\n         parameterized(cx, base, substs.self_r, substs.tps)"}, {"sha": "9c700a237200e5d46a055d29b638ddbcd415890f", "filename": "src/rustdoc/demo.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Fdemo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Fdemo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdemo.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -115,8 +115,10 @@ eget ante feugiat tortor congue auctor ac quis ante. Proin\n condimentum lacinia tincidunt.\n \n \"]\n-resource bored(bored: bool) {\n-    log(error, bored);\n+class bored {\n+  let bored: bool;\n+  new(bored: bool) { self.bored = bored; }\n+  drop { log(error, self.bored); }\n }\n \n #[doc = \""}, {"sha": "12ee7e6ca709137f927e2c16db55ecdad11042b4", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -33,7 +33,6 @@ enum itemtag {\n     consttag(constdoc),\n     fntag(fndoc),\n     enumtag(enumdoc),\n-    restag(resdoc),\n     ifacetag(ifacedoc),\n     impltag(impldoc),\n     tytag(tydoc)\n@@ -82,8 +81,6 @@ type variantdoc = {\n     sig: option<str>\n };\n \n-type resdoc = simpleitemdoc;\n-\n type ifacedoc = {\n     item: itemdoc,\n     methods: [methoddoc]\n@@ -192,15 +189,6 @@ impl util for moddoc {\n         }\n     }\n \n-    fn resources() -> [resdoc] {\n-        vec::filter_map(self.items) {|itemtag|\n-            alt itemtag {\n-              restag(resdoc) { some(resdoc) }\n-              _ { none }\n-            }\n-        }\n-    }\n-\n     fn ifaces() -> [ifacedoc] {\n         vec::filter_map(self.items) {|itemtag|\n             alt itemtag {\n@@ -276,15 +264,6 @@ impl util for [page] {\n         }\n     }\n \n-    fn resources() -> [resdoc] {\n-        vec::filter_map(self) {|page|\n-            alt page {\n-              itempage(restag(resdoc)) { some(resdoc) }\n-              _ { none }\n-            }\n-        }\n-    }\n-\n     fn ifaces() -> [ifacedoc] {\n         vec::filter_map(self) {|page|\n             alt page {\n@@ -325,7 +304,6 @@ impl of item for itemtag {\n           doc::fntag(doc) { doc.item }\n           doc::consttag(doc) { doc.item }\n           doc::enumtag(doc) { doc.item }\n-          doc::restag(doc) { doc.item }\n           doc::ifacetag(doc) { doc.item }\n           doc::impltag(doc) { doc.item }\n           doc::tytag(doc) { doc.item }"}, {"sha": "99663adf32ff785cd3cd3e0cb88c37b05ff9f865", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -83,11 +83,6 @@ fn moddoc_from_mod(\n                     enumdoc_from_enum(itemdoc, variants)\n                 ))\n               }\n-              ast::item_res(_, _, _, _, _, _) {\n-                some(doc::restag(\n-                    resdoc_from_resource(itemdoc)\n-                ))\n-              }\n               ast::item_iface(_, _, methods) {\n                 some(doc::ifacetag(\n                     ifacedoc_from_iface(itemdoc, methods)\n@@ -188,20 +183,6 @@ fn should_extract_enum_variants() {\n     assert doc.cratemod().enums()[0].variants[0].name == \"v\";\n }\n \n-fn resdoc_from_resource(itemdoc: doc::itemdoc) -> doc::resdoc {\n-    {\n-        item: itemdoc,\n-        sig: none\n-    }\n-}\n-\n-#[test]\n-fn should_extract_resources() {\n-    let doc = test::mk_doc(\"resource r(b: bool) { }\");\n-    assert doc.cratemod().resources()[0].id() != 0;\n-    assert doc.cratemod().resources()[0].name() == \"r\";\n-}\n-\n fn ifacedoc_from_iface(\n     itemdoc: doc::itemdoc,\n     methods: [ast::ty_method]"}, {"sha": "e502bb7ce417f3eea66496c35c7fe60c2b47d29b", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -8,7 +8,6 @@ export default_seq_fold_nmod;\n export default_seq_fold_fn;\n export default_seq_fold_const;\n export default_seq_fold_enum;\n-export default_seq_fold_res;\n export default_seq_fold_iface;\n export default_seq_fold_impl;\n export default_seq_fold_type;\n@@ -29,7 +28,6 @@ type fold_nmod<T> = fn~(fold: fold<T>, doc: doc::nmoddoc) -> doc::nmoddoc;\n type fold_fn<T> = fn~(fold: fold<T>, doc: doc::fndoc) -> doc::fndoc;\n type fold_const<T> = fn~(fold: fold<T>, doc: doc::constdoc) -> doc::constdoc;\n type fold_enum<T> = fn~(fold: fold<T>, doc: doc::enumdoc) -> doc::enumdoc;\n-type fold_res<T> = fn~(fold: fold<T>, doc: doc::resdoc) -> doc::resdoc;\n type fold_iface<T> = fn~(fold: fold<T>, doc: doc::ifacedoc) -> doc::ifacedoc;\n type fold_impl<T> = fn~(fold: fold<T>, doc: doc::impldoc) -> doc::impldoc;\n type fold_type<T> = fn~(fold: fold<T>, doc: doc::tydoc) -> doc::tydoc;\n@@ -44,7 +42,6 @@ type t<T> = {\n     fold_fn: fold_fn<T>,\n     fold_const: fold_const<T>,\n     fold_enum: fold_enum<T>,\n-    fold_res: fold_res<T>,\n     fold_iface: fold_iface<T>,\n     fold_impl: fold_impl<T>,\n     fold_type: fold_type<T>\n@@ -63,7 +60,6 @@ fn mk_fold<T:copy>(\n     +fold_fn: fold_fn<T>,\n     +fold_const: fold_const<T>,\n     +fold_enum: fold_enum<T>,\n-    +fold_res: fold_res<T>,\n     +fold_iface: fold_iface<T>,\n     +fold_impl: fold_impl<T>,\n     +fold_type: fold_type<T>\n@@ -78,7 +74,6 @@ fn mk_fold<T:copy>(\n         fold_fn: fold_fn,\n         fold_const: fold_const,\n         fold_enum: fold_enum,\n-        fold_res: fold_res,\n         fold_iface: fold_iface,\n         fold_impl: fold_impl,\n         fold_type: fold_type\n@@ -96,7 +91,6 @@ fn default_any_fold<T:send copy>(ctxt: T) -> fold<T> {\n         {|f, d| default_seq_fold_fn(f, d)},\n         {|f, d| default_seq_fold_const(f, d)},\n         {|f, d| default_seq_fold_enum(f, d)},\n-        {|f, d| default_seq_fold_res(f, d)},\n         {|f, d| default_seq_fold_iface(f, d)},\n         {|f, d| default_seq_fold_impl(f, d)},\n         {|f, d| default_seq_fold_type(f, d)}\n@@ -114,7 +108,6 @@ fn default_seq_fold<T:copy>(ctxt: T) -> fold<T> {\n         {|f, d| default_seq_fold_fn(f, d)},\n         {|f, d| default_seq_fold_const(f, d)},\n         {|f, d| default_seq_fold_enum(f, d)},\n-        {|f, d| default_seq_fold_res(f, d)},\n         {|f, d| default_seq_fold_iface(f, d)},\n         {|f, d| default_seq_fold_impl(f, d)},\n         {|f, d| default_seq_fold_type(f, d)}\n@@ -132,7 +125,6 @@ fn default_par_fold<T:send copy>(ctxt: T) -> fold<T> {\n         {|f, d| default_seq_fold_fn(f, d)},\n         {|f, d| default_seq_fold_const(f, d)},\n         {|f, d| default_seq_fold_enum(f, d)},\n-        {|f, d| default_seq_fold_res(f, d)},\n         {|f, d| default_seq_fold_iface(f, d)},\n         {|f, d| default_seq_fold_impl(f, d)},\n         {|f, d| default_seq_fold_type(f, d)}\n@@ -266,9 +258,6 @@ fn fold_itemtag<T>(fold: fold<T>, doc: doc::itemtag) -> doc::itemtag {\n       doc::enumtag(enumdoc) {\n         doc::enumtag(fold.fold_enum(fold, enumdoc))\n       }\n-      doc::restag(resdoc) {\n-        doc::restag(fold.fold_res(fold, resdoc))\n-      }\n       doc::ifacetag(ifacedoc) {\n         doc::ifacetag(fold.fold_iface(fold, ifacedoc))\n       }\n@@ -311,16 +300,6 @@ fn default_seq_fold_enum<T>(\n     }\n }\n \n-fn default_seq_fold_res<T>(\n-    fold: fold<T>,\n-    doc: doc::resdoc\n-) -> doc::resdoc {\n-    {\n-        item: fold.fold_item(fold, doc.item)\n-        with doc\n-    }\n-}\n-\n fn default_seq_fold_iface<T>(\n     fold: fold<T>,\n     doc: doc::ifacedoc"}, {"sha": "ec700b755e794a451ac43d2acc5485ca39e35519", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -198,9 +198,6 @@ fn header_kind(doc: doc::itemtag) -> str {\n       doc::enumtag(_) {\n         \"Enum\"\n       }\n-      doc::restag(_) {\n-        \"Resource\"\n-      }\n       doc::ifacetag(_) {\n         \"Interface\"\n       }\n@@ -352,7 +349,6 @@ fn write_item_(ctxt: ctxt, doc: doc::itemtag, write_header: bool) {\n       doc::fntag(fndoc) { write_fn(ctxt, fndoc) }\n       doc::consttag(constdoc) { write_const(ctxt, constdoc) }\n       doc::enumtag(enumdoc) { write_enum(ctxt, enumdoc) }\n-      doc::restag(resdoc) { write_res(ctxt, resdoc) }\n       doc::ifacetag(ifacedoc) { write_iface(ctxt, ifacedoc) }\n       doc::impltag(impldoc) { write_impl(ctxt, impldoc) }\n       doc::tytag(tydoc) { write_type(ctxt, tydoc) }\n@@ -643,11 +639,6 @@ fn should_write_variant_list_with_signatures() {\n          \\n* `c(int)` - a\\n\\n\");\n }\n \n-fn write_res(ctxt: ctxt, doc: doc::resdoc) {\n-    write_sig(ctxt, doc.sig);\n-    write_common(ctxt, doc.desc(), doc.sections());\n-}\n-\n #[test]\n fn should_write_resource_header() {\n     let markdown = test::render(\"resource r(a: bool) { }\");"}, {"sha": "f0eac40a297f25843ae386ee94c0d36abd4555e1", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -201,19 +201,6 @@ fn should_prune_unexported_variants() {\n     assert vec::len(doc.cratemod().mods()[0].enums()[0].variants) == 0u;\n }\n \n-#[test]\n-fn should_prune_unexported_resources_from_top_mod() {\n-    let doc = test::mk_doc(\"export a; mod a { } resource r(a: bool) { }\");\n-    assert vec::is_empty(doc.cratemod().resources());\n-}\n-\n-#[test]\n-fn should_prune_unexported_resources() {\n-    let doc = test::mk_doc(\n-        \"mod a { export a; mod a { } resource r(a: bool) { } }\");\n-    assert vec::is_empty(doc.cratemod().mods()[0].resources());\n-}\n-\n #[test]\n fn should_prune_unexported_ifaces_from_top_mod() {\n     let doc = test::mk_doc(\"export a; mod a { } iface b { fn c(); }\");"}, {"sha": "54beb0139607db3769f2927825960ff32582736b", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -374,12 +374,6 @@ fn merge_reexports(\n                 with doc\n             })\n           }\n-          doc::restag(doc @ {item, _}) {\n-            doc::restag({\n-                item: reexport(item, name)\n-                with doc\n-            })\n-          }\n           doc::ifacetag(doc @ {item, _}) {\n             doc::ifacetag({\n                 item: reexport(item, name)"}, {"sha": "96c438a0678a3dcab81a57f4eaf8738616ed844b", "filename": "src/rustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_type_pass.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -9,7 +9,6 @@ fn mk_pass() -> pass {\n               doc::consttag(_) { 0 }\n               doc::tytag(_) { 1 }\n               doc::enumtag(_) { 2 }\n-              doc::restag(_) { 3 }\n               doc::ifacetag(_) { 4 }\n               doc::impltag(_) { 5 }\n               doc::fntag(_) { 6 }\n@@ -30,7 +29,6 @@ fn test() {\n          const iconst: int = 0; \\\n          fn ifn() { } \\\n          enum ienum { ivar } \\\n-         resource ires(a: bool) { } \\\n          iface iiface { fn a(); } \\\n          impl iimpl for int { fn a() { } } \\\n          type itype = int;\";\n@@ -40,7 +38,6 @@ fn test() {\n         assert doc.cratemod().items[0].name() == \"iconst\";\n         assert doc.cratemod().items[1].name() == \"itype\";\n         assert doc.cratemod().items[2].name() == \"ienum\";\n-        assert doc.cratemod().items[3].name() == \"ires\";\n         assert doc.cratemod().items[4].name() == \"iiface\";\n         assert doc.cratemod().items[5].name() == \"iimpl\";\n         assert doc.cratemod().items[6].name() == \"ifn\";"}, {"sha": "bbeaf4b9d2fa70641aa670f14779321f8fd5d019", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -114,18 +114,6 @@ fn should_execute_op_on_variant_desc() {\n     assert doc.cratemod().enums()[0].variants[0].desc == some(\"a\");\n }\n \n-#[test]\n-fn should_execute_op_on_resource_brief() {\n-    let doc = test::mk_doc(\"#[doc = \\\" a \\\"] resource r(a: bool) { }\");\n-    assert doc.cratemod().resources()[0].brief() == some(\"a\");\n-}\n-\n-#[test]\n-fn should_execute_op_on_resource_desc() {\n-    let doc = test::mk_doc(\"#[doc = \\\" a \\\"] resource r(a: bool) { }\");\n-    assert doc.cratemod().resources()[0].desc() == some(\"a\");\n-}\n-\n #[test]\n fn should_execute_op_on_iface_brief() {\n     let doc = test::mk_doc("}, {"sha": "e18be9b43012af5f181851978f3aa2d3e82279b1", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -23,7 +23,6 @@ fn run(\n         fold_fn: fold_fn,\n         fold_const: fold_const,\n         fold_enum: fold_enum,\n-        fold_res: fold_res,\n         fold_iface: fold_iface,\n         fold_impl: fold_impl,\n         fold_type: fold_type\n@@ -139,33 +138,6 @@ fn should_add_variant_sigs() {\n     assert doc.cratemod().enums()[0].variants[0].sig == some(\"b(int)\");\n }\n \n-fn fold_res(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::resdoc\n-) -> doc::resdoc {\n-    let srv = fold.ctxt;\n-\n-    {\n-        sig: some(astsrv::exec(srv) {|ctxt|\n-            alt check ctxt.ast_map.get(doc.id()) {\n-              ast_map::node_item(@{\n-                node: ast::item_res(decl, tys, _, _, _, rp), _\n-              }, _) {\n-                pprust::res_to_str(decl, @doc.name(), tys, rp)\n-              }\n-            }\n-        })\n-        with doc\n-    }\n-}\n-\n-#[test]\n-fn should_add_resource_sigs() {\n-    let doc = test::mk_doc(\"resource r<T>(b: bool) { }\");\n-    assert doc.cratemod().resources()[0].sig\n-        == some(\"resource r<T>(b: bool)\");\n-}\n-\n fn fold_iface(\n     fold: fold::fold<astsrv::srv>,\n     doc: doc::ifacedoc"}, {"sha": "fe1482f92e81957415b623dac1a31d934846e5f5", "filename": "src/test/compile-fail/regions-in-rsrcs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Ftest%2Fcompile-fail%2Fregions-in-rsrcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Ftest%2Fcompile-fail%2Fregions-in-rsrcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-rsrcs.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -1,17 +1,17 @@\n class no0 {\n-  let x: &uint;\n+  let x: &uint; //! ERROR to use region types here, the containing type must be declared with a region bound\n   new(x: &uint) { self.x = x; } //! ERROR to use region types here, the containing type must be declared with a region bound\n   drop {}\n }\n \n class no1 {\n-  let x: &self.uint;\n+  let x: &self.uint; //! ERROR to use region types here, the containing type must be declared with a region bound\n   new(x: &self.uint) { self.x = x; } //! ERROR to use region types here, the containing type must be declared with a region bound\n   drop {}\n }\n \n class no2 {\n-  let x: &foo.uint;\n+  let x: &foo.uint; //! ERROR named regions other than `self` are not allowed as part of a type declaration\n   new(x: &foo.uint) { self.x = x; } //! ERROR named regions other than `self` are not allowed as part of a type declaration\n   drop {}\n }\n@@ -29,7 +29,7 @@ class yes1/& {\n }\n \n class yes2/& {\n-  let x: &foo.uint;\n+  let x: &foo.uint; //! ERROR named regions other than `self` are not allowed as part of a type declaration\n   new(x: &foo.uint) { self.x = x; } //! ERROR named regions other than `self` are not allowed as part of a type declaration\n   drop {}\n }"}, {"sha": "a20d18ea61ed349f31fac1d3bdce8b1a6130d4a1", "filename": "src/test/run-pass/resource-cycle.rs", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -1,7 +1,20 @@\n // Don't leak the unique pointers\n \n-resource r(v: *int) unsafe {\n-    let v2: ~int = unsafe::reinterpret_cast(v);\n+class r {\n+  let v: *int;\n+  new(v: *int) unsafe {\n+    self.v = v;\n+    #debug(\"r's ctor: v = %x, self = %x, self.v = %x\",\n+           unsafe::reinterpret_cast::<*int, uint>(v),\n+           unsafe::reinterpret_cast::<*r, uint>(ptr::addr_of(self)),\n+           unsafe::reinterpret_cast::<**int, uint>(ptr::addr_of(self.v)));\n+     }\n+  drop unsafe {\n+    #debug(\"r's dtor: self = %x, self.v = %x, self.v's value = %x\",\n+           unsafe::reinterpret_cast::<*r, uint>(ptr::addr_of(self)),\n+           unsafe::reinterpret_cast::<**int, uint>(ptr::addr_of(self.v)),\n+           unsafe::reinterpret_cast::<*int, uint>(self.v));\n+    let v2: ~int = unsafe::reinterpret_cast(self.v); }\n }\n \n enum t = {\n@@ -19,12 +32,31 @@ fn main() unsafe {\n \n     let x1 = @t({\n         mut next: none,\n-        r: r(i1p)\n+          r: {\n+          let rs = r(i1p);\n+          #debug(\"r = %x\",\n+                 unsafe::reinterpret_cast::<*r, uint>(ptr::addr_of(rs)));\n+          rs }\n     });\n+    \n+    #debug(\"x1 = %x, x1.r = %x\",\n+        unsafe::reinterpret_cast::<@t, uint>(x1),\n+        unsafe::reinterpret_cast::<*r, uint>(ptr::addr_of(x1.r)));\n+\n     let x2 = @t({\n         mut next: none,\n-        r: r(i2p)\n+          r: {\n+          let rs = r(i2p);\n+          #debug(\"r2 = %x\",\n+                 unsafe::reinterpret_cast::<*r, uint>(ptr::addr_of(rs)));\n+          rs\n+            }\n     });\n+    \n+    #debug(\"x2 = %x, x2.r = %x\",\n+           unsafe::reinterpret_cast::<@t, uint>(x2),\n+           unsafe::reinterpret_cast::<*r, uint>(ptr::addr_of(x2.r)));\n+\n     x1.next = some(x2);\n     x2.next = some(x1);\n }"}, {"sha": "4f0f87908cffb06bc7f868e036fc28e4808f980f", "filename": "src/test/run-pass/resource-cycle2.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/487cbf8e906f73589df9501004abeb570b24f121/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/487cbf8e906f73589df9501004abeb570b24f121/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs?ref=487cbf8e906f73589df9501004abeb570b24f121", "patch": "@@ -6,8 +6,12 @@ type u = {\n     c: *int\n };\n \n-resource r(v: u) unsafe {\n-    let v2: ~int = unsafe::reinterpret_cast(v.c);\n+class r {\n+  let v: u;\n+  new(v: u) { self.v = v; }\n+  drop unsafe {\n+    let v2: ~int = unsafe::reinterpret_cast(self.v.c);\n+  }\n }\n \n enum t = {"}]}