{"sha": "728b0182c5ba5e6b98981c523868a23cbaf88719", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyOGIwMTgyYzViYTVlNmI5ODk4MWM1MjM4NjhhMjNjYmFmODg3MTk=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-08T21:13:33Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T03:43:29Z"}, "message": "Changes to chains with block indent\n\n* More often combine a chain item to the previous line (if it is a block)\n* Don't indent if the parent is a block\n\nThis is not perfect and doesn't pass tests, but I need to refactor to make more\nprogress", "tree": {"sha": "2494bb5be69b1c24ebfa8dc2aec869447d321353", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2494bb5be69b1c24ebfa8dc2aec869447d321353"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/728b0182c5ba5e6b98981c523868a23cbaf88719", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/728b0182c5ba5e6b98981c523868a23cbaf88719", "html_url": "https://github.com/rust-lang/rust/commit/728b0182c5ba5e6b98981c523868a23cbaf88719", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/728b0182c5ba5e6b98981c523868a23cbaf88719/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3288841ea86b7ebcff57c840b9a4855f9033ece", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3288841ea86b7ebcff57c840b9a4855f9033ece", "html_url": "https://github.com/rust-lang/rust/commit/d3288841ea86b7ebcff57c840b9a4855f9033ece"}], "stats": {"total": 91, "additions": 64, "deletions": 27}, "files": [{"sha": "44edaa9c34dd4345c60df8ed5ecc5bd3f2f20215", "filename": "src/chains.rs", "status": "modified", "additions": 64, "deletions": 27, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/728b0182c5ba5e6b98981c523868a23cbaf88719/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728b0182c5ba5e6b98981c523868a23cbaf88719/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=728b0182c5ba5e6b98981c523868a23cbaf88719", "patch": "@@ -78,7 +78,6 @@ use utils::{\n \n use std::borrow::Cow;\n use std::cmp::min;\n-use std::iter;\n \n use syntax::codemap::Span;\n use syntax::{ast, ptr};\n@@ -99,8 +98,8 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n     let parent_shape = if is_block_expr(context, &parent, \"\\n\") {\n         match context.config.indent_style() {\n-            IndentStyle::Visual => shape.visual_indent(0),\n             IndentStyle::Block => shape,\n+            IndentStyle::Visual => shape.visual_indent(0),\n         }\n     } else {\n         shape\n@@ -110,18 +109,30 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         .map(|parent_rw| parent_rw + &\"?\".repeat(prefix_try_num))?;\n     let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n     let is_small_parent = shape.offset + parent_rewrite.len() <= context.config.tab_spaces();\n+    let parent_is_block = is_block_expr(context, &parent, &parent_rewrite);\n \n     // Decide how to layout the rest of the chain. `extend` is true if we can\n     // put the first non-parent item on the same line as the parent.\n     let (nested_shape, extend) = if !parent_rewrite_contains_newline && is_continuable(&parent) {\n-        (\n-            chain_indent(context, shape.add_offset(parent_rewrite.len())),\n-            context.config.indent_style() == IndentStyle::Visual || is_small_parent,\n-        )\n-    } else if is_block_expr(context, &parent, &parent_rewrite) {\n+        match context.config.indent_style() {\n+            IndentStyle::Block => {\n+                // TODO this is naive since if the first child is on the same line\n+                // as the parent, then we should look at that, instead of the parent.\n+                // Can we make the parent the first two things then?\n+                let shape = if parent_is_block {\n+                    shape\n+                } else {\n+                    chain_indent(context, shape.add_offset(parent_rewrite.len()))\n+                };\n+                (shape, is_small_parent)\n+            }\n+            // TODO is this right?\n+            IndentStyle::Visual => (chain_indent(context, shape.add_offset(parent_rewrite.len())), true),\n+        }\n+    } else if parent_is_block {\n         match context.config.indent_style() {\n             // Try to put the first child on the same line with parent's last line\n-            IndentStyle::Block => (parent_shape.block_indent(context.config.tab_spaces()), true),\n+            IndentStyle::Block => (parent_shape, true),\n             // The parent is a block, so align the rest of the chain with the closing\n             // brace.\n             IndentStyle::Visual => (parent_shape, false),\n@@ -136,11 +147,21 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     let other_child_shape = nested_shape.with_max_width(context.config);\n \n     let first_child_shape = if extend {\n-        let overhead = last_line_width(&parent_rewrite);\n-        let offset = trimmed_last_line_width(&parent_rewrite) + prefix_try_num;\n         match context.config.indent_style() {\n-            IndentStyle::Visual => parent_shape.offset_left(overhead)?,\n-            IndentStyle::Block => parent_shape.offset_left(offset)?,\n+            IndentStyle::Block => {\n+                let offset = trimmed_last_line_width(&parent_rewrite) + prefix_try_num;\n+                if parent_is_block {\n+                    parent_shape.offset_left(offset)?\n+                } else {\n+                    parent_shape\n+                        .block_indent(context.config.tab_spaces())\n+                        .offset_left(offset)?\n+                }\n+            }\n+            IndentStyle::Visual => {\n+                let overhead = last_line_width(&parent_rewrite);\n+                parent_shape.offset_left(overhead)?\n+            }\n         }\n     } else {\n         other_child_shape\n@@ -150,16 +171,25 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         first_child_shape, other_child_shape\n     );\n \n-    let child_shape_iter = Some(first_child_shape)\n-        .into_iter()\n-        .chain(iter::repeat(other_child_shape));\n     let subexpr_num = subexpr_list.len();\n     let last_subexpr = &subexpr_list[suffix_try_num];\n     let subexpr_list = &subexpr_list[suffix_try_num..subexpr_num - prefix_try_num];\n-    let iter = subexpr_list.iter().skip(1).rev().zip(child_shape_iter);\n-    let mut rewrites = iter\n-        .map(|(e, shape)| rewrite_chain_subexpr(e, total_span, context, shape))\n-        .collect::<Option<Vec<_>>>()?;\n+\n+    let mut rewrites: Vec<String> = Vec::with_capacity(subexpr_list.len());\n+    let mut is_block_like = Vec::with_capacity(subexpr_list.len());\n+    is_block_like.push(true);\n+    for (i, expr) in subexpr_list.iter().skip(1).rev().enumerate() {\n+        // TODO should only use first_child_shape if expr is block like\n+        let shape = if *is_block_like.last().unwrap() && !(extend && i == 0) {\n+            // TODO change the name of the shapes\n+            first_child_shape\n+        } else {\n+            other_child_shape\n+        };\n+        let rewrite = rewrite_chain_subexpr(expr, total_span, context, shape)?;\n+        is_block_like.push(is_block_expr(context, expr, &rewrite));\n+        rewrites.push(rewrite);\n+    }\n \n     // Total of all items excluding the last.\n     let extend_last_subexpr = if is_small_parent {\n@@ -180,7 +210,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     let all_in_one_line = !parent_rewrite_contains_newline\n         && rewrites.iter().all(|s| !s.contains('\\n'))\n         && almost_total < one_line_budget;\n-    let last_shape = if rewrites.is_empty() {\n+    let last_shape = if is_block_like[rewrites.len()] {\n         first_child_shape\n     } else {\n         other_child_shape\n@@ -228,7 +258,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         parent_shape.offset_left(almost_total).map(|shape| {\n             if let Some(rw) = rewrite_chain_subexpr(last_subexpr, total_span, context, shape) {\n                 // We allow overflowing here only if both of the following conditions match:\n-                // 1. The entire chain fits in a single line expect the last child.\n+                // 1. The entire chain fits in a single line except the last child.\n                 // 2. `last_child_str.lines().count() >= 5`.\n                 let line_count = rw.lines().count();\n                 let fits_single_line = almost_total + first_line_width(&rw) <= one_line_budget;\n@@ -255,6 +285,9 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         (rewrite_last(), false)\n     };\n     rewrites.push(last_subexpr_str?);\n+    // We should never look at this, since we only look at the block-ness of the\n+    // previous item in the chain.\n+    is_block_like.push(false);\n \n     let connector = if fits_single_line && !parent_rewrite_contains_newline {\n         // Yay, we can put everything on one line.\n@@ -293,14 +326,14 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n             first_connector,\n             rewrites[0],\n             second_connector,\n-            join_rewrites(&rewrites[1..], &connector)\n+            join_rewrites(&rewrites[1..], &is_block_like[2..], &connector),\n         )\n     } else {\n         format!(\n             \"{}{}{}\",\n             parent_rewrite,\n             first_connector,\n-            join_rewrites(&rewrites, &connector)\n+            join_rewrites(&rewrites, &is_block_like[1..], &connector),\n         )\n     };\n     let result = format!(\"{}{}\", result, \"?\".repeat(suffix_try_num));\n@@ -332,12 +365,12 @@ fn rewrite_try(\n     Some(format!(\"{}{}\", sub_expr, \"?\".repeat(try_count)))\n }\n \n-fn join_rewrites(rewrites: &[String], connector: &str) -> String {\n+fn join_rewrites(rewrites: &[String], is_block_like: &[bool], connector: &str) -> String {\n     let mut rewrite_iter = rewrites.iter();\n     let mut result = rewrite_iter.next().unwrap().clone();\n \n-    for rewrite in rewrite_iter {\n-        if rewrite != \"?\" {\n+    for (rewrite, prev_is_block_like) in rewrite_iter.zip(is_block_like.iter()) {\n+        if rewrite != \"?\" && !prev_is_block_like {\n             result.push_str(connector);\n         }\n         result.push_str(&rewrite);\n@@ -365,7 +398,11 @@ fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool\n         ast::ExprKind::Paren(ref expr)\n         | ast::ExprKind::Binary(_, _, ref expr)\n         | ast::ExprKind::Index(_, ref expr)\n-        | ast::ExprKind::Unary(_, ref expr) => is_block_expr(context, expr, repr),\n+        | ast::ExprKind::Unary(_, ref expr)\n+        | ast::ExprKind::Closure(_, _, _, _, ref expr, _) => is_block_expr(context, expr, repr),\n+        ast::ExprKind::MethodCall(_, ref exprs) => {\n+            is_block_expr(context, exprs.last().unwrap(), repr)\n+        }\n         _ => false,\n     }\n }"}]}