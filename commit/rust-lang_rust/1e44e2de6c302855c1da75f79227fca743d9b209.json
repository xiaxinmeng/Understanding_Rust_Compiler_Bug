{"sha": "1e44e2de6c302855c1da75f79227fca743d9b209", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNDRlMmRlNmMzMDI4NTVjMWRhNzVmNzkyMjdmY2E3NDNkOWIyMDk=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-09-05T23:18:53Z"}, "committer": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-12-07T05:56:50Z"}, "message": "SGX target: implement user memory management", "tree": {"sha": "2dfbff97935065d7fac12ad851d394b381049ffa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dfbff97935065d7fac12ad851d394b381049ffa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e44e2de6c302855c1da75f79227fca743d9b209", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e44e2de6c302855c1da75f79227fca743d9b209", "html_url": "https://github.com/rust-lang/rust/commit/1e44e2de6c302855c1da75f79227fca743d9b209", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e44e2de6c302855c1da75f79227fca743d9b209/comments", "author": null, "committer": null, "parents": [{"sha": "39f9751716986b498bfb2b14b481751a4256957f", "url": "https://api.github.com/repos/rust-lang/rust/commits/39f9751716986b498bfb2b14b481751a4256957f", "html_url": "https://github.com/rust-lang/rust/commit/39f9751716986b498bfb2b14b481751a4256957f"}], "stats": {"total": 508, "additions": 502, "deletions": 6}, "files": [{"sha": "66771b3c4a2f01fda1faaa4b77808b68d58c441a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e44e2de6c302855c1da75f79227fca743d9b209/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e44e2de6c302855c1da75f79227fca743d9b209/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=1e44e2de6c302855c1da75f79227fca743d9b209", "patch": "@@ -312,7 +312,8 @@\n #![feature(non_exhaustive)]\n #![feature(alloc_layout_extra)]\n #![feature(maybe_uninit)]\n-#![cfg_attr(target_env = \"sgx\", feature(global_asm, range_contains))]\n+#![cfg_attr(target_env = \"sgx\", feature(global_asm, range_contains, slice_index_methods,\n+                                        decl_macro, coerce_unsized))]\n \n #![default_lib_allocator]\n "}, {"sha": "508f2ff4d4fa5e4b9cb95308555111550cee95b1", "filename": "src/libstd/sys/sgx/abi/mem.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1e44e2de6c302855c1da75f79227fca743d9b209/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e44e2de6c302855c1da75f79227fca743d9b209/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs?ref=1e44e2de6c302855c1da75f79227fca743d9b209", "patch": "@@ -11,13 +11,17 @@\n // Do not remove inline: will result in relocation failure\n #[inline(always)]\n pub unsafe fn rel_ptr<T>(offset: u64) -> *const T {\n-    (image_base()+offset) as *const T\n+    (image_base() + offset) as *const T\n }\n \n // Do not remove inline: will result in relocation failure\n #[inline(always)]\n pub unsafe fn rel_ptr_mut<T>(offset: u64) -> *mut T {\n-    (image_base()+offset) as *mut T\n+    (image_base() + offset) as *mut T\n+}\n+\n+extern {\n+    static ENCLAVE_SIZE: usize;\n }\n \n // Do not remove inline: will result in relocation failure\n@@ -26,6 +30,20 @@ pub unsafe fn rel_ptr_mut<T>(offset: u64) -> *mut T {\n #[inline(always)]\n fn image_base() -> u64 {\n     let base;\n-    unsafe{asm!(\"lea IMAGE_BASE(%rip),$0\":\"=r\"(base))};\n+    unsafe { asm!(\"lea IMAGE_BASE(%rip),$0\":\"=r\"(base)) };\n     base\n }\n+\n+pub fn is_enclave_range(p: *const u8, len: usize) -> bool {\n+    let start=p as u64;\n+    let end=start + (len as u64);\n+    start >= image_base() &&\n+        end <= image_base() + (unsafe { ENCLAVE_SIZE } as u64) // unsafe ok: link-time constant\n+}\n+\n+pub fn is_user_range(p: *const u8, len: usize) -> bool {\n+    let start=p as u64;\n+    let end=start + (len as u64);\n+    end <= image_base() ||\n+        start >= image_base() + (unsafe { ENCLAVE_SIZE } as u64) // unsafe ok: link-time constant\n+}"}, {"sha": "612049049627fedc3aed568b7019afd2af7faaa0", "filename": "src/libstd/sys/sgx/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e44e2de6c302855c1da75f79227fca743d9b209/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e44e2de6c302855c1da75f79227fca743d9b209/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=1e44e2de6c302855c1da75f79227fca743d9b209", "patch": "@@ -96,5 +96,5 @@ pub(super) fn exit_with_code(code: isize) -> ! {\n             let _ = write!(out, \"Exited with status code {}\", code);\n         }\n     }\n-    unsafe { usercalls::raw::exit(code != 0) };\n+    usercalls::exit(code != 0);\n }"}, {"sha": "64968a9970c487d0dc143b97fba1b9516bfc7ef6", "filename": "src/libstd/sys/sgx/abi/usercalls/alloc.rs", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/1e44e2de6c302855c1da75f79227fca743d9b209/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e44e2de6c302855c1da75f79227fca743d9b209/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=1e44e2de6c302855c1da75f79227fca743d9b209", "patch": "@@ -0,0 +1,404 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+\n+use ptr;\n+use mem;\n+use cell::UnsafeCell;\n+use slice;\n+use ops::{Deref, DerefMut, Index, IndexMut, CoerceUnsized};\n+use slice::SliceIndex;\n+\n+use fortanix_sgx_abi::*;\n+use super::super::mem::is_user_range;\n+\n+/// A type that can be safely read from or written to userspace.\n+///\n+/// Non-exhaustive list of specific requirements for reading and writing:\n+/// * **Type is `Copy`** (and therefore also not `Drop`). Copies will be\n+///   created when copying from/to userspace. Destructors will not be called.\n+/// * **No references or Rust-style owned pointers** (`Vec`, `Arc`, etc.). When\n+///   reading from userspace, references into enclave memory must not be\n+///   created. Also, only enclave memory is considered managed by the Rust\n+///   compiler's static analysis. When reading from userspace, there can be no\n+///   guarantee that the value correctly adheres to the expectations of the\n+///   type. When writing to userspace, memory addresses of data in enclave\n+///   memory must not be leaked for confidentiality reasons. `User` and\n+///   `UserRef` are also not allowed for the same reasons.\n+/// * **No fat pointers.** When reading from userspace, the size or vtable\n+///   pointer could be automatically interpreted and used by the code. When\n+///   writing to userspace, memory addresses of data in enclave memory (such\n+///   as vtable pointers) must not be leaked for confidentiality reasons.\n+///\n+/// Non-exhaustive list of specific requirements for reading from userspace:\n+/// * Any bit pattern is valid for this type (no `enum`s). There can be no\n+///   guarantee that the value correctly adheres to the expectations of the\n+///   type, so any value must be valid for this type.\n+///\n+/// Non-exhaustive list of specific requirements for writing to userspace:\n+/// * No pointers to enclave memory. Memory addresses of data in enclave memory\n+///   must not be leaked for confidentiality reasons.\n+/// * No internal padding. Padding might contain previously-initialized secret\n+///   data stored at that memory location and must not be leaked for\n+///   confidentiality reasons.\n+pub unsafe trait UserSafeSized: Copy + Sized {}\n+\n+unsafe impl UserSafeSized for u8 {}\n+unsafe impl<T> UserSafeSized for FifoDescriptor<T> {}\n+unsafe impl UserSafeSized for ByteBuffer {}\n+unsafe impl UserSafeSized for Usercall {}\n+unsafe impl UserSafeSized for Return {}\n+unsafe impl<T: UserSafeSized> UserSafeSized for [T; 2] {}\n+\n+/// A type that can be represented in memory as one or more `UserSafeSized`s.\n+pub unsafe trait UserSafe {\n+    unsafe fn align_of() -> usize;\n+\n+    /// NB. This takes a size, not a length!\n+    unsafe fn from_raw_sized_unchecked(ptr: *const u8, size: usize) -> *const Self;\n+\n+    /// NB. This takes a size, not a length!\n+    unsafe fn from_raw_sized(ptr: *const u8, size: usize) -> *const Self {\n+        let ret = Self::from_raw_sized_unchecked(ptr, size);\n+        Self::check_ptr(ret);\n+        ret\n+    }\n+\n+    unsafe fn check_ptr(ptr: *const Self) {\n+        let is_aligned = |p| -> bool {\n+            0 == (p as usize) & (Self::align_of() - 1)\n+        };\n+\n+        assert!(is_aligned(ptr as *const u8));\n+        assert!(is_user_range(ptr as _, mem::size_of_val(&*ptr)));\n+        assert!(!ptr.is_null());\n+    }\n+}\n+\n+unsafe impl<T: UserSafeSized> UserSafe for T {\n+    unsafe fn align_of() -> usize {\n+        mem::align_of::<T>()\n+    }\n+\n+    unsafe fn from_raw_sized_unchecked(ptr: *const u8, size: usize) -> *const Self {\n+        assert_eq!(size, mem::size_of::<T>());\n+        ptr as _\n+    }\n+}\n+\n+unsafe impl<T: UserSafeSized> UserSafe for [T] {\n+    unsafe fn align_of() -> usize {\n+        mem::align_of::<T>()\n+    }\n+\n+    unsafe fn from_raw_sized_unchecked(ptr: *const u8, size: usize) -> *const Self {\n+        let elem_size = mem::size_of::<T>();\n+        assert_eq!(size % elem_size, 0);\n+        let len = size / elem_size;\n+        slice::from_raw_parts(ptr as _, len)\n+    }\n+}\n+\n+/// A reference to some type in userspace memory. `&UserRef<T>` is equivalent\n+/// to `&T` in enclave memory. Access to the memory is only allowed by copying\n+/// to avoid TOCTTOU issues. After copying, code should make sure to completely\n+/// check the value before use.\n+pub struct UserRef<T: ?Sized>(UnsafeCell<T>);\n+/// An owned type in userspace memory. `User<T>` is equivalent to `Box<T>` in\n+/// enclave memory. Access to the memory is only allowed by copying to avoid\n+/// TOCTTOU issues. The user memory will be freed when the value is dropped.\n+/// After copying, code should make sure to completely check the value before\n+/// use.\n+pub struct User<T: UserSafe + ?Sized>(*mut UserRef<T>);\n+\n+impl<T: ?Sized> User<T> where T: UserSafe {\n+    // This function returns memory that is practically uninitialized, but is\n+    // not considered \"unspecified\" or \"undefined\" for purposes of an\n+    // optimizing compiler. This is achieved by returning a pointer from\n+    // from outside as obtained by `super::alloc`.\n+    fn new_uninit_bytes(size: usize) -> Self {\n+        unsafe {\n+            let ptr = super::alloc(size, T::align_of()).expect(\"User memory allocation failed\");\n+            User(T::from_raw_sized(ptr as _, size) as _)\n+        }\n+    }\n+\n+    pub fn new_from_enclave(val: &T) -> Self {\n+        unsafe {\n+            let ret = Self::new_uninit_bytes(mem::size_of_val(val));\n+            ptr::copy(\n+                val as *const T as *const u8,\n+                ret.0 as *mut T as *mut u8,\n+                mem::size_of_val(val)\n+            );\n+            ret\n+        }\n+    }\n+\n+    /// Create an owned `User<T>` from a raw pointer. The pointer should be\n+    /// freeable with the `free` usercall and the alignment of `T`.\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer is not aligned\n+    /// * The pointer is null\n+    /// * The pointed-to range is not in user memory\n+    pub unsafe fn from_raw(ptr: *mut T) -> Self {\n+        T::check_ptr(ptr);\n+        User(ptr as _)\n+    }\n+\n+    /// Convert this value into a raw pointer. The value will no longer be\n+    /// automatically freed.\n+    pub fn into_raw(self) -> *mut T {\n+        let ret = self.0;\n+        mem::forget(self);\n+        ret as _\n+    }\n+}\n+\n+impl<T> User<T> where T: UserSafe {\n+    pub fn uninitialized() -> Self {\n+        Self::new_uninit_bytes(mem::size_of::<T>())\n+    }\n+}\n+\n+impl<T> User<[T]> where [T]: UserSafe {\n+    pub fn uninitialized(n: usize) -> Self {\n+        Self::new_uninit_bytes(n * mem::size_of::<T>())\n+    }\n+\n+    /// Create an owned `User<[T]>` from a raw thin pointer and a slice length.\n+    /// The pointer should be freeable with the `free` usercall and the\n+    /// alignment of `T`.\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer is not aligned\n+    /// * The pointer is null\n+    /// * The pointed-to range is not in user memory\n+    pub unsafe fn from_raw_parts(ptr: *mut T, len: usize) -> Self {\n+        User(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()) as _)\n+    }\n+}\n+\n+impl<T: ?Sized> UserRef<T> where T: UserSafe {\n+    /// Create a `&UserRef<[T]>` from a raw pointer.\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer is not aligned\n+    /// * The pointer is null\n+    /// * The pointed-to range is not in user memory\n+    pub unsafe fn from_ptr<'a>(ptr: *const T) -> &'a Self {\n+        T::check_ptr(ptr);\n+        &*(ptr as *const Self)\n+    }\n+\n+    /// Create a `&mut UserRef<[T]>` from a raw pointer.\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer is not aligned\n+    /// * The pointer is null\n+    /// * The pointed-to range is not in user memory\n+    pub unsafe fn from_mut_ptr<'a>(ptr: *mut T) -> &'a mut Self {\n+        T::check_ptr(ptr);\n+        &mut*(ptr as *mut Self)\n+    }\n+\n+    /// # Panics\n+    /// This function panics if the destination doesn't have the same size as\n+    /// the source. This can happen for dynamically-sized types such as slices.\n+    pub fn copy_from_enclave(&mut self, val: &T) {\n+        unsafe {\n+            assert_eq!(mem::size_of_val(val), mem::size_of_val( &*self.0.get() ));\n+            ptr::copy(\n+                val as *const T as *const u8,\n+                self.0.get() as *mut T as *mut u8,\n+                mem::size_of_val(val)\n+            );\n+        }\n+    }\n+\n+    /// # Panics\n+    /// This function panics if the destination doesn't have the same size as\n+    /// the source. This can happen for dynamically-sized types such as slices.\n+    pub fn copy_to_enclave(&self, dest: &mut T) {\n+        unsafe {\n+            assert_eq!(mem::size_of_val(dest), mem::size_of_val( &*self.0.get() ));\n+            ptr::copy(\n+                self.0.get() as *const T as *const u8,\n+                dest as *mut T as *mut u8,\n+                mem::size_of_val(dest)\n+            );\n+        }\n+    }\n+\n+    pub fn as_raw_ptr(&self) -> *const T {\n+        self as *const _ as _\n+    }\n+\n+    pub fn as_raw_mut_ptr(&mut self) -> *mut T {\n+        self as *mut _ as _\n+    }\n+}\n+\n+impl<T> UserRef<T> where T: UserSafe {\n+    pub fn to_enclave(&self) -> T {\n+        unsafe { ptr::read(self.0.get()) }\n+    }\n+}\n+\n+impl<T> UserRef<[T]> where [T]: UserSafe {\n+    /// Create a `&UserRef<[T]>` from a raw thin pointer and a slice length.\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer is not aligned\n+    /// * The pointer is null\n+    /// * The pointed-to range is not in user memory\n+    pub unsafe fn from_raw_parts<'a>(ptr: *const T, len: usize) -> &'a Self {\n+        &*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()) as *const Self)\n+    }\n+\n+    /// Create a `&mut UserRef<[T]>` from a raw thin pointer and a slice length.\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer is not aligned\n+    /// * The pointer is null\n+    /// * The pointed-to range is not in user memory\n+    pub unsafe fn from_raw_parts_mut<'a>(ptr: *mut T, len: usize) -> &'a mut Self {\n+        &mut*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()) as *mut Self)\n+    }\n+\n+    pub fn as_ptr(&self) -> *const T {\n+        self.0.get() as _\n+    }\n+\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        self.0.get() as _\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        unsafe { (*self.0.get()).len() }\n+    }\n+\n+    pub fn copy_to_enclave_vec(&self, dest: &mut Vec<T>) {\n+        unsafe {\n+            if let Some(missing) = self.len().checked_sub(dest.capacity()) {\n+                dest.reserve(missing)\n+            }\n+            dest.set_len(self.len());\n+            self.copy_to_enclave(&mut dest[..]);\n+        }\n+    }\n+\n+    pub fn to_enclave(&self) -> Vec<T> {\n+        let mut ret = Vec::with_capacity(self.len());\n+        self.copy_to_enclave_vec(&mut ret);\n+        ret\n+    }\n+\n+    pub fn iter(&self) -> Iter<T>\n+        where T: UserSafe // FIXME: should be implied by [T]: UserSafe?\n+    {\n+        unsafe {\n+            Iter((&*self.as_raw_ptr()).iter())\n+        }\n+    }\n+\n+    pub fn iter_mut(&mut self) -> IterMut<T>\n+        where T: UserSafe // FIXME: should be implied by [T]: UserSafe?\n+    {\n+        unsafe {\n+            IterMut((&mut*self.as_raw_mut_ptr()).iter_mut())\n+        }\n+    }\n+}\n+\n+pub struct Iter<'a, T: 'a + UserSafe>(slice::Iter<'a, T>);\n+\n+impl<'a, T: UserSafe> Iterator for Iter<'a, T> {\n+    type Item = &'a UserRef<T>;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        unsafe {\n+            self.0.next().map(|e| UserRef::from_ptr(e))\n+        }\n+    }\n+}\n+\n+pub struct IterMut<'a, T: 'a + UserSafe>(slice::IterMut<'a, T>);\n+\n+impl<'a, T: UserSafe> Iterator for IterMut<'a, T> {\n+    type Item = &'a mut UserRef<T>;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        unsafe {\n+            self.0.next().map(|e| UserRef::from_mut_ptr(e))\n+        }\n+    }\n+}\n+\n+impl<T: ?Sized> Deref for User<T> where T: UserSafe {\n+    type Target = UserRef<T>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        unsafe { &*self.0 }\n+    }\n+}\n+\n+impl<T: ?Sized> DerefMut for User<T> where T: UserSafe {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        unsafe { &mut*self.0 }\n+    }\n+}\n+\n+impl<T: ?Sized> Drop for User<T> where T: UserSafe {\n+    fn drop(&mut self) {\n+        unsafe {\n+            let ptr = (*self.0).0.get();\n+            super::free(ptr as _, mem::size_of_val(&mut*ptr), T::align_of());\n+        }\n+    }\n+}\n+\n+impl<T: CoerceUnsized<U>, U> CoerceUnsized<UserRef<U>> for UserRef<T> {}\n+\n+impl<T, I: SliceIndex<[T]>> Index<I> for UserRef<[T]> where [T]: UserSafe, I::Output: UserSafe {\n+    type Output = UserRef<I::Output>;\n+\n+    #[inline]\n+    fn index(&self, index: I) -> &UserRef<I::Output> {\n+        unsafe {\n+            UserRef::from_ptr(index.index(&*self.as_raw_ptr()))\n+        }\n+    }\n+}\n+\n+impl<T, I: SliceIndex<[T]>> IndexMut<I> for UserRef<[T]> where [T]: UserSafe, I::Output: UserSafe {\n+    #[inline]\n+    fn index_mut(&mut self, index: I) -> &mut UserRef<I::Output> {\n+        unsafe {\n+            UserRef::from_mut_ptr(index.index_mut(&mut*self.as_raw_mut_ptr()))\n+        }\n+    }\n+}"}, {"sha": "f7a9c3da3b2c08e3aba15c28712b5aee2d21e2d4", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/1e44e2de6c302855c1da75f79227fca743d9b209/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e44e2de6c302855c1da75f79227fca743d9b209/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=1e44e2de6c302855c1da75f79227fca743d9b209", "patch": "@@ -8,5 +8,78 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub use fortanix_sgx_abi::*;\n+\n+use io::{Error as IoError, Result as IoResult};\n+\n+mod alloc;\n #[macro_use]\n-pub mod raw;\n+mod raw;\n+\n+pub fn exit(panic: bool) -> ! {\n+    unsafe { raw::exit(panic) }\n+}\n+\n+pub fn alloc(size: usize, alignment: usize) -> IoResult<*mut u8> {\n+    unsafe { raw::alloc(size, alignment).from_sgx_result() }\n+}\n+\n+pub use self::raw::free;\n+\n+fn check_os_error(err: Result) -> i32 {\n+    // FIXME: not sure how to make sure all variants of Error are covered\n+    if err == Error::NotFound as _ ||\n+       err == Error::PermissionDenied as _ ||\n+       err == Error::ConnectionRefused as _ ||\n+       err == Error::ConnectionReset as _ ||\n+       err == Error::ConnectionAborted as _ ||\n+       err == Error::NotConnected as _ ||\n+       err == Error::AddrInUse as _ ||\n+       err == Error::AddrNotAvailable as _ ||\n+       err == Error::BrokenPipe as _ ||\n+       err == Error::AlreadyExists as _ ||\n+       err == Error::WouldBlock as _ ||\n+       err == Error::InvalidInput as _ ||\n+       err == Error::InvalidData as _ ||\n+       err == Error::TimedOut as _ ||\n+       err == Error::WriteZero as _ ||\n+       err == Error::Interrupted as _ ||\n+       err == Error::Other as _ ||\n+       err == Error::UnexpectedEof as _ ||\n+       ((Error::UserRangeStart as _)..=(Error::UserRangeEnd as _)).contains(&err)\n+    {\n+        err\n+    } else {\n+        panic!(\"Usercall: returned invalid error value {}\", err)\n+    }\n+}\n+\n+trait FromSgxResult {\n+    type Return;\n+\n+    fn from_sgx_result(self) -> IoResult<Self::Return>;\n+}\n+\n+impl<T> FromSgxResult for (Result, T) {\n+    type Return = T;\n+\n+    fn from_sgx_result(self) -> IoResult<Self::Return> {\n+        if self.0 == RESULT_SUCCESS {\n+            Ok(self.1)\n+        } else {\n+            Err(IoError::from_raw_os_error(check_os_error(self.0)))\n+        }\n+    }\n+}\n+\n+impl FromSgxResult for Result {\n+    type Return = ();\n+\n+    fn from_sgx_result(self) -> IoResult<Self::Return> {\n+        if self == RESULT_SUCCESS {\n+            Ok(())\n+        } else {\n+            Err(IoError::from_raw_os_error(check_os_error(self)))\n+        }\n+    }\n+}"}]}