{"sha": "b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2NzE2YTFjZGQ3YWQ4ZWFiOTNjOWUyNWU3ODMyYTNjMGY3NDRkNjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-23T02:25:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-23T02:25:10Z"}, "message": "Auto merge of #64695 - Centril:rollup-t1xnl2c, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #64294 (Fix `Stdio::piped` example code and lint)\n - #64670 (Cleanup syntax::ext::build)\n - #64674 (Propagate `types.err` in locals further to avoid spurious knock-down errors)\n - #64676 (Parse assoc type bounds in generic params and provide custom diagnostic)\n - #64677 (remove outdated comment)\n - #64679 (Infer consts more consistently)\n - #64688 (Clarify the \"since\" tidy check)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "4ca54312a3172a1d1c2f22e3b08eabb13281d79a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ca54312a3172a1d1c2f22e3b08eabb13281d79a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "html_url": "https://github.com/rust-lang/rust/commit/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0b7e71bec30753a1c4c387c8b14710b8674649f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b7e71bec30753a1c4c387c8b14710b8674649f", "html_url": "https://github.com/rust-lang/rust/commit/c0b7e71bec30753a1c4c387c8b14710b8674649f"}, {"sha": "55df97c3946b1c09752ed8fe39a0287367a1a2b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/55df97c3946b1c09752ed8fe39a0287367a1a2b8", "html_url": "https://github.com/rust-lang/rust/commit/55df97c3946b1c09752ed8fe39a0287367a1a2b8"}], "stats": {"total": 652, "additions": 186, "deletions": 466}, "files": [{"sha": "966c5810171af34535fbe00e289ae9486bf45b05", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -30,6 +30,7 @@ use super::sub::Sub;\n use super::type_variable::TypeVariableValue;\n use super::unify_key::{ConstVarValue, ConstVariableValue};\n use super::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n+use super::unify_key::replace_if_possible;\n \n use crate::hir::def_id::DefId;\n use crate::mir::interpret::ConstValue;\n@@ -127,6 +128,12 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n     where\n         R: TypeRelation<'tcx>,\n     {\n+        debug!(\"{}.consts({:?}, {:?})\", relation.tag(), a, b);\n+        if a == b { return Ok(a); }\n+\n+        let a = replace_if_possible(self.const_unification_table.borrow_mut(), a);\n+        let b = replace_if_possible(self.const_unification_table.borrow_mut(), b);\n+\n         let a_is_expected = relation.a_is_expected();\n \n         match (a.val, b.val) {"}, {"sha": "6065387647fa758ae3a7f9b5c0e25245c0f29395", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 37, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -1,14 +1,12 @@\n-use super::combine::{CombineFields, RelationDir, const_unification_error};\n+use super::combine::{CombineFields, RelationDir};\n use super::Subtype;\n \n use crate::hir::def_id::DefId;\n \n-use crate::ty::{self, Ty, TyCtxt, InferConst};\n+use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::TyVar;\n use crate::ty::subst::SubstsRef;\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use crate::mir::interpret::ConstValue;\n-use crate::infer::unify_key::replace_if_possible;\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n pub struct Equate<'combine, 'infcx, 'tcx> {\n@@ -108,39 +106,7 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n         a: &'tcx ty::Const<'tcx>,\n         b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n-        if a == b { return Ok(a); }\n-\n-        let infcx = self.fields.infcx;\n-        let a = replace_if_possible(infcx.const_unification_table.borrow_mut(), a);\n-        let b = replace_if_possible(infcx.const_unification_table.borrow_mut(), b);\n-        let a_is_expected = self.a_is_expected();\n-\n-        match (a.val, b.val) {\n-            (ConstValue::Infer(InferConst::Var(a_vid)),\n-                ConstValue::Infer(InferConst::Var(b_vid))) => {\n-                infcx.const_unification_table\n-                    .borrow_mut()\n-                    .unify_var_var(a_vid, b_vid)\n-                    .map_err(|e| const_unification_error(a_is_expected, e))?;\n-                return Ok(a);\n-            }\n-\n-            (ConstValue::Infer(InferConst::Var(a_id)), _) => {\n-                self.fields.infcx.unify_const_variable(a_is_expected, a_id, b)?;\n-                return Ok(a);\n-            }\n-\n-            (_, ConstValue::Infer(InferConst::Var(b_id))) => {\n-                self.fields.infcx.unify_const_variable(!a_is_expected, b_id, a)?;\n-                return Ok(a);\n-            }\n-\n-            _ => {}\n-        }\n-\n-        self.fields.infcx.super_combine_consts(self, a, b)?;\n-        Ok(a)\n+        self.fields.infcx.super_combine_consts(self, a, b)\n     }\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)"}, {"sha": "37de54a7e8558c520983e904a636fb46e360cfee", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -66,11 +66,6 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n         a: &'tcx ty::Const<'tcx>,\n         b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n-        if a == b {\n-            return Ok(a);\n-        }\n-\n         self.fields.infcx.super_combine_consts(self, a, b)\n     }\n "}, {"sha": "a1a94865e74e3fd680b435839c4597a2473280ce", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -66,11 +66,6 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n         a: &'tcx ty::Const<'tcx>,\n         b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n-        if a == b {\n-            return Ok(a);\n-        }\n-\n         self.fields.infcx.super_combine_consts(self, a, b)\n     }\n "}, {"sha": "67c97ef5d8b295d68650eaf40c4440e7baf02ea6", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 39, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -1,13 +1,11 @@\n use super::SubregionOrigin;\n-use super::combine::{CombineFields, RelationDir, const_unification_error};\n+use super::combine::{CombineFields, RelationDir};\n \n use crate::traits::Obligation;\n-use crate::ty::{self, Ty, TyCtxt, InferConst};\n+use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::TyVar;\n use crate::ty::fold::TypeFoldable;\n use crate::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n-use crate::infer::unify_key::replace_if_possible;\n-use crate::mir::interpret::ConstValue;\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n@@ -142,41 +140,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         a: &'tcx ty::Const<'tcx>,\n         b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n-        if a == b { return Ok(a); }\n-\n-        let infcx = self.fields.infcx;\n-        let a = replace_if_possible(infcx.const_unification_table.borrow_mut(), a);\n-        let b = replace_if_possible(infcx.const_unification_table.borrow_mut(), b);\n-\n-        // Consts can only be equal or unequal to each other: there's no subtyping\n-        // relation, so we're just going to perform equating here instead.\n-        let a_is_expected = self.a_is_expected();\n-        match (a.val, b.val) {\n-            (ConstValue::Infer(InferConst::Var(a_vid)),\n-                ConstValue::Infer(InferConst::Var(b_vid))) => {\n-                infcx.const_unification_table\n-                    .borrow_mut()\n-                    .unify_var_var(a_vid, b_vid)\n-                    .map_err(|e| const_unification_error(a_is_expected, e))?;\n-                return Ok(a);\n-            }\n-\n-            (ConstValue::Infer(InferConst::Var(a_id)), _) => {\n-                self.fields.infcx.unify_const_variable(a_is_expected, a_id, b)?;\n-                return Ok(a);\n-            }\n-\n-            (_, ConstValue::Infer(InferConst::Var(b_id))) => {\n-                self.fields.infcx.unify_const_variable(!a_is_expected, b_id, a)?;\n-                return Ok(a);\n-            }\n-\n-            _ => {}\n-        }\n-\n-        self.fields.infcx.super_combine_consts(self, a, b)?;\n-        Ok(a)\n+        self.fields.infcx.super_combine_consts(self, a, b)\n     }\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)"}, {"sha": "1f17ab69f6660b722e613a46586df945aeb9a044", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -23,7 +23,6 @@ use std::rc::Rc;\n \n crate type PoloniusOutput = Output<RegionVid, BorrowIndex, LocationIndex, Local, MovePathIndex>;\n \n-// (forced to be `pub` due to its use as an associated type below.)\n crate struct Flows<'b, 'tcx> {\n     borrows: FlowAtLocation<'tcx, Borrows<'b, 'tcx>>,\n     pub uninits: FlowAtLocation<'tcx, MaybeUninitializedPlaces<'b, 'tcx>>,"}, {"sha": "d98e1f3e1283fa3306bbd4492109846e971e504e", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -163,7 +163,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // Just ignore error types.\n         if a.references_error() || b.references_error() {\n-            return success(vec![], b, vec![]);\n+            return success(vec![], self.fcx.tcx.types.err, vec![]);\n         }\n \n         if a.is_never() {\n@@ -821,7 +821,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (adjustments, _) = self.register_infer_ok_obligations(ok);\n         self.apply_adjustments(expr, adjustments);\n-        Ok(target)\n+        Ok(if expr_ty.references_error() {\n+            self.tcx.types.err\n+        } else {\n+            target\n+        })\n     }\n \n     /// Same as `try_coerce()`, but without side-effects."}, {"sha": "6c8c5ae5123582cbccd9c6b6d0b80231edea73c3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -153,7 +153,7 @@ use self::method::{MethodCallee, SelfSource};\n use self::TupleArgumentsFlag::*;\n \n /// The type of a local binding, including the revealed type for anon types.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub struct LocalTy<'tcx> {\n     decl_ty: Ty<'tcx>,\n     revealed_ty: Ty<'tcx>\n@@ -3822,15 +3822,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let Some(ref init) = local.init {\n             let init_ty = self.check_decl_initializer(local, &init);\n-            if init_ty.references_error() {\n-                self.write_ty(local.hir_id, init_ty);\n-            }\n+            self.overwrite_local_ty_if_err(local, t, init_ty);\n         }\n \n         self.check_pat_top(&local.pat, t, None);\n         let pat_ty = self.node_ty(local.pat.hir_id);\n-        if pat_ty.references_error() {\n-            self.write_ty(local.hir_id, pat_ty);\n+        self.overwrite_local_ty_if_err(local, t, pat_ty);\n+    }\n+\n+    fn overwrite_local_ty_if_err(&self, local: &'tcx hir::Local, decl_ty: Ty<'tcx>, ty: Ty<'tcx>) {\n+        if ty.references_error() {\n+            // Override the types everywhere with `types.err` to avoid knock down errors.\n+            self.write_ty(local.hir_id, ty);\n+            self.write_ty(local.pat.hir_id, ty);\n+            let local_ty = LocalTy {\n+                decl_ty,\n+                revealed_ty: ty,\n+            };\n+            self.locals.borrow_mut().insert(local.hir_id, local_ty);\n+            self.locals.borrow_mut().insert(local.pat.hir_id, local_ty);\n         }\n     }\n "}, {"sha": "da136ca6bf68dcbf6d9ff30fa607c0bcb2806d3e", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -940,7 +940,7 @@ impl Stdio {\n     /// }\n     ///\n     /// let output = child.wait_with_output().expect(\"Failed to read stdout\");\n-    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"!dlrow ,olleH\\n\");\n+    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"!dlrow ,olleH\");\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn piped() -> Stdio { Stdio(imp::Stdio::MakePipe) }"}, {"sha": "f903b66e2961d4e2487bd58ae634b195b283b739", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 9, "deletions": 316, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -1,30 +1,28 @@\n-use crate::ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp, PatKind};\n+use crate::ast::{self, Ident, Expr, BlockCheckMode, UnOp, PatKind};\n use crate::attr;\n-use crate::source_map::{dummy_spanned, respan, Spanned};\n+use crate::source_map::{respan, Spanned};\n use crate::ext::base::ExtCtxt;\n use crate::ptr::P;\n use crate::symbol::{kw, sym, Symbol};\n use crate::ThinVec;\n \n-use rustc_target::spec::abi::Abi;\n use syntax_pos::{Pos, Span};\n \n impl<'a> ExtCtxt<'a> {\n     pub fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n-        self.path_all(span, false, strs, vec![], vec![])\n+        self.path_all(span, false, strs, vec![])\n     }\n     pub fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path {\n         self.path(span, vec![id])\n     }\n     pub fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n-        self.path_all(span, true, strs, vec![], vec![])\n+        self.path_all(span, true, strs, vec![])\n     }\n     pub fn path_all(&self,\n                 span: Span,\n                 global: bool,\n                 mut idents: Vec<ast::Ident> ,\n-                args: Vec<ast::GenericArg>,\n-                constraints: Vec<ast::AssocTyConstraint> )\n+                args: Vec<ast::GenericArg>)\n                 -> ast::Path {\n         assert!(!idents.is_empty());\n         let add_root = global && !idents[0].is_path_segment_keyword();\n@@ -36,8 +34,8 @@ impl<'a> ExtCtxt<'a> {\n         segments.extend(idents.into_iter().map(|ident| {\n             ast::PathSegment::from_ident(ident.with_span_pos(span))\n         }));\n-        let args = if !args.is_empty() || !constraints.is_empty() {\n-            ast::AngleBracketedArgs { args, constraints, span }.into()\n+        let args = if !args.is_empty() {\n+            ast::AngleBracketedArgs { args, constraints: Vec::new(), span }.into()\n         } else {\n             None\n         };\n@@ -49,42 +47,6 @@ impl<'a> ExtCtxt<'a> {\n         ast::Path { span, segments }\n     }\n \n-    /// Constructs a qualified path.\n-    ///\n-    /// Constructs a path like `<self_type as trait_path>::ident`.\n-    pub fn qpath(&self,\n-             self_type: P<ast::Ty>,\n-             trait_path: ast::Path,\n-             ident: ast::Ident)\n-             -> (ast::QSelf, ast::Path) {\n-        self.qpath_all(self_type, trait_path, ident, vec![], vec![])\n-    }\n-\n-    /// Constructs a qualified path.\n-    ///\n-    /// Constructs a path like `<self_type as trait_path>::ident<'a, T, A = Bar>`.\n-    pub fn qpath_all(&self,\n-                 self_type: P<ast::Ty>,\n-                 trait_path: ast::Path,\n-                 ident: ast::Ident,\n-                 args: Vec<ast::GenericArg>,\n-                 constraints: Vec<ast::AssocTyConstraint>)\n-                 -> (ast::QSelf, ast::Path) {\n-        let mut path = trait_path;\n-        let args = if !args.is_empty() || !constraints.is_empty() {\n-            ast::AngleBracketedArgs { args, constraints, span: ident.span }.into()\n-        } else {\n-            None\n-        };\n-        path.segments.push(ast::PathSegment { ident, id: ast::DUMMY_NODE_ID, args });\n-\n-        (ast::QSelf {\n-            ty: self_type,\n-            path_span: path.span,\n-            position: path.segments.len() - 1\n-        }, path)\n-    }\n-\n     pub fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy {\n         ast::MutTy {\n             ty,\n@@ -146,10 +108,6 @@ impl<'a> ExtCtxt<'a> {\n                 ast::TyKind::Ptr(self.ty_mt(ty, mutbl)))\n     }\n \n-    pub fn ty_infer(&self, span: Span) -> P<ast::Ty> {\n-        self.ty(span, ast::TyKind::Infer)\n-    }\n-\n     pub fn typaram(&self,\n                span: Span,\n                ident: ast::Ident,\n@@ -217,14 +175,6 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn stmt_semi(&self, expr: P<ast::Expr>) -> ast::Stmt {\n-        ast::Stmt {\n-            id: ast::DUMMY_NODE_ID,\n-            span: expr.span,\n-            node: ast::StmtKind::Semi(expr),\n-        }\n-    }\n-\n     pub fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident,\n                 ex: P<ast::Expr>) -> ast::Stmt {\n         let pat = if mutbl {\n@@ -248,34 +198,6 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn stmt_let_typed(&self,\n-                      sp: Span,\n-                      mutbl: bool,\n-                      ident: ast::Ident,\n-                      typ: P<ast::Ty>,\n-                      ex: P<ast::Expr>)\n-                      -> ast::Stmt {\n-        let pat = if mutbl {\n-            let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Mutable);\n-            self.pat_ident_binding_mode(sp, ident, binding_mode)\n-        } else {\n-            self.pat_ident(sp, ident)\n-        };\n-        let local = P(ast::Local {\n-            pat,\n-            ty: Some(typ),\n-            init: Some(ex),\n-            id: ast::DUMMY_NODE_ID,\n-            span: sp,\n-            attrs: ThinVec::new(),\n-        });\n-        ast::Stmt {\n-            id: ast::DUMMY_NODE_ID,\n-            node: ast::StmtKind::Local(local),\n-            span: sp,\n-        }\n-    }\n-\n     // Generates `let _: Type;`, which is usually used for type assertions.\n     pub fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt {\n         let local = P(ast::Local {\n@@ -330,11 +252,6 @@ impl<'a> ExtCtxt<'a> {\n         self.expr(path.span, ast::ExprKind::Path(None, path))\n     }\n \n-    /// Constructs a `QPath` expression.\n-    pub fn expr_qpath(&self, span: Span, qself: ast::QSelf, path: ast::Path) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprKind::Path(Some(qself), path))\n-    }\n-\n     pub fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr> {\n         self.expr_path(self.path_ident(span, id))\n     }\n@@ -348,27 +265,12 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr_unary(sp, UnOp::Deref, e)\n-    }\n-    pub fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::Unary(op, e))\n+        self.expr(sp, ast::ExprKind::Unary(UnOp::Deref, e))\n     }\n \n-    pub fn expr_field_access(\n-        &self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident,\n-    ) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::Field(expr, ident.with_span_pos(sp)))\n-    }\n-    pub fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: usize) -> P<ast::Expr> {\n-        let ident = Ident::new(sym::integer(idx), sp);\n-        self.expr(sp, ast::ExprKind::Field(expr, ident))\n-    }\n     pub fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::AddrOf(ast::Mutability::Immutable, e))\n     }\n-    pub fn expr_mut_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::AddrOf(ast::Mutability::Mutable, e))\n-    }\n \n     pub fn expr_call(\n         &self, span: Span, expr: P<ast::Expr>, args: Vec<P<ast::Expr>>,\n@@ -424,39 +326,17 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_lit(span, ast::LitKind::Int(i as u128,\n                                               ast::LitIntType::Unsigned(ast::UintTy::Usize)))\n     }\n-    pub fn expr_isize(&self, sp: Span, i: isize) -> P<ast::Expr> {\n-        if i < 0 {\n-            let i = (-i) as u128;\n-            let lit_ty = ast::LitIntType::Signed(ast::IntTy::Isize);\n-            let lit = self.expr_lit(sp, ast::LitKind::Int(i, lit_ty));\n-            self.expr_unary(sp, ast::UnOp::Neg, lit)\n-        } else {\n-            self.expr_lit(sp, ast::LitKind::Int(i as u128,\n-                                                ast::LitIntType::Signed(ast::IntTy::Isize)))\n-        }\n-    }\n     pub fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Int(u as u128,\n                                             ast::LitIntType::Unsigned(ast::UintTy::U32)))\n     }\n-    pub fn expr_u16(&self, sp: Span, u: u16) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Int(u as u128,\n-                                            ast::LitIntType::Unsigned(ast::UintTy::U16)))\n-    }\n-    pub fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Int(u as u128, ast::LitIntType::Unsigned(ast::UintTy::U8)))\n-    }\n     pub fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Bool(value))\n     }\n \n     pub fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Array(exprs))\n     }\n-    pub fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr> {\n-        self.expr_call_global(sp, self.std_path(&[sym::vec, sym::Vec, sym::new]),\n-                              Vec::new())\n-    }\n     pub fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr_addr_of(sp, self.expr_vec(sp, exprs))\n     }\n@@ -473,16 +353,6 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_call_global(sp, some, vec![expr])\n     }\n \n-    pub fn expr_none(&self, sp: Span) -> P<ast::Expr> {\n-        let none = self.std_path(&[sym::option, sym::Option, sym::None]);\n-        let none = self.path_global(sp, none);\n-        self.expr_path(none)\n-    }\n-\n-    pub fn expr_break(&self, sp: Span) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::Break(None, None))\n-    }\n-\n     pub fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::Tup(exprs))\n     }\n@@ -511,11 +381,6 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_call_global(sp, ok, vec![expr])\n     }\n \n-    pub fn expr_err(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        let err = self.std_path(&[sym::result, sym::Result, sym::Err]);\n-        self.expr_call_global(sp, err, vec![expr])\n-    }\n-\n     pub fn expr_try(&self, sp: Span, head: P<ast::Expr>) -> P<ast::Expr> {\n         let ok = self.std_path(&[sym::result, sym::Result, sym::Ok]);\n         let ok_path = self.path_global(sp, ok);\n@@ -632,10 +497,6 @@ impl<'a> ExtCtxt<'a> {\n         self.expr(span, ast::ExprKind::If(cond, self.block_expr(then), els))\n     }\n \n-    pub fn expr_loop(&self, span: Span, block: P<ast::Block>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprKind::Loop(block, None))\n-    }\n-\n     pub fn lambda_fn_decl(&self,\n                       span: Span,\n                       fn_decl: P<ast::FnDecl>,\n@@ -656,7 +517,7 @@ impl<'a> ExtCtxt<'a> {\n               body: P<ast::Expr>)\n               -> P<ast::Expr> {\n         let fn_decl = self.fn_decl(\n-            ids.iter().map(|id| self.param(span, *id, self.ty_infer(span))).collect(),\n+            ids.iter().map(|id| self.param(span, *id, self.ty(span, ast::TyKind::Infer))).collect(),\n             ast::FunctionRetTy::Default(span));\n \n         // FIXME -- We are using `span` as the span of the `|...|`\n@@ -679,16 +540,6 @@ impl<'a> ExtCtxt<'a> {\n         self.lambda(span, vec![ident], body)\n     }\n \n-    pub fn lambda_stmts(&self,\n-                    span: Span,\n-                    ids: Vec<ast::Ident>,\n-                    stmts: Vec<ast::Stmt>)\n-                    -> P<ast::Expr> {\n-        self.lambda(span, ids, self.expr_block(self.block(span, stmts)))\n-    }\n-    pub fn lambda_stmts_0(&self, span: Span, stmts: Vec<ast::Stmt>) -> P<ast::Expr> {\n-        self.lambda0(span, self.expr_block(self.block(span, stmts)))\n-    }\n     pub fn lambda_stmts_1(&self, span: Span, stmts: Vec<ast::Stmt>,\n                       ident: ast::Ident) -> P<ast::Expr> {\n         self.lambda1(span, self.expr_block(self.block(span, stmts)), ident)\n@@ -730,43 +581,6 @@ impl<'a> ExtCtxt<'a> {\n         })\n     }\n \n-    pub fn item_fn_poly(&self,\n-                    span: Span,\n-                    name: Ident,\n-                    inputs: Vec<ast::Param> ,\n-                    output: P<ast::Ty>,\n-                    generics: Generics,\n-                    body: P<ast::Block>) -> P<ast::Item> {\n-        self.item(span,\n-                  name,\n-                  Vec::new(),\n-                  ast::ItemKind::Fn(self.fn_decl(inputs, ast::FunctionRetTy::Ty(output)),\n-                              ast::FnHeader {\n-                                  unsafety: ast::Unsafety::Normal,\n-                                  asyncness: dummy_spanned(ast::IsAsync::NotAsync),\n-                                  constness: dummy_spanned(ast::Constness::NotConst),\n-                                  abi: Abi::Rust,\n-                              },\n-                              generics,\n-                              body))\n-    }\n-\n-    pub fn item_fn(&self,\n-               span: Span,\n-               name: Ident,\n-               inputs: Vec<ast::Param> ,\n-               output: P<ast::Ty>,\n-               body: P<ast::Block>\n-              ) -> P<ast::Item> {\n-        self.item_fn_poly(\n-            span,\n-            name,\n-            inputs,\n-            output,\n-            Generics::default(),\n-            body)\n-    }\n-\n     pub fn variant(&self, span: Span, ident: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant {\n         let fields: Vec<_> = tys.into_iter().map(|ty| {\n             ast::StructField {\n@@ -797,52 +611,6 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn item_enum_poly(&self, span: Span, name: Ident,\n-                      enum_definition: ast::EnumDef,\n-                      generics: Generics) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::Enum(enum_definition, generics))\n-    }\n-\n-    pub fn item_enum(&self, span: Span, name: Ident,\n-                 enum_definition: ast::EnumDef) -> P<ast::Item> {\n-        self.item_enum_poly(span, name, enum_definition,\n-                            Generics::default())\n-    }\n-\n-    pub fn item_struct(&self, span: Span, name: Ident,\n-                   struct_def: ast::VariantData) -> P<ast::Item> {\n-        self.item_struct_poly(\n-            span,\n-            name,\n-            struct_def,\n-            Generics::default()\n-        )\n-    }\n-\n-    pub fn item_struct_poly(&self, span: Span, name: Ident,\n-        struct_def: ast::VariantData, generics: Generics) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::Struct(struct_def, generics))\n-    }\n-\n-    pub fn item_mod(&self, span: Span, inner_span: Span, name: Ident,\n-                attrs: Vec<ast::Attribute>,\n-                items: Vec<P<ast::Item>>) -> P<ast::Item> {\n-        self.item(\n-            span,\n-            name,\n-            attrs,\n-            ast::ItemKind::Mod(ast::Mod {\n-                inner: inner_span,\n-                items,\n-                inline: true\n-            })\n-        )\n-    }\n-\n-    pub fn item_extern_crate(&self, span: Span, name: Ident) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::ExternCrate(None))\n-    }\n-\n     pub fn item_static(&self,\n                    span: Span,\n                    name: Ident,\n@@ -862,86 +630,11 @@ impl<'a> ExtCtxt<'a> {\n         self.item(span, name, Vec::new(), ast::ItemKind::Const(ty, expr))\n     }\n \n-    pub fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n-                    generics: Generics) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::TyAlias(ty, generics))\n-    }\n-\n-    pub fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item> {\n-        self.item_ty_poly(span, name, ty, Generics::default())\n-    }\n-\n     pub fn attribute(&self, mi: ast::MetaItem) -> ast::Attribute {\n         attr::mk_attr_outer(mi)\n     }\n \n     pub fn meta_word(&self, sp: Span, w: ast::Name) -> ast::MetaItem {\n         attr::mk_word_item(Ident::new(w, sp))\n     }\n-\n-    pub fn meta_list_item_word(&self, sp: Span, w: ast::Name) -> ast::NestedMetaItem {\n-        attr::mk_nested_word_item(Ident::new(w, sp))\n-    }\n-\n-    pub fn meta_list(&self, sp: Span, name: ast::Name, mis: Vec<ast::NestedMetaItem>)\n-                 -> ast::MetaItem {\n-        attr::mk_list_item(Ident::new(name, sp), mis)\n-    }\n-\n-    pub fn meta_name_value(&self, span: Span, name: ast::Name, lit_kind: ast::LitKind)\n-                       -> ast::MetaItem {\n-        attr::mk_name_value_item(Ident::new(name, span), lit_kind, span)\n-    }\n-\n-    pub fn item_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: P<ast::UseTree>) -> P<ast::Item> {\n-        P(ast::Item {\n-            id: ast::DUMMY_NODE_ID,\n-            ident: Ident::invalid(),\n-            attrs: vec![],\n-            node: ast::ItemKind::Use(vp),\n-            vis,\n-            span: sp,\n-            tokens: None,\n-        })\n-    }\n-\n-    pub fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item> {\n-        self.item_use_simple_(sp, vis, None, path)\n-    }\n-\n-    pub fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,\n-                        rename: Option<ast::Ident>, path: ast::Path) -> P<ast::Item> {\n-        self.item_use(sp, vis, P(ast::UseTree {\n-            span: sp,\n-            prefix: path,\n-            kind: ast::UseTreeKind::Simple(rename, ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID),\n-        }))\n-    }\n-\n-    pub fn item_use_list(&self, sp: Span, vis: ast::Visibility,\n-                     path: Vec<ast::Ident>, imports: &[ast::Ident]) -> P<ast::Item> {\n-        let imports = imports.iter().map(|id| {\n-            (ast::UseTree {\n-                span: sp,\n-                prefix: self.path(sp, vec![*id]),\n-                kind: ast::UseTreeKind::Simple(None, ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID),\n-            }, ast::DUMMY_NODE_ID)\n-        }).collect();\n-\n-        self.item_use(sp, vis, P(ast::UseTree {\n-            span: sp,\n-            prefix: self.path(sp, path),\n-            kind: ast::UseTreeKind::Nested(imports),\n-        }))\n-    }\n-\n-    pub fn item_use_glob(&self, sp: Span,\n-                     vis: ast::Visibility, path: Vec<ast::Ident>) -> P<ast::Item> {\n-        self.item_use(sp, vis, P(ast::UseTree {\n-            span: sp,\n-            prefix: self.path(sp, path),\n-            kind: ast::UseTreeKind::Glob,\n-        }))\n-    }\n }"}, {"sha": "2ecd9cca3c64b532553645e7ca5407652e463f33", "filename": "src/libsyntax/parse/parser/generics.rs", "status": "modified", "additions": 61, "deletions": 38, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -100,13 +100,31 @@ impl<'a> Parser<'a> {\n             } else if self.check_ident() {\n                 // Parse type parameter.\n                 params.push(self.parse_ty_param(attrs)?);\n+            } else if self.token.can_begin_type() {\n+                // Trying to write an associated type bound? (#26271)\n+                let snapshot = self.clone();\n+                match self.parse_ty_where_predicate() {\n+                    Ok(where_predicate) => {\n+                        self.struct_span_err(\n+                            where_predicate.span(),\n+                            \"bounds on associated types do not belong here\",\n+                        )\n+                        .span_label(where_predicate.span(), \"belongs in `where` clause\")\n+                        .emit();\n+                    }\n+                    Err(mut err) => {\n+                        err.cancel();\n+                        std::mem::replace(self, snapshot);\n+                        break\n+                    }\n+                }\n             } else {\n                 // Check for trailing attributes and stop parsing.\n                 if !attrs.is_empty() {\n                     if !params.is_empty() {\n                         self.struct_span_err(\n                             attrs[0].span,\n-                            &format!(\"trailing attribute after generic parameter\"),\n+                            \"trailing attribute after generic parameter\",\n                         )\n                         .span_label(attrs[0].span, \"attributes must go before parameters\")\n                         .emit();\n@@ -202,43 +220,7 @@ impl<'a> Parser<'a> {\n                     }\n                 ));\n             } else if self.check_type() {\n-                // Parse optional `for<'a, 'b>`.\n-                // This `for` is parsed greedily and applies to the whole predicate,\n-                // the bounded type can have its own `for` applying only to it.\n-                // Examples:\n-                // * `for<'a> Trait1<'a>: Trait2<'a /* ok */>`\n-                // * `(for<'a> Trait1<'a>): Trait2<'a /* not ok */>`\n-                // * `for<'a> for<'b> Trait1<'a, 'b>: Trait2<'a /* ok */, 'b /* not ok */>`\n-                let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-\n-                // Parse type with mandatory colon and (possibly empty) bounds,\n-                // or with mandatory equality sign and the second type.\n-                let ty = self.parse_ty()?;\n-                if self.eat(&token::Colon) {\n-                    let bounds = self.parse_generic_bounds(Some(self.prev_span))?;\n-                    where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n-                        ast::WhereBoundPredicate {\n-                            span: lo.to(self.prev_span),\n-                            bound_generic_params: lifetime_defs,\n-                            bounded_ty: ty,\n-                            bounds,\n-                        }\n-                    ));\n-                // FIXME: Decide what should be used here, `=` or `==`.\n-                // FIXME: We are just dropping the binders in lifetime_defs on the floor here.\n-                } else if self.eat(&token::Eq) || self.eat(&token::EqEq) {\n-                    let rhs_ty = self.parse_ty()?;\n-                    where_clause.predicates.push(ast::WherePredicate::EqPredicate(\n-                        ast::WhereEqPredicate {\n-                            span: lo.to(self.prev_span),\n-                            lhs_ty: ty,\n-                            rhs_ty,\n-                            id: ast::DUMMY_NODE_ID,\n-                        }\n-                    ));\n-                } else {\n-                    return self.unexpected();\n-                }\n+                where_clause.predicates.push(self.parse_ty_where_predicate()?);\n             } else {\n                 break\n             }\n@@ -252,6 +234,47 @@ impl<'a> Parser<'a> {\n         Ok(where_clause)\n     }\n \n+    fn parse_ty_where_predicate(&mut self) -> PResult<'a, ast::WherePredicate> {\n+        let lo = self.token.span;\n+        // Parse optional `for<'a, 'b>`.\n+        // This `for` is parsed greedily and applies to the whole predicate,\n+        // the bounded type can have its own `for` applying only to it.\n+        // Examples:\n+        // * `for<'a> Trait1<'a>: Trait2<'a /* ok */>`\n+        // * `(for<'a> Trait1<'a>): Trait2<'a /* not ok */>`\n+        // * `for<'a> for<'b> Trait1<'a, 'b>: Trait2<'a /* ok */, 'b /* not ok */>`\n+        let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+\n+        // Parse type with mandatory colon and (possibly empty) bounds,\n+        // or with mandatory equality sign and the second type.\n+        let ty = self.parse_ty()?;\n+        if self.eat(&token::Colon) {\n+            let bounds = self.parse_generic_bounds(Some(self.prev_span))?;\n+            Ok(ast::WherePredicate::BoundPredicate(\n+                ast::WhereBoundPredicate {\n+                    span: lo.to(self.prev_span),\n+                    bound_generic_params: lifetime_defs,\n+                    bounded_ty: ty,\n+                    bounds,\n+                }\n+            ))\n+        // FIXME: Decide what should be used here, `=` or `==`.\n+        // FIXME: We are just dropping the binders in lifetime_defs on the floor here.\n+        } else if self.eat(&token::Eq) || self.eat(&token::EqEq) {\n+            let rhs_ty = self.parse_ty()?;\n+            Ok(ast::WherePredicate::EqPredicate(\n+                ast::WhereEqPredicate {\n+                    span: lo.to(self.prev_span),\n+                    lhs_ty: ty,\n+                    rhs_ty,\n+                    id: ast::DUMMY_NODE_ID,\n+                }\n+            ))\n+        } else {\n+            self.unexpected()\n+        }\n+    }\n+\n     pub(super) fn choose_generics_over_qpath(&self) -> bool {\n         // There's an ambiguity between generic parameters and qualified paths in impls.\n         // If we see `<` it may start both, so we have to inspect some following tokens."}, {"sha": "9a4c540dc6f1f349ea7600e655c24edb145f31d4", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -115,7 +115,7 @@ fn cs_clone_shallow(name: &str,\n         let span = cx.with_def_site_ctxt(span);\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[sym::clone, Symbol::intern(helper_name)]),\n-                                        vec![GenericArg::Type(ty)], vec![]);\n+                                        vec![GenericArg::Type(ty)]);\n         stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n     }\n     fn process_variant(cx: &mut ExtCtxt<'_>, stmts: &mut Vec<ast::Stmt>, variant: &VariantData) {"}, {"sha": "c92339dd2fbd5c2141900258d1340a013a063ff4", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -2,7 +2,7 @@ use crate::deriving::path_std;\n use crate::deriving::generic::*;\n use crate::deriving::generic::ty::*;\n \n-use syntax::ast::{self, Expr, MetaItem, GenericArg};\n+use syntax::ast::{self, Ident, Expr, MetaItem, GenericArg};\n use syntax::ext::base::{Annotatable, ExtCtxt, SpecialDerives};\n use syntax::ptr::P;\n use syntax::symbol::{sym, Symbol};\n@@ -16,8 +16,8 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt<'_>,\n     cx.resolver.add_derives(cx.current_expansion.id.expn_data().parent, SpecialDerives::EQ);\n \n     let inline = cx.meta_word(span, sym::inline);\n-    let hidden = cx.meta_list_item_word(span, sym::hidden);\n-    let doc = cx.meta_list(span, sym::doc, vec![hidden]);\n+    let hidden = syntax::attr::mk_nested_word_item(Ident::new(sym::hidden, span));\n+    let doc = syntax::attr::mk_list_item(Ident::new(sym::doc, span), vec![hidden]);\n     let attrs = vec![cx.attribute(inline), cx.attribute(doc)];\n     let trait_def = TraitDef {\n         span,\n@@ -56,7 +56,7 @@ fn cs_total_eq_assert(cx: &mut ExtCtxt<'_>,\n         let span = cx.with_def_site_ctxt(span);\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[sym::cmp, Symbol::intern(helper_name)]),\n-                                        vec![GenericArg::Type(ty)], vec![]);\n+                                        vec![GenericArg::Type(ty)]);\n         stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n     }\n     fn process_variant(cx: &mut ExtCtxt<'_>,"}, {"sha": "fec035d331dc564ee535990383c9ee1ec0de9149", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -664,16 +664,19 @@ impl<'a> TraitDef<'a> {\n         }).collect();\n \n         // Create the type of `self`.\n-        let path = cx.path_all(self.span, false, vec![type_ident], self_params, vec![]);\n+        let path = cx.path_all(self.span, false, vec![type_ident], self_params);\n         let self_type = cx.ty_path(path);\n \n         let attr = cx.attribute(cx.meta_word(self.span, sym::automatically_derived));\n         // Just mark it now since we know that it'll end up used downstream\n         attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n         let unused_qual = {\n-            let word = cx.meta_list_item_word(self.span, Symbol::intern(\"unused_qualifications\"));\n-            cx.attribute(cx.meta_list(self.span, sym::allow, vec![word]))\n+            let word = syntax::attr::mk_nested_word_item(\n+                Ident::new(Symbol::intern(\"unused_qualifications\"), self.span));\n+            let list = syntax::attr::mk_list_item(\n+                Ident::new(sym::allow, self.span), vec![word]);\n+            cx.attribute(list)\n         };\n \n         let mut a = vec![attr, unused_qual];"}, {"sha": "6ae02a5cab199e8cc857370c6d5d4dd8a527d292", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -82,12 +82,12 @@ impl<'a> Path<'a> {\n                        .collect();\n \n         match self.kind {\n-            PathKind::Global => cx.path_all(span, true, idents, params, Vec::new()),\n-            PathKind::Local => cx.path_all(span, false, idents, params, Vec::new()),\n+            PathKind::Global => cx.path_all(span, true, idents, params),\n+            PathKind::Local => cx.path_all(span, false, idents, params),\n             PathKind::Std => {\n                 let def_site = cx.with_def_site_ctxt(DUMMY_SP);\n                 idents.insert(0, Ident::new(kw::DollarCrate, def_site));\n-                cx.path_all(span, false, idents, params, Vec::new())\n+                cx.path_all(span, false, idents, params)\n             }\n         }\n \n@@ -183,7 +183,7 @@ impl<'a> Ty<'a> {\n                     }\n                 }).collect();\n \n-                cx.path_all(span, false, vec![self_ty], params, vec![])\n+                cx.path_all(span, false, vec![self_ty], params)\n             }\n             Literal(ref p) => p.to_path(cx, span, self_ty, generics),\n             Ptr(..) => cx.span_bug(span, \"pointer in a path in generic `derive`\"),"}, {"sha": "02757bf6b1689f730aa63aaea8a747f2870093a0", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -32,7 +32,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                                                                  Ident::new(sym::str, sp)),\n                                                      Some(lt),\n                                                      ast::Mutability::Immutable))],\n-                                     vec![]))\n+                                     ))\n         }\n         Ok(s) => {\n             cx.expr_call_global(sp,"}, {"sha": "6c7e3e3eb98759185ab381a10d89eeec1a99c347", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -145,8 +145,8 @@ pub fn expand_test_or_bench(\n     let mut test_const = cx.item(sp, ast::Ident::new(item.ident.name, sp),\n         vec![\n             // #[cfg(test)]\n-            cx.attribute(cx.meta_list(attr_sp, sym::cfg, vec![\n-                cx.meta_list_item_word(attr_sp, sym::test)\n+            cx.attribute(attr::mk_list_item(ast::Ident::new(sym::cfg, attr_sp), vec![\n+                attr::mk_nested_word_item(ast::Ident::new(sym::test, attr_sp))\n             ])),\n             // #[rustc_test_marker]\n             cx.attribute(cx.meta_word(attr_sp, sym::rustc_test_marker)),"}, {"sha": "72cce9b4843d77547446467016555fa124f9f384", "filename": "src/test/ui/const-generics/issue-64519.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Ftest%2Fui%2Fconst-generics%2Fissue-64519.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Ftest%2Fui%2Fconst-generics%2Fissue-64519.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-64519.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+struct Foo<const D: usize> {\n+    state: Option<[u8; D]>,\n+}\n+\n+impl<const D: usize> Iterator for Foo<{D}> {\n+    type Item = [u8; D];\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if true {\n+            return Some(self.state.unwrap().clone());\n+        } else {\n+            return Some(self.state.unwrap().clone());\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d368f39d903a0107d78caa05b437a723763a43b7", "filename": "src/test/ui/const-generics/issue-64519.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Ftest%2Fui%2Fconst-generics%2Fissue-64519.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Ftest%2Fui%2Fconst-generics%2Fissue-64519.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-64519.stderr?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue-64519.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "09c499452adb687b737843c63ed5c2d4bc8c33e8", "filename": "src/test/ui/issues/issue-33575.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Ftest%2Fui%2Fissues%2Fissue-33575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Ftest%2Fui%2Fissues%2Fissue-33575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33575.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let baz = ().foo(); //~ ERROR no method named `foo` found for type `()` in the current scope\n+    <i32 as std::str::FromStr>::from_str(&baz); // No complaints about `str` being unsized\n+}"}, {"sha": "e6b74d262c340d4f04985e24d1206579378e8296", "filename": "src/test/ui/issues/issue-33575.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Ftest%2Fui%2Fissues%2Fissue-33575.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Ftest%2Fui%2Fissues%2Fissue-33575.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33575.stderr?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -0,0 +1,9 @@\n+error[E0599]: no method named `foo` found for type `()` in the current scope\n+  --> $DIR/issue-33575.rs:2:18\n+   |\n+LL |     let baz = ().foo();\n+   |                  ^^^ method not found in `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "000956ea24fadb5c14d1dd352d6756464fcf276f", "filename": "src/test/ui/parser/assoc-type-in-type-arg.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -0,0 +1,11 @@\n+trait Tr {\n+    type TrSubtype;\n+}\n+\n+struct Bar<'a, Item: Tr, <Item as Tr>::TrSubtype: 'a> {\n+    //~^ ERROR bounds on associated types do not belong here\n+    item: Item,\n+    item_sub: &'a <Item as Tr>::TrSubtype,\n+}\n+\n+fn main() {}"}, {"sha": "b637702f21e90d3452fc5cf1864df81132747180", "filename": "src/test/ui/parser/assoc-type-in-type-arg.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.stderr?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -0,0 +1,8 @@\n+error: bounds on associated types do not belong here\n+  --> $DIR/assoc-type-in-type-arg.rs:5:26\n+   |\n+LL | struct Bar<'a, Item: Tr, <Item as Tr>::TrSubtype: 'a> {\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ belongs in `where` clause\n+\n+error: aborting due to previous error\n+"}, {"sha": "6d38cfc8630d186acff710b6f5907af187453568", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "patch": "@@ -307,7 +307,7 @@ fn collect_lang_features_in(base: &Path, file: &str, bad: &mut bool) -> Features\n                 if prev_since > since {\n                     tidy_error!(\n                         bad,\n-                        \"{}:{}: feature {} is not sorted by since\",\n+                        \"{}:{}: feature {} is not sorted by \\\"since\\\" (version number)\",\n                         path.display(),\n                         line_number,\n                         name,"}]}