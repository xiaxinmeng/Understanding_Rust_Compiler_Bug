{"sha": "e0f72e22985d0d39707f7741c0b63002889c457a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZjcyZTIyOTg1ZDBkMzk3MDdmNzc0MWMwYjYzMDAyODg5YzQ1N2E=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-03-07T22:54:23Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-04-06T00:37:05Z"}, "message": "checkpoint", "tree": {"sha": "0d6efc0ec923db3ce62ee7812c58466b55e6135c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d6efc0ec923db3ce62ee7812c58466b55e6135c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0f72e22985d0d39707f7741c0b63002889c457a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f72e22985d0d39707f7741c0b63002889c457a", "html_url": "https://github.com/rust-lang/rust/commit/e0f72e22985d0d39707f7741c0b63002889c457a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0f72e22985d0d39707f7741c0b63002889c457a/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6f455ebca79b6a3d374158a047b1cdd744ebc5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6f455ebca79b6a3d374158a047b1cdd744ebc5e", "html_url": "https://github.com/rust-lang/rust/commit/d6f455ebca79b6a3d374158a047b1cdd744ebc5e"}], "stats": {"total": 268, "additions": 200, "deletions": 68}, "files": [{"sha": "86802c65781442761f61d3192ee8900ca27d2921", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 174, "deletions": 16, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/e0f72e22985d0d39707f7741c0b63002889c457a/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/e0f72e22985d0d39707f7741c0b63002889c457a/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=e0f72e22985d0d39707f7741c0b63002889c457a", "patch": "@@ -281,7 +281,13 @@ impl Ctx {\n \n         match cmd {\n             ~\"build\" => {\n-                self.build(&os::getcwd(), true, false, false);\n+                if args.len() < 1 {\n+                    return usage::build();\n+                }\n+                let pkgid = PkgId::new(args[0]);\n+                let mut src = PkgSrc::new(&Path(\".\"), &pkgid);\n+                src.find_crates();\n+                src.build(&Path(\".\"));\n             }\n             ~\"clean\" => {\n                 self.clean();\n@@ -927,7 +933,7 @@ pub fn main() {\n \n /// A crate is a unit of Rust code to be compiled into a binary or library\n pub struct Crate {\n-    file: ~str,\n+    file: Path,\n     flags: ~[~str],\n     cfgs: ~[~str]\n }\n@@ -959,44 +965,44 @@ pub fn run(listeners: ~[Listener]) {\n }\n \n pub impl Crate {\n-    pub fn flag(&self, flag: ~str) -> Crate {\n+\n+    static fn new(p: &Path) -> Crate {\n+        Crate {\n+            file: copy *p,\n+            flags: ~[],\n+            cfgs: ~[]\n+        }\n+    }\n+\n+    fn flag(&self, flag: ~str) -> Crate {\n         Crate {\n             flags: vec::append(copy self.flags, ~[flag]),\n             .. copy *self\n         }\n     }\n \n-    pub fn flags(&self, flags: ~[~str]) -> Crate {\n+    fn flags(&self, flags: ~[~str]) -> Crate {\n         Crate {\n             flags: vec::append(copy self.flags, flags),\n             .. copy *self\n         }\n     }\n \n-    pub fn cfg(&self, cfg: ~str) -> Crate {\n+    fn cfg(&self, cfg: ~str) -> Crate {\n         Crate {\n             cfgs: vec::append(copy self.cfgs, ~[cfg]),\n             .. copy *self\n         }\n     }\n \n-    pub fn cfgs(&self, cfgs: ~[~str]) -> Crate {\n+    fn cfgs(&self, cfgs: ~[~str]) -> Crate {\n         Crate {\n             cfgs: vec::append(copy self.cfgs, cfgs),\n             .. copy *self\n         }\n     }\n }\n \n-/// Create a crate target from a source file\n-pub fn Crate(file: ~str) -> Crate {\n-    Crate {\n-        file: file,\n-        flags: ~[],\n-        cfgs: ~[]\n-    }\n-}\n-\n /**\n  * Get the working directory of the package script.\n  * Assumes that the package script has been compiled\n@@ -1026,7 +1032,7 @@ pub fn build(crates: ~[Crate]) -> bool {\n     let test = args[3] == ~\"true\";\n \n     for crates.each |&crate| {\n-        let path = &dir.push_rel(&Path(crate.file)).normalize();\n+        let path = &dir.push_rel(&crate.file).normalize();\n \n         util::note(fmt!(\"compiling %s\", path.to_str()));\n \n@@ -1043,3 +1049,155 @@ pub fn build(crates: ~[Crate]) -> bool {\n \n     success\n }\n+\n+\n+// Path-fragment identifier of a package such as \n+// 'github.com/graydon/test'; must be a relative\n+// path with >=1 component.\n+struct PkgId {\n+    path: Path\n+}\n+\n+condition! {\n+    bad_pkg_id: (::core::path::Path, ~str) -> ::PkgId;\n+}\n+\n+impl PkgId {\n+    static fn new(s: &str) -> PkgId {\n+        use bad_pkg_id::cond;\n+\n+        let p = Path(s);\n+        if p.is_absolute {\n+            return cond.raise((p, ~\"absolute pkgid\"));\n+        }\n+        if p.components.len() < 1 {\n+            return cond.raise((p, ~\"0-length pkgid\"));\n+        }\n+        PkgId {\n+            path: p\n+        }\n+    }\n+}\n+\n+\n+// An enumeration of the unpacked source of a package workspace.\n+// This contains a list of files found in the source workspace.\n+pub struct PkgSrc {\n+    root: Path,\n+    id: PkgId,\n+    libs: ~[Crate],\n+    mains: ~[Crate],\n+    tests: ~[Crate],\n+    benchs: ~[Crate],\n+}\n+\n+condition! {\n+    bad_path: (::core::path::Path, ~str) -> ::core::path::Path;\n+}\n+\n+condition! {\n+    build_err: (~str) -> ();\n+}\n+\n+impl PkgSrc {\n+\n+\n+    static fn new(fs_root: &Path, id: &PkgId) -> PkgSrc {\n+        PkgSrc {\n+            root: copy *fs_root,\n+            id: copy *id,\n+            libs: ~[],\n+            mains: ~[],\n+            tests: ~[],\n+            benchs: ~[]\n+        }\n+    }\n+\n+\n+    fn check_dir(&self) -> Path {\n+        use bad_path::cond;\n+\n+        let dir = self.root.push_rel(&self.id.path).normalize();\n+\n+        if ! os::path_exists(&dir) {\n+            return cond.raise((dir, ~\"missing package dir\"));\n+        }\n+              \n+        if ! os::path_is_dir(&dir) {\n+            return cond.raise((dir, ~\"missing package dir\"));\n+        }\n+\n+        dir\n+    }\n+\n+\n+    fn has_pkg_file(&self) -> bool {\n+        let dir = self.check_dir();\n+        dir.push(\"pkg.rs\").exists()\n+    }\n+\n+\n+    static fn push_crate(cs: &mut ~[Crate], prefix: uint, p: &Path) {\n+        assert p.components.len() > prefix;\n+        let mut sub = Path(\"\");\n+        for vec::slice(p.components, prefix,\n+                       p.components.len()).each |c| {\n+            sub = sub.push(*c);\n+        }\n+        debug!(\"found crate %s\", sub.to_str());\n+        cs.push(Crate::new(&sub));\n+    }\n+\n+    fn find_crates(&mut self) {\n+        use PkgSrc::push_crate;\n+        assert ! self.has_pkg_file();\n+        let dir = self.check_dir();\n+        let prefix = dir.components.len();\n+        for os::walk_dir(&dir) |pth| {\n+            match pth.filename() {\n+                Some(~\"lib.rs\") => push_crate(&mut self.libs,\n+                                              prefix, pth),\n+                Some(~\"main.rs\") => push_crate(&mut self.mains,\n+                                               prefix, pth),\n+                Some(~\"test.rs\") => push_crate(&mut self.tests,\n+                                               prefix, pth),\n+                Some(~\"bench.rs\") => push_crate(&mut self.benchs,\n+                                                prefix, pth),\n+                _ => ()\n+            }\n+        }\n+        debug!(\"found %u libs, %u mains, %u tests, %u benchs\",\n+               self.libs.len(),\n+               self.mains.len(),\n+               self.tests.len(),\n+               self.benchs.len())\n+    }\n+\n+\n+    static fn build_crates(dst_dir: &Path,\n+                           src_dir: &Path,\n+                           crates: &[Crate],\n+                           test: bool) {\n+\n+        for crates.each |&crate| {\n+            let path = &src_dir.push_rel(&crate.file).normalize();\n+            util::note(fmt!(\"compiling %s\", path.to_str()));\n+            if ! util::compile_crate(None, path,\n+                                     dst_dir,\n+                                     crate.flags,\n+                                     crate.cfgs,\n+                                     false, test) {\n+                build_err::cond.raise(fmt!(\"build failure on %s\",\n+                                           path.to_str()));\n+            }\n+        }\n+    }\n+\n+    fn build(&self, dst_dir: &Path) {\n+        let dir = self.check_dir();\n+        PkgSrc::build_crates(dst_dir, &dir, self.libs, false);\n+        PkgSrc::build_crates(dst_dir, &dir, self.mains, false);\n+        PkgSrc::build_crates(dst_dir, &dir, self.tests, true);\n+        PkgSrc::build_crates(dst_dir, &dir, self.benchs, true);\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "776ca3982683487478b57ea4a09bb90dd56f363b", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 26, "deletions": 52, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e0f72e22985d0d39707f7741c0b63002889c457a/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f72e22985d0d39707f7741c0b63002889c457a/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=e0f72e22985d0d39707f7741c0b63002889c457a", "patch": "@@ -597,11 +597,23 @@ pub fn remove_pkg(pkg: &Package) -> bool {\n     true\n }\n \n-pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n-               flags: ~[~str], cfgs: ~[~str], opt: bool, test: bool) -> bool {\n-    let lib_dir = dir.push(~\"lib\");\n-    let bin_dir = dir.push(~\"bin\");\n-    let test_dir = dir.push(~\"test\");\n+pub fn compile_input(sysroot: Option<Path>,\n+                     in_file: &Path,\n+                     out_dir: &Path,\n+                     flags: ~[~str],\n+                     cfgs: ~[~str],\n+                     opt: bool,\n+                     test: bool) -> bool {\n+\n+    assert in_file.components.len() > 1;\n+    let input = driver::file_input(copy *in_file);\n+    let short_name = in_file.pop().filename().get();\n+    let out_file = out_dir.push(os::dll_filename(short_name));\n+\n+    debug!(\"compiling %s into %s\",\n+           in_file.to_str(),\n+           out_file.to_str());\n+\n     let binary = os::args()[0];\n     let matches = getopts(flags, driver::optgroups()).get();\n     let options = @session::options {\n@@ -630,15 +642,12 @@ pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n \n     let mut name = None;\n     let mut vers = None;\n-    let mut uuid = None;\n     let mut crate_type = None;\n \n     fn load_link_attr(mis: ~[@ast::meta_item]) -> (Option<~str>,\n-                                                   Option<~str>,\n                                                    Option<~str>) {\n         let mut name = None;\n         let mut vers = None;\n-        let mut uuid = None;\n \n         for mis.each |a| {\n             match a.node {\n@@ -647,15 +656,14 @@ pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n                     match *v {\n                         ~\"name\" => name = Some(*s),\n                         ~\"vers\" => vers = Some(*s),\n-                        ~\"uuid\" => uuid = Some(*s),\n                         _ => { }\n                     }\n                 }\n                 _ => {}\n             }\n         }\n \n-        (name, vers, uuid)\n+        (name, vers)\n     }\n \n     for crate.node.attrs.each |a| {\n@@ -670,11 +678,10 @@ pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n             ast::meta_list(v, mis) => {\n                 match *v {\n                     ~\"link\" => {\n-                        let (n, v, u) = load_link_attr(mis);\n+                        let (n, v) = load_link_attr(mis);\n \n                         name = n;\n                         vers = v;\n-                        uuid = u;\n                     }\n                     _ => {}\n                 }\n@@ -683,16 +690,6 @@ pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n         }\n     }\n \n-    if name.is_none() || vers.is_none() || uuid.is_none() {\n-        error(~\"link attr without (name, vers, uuid) values\");\n-\n-        return false;\n-    }\n-\n-    let name = name.get();\n-    let vers = vers.get();\n-    let uuid = uuid.get();\n-\n     let is_bin = match crate_type {\n         Some(crate_type) => {\n             match crate_type {\n@@ -712,29 +709,14 @@ pub fn compile_input(sysroot: Option<Path>, input: driver::input, dir: &Path,\n         }\n     };\n \n-    if test {\n-        need_dir(&test_dir);\n-\n-        outputs = driver::build_output_filenames(input, &Some(test_dir),\n-                                                 &None, sess)\n-    }\n-    else if is_bin {\n-        need_dir(&bin_dir);\n-\n-        let path = bin_dir.push(fmt!(\"%s-%s-%s%s\", name,\n-                                                   hash(name + uuid + vers),\n-                                                   vers, exe_suffix()));\n-        outputs = driver::build_output_filenames(input, &None, &Some(path),\n-                                                 sess);\n-    } else {\n-        need_dir(&lib_dir);\n-\n-        outputs = driver::build_output_filenames(input, &Some(lib_dir),\n-                                                 &None, sess)\n-    }\n+    outputs = driver::build_output_filenames(input,\n+                                             &Some(copy *out_dir),\n+                                             &Some(out_file),\n+                                             sess);\n \n     driver::compile_rest(sess, cfg, driver::cu_everything,\n-                         Some(outputs), Some(crate));\n+                         Some(outputs),\n+                         Some(crate));\n \n     true\n }\n@@ -753,15 +735,7 @@ pub fn exe_suffix() -> ~str { ~\"\" }\n pub fn compile_crate(sysroot: Option<Path>, crate: &Path, dir: &Path,\n                      flags: ~[~str], cfgs: ~[~str], opt: bool,\n                      test: bool) -> bool {\n-    compile_input(sysroot, driver::file_input(*crate), dir, flags, cfgs,\n-                  opt, test)\n-}\n-\n-pub fn compile_str(sysroot: Option<Path>, code: ~str, dir: &Path,\n-                   flags: ~[~str], cfgs: ~[~str], opt: bool,\n-                   test: bool) -> bool {\n-    compile_input(sysroot, driver::str_input(code), dir, flags, cfgs,\n-                  opt, test)\n+    compile_input(sysroot, crate, dir, flags, cfgs, opt, test)\n }\n \n #[cfg(windows)]"}]}