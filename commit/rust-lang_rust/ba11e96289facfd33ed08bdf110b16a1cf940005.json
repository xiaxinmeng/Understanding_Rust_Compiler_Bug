{"sha": "ba11e96289facfd33ed08bdf110b16a1cf940005", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMTFlOTYyODlmYWNmZDMzZWQwOGJkZjExMGIxNmExY2Y5NDAwMDU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T19:46:19Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T19:47:02Z"}, "message": "librustc: De-export trans. rs=deexporting", "tree": {"sha": "5c2fcfbf3df79c3cc2d1d3114f3ab571852023b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c2fcfbf3df79c3cc2d1d3114f3ab571852023b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba11e96289facfd33ed08bdf110b16a1cf940005", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba11e96289facfd33ed08bdf110b16a1cf940005", "html_url": "https://github.com/rust-lang/rust/commit/ba11e96289facfd33ed08bdf110b16a1cf940005", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba11e96289facfd33ed08bdf110b16a1cf940005/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ad071627565fa2b1277c05279cf35c2fe3b1ebf", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ad071627565fa2b1277c05279cf35c2fe3b1ebf", "html_url": "https://github.com/rust-lang/rust/commit/7ad071627565fa2b1277c05279cf35c2fe3b1ebf"}], "stats": {"total": 2082, "additions": 1021, "deletions": 1061}, "files": [{"sha": "86dad3b7c1b250aaaa0d2bea034edf2a166d42be", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 136, "deletions": 126, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -173,27 +173,30 @@ use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::print::pprust::pat_to_str;\n \n-fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n+pub fn macros() {\n+    // FIXME(#3114): Macro import/export.\n+    include!(\"macros.rs\");\n+}\n \n // An option identifying a literal: either a unit-like struct or an\n // expression.\n-enum Lit {\n+pub enum Lit {\n     UnitLikeStructLit(ast::node_id),    // the node ID of the pattern\n     ExprLit(@ast::expr),\n     ConstLit(ast::def_id),              // the def ID of the constant\n }\n \n // An option identifying a branch (either a literal, a enum variant or a\n // range)\n-enum Opt {\n+pub enum Opt {\n     lit(Lit),\n     var(/* disr val */int, /* variant dids */{enm: def_id, var: def_id}),\n     range(@ast::expr, @ast::expr),\n     vec_len_eq(uint),\n     vec_len_ge(uint)\n }\n \n-fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n+pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n     match (*a, *b) {\n       (lit(a), lit(b)) => {\n         match (a, b) {\n@@ -240,12 +243,12 @@ fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n     }\n }\n \n-enum opt_result {\n+pub enum opt_result {\n     single_result(Result),\n     lower_bound(Result),\n     range_result(Result, Result),\n }\n-fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n+pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n     let _icx = bcx.insn_ctxt(\"match::trans_opt\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n@@ -279,7 +282,7 @@ fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n     }\n }\n \n-fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> Opt {\n+pub fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> Opt {\n     match tcx.def_map.get(pat_id) {\n         ast::def_variant(enum_id, var_id) => {\n             let variants = ty::enum_variants(tcx, enum_id);\n@@ -299,7 +302,7 @@ fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> Opt {\n     }\n }\n \n-enum TransBindingMode {\n+pub enum TransBindingMode {\n     TrByValue(/*ismove:*/ bool, /*llbinding:*/ ValueRef),\n     TrByRef,\n     TrByImplicitRef\n@@ -313,27 +316,27 @@ enum TransBindingMode {\n  * - `trmode` is the trans binding mode\n  * - `id` is the node id of the binding\n  * - `ty` is the Rust type of the binding */\n-struct BindingInfo {\n+pub struct BindingInfo {\n     llmatch: ValueRef,\n     trmode: TransBindingMode,\n     id: ast::node_id,\n     ty: ty::t,\n }\n \n-type BindingsMap = HashMap<ident, BindingInfo>;\n+pub type BindingsMap = HashMap<ident, BindingInfo>;\n \n-struct ArmData {\n+pub struct ArmData {\n     bodycx: block,\n     arm: &ast::arm,\n     bindings_map: BindingsMap\n }\n \n-struct Match {\n+pub struct Match {\n     pats: ~[@ast::pat],\n     data: @ArmData\n }\n \n-fn match_to_str(bcx: block, m: &Match) -> ~str {\n+pub fn match_to_str(bcx: block, m: &Match) -> ~str {\n     if bcx.sess().verbose() {\n         // for many programs, this just take too long to serialize\n         fmt!(\"%?\", m.pats.map(|p| pat_to_str(*p, bcx.sess().intr())))\n@@ -342,11 +345,11 @@ fn match_to_str(bcx: block, m: &Match) -> ~str {\n     }\n }\n \n-fn matches_to_str(bcx: block, m: &[@Match]) -> ~str {\n+pub fn matches_to_str(bcx: block, m: &[@Match]) -> ~str {\n     fmt!(\"%?\", m.map(|n| match_to_str(bcx, *n)))\n }\n \n-fn has_nested_bindings(m: &[@Match], col: uint) -> bool {\n+pub fn has_nested_bindings(m: &[@Match], col: uint) -> bool {\n     for vec::each(m) |br| {\n         match br.pats[col].node {\n           ast::pat_ident(_, _, Some(_)) => return true,\n@@ -356,10 +359,9 @@ fn has_nested_bindings(m: &[@Match], col: uint) -> bool {\n     return false;\n }\n \n-fn expand_nested_bindings(bcx: block, m: &[@Match/&r],\n-                          col: uint, val: ValueRef)\n-    -> ~[@Match/&r]\n-{\n+pub fn expand_nested_bindings(bcx: block, m: &[@Match/&r],\n+                              col: uint, val: ValueRef)\n+                           -> ~[@Match/&r] {\n     debug!(\"expand_nested_bindings(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -388,9 +390,9 @@ fn expand_nested_bindings(bcx: block, m: &[@Match/&r],\n     }\n }\n \n-type enter_pat = fn(@ast::pat) -> Option<~[@ast::pat]>;\n+pub type enter_pat = fn(@ast::pat) -> Option<~[@ast::pat]>;\n \n-fn assert_is_binding_or_wild(bcx: block, p: @ast::pat) {\n+pub fn assert_is_binding_or_wild(bcx: block, p: @ast::pat) {\n     if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {\n         bcx.sess().span_bug(\n             p.span,\n@@ -399,10 +401,9 @@ fn assert_is_binding_or_wild(bcx: block, p: @ast::pat) {\n     }\n }\n \n-fn enter_match(bcx: block, dm: DefMap, m: &[@Match/&r],\n-               col: uint, val: ValueRef, e: enter_pat)\n-    -> ~[@Match/&r]\n-{\n+pub fn enter_match(bcx: block, dm: DefMap, m: &[@Match/&r],\n+                   col: uint, val: ValueRef, e: enter_pat)\n+                -> ~[@Match/&r] {\n     debug!(\"enter_match(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -442,10 +443,9 @@ fn enter_match(bcx: block, dm: DefMap, m: &[@Match/&r],\n     return result;\n }\n \n-fn enter_default(bcx: block, dm: DefMap, m: &[@Match/&r],\n-                 col: uint, val: ValueRef)\n-    -> ~[@Match/&r]\n-{\n+pub fn enter_default(bcx: block, dm: DefMap, m: &[@Match/&r],\n+                     col: uint, val: ValueRef)\n+                  -> ~[@Match/&r] {\n     debug!(\"enter_default(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -487,10 +487,9 @@ fn enter_default(bcx: block, dm: DefMap, m: &[@Match/&r],\n // <nmatsakis> so all patterns must either be records (resp. tuples) or\n //             wildcards\n \n-fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n-             variant_size: uint, val: ValueRef)\n-    -> ~[@Match/&r]\n-{\n+pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n+                 variant_size: uint, val: ValueRef)\n+              -> ~[@Match/&r] {\n     debug!(\"enter_opt(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -591,8 +590,13 @@ fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n     }\n }\n \n-fn enter_rec_or_struct(bcx: block, dm: DefMap, m: &[@Match/&r], col: uint,\n-                       fields: ~[ast::ident], val: ValueRef) -> ~[@Match/&r] {\n+pub fn enter_rec_or_struct(bcx: block,\n+                           dm: DefMap,\n+                           m: &[@Match/&r],\n+                           col: uint,\n+                           fields: ~[ast::ident],\n+                           val: ValueRef)\n+                        -> ~[@Match/&r] {\n     debug!(\"enter_rec_or_struct(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -621,10 +625,9 @@ fn enter_rec_or_struct(bcx: block, dm: DefMap, m: &[@Match/&r], col: uint,\n     }\n }\n \n-fn enter_tup(bcx: block, dm: DefMap, m: &[@Match/&r],\n-             col: uint, val: ValueRef, n_elts: uint)\n-    -> ~[@Match/&r]\n-{\n+pub fn enter_tup(bcx: block, dm: DefMap, m: &[@Match/&r],\n+                 col: uint, val: ValueRef, n_elts: uint)\n+              -> ~[@Match/&r] {\n     debug!(\"enter_tup(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -646,10 +649,13 @@ fn enter_tup(bcx: block, dm: DefMap, m: &[@Match/&r],\n     }\n }\n \n-fn enter_tuple_struct(bcx: block, dm: DefMap, m: &[@Match/&r], col: uint,\n-                      val: ValueRef, n_elts: uint)\n-    -> ~[@Match/&r]\n-{\n+pub fn enter_tuple_struct(bcx: block,\n+                          dm: DefMap,\n+                          m: &[@Match/&r],\n+                          col: uint,\n+                          val: ValueRef,\n+                          n_elts: uint)\n+                       -> ~[@Match/&r] {\n     debug!(\"enter_tuple_struct(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -669,10 +675,12 @@ fn enter_tuple_struct(bcx: block, dm: DefMap, m: &[@Match/&r], col: uint,\n     }\n }\n \n-fn enter_box(bcx: block, dm: DefMap, m: &[@Match/&r],\n-             col: uint, val: ValueRef)\n-    -> ~[@Match/&r]\n-{\n+pub fn enter_box(bcx: block,\n+                 dm: DefMap,\n+                 m: &[@Match/&r],\n+                 col: uint,\n+                 val: ValueRef)\n+              -> ~[@Match/&r] {\n     debug!(\"enter_box(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -694,10 +702,12 @@ fn enter_box(bcx: block, dm: DefMap, m: &[@Match/&r],\n     }\n }\n \n-fn enter_uniq(bcx: block, dm: DefMap, m: &[@Match/&r],\n-              col: uint, val: ValueRef)\n-    -> ~[@Match/&r]\n-{\n+pub fn enter_uniq(bcx: block,\n+                  dm: DefMap,\n+                  m: &[@Match/&r],\n+                  col: uint,\n+                  val: ValueRef)\n+               -> ~[@Match/&r] {\n     debug!(\"enter_uniq(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -719,10 +729,12 @@ fn enter_uniq(bcx: block, dm: DefMap, m: &[@Match/&r],\n     }\n }\n \n-fn enter_region(bcx: block, dm: DefMap, m: &[@Match/&r],\n-                col: uint, val: ValueRef)\n-    -> ~[@Match/&r]\n-{\n+pub fn enter_region(bcx: block,\n+                    dm: DefMap,\n+                    m: &[@Match/&r],\n+                    col: uint,\n+                    val: ValueRef)\n+                 -> ~[@Match/&r] {\n     debug!(\"enter_region(bcx=%s, m=%s, col=%u, val=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -747,7 +759,7 @@ fn enter_region(bcx: block, dm: DefMap, m: &[@Match/&r],\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n+pub fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n     fn add_to_set(tcx: ty::ctxt, set: &DVec<Opt>, val: Opt) {\n         if set.any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n@@ -806,11 +818,11 @@ fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n     return dvec::unwrap(move found);\n }\n \n-fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n-                        vdefs: {enm: def_id, var: def_id},\n-                        val: ValueRef)\n-    -> {vals: ~[ValueRef], bcx: block}\n-{\n+pub fn extract_variant_args(bcx: block,\n+                            pat_id: ast::node_id,\n+                            vdefs: {enm: def_id, var: def_id},\n+                            val: ValueRef)\n+                         -> {vals: ~[ValueRef], bcx: block} {\n     let _icx = bcx.insn_ctxt(\"match::extract_variant_args\");\n     let ccx = bcx.fcx.ccx;\n     let enum_ty_substs = match ty::get(node_id_type(bcx, pat_id)).sty {\n@@ -838,10 +850,12 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     return {vals: args, bcx: bcx};\n }\n \n-fn extract_vec_elems(bcx: block, pat_id: ast::node_id,\n-                     elem_count: uint, tail: bool, val: ValueRef)\n-    -> {vals: ~[ValueRef], bcx: block}\n-{\n+pub fn extract_vec_elems(bcx: block,\n+                         pat_id: ast::node_id,\n+                         elem_count: uint,\n+                         tail: bool,\n+                         val: ValueRef)\n+                      -> {vals: ~[ValueRef], bcx: block} {\n     let _icx = bcx.insn_ctxt(\"match::extract_vec_elems\");\n     let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n     let unboxed = load_if_immediate(bcx, val, vt.vec_ty);\n@@ -874,8 +888,10 @@ fn extract_vec_elems(bcx: block, pat_id: ast::node_id,\n }\n \n // NB: This function does not collect fields from struct-like enum variants.\n-fn collect_record_or_struct_fields(bcx: block, m: &[@Match], col: uint) ->\n-                                   ~[ast::ident] {\n+pub fn collect_record_or_struct_fields(bcx: block,\n+                                       m: &[@Match],\n+                                       col: uint)\n+                                    -> ~[ast::ident] {\n     let mut fields: ~[ast::ident] = ~[];\n     for vec::each(m) |br| {\n         match /*bad*/copy br.pats[col].node {\n@@ -901,11 +917,11 @@ fn collect_record_or_struct_fields(bcx: block, m: &[@Match], col: uint) ->\n     }\n }\n \n-fn root_pats_as_necessary(bcx: block,\n-                          m: &[@Match],\n-                          col: uint,\n-                          val: ValueRef)\n-                       -> block {\n+pub fn root_pats_as_necessary(bcx: block,\n+                              m: &[@Match],\n+                              col: uint,\n+                              val: ValueRef)\n+                           -> block {\n     let mut bcx = bcx;\n     for vec::each(m) |br| {\n         let pat_id = br.pats[col].id;\n@@ -945,23 +961,23 @@ macro_rules! any_pat (\n     )\n )\n \n-fn any_box_pat(m: &[@Match], col: uint) -> bool {\n+pub fn any_box_pat(m: &[@Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_box(_))\n }\n \n-fn any_uniq_pat(m: &[@Match], col: uint) -> bool {\n+pub fn any_uniq_pat(m: &[@Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_uniq(_))\n }\n \n-fn any_region_pat(m: &[@Match], col: uint) -> bool {\n+pub fn any_region_pat(m: &[@Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_region(_))\n }\n \n-fn any_tup_pat(m: &[@Match], col: uint) -> bool {\n+pub fn any_tup_pat(m: &[@Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_tup(_))\n }\n \n-fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n+pub fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n     vec::any(m, |br| {\n         let pat = br.pats[col];\n         match pat.node {\n@@ -976,9 +992,9 @@ fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n     })\n }\n \n-type mk_fail = fn@() -> BasicBlockRef;\n+pub type mk_fail = fn@() -> BasicBlockRef;\n \n-fn pick_col(m: &[@Match]) -> uint {\n+pub fn pick_col(m: &[@Match]) -> uint {\n     fn score(p: @ast::pat) -> uint {\n         match p.node {\n           ast::pat_lit(_) | ast::pat_enum(_, _) | ast::pat_range(_, _) => 1u,\n@@ -1008,18 +1024,15 @@ fn pick_col(m: &[@Match]) -> uint {\n     return best_col;\n }\n \n-enum branch_kind { no_branch, single, switch, compare, compare_vec_len, }\n-\n-impl branch_kind : cmp::Eq {\n-    pure fn eq(&self, other: &branch_kind) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &branch_kind) -> bool { !(*self).eq(other) }\n-}\n+#[deriving_eq]\n+pub enum branch_kind { no_branch, single, switch, compare, compare_vec_len, }\n \n // Compiles a comparison between two things.\n-fn compare_values(cx: block, lhs: ValueRef, rhs: ValueRef, rhs_t: ty::t) ->\n-                  Result {\n+pub fn compare_values(cx: block,\n+                      lhs: ValueRef,\n+                      rhs: ValueRef,\n+                      rhs_t: ty::t)\n+                   -> Result {\n     let _icx = cx.insn_ctxt(\"compare_values\");\n     if ty::type_is_scalar(rhs_t) {\n       let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::eq);\n@@ -1059,11 +1072,10 @@ fn compare_values(cx: block, lhs: ValueRef, rhs: ValueRef, rhs_t: ty::t) ->\n     }\n }\n \n-fn store_non_ref_bindings(bcx: block,\n-                          data: &ArmData,\n-                          opt_temp_cleanups: Option<&DVec<ValueRef>>)\n-    -> block\n-{\n+pub fn store_non_ref_bindings(bcx: block,\n+                              data: &ArmData,\n+                              opt_temp_cleanups: Option<&DVec<ValueRef>>)\n+                           -> block {\n     /*!\n      *\n      * For each copy/move binding, copy the value from the value\n@@ -1099,9 +1111,9 @@ fn store_non_ref_bindings(bcx: block,\n     return bcx;\n }\n \n-fn insert_lllocals(bcx: block,\n-                   data: &ArmData,\n-                   add_cleans: bool) -> block {\n+pub fn insert_lllocals(bcx: block,\n+                       data: &ArmData,\n+                       add_cleans: bool) -> block {\n     /*!\n      *\n      * For each binding in `data.bindings_map`, adds an appropriate entry into\n@@ -1139,14 +1151,13 @@ fn insert_lllocals(bcx: block,\n     return bcx;\n }\n \n-fn compile_guard(bcx: block,\n-                 guard_expr: @ast::expr,\n-                 data: &ArmData,\n-                 m: &[@Match],\n-                 vals: &[ValueRef],\n-                 chk: Option<mk_fail>)\n-    -> block\n-{\n+pub fn compile_guard(bcx: block,\n+                     guard_expr: @ast::expr,\n+                     data: &ArmData,\n+                     m: &[@Match],\n+                     vals: &[ValueRef],\n+                     chk: Option<mk_fail>)\n+                  -> block {\n     debug!(\"compile_guard(bcx=%s, guard_expr=%s, m=%s, vals=%?)\",\n            bcx.to_str(),\n            bcx.expr_to_str(guard_expr),\n@@ -1194,11 +1205,10 @@ fn compile_guard(bcx: block,\n     }\n }\n \n-fn compile_submatch(bcx: block,\n-                    m: &[@Match],\n-                    vals: &[ValueRef],\n-                    chk: Option<mk_fail>)\n-{\n+pub fn compile_submatch(bcx: block,\n+                        m: &[@Match],\n+                        vals: &[ValueRef],\n+                        chk: Option<mk_fail>) {\n     debug!(\"compile_submatch(bcx=%s, m=%s, vals=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n@@ -1530,21 +1540,21 @@ fn compile_submatch(bcx: block,\n     }\n }\n \n-fn trans_match(bcx: block,\n-             match_expr: @ast::expr,\n-             discr_expr: @ast::expr,\n-             arms: ~[ast::arm],\n-             dest: Dest) -> block {\n+pub fn trans_match(bcx: block,\n+                   match_expr: @ast::expr,\n+                   discr_expr: @ast::expr,\n+                   arms: ~[ast::arm],\n+                   dest: Dest) -> block {\n     let _icx = bcx.insn_ctxt(\"match::trans_match\");\n     do with_scope(bcx, match_expr.info(), ~\"match\") |bcx| {\n         trans_match_inner(bcx, discr_expr, arms, dest)\n     }\n }\n \n-fn trans_match_inner(scope_cx: block,\n-                   discr_expr: @ast::expr,\n-                   arms: &[ast::arm],\n-                   dest: Dest) -> block {\n+pub fn trans_match_inner(scope_cx: block,\n+                         discr_expr: @ast::expr,\n+                         arms: &[ast::arm],\n+                         dest: Dest) -> block {\n     let _icx = scope_cx.insn_ctxt(\"match::trans_match_inner\");\n     let mut bcx = scope_cx;\n     let tcx = bcx.tcx();\n@@ -1659,20 +1669,20 @@ fn trans_match_inner(scope_cx: block,\n     }\n }\n \n-enum IrrefutablePatternBindingMode {\n+pub enum IrrefutablePatternBindingMode {\n     // Stores the association between node ID and LLVM value in `lllocals`.\n     BindLocal,\n     // Stores the association between node ID and LLVM value in `llargs`.\n     BindArgument\n }\n \n // Not match-related, but similar to the pattern-munging code above\n-fn bind_irrefutable_pat(bcx: block,\n-                        pat: @ast::pat,\n-                        val: ValueRef,\n-                        make_copy: bool,\n-                        binding_mode: IrrefutablePatternBindingMode)\n-                     -> block {\n+pub fn bind_irrefutable_pat(bcx: block,\n+                            pat: @ast::pat,\n+                            val: ValueRef,\n+                            make_copy: bool,\n+                            binding_mode: IrrefutablePatternBindingMode)\n+                         -> block {\n     let _icx = bcx.insn_ctxt(\"match::bind_irrefutable_pat\");\n     let ccx = bcx.fcx.ccx;\n     let mut bcx = bcx;"}, {"sha": "864ffd5e82021c885fbd2f35510ec1b3085bf441", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 292, "deletions": 285, "changes": 577, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -55,6 +55,7 @@ use middle::trans::expr;\n use middle::trans::foreign;\n use middle::trans::glue;\n use middle::trans::inline;\n+use middle::trans::machine;\n use middle::trans::meth;\n use middle::trans::monomorphize;\n use middle::trans::reachable;\n@@ -88,7 +89,7 @@ use syntax::visit;\n use syntax::visit::vt;\n use syntax::{ast, ast_util, codemap, ast_map};\n \n-struct icx_popper {\n+pub struct icx_popper {\n     ccx: @crate_ctxt,\n     drop {\n       if self.ccx.sess.count_llvm_insns() {\n@@ -97,17 +98,17 @@ struct icx_popper {\n     }\n }\n \n-fn icx_popper(ccx: @crate_ctxt) -> icx_popper {\n+pub fn icx_popper(ccx: @crate_ctxt) -> icx_popper {\n     icx_popper {\n         ccx: ccx\n     }\n }\n \n-trait get_insn_ctxt {\n+pub trait get_insn_ctxt {\n     fn insn_ctxt(s: &str) -> icx_popper;\n }\n \n-impl @crate_ctxt: get_insn_ctxt {\n+pub impl @crate_ctxt: get_insn_ctxt {\n     fn insn_ctxt(s: &str) -> icx_popper {\n         debug!(\"new insn_ctxt: %s\", s);\n         if self.sess.count_llvm_insns() {\n@@ -117,27 +118,27 @@ impl @crate_ctxt: get_insn_ctxt {\n     }\n }\n \n-impl block: get_insn_ctxt {\n+pub impl block: get_insn_ctxt {\n     fn insn_ctxt(s: &str) -> icx_popper {\n         self.ccx().insn_ctxt(s)\n     }\n }\n \n-impl fn_ctxt: get_insn_ctxt {\n+pub impl fn_ctxt: get_insn_ctxt {\n     fn insn_ctxt(s: &str) -> icx_popper {\n         self.ccx.insn_ctxt(s)\n     }\n }\n \n-fn log_fn_time(ccx: @crate_ctxt, +name: ~str, start: time::Timespec,\n-               end: time::Timespec) {\n+pub fn log_fn_time(ccx: @crate_ctxt, +name: ~str, start: time::Timespec,\n+                   end: time::Timespec) {\n     let elapsed = 1000 * ((end.sec - start.sec) as int) +\n         ((end.nsec as int) - (start.nsec as int)) / 1000000;\n     ccx.stats.fn_times.push({ident: name, time: elapsed});\n }\n \n-fn decl_fn(llmod: ModuleRef, name: ~str, cc: lib::llvm::CallConv,\n-           llty: TypeRef) -> ValueRef {\n+pub fn decl_fn(llmod: ModuleRef, name: ~str, cc: lib::llvm::CallConv,\n+               llty: TypeRef) -> ValueRef {\n     let llfn: ValueRef = str::as_c_str(name, |buf| {\n         unsafe {\n             llvm::LLVMGetOrInsertFunction(llmod, buf, llty)\n@@ -149,24 +150,25 @@ fn decl_fn(llmod: ModuleRef, name: ~str, cc: lib::llvm::CallConv,\n     return llfn;\n }\n \n-fn decl_cdecl_fn(llmod: ModuleRef, +name: ~str, llty: TypeRef) -> ValueRef {\n+pub fn decl_cdecl_fn(llmod: ModuleRef, +name: ~str, llty: TypeRef)\n+                  -> ValueRef {\n     return decl_fn(llmod, name, lib::llvm::CCallConv, llty);\n }\n \n // Only use this if you are going to actually define the function. It's\n // not valid to simply declare a function as internal.\n-fn decl_internal_cdecl_fn(llmod: ModuleRef, +name: ~str, llty: TypeRef) ->\n+pub fn decl_internal_cdecl_fn(llmod: ModuleRef, +name: ~str, llty: TypeRef) ->\n    ValueRef {\n     let llfn = decl_cdecl_fn(llmod, name, llty);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     return llfn;\n }\n \n-fn get_extern_fn(externs: HashMap<~str, ValueRef>,\n-                 llmod: ModuleRef,\n-                 +name: ~str,\n-                 cc: lib::llvm::CallConv,\n-                 ty: TypeRef) -> ValueRef {\n+pub fn get_extern_fn(externs: HashMap<~str, ValueRef>,\n+                     llmod: ModuleRef,\n+                     +name: ~str,\n+                     cc: lib::llvm::CallConv,\n+                     ty: TypeRef) -> ValueRef {\n     // XXX: Bad copy.\n     if externs.contains_key(copy name) { return externs.get(name); }\n     // XXX: Bad copy.\n@@ -175,8 +177,8 @@ fn get_extern_fn(externs: HashMap<~str, ValueRef>,\n     return f;\n }\n \n-fn get_extern_const(externs: HashMap<~str, ValueRef>, llmod: ModuleRef,\n-                    +name: ~str, ty: TypeRef) -> ValueRef {\n+pub fn get_extern_const(externs: HashMap<~str, ValueRef>, llmod: ModuleRef,\n+                        +name: ~str, ty: TypeRef) -> ValueRef {\n     unsafe {\n         // XXX: Bad copy.\n         if externs.contains_key(copy name) { return externs.get(name); }\n@@ -188,11 +190,11 @@ fn get_extern_const(externs: HashMap<~str, ValueRef>, llmod: ModuleRef,\n     }\n }\n \n-fn get_simple_extern_fn(cx: block,\n-                        externs: HashMap<~str, ValueRef>,\n-                        llmod: ModuleRef,\n-                        +name: ~str,\n-                        n_args: int) -> ValueRef {\n+    fn get_simple_extern_fn(cx: block,\n+                            externs: HashMap<~str, ValueRef>,\n+                            llmod: ModuleRef,\n+                            +name: ~str,\n+                            n_args: int) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"get_simple_extern_fn\");\n     let ccx = cx.fcx.ccx;\n     let inputs = vec::from_elem(n_args as uint, ccx.int_type);\n@@ -201,8 +203,8 @@ fn get_simple_extern_fn(cx: block,\n     return get_extern_fn(externs, llmod, name, lib::llvm::CCallConv, t);\n }\n \n-fn trans_foreign_call(cx: block, externs: HashMap<~str, ValueRef>,\n-                      llmod: ModuleRef, +name: ~str, args: ~[ValueRef]) ->\n+pub fn trans_foreign_call(cx: block, externs: HashMap<~str, ValueRef>,\n+                          llmod: ModuleRef, +name: ~str, args: ~[ValueRef]) ->\n    ValueRef {\n     let _icx = cx.insn_ctxt(\"trans_foreign_call\");\n     let n = args.len() as int;\n@@ -211,13 +213,13 @@ fn trans_foreign_call(cx: block, externs: HashMap<~str, ValueRef>,\n     return Call(cx, llforeign, args);\n }\n \n-fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n+pub fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"umax\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n     return Select(cx, cond, b, a);\n }\n \n-fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n+pub fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"umin\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n     return Select(cx, cond, a, b);\n@@ -226,15 +228,15 @@ fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n // Given a pointer p, returns a pointer sz(p) (i.e., inc'd by sz bytes).\n // The type of the returned pointer is always i8*.  If you care about the\n // return type, use bump_ptr().\n-fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n+pub fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"ptr_offs\");\n     let raw = PointerCast(bcx, base, T_ptr(T_i8()));\n     InBoundsGEP(bcx, raw, ~[sz])\n }\n \n // Increment a pointer by a given amount and then cast it to be a pointer\n // to a given type.\n-fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n+pub fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n    ValueRef {\n     let _icx = bcx.insn_ctxt(\"bump_ptr\");\n     let ccx = bcx.ccx();\n@@ -246,9 +248,9 @@ fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n // Replacement for the LLVM 'GEP' instruction when field indexing into a enum.\n // @llblobptr is the data part of a enum value; its actual type\n // is meaningless, as it will be cast away.\n-fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n-            variant_id: ast::def_id, ty_substs: ~[ty::t],\n-            ix: uint) -> ValueRef {\n+pub fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n+                variant_id: ast::def_id, ty_substs: ~[ty::t],\n+                ix: uint) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"GEP_enum\");\n     let ccx = bcx.ccx();\n     let variant = ty::enum_variant_with_id(ccx.tcx, enum_id, variant_id);\n@@ -267,9 +269,9 @@ fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n // known.\n //\n // The runtime equivalent is box_body() in \"rust_internal.h\".\n-fn opaque_box_body(bcx: block,\n-                   body_t: ty::t,\n-                   boxptr: ValueRef) -> ValueRef {\n+pub fn opaque_box_body(bcx: block,\n+                       body_t: ty::t,\n+                       boxptr: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"opaque_box_body\");\n     let ccx = bcx.ccx();\n     let boxptr = PointerCast(bcx, boxptr, T_ptr(T_box_header(ccx)));\n@@ -279,10 +281,10 @@ fn opaque_box_body(bcx: block,\n \n // malloc_raw_dyn: allocates a box to contain a given type, but with a\n // potentially dynamic size.\n-fn malloc_raw_dyn(bcx: block,\n-                  t: ty::t,\n-                  heap: heap,\n-                  size: ValueRef) -> Result {\n+pub fn malloc_raw_dyn(bcx: block,\n+                      t: ty::t,\n+                      heap: heap,\n+                      size: ValueRef) -> Result {\n     let _icx = bcx.insn_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n@@ -322,7 +324,7 @@ fn malloc_raw_dyn(bcx: block,\n * address space 0. Otherwise the resulting (non-box) pointer will be in the\n * wrong address space and thus be the wrong type.\n */\n-fn non_gc_box_cast(bcx: block, val: ValueRef) -> ValueRef {\n+pub fn non_gc_box_cast(bcx: block, val: ValueRef) -> ValueRef {\n     unsafe {\n         debug!(\"non_gc_box_cast\");\n         add_comment(bcx, ~\"non_gc_box_cast\");\n@@ -336,13 +338,13 @@ fn non_gc_box_cast(bcx: block, val: ValueRef) -> ValueRef {\n // malloc_raw: expects an unboxed type and returns a pointer to\n // enough space for a box of that type.  This includes a rust_opaque_box\n // header.\n-fn malloc_raw(bcx: block, t: ty::t, heap: heap) -> Result {\n+pub fn malloc_raw(bcx: block, t: ty::t, heap: heap) -> Result {\n     malloc_raw_dyn(bcx, t, heap, llsize_of(bcx.ccx(), type_of(bcx.ccx(), t)))\n }\n \n // malloc_general_dyn: usefully wraps malloc_raw_dyn; allocates a box,\n // and pulls out the body\n-fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef)\n+pub fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef)\n     -> {bcx: block, box: ValueRef, body: ValueRef} {\n     let _icx = bcx.insn_ctxt(\"malloc_general\");\n     let Result {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, t, heap, size);\n@@ -351,27 +353,27 @@ fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef)\n     return {bcx: bcx, box: llbox, body: body};\n }\n \n-fn malloc_general(bcx: block, t: ty::t, heap: heap)\n+pub fn malloc_general(bcx: block, t: ty::t, heap: heap)\n     -> {bcx: block, box: ValueRef, body: ValueRef} {\n     malloc_general_dyn(bcx, t, heap,\n                        llsize_of(bcx.ccx(), type_of(bcx.ccx(), t)))\n }\n-fn malloc_boxed(bcx: block, t: ty::t)\n+pub fn malloc_boxed(bcx: block, t: ty::t)\n     -> {bcx: block, box: ValueRef, body: ValueRef} {\n     malloc_general(bcx, t, heap_shared)\n }\n-fn malloc_unique(bcx: block, t: ty::t)\n+pub fn malloc_unique(bcx: block, t: ty::t)\n     -> {bcx: block, box: ValueRef, body: ValueRef} {\n     malloc_general(bcx, t, heap_exchange)\n }\n \n // Type descriptor and type glue stuff\n \n-fn get_tydesc_simple(ccx: @crate_ctxt, t: ty::t) -> ValueRef {\n+pub fn get_tydesc_simple(ccx: @crate_ctxt, t: ty::t) -> ValueRef {\n     get_tydesc(ccx, t).tydesc\n }\n \n-fn get_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n+pub fn get_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     match ccx.tydescs.find(t) {\n       Some(inf) => inf,\n       _ => {\n@@ -383,15 +385,15 @@ fn get_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     }\n }\n \n-fn set_no_inline(f: ValueRef) {\n+pub fn set_no_inline(f: ValueRef) {\n     unsafe {\n         llvm::LLVMAddFunctionAttr(f,\n                                   lib::llvm::NoInlineAttribute as c_ulonglong,\n                                   0u as c_ulonglong);\n     }\n }\n \n-fn set_no_unwind(f: ValueRef) {\n+pub fn set_no_unwind(f: ValueRef) {\n     unsafe {\n         llvm::LLVMAddFunctionAttr(f,\n                                   lib::llvm::NoUnwindAttribute as c_ulonglong,\n@@ -401,23 +403,23 @@ fn set_no_unwind(f: ValueRef) {\n \n // Tell LLVM to emit the information necessary to unwind the stack for the\n // function f.\n-fn set_uwtable(f: ValueRef) {\n+pub fn set_uwtable(f: ValueRef) {\n     unsafe {\n         llvm::LLVMAddFunctionAttr(f,\n                                   lib::llvm::UWTableAttribute as c_ulonglong,\n                                   0u as c_ulonglong);\n     }\n }\n \n-fn set_inline_hint(f: ValueRef) {\n+pub fn set_inline_hint(f: ValueRef) {\n     unsafe {\n         llvm::LLVMAddFunctionAttr(f, lib::llvm::InlineHintAttribute\n                                   as c_ulonglong, 0u as c_ulonglong);\n     }\n }\n \n-fn set_inline_hint_if_appr(attrs: ~[ast::attribute],\n-                           llfn: ValueRef) {\n+pub fn set_inline_hint_if_appr(attrs: ~[ast::attribute],\n+                               llfn: ValueRef) {\n     match attr::find_inline_attr(attrs) {\n       attr::ia_hint => set_inline_hint(llfn),\n       attr::ia_always => set_always_inline(llfn),\n@@ -426,28 +428,28 @@ fn set_inline_hint_if_appr(attrs: ~[ast::attribute],\n     }\n }\n \n-fn set_always_inline(f: ValueRef) {\n+pub fn set_always_inline(f: ValueRef) {\n     unsafe {\n         llvm::LLVMAddFunctionAttr(f, lib::llvm::AlwaysInlineAttribute\n                                   as c_ulonglong, 0u as c_ulonglong);\n     }\n }\n \n-fn set_custom_stack_growth_fn(f: ValueRef) {\n+pub fn set_custom_stack_growth_fn(f: ValueRef) {\n     unsafe {\n         llvm::LLVMAddFunctionAttr(f, 0u as c_ulonglong, 1u as c_ulonglong);\n     }\n }\n \n-fn set_glue_inlining(f: ValueRef, t: ty::t) {\n+pub fn set_glue_inlining(f: ValueRef, t: ty::t) {\n     if ty::type_is_structural(t) {\n         set_no_inline(f);\n     } else { set_always_inline(f); }\n }\n \n // Double-check that we never ask LLVM to declare the same symbol twice. It\n // silently mangles such symbols, breaking our linkage model.\n-fn note_unique_llvm_symbol(ccx: @crate_ctxt, +sym: ~str) {\n+pub fn note_unique_llvm_symbol(ccx: @crate_ctxt, +sym: ~str) {\n     // XXX: Bad copy.\n     if ccx.all_llvm_symbols.contains_key(copy sym) {\n         ccx.sess.bug(~\"duplicate LLVM symbol: \" + sym);\n@@ -456,8 +458,8 @@ fn note_unique_llvm_symbol(ccx: @crate_ctxt, +sym: ~str) {\n }\n \n \n-fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n-                parent_id: ast::def_id, substs: ~[ty::t])\n+pub fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n+                    parent_id: ast::def_id, substs: ~[ty::t])\n    -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"trans_res_dtor\");\n     if !substs.is_empty() {\n@@ -480,7 +482,7 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n }\n \n // Structural comparison: a rather involved form of glue.\n-fn maybe_name_value(cx: @crate_ctxt, v: ValueRef, s: ~str) {\n+pub fn maybe_name_value(cx: @crate_ctxt, v: ValueRef, s: ~str) {\n     if cx.sess.opts.save_temps {\n         let _: () = str::as_c_str(s, |buf| {\n             unsafe {\n@@ -492,10 +494,10 @@ fn maybe_name_value(cx: @crate_ctxt, v: ValueRef, s: ~str) {\n \n \n // Used only for creating scalar comparison glue.\n-enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n+pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n \n-fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n-                        t: ty::t, op: ast::binop) -> Result {\n+pub fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n+                            t: ty::t, op: ast::binop) -> Result {\n     let f = |a| compare_scalar_values(cx, lhs, rhs, a, op);\n \n     match ty::get(t).sty {\n@@ -521,8 +523,8 @@ fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n \n \n // A helper function to do the actual comparison of scalar values.\n-fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n-                         nt: scalar_type, op: ast::binop) -> ValueRef {\n+pub fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n+                             nt: scalar_type, op: ast::binop) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"compare_scalar_values\");\n     fn die(cx: block) -> ! {\n         cx.tcx().sess.bug(~\"compare_scalar_values: must be a\\\n@@ -578,20 +580,20 @@ fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n     }\n }\n \n-type val_pair_fn = fn@(block, ValueRef, ValueRef) -> block;\n-type val_and_ty_fn = fn@(block, ValueRef, ty::t) -> block;\n+pub type val_pair_fn = fn@(block, ValueRef, ValueRef) -> block;\n+pub type val_and_ty_fn = fn@(block, ValueRef, ty::t) -> block;\n \n-fn load_inbounds(cx: block, p: ValueRef, idxs: &[uint]) -> ValueRef {\n+pub fn load_inbounds(cx: block, p: ValueRef, idxs: &[uint]) -> ValueRef {\n     return Load(cx, GEPi(cx, p, idxs));\n }\n \n-fn store_inbounds(cx: block, v: ValueRef, p: ValueRef, idxs: &[uint]) {\n+pub fn store_inbounds(cx: block, v: ValueRef, p: ValueRef, idxs: &[uint]) {\n     Store(cx, v, GEPi(cx, p, idxs));\n }\n \n // Iterates through the elements of a structural type.\n-fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n-                      f: val_and_ty_fn) -> block {\n+pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n+                          f: val_and_ty_fn) -> block {\n     let _icx = cx.insn_ctxt(\"iter_structural_ty\");\n \n     fn iter_variant(cx: block, a_tup: ValueRef,\n@@ -691,27 +693,27 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     return cx;\n }\n \n-fn cast_shift_expr_rhs(cx: block, op: ast::binop,\n-                       lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn cast_shift_expr_rhs(cx: block, op: ast::binop,\n+                           lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs,\n                    |a,b| Trunc(cx, a, b),\n                    |a,b| ZExt(cx, a, b))\n }\n \n-fn cast_shift_const_rhs(op: ast::binop,\n-                        lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+pub fn cast_shift_const_rhs(op: ast::binop,\n+                            lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     unsafe {\n         cast_shift_rhs(op, lhs, rhs,\n                        |a, b| unsafe { llvm::LLVMConstTrunc(a, b) },\n                        |a, b| unsafe { llvm::LLVMConstZExt(a, b) })\n     }\n }\n \n-fn cast_shift_rhs(op: ast::binop,\n-                  lhs: ValueRef, rhs: ValueRef,\n-                  trunc: fn(ValueRef, TypeRef) -> ValueRef,\n-                  zext: fn(ValueRef, TypeRef) -> ValueRef\n-                 ) -> ValueRef {\n+pub fn cast_shift_rhs(op: ast::binop,\n+                      lhs: ValueRef, rhs: ValueRef,\n+                      trunc: fn(ValueRef, TypeRef) -> ValueRef,\n+                      zext: fn(ValueRef, TypeRef) -> ValueRef)\n+                   -> ValueRef {\n     // Shifts may have any size int on the rhs\n     unsafe {\n         if ast_util::is_shift_binop(op) {\n@@ -734,8 +736,8 @@ fn cast_shift_rhs(op: ast::binop,\n     }\n }\n \n-fn fail_if_zero(cx: block, span: span, divmod: ast::binop,\n-                rhs: ValueRef, rhs_t: ty::t) -> block {\n+pub fn fail_if_zero(cx: block, span: span, divmod: ast::binop,\n+                    rhs: ValueRef, rhs_t: ty::t) -> block {\n     let text = if divmod == ast::div {\n         ~\"divide by zero\"\n     } else {\n@@ -760,11 +762,11 @@ fn fail_if_zero(cx: block, span: span, divmod: ast::binop,\n     }\n }\n \n-fn null_env_ptr(bcx: block) -> ValueRef {\n+pub fn null_env_ptr(bcx: block) -> ValueRef {\n     C_null(T_opaque_box_ptr(bcx.ccx()))\n }\n \n-fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n+pub fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     -> ValueRef {\n     let name = csearch::get_symbol(ccx.sess.cstore, did);\n     match ty::get(t).sty {\n@@ -780,8 +782,8 @@ fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     };\n }\n \n-fn get_discrim_val(cx: @crate_ctxt, span: span, enum_did: ast::def_id,\n-                   variant_did: ast::def_id) -> ValueRef {\n+pub fn get_discrim_val(cx: @crate_ctxt, span: span, enum_did: ast::def_id,\n+                       variant_did: ast::def_id) -> ValueRef {\n     // Can't use `discrims` from the crate context here because\n     // those discriminants have an extra level of indirection,\n     // and there's no LLVM constant load instruction.\n@@ -804,7 +806,7 @@ fn get_discrim_val(cx: @crate_ctxt, span: span, enum_did: ast::def_id,\n     }\n }\n \n-fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n+pub fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n     unsafe {\n         let _icx = ccx.insn_ctxt(\"lookup_discriminant\");\n         match ccx.discrims.find(vid) {\n@@ -825,7 +827,7 @@ fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n     }\n }\n \n-fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef]) -> block {\n+pub fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef]) -> block {\n     let _icx = bcx.insn_ctxt(\"invoke_\");\n     if bcx.unreachable { return bcx; }\n     if need_invoke(bcx) {\n@@ -840,7 +842,7 @@ fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef]) -> block {\n     }\n }\n \n-fn need_invoke(bcx: block) -> bool {\n+pub fn need_invoke(bcx: block) -> bool {\n     if (bcx.ccx().sess.opts.debugging_opts & session::no_landing_pads != 0) {\n         return false;\n     }\n@@ -878,7 +880,7 @@ fn need_invoke(bcx: block) -> bool {\n     }\n }\n \n-fn have_cached_lpad(bcx: block) -> bool {\n+pub fn have_cached_lpad(bcx: block) -> bool {\n     let mut res = false;\n     do in_lpad_scope_cx(bcx) |inf| {\n         match inf.landing_pad {\n@@ -889,7 +891,7 @@ fn have_cached_lpad(bcx: block) -> bool {\n     return res;\n }\n \n-fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n+pub fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n     let mut bcx = bcx;\n     loop {\n         match bcx.kind {\n@@ -904,7 +906,7 @@ fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n     }\n }\n \n-fn get_landing_pad(bcx: block) -> BasicBlockRef {\n+pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     let _icx = bcx.insn_ctxt(\"get_landing_pad\");\n \n     let mut cached = None, pad_bcx = bcx; // Guaranteed to be set below\n@@ -964,10 +966,10 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n // block, so an SSA value that is valid in the inner block may not be valid in\n // the outer block.  In fact, the inner block may not even execute.  Rather\n // than generate the full SSA form, we just use an alloca'd value.\n-fn add_root_cleanup(bcx: block,\n-                    root_info: RootInfo,\n-                    root_loc: ValueRef,\n-                    ty: ty::t) {\n+pub fn add_root_cleanup(bcx: block,\n+                        root_info: RootInfo,\n+                        root_loc: ValueRef,\n+                        ty: ty::t) {\n \n     debug!(\"add_root_cleanup(bcx=%s, \\\n                              scope=%d, \\\n@@ -1006,7 +1008,7 @@ fn add_root_cleanup(bcx: block,\n     }\n }\n \n-fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_bot(t) {\n         return C_null(T_ptr(T_i8()));\n     }\n@@ -1020,25 +1022,25 @@ fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n // [Note-arg-mode]\n // ++ mode is temporary, due to how borrowck treats enums. With hope,\n // will go away anyway when we get rid of modes.\n-fn do_spill_noroot(++cx: block, v: ValueRef) -> ValueRef {\n+pub fn do_spill_noroot(++cx: block, v: ValueRef) -> ValueRef {\n     let llptr = alloca(cx, val_ty(v));\n     Store(cx, v, llptr);\n     return llptr;\n }\n \n-fn spill_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn spill_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"spill_if_immediate\");\n     if ty::type_is_immediate(t) { return do_spill(cx, v, t); }\n     return v;\n }\n \n-fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n+pub fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"load_if_immediate\");\n     if ty::type_is_immediate(t) { return Load(cx, v); }\n     return v;\n }\n \n-fn trans_trace(bcx: block, sp_opt: Option<span>, +trace_str: ~str) {\n+pub fn trans_trace(bcx: block, sp_opt: Option<span>, +trace_str: ~str) {\n     if !bcx.sess().trace() { return; }\n     let _icx = bcx.insn_ctxt(\"trans_trace\");\n     // XXX: Bad copy.\n@@ -1063,18 +1065,18 @@ fn trans_trace(bcx: block, sp_opt: Option<span>, +trace_str: ~str) {\n     Call(bcx, ccx.upcalls.trace, args);\n }\n \n-fn build_return(bcx: block) {\n+pub fn build_return(bcx: block) {\n     let _icx = bcx.insn_ctxt(\"build_return\");\n     Br(bcx, bcx.fcx.llreturn);\n }\n \n-fn ignore_lhs(_bcx: block, local: @ast::local) -> bool {\n+pub fn ignore_lhs(_bcx: block, local: @ast::local) -> bool {\n     match local.node.pat.node {\n         ast::pat_wild => true, _ => false\n     }\n }\n \n-fn init_local(bcx: block, local: @ast::local) -> block {\n+pub fn init_local(bcx: block, local: @ast::local) -> block {\n \n     debug!(\"init_local(bcx=%s, local.id=%?)\",\n            bcx.to_str(), local.node.id);\n@@ -1126,7 +1128,7 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n                                        _match::BindLocal);\n }\n \n-fn trans_stmt(cx: block, s: ast::stmt) -> block {\n+pub fn trans_stmt(cx: block, s: ast::stmt) -> block {\n     let _icx = cx.insn_ctxt(\"trans_stmt\");\n     debug!(\"trans_stmt(%s)\", stmt_to_str(s, cx.tcx().sess.intr()));\n \n@@ -1162,8 +1164,8 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n \n // You probably don't want to use this one. See the\n // next three functions instead.\n-fn new_block(cx: fn_ctxt, parent: Option<block>, +kind: block_kind,\n-             is_lpad: bool, +name: ~str, opt_node_info: Option<node_info>)\n+pub fn new_block(cx: fn_ctxt, parent: Option<block>, +kind: block_kind,\n+                 is_lpad: bool, +name: ~str, opt_node_info: Option<node_info>)\n     -> block {\n \n     let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n@@ -1188,7 +1190,7 @@ fn new_block(cx: fn_ctxt, parent: Option<block>, +kind: block_kind,\n     }\n }\n \n-fn simple_block_scope() -> block_kind {\n+pub fn simple_block_scope() -> block_kind {\n     block_scope(scope_info {\n         loop_break: None,\n         loop_label: None,\n@@ -1199,20 +1201,24 @@ fn simple_block_scope() -> block_kind {\n }\n \n // Use this when you're at the top block of a function or the like.\n-fn top_scope_block(fcx: fn_ctxt, opt_node_info: Option<node_info>) -> block {\n+pub fn top_scope_block(fcx: fn_ctxt, opt_node_info: Option<node_info>)\n+                    -> block {\n     return new_block(fcx, None, simple_block_scope(), false,\n                   ~\"function top level\", opt_node_info);\n }\n \n-fn scope_block(bcx: block,\n-               opt_node_info: Option<node_info>,\n-               +n: ~str) -> block {\n+pub fn scope_block(bcx: block,\n+                   opt_node_info: Option<node_info>,\n+                   +n: ~str) -> block {\n     return new_block(bcx.fcx, Some(bcx), simple_block_scope(), bcx.is_lpad,\n                   n, opt_node_info);\n }\n \n-fn loop_scope_block(bcx: block, loop_break: block, loop_label: Option<ident>,\n-                    +n: ~str, opt_node_info: Option<node_info>) -> block {\n+pub fn loop_scope_block(bcx: block,\n+                        loop_break: block,\n+                        loop_label: Option<ident>,\n+                        +n: ~str,\n+                        opt_node_info: Option<node_info>) -> block {\n     return new_block(bcx.fcx, Some(bcx), block_scope(scope_info {\n         loop_break: Some(loop_break),\n         loop_label: loop_label,\n@@ -1223,16 +1229,16 @@ fn loop_scope_block(bcx: block, loop_break: block, loop_label: Option<ident>,\n }\n \n // Use this when creating a block for the inside of a landing pad.\n-fn lpad_block(bcx: block, +n: ~str) -> block {\n+pub fn lpad_block(bcx: block, +n: ~str) -> block {\n     new_block(bcx.fcx, Some(bcx), block_non_scope, true, n, None)\n }\n \n // Use this when you're making a general CFG BB within a scope.\n-fn sub_block(bcx: block, +n: ~str) -> block {\n+pub fn sub_block(bcx: block, +n: ~str) -> block {\n     new_block(bcx.fcx, Some(bcx), block_non_scope, bcx.is_lpad, n, None)\n }\n \n-fn raw_block(fcx: fn_ctxt, is_lpad: bool, llbb: BasicBlockRef) -> block {\n+pub fn raw_block(fcx: fn_ctxt, is_lpad: bool, llbb: BasicBlockRef) -> block {\n     mk_block(llbb, None, block_non_scope, is_lpad, None, fcx)\n }\n \n@@ -1244,14 +1250,14 @@ fn raw_block(fcx: fn_ctxt, is_lpad: bool, llbb: BasicBlockRef) -> block {\n // need to make sure those variables go out of scope when the block ends.  We\n // do that by running a 'cleanup' function for each variable.\n // trans_block_cleanups runs all the cleanup functions for the block.\n-fn trans_block_cleanups(bcx: block, +cleanups: ~[cleanup]) -> block {\n+pub fn trans_block_cleanups(bcx: block, +cleanups: ~[cleanup]) -> block {\n     trans_block_cleanups_(bcx, cleanups, false)\n }\n \n-fn trans_block_cleanups_(bcx: block,\n-                         +cleanups: ~[cleanup],\n-                         /* cleanup_cx: block, */ is_lpad: bool) ->\n-   block {\n+pub fn trans_block_cleanups_(bcx: block,\n+                             +cleanups: ~[cleanup],\n+                             /* cleanup_cx: block, */\n+                             is_lpad: bool) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_block_cleanups\");\n     // NB: Don't short-circuit even if this block is unreachable because\n     // GC-based cleanup needs to the see that the roots are live.\n@@ -1276,9 +1282,9 @@ fn trans_block_cleanups_(bcx: block,\n // In the last argument, Some(block) mean jump to this block, and none means\n // this is a landing pad and leaving should be accomplished with a resume\n // instruction.\n-fn cleanup_and_leave(bcx: block,\n-                     upto: Option<BasicBlockRef>,\n-                     leave: Option<BasicBlockRef>) {\n+pub fn cleanup_and_leave(bcx: block,\n+                         upto: Option<BasicBlockRef>,\n+                         leave: Option<BasicBlockRef>) {\n     let _icx = bcx.insn_ctxt(\"cleanup_and_leave\");\n     let mut cur = bcx, bcx = bcx;\n     let is_lpad = leave == None;\n@@ -1320,22 +1326,23 @@ fn cleanup_and_leave(bcx: block,\n     }\n }\n \n-fn cleanup_and_Br(bcx: block, upto: block,\n-                  target: BasicBlockRef) {\n+pub fn cleanup_and_Br(bcx: block, upto: block, target: BasicBlockRef) {\n     let _icx = bcx.insn_ctxt(\"cleanup_and_Br\");\n     cleanup_and_leave(bcx, Some(upto.llbb), Some(target));\n }\n \n-fn leave_block(bcx: block, out_of: block) -> block {\n+pub fn leave_block(bcx: block, out_of: block) -> block {\n     let _icx = bcx.insn_ctxt(\"leave_block\");\n     let next_cx = sub_block(block_parent(out_of), ~\"next\");\n     if bcx.unreachable { Unreachable(next_cx); }\n     cleanup_and_Br(bcx, out_of, next_cx.llbb);\n     next_cx\n }\n \n-fn with_scope(bcx: block, opt_node_info: Option<node_info>,\n-              +name: ~str, f: fn(block) -> block) -> block {\n+pub fn with_scope(bcx: block,\n+                  opt_node_info: Option<node_info>,\n+                  +name: ~str,\n+                  f: fn(block) -> block) -> block {\n     let _icx = bcx.insn_ctxt(\"with_scope\");\n \n     debug!(\"with_scope(bcx=%s, opt_node_info=%?, name=%s)\",\n@@ -1347,22 +1354,20 @@ fn with_scope(bcx: block, opt_node_info: Option<node_info>,\n     leave_block(f(scope_cx), scope_cx)\n }\n \n-fn with_scope_result(bcx: block,\n-                     opt_node_info: Option<node_info>,\n-                     +name: ~str,\n-                     f: fn(block) -> Result)\n-                  -> Result {\n+pub fn with_scope_result(bcx: block,\n+                         opt_node_info: Option<node_info>,\n+                         +name: ~str,\n+                         f: fn(block) -> Result) -> Result {\n     let _icx = bcx.insn_ctxt(\"with_scope_result\");\n     let scope_cx = scope_block(bcx, opt_node_info, name);\n     Br(bcx, scope_cx.llbb);\n     let Result {bcx, val} = f(scope_cx);\n     rslt(leave_block(bcx, scope_cx), val)\n }\n \n-fn with_scope_datumblock(bcx: block, opt_node_info: Option<node_info>,\n-                         +name: ~str, f: fn(block) -> datum::DatumBlock)\n-    -> datum::DatumBlock\n-{\n+pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<node_info>,\n+                             +name: ~str, f: fn(block) -> datum::DatumBlock)\n+                          -> datum::DatumBlock {\n     use middle::trans::datum::DatumBlock;\n \n     let _icx = bcx.insn_ctxt(\"with_scope_result\");\n@@ -1372,7 +1377,7 @@ fn with_scope_datumblock(bcx: block, opt_node_info: Option<node_info>,\n     DatumBlock {bcx: leave_block(bcx, scope_cx), datum: datum}\n }\n \n-fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n+pub fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n     for vec::each(b.node.stmts) |s| {\n         match s.node {\n           ast::stmt_decl(d, _) => {\n@@ -1390,7 +1395,7 @@ fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n     }\n }\n \n-fn alloc_local(cx: block, local: @ast::local) -> block {\n+pub fn alloc_local(cx: block, local: @ast::local) -> block {\n     let _icx = cx.insn_ctxt(\"alloc_local\");\n     let t = node_id_type(cx, local.node.id);\n     let simple_name = match local.node.pat.node {\n@@ -1412,7 +1417,7 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n }\n \n \n-fn with_cond(bcx: block, val: ValueRef, f: fn(block) -> block) -> block {\n+pub fn with_cond(bcx: block, val: ValueRef, f: fn(block) -> block) -> block {\n     let _icx = bcx.insn_ctxt(\"with_cond\");\n     let next_cx = base::sub_block(bcx, ~\"next\");\n     let cond_cx = base::sub_block(bcx, ~\"cond\");\n@@ -1422,8 +1427,8 @@ fn with_cond(bcx: block, val: ValueRef, f: fn(block) -> block) -> block {\n     next_cx\n }\n \n-fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef,\n-                n_bytes: ValueRef) {\n+pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef,\n+                   n_bytes: ValueRef) {\n     // FIXME (Related to #1645, I think?): Provide LLVM with better\n     // alignment information when the alignment is statically known (it must\n     // be nothing more than a constant int, or LLVM complains -- not even a\n@@ -1443,7 +1448,7 @@ fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef,\n     Call(cx, memcpy, ~[dst_ptr, src_ptr, size, align, volatile]);\n }\n \n-fn memcpy_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n+pub fn memcpy_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n@@ -1454,7 +1459,7 @@ fn memcpy_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     }\n }\n \n-fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) {\n+pub fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) {\n     let _icx = cx.insn_ctxt(\"zero_mem\");\n     let bcx = cx;\n     let ccx = cx.ccx();\n@@ -1467,7 +1472,7 @@ fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) {\n // allocation for large data structures, and the generated code will be\n // awful. (A telltale sign of this is large quantities of\n // `mov [byte ptr foo],0` in the generated code.)\n-fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n+pub fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n     let _icx = cx.insn_ctxt(\"memzero\");\n     let ccx = cx.ccx();\n \n@@ -1484,13 +1489,13 @@ fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n     let llintrinsicfn = ccx.intrinsics.get(intrinsic_key);\n     let llptr = PointerCast(cx, llptr, T_ptr(T_i8()));\n     let llzeroval = C_u8(0);\n-    let size = IntCast(cx, shape::llsize_of(ccx, llty), ccx.int_type);\n+    let size = IntCast(cx, machine::llsize_of(ccx, llty), ccx.int_type);\n     let align = C_i32(1i32);\n     let volatile = C_bool(false);\n     Call(cx, llintrinsicfn, ~[llptr, llzeroval, size, align, volatile]);\n }\n \n-fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n+pub fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let llty = type_of::type_of(ccx, t);\n@@ -1500,11 +1505,11 @@ fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n     return val;\n }\n \n-fn alloca(cx: block, t: TypeRef) -> ValueRef {\n+pub fn alloca(cx: block, t: TypeRef) -> ValueRef {\n     alloca_maybe_zeroed(cx, t, false)\n }\n \n-fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n+pub fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"alloca\");\n     if cx.unreachable {\n         unsafe {\n@@ -1517,7 +1522,7 @@ fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n     return p;\n }\n \n-fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n+pub fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"arrayalloca\");\n     if cx.unreachable {\n         unsafe {\n@@ -1529,7 +1534,7 @@ fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n }\n \n // Creates the standard set of basic blocks for a function\n-fn mk_standard_basic_blocks(llfn: ValueRef) ->\n+pub fn mk_standard_basic_blocks(llfn: ValueRef) ->\n    {sa: BasicBlockRef, rt: BasicBlockRef} {\n     unsafe {\n         {sa: str::as_c_str(~\"static_allocas\",\n@@ -1546,13 +1551,13 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn new_fn_ctxt_w_id(ccx: @crate_ctxt,\n-                    +path: path,\n-                    llfndecl: ValueRef,\n-                    id: ast::node_id,\n-                    impl_id: Option<ast::def_id>,\n-                    +param_substs: Option<param_substs>,\n-                    sp: Option<span>) -> fn_ctxt {\n+pub fn new_fn_ctxt_w_id(ccx: @crate_ctxt,\n+                        +path: path,\n+                        llfndecl: ValueRef,\n+                        id: ast::node_id,\n+                        impl_id: Option<ast::def_id>,\n+                        +param_substs: Option<param_substs>,\n+                        sp: Option<span>) -> fn_ctxt {\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n     return @fn_ctxt_ {\n           llfn: llfndecl,\n@@ -1576,11 +1581,11 @@ fn new_fn_ctxt_w_id(ccx: @crate_ctxt,\n     };\n }\n \n-fn new_fn_ctxt(ccx: @crate_ctxt,\n-               +path: path,\n-               llfndecl: ValueRef,\n-               sp: Option<span>)\n-            -> fn_ctxt {\n+pub fn new_fn_ctxt(ccx: @crate_ctxt,\n+                   +path: path,\n+                   llfndecl: ValueRef,\n+                   sp: Option<span>)\n+                -> fn_ctxt {\n     return new_fn_ctxt_w_id(ccx, path, llfndecl, -1, None, None, sp);\n }\n \n@@ -1598,9 +1603,9 @@ fn new_fn_ctxt(ccx: @crate_ctxt,\n // spaces that have been created for them (by code in the llallocas field of\n // the function's fn_ctxt).  create_llargs_for_fn_args populates the llargs\n // field of the fn_ctxt with\n-fn create_llargs_for_fn_args(cx: fn_ctxt,\n-                             ty_self: self_arg,\n-                             args: ~[ast::arg]) -> ~[ValueRef] {\n+pub fn create_llargs_for_fn_args(cx: fn_ctxt,\n+                                 ty_self: self_arg,\n+                                 args: ~[ast::arg]) -> ~[ValueRef] {\n     let _icx = cx.insn_ctxt(\"create_llargs_for_fn_args\");\n \n     match ty_self {\n@@ -1631,11 +1636,11 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n     })\n }\n \n-fn copy_args_to_allocas(fcx: fn_ctxt,\n-                        bcx: block,\n-                        args: &[ast::arg],\n-                        raw_llargs: &[ValueRef],\n-                        arg_tys: &[ty::arg]) -> block {\n+pub fn copy_args_to_allocas(fcx: fn_ctxt,\n+                            bcx: block,\n+                            args: &[ast::arg],\n+                            raw_llargs: &[ValueRef],\n+                            arg_tys: &[ty::arg]) -> block {\n     let _icx = fcx.insn_ctxt(\"copy_args_to_allocas\");\n     let tcx = bcx.tcx();\n     let mut bcx = bcx;\n@@ -1709,14 +1714,14 @@ fn copy_args_to_allocas(fcx: fn_ctxt,\n \n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n-fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef) {\n+pub fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef) {\n     let _icx = fcx.insn_ctxt(\"finish_fn\");\n     tie_up_header_blocks(fcx, lltop);\n     let ret_cx = raw_block(fcx, false, fcx.llreturn);\n     RetVoid(ret_cx);\n }\n \n-fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n+pub fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n     let _icx = fcx.insn_ctxt(\"tie_up_header_blocks\");\n     match fcx.llloadenv {\n         Some(copy ll) => {\n@@ -1729,22 +1734,22 @@ fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n     }\n }\n \n-enum self_arg { impl_self(ty::t), impl_owned_self(ty::t), no_self, }\n+pub enum self_arg { impl_self(ty::t), impl_owned_self(ty::t), no_self, }\n \n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-fn trans_closure(ccx: @crate_ctxt,\n-                 +path: path,\n-                 decl: ast::fn_decl,\n-                 body: ast::blk,\n-                 llfndecl: ValueRef,\n-                 ty_self: self_arg,\n-                 +param_substs: Option<param_substs>,\n-                 id: ast::node_id,\n-                 impl_id: Option<ast::def_id>,\n-                 maybe_load_env: fn(fn_ctxt),\n-                 finish: fn(block)) {\n+pub fn trans_closure(ccx: @crate_ctxt,\n+                     +path: path,\n+                     decl: ast::fn_decl,\n+                     body: ast::blk,\n+                     llfndecl: ValueRef,\n+                     ty_self: self_arg,\n+                     +param_substs: Option<param_substs>,\n+                     id: ast::node_id,\n+                     impl_id: Option<ast::def_id>,\n+                     maybe_load_env: fn(fn_ctxt),\n+                     finish: fn(block)) {\n     ccx.stats.n_closures += 1;\n     let _icx = ccx.insn_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n@@ -1798,15 +1803,15 @@ fn trans_closure(ccx: @crate_ctxt,\n \n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n-fn trans_fn(ccx: @crate_ctxt,\n-            +path: path,\n-            decl: ast::fn_decl,\n-            body: ast::blk,\n-            llfndecl: ValueRef,\n-            ty_self: self_arg,\n-            +param_substs: Option<param_substs>,\n-            id: ast::node_id,\n-            impl_id: Option<ast::def_id>) {\n+pub fn trans_fn(ccx: @crate_ctxt,\n+                +path: path,\n+                decl: ast::fn_decl,\n+                body: ast::blk,\n+                llfndecl: ValueRef,\n+                ty_self: self_arg,\n+                +param_substs: Option<param_substs>,\n+                id: ast::node_id,\n+                impl_id: Option<ast::def_id>) {\n     let do_time = ccx.sess.trans_stats();\n     let start = if do_time { time::get_time() }\n                 else { time::Timespec::new(0, 0) };\n@@ -1828,14 +1833,14 @@ fn trans_fn(ccx: @crate_ctxt,\n     }\n }\n \n-fn trans_enum_variant(ccx: @crate_ctxt,\n-                      enum_id: ast::node_id,\n-                      variant: ast::variant,\n-                      args: ~[ast::variant_arg],\n-                      disr: int,\n-                      is_degen: bool,\n-                      +param_substs: Option<param_substs>,\n-                      llfndecl: ValueRef) {\n+pub fn trans_enum_variant(ccx: @crate_ctxt,\n+                          enum_id: ast::node_id,\n+                          variant: ast::variant,\n+                          args: ~[ast::variant_arg],\n+                          disr: int,\n+                          is_degen: bool,\n+                          +param_substs: Option<param_substs>,\n+                          llfndecl: ValueRef) {\n     let _icx = ccx.insn_ctxt(\"trans_enum_variant\");\n     // Translate variant arguments to function arguments.\n     let fn_args = do args.map |varg| {\n@@ -1894,11 +1899,11 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n \n // NB: In theory this should be merged with the function above. But the AST\n // structures are completely different, so very little code would be shared.\n-fn trans_tuple_struct(ccx: @crate_ctxt,\n-                      fields: ~[@ast::struct_field],\n-                      ctor_id: ast::node_id,\n-                      +param_substs: Option<param_substs>,\n-                      llfndecl: ValueRef) {\n+pub fn trans_tuple_struct(ccx: @crate_ctxt,\n+                          fields: ~[@ast::struct_field],\n+                          ctor_id: ast::node_id,\n+                          +param_substs: Option<param_substs>,\n+                          llfndecl: ValueRef) {\n     let _icx = ccx.insn_ctxt(\"trans_tuple_struct\");\n \n     // Translate struct fields to function arguments.\n@@ -1942,14 +1947,14 @@ fn trans_tuple_struct(ccx: @crate_ctxt,\n     finish_fn(fcx, lltop);\n }\n \n-fn trans_struct_dtor(ccx: @crate_ctxt,\n-                     +path: path,\n-                     body: ast::blk,\n-                     dtor_id: ast::node_id,\n-                     +psubsts: Option<param_substs>,\n-                     hash_id: Option<mono_id>,\n-                     parent_id: ast::def_id)\n-                  -> ValueRef {\n+pub fn trans_struct_dtor(ccx: @crate_ctxt,\n+                         +path: path,\n+                         body: ast::blk,\n+                         dtor_id: ast::node_id,\n+                         +psubsts: Option<param_substs>,\n+                         hash_id: Option<mono_id>,\n+                         parent_id: ast::def_id)\n+                      -> ValueRef {\n   let tcx = ccx.tcx;\n   /* Look up the parent class's def_id */\n   let mut class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n@@ -1980,10 +1985,10 @@ fn trans_struct_dtor(ccx: @crate_ctxt,\n   lldecl\n }\n \n-fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n-                  id: ast::node_id, tps: ~[ast::ty_param], degen: bool,\n-                  path: @ast_map::path, vi: @~[ty::VariantInfo],\n-                  i: &mut uint) {\n+pub fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n+                      id: ast::node_id, tps: ~[ast::ty_param], degen: bool,\n+                      path: @ast_map::path, vi: @~[ty::VariantInfo],\n+                      i: &mut uint) {\n     for vec::each(enum_definition.variants) |variant| {\n         let disr_val = vi[*i].disr_val;\n         *i += 1;\n@@ -2015,7 +2020,7 @@ fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n     }\n }\n \n-fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n+pub fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_item\");\n     let path = match ccx.tcx.items.get(item.id) {\n         ast_map::node_item(_, p) => p,\n@@ -2081,9 +2086,9 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n     }\n }\n \n-fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n-                    tps: ~[ast::ty_param], path: @ast_map::path,\n-                    id: ast::node_id) {\n+pub fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n+                        tps: ~[ast::ty_param], path: @ast_map::path,\n+                        id: ast::node_id) {\n     // If there are type parameters, the destructor and constructor will be\n     // monomorphized, so we don't translate them here.\n     if tps.len() == 0u {\n@@ -2112,49 +2117,49 @@ fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n // separate modules in the compiled program.  That's because modules exist\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n-fn trans_mod(ccx: @crate_ctxt, m: ast::_mod) {\n+pub fn trans_mod(ccx: @crate_ctxt, m: ast::_mod) {\n     let _icx = ccx.insn_ctxt(\"trans_mod\");\n     for vec::each(m.items) |item| {\n         trans_item(ccx, **item);\n     }\n }\n \n-fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n+pub fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the pair.\n     return struct_elt(llpairty, 0u);\n }\n \n-fn register_fn(ccx: @crate_ctxt,\n-               sp: span,\n-               +path: path,\n-               node_id: ast::node_id,\n-               attrs: &[ast::attribute])\n-            -> ValueRef {\n+pub fn register_fn(ccx: @crate_ctxt,\n+                   sp: span,\n+                   +path: path,\n+                   node_id: ast::node_id,\n+                   attrs: &[ast::attribute])\n+                -> ValueRef {\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     register_fn_full(ccx, sp, path, node_id, attrs, t)\n }\n \n-fn register_fn_full(ccx: @crate_ctxt,\n-                    sp: span,\n-                    +path: path,\n-                    node_id: ast::node_id,\n-                    attrs: &[ast::attribute],\n-                    node_type: ty::t)\n-                 -> ValueRef {\n+pub fn register_fn_full(ccx: @crate_ctxt,\n+                        sp: span,\n+                        +path: path,\n+                        node_id: ast::node_id,\n+                        attrs: &[ast::attribute],\n+                        node_type: ty::t)\n+                     -> ValueRef {\n     let llfty = type_of_fn_from_ty(ccx, node_type);\n     register_fn_fuller(ccx, sp, path, node_id, attrs, node_type,\n                        lib::llvm::CCallConv, llfty)\n }\n \n-fn register_fn_fuller(ccx: @crate_ctxt,\n-                      sp: span,\n-                      +path: path,\n-                      node_id: ast::node_id,\n-                      attrs: &[ast::attribute],\n-                      node_type: ty::t,\n-                      cc: lib::llvm::CallConv,\n-                      llfty: TypeRef)\n-                   -> ValueRef {\n+pub fn register_fn_fuller(ccx: @crate_ctxt,\n+                          sp: span,\n+                          +path: path,\n+                          node_id: ast::node_id,\n+                          attrs: &[ast::attribute],\n+                          node_type: ty::t,\n+                          cc: lib::llvm::CallConv,\n+                          llfty: TypeRef)\n+                       -> ValueRef {\n     debug!(\"register_fn_fuller creating fn for item %d with path %s\",\n            node_id,\n            ast_map::path_to_str(path, ccx.sess.parse_sess.interner));\n@@ -2178,7 +2183,7 @@ fn register_fn_fuller(ccx: @crate_ctxt,\n     llfn\n }\n \n-fn is_main_fn(sess: &Session, node_id: ast::node_id) -> bool {\n+pub fn is_main_fn(sess: &Session, node_id: ast::node_id) -> bool {\n     match sess.main_fn {\n         Some((main_id, _)) => node_id == main_id,\n         None => false\n@@ -2187,7 +2192,7 @@ fn is_main_fn(sess: &Session, node_id: ast::node_id) -> bool {\n \n // Create a _rust_main(args: ~[str]) function which will be called from the\n // runtime rust_start function\n-fn create_main_wrapper(ccx: @crate_ctxt, _sp: span, main_llfn: ValueRef) {\n+pub fn create_main_wrapper(ccx: @crate_ctxt, _sp: span, main_llfn: ValueRef) {\n \n     let llfn = create_main(ccx, main_llfn);\n     create_entry_fn(ccx, llfn);\n@@ -2271,8 +2276,8 @@ fn create_main_wrapper(ccx: @crate_ctxt, _sp: span, main_llfn: ValueRef) {\n     }\n }\n \n-fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n-                llenvptr: ValueRef) {\n+pub fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n+                    llenvptr: ValueRef) {\n     let ccx = bcx.ccx();\n     let code_cell = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n     Store(bcx, llfn, code_cell);\n@@ -2281,7 +2286,7 @@ fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n     Store(bcx, llenvblobptr, env_cell);\n }\n \n-fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n+pub fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n     vec::append(\n         /*bad*/copy *match ccx.tcx.items.get(i.id) {\n             ast_map::node_item(_, p) => p,\n@@ -2293,11 +2298,11 @@ fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n \n /* If there's already a symbol for the dtor with <id> and substs <substs>,\n    return it; otherwise, create one and register it, returning it as well */\n-fn get_dtor_symbol(ccx: @crate_ctxt,\n-                   +path: path,\n-                   id: ast::node_id,\n-                   +substs: Option<param_substs>)\n-                -> ~str {\n+pub fn get_dtor_symbol(ccx: @crate_ctxt,\n+                       +path: path,\n+                       id: ast::node_id,\n+                       +substs: Option<param_substs>)\n+                    -> ~str {\n   let t = ty::node_id_to_type(ccx.tcx, id);\n   match ccx.item_symbols.find(id) {\n      Some(ref s) => (/*bad*/copy *s),\n@@ -2331,7 +2336,7 @@ fn get_dtor_symbol(ccx: @crate_ctxt,\n   }\n }\n \n-fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n+pub fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n     debug!(\"get_item_val(id=`%?`)\", id);\n     let tcx = ccx.tcx;\n     match ccx.item_vals.find(id) {\n@@ -2500,8 +2505,10 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n     }\n }\n \n-fn register_method(ccx: @crate_ctxt, id: ast::node_id, pth: @ast_map::path,\n-                m: @ast::method) -> ValueRef {\n+pub fn register_method(ccx: @crate_ctxt,\n+                       id: ast::node_id,\n+                       pth: @ast_map::path,\n+                       m: @ast::method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n     let pth = vec::append(/*bad*/copy *pth, ~[path_name((ccx.names)(~\"meth\")),\n                                   path_name(m.ident)]);\n@@ -2511,7 +2518,7 @@ fn register_method(ccx: @crate_ctxt, id: ast::node_id, pth: @ast_map::path,\n }\n \n // The constant translation pass.\n-fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n+pub fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_constant\");\n     match it.node {\n       ast::item_enum(ref enum_definition, _) => {\n@@ -2548,7 +2555,7 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n     }\n }\n \n-fn trans_constants(ccx: @crate_ctxt, crate: &ast::crate) {\n+pub fn trans_constants(ccx: @crate_ctxt, crate: &ast::crate) {\n     visit::visit_crate(\n         *crate, (),\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n@@ -2557,18 +2564,18 @@ fn trans_constants(ccx: @crate_ctxt, crate: &ast::crate) {\n         }));\n }\n \n-fn vp2i(cx: block, v: ValueRef) -> ValueRef {\n+pub fn vp2i(cx: block, v: ValueRef) -> ValueRef {\n     let ccx = cx.ccx();\n     return PtrToInt(cx, v, ccx.int_type);\n }\n \n-fn p2i(ccx: @crate_ctxt, v: ValueRef) -> ValueRef {\n+pub fn p2i(ccx: @crate_ctxt, v: ValueRef) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstPtrToInt(v, ccx.int_type);\n     }\n }\n \n-fn declare_intrinsics(llmod: ModuleRef) -> HashMap<~str, ValueRef> {\n+pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<~str, ValueRef> {\n     let T_memcpy32_args: ~[TypeRef] =\n         ~[T_ptr(T_i8()), T_ptr(T_i8()), T_i32(), T_i32(), T_i1()];\n     let T_memcpy64_args: ~[TypeRef] =\n@@ -2761,8 +2768,8 @@ fn declare_intrinsics(llmod: ModuleRef) -> HashMap<~str, ValueRef> {\n     return intrinsics;\n }\n \n-fn declare_dbg_intrinsics(llmod: ModuleRef,\n-                          intrinsics: HashMap<~str, ValueRef>) {\n+pub fn declare_dbg_intrinsics(llmod: ModuleRef,\n+                              intrinsics: HashMap<~str, ValueRef>) {\n     let declare =\n         decl_cdecl_fn(llmod, ~\"llvm.dbg.declare\",\n                       T_fn(~[T_metadata(), T_metadata()], T_void()));\n@@ -2774,15 +2781,15 @@ fn declare_dbg_intrinsics(llmod: ModuleRef,\n     intrinsics.insert(~\"llvm.dbg.value\", value);\n }\n \n-fn trap(bcx: block) {\n+pub fn trap(bcx: block) {\n     let v: ~[ValueRef] = ~[];\n     match bcx.ccx().intrinsics.find(~\"llvm.trap\") {\n       Some(x) => { Call(bcx, x, v); },\n       _ => bcx.sess().bug(~\"unbound llvm.trap in trap\")\n     }\n }\n \n-fn decl_gc_metadata(ccx: @crate_ctxt, llmod_id: ~str) {\n+pub fn decl_gc_metadata(ccx: @crate_ctxt, llmod_id: ~str) {\n     if !ccx.sess.opts.gc || !ccx.uses_gc {\n         return;\n     }\n@@ -2800,7 +2807,7 @@ fn decl_gc_metadata(ccx: @crate_ctxt, llmod_id: ~str) {\n     }\n }\n \n-fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n+pub fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n     let elttype = T_struct(~[ccx.int_type, ccx.int_type]);\n     let maptype = T_array(elttype, ccx.module_data.size() + 1u);\n     let map = str::as_c_str(~\"_rust_mod_map\", |buf| {\n@@ -2826,8 +2833,8 @@ fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n }\n \n \n-fn decl_crate_map(sess: session::Session, mapmeta: link_meta,\n-                  llmod: ModuleRef) -> ValueRef {\n+pub fn decl_crate_map(sess: session::Session, mapmeta: link_meta,\n+                      llmod: ModuleRef) -> ValueRef {\n     let targ_cfg = sess.targ_cfg;\n     let int_type = T_int(targ_cfg);\n     let mut n_subcrates = 1;\n@@ -2849,7 +2856,7 @@ fn decl_crate_map(sess: session::Session, mapmeta: link_meta,\n     return map;\n }\n \n-fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n+pub fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n     let mut subcrates: ~[ValueRef] = ~[];\n     let mut i = 1;\n     let cstore = ccx.sess.cstore;\n@@ -2890,7 +2897,7 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n     }\n }\n \n-fn crate_ctxt_to_encode_parms(cx: @crate_ctxt) -> encoder::encode_parms {\n+pub fn crate_ctxt_to_encode_parms(cx: @crate_ctxt) -> encoder::encode_parms {\n     let encode_inlined_item: encoder::encode_inlined_item =\n         |ecx, ebml_w, path, ii|\n         astencode::encode_inlined_item(ecx, ebml_w, path, ii, cx.maps);\n@@ -2908,7 +2915,7 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt) -> encoder::encode_parms {\n     };\n }\n \n-fn write_metadata(cx: @crate_ctxt, crate: &ast::crate) {\n+pub fn write_metadata(cx: @crate_ctxt, crate: &ast::crate) {\n     if !cx.sess.building_library { return; }\n     let encode_parms = crate_ctxt_to_encode_parms(cx);\n     let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n@@ -2936,17 +2943,17 @@ fn write_metadata(cx: @crate_ctxt, crate: &ast::crate) {\n }\n \n // Writes the current ABI version into the crate.\n-fn write_abi_version(ccx: @crate_ctxt) {\n+pub fn write_abi_version(ccx: @crate_ctxt) {\n     mk_global(ccx, ~\"rust_abi_version\", C_uint(ccx, abi::abi_version),\n                      false);\n }\n \n-fn trans_crate(sess: session::Session,\n-               crate: @ast::crate,\n-               tcx: ty::ctxt,\n-               output: &Path,\n-               emap2: resolve::ExportMap2,\n-               maps: astencode::maps) -> (ModuleRef, link_meta) {\n+pub fn trans_crate(sess: session::Session,\n+                   crate: @ast::crate,\n+                   tcx: ty::ctxt,\n+                   output: &Path,\n+                   emap2: resolve::ExportMap2,\n+                   maps: astencode::maps) -> (ModuleRef, link_meta) {\n \n     let symbol_hasher = @hash::default_state();\n     let link_meta ="}, {"sha": "584e5d9f184864407ff41883bf547854cd8b666a", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 119, "deletions": 118, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -25,27 +25,27 @@ use core::vec;\n use std::map::HashMap;\n use syntax::codemap;\n \n-fn terminate(cx: block, _: &str) {\n+pub fn terminate(cx: block, _: &str) {\n     unsafe {\n         cx.terminated = true;\n     }\n }\n \n-fn check_not_terminated(cx: block) {\n+pub fn check_not_terminated(cx: block) {\n     if cx.terminated {\n         fail ~\"already terminated!\";\n     }\n }\n \n-fn B(cx: block) -> BuilderRef {\n+pub fn B(cx: block) -> BuilderRef {\n     unsafe {\n         let b = cx.fcx.ccx.builder.B;\n         llvm::LLVMPositionBuilderAtEnd(b, cx.llbb);\n         return b;\n     }\n }\n \n-fn count_insn(cx: block, category: &str) {\n+pub fn count_insn(cx: block, category: &str) {\n     if cx.ccx().sess.count_llvm_insns() {\n \n         let h = cx.ccx().stats.llvm_insns;\n@@ -96,7 +96,7 @@ fn count_insn(cx: block, category: &str) {\n // for (fail/break/return statements, call to diverging functions, etc), and\n // further instructions to the block should simply be ignored.\n \n-fn RetVoid(cx: block) {\n+pub fn RetVoid(cx: block) {\n     unsafe {\n         if cx.unreachable { return; }\n         check_not_terminated(cx);\n@@ -106,7 +106,7 @@ fn RetVoid(cx: block) {\n     }\n }\n \n-fn Ret(cx: block, V: ValueRef) {\n+pub fn Ret(cx: block, V: ValueRef) {\n     unsafe {\n         if cx.unreachable { return; }\n         check_not_terminated(cx);\n@@ -116,7 +116,7 @@ fn Ret(cx: block, V: ValueRef) {\n     }\n }\n \n-fn AggregateRet(cx: block, RetVals: ~[ValueRef]) {\n+pub fn AggregateRet(cx: block, RetVals: ~[ValueRef]) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"AggregateRet\");\n@@ -126,7 +126,7 @@ fn AggregateRet(cx: block, RetVals: ~[ValueRef]) {\n     }\n }\n \n-fn Br(cx: block, Dest: BasicBlockRef) {\n+pub fn Br(cx: block, Dest: BasicBlockRef) {\n     unsafe {\n         if cx.unreachable { return; }\n         check_not_terminated(cx);\n@@ -136,8 +136,8 @@ fn Br(cx: block, Dest: BasicBlockRef) {\n     }\n }\n \n-fn CondBr(cx: block, If: ValueRef, Then: BasicBlockRef,\n-          Else: BasicBlockRef) {\n+pub fn CondBr(cx: block, If: ValueRef, Then: BasicBlockRef,\n+              Else: BasicBlockRef) {\n     unsafe {\n         if cx.unreachable { return; }\n         check_not_terminated(cx);\n@@ -147,7 +147,7 @@ fn CondBr(cx: block, If: ValueRef, Then: BasicBlockRef,\n     }\n }\n \n-fn Switch(cx: block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n+pub fn Switch(cx: block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n     -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(V); }\n@@ -157,14 +157,14 @@ fn Switch(cx: block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n     }\n }\n \n-fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n+pub fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n     unsafe {\n         if llvm::LLVMIsUndef(S) == lib::llvm::True { return; }\n         llvm::LLVMAddCase(S, OnVal, Dest);\n     }\n }\n \n-fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n+pub fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n     unsafe {\n         if cx.unreachable { return; }\n         check_not_terminated(cx);\n@@ -176,15 +176,15 @@ fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n // lot more efficient) than doing str::as_c_str(\"\", ...) every time.\n-fn noname() -> *libc::c_char {\n+pub fn noname() -> *libc::c_char {\n     unsafe {\n         const cnull: uint = 0u;\n         return cast::reinterpret_cast(&ptr::addr_of(&cnull));\n     }\n }\n \n-fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n-          Then: BasicBlockRef, Catch: BasicBlockRef) {\n+pub fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n+              Then: BasicBlockRef, Catch: BasicBlockRef) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"Invoke\");\n@@ -201,8 +201,8 @@ fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n     }\n }\n \n-fn FastInvoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n-              Then: BasicBlockRef, Catch: BasicBlockRef) {\n+pub fn FastInvoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n+                  Then: BasicBlockRef, Catch: BasicBlockRef) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"FastInvoke\");\n@@ -215,7 +215,7 @@ fn FastInvoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n     }\n }\n \n-fn Unreachable(cx: block) {\n+pub fn Unreachable(cx: block) {\n     unsafe {\n         if cx.unreachable { return; }\n         cx.unreachable = true;\n@@ -226,253 +226,254 @@ fn Unreachable(cx: block) {\n     }\n }\n \n-fn _Undef(val: ValueRef) -> ValueRef {\n+pub fn _Undef(val: ValueRef) -> ValueRef {\n     unsafe {\n         return llvm::LLVMGetUndef(val_ty(val));\n     }\n }\n \n /* Arithmetic */\n-fn Add(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Add(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"add\");\n         return llvm::LLVMBuildAdd(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn NSWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NSWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"nswadd\");\n         return llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn NUWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NUWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"nuwadd\");\n         return llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn FAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"fadd\");\n         return llvm::LLVMBuildFAdd(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn Sub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Sub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"sub\");\n         return llvm::LLVMBuildSub(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn NSWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NSWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"nwsub\");\n         return llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn NUWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NUWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"nuwsub\");\n         return llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn FSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"sub\");\n         return llvm::LLVMBuildFSub(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn Mul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Mul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"mul\");\n         return llvm::LLVMBuildMul(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn NSWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NSWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"nswmul\");\n         return llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn NUWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn NUWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"nuwmul\");\n         return llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn FMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"fmul\");\n         return llvm::LLVMBuildFMul(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn UDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn UDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"udiv\");\n         return llvm::LLVMBuildUDiv(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn SDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn SDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"sdiv\");\n         return llvm::LLVMBuildSDiv(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn ExactSDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn ExactSDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"extractsdiv\");\n         return llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn FDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"fdiv\");\n         return llvm::LLVMBuildFDiv(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn URem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn URem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"urem\");\n         return llvm::LLVMBuildURem(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn SRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn SRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"srem\");\n         return llvm::LLVMBuildSRem(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn FRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn FRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"frem\");\n         return llvm::LLVMBuildFRem(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn Shl(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Shl(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"shl\");\n         return llvm::LLVMBuildShl(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn LShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn LShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"lshr\");\n         return llvm::LLVMBuildLShr(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn AShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn AShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"ashr\");\n         return llvm::LLVMBuildAShr(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn And(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn And(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"and\");\n         return llvm::LLVMBuildAnd(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn Or(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Or(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"or\");\n         return llvm::LLVMBuildOr(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn Xor(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn Xor(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"xor\");\n         return llvm::LLVMBuildXor(B(cx), LHS, RHS, noname());\n     }\n }\n \n-fn BinOp(cx: block, Op: Opcode, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn BinOp(cx: block, Op: Opcode, LHS: ValueRef, RHS: ValueRef)\n+          -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(LHS); }\n         count_insn(cx, \"binop\");\n         return llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, noname());\n     }\n }\n \n-fn Neg(cx: block, V: ValueRef) -> ValueRef {\n+pub fn Neg(cx: block, V: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(V); }\n         count_insn(cx, \"neg\");\n         return llvm::LLVMBuildNeg(B(cx), V, noname());\n     }\n }\n \n-fn NSWNeg(cx: block, V: ValueRef) -> ValueRef {\n+pub fn NSWNeg(cx: block, V: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(V); }\n         count_insn(cx, \"nswneg\");\n         return llvm::LLVMBuildNSWNeg(B(cx), V, noname());\n     }\n }\n \n-fn NUWNeg(cx: block, V: ValueRef) -> ValueRef {\n+pub fn NUWNeg(cx: block, V: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(V); }\n         count_insn(cx, \"nuwneg\");\n         return llvm::LLVMBuildNUWNeg(B(cx), V, noname());\n     }\n }\n-fn FNeg(cx: block, V: ValueRef) -> ValueRef {\n+pub fn FNeg(cx: block, V: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(V); }\n         count_insn(cx, \"fneg\");\n         return llvm::LLVMBuildFNeg(B(cx), V, noname());\n     }\n }\n \n-fn Not(cx: block, V: ValueRef) -> ValueRef {\n+pub fn Not(cx: block, V: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(V); }\n         count_insn(cx, \"not\");\n@@ -481,47 +482,47 @@ fn Not(cx: block, V: ValueRef) -> ValueRef {\n }\n \n /* Memory */\n-fn Malloc(cx: block, Ty: TypeRef) -> ValueRef {\n+pub fn Malloc(cx: block, Ty: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n         count_insn(cx, \"malloc\");\n         return llvm::LLVMBuildMalloc(B(cx), Ty, noname());\n     }\n }\n \n-fn ArrayMalloc(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n+pub fn ArrayMalloc(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n         count_insn(cx, \"arraymalloc\");\n         return llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, noname());\n     }\n }\n \n-fn Alloca(cx: block, Ty: TypeRef) -> ValueRef {\n+pub fn Alloca(cx: block, Ty: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(Ty)); }\n         count_insn(cx, \"alloca\");\n         return llvm::LLVMBuildAlloca(B(cx), Ty, noname());\n     }\n }\n \n-fn ArrayAlloca(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n+pub fn ArrayAlloca(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(Ty)); }\n         count_insn(cx, \"arrayalloca\");\n         return llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, noname());\n     }\n }\n \n-fn Free(cx: block, PointerVal: ValueRef) {\n+pub fn Free(cx: block, PointerVal: ValueRef) {\n     unsafe {\n         if cx.unreachable { return; }\n         count_insn(cx, \"free\");\n         llvm::LLVMBuildFree(B(cx), PointerVal);\n     }\n }\n \n-fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n+pub fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable {\n@@ -535,7 +536,7 @@ fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n     }\n }\n \n-fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n+pub fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n     unsafe {\n         if cx.unreachable { return; }\n         debug!(\"Store %s -> %s\",\n@@ -546,7 +547,7 @@ fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n     }\n }\n \n-fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n+pub fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n         count_insn(cx, \"gep\");\n@@ -559,13 +560,13 @@ fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n // in C_i32()\n //\n // XXX: Use a small-vector optimization to avoid allocations here.\n-fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n+pub fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     let v = do vec::map(ixs) |i| { C_i32(*i as i32) };\n     count_insn(cx, \"gepi\");\n     return InBoundsGEP(cx, base, v);\n }\n \n-fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) ->\n+pub fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) ->\n    ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n@@ -579,7 +580,7 @@ fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) ->\n     }\n }\n \n-fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n+pub fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n         count_insn(cx, \"structgep\");\n@@ -590,15 +591,15 @@ fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     }\n }\n \n-fn GlobalString(cx: block, _Str: *libc::c_char) -> ValueRef {\n+pub fn GlobalString(cx: block, _Str: *libc::c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n         count_insn(cx, \"globalstring\");\n         return llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n     }\n }\n \n-fn GlobalStringPtr(cx: block, _Str: *libc::c_char) -> ValueRef {\n+pub fn GlobalStringPtr(cx: block, _Str: *libc::c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n         count_insn(cx, \"globalstringptr\");\n@@ -607,127 +608,127 @@ fn GlobalStringPtr(cx: block, _Str: *libc::c_char) -> ValueRef {\n }\n \n /* Casts */\n-fn Trunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn Trunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"trunc\");\n         return llvm::LLVMBuildTrunc(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn ZExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn ZExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"zext\");\n         return llvm::LLVMBuildZExt(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn SExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn SExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"sext\");\n         return llvm::LLVMBuildSExt(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn FPToUI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn FPToUI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"fptoui\");\n         return llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn FPToSI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn FPToSI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"fptosi\");\n         return llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn UIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn UIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"uitofp\");\n         return llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn SIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn SIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"sitofp\");\n         return llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn FPTrunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn FPTrunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"fptrunc\");\n         return llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn FPExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn FPExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"fpext\");\n         return llvm::LLVMBuildFPExt(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn PtrToInt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn PtrToInt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"ptrtoint\");\n         return llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn IntToPtr(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn IntToPtr(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"inttoptr\");\n         return llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn BitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn BitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"bitcast\");\n         return llvm::LLVMBuildBitCast(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn ZExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn ZExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"zextorbitcast\");\n         return llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn SExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn SExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"sextorbitcast\");\n         return llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"truncorbitcast\");\n         return llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: TypeRef, _: *u8)\n+pub fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: TypeRef, _: *u8)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n@@ -736,23 +737,23 @@ fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: TypeRef, _: *u8)\n     }\n }\n \n-fn PointerCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn PointerCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"pointercast\");\n         return llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn IntCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn IntCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"intcast\");\n         return llvm::LLVMBuildIntCast(B(cx), Val, DestTy, noname());\n     }\n }\n \n-fn FPCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn FPCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"fpcast\");\n@@ -762,7 +763,7 @@ fn FPCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n \n \n /* Comparisons */\n-fn ICmp(cx: block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n+pub fn ICmp(cx: block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n@@ -771,7 +772,7 @@ fn ICmp(cx: block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n     }\n }\n \n-fn FCmp(cx: block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n+pub fn FCmp(cx: block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n@@ -781,15 +782,15 @@ fn FCmp(cx: block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n }\n \n /* Miscellaneous instructions */\n-fn EmptyPhi(cx: block, Ty: TypeRef) -> ValueRef {\n+pub fn EmptyPhi(cx: block, Ty: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n         count_insn(cx, \"emptyphi\");\n         return llvm::LLVMBuildPhi(B(cx), Ty, noname());\n     }\n }\n \n-fn Phi(cx: block, Ty: TypeRef, vals: ~[ValueRef], bbs: ~[BasicBlockRef])\n+pub fn Phi(cx: block, Ty: TypeRef, vals: ~[ValueRef], bbs: ~[BasicBlockRef])\n     -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n@@ -803,7 +804,7 @@ fn Phi(cx: block, Ty: TypeRef, vals: ~[ValueRef], bbs: ~[BasicBlockRef])\n     }\n }\n \n-fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n+pub fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n     unsafe {\n         if llvm::LLVMIsUndef(phi) == lib::llvm::True { return; }\n         let valptr = cast::reinterpret_cast(&ptr::addr_of(&val));\n@@ -812,7 +813,7 @@ fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n     }\n }\n \n-fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n+pub fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         let ty = val_ty(Fn);\n@@ -823,7 +824,7 @@ fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n     }\n }\n \n-fn add_span_comment(bcx: block, sp: span, text: ~str) {\n+pub fn add_span_comment(bcx: block, sp: span, text: ~str) {\n     let ccx = bcx.ccx();\n     if !ccx.sess.no_asm_comments() {\n         let s = text + ~\" (\" + ccx.sess.codemap.span_to_str(sp)\n@@ -833,7 +834,7 @@ fn add_span_comment(bcx: block, sp: span, text: ~str) {\n     }\n }\n \n-fn add_comment(bcx: block, text: ~str) {\n+pub fn add_comment(bcx: block, text: ~str) {\n     unsafe {\n         let ccx = bcx.ccx();\n         if !ccx.sess.no_asm_comments() {\n@@ -852,7 +853,7 @@ fn add_comment(bcx: block, text: ~str) {\n     }\n }\n \n-fn Call(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n+pub fn Call(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {\n         count_insn(cx, \"call\");\n@@ -867,7 +868,7 @@ fn Call(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n     }\n }\n \n-fn FastCall(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n+pub fn FastCall(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {\n         count_insn(cx, \"fastcall\");\n@@ -878,8 +879,8 @@ fn FastCall(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n     }\n }\n \n-fn CallWithConv(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n-                Conv: CallConv) -> ValueRef {\n+pub fn CallWithConv(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n+                    Conv: CallConv) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {\n         count_insn(cx, \"callwithconv\");\n@@ -890,7 +891,7 @@ fn CallWithConv(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n     }\n }\n \n-fn Select(cx: block, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n+pub fn Select(cx: block, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n    ValueRef {\n     unsafe {\n         if cx.unreachable { return _Undef(Then); }\n@@ -899,15 +900,15 @@ fn Select(cx: block, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n     }\n }\n \n-fn VAArg(cx: block, list: ValueRef, Ty: TypeRef) -> ValueRef {\n+pub fn VAArg(cx: block, list: ValueRef, Ty: TypeRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n         count_insn(cx, \"vaarg\");\n         return llvm::LLVMBuildVAArg(B(cx), list, Ty, noname());\n     }\n }\n \n-fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) ->\n+pub fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) ->\n    ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n@@ -916,7 +917,7 @@ fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) ->\n     }\n }\n \n-fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n+pub fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n                  Index: ValueRef) {\n     unsafe {\n         if cx.unreachable { return; }\n@@ -925,16 +926,16 @@ fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n     }\n }\n \n-fn ShuffleVector(cx: block, V1: ValueRef, V2: ValueRef,\n-                 Mask: ValueRef) {\n+pub fn ShuffleVector(cx: block, V1: ValueRef, V2: ValueRef,\n+                     Mask: ValueRef) {\n     unsafe {\n         if cx.unreachable { return; }\n         count_insn(cx, \"shufflevector\");\n         llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname());\n     }\n }\n \n-fn ExtractValue(cx: block, AggVal: ValueRef, Index: uint) -> ValueRef {\n+pub fn ExtractValue(cx: block, AggVal: ValueRef, Index: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n         count_insn(cx, \"extractvalue\");\n@@ -943,8 +944,8 @@ fn ExtractValue(cx: block, AggVal: ValueRef, Index: uint) -> ValueRef {\n     }\n }\n \n-fn InsertValue(cx: block, AggVal: ValueRef, EltVal: ValueRef,\n-               Index: uint) {\n+pub fn InsertValue(cx: block, AggVal: ValueRef, EltVal: ValueRef,\n+                   Index: uint) {\n     unsafe {\n         if cx.unreachable { return; }\n         count_insn(cx, \"insertvalue\");\n@@ -953,23 +954,23 @@ fn InsertValue(cx: block, AggVal: ValueRef, EltVal: ValueRef,\n     }\n }\n \n-fn IsNull(cx: block, Val: ValueRef) -> ValueRef {\n+pub fn IsNull(cx: block, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n         count_insn(cx, \"isnull\");\n         return llvm::LLVMBuildIsNull(B(cx), Val, noname());\n     }\n }\n \n-fn IsNotNull(cx: block, Val: ValueRef) -> ValueRef {\n+pub fn IsNotNull(cx: block, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n         count_insn(cx, \"isnotnull\");\n         return llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n     }\n }\n \n-fn PtrDiff(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn PtrDiff(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type); }\n@@ -978,7 +979,7 @@ fn PtrDiff(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     }\n }\n \n-fn Trap(cx: block) {\n+pub fn Trap(cx: block) {\n     unsafe {\n         if cx.unreachable { return; }\n         let b = B(cx);\n@@ -998,8 +999,8 @@ fn Trap(cx: block) {\n     }\n }\n \n-fn LandingPad(cx: block, Ty: TypeRef, PersFn: ValueRef,\n-              NumClauses: uint) -> ValueRef {\n+pub fn LandingPad(cx: block, Ty: TypeRef, PersFn: ValueRef,\n+                  NumClauses: uint) -> ValueRef {\n     unsafe {\n         check_not_terminated(cx);\n         assert !cx.unreachable;\n@@ -1009,14 +1010,14 @@ fn LandingPad(cx: block, Ty: TypeRef, PersFn: ValueRef,\n     }\n }\n \n-fn SetCleanup(cx: block, LandingPad: ValueRef) {\n+pub fn SetCleanup(cx: block, LandingPad: ValueRef) {\n     unsafe {\n         count_insn(cx, \"setcleanup\");\n         llvm::LLVMSetCleanup(LandingPad, lib::llvm::True);\n     }\n }\n \n-fn Resume(cx: block, Exn: ValueRef) -> ValueRef {\n+pub fn Resume(cx: block, Exn: ValueRef) -> ValueRef {\n     unsafe {\n         check_not_terminated(cx);\n         terminate(cx, \"Resume\");\n@@ -1026,16 +1027,16 @@ fn Resume(cx: block, Exn: ValueRef) -> ValueRef {\n }\n \n // Atomic Operations\n-fn AtomicCmpXchg(cx: block, dst: ValueRef,\n-                 cmp: ValueRef, src: ValueRef,\n-                 order: AtomicOrdering) -> ValueRef {\n+pub fn AtomicCmpXchg(cx: block, dst: ValueRef,\n+                     cmp: ValueRef, src: ValueRef,\n+                     order: AtomicOrdering) -> ValueRef {\n     unsafe {\n         llvm::LLVMBuildAtomicCmpXchg(B(cx), dst, cmp, src, order)\n     }\n }\n-fn AtomicRMW(cx: block, op: AtomicBinOp,\n-             dst: ValueRef, src: ValueRef,\n-             order: AtomicOrdering) -> ValueRef {\n+pub fn AtomicRMW(cx: block, op: AtomicBinOp,\n+                 dst: ValueRef, src: ValueRef,\n+                 order: AtomicOrdering) -> ValueRef {\n     unsafe {\n         llvm::LLVMBuildAtomicRMW(B(cx), op, dst, src, order)\n     }"}, {"sha": "908c567761411277ae3f0e86fa256814af4b8421", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -13,29 +13,26 @@ use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n \n-export ABIInfo, LLVMType, FnType;\n-export llvm_abi_info;\n-\n-trait ABIInfo {\n+pub trait ABIInfo {\n     fn compute_info(&self,\n                     atys: &[TypeRef],\n                     rty: TypeRef,\n                     ret_def: bool) -> FnType;\n }\n \n-struct LLVMType {\n+pub struct LLVMType {\n     cast: bool,\n     ty: TypeRef\n }\n \n-struct FnType {\n+pub struct FnType {\n     arg_tys: ~[LLVMType],\n     ret_ty: LLVMType,\n     attrs: ~[Option<Attribute>],\n     sret: bool\n }\n \n-impl FnType {\n+pub impl FnType {\n     fn decl_fn(&self, decl: fn(fnty: TypeRef) -> ValueRef) -> ValueRef {\n         let atys = vec::map(self.arg_tys, |t| t.ty);\n         let rty = self.ret_ty.ty;\n@@ -208,7 +205,7 @@ impl LLVM_ABIInfo: ABIInfo {\n     }\n }\n \n-fn llvm_abi_info() -> ABIInfo {\n+pub fn llvm_abi_info() -> ABIInfo {\n     return LLVM_ABIInfo as ABIInfo;\n }\n "}, {"sha": "e4a70241d1a65dde41714c87e0d4a19486f08830", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -17,8 +17,6 @@ use lib::llvm::{StructRetAttribute, ByValAttribute};\n use middle::trans::common::*;\n use middle::trans::cabi::*;\n \n-export x86_64_abi_info;\n-\n enum x86_64_reg_class {\n     no_class,\n     integer_class,\n@@ -412,6 +410,6 @@ impl X86_64_ABIInfo: ABIInfo {\n     }\n }\n \n-fn x86_64_abi_info() -> ABIInfo {\n+pub fn x86_64_abi_info() -> ABIInfo {\n     return X86_64_ABIInfo as ABIInfo;\n }"}, {"sha": "f6a6c5af5ff5d9d6155a5c5c6081427d561605a5", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 43, "deletions": 47, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -23,6 +23,7 @@ use middle::trans::common::*;\n use middle::trans::datum::{Datum, INIT, ByRef, ByValue, FromLvalue};\n use middle::trans::expr;\n use middle::trans::glue;\n+use middle::trans::machine;\n use middle::trans::type_of::*;\n use util::ppaux::ty_to_str;\n \n@@ -103,7 +104,7 @@ use syntax::print::pprust::expr_to_str;\n //\n // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-enum EnvAction {\n+pub enum EnvAction {\n     /// Copy the value from this llvm ValueRef into the environment.\n     EnvStore,\n \n@@ -114,12 +115,12 @@ enum EnvAction {\n     EnvRef\n }\n \n-struct EnvValue {\n+pub struct EnvValue {\n     action: EnvAction,\n     datum: Datum\n }\n \n-impl EnvAction {\n+pub impl EnvAction {\n     fn to_str() -> ~str {\n         match self {\n             EnvStore => ~\"EnvStore\",\n@@ -129,21 +130,21 @@ impl EnvAction {\n     }\n }\n \n-impl EnvValue {\n+pub impl EnvValue {\n     fn to_str(ccx: @crate_ctxt) -> ~str {\n         fmt!(\"%s(%s)\", self.action.to_str(), self.datum.to_str(ccx))\n     }\n }\n \n-fn mk_tuplified_uniq_cbox_ty(tcx: ty::ctxt, cdata_ty: ty::t) -> ty::t {\n+pub fn mk_tuplified_uniq_cbox_ty(tcx: ty::ctxt, cdata_ty: ty::t) -> ty::t {\n     let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n     return ty::mk_imm_uniq(tcx, cbox_ty);\n }\n \n // Given a closure ty, emits a corresponding tuple ty\n-fn mk_closure_tys(tcx: ty::ctxt,\n-                  bound_values: ~[EnvValue])\n-    -> ty::t {\n+pub fn mk_closure_tys(tcx: ty::ctxt,\n+                      bound_values: ~[EnvValue])\n+                   -> ty::t {\n     // determine the types of the values in the env.  Note that this\n     // is the actual types that will be stored in the map, not the\n     // logical types as the user sees them, so by-ref upvars must be\n@@ -159,9 +160,8 @@ fn mk_closure_tys(tcx: ty::ctxt,\n     return cdata_ty;\n }\n \n-fn allocate_cbox(bcx: block, proto: ast::Proto, cdata_ty: ty::t)\n-    -> Result\n-{\n+pub fn allocate_cbox(bcx: block, proto: ast::Proto, cdata_ty: ty::t)\n+                  -> Result {\n     let _icx = bcx.insn_ctxt(\"closure::allocate_cbox\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n@@ -196,7 +196,7 @@ fn allocate_cbox(bcx: block, proto: ast::Proto, cdata_ty: ty::t)\n     }\n }\n \n-type closure_result = {\n+pub type closure_result = {\n     llbox: ValueRef,     // llvalue of ptr to closure\n     cdata_ty: ty::t,      // type of the closure data\n     bcx: block     // final bcx\n@@ -206,9 +206,9 @@ type closure_result = {\n // construct a closure out of them. If copying is true, it is a\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n-fn store_environment(bcx: block,\n-                     bound_values: ~[EnvValue],\n-                     proto: ast::Proto) -> closure_result {\n+pub fn store_environment(bcx: block,\n+                         bound_values: ~[EnvValue],\n+                         proto: ast::Proto) -> closure_result {\n     let _icx = bcx.insn_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n@@ -263,10 +263,10 @@ fn store_environment(bcx: block,\n \n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n-fn build_closure(bcx0: block,\n-                 cap_vars: ~[capture::capture_var],\n-                 proto: ast::Proto,\n-                 include_ret_handle: Option<ValueRef>) -> closure_result {\n+pub fn build_closure(bcx0: block,\n+                     cap_vars: ~[capture::capture_var],\n+                     proto: ast::Proto,\n+                     include_ret_handle: Option<ValueRef>) -> closure_result {\n     let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n     // If we need to, package up the iterator body to call\n     let mut bcx = bcx0;;\n@@ -326,11 +326,11 @@ fn build_closure(bcx0: block,\n // Given an enclosing block context, a new function context, a closure type,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n-fn load_environment(fcx: fn_ctxt,\n-                    cdata_ty: ty::t,\n-                    cap_vars: ~[capture::capture_var],\n-                    load_ret_handle: bool,\n-                    proto: ast::Proto) {\n+pub fn load_environment(fcx: fn_ctxt,\n+                        cdata_ty: ty::t,\n+                        cap_vars: ~[capture::capture_var],\n+                        load_ret_handle: bool,\n+                        proto: ast::Proto) {\n     let _icx = fcx.insn_ctxt(\"closure::load_environment\");\n \n     let llloadenv = match fcx.llloadenv {\n@@ -377,16 +377,15 @@ fn load_environment(fcx: fn_ctxt,\n     }\n }\n \n-fn trans_expr_fn(bcx: block,\n-                 proto: ast::Proto,\n-                 +decl: ast::fn_decl,\n-                 +body: ast::blk,\n-                 outer_id: ast::node_id,\n-                 user_id: ast::node_id,\n-                 cap_clause: ast::capture_clause,\n-                 is_loop_body: Option<Option<ValueRef>>,\n-                 dest: expr::Dest) -> block\n-{\n+pub fn trans_expr_fn(bcx: block,\n+                     proto: ast::Proto,\n+                     +decl: ast::fn_decl,\n+                     +body: ast::blk,\n+                     outer_id: ast::node_id,\n+                     user_id: ast::node_id,\n+                     cap_clause: ast::capture_clause,\n+                     is_loop_body: Option<Option<ValueRef>>,\n+                     dest: expr::Dest) -> block {\n     /*!\n      *\n      * Translates the body of a closure expression.\n@@ -462,13 +461,11 @@ fn trans_expr_fn(bcx: block,\n     return bcx;\n }\n \n-fn make_fn_glue(\n-    cx: block,\n-    v: ValueRef,\n-    t: ty::t,\n-    glue_fn: fn@(block, v: ValueRef, t: ty::t) -> block)\n-    -> block\n-{\n+pub fn make_fn_glue(cx: block,\n+                    v: ValueRef,\n+                    t: ty::t,\n+                    glue_fn: fn@(block, v: ValueRef, t: ty::t) -> block)\n+                 -> block {\n     let _icx = cx.insn_ctxt(\"closure::make_fn_glue\");\n     let bcx = cx;\n     let tcx = cx.tcx();\n@@ -487,12 +484,11 @@ fn make_fn_glue(\n     }\n }\n \n-fn make_opaque_cbox_take_glue(\n+pub fn make_opaque_cbox_take_glue(\n     bcx: block,\n     proto: ast::Proto,\n     cboxptr: ValueRef)     // ptr to ptr to the opaque closure\n-    -> block\n-{\n+    -> block {\n     // Easy cases:\n     let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_take_glue\");\n     match proto {\n@@ -521,7 +517,7 @@ fn make_opaque_cbox_take_glue(\n         let sz = Load(bcx, GEPi(bcx, tydesc, [0u, abi::tydesc_field_size]));\n \n         // Adjust sz to account for the rust_opaque_box header fields\n-        let sz = Add(bcx, sz, shape::llsize_of(ccx, T_box_header(ccx)));\n+        let sz = Add(bcx, sz, machine::llsize_of(ccx, T_box_header(ccx)));\n \n         // Allocate memory, update original ptr, and copy existing data\n         let opaque_tydesc = PointerCast(bcx, tydesc, T_ptr(T_i8()));\n@@ -547,7 +543,7 @@ fn make_opaque_cbox_take_glue(\n     }\n }\n \n-fn make_opaque_cbox_drop_glue(\n+pub fn make_opaque_cbox_drop_glue(\n     bcx: block,\n     proto: ast::Proto,\n     cboxptr: ValueRef)     // ptr to the opaque closure\n@@ -568,7 +564,7 @@ fn make_opaque_cbox_drop_glue(\n     }\n }\n \n-fn make_opaque_cbox_free_glue(\n+pub fn make_opaque_cbox_free_glue(\n     bcx: block,\n     proto: ast::Proto,\n     cbox: ValueRef)     // ptr to ptr to the opaque closure"}, {"sha": "7ab90dd1ef7d7d2cae72b782286055511f26ec62", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 168, "deletions": 212, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -61,8 +61,8 @@ use syntax::parse::token::ident_interner;\n use syntax::print::pprust::expr_to_str;\n use syntax::{ast, ast_map};\n \n-type namegen = fn@(~str) -> ident;\n-fn new_namegen(intr: @ident_interner) -> namegen {\n+pub type namegen = fn@(~str) -> ident;\n+pub fn new_namegen(intr: @ident_interner) -> namegen {\n     return fn@(prefix: ~str) -> ident {\n         // XXX: Bad copies.\n         return intr.gensym(@fmt!(\"%s_%u\",\n@@ -71,23 +71,23 @@ fn new_namegen(intr: @ident_interner) -> namegen {\n     };\n }\n \n-type addrspace = c_uint;\n+pub type addrspace = c_uint;\n \n // Address spaces communicate to LLVM which destructors need to run for\n-// specifc types.\n+// specific types.\n //    0 is ignored by the GC, and is used for all non-GC'd pointers.\n //    1 is for opaque GC'd boxes.\n //    >= 2 are for specific types (e.g. resources).\n-const default_addrspace: addrspace = 0;\n-const gc_box_addrspace: addrspace = 1;\n+pub const default_addrspace: addrspace = 0;\n+pub const gc_box_addrspace: addrspace = 1;\n \n-type addrspace_gen = fn@() -> addrspace;\n-fn new_addrspace_gen() -> addrspace_gen {\n+pub type addrspace_gen = fn@() -> addrspace;\n+pub fn new_addrspace_gen() -> addrspace_gen {\n     let i = @mut 1;\n     return fn@() -> addrspace { *i += 1; *i };\n }\n \n-type tydesc_info =\n+pub type tydesc_info =\n     {ty: ty::t,\n      tydesc: ValueRef,\n      size: ValueRef,\n@@ -124,7 +124,7 @@ type tydesc_info =\n  *\n  */\n \n-type stats =\n+pub type stats =\n     {mut n_static_tydescs: uint,\n      mut n_glues_created: uint,\n      mut n_null_glues: uint,\n@@ -137,7 +137,7 @@ type stats =\n      llvm_insns: HashMap<~str, uint>,\n      fn_times: @mut ~[{ident: ~str, time: int}]};\n \n-struct BuilderRef_res {\n+pub struct BuilderRef_res {\n     B: BuilderRef,\n     drop {\n         unsafe {\n@@ -146,14 +146,14 @@ struct BuilderRef_res {\n     }\n }\n \n-fn BuilderRef_res(B: BuilderRef) -> BuilderRef_res {\n+pub fn BuilderRef_res(B: BuilderRef) -> BuilderRef_res {\n     BuilderRef_res {\n         B: B\n     }\n }\n \n // Crate context.  Every crate we compile has one of these.\n-struct crate_ctxt {\n+pub struct crate_ctxt {\n      sess: session::Session,\n      llmod: ModuleRef,\n      td: target_data,\n@@ -225,24 +225,24 @@ struct crate_ctxt {\n }\n \n // Types used for llself.\n-struct ValSelfData {\n+pub struct ValSelfData {\n     v: ValueRef,\n     t: ty::t,\n     is_owned: bool\n }\n \n-enum local_val { local_mem(ValueRef), local_imm(ValueRef), }\n+pub enum local_val { local_mem(ValueRef), local_imm(ValueRef), }\n \n // Here `self_ty` is the real type of the self parameter to this method. It\n // will only be set in the case of default methods.\n-struct param_substs {\n+pub struct param_substs {\n     tys: ~[ty::t],\n     vtables: Option<typeck::vtable_res>,\n     bounds: @~[ty::param_bounds],\n     self_ty: Option<ty::t>\n }\n \n-fn param_substs_to_str(tcx: ty::ctxt, substs: &param_substs) -> ~str {\n+pub fn param_substs_to_str(tcx: ty::ctxt, substs: &param_substs) -> ~str {\n     fmt!(\"param_substs {tys:%?, vtables:%?, bounds:%?}\",\n          substs.tys.map(|t| ty_to_str(tcx, *t)),\n          substs.vtables.map(|vs| vs.map(|v| v.to_str(tcx))),\n@@ -251,7 +251,7 @@ fn param_substs_to_str(tcx: ty::ctxt, substs: &param_substs) -> ~str {\n \n // Function context.  Every LLVM function we create will have one of\n // these.\n-struct fn_ctxt_ {\n+pub struct fn_ctxt_ {\n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n     // address of the first instruction in the sequence of\n     // instructions for this function that will go in the .text\n@@ -319,60 +319,40 @@ struct fn_ctxt_ {\n \n pub type fn_ctxt = @fn_ctxt_;\n \n-fn warn_not_to_commit(ccx: @crate_ctxt, msg: ~str) {\n+pub fn warn_not_to_commit(ccx: @crate_ctxt, msg: ~str) {\n     if !ccx.do_not_commit_warning_issued {\n         ccx.do_not_commit_warning_issued = true;\n         ccx.sess.warn(msg + ~\" -- do not commit like this!\");\n     }\n }\n \n // Heap selectors. Indicate which heap something should go on.\n-enum heap {\n+pub enum heap {\n     heap_shared,\n     heap_exchange,\n }\n \n-enum cleantype {\n+#[deriving_eq]\n+pub enum cleantype {\n     normal_exit_only,\n     normal_exit_and_unwind\n }\n \n-enum cleanup {\n+pub enum cleanup {\n     clean(fn@(block) -> block, cleantype),\n     clean_temp(ValueRef, fn@(block) -> block, cleantype),\n }\n \n-impl cleantype : cmp::Eq {\n-    pure fn eq(&self, other: &cleantype) -> bool {\n-        match (*self) {\n-            normal_exit_only => {\n-                match (*other) {\n-                    normal_exit_only => true,\n-                    _ => false\n-                }\n-            }\n-            normal_exit_and_unwind => {\n-                match (*other) {\n-                    normal_exit_and_unwind => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &cleantype) -> bool { !(*self).eq(other) }\n-}\n-\n // Used to remember and reuse existing cleanup paths\n // target: none means the path ends in an resume instruction\n-type cleanup_path = {target: Option<BasicBlockRef>,\n-                     dest: BasicBlockRef};\n+pub type cleanup_path = {target: Option<BasicBlockRef>, dest: BasicBlockRef};\n \n-fn scope_clean_changed(scope_info: scope_info) {\n+pub fn scope_clean_changed(scope_info: scope_info) {\n     if scope_info.cleanup_paths.len() > 0u { scope_info.cleanup_paths = ~[]; }\n     scope_info.landing_pad = None;\n }\n \n-fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n+pub fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n     if ty::type_needs_unwind_cleanup(cx, ty) {\n         normal_exit_and_unwind\n     } else {\n@@ -386,7 +366,7 @@ fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n // but have trouble knowing where non-immediates are on the stack. For\n // non-immediates, we must add an additional level of indirection, which\n // allows us to alloca a pointer with the right addrspace.\n-fn root_for_cleanup(bcx: block, v: ValueRef, t: ty::t)\n+pub fn root_for_cleanup(bcx: block, v: ValueRef, t: ty::t)\n     -> {root: ValueRef, rooted: bool} {\n     let ccx = bcx.ccx();\n \n@@ -401,7 +381,7 @@ fn root_for_cleanup(bcx: block, v: ValueRef, t: ty::t)\n     }\n }\n \n-fn add_clean(bcx: block, val: ValueRef, t: ty::t) {\n+pub fn add_clean(bcx: block, val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n     debug!(\"add_clean(%s, %s, %s)\",\n            bcx.to_str(), val_str(bcx.ccx().tn, val),\n@@ -416,7 +396,7 @@ fn add_clean(bcx: block, val: ValueRef, t: ty::t) {\n     }\n }\n \n-fn add_clean_temp_immediate(cx: block, val: ValueRef, ty: ty::t) {\n+pub fn add_clean_temp_immediate(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n     debug!(\"add_clean_temp_immediate(%s, %s, %s)\",\n            cx.to_str(), val_str(cx.ccx().tn, val),\n@@ -429,7 +409,7 @@ fn add_clean_temp_immediate(cx: block, val: ValueRef, ty: ty::t) {\n         scope_clean_changed(scope_info);\n     }\n }\n-fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n+pub fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n     if !ty::type_needs_drop(bcx.tcx(), t) { return; }\n     debug!(\"add_clean_temp_mem(%s, %s, %s)\",\n            bcx.to_str(), val_str(bcx.ccx().tn, val),\n@@ -443,7 +423,7 @@ fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n         scope_clean_changed(scope_info);\n     }\n }\n-fn add_clean_frozen_root(bcx: block, val: ValueRef, t: ty::t) {\n+pub fn add_clean_frozen_root(bcx: block, val: ValueRef, t: ty::t) {\n     debug!(\"add_clean_frozen_root(%s, %s, %s)\",\n            bcx.to_str(), val_str(bcx.ccx().tn, val),\n            ty_to_str(bcx.ccx().tcx, t));\n@@ -468,7 +448,7 @@ fn add_clean_frozen_root(bcx: block, val: ValueRef, t: ty::t) {\n         scope_clean_changed(scope_info);\n     }\n }\n-fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n+pub fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n     let free_fn = match heap {\n       heap_shared => {\n         let f: @fn(block) -> block = |a| glue::trans_free(a, ptr);\n@@ -490,7 +470,7 @@ fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n // to a system where we can also cancel the cleanup on local variables, but\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n-fn revoke_clean(cx: block, val: ValueRef) {\n+pub fn revoke_clean(cx: block, val: ValueRef) {\n     do in_scope_cx(cx) |scope_info| {\n         let cleanup_pos = vec::position(\n             scope_info.cleanups,\n@@ -509,14 +489,14 @@ fn revoke_clean(cx: block, val: ValueRef) {\n     }\n }\n \n-fn block_cleanups(bcx: block) -> ~[cleanup] {\n+pub fn block_cleanups(bcx: block) -> ~[cleanup] {\n     match bcx.kind {\n        block_non_scope  => ~[],\n        block_scope(ref inf) => /*bad*/copy inf.cleanups\n     }\n }\n \n-enum block_kind {\n+pub enum block_kind {\n     // A scope at the end of which temporary values created inside of it are\n     // cleaned up. May correspond to an actual block in the language, but also\n     // to an implicit scope, for example, calls introduce an implicit scope in\n@@ -530,7 +510,7 @@ enum block_kind {\n     block_non_scope,\n }\n \n-struct scope_info {\n+pub struct scope_info {\n     loop_break: Option<block>,\n     loop_label: Option<ident>,\n     // A list of functions that must be run at when leaving this\n@@ -544,32 +524,32 @@ struct scope_info {\n     mut landing_pad: Option<BasicBlockRef>,\n }\n \n-trait get_node_info {\n+pub trait get_node_info {\n     fn info() -> Option<node_info>;\n }\n \n-impl @ast::expr: get_node_info {\n+pub impl @ast::expr: get_node_info {\n     fn info() -> Option<node_info> {\n         Some({id: self.id, span: self.span})\n     }\n }\n \n-impl ast::blk: get_node_info {\n+pub impl ast::blk: get_node_info {\n     fn info() -> Option<node_info> {\n         Some({id: self.node.id, span: self.span})\n     }\n }\n \n // XXX: Work around a trait parsing bug. remove after snapshot\n-type optional_boxed_ast_expr = Option<@ast::expr>;\n+pub type optional_boxed_ast_expr = Option<@ast::expr>;\n \n-impl optional_boxed_ast_expr: get_node_info {\n+pub impl optional_boxed_ast_expr: get_node_info {\n     fn info() -> Option<node_info> {\n         self.chain_ref(|s| s.info())\n     }\n }\n \n-type node_info = {\n+pub type node_info = {\n     id: ast::node_id,\n     span: span\n };\n@@ -579,7 +559,7 @@ type node_info = {\n // code.  Each basic block we generate is attached to a function, typically\n // with many basic blocks per function.  All the basic blocks attached to a\n // function are organized as a directed graph.\n-struct block_ {\n+pub struct block_ {\n     // The BasicBlockRef returned from a call to\n     // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n     // block to the function pointed to by llfn.  We insert\n@@ -600,8 +580,8 @@ struct block_ {\n     fcx: fn_ctxt\n }\n \n-fn block_(llbb: BasicBlockRef, parent: Option<block>, -kind: block_kind,\n-          is_lpad: bool, node_info: Option<node_info>, fcx: fn_ctxt)\n+pub fn block_(llbb: BasicBlockRef, parent: Option<block>, -kind: block_kind,\n+              is_lpad: bool, node_info: Option<node_info>, fcx: fn_ctxt)\n     -> block_ {\n \n     block_ {\n@@ -618,49 +598,49 @@ fn block_(llbb: BasicBlockRef, parent: Option<block>, -kind: block_kind,\n \n /* This must be enum and not type, or trans goes into an infinite loop (#2572)\n  */\n-enum block = @block_;\n+pub enum block = @block_;\n \n-fn mk_block(llbb: BasicBlockRef, parent: Option<block>, -kind: block_kind,\n+pub fn mk_block(llbb: BasicBlockRef, parent: Option<block>, -kind: block_kind,\n             is_lpad: bool, node_info: Option<node_info>, fcx: fn_ctxt)\n     -> block {\n     block(@block_(llbb, parent, move kind, is_lpad, node_info, fcx))\n }\n \n // First two args are retptr, env\n-const first_real_arg: uint = 2u;\n+pub const first_real_arg: uint = 2u;\n \n-struct Result {\n+pub struct Result {\n     bcx: block,\n     val: ValueRef\n }\n \n-fn rslt(bcx: block, val: ValueRef) -> Result {\n+pub fn rslt(bcx: block, val: ValueRef) -> Result {\n     Result {bcx: bcx, val: val}\n }\n \n-impl Result {\n+pub impl Result {\n     fn unpack(bcx: &mut block) -> ValueRef {\n         *bcx = self.bcx;\n         return self.val;\n     }\n }\n \n-fn ty_str(tn: type_names, t: TypeRef) -> @str {\n+pub fn ty_str(tn: type_names, t: TypeRef) -> @str {\n     return lib::llvm::type_to_str(tn, t);\n }\n \n-fn val_ty(v: ValueRef) -> TypeRef {\n+pub fn val_ty(v: ValueRef) -> TypeRef {\n     unsafe {\n         return llvm::LLVMTypeOf(v);\n     }\n }\n \n-fn val_str(tn: type_names, v: ValueRef) -> @str {\n+pub fn val_str(tn: type_names, v: ValueRef) -> @str {\n     return ty_str(tn, val_ty(v));\n }\n \n // Returns the nth element of the given LLVM structure type.\n-fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef {\n+pub fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef {\n     unsafe {\n         let elt_count = llvm::LLVMCountStructElementTypes(llstructty) as uint;\n         assert (n < elt_count);\n@@ -672,7 +652,7 @@ fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef {\n     }\n }\n \n-fn in_scope_cx(cx: block, f: fn(scope_info)) {\n+pub fn in_scope_cx(cx: block, f: fn(scope_info)) {\n     let mut cur = cx;\n     loop {\n         match cur.kind {\n@@ -688,7 +668,7 @@ fn in_scope_cx(cx: block, f: fn(scope_info)) {\n     }\n }\n \n-fn block_parent(cx: block) -> block {\n+pub fn block_parent(cx: block) -> block {\n     match cx.parent {\n       Some(b) => b,\n       None    => cx.sess().bug(fmt!(\"block_parent called on root block %?\",\n@@ -698,7 +678,7 @@ fn block_parent(cx: block) -> block {\n \n // Accessors\n \n-impl block {\n+pub impl block {\n     pure fn ccx() -> @crate_ctxt { self.fcx.ccx }\n     pure fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n     pure fn sess() -> Session { self.fcx.ccx.sess }\n@@ -753,43 +733,43 @@ impl block {\n }\n \n // LLVM type constructors.\n-fn T_void() -> TypeRef {\n+pub fn T_void() -> TypeRef {\n     unsafe {\n         return llvm::LLVMVoidType();\n     }\n }\n \n-fn T_nil() -> TypeRef {\n+pub fn T_nil() -> TypeRef {\n     return T_struct(~[])\n }\n \n-fn T_metadata() -> TypeRef { unsafe { return llvm::LLVMMetadataType(); } }\n+pub fn T_metadata() -> TypeRef { unsafe { return llvm::LLVMMetadataType(); } }\n \n-fn T_i1() -> TypeRef { unsafe { return llvm::LLVMInt1Type(); } }\n+pub fn T_i1() -> TypeRef { unsafe { return llvm::LLVMInt1Type(); } }\n \n-fn T_i8() -> TypeRef { unsafe { return llvm::LLVMInt8Type(); } }\n+pub fn T_i8() -> TypeRef { unsafe { return llvm::LLVMInt8Type(); } }\n \n-fn T_i16() -> TypeRef { unsafe { return llvm::LLVMInt16Type(); } }\n+pub fn T_i16() -> TypeRef { unsafe { return llvm::LLVMInt16Type(); } }\n \n-fn T_i32() -> TypeRef { unsafe { return llvm::LLVMInt32Type(); } }\n+pub fn T_i32() -> TypeRef { unsafe { return llvm::LLVMInt32Type(); } }\n \n-fn T_i64() -> TypeRef { unsafe { return llvm::LLVMInt64Type(); } }\n+pub fn T_i64() -> TypeRef { unsafe { return llvm::LLVMInt64Type(); } }\n \n-fn T_f32() -> TypeRef { unsafe { return llvm::LLVMFloatType(); } }\n+pub fn T_f32() -> TypeRef { unsafe { return llvm::LLVMFloatType(); } }\n \n-fn T_f64() -> TypeRef { unsafe { return llvm::LLVMDoubleType(); } }\n+pub fn T_f64() -> TypeRef { unsafe { return llvm::LLVMDoubleType(); } }\n \n-fn T_bool() -> TypeRef { return T_i1(); }\n+pub fn T_bool() -> TypeRef { return T_i1(); }\n \n-fn T_int(targ_cfg: @session::config) -> TypeRef {\n+pub fn T_int(targ_cfg: @session::config) -> TypeRef {\n     return match targ_cfg.arch {\n       session::arch_x86 => T_i32(),\n       session::arch_x86_64 => T_i64(),\n       session::arch_arm => T_i32()\n     };\n }\n \n-fn T_int_ty(cx: @crate_ctxt, t: ast::int_ty) -> TypeRef {\n+pub fn T_int_ty(cx: @crate_ctxt, t: ast::int_ty) -> TypeRef {\n     match t {\n       ast::ty_i => cx.int_type,\n       ast::ty_char => T_char(),\n@@ -800,7 +780,7 @@ fn T_int_ty(cx: @crate_ctxt, t: ast::int_ty) -> TypeRef {\n     }\n }\n \n-fn T_uint_ty(cx: @crate_ctxt, t: ast::uint_ty) -> TypeRef {\n+pub fn T_uint_ty(cx: @crate_ctxt, t: ast::uint_ty) -> TypeRef {\n     match t {\n       ast::ty_u => cx.int_type,\n       ast::ty_u8 => T_i8(),\n@@ -810,68 +790,68 @@ fn T_uint_ty(cx: @crate_ctxt, t: ast::uint_ty) -> TypeRef {\n     }\n }\n \n-fn T_float_ty(cx: @crate_ctxt, t: ast::float_ty) -> TypeRef {\n+pub fn T_float_ty(cx: @crate_ctxt, t: ast::float_ty) -> TypeRef {\n     match t {\n       ast::ty_f => cx.float_type,\n       ast::ty_f32 => T_f32(),\n       ast::ty_f64 => T_f64()\n     }\n }\n \n-fn T_float(targ_cfg: @session::config) -> TypeRef {\n+pub fn T_float(targ_cfg: @session::config) -> TypeRef {\n     return match targ_cfg.arch {\n       session::arch_x86 => T_f64(),\n       session::arch_x86_64 => T_f64(),\n       session::arch_arm => T_f64()\n     };\n }\n \n-fn T_char() -> TypeRef { return T_i32(); }\n+pub fn T_char() -> TypeRef { return T_i32(); }\n \n-fn T_size_t(targ_cfg: @session::config) -> TypeRef {\n+pub fn T_size_t(targ_cfg: @session::config) -> TypeRef {\n     return T_int(targ_cfg);\n }\n \n-fn T_fn(inputs: ~[TypeRef], output: TypeRef) -> TypeRef {\n+pub fn T_fn(inputs: ~[TypeRef], output: TypeRef) -> TypeRef {\n     unsafe {\n         return llvm::LLVMFunctionType(output, to_ptr(inputs),\n                                    inputs.len() as c_uint,\n                                    False);\n     }\n }\n \n-fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n+pub fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n     return T_struct(~[T_ptr(tfn), T_opaque_cbox_ptr(cx)]);\n }\n \n-fn T_ptr(t: TypeRef) -> TypeRef {\n+pub fn T_ptr(t: TypeRef) -> TypeRef {\n     unsafe {\n         return llvm::LLVMPointerType(t, default_addrspace);\n     }\n }\n \n-fn T_root(t: TypeRef, addrspace: addrspace) -> TypeRef {\n+pub fn T_root(t: TypeRef, addrspace: addrspace) -> TypeRef {\n     unsafe {\n         return llvm::LLVMPointerType(t, addrspace);\n     }\n }\n \n-fn T_struct(elts: ~[TypeRef]) -> TypeRef {\n+pub fn T_struct(elts: ~[TypeRef]) -> TypeRef {\n     unsafe {\n         return llvm::LLVMStructType(to_ptr(elts),\n                                     elts.len() as c_uint,\n                                     False);\n     }\n }\n \n-fn T_named_struct(name: ~str) -> TypeRef {\n+pub fn T_named_struct(name: ~str) -> TypeRef {\n     unsafe {\n         let c = llvm::LLVMGetGlobalContext();\n         return str::as_c_str(name, |buf| llvm::LLVMStructCreateNamed(c, buf));\n     }\n }\n \n-fn set_struct_body(t: TypeRef, elts: ~[TypeRef]) {\n+pub fn set_struct_body(t: TypeRef, elts: ~[TypeRef]) {\n     unsafe {\n         llvm::LLVMStructSetBody(t,\n                                 to_ptr(elts),\n@@ -880,15 +860,15 @@ fn set_struct_body(t: TypeRef, elts: ~[TypeRef]) {\n     }\n }\n \n-fn T_empty_struct() -> TypeRef { return T_struct(~[]); }\n+pub fn T_empty_struct() -> TypeRef { return T_struct(~[]); }\n \n // A vtable is, in reality, a vtable pointer followed by zero or more pointers\n // to tydescs and other vtables that it closes over. But the types and number\n // of those are rarely known to the code that needs to manipulate them, so\n // they are described by this opaque type.\n-fn T_vtable() -> TypeRef { T_array(T_ptr(T_i8()), 1u) }\n+pub fn T_vtable() -> TypeRef { T_array(T_ptr(T_i8()), 1u) }\n \n-fn T_task(targ_cfg: @session::config) -> TypeRef {\n+pub fn T_task(targ_cfg: @session::config) -> TypeRef {\n     let t = T_named_struct(~\"task\");\n \n     // Refcount\n@@ -910,7 +890,7 @@ fn T_task(targ_cfg: @session::config) -> TypeRef {\n     return t;\n }\n \n-fn T_tydesc_field(cx: @crate_ctxt, field: uint) -> TypeRef {\n+pub fn T_tydesc_field(cx: @crate_ctxt, field: uint) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n     unsafe {\n@@ -925,7 +905,7 @@ fn T_tydesc_field(cx: @crate_ctxt, field: uint) -> TypeRef {\n     }\n }\n \n-fn T_generic_glue_fn(cx: @crate_ctxt) -> TypeRef {\n+pub fn T_generic_glue_fn(cx: @crate_ctxt) -> TypeRef {\n     let s = @\"glue_fn\";\n     match name_has_type(cx.tn, s) {\n       Some(t) => return t,\n@@ -936,7 +916,7 @@ fn T_generic_glue_fn(cx: @crate_ctxt) -> TypeRef {\n     return t;\n }\n \n-fn T_tydesc(targ_cfg: @session::config) -> TypeRef {\n+pub fn T_tydesc(targ_cfg: @session::config) -> TypeRef {\n     let tydesc = T_named_struct(~\"tydesc\");\n     let tydescpp = T_ptr(T_ptr(tydesc));\n     let pvoid = T_ptr(T_i8());\n@@ -953,32 +933,32 @@ fn T_tydesc(targ_cfg: @session::config) -> TypeRef {\n     return tydesc;\n }\n \n-fn T_array(t: TypeRef, n: uint) -> TypeRef {\n+pub fn T_array(t: TypeRef, n: uint) -> TypeRef {\n     unsafe {\n         return llvm::LLVMArrayType(t, n as c_uint);\n     }\n }\n \n // Interior vector.\n-fn T_vec2(targ_cfg: @session::config, t: TypeRef) -> TypeRef {\n+pub fn T_vec2(targ_cfg: @session::config, t: TypeRef) -> TypeRef {\n     return T_struct(~[T_int(targ_cfg), // fill\n                   T_int(targ_cfg), // alloc\n                   T_array(t, 0u)]); // elements\n }\n \n-fn T_vec(ccx: @crate_ctxt, t: TypeRef) -> TypeRef {\n+pub fn T_vec(ccx: @crate_ctxt, t: TypeRef) -> TypeRef {\n     return T_vec2(ccx.sess.targ_cfg, t);\n }\n \n // Note that the size of this one is in bytes.\n-fn T_opaque_vec(targ_cfg: @session::config) -> TypeRef {\n+pub fn T_opaque_vec(targ_cfg: @session::config) -> TypeRef {\n     return T_vec2(targ_cfg, T_i8());\n }\n \n // Let T be the content of a box @T.  tuplify_box_ty(t) returns the\n // representation of @T as a tuple (i.e., the ty::t version of what T_box()\n // returns).\n-fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n+pub fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let ptr = ty::mk_ptr(\n         tcx,\n         ty::mt {ty: ty::mk_nil(tcx), mutbl: ast::m_imm}\n@@ -988,58 +968,58 @@ fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n                          t]);\n }\n \n-fn T_box_header_fields(cx: @crate_ctxt) -> ~[TypeRef] {\n+pub fn T_box_header_fields(cx: @crate_ctxt) -> ~[TypeRef] {\n     let ptr = T_ptr(T_i8());\n     return ~[cx.int_type, T_ptr(cx.tydesc_type), ptr, ptr];\n }\n \n-fn T_box_header(cx: @crate_ctxt) -> TypeRef {\n+pub fn T_box_header(cx: @crate_ctxt) -> TypeRef {\n     return T_struct(T_box_header_fields(cx));\n }\n \n-fn T_box(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n+pub fn T_box(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n     return T_struct(vec::append(T_box_header_fields(cx), ~[t]));\n }\n \n-fn T_box_ptr(t: TypeRef) -> TypeRef {\n+pub fn T_box_ptr(t: TypeRef) -> TypeRef {\n     unsafe {\n         return llvm::LLVMPointerType(t, gc_box_addrspace);\n     }\n }\n \n-fn T_opaque_box(cx: @crate_ctxt) -> TypeRef {\n+pub fn T_opaque_box(cx: @crate_ctxt) -> TypeRef {\n     return T_box(cx, T_i8());\n }\n \n-fn T_opaque_box_ptr(cx: @crate_ctxt) -> TypeRef {\n+pub fn T_opaque_box_ptr(cx: @crate_ctxt) -> TypeRef {\n     return T_box_ptr(T_opaque_box(cx));\n }\n \n-fn T_unique(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n+pub fn T_unique(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n     return T_struct(vec::append(T_box_header_fields(cx), ~[t]));\n }\n \n-fn T_unique_ptr(t: TypeRef) -> TypeRef {\n+pub fn T_unique_ptr(t: TypeRef) -> TypeRef {\n     unsafe {\n         return llvm::LLVMPointerType(t, gc_box_addrspace);\n     }\n }\n \n-fn T_port(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n+pub fn T_port(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n     return T_struct(~[cx.int_type]); // Refcount\n \n }\n \n-fn T_chan(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n+pub fn T_chan(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n     return T_struct(~[cx.int_type]); // Refcount\n \n }\n \n-fn T_taskptr(cx: @crate_ctxt) -> TypeRef { return T_ptr(cx.task_type); }\n+pub fn T_taskptr(cx: @crate_ctxt) -> TypeRef { return T_ptr(cx.task_type); }\n \n \n // This type must never be used directly; it must always be cast away.\n-fn T_typaram(tn: type_names) -> TypeRef {\n+pub fn T_typaram(tn: type_names) -> TypeRef {\n     let s = @\"typaram\";\n     match name_has_type(tn, s) {\n       Some(t) => return t,\n@@ -1050,19 +1030,21 @@ fn T_typaram(tn: type_names) -> TypeRef {\n     return t;\n }\n \n-fn T_typaram_ptr(tn: type_names) -> TypeRef { return T_ptr(T_typaram(tn)); }\n+pub fn T_typaram_ptr(tn: type_names) -> TypeRef {\n+    return T_ptr(T_typaram(tn));\n+}\n \n-fn T_opaque_cbox_ptr(cx: @crate_ctxt) -> TypeRef {\n+pub fn T_opaque_cbox_ptr(cx: @crate_ctxt) -> TypeRef {\n     // closures look like boxes (even when they are fn~ or fn&)\n     // see trans_closure.rs\n     return T_opaque_box_ptr(cx);\n }\n \n-fn T_enum_discrim(cx: @crate_ctxt) -> TypeRef {\n+pub fn T_enum_discrim(cx: @crate_ctxt) -> TypeRef {\n     return cx.int_type;\n }\n \n-fn T_opaque_enum(cx: @crate_ctxt) -> TypeRef {\n+pub fn T_opaque_enum(cx: @crate_ctxt) -> TypeRef {\n     let s = @\"opaque_enum\";\n     match name_has_type(cx.tn, s) {\n       Some(t) => return t,\n@@ -1073,15 +1055,15 @@ fn T_opaque_enum(cx: @crate_ctxt) -> TypeRef {\n     return t;\n }\n \n-fn T_opaque_enum_ptr(cx: @crate_ctxt) -> TypeRef {\n+pub fn T_opaque_enum_ptr(cx: @crate_ctxt) -> TypeRef {\n     return T_ptr(T_opaque_enum(cx));\n }\n \n-fn T_captured_tydescs(cx: @crate_ctxt, n: uint) -> TypeRef {\n+pub fn T_captured_tydescs(cx: @crate_ctxt, n: uint) -> TypeRef {\n     return T_struct(vec::from_elem::<TypeRef>(n, T_ptr(cx.tydesc_type)));\n }\n \n-fn T_opaque_trait(cx: @crate_ctxt, vstore: ty::vstore) -> TypeRef {\n+pub fn T_opaque_trait(cx: @crate_ctxt, vstore: ty::vstore) -> TypeRef {\n     match vstore {\n         ty::vstore_box => {\n             T_struct(~[T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)])\n@@ -1095,60 +1077,62 @@ fn T_opaque_trait(cx: @crate_ctxt, vstore: ty::vstore) -> TypeRef {\n     }\n }\n \n-fn T_opaque_port_ptr() -> TypeRef { return T_ptr(T_i8()); }\n+pub fn T_opaque_port_ptr() -> TypeRef { return T_ptr(T_i8()); }\n \n-fn T_opaque_chan_ptr() -> TypeRef { return T_ptr(T_i8()); }\n+pub fn T_opaque_chan_ptr() -> TypeRef { return T_ptr(T_i8()); }\n \n \n // LLVM constant constructors.\n-fn C_null(t: TypeRef) -> ValueRef {\n+pub fn C_null(t: TypeRef) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstNull(t);\n     }\n }\n \n-fn C_integral(t: TypeRef, u: u64, sign_extend: Bool) -> ValueRef {\n+pub fn C_integral(t: TypeRef, u: u64, sign_extend: Bool) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstInt(t, u, sign_extend);\n     }\n }\n \n-fn C_floating(s: ~str, t: TypeRef) -> ValueRef {\n+pub fn C_floating(s: ~str, t: TypeRef) -> ValueRef {\n     unsafe {\n         return str::as_c_str(s, |buf| llvm::LLVMConstRealOfString(t, buf));\n     }\n }\n \n-fn C_nil() -> ValueRef {\n+pub fn C_nil() -> ValueRef {\n     return C_struct(~[]);\n }\n \n-fn C_bool(b: bool) -> ValueRef {\n+pub fn C_bool(b: bool) -> ValueRef {\n     C_integral(T_bool(), if b { 1u64 } else { 0u64 }, False)\n }\n \n-fn C_i32(i: i32) -> ValueRef {\n+pub fn C_i32(i: i32) -> ValueRef {\n     return C_integral(T_i32(), i as u64, True);\n }\n \n-fn C_i64(i: i64) -> ValueRef {\n+pub fn C_i64(i: i64) -> ValueRef {\n     return C_integral(T_i64(), i as u64, True);\n }\n \n-fn C_int(cx: @crate_ctxt, i: int) -> ValueRef {\n+pub fn C_int(cx: @crate_ctxt, i: int) -> ValueRef {\n     return C_integral(cx.int_type, i as u64, True);\n }\n \n-fn C_uint(cx: @crate_ctxt, i: uint) -> ValueRef {\n+pub fn C_uint(cx: @crate_ctxt, i: uint) -> ValueRef {\n     return C_integral(cx.int_type, i as u64, False);\n }\n \n-fn C_u8(i: uint) -> ValueRef { return C_integral(T_i8(), i as u64, False); }\n+pub fn C_u8(i: uint) -> ValueRef {\n+    return C_integral(T_i8(), i as u64, False);\n+}\n \n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-fn C_cstr(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n+pub fn C_cstr(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n     unsafe {\n         match cx.const_cstr_cache.find(s) {\n           Some(llval) => return llval,\n@@ -1173,7 +1157,7 @@ fn C_cstr(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-fn C_estr_slice(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n+pub fn C_estr_slice(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n     unsafe {\n         let len = str::len(s);\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), T_ptr(T_i8()));\n@@ -1182,15 +1166,15 @@ fn C_estr_slice(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n }\n \n // Returns a Plain Old LLVM String:\n-fn C_postr(s: ~str) -> ValueRef {\n+pub fn C_postr(s: ~str) -> ValueRef {\n     unsafe {\n         return do str::as_c_str(s) |buf| {\n             llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n         };\n     }\n }\n \n-fn C_zero_byte_arr(size: uint) -> ValueRef {\n+pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n     unsafe {\n         let mut i = 0u;\n         let mut elts: ~[ValueRef] = ~[];\n@@ -1201,54 +1185,54 @@ fn C_zero_byte_arr(size: uint) -> ValueRef {\n     }\n }\n \n-fn C_struct(elts: &[ValueRef]) -> ValueRef {\n+pub fn C_struct(elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n         do vec::as_imm_buf(elts) |ptr, len| {\n             llvm::LLVMConstStruct(ptr, len as c_uint, False)\n         }\n     }\n }\n \n-fn C_packed_struct(elts: &[ValueRef]) -> ValueRef {\n+pub fn C_packed_struct(elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n         do vec::as_imm_buf(elts) |ptr, len| {\n             llvm::LLVMConstStruct(ptr, len as c_uint, True)\n         }\n     }\n }\n \n-fn C_named_struct(T: TypeRef, elts: &[ValueRef]) -> ValueRef {\n+pub fn C_named_struct(T: TypeRef, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n         do vec::as_imm_buf(elts) |ptr, len| {\n             llvm::LLVMConstNamedStruct(T, ptr, len as c_uint)\n         }\n     }\n }\n \n-fn C_array(ty: TypeRef, elts: ~[ValueRef]) -> ValueRef {\n+pub fn C_array(ty: TypeRef, elts: ~[ValueRef]) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstArray(ty, vec::raw::to_ptr(elts),\n                                  elts.len() as c_uint);\n     }\n }\n \n-fn C_bytes(bytes: ~[u8]) -> ValueRef {\n+pub fn C_bytes(bytes: ~[u8]) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstString(\n             cast::reinterpret_cast(&vec::raw::to_ptr(bytes)),\n             bytes.len() as c_uint, True);\n     }\n }\n \n-fn C_bytes_plus_null(bytes: ~[u8]) -> ValueRef {\n+pub fn C_bytes_plus_null(bytes: ~[u8]) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstString(\n             cast::reinterpret_cast(&vec::raw::to_ptr(bytes)),\n             bytes.len() as c_uint, False);\n     }\n }\n \n-fn C_shape(ccx: @crate_ctxt, +bytes: ~[u8]) -> ValueRef {\n+pub fn C_shape(ccx: @crate_ctxt, +bytes: ~[u8]) -> ValueRef {\n     unsafe {\n         let llshape = C_bytes_plus_null(bytes);\n         let name = fmt!(\"shape%u\", (ccx.names)(~\"shape\").repr);\n@@ -1262,14 +1246,15 @@ fn C_shape(ccx: @crate_ctxt, +bytes: ~[u8]) -> ValueRef {\n     }\n }\n \n-fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n+pub fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n     unsafe {\n         llvm::LLVMGetParam(fndecl, param as c_uint)\n     }\n }\n \n // Used to identify cached monomorphized functions and vtables\n-enum mono_param_id {\n+#[deriving_eq]\n+pub enum mono_param_id {\n     mono_precise(ty::t, Option<~[mono_id]>),\n     mono_any,\n     mono_repr(uint /* size */,\n@@ -1278,43 +1263,16 @@ enum mono_param_id {\n               datum::DatumMode),\n }\n \n-struct mono_id_ {\n+#[deriving_eq]\n+pub struct mono_id_ {\n     def: ast::def_id,\n     params: ~[mono_param_id],\n     impl_did_opt: Option<ast::def_id>\n }\n \n-type mono_id = @mono_id_;\n-\n-impl mono_param_id : cmp::Eq {\n-    pure fn eq(&self, other: &mono_param_id) -> bool {\n-        match (self, other) {\n-            (&mono_precise(ty_a, ref ids_a),\n-             &mono_precise(ty_b, ref ids_b)) => {\n-                ty_a == ty_b && ids_a == ids_b\n-            }\n-            (&mono_any, &mono_any) => true,\n-            (&mono_repr(size_a, align_a, is_float_a, mode_a),\n-             &mono_repr(size_b, align_b, is_float_b, mode_b)) => {\n-                size_a == size_b && align_a == align_b &&\n-                    is_float_a == is_float_b && mode_a == mode_b\n-            }\n-            (&mono_precise(*), _) => false,\n-            (&mono_any, _) => false,\n-            (&mono_repr(*), _) => false\n-        }\n-    }\n-    pure fn ne(&self, other: &mono_param_id) -> bool { !(*self).eq(other) }\n-}\n-\n-impl mono_id_ : cmp::Eq {\n-    pure fn eq(&self, other: &mono_id_) -> bool {\n-        (*self).def == (*other).def && (*self).params == (*other).params\n-    }\n-    pure fn ne(&self, other: &mono_id_) -> bool { !(*self).eq(other) }\n-}\n+pub type mono_id = @mono_id_;\n \n-impl mono_param_id : to_bytes::IterBytes {\n+pub impl mono_param_id : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match /*bad*/copy *self {\n           mono_precise(t, mids) =>\n@@ -1328,29 +1286,29 @@ impl mono_param_id : to_bytes::IterBytes {\n     }\n }\n \n-impl mono_id_ : to_bytes::IterBytes {\n+pub impl mono_id_ : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f);\n     }\n }\n \n-fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n+pub fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n     return build::Select(cx, cond, b, a);\n }\n \n-fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n+pub fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let cond = build::ICmp(cx, lib::llvm::IntULT, a, b);\n     return build::Select(cx, cond, a, b);\n }\n \n-fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n+pub fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n     let mask = build::Sub(cx, align, C_int(cx.ccx(), 1));\n     let bumped = build::Add(cx, off, mask);\n     return build::And(cx, bumped, build::Not(cx, mask));\n }\n \n-fn path_str(sess: session::Session, p: path) -> ~str {\n+pub fn path_str(sess: session::Session, p: path) -> ~str {\n     let mut r = ~\"\", first = true;\n     for vec::each(p) |e| {\n         match *e {\n@@ -1364,7 +1322,7 @@ fn path_str(sess: session::Session, p: path) -> ~str {\n     r\n }\n \n-fn monomorphize_type(bcx: block, t: ty::t) -> ty::t {\n+pub fn monomorphize_type(bcx: block, t: ty::t) -> ty::t {\n     match /*bad*/copy bcx.fcx.param_substs {\n         Some(substs) => {\n             ty::subst_tps(bcx.tcx(), substs.tys, substs.self_ty, t)\n@@ -1373,17 +1331,17 @@ fn monomorphize_type(bcx: block, t: ty::t) -> ty::t {\n     }\n }\n \n-fn node_id_type(bcx: block, id: ast::node_id) -> ty::t {\n+pub fn node_id_type(bcx: block, id: ast::node_id) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n     monomorphize_type(bcx, t)\n }\n \n-fn expr_ty(bcx: block, ex: @ast::expr) -> ty::t {\n+pub fn expr_ty(bcx: block, ex: @ast::expr) -> ty::t {\n     node_id_type(bcx, ex.id)\n }\n \n-fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n+pub fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     let tcx = bcx.tcx();\n     let params = ty::node_id_to_type_params(tcx, id);\n     match /*bad*/copy bcx.fcx.param_substs {\n@@ -1396,23 +1354,22 @@ fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     }\n }\n \n-fn node_vtables(bcx: block, id: ast::node_id) -> Option<typeck::vtable_res> {\n+pub fn node_vtables(bcx: block, id: ast::node_id)\n+                 -> Option<typeck::vtable_res> {\n     let raw_vtables = bcx.ccx().maps.vtable_map.find(id);\n     raw_vtables.map(\n-        |vts| meth::resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n+        |vts| resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n }\n \n-fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)\n-    -> typeck::vtable_res\n-{\n+pub fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)\n+    -> typeck::vtable_res {\n     @vec::map(*vts, |d| resolve_vtable_in_fn_ctxt(fcx, copy *d))\n }\n \n // Apply the typaram substitutions in the fn_ctxt to a vtable. This should\n // eliminate any vtable_params.\n-fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, +vt: typeck::vtable_origin)\n-    -> typeck::vtable_origin\n-{\n+pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, +vt: typeck::vtable_origin)\n+    -> typeck::vtable_origin {\n     let tcx = fcx.ccx.tcx;\n     match vt {\n         typeck::vtable_static(trait_id, tys, sub) => {\n@@ -1443,10 +1400,9 @@ fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, +vt: typeck::vtable_origin)\n     }\n }\n \n-fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n+pub fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n                n_param: uint, n_bound: uint)\n-    -> typeck::vtable_origin\n-{\n+    -> typeck::vtable_origin {\n     debug!(\"find_vtable_in_fn_ctxt(n_param=%u, n_bound=%u, ps=%?)\",\n            n_param, n_bound, param_substs_to_str(tcx, ps));\n \n@@ -1459,21 +1415,21 @@ fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n     /*bad*/ copy ps.vtables.get()[vtable_off]\n }\n \n-fn dummy_substs(+tps: ~[ty::t]) -> ty::substs {\n+pub fn dummy_substs(+tps: ~[ty::t]) -> ty::substs {\n     substs {\n         self_r: Some(ty::re_bound(ty::br_self)),\n         self_ty: None,\n         tps: tps\n     }\n }\n \n-fn struct_field(index: uint) -> [uint * 3] {\n+pub fn struct_field(index: uint) -> [uint * 3] {\n     //! The GEPi sequence to access a field of a record/struct.\n \n     [0, 0, index]\n }\n \n-fn struct_dtor() -> [uint * 2] {\n+pub fn struct_dtor() -> [uint * 2] {\n     //! The GEPi sequence to access the dtor of a struct.\n \n     [0, 1]"}, {"sha": "947e67c9e43f41c3b253755804839d44affad9dc", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -15,11 +15,12 @@ use middle::trans::base::get_insn_ctxt;\n use middle::trans::common::*;\n use middle::trans::consts;\n use middle::trans::expr;\n+use middle::trans::machine;\n use middle::ty;\n \n use syntax::{ast, ast_util, codemap, ast_map};\n \n-fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n+pub fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n     -> ValueRef {\n     let _icx = cx.insn_ctxt(\"trans_lit\");\n     match lit.node {\n@@ -58,28 +59,28 @@ fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n     }\n }\n \n-fn const_ptrcast(cx: @crate_ctxt, a: ValueRef, t: TypeRef) -> ValueRef {\n+pub fn const_ptrcast(cx: @crate_ctxt, a: ValueRef, t: TypeRef) -> ValueRef {\n     unsafe {\n         let b = llvm::LLVMConstPointerCast(a, T_ptr(t));\n         assert cx.const_globals.insert(b as int, a);\n         b\n     }\n }\n \n-fn const_vec(cx: @crate_ctxt, e: @ast::expr, es: &[@ast::expr])\n+pub fn const_vec(cx: @crate_ctxt, e: @ast::expr, es: &[@ast::expr])\n     -> (ValueRef, ValueRef, TypeRef) {\n     unsafe {\n         let vec_ty = ty::expr_ty(cx.tcx, e);\n         let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n         let llunitty = type_of::type_of(cx, unit_ty);\n         let v = C_array(llunitty, es.map(|e| const_expr(cx, *e)));\n-        let unit_sz = shape::llsize_of(cx, llunitty);\n+        let unit_sz = machine::llsize_of(cx, llunitty);\n         let sz = llvm::LLVMConstMul(C_uint(cx, es.len()), unit_sz);\n         return (v, sz, llunitty);\n     }\n }\n \n-fn const_deref(cx: @crate_ctxt, v: ValueRef) -> ValueRef {\n+pub fn const_deref(cx: @crate_ctxt, v: ValueRef) -> ValueRef {\n     unsafe {\n         let v = match cx.const_globals.find(v as int) {\n             Some(v) => v,\n@@ -91,7 +92,8 @@ fn const_deref(cx: @crate_ctxt, v: ValueRef) -> ValueRef {\n     }\n }\n \n-fn const_get_elt(cx: @crate_ctxt, v: ValueRef, us: &[c_uint]) -> ValueRef {\n+pub fn const_get_elt(cx: @crate_ctxt, v: ValueRef, us: &[c_uint])\n+                  -> ValueRef {\n     unsafe {\n         let r = do vec::as_imm_buf(us) |p, len| {\n             llvm::LLVMConstExtractValue(v, p, len as c_uint)\n@@ -104,7 +106,7 @@ fn const_get_elt(cx: @crate_ctxt, v: ValueRef, us: &[c_uint]) -> ValueRef {\n     }\n }\n \n-fn const_autoderef(cx: @crate_ctxt, ty: ty::t, v: ValueRef)\n+pub fn const_autoderef(cx: @crate_ctxt, ty: ty::t, v: ValueRef)\n     -> (ty::t, ValueRef) {\n     let mut t1 = ty;\n     let mut v1 = v;\n@@ -120,7 +122,7 @@ fn const_autoderef(cx: @crate_ctxt, ty: ty::t, v: ValueRef)\n     }\n }\n \n-fn get_const_val(cx: @crate_ctxt, def_id: ast::def_id) -> ValueRef {\n+pub fn get_const_val(cx: @crate_ctxt, def_id: ast::def_id) -> ValueRef {\n     if !ast_util::is_local(def_id) {\n         cx.tcx.sess.bug(~\"cross-crate constants\");\n     }\n@@ -137,7 +139,7 @@ fn get_const_val(cx: @crate_ctxt, def_id: ast::def_id) -> ValueRef {\n     cx.const_values.get(def_id.node)\n }\n \n-fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n+pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n     unsafe {\n         let _icx = cx.insn_ctxt(\"const_expr\");\n         return match /*bad*/copy e.node {\n@@ -244,7 +246,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n                       ty::vstore_slice(_) => {\n                           let unit_ty = ty::sequence_element_type(cx.tcx, bt);\n                           let llunitty = type_of::type_of(cx, unit_ty);\n-                          let unit_sz = shape::llsize_of(cx, llunitty);\n+                          let unit_sz = machine::llsize_of(cx, llunitty);\n \n                           (const_deref(cx, const_get_elt(cx, bv, [0])),\n                            llvm::LLVMConstUDiv(const_get_elt(cx, bv, [1]),\n@@ -450,7 +452,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n             Some(ast::def_variant(tid, vid)) => {\n                 let ety = ty::expr_ty(cx.tcx, e);\n                 let degen = ty::enum_is_univariant(cx.tcx, tid);\n-                let size = shape::static_size_of_enum(cx, ety);\n+                let size = machine::static_size_of_enum(cx, ety);\n \n                 let discrim = base::get_discrim_val(cx, e.span, tid, vid);\n                 let c_args = C_struct(args.map(|a| const_expr(cx, *a)));\n@@ -474,7 +476,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n     }\n }\n \n-fn trans_const(ccx: @crate_ctxt, _e: @ast::expr, id: ast::node_id) {\n+pub fn trans_const(ccx: @crate_ctxt, _e: @ast::expr, id: ast::node_id) {\n     unsafe {\n         let _icx = ccx.insn_ctxt(\"trans_const\");\n         let g = base::get_item_val(ccx, id);"}, {"sha": "127f5d5d3397be9d7517ab13f7bf29a5cafc31e0", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -17,7 +17,7 @@ use middle::pat_util::*;\n use middle::trans::base;\n use middle::trans::build::B;\n use middle::trans::common::*;\n-use middle::trans::shape;\n+use middle::trans::machine;\n use middle::trans::type_of;\n use middle::trans;\n use middle::ty;\n@@ -33,13 +33,6 @@ use syntax::codemap::{span, CharPos};\n use syntax::parse::token::ident_interner;\n use syntax::{ast, codemap, ast_util, ast_map};\n \n-export create_local_var;\n-export create_function;\n-export create_arg;\n-export update_source_pos;\n-export debug_ctxt;\n-export mk_ctxt;\n-\n const LLVMDebugVersion: int = (9 << 16);\n \n const DW_LANG_RUST: int = 0x9000;\n@@ -111,13 +104,13 @@ fn add_named_metadata(cx: @crate_ctxt, name: ~str, val: ValueRef) {\n \n ////////////////\n \n-type debug_ctxt = {\n+pub type debug_ctxt = {\n     llmetadata: metadata_cache,\n     names: namegen,\n     crate_file: ~str\n };\n \n-fn mk_ctxt(+crate: ~str, intr: @ident_interner) -> debug_ctxt {\n+pub fn mk_ctxt(+crate: ~str, intr: @ident_interner) -> debug_ctxt {\n     {llmetadata: map::HashMap(),\n      names: new_namegen(intr),\n      crate_file: crate}\n@@ -313,8 +306,8 @@ fn create_block(cx: block) -> @metadata<block_md> {\n \n fn size_and_align_of(cx: @crate_ctxt, t: ty::t) -> (int, int) {\n     let llty = type_of::type_of(cx, t);\n-    (shape::llsize_of_real(cx, llty) as int,\n-     shape::llalign_of_pref(cx, llty) as int)\n+    (machine::llsize_of_real(cx, llty) as int,\n+     machine::llalign_of_pref(cx, llty) as int)\n }\n \n fn create_basic_type(cx: @crate_ctxt, t: ty::t, span: span)\n@@ -654,7 +647,7 @@ fn create_var(type_tag: int, context: ValueRef, +name: ~str, file: ValueRef,\n     return llmdnode(lldata);\n }\n \n-fn create_local_var(bcx: block, local: @ast::local)\n+pub fn create_local_var(bcx: block, local: @ast::local)\n     -> @metadata<local_var_md> {\n     unsafe {\n         let cx = bcx.ccx();\n@@ -705,7 +698,7 @@ fn create_local_var(bcx: block, local: @ast::local)\n     }\n }\n \n-fn create_arg(bcx: block, arg: ast::arg, sp: span)\n+pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     -> Option<@metadata<argument_md>> {\n     unsafe {\n         let fcx = bcx.fcx, cx = fcx.ccx;\n@@ -752,7 +745,7 @@ fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     }\n }\n \n-fn update_source_pos(cx: block, s: span) {\n+pub fn update_source_pos(cx: block, s: span) {\n     if !cx.sess().opts.debuginfo {\n         return;\n     }\n@@ -769,7 +762,7 @@ fn update_source_pos(cx: block, s: span) {\n     }\n }\n \n-fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n+pub fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let cx = fcx.ccx;\n     let dbg_cx = (/*bad*/copy cx.dbg_cx).get();\n "}, {"sha": "e725e484a8943084026da0a2867195ec40d6de94", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -40,17 +40,14 @@ use syntax::{ast, ast_util};\n use syntax::{attr, ast_map};\n use syntax::parse::token::special_idents;\n \n-export link_name, trans_foreign_mod, register_foreign_fn, trans_foreign_fn,\n-       trans_intrinsic;\n-\n fn abi_info(arch: session::arch) -> cabi::ABIInfo {\n     return match arch {\n         arch_x86_64 => x86_64_abi_info(),\n         _ => cabi::llvm_abi_info()\n     }\n }\n \n-fn link_name(ccx: @crate_ctxt, i: @ast::foreign_item) -> ~str {\n+pub fn link_name(ccx: @crate_ctxt, i: @ast::foreign_item) -> ~str {\n     match attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n         None => ccx.sess.str_of(i.ident),\n         option::Some(ref ln) => (/*bad*/copy *ln)\n@@ -206,8 +203,9 @@ fn build_wrap_fn_(ccx: @crate_ctxt,\n // stack pointer appropriately to avoid a round of copies.  (In fact, the shim\n // function itself is unnecessary). We used to do this, in fact, and will\n // perhaps do so in the future.\n-fn trans_foreign_mod(ccx: @crate_ctxt,\n-                    foreign_mod: ast::foreign_mod, abi: ast::foreign_abi) {\n+pub fn trans_foreign_mod(ccx: @crate_ctxt,\n+                         foreign_mod: ast::foreign_mod,\n+                         abi: ast::foreign_abi) {\n \n     let _icx = ccx.insn_ctxt(\"foreign::trans_foreign_mod\");\n \n@@ -332,10 +330,12 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n     }\n }\n \n-fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n-                   +path: ast_map::path, +substs: param_substs,\n-                   ref_id: Option<ast::node_id>)\n-{\n+pub fn trans_intrinsic(ccx: @crate_ctxt,\n+                       decl: ValueRef,\n+                       item: @ast::foreign_item,\n+                       +path: ast_map::path,\n+                       +substs: param_substs,\n+                       ref_id: Option<ast::node_id>) {\n     debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n \n     // XXX: Bad copy.\n@@ -433,7 +433,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n         ~\"size_of\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Store(bcx, C_uint(ccx, shape::llsize_of_real(ccx, lltp_ty)),\n+            Store(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty)),\n                   fcx.llretptr);\n         }\n         ~\"move_val\" => {\n@@ -464,13 +464,13 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n         ~\"min_align_of\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Store(bcx, C_uint(ccx, shape::llalign_of_min(ccx, lltp_ty)),\n+            Store(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty)),\n                   fcx.llretptr);\n         }\n         ~\"pref_align_of\"=> {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Store(bcx, C_uint(ccx, shape::llalign_of_pref(ccx, lltp_ty)),\n+            Store(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty)),\n                   fcx.llretptr);\n         }\n         ~\"get_tydesc\" => {\n@@ -839,9 +839,12 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n     finish_fn(fcx, lltop);\n }\n \n-fn trans_foreign_fn(ccx: @crate_ctxt, +path: ast_map::path,\n-                    decl: ast::fn_decl, body: ast::blk, llwrapfn: ValueRef,\n-                    id: ast::node_id) {\n+pub fn trans_foreign_fn(ccx: @crate_ctxt,\n+                        +path: ast_map::path,\n+                        decl: ast::fn_decl,\n+                        body: ast::blk,\n+                        llwrapfn: ValueRef,\n+                        id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"foreign::build_foreign_fn\");\n \n     fn build_rust_fn(ccx: @crate_ctxt, +path: ast_map::path,\n@@ -930,12 +933,12 @@ fn trans_foreign_fn(ccx: @crate_ctxt, +path: ast_map::path,\n     build_wrap_fn(ccx, llshimfn, llwrapfn, tys)\n }\n \n-fn register_foreign_fn(ccx: @crate_ctxt,\n-                       sp: span,\n-                       +path: ast_map::path,\n-                       node_id: ast::node_id,\n-                       attrs: &[ast::attribute])\n-                    -> ValueRef {\n+pub fn register_foreign_fn(ccx: @crate_ctxt,\n+                           sp: span,\n+                           +path: ast_map::path,\n+                           node_id: ast::node_id,\n+                           attrs: &[ast::attribute])\n+                        -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"foreign::register_foreign_fn\");\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, node_id);"}, {"sha": "bb815df6b75abfa578992026327c4985c06ec74e", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 87, "deletions": 81, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -39,17 +39,20 @@ use syntax::ast_util::local_def;\n use syntax::print::pprust::expr_to_str;\n use syntax::{ast, ast_map};\n \n-fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n+pub fn macros() {\n+    // FIXME(#3114): Macro import/export.\n+    include!(\"macros.rs\");\n+}\n \n /**\n The main \"translation\" pass for methods.  Generates code\n for non-monomorphized methods only.  Other methods will\n be generated once they are invoked with specific type parameters,\n see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n-fn trans_impl(ccx: @crate_ctxt, +path: path, name: ast::ident,\n-              methods: ~[@ast::method], tps: ~[ast::ty_param],\n-              self_ty: Option<ty::t>, id: ast::node_id) {\n+pub fn trans_impl(ccx: @crate_ctxt, +path: path, name: ast::ident,\n+                  methods: ~[@ast::method], tps: ~[ast::ty_param],\n+                  self_ty: Option<ty::t>, id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n     if tps.len() > 0u { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n@@ -93,13 +96,13 @@ Translates a (possibly monomorphized) method body.\n - `llfn`: the LLVM ValueRef for the method\n - `impl_id`: the node ID of the impl this method is inside\n */\n-fn trans_method(ccx: @crate_ctxt,\n-                +path: path,\n-                method: &ast::method,\n-                +param_substs: Option<param_substs>,\n-                base_self_ty: Option<ty::t>,\n-                llfn: ValueRef,\n-                impl_id: ast::def_id) {\n+pub fn trans_method(ccx: @crate_ctxt,\n+                    +path: path,\n+                    method: &ast::method,\n+                    +param_substs: Option<param_substs>,\n+                    base_self_ty: Option<ty::t>,\n+                    llfn: ValueRef,\n+                    impl_id: ast::def_id) {\n     // figure out how self is being passed\n     let self_arg = match method.self_ty.node {\n       ast::sty_static => {\n@@ -148,9 +151,9 @@ fn trans_method(ccx: @crate_ctxt,\n              Some(impl_id));\n }\n \n-fn trans_self_arg(bcx: block,\n-                  base: @ast::expr,\n-                  mentry: typeck::method_map_entry) -> Result {\n+pub fn trans_self_arg(bcx: block,\n+                      base: @ast::expr,\n+                      mentry: typeck::method_map_entry) -> Result {\n     let _icx = bcx.insn_ctxt(\"impl::trans_self_arg\");\n     let mut temp_cleanups = ~[];\n \n@@ -172,9 +175,11 @@ fn trans_self_arg(bcx: block,\n     return result;\n }\n \n-fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n-                       self: @ast::expr, mentry: typeck::method_map_entry) ->\n-                       Callee {\n+pub fn trans_method_callee(bcx: block,\n+                           callee_id: ast::node_id,\n+                           self: @ast::expr,\n+                           mentry: typeck::method_map_entry)\n+                        -> Callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_method_callee\");\n \n     // Replace method_self with method_static here.\n@@ -243,7 +248,7 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n         }) => {\n             match bcx.fcx.param_substs {\n                 Some(ref substs) => {\n-                    let vtbl = base::find_vtable(bcx.tcx(), substs, p, b);\n+                    let vtbl = find_vtable(bcx.tcx(), substs, p, b);\n                     trans_monomorphized_callee(bcx, callee_id, self, mentry,\n                                                trait_id, off, vtbl)\n                 }\n@@ -265,11 +270,11 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n     }\n }\n \n-fn trans_static_method_callee(bcx: block,\n-                              method_id: ast::def_id,\n-                              trait_id: ast::def_id,\n-                              callee_id: ast::node_id) -> FnData\n-{\n+pub fn trans_static_method_callee(bcx: block,\n+                                  method_id: ast::def_id,\n+                                  trait_id: ast::def_id,\n+                                  callee_id: ast::node_id)\n+                               -> FnData {\n     let _icx = bcx.insn_ctxt(\"impl::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n \n@@ -348,13 +353,13 @@ fn trans_static_method_callee(bcx: block,\n     }\n }\n \n-fn method_from_methods(ms: ~[@ast::method], name: ast::ident)\n+pub fn method_from_methods(ms: ~[@ast::method], name: ast::ident)\n     -> Option<ast::def_id> {\n     ms.find(|m| m.ident == name).map(|m| local_def(m.id))\n }\n \n-fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n-                    name: ast::ident) -> ast::def_id {\n+pub fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n+                        name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n         match ccx.tcx.items.get(impl_id.node) {\n           ast_map::node_item(@ast::item {\n@@ -370,8 +375,8 @@ fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n     }\n }\n \n-fn method_with_name_or_default(ccx: @crate_ctxt, impl_id: ast::def_id,\n-                               name: ast::ident) -> ast::def_id {\n+pub fn method_with_name_or_default(ccx: @crate_ctxt, impl_id: ast::def_id,\n+                                   name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n         match ccx.tcx.items.get(impl_id.node) {\n           ast_map::node_item(@ast::item {\n@@ -404,8 +409,8 @@ fn method_with_name_or_default(ccx: @crate_ctxt, impl_id: ast::def_id,\n     }\n }\n \n-fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id,\n-                         i_id: ast::def_id) -> uint {\n+pub fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id,\n+                             i_id: ast::def_id) -> uint {\n     debug!(\"method_ty_param_count: m_id: %?, i_id: %?\", m_id, i_id);\n     if m_id.crate == ast::local_crate {\n         match ccx.tcx.items.find(m_id.node) {\n@@ -431,15 +436,14 @@ fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id,\n     }\n }\n \n-fn trans_monomorphized_callee(bcx: block,\n-                              callee_id: ast::node_id,\n-                              base: @ast::expr,\n-                              mentry: typeck::method_map_entry,\n-                              trait_id: ast::def_id,\n-                              n_method: uint,\n-                              +vtbl: typeck::vtable_origin)\n-    -> Callee\n-{\n+pub fn trans_monomorphized_callee(bcx: block,\n+                                  callee_id: ast::node_id,\n+                                  base: @ast::expr,\n+                                  mentry: typeck::method_map_entry,\n+                                  trait_id: ast::def_id,\n+                                  n_method: uint,\n+                                  +vtbl: typeck::vtable_origin)\n+                               -> Callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_monomorphized_callee\");\n     return match vtbl {\n       typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n@@ -495,13 +499,12 @@ fn trans_monomorphized_callee(bcx: block,\n \n }\n \n-fn combine_impl_and_methods_tps(bcx: block,\n-                                mth_did: ast::def_id,\n-                                impl_did: ast::def_id,\n-                                callee_id: ast::node_id,\n-                                +rcvr_substs: ~[ty::t])\n-    -> ~[ty::t]\n-{\n+pub fn combine_impl_and_methods_tps(bcx: block,\n+                                    mth_did: ast::def_id,\n+                                    impl_did: ast::def_id,\n+                                    callee_id: ast::node_id,\n+                                    +rcvr_substs: ~[ty::t])\n+                                 -> ~[ty::t] {\n     /*!\n     *\n     * Creates a concatenated set of substitutions which includes\n@@ -534,13 +537,12 @@ fn combine_impl_and_methods_tps(bcx: block,\n     return ty_substs;\n }\n \n-fn combine_impl_and_methods_origins(bcx: block,\n-                                    mth_did: ast::def_id,\n-                                    impl_did: ast::def_id,\n-                                    callee_id: ast::node_id,\n-                                    rcvr_origins: typeck::vtable_res)\n-    -> typeck::vtable_res\n-{\n+pub fn combine_impl_and_methods_origins(bcx: block,\n+                                        mth_did: ast::def_id,\n+                                        impl_did: ast::def_id,\n+                                        callee_id: ast::node_id,\n+                                        rcvr_origins: typeck::vtable_res)\n+                                     -> typeck::vtable_res {\n     /*!\n      *\n      * Similar to `combine_impl_and_methods_tps`, but for vtables.\n@@ -576,14 +578,13 @@ fn combine_impl_and_methods_origins(bcx: block,\n }\n \n \n-fn trans_trait_callee(bcx: block,\n-                      callee_id: ast::node_id,\n-                      n_method: uint,\n-                      self_expr: @ast::expr,\n-                      vstore: ty::vstore,\n-                      explicit_self: ast::self_ty_)\n-                   -> Callee\n-{\n+pub fn trans_trait_callee(bcx: block,\n+                          callee_id: ast::node_id,\n+                          n_method: uint,\n+                          self_expr: @ast::expr,\n+                          vstore: ty::vstore,\n+                          explicit_self: ast::self_ty_)\n+                       -> Callee {\n     //!\n     //\n     // Create a method callee where the method is coming from a trait\n@@ -614,14 +615,13 @@ fn trans_trait_callee(bcx: block,\n                                   explicit_self)\n }\n \n-fn trans_trait_callee_from_llval(bcx: block,\n-                                 callee_ty: ty::t,\n-                                 n_method: uint,\n-                                 llpair: ValueRef,\n-                                 vstore: ty::vstore,\n-                                 explicit_self: ast::self_ty_)\n-                              -> Callee\n-{\n+pub fn trans_trait_callee_from_llval(bcx: block,\n+                                     callee_ty: ty::t,\n+                                     n_method: uint,\n+                                     llpair: ValueRef,\n+                                     vstore: ty::vstore,\n+                                     explicit_self: ast::self_ty_)\n+                                  -> Callee {\n     //!\n     //\n     // Same as `trans_trait_callee()` above, except that it is given\n@@ -743,7 +743,9 @@ fn trans_trait_callee_from_llval(bcx: block,\n     };\n }\n \n-fn vtable_id(ccx: @crate_ctxt, +origin: typeck::vtable_origin) -> mono_id {\n+pub fn vtable_id(ccx: @crate_ctxt,\n+                 +origin: typeck::vtable_origin)\n+              -> mono_id {\n     match origin {\n         typeck::vtable_static(impl_id, substs, sub_vtables) => {\n             monomorphize::make_mono_id(\n@@ -770,7 +772,9 @@ fn vtable_id(ccx: @crate_ctxt, +origin: typeck::vtable_origin) -> mono_id {\n     }\n }\n \n-fn get_vtable(ccx: @crate_ctxt, +origin: typeck::vtable_origin) -> ValueRef {\n+pub fn get_vtable(ccx: @crate_ctxt,\n+                  +origin: typeck::vtable_origin)\n+               -> ValueRef {\n     // XXX: Bad copy.\n     let hash_id = vtable_id(ccx, copy origin);\n     match ccx.vtables.find(hash_id) {\n@@ -784,7 +788,7 @@ fn get_vtable(ccx: @crate_ctxt, +origin: typeck::vtable_origin) -> ValueRef {\n     }\n }\n \n-fn make_vtable(ccx: @crate_ctxt, ptrs: ~[ValueRef]) -> ValueRef {\n+pub fn make_vtable(ccx: @crate_ctxt, ptrs: ~[ValueRef]) -> ValueRef {\n     unsafe {\n         let _icx = ccx.insn_ctxt(\"impl::make_vtable\");\n         let tbl = C_struct(ptrs);\n@@ -799,8 +803,11 @@ fn make_vtable(ccx: @crate_ctxt, ptrs: ~[ValueRef]) -> ValueRef {\n     }\n }\n \n-fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n-                    vtables: typeck::vtable_res) -> ValueRef {\n+pub fn make_impl_vtable(ccx: @crate_ctxt,\n+                        impl_id: ast::def_id,\n+                        substs: ~[ty::t],\n+                        vtables: typeck::vtable_res)\n+                     -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"impl::make_impl_vtable\");\n     let tcx = ccx.tcx;\n \n@@ -840,13 +847,12 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n     }))\n }\n \n-fn trans_trait_cast(bcx: block,\n-                    val: @ast::expr,\n-                    id: ast::node_id,\n-                    dest: expr::Dest,\n-                    vstore: ty::vstore)\n-    -> block\n-{\n+pub fn trans_trait_cast(bcx: block,\n+                        val: @ast::expr,\n+                        id: ast::node_id,\n+                        dest: expr::Dest,\n+                        vstore: ty::vstore)\n+                     -> block {\n     let mut bcx = bcx;\n     let _icx = bcx.insn_ctxt(\"impl::trans_cast\");\n "}, {"sha": "d7deb2a4da7e04ff6c4bea70355058f7e753b223", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -351,7 +351,7 @@ pub fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n                         {\n                             let llty = type_of::type_of(ccx, subst);\n                             let size = machine::llbitsize_of_real(ccx, llty);\n-                            let align = shape::llalign_of_pref(ccx, llty);\n+                            let align = machine::llalign_of_pref(ccx, llty);\n                             let mode = datum::appropriate_mode(subst);\n \n                             // FIXME(#3547)---scalars and floats are"}, {"sha": "6b266f1d9639398eaa2dea467bd078b42b0f28f5", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -29,9 +29,7 @@ use syntax::attr;\n use syntax::print::pprust::expr_to_str;\n use syntax::{visit, ast_util, ast_map};\n \n-export map, find_reachable;\n-\n-type map = HashMap<node_id, ()>;\n+pub type map = HashMap<node_id, ()>;\n \n struct ctx {\n     exp_map2: resolve::ExportMap2,\n@@ -40,8 +38,8 @@ struct ctx {\n     rmap: map\n }\n \n-fn find_reachable(crate_mod: _mod, exp_map2: resolve::ExportMap2,\n-                  tcx: ty::ctxt, method_map: typeck::method_map) -> map {\n+pub fn find_reachable(crate_mod: _mod, exp_map2: resolve::ExportMap2,\n+                      tcx: ty::ctxt, method_map: typeck::method_map) -> map {\n     let rmap = HashMap();\n     let cx = ctx {\n         exp_map2: exp_map2,"}, {"sha": "f773b09d5dece96b92e31559ffbd72a117783820", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -19,24 +19,24 @@ use middle::trans::common::*;\n use middle::trans::datum::*;\n use middle::trans::expr::SaveIn;\n use middle::trans::glue;\n+use middle::trans::machine;\n use middle::trans::meth;\n-use middle::trans::shape;\n use middle::trans::type_of::*;\n use util::ppaux::ty_to_str;\n \n use std::map::HashMap;\n use syntax::ast::def_id;\n use syntax::ast;\n \n-enum reflector = {\n+pub enum reflector = {\n     visitor_val: ValueRef,\n     visitor_methods: @~[ty::method],\n     final_bcx: block,\n     tydesc_ty: TypeRef,\n     mut bcx: block\n };\n \n-impl reflector {\n+pub impl reflector {\n \n     fn c_uint(u: uint) -> ValueRef {\n         C_uint(self.bcx.ccx(), u)\n@@ -62,8 +62,8 @@ impl reflector {\n \n     fn c_size_and_align(t: ty::t) -> ~[ValueRef] {\n         let tr = type_of::type_of(self.bcx.ccx(), t);\n-        let s = shape::llsize_of_real(self.bcx.ccx(), tr);\n-        let a = shape::llalign_of_min(self.bcx.ccx(), tr);\n+        let s = machine::llsize_of_real(self.bcx.ccx(), tr);\n+        let a = machine::llalign_of_min(self.bcx.ccx(), tr);\n         return ~[self.c_uint(s),\n              self.c_uint(a)];\n     }\n@@ -310,9 +310,11 @@ impl reflector {\n }\n \n // Emit a sequence of calls to visit_ty::visit_foo\n-fn emit_calls_to_trait_visit_ty(bcx: block, t: ty::t,\n-                                visitor_val: ValueRef,\n-                                visitor_trait_id: def_id) -> block {\n+pub fn emit_calls_to_trait_visit_ty(bcx: block,\n+                                    t: ty::t,\n+                                    visitor_val: ValueRef,\n+                                    visitor_trait_id: def_id)\n+                                 -> block {\n     use syntax::parse::token::special_idents::tydesc;\n     let final = sub_block(bcx, ~\"final\");\n     assert bcx.ccx().tcx.intrinsic_defs.contains_key(tydesc);\n@@ -330,11 +332,12 @@ fn emit_calls_to_trait_visit_ty(bcx: block, t: ty::t,\n     return final;\n }\n \n-fn ast_proto_constant(proto: ast::Proto) -> uint {\n+pub fn ast_proto_constant(proto: ast::Proto) -> uint {\n     match proto {\n         ast::ProtoBare => 0u,\n         ast::ProtoUniq => 2u,\n         ast::ProtoBox => 3u,\n         ast::ProtoBorrowed => 4u,\n     }\n }\n+"}, {"sha": "a4cd967115be83b1e9afbd6b68e888dab16f2a0a", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -34,10 +34,13 @@ use syntax::util::interner;\n \n use ty_ctxt = middle::ty::ctxt;\n \n-type ctxt = {mut next_tag_id: u16, pad: u16, pad2: u32};\n+pub type ctxt = {mut next_tag_id: u16, pad: u16, pad2: u32};\n \n-fn mk_global(ccx: @crate_ctxt, name: ~str, llval: ValueRef, internal: bool) ->\n-   ValueRef {\n+pub fn mk_global(ccx: @crate_ctxt,\n+                 name: ~str,\n+                 llval: ValueRef,\n+                 internal: bool)\n+              -> ValueRef {\n     unsafe {\n         let llglobal = do str::as_c_str(name) |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval), buf)\n@@ -54,7 +57,7 @@ fn mk_global(ccx: @crate_ctxt, name: ~str, llval: ValueRef, internal: bool) ->\n     }\n }\n \n-fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n+pub fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n     unsafe {\n         let llshapetablesty = trans::common::T_named_struct(~\"shapes\");\n         let _llshapetables = str::as_c_str(~\"shapes\", |buf| {\n@@ -69,11 +72,11 @@ fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n Although these two functions are never called, they are here\n for a VERY GOOD REASON. See #3670\n */\n-fn add_u16(dest: &mut ~[u8], val: u16) {\n+pub fn add_u16(dest: &mut ~[u8], val: u16) {\n     *dest += ~[(val & 0xffu16) as u8, (val >> 8u16) as u8];\n }\n \n-fn add_substr(dest: &mut ~[u8], src: ~[u8]) {\n+pub fn add_substr(dest: &mut ~[u8], src: ~[u8]) {\n     add_u16(&mut *dest, vec::len(src) as u16);\n     *dest += src;\n }"}, {"sha": "65d16effed3956f3495de53ee772d3cfd2586c4f", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 59, "deletions": 55, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -31,7 +31,7 @@ use syntax::print::pprust::{expr_to_str};\n // containing an unboxed vector. This expands a boxed vector type into such an\n // expanded type. It doesn't respect mutability, but that doesn't matter at\n // this point.\n-fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n+pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let unit_ty = ty::sequence_element_type(tcx, t);\n     let unboxed_vec_ty = ty::mk_mut_unboxed_vec(tcx, unit_ty);\n     match ty::get(t).sty {\n@@ -46,35 +46,35 @@ fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     }\n }\n \n-fn get_fill(bcx: block, vptr: ValueRef) -> ValueRef {\n+pub fn get_fill(bcx: block, vptr: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_fill\");\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]))\n }\n-fn set_fill(bcx: block, vptr: ValueRef, fill: ValueRef) {\n+pub fn set_fill(bcx: block, vptr: ValueRef, fill: ValueRef) {\n     Store(bcx, fill, GEPi(bcx, vptr, [0u, abi::vec_elt_fill]));\n }\n-fn get_alloc(bcx: block, vptr: ValueRef) -> ValueRef {\n+pub fn get_alloc(bcx: block, vptr: ValueRef) -> ValueRef {\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_alloc]))\n }\n \n-fn get_bodyptr(bcx: block, vptr: ValueRef) -> ValueRef {\n+pub fn get_bodyptr(bcx: block, vptr: ValueRef) -> ValueRef {\n     base::non_gc_box_cast(bcx, GEPi(bcx, vptr, [0u, abi::box_field_body]))\n }\n \n-fn get_dataptr(bcx: block, vptr: ValueRef) -> ValueRef {\n+pub fn get_dataptr(bcx: block, vptr: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_dataptr\");\n     GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n }\n \n-fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n+pub fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::pointer_add\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, T_ptr(T_i8()));\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, ~[bytes]), old_ty);\n }\n \n-fn alloc_raw(bcx: block, unit_ty: ty::t,\n-              fill: ValueRef, alloc: ValueRef, heap: heap) -> Result {\n+pub fn alloc_raw(bcx: block, unit_ty: ty::t,\n+                 fill: ValueRef, alloc: ValueRef, heap: heap) -> Result {\n     let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n \n@@ -87,12 +87,16 @@ fn alloc_raw(bcx: block, unit_ty: ty::t,\n     Store(bcx, alloc, GEPi(bcx, body, [0u, abi::vec_elt_alloc]));\n     return rslt(bcx, box);\n }\n-fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n-                  fill: ValueRef, alloc: ValueRef) -> Result {\n+pub fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n+                      fill: ValueRef, alloc: ValueRef) -> Result {\n     alloc_raw(bcx, unit_ty, fill, alloc, heap_exchange)\n }\n \n-fn alloc_vec(bcx: block, unit_ty: ty::t, elts: uint, heap: heap) -> Result {\n+pub fn alloc_vec(bcx: block,\n+                 unit_ty: ty::t,\n+                 elts: uint,\n+                 heap: heap)\n+              -> Result {\n     let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n     let llunitty = type_of::type_of(ccx, unit_ty);\n@@ -106,7 +110,7 @@ fn alloc_vec(bcx: block, unit_ty: ty::t, elts: uint, heap: heap) -> Result {\n     return rslt(bcx, vptr);\n }\n \n-fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> Result {\n+pub fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> Result {\n     let _icx = bcx.insn_ctxt(\"tvec::duplicate_uniq\");\n \n     let fill = get_fill(bcx, get_bodyptr(bcx, vptr));\n@@ -123,7 +127,7 @@ fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> Result {\n     return rslt(bcx, newptr);\n }\n \n-fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n+pub fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n    block {\n     let _icx = bcx.insn_ctxt(\"tvec::make_drop_glue_unboxed\");\n     let tcx = bcx.tcx(), unit_ty = ty::sequence_element_type(tcx, vec_ty);\n@@ -132,14 +136,14 @@ fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n     } else { bcx }\n }\n \n-struct VecTypes {\n+pub struct VecTypes {\n     vec_ty: ty::t,\n     unit_ty: ty::t,\n     llunit_ty: TypeRef,\n     llunit_size: ValueRef\n }\n \n-impl VecTypes {\n+pub impl VecTypes {\n     fn to_str(ccx: @crate_ctxt) -> ~str {\n         fmt!(\"VecTypes {vec_ty=%s, unit_ty=%s, llunit_ty=%s, llunit_size=%s}\",\n              ty_to_str(ccx.tcx, self.vec_ty),\n@@ -149,11 +153,11 @@ impl VecTypes {\n     }\n }\n \n-fn trans_fixed_vstore(bcx: block,\n-                      vstore_expr: @ast::expr,\n-                      content_expr: @ast::expr,\n-                      dest: expr::Dest) -> block\n-{\n+pub fn trans_fixed_vstore(bcx: block,\n+                          vstore_expr: @ast::expr,\n+                          content_expr: @ast::expr,\n+                          dest: expr::Dest)\n+                       -> block {\n     //!\n     //\n     // [...] allocates a fixed-size array and moves it around \"by value\".\n@@ -178,11 +182,11 @@ fn trans_fixed_vstore(bcx: block,\n     };\n }\n \n-fn trans_slice_vstore(bcx: block,\n-                      vstore_expr: @ast::expr,\n-                      content_expr: @ast::expr,\n-                      dest: expr::Dest) -> block\n-{\n+pub fn trans_slice_vstore(bcx: block,\n+                          vstore_expr: @ast::expr,\n+                          content_expr: @ast::expr,\n+                          dest: expr::Dest)\n+                       -> block {\n     //!\n     //\n     // &[...] allocates memory on the stack and writes the values into it,\n@@ -237,11 +241,11 @@ fn trans_slice_vstore(bcx: block,\n     return bcx;\n }\n \n-fn trans_lit_str(bcx: block,\n-                 lit_expr: @ast::expr,\n-                 lit_str: @~str,\n-                 dest: Dest) -> block\n-{\n+pub fn trans_lit_str(bcx: block,\n+                     lit_expr: @ast::expr,\n+                     lit_str: @~str,\n+                     dest: Dest)\n+                  -> block {\n     //!\n     //\n     // Literal strings translate to slices into static memory.  This is\n@@ -275,10 +279,10 @@ fn trans_lit_str(bcx: block,\n }\n \n \n-fn trans_uniq_or_managed_vstore(bcx: block,\n-                                heap: heap,\n-                                vstore_expr: @ast::expr,\n-                                content_expr: @ast::expr) -> DatumBlock {\n+pub fn trans_uniq_or_managed_vstore(bcx: block,\n+                                    heap: heap,\n+                                    vstore_expr: @ast::expr,\n+                                    content_expr: @ast::expr) -> DatumBlock {\n     //!\n     //\n     // @[...] or ~[...] (also @\"...\" or ~\"...\") allocate boxes in the\n@@ -334,12 +338,12 @@ fn trans_uniq_or_managed_vstore(bcx: block,\n     return immediate_rvalue_bcx(bcx, val, vt.vec_ty);\n }\n \n-fn write_content(bcx: block,\n-                 vt: &VecTypes,\n-                 vstore_expr: @ast::expr,\n-                 content_expr: @ast::expr,\n-                 dest: Dest) -> block\n-{\n+pub fn write_content(bcx: block,\n+                     vt: &VecTypes,\n+                     vstore_expr: @ast::expr,\n+                     content_expr: @ast::expr,\n+                     dest: Dest)\n+                  -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::write_content\");\n     let mut bcx = bcx;\n \n@@ -436,12 +440,12 @@ fn write_content(bcx: block,\n     }\n }\n \n-fn vec_types_from_expr(bcx: block, vec_expr: @ast::expr) -> VecTypes {\n+pub fn vec_types_from_expr(bcx: block, vec_expr: @ast::expr) -> VecTypes {\n     let vec_ty = node_id_type(bcx, vec_expr.id);\n     vec_types(bcx, vec_ty)\n }\n \n-fn vec_types(bcx: block, vec_ty: ty::t) -> VecTypes {\n+pub fn vec_types(bcx: block, vec_ty: ty::t) -> VecTypes {\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let llunit_ty = type_of::type_of(ccx, unit_ty);\n@@ -453,7 +457,7 @@ fn vec_types(bcx: block, vec_ty: ty::t) -> VecTypes {\n               llunit_size: llunit_size}\n }\n \n-fn elements_required(bcx: block, content_expr: @ast::expr) -> uint {\n+pub fn elements_required(bcx: block, content_expr: @ast::expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match /*bad*/copy content_expr.node {\n@@ -469,9 +473,9 @@ fn elements_required(bcx: block, content_expr: @ast::expr) -> uint {\n     }\n }\n \n-fn get_base_and_len(bcx: block,\n-                    llval: ValueRef,\n-                    vec_ty: ty::t) -> (ValueRef, ValueRef) {\n+pub fn get_base_and_len(bcx: block,\n+                        llval: ValueRef,\n+                        vec_ty: ty::t) -> (ValueRef, ValueRef) {\n     //!\n     //\n     // Converts a vector into the slice pair.  The vector should be stored in\n@@ -507,12 +511,12 @@ fn get_base_and_len(bcx: block,\n     }\n }\n \n-type val_and_ty_fn = fn@(block, ValueRef, ty::t) -> Result;\n+pub type val_and_ty_fn = fn@(block, ValueRef, ty::t) -> Result;\n \n-type iter_vec_block = fn(block, ValueRef, ty::t) -> block;\n+pub type iter_vec_block = fn(block, ValueRef, ty::t) -> block;\n \n-fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n-                fill: ValueRef, f: iter_vec_block) -> block {\n+pub fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n+                    fill: ValueRef, f: iter_vec_block) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::iter_vec_raw\");\n \n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n@@ -542,15 +546,15 @@ fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n \n }\n \n-fn iter_vec_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n-                 fill: ValueRef, f: iter_vec_block) -> block {\n+pub fn iter_vec_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n+                     fill: ValueRef, f: iter_vec_block) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::iter_vec_uniq\");\n     let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr));\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n \n-fn iter_vec_unboxed(bcx: block, body_ptr: ValueRef, vec_ty: ty::t,\n-                    f: iter_vec_block) -> block {\n+pub fn iter_vec_unboxed(bcx: block, body_ptr: ValueRef, vec_ty: ty::t,\n+                        f: iter_vec_block) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::iter_vec_unboxed\");\n     let fill = get_fill(bcx, body_ptr);\n     let dataptr = get_dataptr(bcx, body_ptr);"}, {"sha": "a4b7dc323e8f7d7229dda4d15d1958b1632bbde3", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -14,6 +14,7 @@ use lib::llvm::{TypeRef};\n use middle::trans::common::*;\n use middle::trans::common;\n use middle::trans::expr;\n+use middle::trans::machine;\n use util::ppaux;\n \n use std::map::HashMap;\n@@ -29,7 +30,7 @@ export type_of_glue_fn;\n export type_of_non_gc_box;\n export type_of_rooted;\n \n-fn type_of_explicit_arg(ccx: @crate_ctxt, arg: ty::arg) -> TypeRef {\n+pub fn type_of_explicit_arg(ccx: @crate_ctxt, arg: ty::arg) -> TypeRef {\n     let llty = type_of(ccx, arg.ty);\n     match ty::resolved_mode(ccx.tcx, arg.mode) {\n         ast::by_val => llty,\n@@ -44,12 +45,13 @@ fn type_of_explicit_arg(ccx: @crate_ctxt, arg: ty::arg) -> TypeRef {\n     }\n }\n \n-fn type_of_explicit_args(ccx: @crate_ctxt, inputs: ~[ty::arg]) -> ~[TypeRef] {\n+pub fn type_of_explicit_args(ccx: @crate_ctxt, inputs: ~[ty::arg])\n+                          -> ~[TypeRef] {\n     inputs.map(|arg| type_of_explicit_arg(ccx, *arg))\n }\n \n-fn type_of_fn(cx: @crate_ctxt, inputs: ~[ty::arg],\n-              output: ty::t) -> TypeRef {\n+pub fn type_of_fn(cx: @crate_ctxt, inputs: ~[ty::arg],\n+                  output: ty::t) -> TypeRef {\n     unsafe {\n         let mut atys: ~[TypeRef] = ~[];\n \n@@ -66,11 +68,11 @@ fn type_of_fn(cx: @crate_ctxt, inputs: ~[ty::arg],\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t) -> TypeRef {\n+pub fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t) -> TypeRef {\n     type_of_fn(cx, ty::ty_fn_args(fty), ty::ty_fn_ret(fty))\n }\n \n-fn type_of_non_gc_box(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n+pub fn type_of_non_gc_box(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     assert !ty::type_needs_infer(t);\n \n     let t_norm = ty::normalize_ty(cx.tcx, t);\n@@ -91,7 +93,7 @@ fn type_of_non_gc_box(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     }\n }\n \n-fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n+pub fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     debug!(\"type_of %?: %?\", t, ty::get(t));\n \n     // Check the cache.\n@@ -234,14 +236,14 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     return llty;\n }\n \n-fn fill_type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t,\n-                     llty: TypeRef) {\n+pub fn fill_type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t,\n+                         llty: TypeRef) {\n \n     debug!(\"type_of_enum %?: %?\", t, ty::get(t));\n \n     let lltys = {\n         let degen = ty::enum_is_univariant(cx.tcx, did);\n-        let size = shape::static_size_of_enum(cx, t);\n+        let size = machine::static_size_of_enum(cx, t);\n         if !degen {\n             ~[T_enum_discrim(cx), T_array(T_i8(), size)]\n         }\n@@ -257,13 +259,12 @@ fn fill_type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t,\n }\n \n // Want refinements! (Or case classes, I guess\n-enum named_ty { a_struct, an_enum }\n+pub enum named_ty { a_struct, an_enum }\n \n-fn llvm_type_name(cx: @crate_ctxt,\n-                  what: named_ty,\n-                  did: ast::def_id,\n-                  tps: ~[ty::t]\n-                  ) -> ~str {\n+pub fn llvm_type_name(cx: @crate_ctxt,\n+                      what: named_ty,\n+                      did: ast::def_id,\n+                      tps: ~[ty::t]) -> ~str {\n     let name = match what {\n         a_struct => { \"~struct\" }\n         an_enum => { \"~enum\" }\n@@ -280,22 +281,22 @@ fn llvm_type_name(cx: @crate_ctxt,\n     );\n }\n \n-fn type_of_dtor(ccx: @crate_ctxt, self_ty: ty::t) -> TypeRef {\n+pub fn type_of_dtor(ccx: @crate_ctxt, self_ty: ty::t) -> TypeRef {\n     unsafe {\n         T_fn(~[T_ptr(type_of(ccx, ty::mk_nil(ccx.tcx))), // output pointer\n                T_ptr(type_of(ccx, self_ty))],            // self arg\n              llvm::LLVMVoidType())\n     }\n }\n \n-fn type_of_rooted(ccx: @crate_ctxt, t: ty::t) -> TypeRef {\n+pub fn type_of_rooted(ccx: @crate_ctxt, t: ty::t) -> TypeRef {\n     let addrspace = base::get_tydesc(ccx, t).addrspace;\n     debug!(\"type_of_rooted %s in addrspace %u\",\n            ty_to_str(ccx.tcx, t), addrspace as uint);\n     return T_root(type_of(ccx, t), addrspace);\n }\n \n-fn type_of_glue_fn(ccx: @crate_ctxt, t: ty::t) -> TypeRef {\n+pub fn type_of_glue_fn(ccx: @crate_ctxt, t: ty::t) -> TypeRef {\n     let tydescpp = T_ptr(T_ptr(ccx.tydesc_type));\n     let llty = T_ptr(type_of(ccx, t));\n     return T_fn(~[T_ptr(T_nil()), T_ptr(T_nil()), tydescpp, llty],"}, {"sha": "c19db4a75b9ddabd5a604208d69b60425174b339", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -44,15 +44,14 @@ use syntax::ast_map;\n use syntax::ast_util;\n use syntax::visit;\n \n-type type_uses = uint; // Bitmask\n-const use_repr: uint = 1u;   /* Dependency on size/alignment/mode and\n-                                take/drop glue */\n-const use_tydesc: uint = 2u; /* Takes the tydesc, or compares */\n+pub type type_uses = uint; // Bitmask\n+pub const use_repr: uint = 1u;   /* Dependency on size/alignment/mode and\n+                                    take/drop glue */\n+pub const use_tydesc: uint = 2u; /* Takes the tydesc, or compares */\n \n-type ctx = {ccx: @crate_ctxt,\n-            uses: ~[mut type_uses]};\n+pub type ctx = {ccx: @crate_ctxt, uses: ~[mut type_uses]};\n \n-fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n+pub fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     -> ~[type_uses] {\n     match ccx.type_use_cache.find(fn_id) {\n       Some(uses) => return uses,\n@@ -175,7 +174,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     uses\n }\n \n-fn type_needs(cx: ctx, use_: uint, ty: ty::t) {\n+pub fn type_needs(cx: ctx, use_: uint, ty: ty::t) {\n     // Optimization -- don't descend type if all params already have this use\n     for vec::each_mut(cx.uses) |u| {\n         if *u & use_ != use_ {\n@@ -185,8 +184,10 @@ fn type_needs(cx: ctx, use_: uint, ty: ty::t) {\n     }\n }\n \n-fn type_needs_inner(cx: ctx, use_: uint, ty: ty::t,\n-                    enums_seen: @List<def_id>) {\n+pub fn type_needs_inner(cx: ctx,\n+                        use_: uint,\n+                        ty: ty::t,\n+                        enums_seen: @List<def_id>) {\n     do ty::maybe_walk_ty(ty) |ty| {\n         if ty::type_has_params(ty) {\n             match ty::get(ty).sty {\n@@ -220,11 +221,11 @@ fn type_needs_inner(cx: ctx, use_: uint, ty: ty::t,\n     }\n }\n \n-fn node_type_needs(cx: ctx, use_: uint, id: node_id) {\n+pub fn node_type_needs(cx: ctx, use_: uint, id: node_id) {\n     type_needs(cx, use_, ty::node_id_to_type(cx.ccx.tcx, id));\n }\n \n-fn mark_for_method_call(cx: ctx, e_id: node_id, callee_id: node_id) {\n+pub fn mark_for_method_call(cx: ctx, e_id: node_id, callee_id: node_id) {\n     do option::iter(&cx.ccx.maps.method_map.find(e_id)) |mth| {\n         match mth.origin {\n           typeck::method_static(did) => {\n@@ -247,7 +248,7 @@ fn mark_for_method_call(cx: ctx, e_id: node_id, callee_id: node_id) {\n     }\n }\n \n-fn mark_for_expr(cx: ctx, e: @expr) {\n+pub fn mark_for_expr(cx: ctx, e: @expr) {\n     match e.node {\n       expr_vstore(_, _) |\n       expr_vec(_, _) |\n@@ -347,7 +348,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n     }\n }\n \n-fn handle_body(cx: ctx, body: blk) {\n+pub fn handle_body(cx: ctx, body: blk) {\n     let v = visit::mk_vt(@visit::Visitor {\n         visit_expr: |e, cx, v| {\n             visit::visit_expr(e, cx, v);\n@@ -372,3 +373,4 @@ fn handle_body(cx: ctx, body: blk) {\n     });\n     (v.visit_block)(body, cx, v);\n }\n+"}, {"sha": "194a9c4ea09bf6590bbf7472b73f02a0646d683c", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -20,9 +20,7 @@ use middle::trans::glue;\n \n use syntax::ast;\n \n-export make_free_glue, autoderef, duplicate;\n-\n-fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n+pub fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n     -> block {\n     let _icx = bcx.insn_ctxt(\"uniq::make_free_glue\");\n     let box_datum = immediate_rvalue(Load(bcx, vptrptr), box_ty);\n@@ -36,7 +34,7 @@ fn make_free_glue(bcx: block, vptrptr: ValueRef, box_ty: ty::t)\n     }\n }\n \n-fn duplicate(bcx: block, src_box: ValueRef, src_ty: ty::t) -> Result {\n+pub fn duplicate(bcx: block, src_box: ValueRef, src_ty: ty::t) -> Result {\n     let _icx = bcx.insn_ctxt(\"uniq::duplicate\");\n \n     // Load the body of the source (*src)"}, {"sha": "676f4d0238fd11a7e68c2ac86107e60b89918ec7", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ba11e96289facfd33ed08bdf110b16a1cf940005/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=ba11e96289facfd33ed08bdf110b16a1cf940005", "patch": "@@ -57,41 +57,23 @@ pub mod middle {\n         pub mod datum;\n         pub mod callee;\n         pub mod expr;\n-        #[legacy_exports]\n         pub mod common;\n-        #[legacy_exports]\n         pub mod consts;\n-        #[legacy_exports]\n         pub mod type_of;\n-        #[legacy_exports]\n         pub mod build;\n-        #[legacy_exports]\n         pub mod base;\n-        #[legacy_exports]\n         pub mod _match;\n-        #[legacy_exports]\n         pub mod uniq;\n-        #[legacy_exports]\n         pub mod closure;\n-        #[legacy_exports]\n         pub mod tvec;\n-        #[legacy_exports]\n         pub mod meth;\n-        #[legacy_exports]\n         pub mod cabi;\n-        #[legacy_exports]\n         pub mod cabi_x86_64;\n-        #[legacy_exports]\n         pub mod foreign;\n-        #[legacy_exports]\n         pub mod reflect;\n-        #[legacy_exports]\n         pub mod shape;\n-        #[legacy_exports]\n         pub mod debuginfo;\n-        #[legacy_exports]\n         pub mod type_use;\n-        #[legacy_exports]\n         pub mod reachable;\n         pub mod machine;\n     }"}]}