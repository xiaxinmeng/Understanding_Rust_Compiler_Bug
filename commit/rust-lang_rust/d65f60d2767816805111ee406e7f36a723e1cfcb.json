{"sha": "d65f60d2767816805111ee406e7f36a723e1cfcb", "node_id": "C_kwDOAAsO6NoAKGQ2NWY2MGQyNzY3ODE2ODA1MTExZWU0MDZlN2YzNmE3MjNlMWNmY2I", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2023-01-31T22:38:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-31T22:38:50Z"}, "message": "Rollup merge of #107348 - lcnr:project-solve-new, r=compiler-errors\n\nsmall refactor to new projection code\n\nextract `eq_term_and_make_canonical_response` into a helper function which also is another guarantee that the expected term does not influence candidate selection for projections.\n\nalso change `evaluate_all(vec![single_goal])` to use `evaluate_goal`.\n\nthe second commit now also adds a `debug_assert!` to `evaluate_goal`.", "tree": {"sha": "e644381b07862a0fa62fa7468abcef6824c82851", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e644381b07862a0fa62fa7468abcef6824c82851"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d65f60d2767816805111ee406e7f36a723e1cfcb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj2Zh6CRBK7hj4Ov3rIwAAIAYIABS3fWDp8GAc9y5XJ+qcnnx1\n4sJ2lG80EXkKvt5ynacR6I44MUNicBeoFe4P/bG44+PJd9pcDFuV0oSTQEf6NcQM\nWGZ0zDsLNjwjlvFK+rtrki2SX03Bt8LK44jJxQi98gC6M2fPbs+RRGnFIHH5QT2a\nHCnYt0l6GE6lvRmafjQFKz3woi/OFKy8yq5ThCraZrWdE9IOt4ONU2V7dpO8NKf3\nFyA2XA10+DpsJJZ+GKon0k/vm+uuQSK+b1O83qNg2QeVM0qVX7UZz81zSXu84SjD\nZjNF0j5R0oM7Tg1DzvCnwRFbCrNSPV5l4jXTLVCWumTeK7wls6ZRwzmJby1+mF8=\n=Xhk2\n-----END PGP SIGNATURE-----\n", "payload": "tree e644381b07862a0fa62fa7468abcef6824c82851\nparent 4755c7c60e9496bdc2365854a0f0ec595a569547\nparent 85e6f38e797959d2f65f908f88a81d3e6891d609\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1675204730 +0100\ncommitter GitHub <noreply@github.com> 1675204730 +0100\n\nRollup merge of #107348 - lcnr:project-solve-new, r=compiler-errors\n\nsmall refactor to new projection code\n\nextract `eq_term_and_make_canonical_response` into a helper function which also is another guarantee that the expected term does not influence candidate selection for projections.\n\nalso change `evaluate_all(vec![single_goal])` to use `evaluate_goal`.\n\nthe second commit now also adds a `debug_assert!` to `evaluate_goal`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d65f60d2767816805111ee406e7f36a723e1cfcb", "html_url": "https://github.com/rust-lang/rust/commit/d65f60d2767816805111ee406e7f36a723e1cfcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d65f60d2767816805111ee406e7f36a723e1cfcb/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4755c7c60e9496bdc2365854a0f0ec595a569547", "url": "https://api.github.com/repos/rust-lang/rust/commits/4755c7c60e9496bdc2365854a0f0ec595a569547", "html_url": "https://github.com/rust-lang/rust/commit/4755c7c60e9496bdc2365854a0f0ec595a569547"}, {"sha": "85e6f38e797959d2f65f908f88a81d3e6891d609", "url": "https://api.github.com/repos/rust-lang/rust/commits/85e6f38e797959d2f65f908f88a81d3e6891d609", "html_url": "https://github.com/rust-lang/rust/commit/85e6f38e797959d2f65f908f88a81d3e6891d609"}], "stats": {"total": 131, "additions": 86, "deletions": 45}, "files": [{"sha": "36170b3788a7a7b0cc5d1cf21badbbf48ae0f261", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d65f60d2767816805111ee406e7f36a723e1cfcb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d65f60d2767816805111ee406e7f36a723e1cfcb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=d65f60d2767816805111ee406e7f36a723e1cfcb", "patch": "@@ -161,6 +161,7 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n             search_graph: &mut search_graph,\n             infcx: self,\n             var_values: CanonicalVarValues::dummy(),\n+            in_projection_eq_hack: false,\n         }\n         .evaluate_goal(goal);\n \n@@ -174,6 +175,10 @@ struct EvalCtxt<'a, 'tcx> {\n     var_values: CanonicalVarValues<'tcx>,\n \n     search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n+\n+    /// This field is used by a debug assertion in [`EvalCtxt::evaluate_goal`],\n+    /// see the comment in that method for more details.\n+    in_projection_eq_hack: bool,\n }\n \n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n@@ -209,7 +214,8 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         loop {\n             let (ref infcx, goal, var_values) =\n                 tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-            let mut ecx = EvalCtxt { infcx, var_values, search_graph };\n+            let mut ecx =\n+                EvalCtxt { infcx, var_values, search_graph, in_projection_eq_hack: false };\n             let result = ecx.compute_goal(goal);\n \n             // FIXME: `Response` should be `Copy`\n@@ -239,10 +245,28 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         let canonical_goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n         let canonical_response =\n             EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n-        Ok((\n-            !canonical_response.value.var_values.is_identity(),\n-            instantiate_canonical_query_response(self.infcx, &orig_values, canonical_response),\n-        ))\n+\n+        let has_changed = !canonical_response.value.var_values.is_identity();\n+        let certainty =\n+            instantiate_canonical_query_response(self.infcx, &orig_values, canonical_response);\n+\n+        // Check that rerunning this query with its inference constraints applied\n+        // doesn't result in new inference constraints and has the same result.\n+        //\n+        // If we have projection goals like `<T as Trait>::Assoc == u32` we recursively\n+        // call `exists<U> <T as Trait>::Assoc == U` to enable better caching. This goal\n+        // could constrain `U` to `u32` which would cause this check to result in a\n+        // solver cycle.\n+        if cfg!(debug_assertions) && has_changed && !self.in_projection_eq_hack {\n+            let mut orig_values = OriginalQueryValues::default();\n+            let canonical_goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+            let canonical_response =\n+                EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n+            assert!(canonical_response.value.var_values.is_identity());\n+            assert_eq!(certainty, canonical_response.value.certainty);\n+        }\n+\n+        Ok((has_changed, certainty))\n     }\n \n     fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {"}, {"sha": "a23fdd24b4e42338032bb8bd919a6faec10f5a6a", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 52, "deletions": 39, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d65f60d2767816805111ee406e7f36a723e1cfcb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d65f60d2767816805111ee406e7f36a723e1cfcb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=d65f60d2767816805111ee406e7f36a723e1cfcb", "patch": "@@ -45,8 +45,9 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 projection_ty: goal.predicate.projection_ty,\n                 term: unconstrained_rhs,\n             });\n-            let (_has_changed, normalize_certainty) =\n-                self.evaluate_goal(goal.with(self.tcx(), unconstrained_predicate))?;\n+            let (_has_changed, normalize_certainty) = self.in_projection_eq_hack(|this| {\n+                this.evaluate_goal(goal.with(this.tcx(), unconstrained_predicate))\n+            })?;\n \n             let nested_eq_goals =\n                 self.infcx.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n@@ -55,6 +56,15 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    /// This sets a flag used by a debug assert in [`EvalCtxt::evaluate_goal`],\n+    /// see the comment in that method for more details.\n+    fn in_projection_eq_hack<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n+        self.in_projection_eq_hack = true;\n+        let result = f(self);\n+        self.in_projection_eq_hack = false;\n+        result\n+    }\n+\n     /// Is the projection predicate is of the form `exists<T> <Ty as Trait>::Assoc = T`.\n     ///\n     /// This is the case if the `term` is an inference variable in the innermost universe\n@@ -122,6 +132,28 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             && goal.param_env.visit_with(&mut visitor).is_continue()\n     }\n \n+    /// After normalizing the projection to `normalized_alias` with the given\n+    /// `normalization_certainty`, constrain the inference variable `term` to it\n+    /// and return a query response.\n+    fn eq_term_and_make_canonical_response(\n+        &mut self,\n+        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n+        normalization_certainty: Certainty,\n+        normalized_alias: impl Into<ty::Term<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        // The term of our goal should be fully unconstrained, so this should never fail.\n+        //\n+        // It can however be ambiguous when the `normalized_alias` contains a projection.\n+        let nested_goals = self\n+            .infcx\n+            .eq(goal.param_env, goal.predicate.term, normalized_alias.into())\n+            .expect(\"failed to unify with unconstrained term\");\n+        let rhs_certainty =\n+            self.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n+\n+        self.make_canonical_response(normalization_certainty.unify_and(rhs_certainty))\n+    }\n+\n     fn merge_project_candidates(\n         &mut self,\n         mut candidates: Vec<Candidate<'tcx>>,\n@@ -218,7 +250,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 .map(|pred| goal.with(tcx, pred));\n \n             nested_goals.extend(where_clause_bounds);\n-            let trait_ref_certainty = ecx.evaluate_all(nested_goals)?;\n+            let match_impl_certainty = ecx.evaluate_all(nested_goals)?;\n \n             // In case the associated item is hidden due to specialization, we have to\n             // return ambiguity this would otherwise be incomplete, resulting in\n@@ -230,7 +262,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 goal.predicate.def_id(),\n                 impl_def_id\n             )? else {\n-                return ecx.make_canonical_response(trait_ref_certainty.unify_and(Certainty::AMBIGUOUS));\n+                return ecx.make_canonical_response(match_impl_certainty.unify_and(Certainty::AMBIGUOUS));\n             };\n \n             if !assoc_def.item.defaultness(tcx).has_value() {\n@@ -277,17 +309,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ty.map_bound(|ty| ty.into())\n             };\n \n-            // The term of our goal should be fully unconstrained, so this should never fail.\n-            //\n-            // It can however be ambiguous when the resolved type is a projection.\n-            let nested_goals = ecx\n-                .infcx\n-                .eq(goal.param_env, goal.predicate.term, term.subst(tcx, substs))\n-                .expect(\"failed to unify with unconstrained term\");\n-            let rhs_certainty =\n-                ecx.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n-\n-            ecx.make_canonical_response(trait_ref_certainty.unify_and(rhs_certainty))\n+            ecx.eq_term_and_make_canonical_response(goal, match_impl_certainty, term.subst(tcx, substs))\n         })\n     }\n \n@@ -309,18 +331,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 )?;\n                 let subst_certainty = ecx.evaluate_all(nested_goals)?;\n \n-                // The term of our goal should be fully unconstrained, so this should never fail.\n-                //\n-                // It can however be ambiguous when the resolved type is a projection.\n-                let nested_goals = ecx\n-                    .infcx\n-                    .eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)\n-                    .expect(\"failed to unify with unconstrained term\");\n-                let rhs_certainty = ecx\n-                    .evaluate_all(nested_goals)\n-                    .expect(\"failed to unify with unconstrained term\");\n-\n-                ecx.make_canonical_response(subst_certainty.unify_and(rhs_certainty))\n+                ecx.eq_term_and_make_canonical_response(\n+                    goal,\n+                    subst_certainty,\n+                    assumption_projection_pred.term,\n+                )\n             })\n         } else {\n             Err(NoSolution)\n@@ -437,14 +452,12 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                         [ty::GenericArg::from(goal.predicate.self_ty())],\n                     ));\n \n-                    let mut nested_goals = ecx.infcx.eq(\n-                        goal.param_env,\n-                        goal.predicate.term.ty().unwrap(),\n+                    let is_sized_certainty = ecx.evaluate_goal(goal.with(tcx, sized_predicate))?.1;\n+                    return ecx.eq_term_and_make_canonical_response(\n+                        goal,\n+                        is_sized_certainty,\n                         tcx.types.unit,\n-                    )?;\n-                    nested_goals.push(goal.with(tcx, sized_predicate));\n-\n-                    return ecx.evaluate_all_and_make_canonical_response(nested_goals);\n+                    );\n                 }\n \n                 ty::Adt(def, substs) if def.is_struct() => {\n@@ -456,7 +469,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                                 tcx,\n                                 ty::Binder::dummy(goal.predicate.with_self_ty(tcx, self_ty)),\n                             );\n-                            return ecx.evaluate_all_and_make_canonical_response(vec![new_goal]);\n+                            let (_, certainty) = ecx.evaluate_goal(new_goal)?;\n+                            return ecx.make_canonical_response(certainty);\n                         }\n                     }\n                 }\n@@ -469,7 +483,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                             tcx,\n                             ty::Binder::dummy(goal.predicate.with_self_ty(tcx, self_ty)),\n                         );\n-                        return ecx.evaluate_all_and_make_canonical_response(vec![new_goal]);\n+                        let (_, certainty) = ecx.evaluate_goal(new_goal)?;\n+                        return ecx.make_canonical_response(certainty);\n                     }\n                 },\n \n@@ -482,9 +497,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ),\n             };\n \n-            let nested_goals =\n-                ecx.infcx.eq(goal.param_env, goal.predicate.term.ty().unwrap(), metadata_ty)?;\n-            ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+            ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, metadata_ty)\n         })\n     }\n "}, {"sha": "7514c7ee55170482df63a66136f376b39492629f", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d65f60d2767816805111ee406e7f36a723e1cfcb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d65f60d2767816805111ee406e7f36a723e1cfcb/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=d65f60d2767816805111ee406e7f36a723e1cfcb", "patch": "@@ -45,6 +45,7 @@ impl<'tcx> SearchGraph<'tcx> {\n     /// Tries putting the new goal on the stack, returning an error if it is already cached.\n     ///\n     /// This correctly updates the provisional cache if there is a cycle.\n+    #[instrument(level = \"debug\", skip(self, tcx), ret)]\n     pub(super) fn try_push_stack(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n@@ -79,8 +80,10 @@ impl<'tcx> SearchGraph<'tcx> {\n             Entry::Occupied(entry_index) => {\n                 let entry_index = *entry_index.get();\n \n-                cache.add_dependency_of_leaf_on(entry_index);\n                 let stack_depth = cache.depth(entry_index);\n+                debug!(\"encountered cycle with depth {stack_depth:?}\");\n+\n+                cache.add_dependency_of_leaf_on(entry_index);\n \n                 self.stack[stack_depth].has_been_used = true;\n                 // NOTE: The goals on the stack aren't the only goals involved in this cycle.\n@@ -117,6 +120,7 @@ impl<'tcx> SearchGraph<'tcx> {\n     /// updated the provisional cache and we have to recompute the current goal.\n     ///\n     /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n+    #[instrument(level = \"debug\", skip(self, tcx, actual_goal), ret)]\n     pub(super) fn try_finalize_goal(\n         &mut self,\n         tcx: TyCtxt<'tcx>,"}]}