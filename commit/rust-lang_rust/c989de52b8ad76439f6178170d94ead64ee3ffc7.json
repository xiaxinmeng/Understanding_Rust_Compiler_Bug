{"sha": "c989de52b8ad76439f6178170d94ead64ee3ffc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ODlkZTUyYjhhZDc2NDM5ZjYxNzgxNzBkOTRlYWQ2NGVlM2ZmYzc=", "commit": {"author": {"name": "Theodore Cipicchio", "email": "okready@users.noreply.github.com", "date": "2020-09-04T16:34:11Z"}, "committer": {"name": "Theodore Cipicchio", "email": "okready@users.noreply.github.com", "date": "2020-09-04T20:58:59Z"}, "message": "Add is_enclave_range/is_user_range overflow checks\n\nFunctions such as `is_enclave_range` and `is_user_range` in\n`sgx::os::fortanix_sgx::mem` are often used to make sure memory ranges\npassed to an enclave from untrusted code or passed to other trusted code\nfunctions are safe to use for their intended purpose. Currently, these\nfunctions do not perform any checks to make sure the range provided\ndoesn't overflow when adding the range length to the base address. While\ndebug builds will panic if overflow occurs, release builds will simply\nwrap the result, leading to false positive results for either function.\nThe burden is placed on application authors to know to perform overflow\nchecks on their own before calling these functions, which can easily\nlead to security vulnerabilities if omitted. Additionally, since such\nchecks are performed in the Intel SGX SDK versions of these functions,\ndevelopers migrating from Intel SGX SDK code may expect these functions\nto operate the same.\n\nThis commit adds explicit overflow checking to `is_enclave_range` and\n`is_user_range`, returning `false` if overflow occurs in order to\nprevent misuse of invalid memory ranges. It also alters the checks to\naccount for ranges that lie exactly at the end of the address space,\nwhere calculating `p + len` would overflow despite the range being\nvalid.", "tree": {"sha": "c8d80a2b0f3c718b0311fee018404ad459160845", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8d80a2b0f3c718b0311fee018404ad459160845"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c989de52b8ad76439f6178170d94ead64ee3ffc7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEETqenfstpHrwUj1Tt9FoElUL2BdcFAl9SqpUACgkQ9FoElUL2\nBdcyKw/9HP5rmVJ0k0HDYHe4xeQtuNQ1BUMizd/EGF32Mer6yyxefAZLm+3NyOeS\nriJnGapR8xagoPBPhrpvIEb37mymMrl6lUJf7XNXQTgpUgMvW4htk9pixU2lOPZ3\nOpf6Md+zjR1x9WwPM78ec0sbfGg/IGJIM0GdCyS46+rML7yR35rCITHCXbo1A6ea\niUeIkxXttEoo5H1m1i8KRHp3rNawN8+K8bxN+tVexspb5toPqsIgf9E7zILu4ThD\ny/S4Ivh8s3VhkPEjMaQIBHBioVSYQCRGAEY3JDrVU4ipjLok6w9nYdybA5+joCb1\nfau0uW2OONRW7C/QKvQ3dQSWDhjTJ4v8dxPFm5ASyRPb+qiLaJ00rlywzpxa8pZN\n42+hXkQI45z8HkakvuD+zOoAWFjN/TkTH9wfXDPJ2vXX9mMOEh3plAquyjQz7mSh\ngz7Qxx0aJuKIWwYb2LvjwHLne5uDT8QEPXQOQwkECQwf4s344vc6on/CWip4i/R2\nYm38ZqNrn/qCRVtvZrgjwZ9Vn0pSV8u6mY88T8TVBmddN92MtiV4XIIt0AONnt09\nS2wLpwUenlXIj3cTY5g9Jksvt6sjSEOKzW1lYBm7OVWgo6eNvt1Hz6Yr6RtJsrOi\nDQsdciLqiZdybtAVx5aAhmhv5ZK2Tc47eAWC/idQxGnHFle8S9I=\n=WW9G\n-----END PGP SIGNATURE-----", "payload": "tree c8d80a2b0f3c718b0311fee018404ad459160845\nparent d2454643e137bde519786ee9e650c455d7ad6f34\nauthor Theodore Cipicchio <okready@users.noreply.github.com> 1599237251 -0700\ncommitter Theodore Cipicchio <okready@users.noreply.github.com> 1599253139 -0700\n\nAdd is_enclave_range/is_user_range overflow checks\n\nFunctions such as `is_enclave_range` and `is_user_range` in\n`sgx::os::fortanix_sgx::mem` are often used to make sure memory ranges\npassed to an enclave from untrusted code or passed to other trusted code\nfunctions are safe to use for their intended purpose. Currently, these\nfunctions do not perform any checks to make sure the range provided\ndoesn't overflow when adding the range length to the base address. While\ndebug builds will panic if overflow occurs, release builds will simply\nwrap the result, leading to false positive results for either function.\nThe burden is placed on application authors to know to perform overflow\nchecks on their own before calling these functions, which can easily\nlead to security vulnerabilities if omitted. Additionally, since such\nchecks are performed in the Intel SGX SDK versions of these functions,\ndevelopers migrating from Intel SGX SDK code may expect these functions\nto operate the same.\n\nThis commit adds explicit overflow checking to `is_enclave_range` and\n`is_user_range`, returning `false` if overflow occurs in order to\nprevent misuse of invalid memory ranges. It also alters the checks to\naccount for ranges that lie exactly at the end of the address space,\nwhere calculating `p + len` would overflow despite the range being\nvalid.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c989de52b8ad76439f6178170d94ead64ee3ffc7", "html_url": "https://github.com/rust-lang/rust/commit/c989de52b8ad76439f6178170d94ead64ee3ffc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c989de52b8ad76439f6178170d94ead64ee3ffc7/comments", "author": {"login": "okready", "id": 423952, "node_id": "MDQ6VXNlcjQyMzk1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/423952?v=4", "gravatar_id": "", "url": "https://api.github.com/users/okready", "html_url": "https://github.com/okready", "followers_url": "https://api.github.com/users/okready/followers", "following_url": "https://api.github.com/users/okready/following{/other_user}", "gists_url": "https://api.github.com/users/okready/gists{/gist_id}", "starred_url": "https://api.github.com/users/okready/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/okready/subscriptions", "organizations_url": "https://api.github.com/users/okready/orgs", "repos_url": "https://api.github.com/users/okready/repos", "events_url": "https://api.github.com/users/okready/events{/privacy}", "received_events_url": "https://api.github.com/users/okready/received_events", "type": "User", "site_admin": false}, "committer": {"login": "okready", "id": 423952, "node_id": "MDQ6VXNlcjQyMzk1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/423952?v=4", "gravatar_id": "", "url": "https://api.github.com/users/okready", "html_url": "https://github.com/okready", "followers_url": "https://api.github.com/users/okready/followers", "following_url": "https://api.github.com/users/okready/following{/other_user}", "gists_url": "https://api.github.com/users/okready/gists{/gist_id}", "starred_url": "https://api.github.com/users/okready/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/okready/subscriptions", "organizations_url": "https://api.github.com/users/okready/orgs", "repos_url": "https://api.github.com/users/okready/repos", "events_url": "https://api.github.com/users/okready/events{/privacy}", "received_events_url": "https://api.github.com/users/okready/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2454643e137bde519786ee9e650c455d7ad6f34", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2454643e137bde519786ee9e650c455d7ad6f34", "html_url": "https://github.com/rust-lang/rust/commit/d2454643e137bde519786ee9e650c455d7ad6f34"}], "stats": {"total": 42, "additions": 34, "deletions": 8}, "files": [{"sha": "09f5a4fb760e61e798cfda0b3bfbf4961ebd67d5", "filename": "library/std/src/sys/sgx/abi/mem.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c989de52b8ad76439f6178170d94ead64ee3ffc7/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c989de52b8ad76439f6178170d94ead64ee3ffc7/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fmem.rs?ref=c989de52b8ad76439f6178170d94ead64ee3ffc7", "patch": "@@ -28,20 +28,46 @@ pub fn image_base() -> u64 {\n \n /// Returns `true` if the specified memory range is in the enclave.\n ///\n-/// `p + len` must not overflow.\n+/// For safety, this function also checks whether the range given overflows,\n+/// returning `false` if so.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn is_enclave_range(p: *const u8, len: usize) -> bool {\n-    let start = p as u64;\n-    let end = start + (len as u64);\n-    start >= image_base() && end <= image_base() + (unsafe { ENCLAVE_SIZE } as u64) // unsafe ok: link-time constant\n+    let start = p as usize;\n+\n+    // Subtract one from `len` when calculating `end` in case `p + len` is\n+    // exactly at the end of addressable memory (`p + len` would overflow, but\n+    // the range is still valid).\n+    let end = if len == 0 {\n+        start\n+    } else if let Some(end) = start.checked_add(len - 1) {\n+        end\n+    } else {\n+        return false;\n+    };\n+\n+    let base = image_base() as usize;\n+    start >= base && end <= base + (unsafe { ENCLAVE_SIZE } - 1) // unsafe ok: link-time constant\n }\n \n /// Returns `true` if the specified memory range is in userspace.\n ///\n-/// `p + len` must not overflow.\n+/// For safety, this function also checks whether the range given overflows,\n+/// returning `false` if so.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn is_user_range(p: *const u8, len: usize) -> bool {\n-    let start = p as u64;\n-    let end = start + (len as u64);\n-    end <= image_base() || start >= image_base() + (unsafe { ENCLAVE_SIZE } as u64) // unsafe ok: link-time constant\n+    let start = p as usize;\n+\n+    // Subtract one from `len` when calculating `end` in case `p + len` is\n+    // exactly at the end of addressable memory (`p + len` would overflow, but\n+    // the range is still valid).\n+    let end = if len == 0 {\n+        start\n+    } else if let Some(end) = start.checked_add(len - 1) {\n+        end\n+    } else {\n+        return false;\n+    };\n+\n+    let base = image_base() as usize;\n+    end < base || start > base + (unsafe { ENCLAVE_SIZE } - 1) // unsafe ok: link-time constant\n }"}]}