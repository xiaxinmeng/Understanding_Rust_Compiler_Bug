{"sha": "617d3d6d722c432cdcbf210e6db55c3bdeafe381", "node_id": "C_kwDOAAsO6NoAKDYxN2QzZDZkNzIyYzQzMmNkY2JmMjEwZTZkYjU1YzNiZGVhZmUzODE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-31T05:42:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-31T05:42:26Z"}, "message": "Auto merge of #112127 - matthiaskrgr:rollup-77pt893, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #112031 (Migrate  `item_proc_macro` to Askama)\n - #112053 (Remove `-Zcgu-partitioning-strategy`.)\n - #112069 (offset_of: don't require type to be `Sized`)\n - #112084 (enhancements on  build_helper utilization and rustdoc-gui-test)\n - #112096 (Remove array_zip)\n - #112108 (Fix re-export of doc hidden item inside private item not displayed)\n - #112113 (rustdoc: simplify `clean` by removing `FnRetTy`)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "3f2161a911343bb2a4880e0b97c582d1807a216c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f2161a911343bb2a4880e0b97c582d1807a216c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/617d3d6d722c432cdcbf210e6db55c3bdeafe381", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/617d3d6d722c432cdcbf210e6db55c3bdeafe381", "html_url": "https://github.com/rust-lang/rust/commit/617d3d6d722c432cdcbf210e6db55c3bdeafe381", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/617d3d6d722c432cdcbf210e6db55c3bdeafe381/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f51fca3af344686d734c3ff6b4399642c4f92305", "url": "https://api.github.com/repos/rust-lang/rust/commits/f51fca3af344686d734c3ff6b4399642c4f92305", "html_url": "https://github.com/rust-lang/rust/commit/f51fca3af344686d734c3ff6b4399642c4f92305"}, {"sha": "77bbfbcdecae1d696da9dc7e671b33a804aa6abf", "url": "https://api.github.com/repos/rust-lang/rust/commits/77bbfbcdecae1d696da9dc7e671b33a804aa6abf", "html_url": "https://github.com/rust-lang/rust/commit/77bbfbcdecae1d696da9dc7e671b33a804aa6abf"}], "stats": {"total": 2971, "additions": 1413, "deletions": 1558}, "files": [{"sha": "e7aa317ad7501f2f08904c14d469a5cf909bd5f2", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -4289,6 +4289,7 @@ dependencies = [\n name = \"rustdoc-gui-test\"\n version = \"0.1.0\"\n dependencies = [\n+ \"build_helper\",\n  \"compiletest\",\n  \"getopts\",\n  \"walkdir\","}, {"sha": "0255b6603805d93fb274542b3af3f32dafe32d4d", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -668,11 +668,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             mir::Rvalue::NullaryOp(ref null_op, ty) => {\n                 let ty = self.monomorphize(ty);\n-                assert!(bx.cx().type_is_sized(ty));\n                 let layout = bx.cx().layout_of(ty);\n                 let val = match null_op {\n-                    mir::NullOp::SizeOf => layout.size.bytes(),\n-                    mir::NullOp::AlignOf => layout.align.abi.bytes(),\n+                    mir::NullOp::SizeOf => {\n+                        assert!(bx.cx().type_is_sized(ty));\n+                        layout.size.bytes()\n+                    }\n+                    mir::NullOp::AlignOf => {\n+                        assert!(bx.cx().type_is_sized(ty));\n+                        layout.align.abi.bytes()\n+                    }\n                     mir::NullOp::OffsetOf(fields) => {\n                         layout.offset_of_subfield(bx.cx(), fields.iter().map(|f| f.index())).bytes()\n                     }"}, {"sha": "be9c349c3841621857f1b587bb4389e961fa29bb", "filename": "compiler/rustc_monomorphize/src/partitioning.rs", "status": "added", "additions": 1182, "deletions": 0, "changes": 1182, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -0,0 +1,1182 @@\n+//! Partitioning Codegen Units for Incremental Compilation\n+//! ======================================================\n+//!\n+//! The task of this module is to take the complete set of monomorphizations of\n+//! a crate and produce a set of codegen units from it, where a codegen unit\n+//! is a named set of (mono-item, linkage) pairs. That is, this module\n+//! decides which monomorphization appears in which codegen units with which\n+//! linkage. The following paragraphs describe some of the background on the\n+//! partitioning scheme.\n+//!\n+//! The most important opportunity for saving on compilation time with\n+//! incremental compilation is to avoid re-codegenning and re-optimizing code.\n+//! Since the unit of codegen and optimization for LLVM is \"modules\" or, how\n+//! we call them \"codegen units\", the particulars of how much time can be saved\n+//! by incremental compilation are tightly linked to how the output program is\n+//! partitioned into these codegen units prior to passing it to LLVM --\n+//! especially because we have to treat codegen units as opaque entities once\n+//! they are created: There is no way for us to incrementally update an existing\n+//! LLVM module and so we have to build any such module from scratch if it was\n+//! affected by some change in the source code.\n+//!\n+//! From that point of view it would make sense to maximize the number of\n+//! codegen units by, for example, putting each function into its own module.\n+//! That way only those modules would have to be re-compiled that were actually\n+//! affected by some change, minimizing the number of functions that could have\n+//! been re-used but just happened to be located in a module that is\n+//! re-compiled.\n+//!\n+//! However, since LLVM optimization does not work across module boundaries,\n+//! using such a highly granular partitioning would lead to very slow runtime\n+//! code since it would effectively prohibit inlining and other inter-procedure\n+//! optimizations. We want to avoid that as much as possible.\n+//!\n+//! Thus we end up with a trade-off: The bigger the codegen units, the better\n+//! LLVM's optimizer can do its work, but also the smaller the compilation time\n+//! reduction we get from incremental compilation.\n+//!\n+//! Ideally, we would create a partitioning such that there are few big codegen\n+//! units with few interdependencies between them. For now though, we use the\n+//! following heuristic to determine the partitioning:\n+//!\n+//! - There are two codegen units for every source-level module:\n+//! - One for \"stable\", that is non-generic, code\n+//! - One for more \"volatile\" code, i.e., monomorphized instances of functions\n+//!   defined in that module\n+//!\n+//! In order to see why this heuristic makes sense, let's take a look at when a\n+//! codegen unit can get invalidated:\n+//!\n+//! 1. The most straightforward case is when the BODY of a function or global\n+//! changes. Then any codegen unit containing the code for that item has to be\n+//! re-compiled. Note that this includes all codegen units where the function\n+//! has been inlined.\n+//!\n+//! 2. The next case is when the SIGNATURE of a function or global changes. In\n+//! this case, all codegen units containing a REFERENCE to that item have to be\n+//! re-compiled. This is a superset of case 1.\n+//!\n+//! 3. The final and most subtle case is when a REFERENCE to a generic function\n+//! is added or removed somewhere. Even though the definition of the function\n+//! might be unchanged, a new REFERENCE might introduce a new monomorphized\n+//! instance of this function which has to be placed and compiled somewhere.\n+//! Conversely, when removing a REFERENCE, it might have been the last one with\n+//! that particular set of generic arguments and thus we have to remove it.\n+//!\n+//! From the above we see that just using one codegen unit per source-level\n+//! module is not such a good idea, since just adding a REFERENCE to some\n+//! generic item somewhere else would invalidate everything within the module\n+//! containing the generic item. The heuristic above reduces this detrimental\n+//! side-effect of references a little by at least not touching the non-generic\n+//! code of the module.\n+//!\n+//! A Note on Inlining\n+//! ------------------\n+//! As briefly mentioned above, in order for LLVM to be able to inline a\n+//! function call, the body of the function has to be available in the LLVM\n+//! module where the call is made. This has a few consequences for partitioning:\n+//!\n+//! - The partitioning algorithm has to take care of placing functions into all\n+//!   codegen units where they should be available for inlining. It also has to\n+//!   decide on the correct linkage for these functions.\n+//!\n+//! - The partitioning algorithm has to know which functions are likely to get\n+//!   inlined, so it can distribute function instantiations accordingly. Since\n+//!   there is no way of knowing for sure which functions LLVM will decide to\n+//!   inline in the end, we apply a heuristic here: Only functions marked with\n+//!   `#[inline]` are considered for inlining by the partitioner. The current\n+//!   implementation will not try to determine if a function is likely to be\n+//!   inlined by looking at the functions definition.\n+//!\n+//! Note though that as a side-effect of creating a codegen units per\n+//! source-level module, functions from the same module will be available for\n+//! inlining, even when they are not marked `#[inline]`.\n+\n+use std::cmp;\n+use std::collections::hash_map::Entry;\n+use std::fs::{self, File};\n+use std::io::{BufWriter, Write};\n+use std::path::{Path, PathBuf};\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::sync;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::{DefId, DefIdSet, LOCAL_CRATE};\n+use rustc_hir::definitions::DefPathDataName;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::middle::exported_symbols::{SymbolExportInfo, SymbolExportLevel};\n+use rustc_middle::mir;\n+use rustc_middle::mir::mono::{\n+    CodegenUnit, CodegenUnitNameBuilder, InstantiationMode, Linkage, MonoItem, Visibility,\n+};\n+use rustc_middle::query::Providers;\n+use rustc_middle::ty::print::{characteristic_def_id_of_type, with_no_trimmed_paths};\n+use rustc_middle::ty::{self, visit::TypeVisitableExt, InstanceDef, TyCtxt};\n+use rustc_session::config::{DumpMonoStatsFormat, SwitchWithOptPath};\n+use rustc_span::symbol::Symbol;\n+\n+use crate::collector::InliningMap;\n+use crate::collector::{self, MonoItemCollectionMode};\n+use crate::errors::{CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownCguCollectionMode};\n+\n+struct PartitioningCx<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    target_cgu_count: usize,\n+    inlining_map: &'a InliningMap<'tcx>,\n+}\n+\n+struct PlacedRootMonoItems<'tcx> {\n+    codegen_units: Vec<CodegenUnit<'tcx>>,\n+    roots: FxHashSet<MonoItem<'tcx>>,\n+    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+}\n+\n+fn partition<'tcx, I>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_items: &mut I,\n+    max_cgu_count: usize,\n+    inlining_map: &InliningMap<'tcx>,\n+) -> Vec<CodegenUnit<'tcx>>\n+where\n+    I: Iterator<Item = MonoItem<'tcx>>,\n+{\n+    let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning\");\n+\n+    let cx = &PartitioningCx { tcx, target_cgu_count: max_cgu_count, inlining_map };\n+    // In the first step, we place all regular monomorphizations into their\n+    // respective 'home' codegen unit. Regular monomorphizations are all\n+    // functions and statics defined in the local crate.\n+    let PlacedRootMonoItems { mut codegen_units, roots, internalization_candidates } = {\n+        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n+        place_root_mono_items(cx, mono_items)\n+    };\n+\n+    for cgu in &mut codegen_units {\n+        cgu.create_size_estimate(tcx);\n+    }\n+\n+    debug_dump(tcx, \"INITIAL PARTITIONING\", &codegen_units);\n+\n+    // Merge until we have at most `max_cgu_count` codegen units.\n+    // `merge_codegen_units` is responsible for updating the CGU size\n+    // estimates.\n+    {\n+        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n+        merge_codegen_units(cx, &mut codegen_units);\n+        debug_dump(tcx, \"POST MERGING\", &codegen_units);\n+    }\n+\n+    // In the next step, we use the inlining map to determine which additional\n+    // monomorphizations have to go into each codegen unit. These additional\n+    // monomorphizations can be drop-glue, functions from external crates, and\n+    // local functions the definition of which is marked with `#[inline]`.\n+    let mono_item_placements = {\n+        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n+        place_inlined_mono_items(cx, &mut codegen_units, roots)\n+    };\n+\n+    for cgu in &mut codegen_units {\n+        cgu.create_size_estimate(tcx);\n+    }\n+\n+    debug_dump(tcx, \"POST INLINING\", &codegen_units);\n+\n+    // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n+    // more freedom to optimize.\n+    if !tcx.sess.link_dead_code() {\n+        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n+        internalize_symbols(\n+            cx,\n+            &mut codegen_units,\n+            mono_item_placements,\n+            internalization_candidates,\n+        );\n+    }\n+\n+    let instrument_dead_code =\n+        tcx.sess.instrument_coverage() && !tcx.sess.instrument_coverage_except_unused_functions();\n+\n+    if instrument_dead_code {\n+        assert!(\n+            codegen_units.len() > 0,\n+            \"There must be at least one CGU that code coverage data can be generated in.\"\n+        );\n+\n+        // Find the smallest CGU that has exported symbols and put the dead\n+        // function stubs in that CGU. We look for exported symbols to increase\n+        // the likelihood the linker won't throw away the dead functions.\n+        // FIXME(#92165): In order to truly resolve this, we need to make sure\n+        // the object file (CGU) containing the dead function stubs is included\n+        // in the final binary. This will probably require forcing these\n+        // function symbols to be included via `-u` or `/include` linker args.\n+        let mut cgus: Vec<_> = codegen_units.iter_mut().collect();\n+        cgus.sort_by_key(|cgu| cgu.size_estimate());\n+\n+        let dead_code_cgu =\n+            if let Some(cgu) = cgus.into_iter().rev().find(|cgu| {\n+                cgu.items().iter().any(|(_, (linkage, _))| *linkage == Linkage::External)\n+            }) {\n+                cgu\n+            } else {\n+                // If there are no CGUs that have externally linked items,\n+                // then we just pick the first CGU as a fallback.\n+                &mut codegen_units[0]\n+            };\n+        dead_code_cgu.make_code_coverage_dead_code_cgu();\n+    }\n+\n+    // Finally, sort by codegen unit name, so that we get deterministic results.\n+    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n+\n+    debug_dump(tcx, \"FINAL\", &codegen_units);\n+\n+    codegen_units\n+}\n+\n+fn place_root_mono_items<'tcx, I>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    mono_items: &mut I,\n+) -> PlacedRootMonoItems<'tcx>\n+where\n+    I: Iterator<Item = MonoItem<'tcx>>,\n+{\n+    let mut roots = FxHashSet::default();\n+    let mut codegen_units = FxHashMap::default();\n+    let is_incremental_build = cx.tcx.sess.opts.incremental.is_some();\n+    let mut internalization_candidates = FxHashSet::default();\n+\n+    // Determine if monomorphizations instantiated in this crate will be made\n+    // available to downstream crates. This depends on whether we are in\n+    // share-generics mode and whether the current crate can even have\n+    // downstream crates.\n+    let export_generics =\n+        cx.tcx.sess.opts.share_generics() && cx.tcx.local_crate_exports_generics();\n+\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n+    let cgu_name_cache = &mut FxHashMap::default();\n+\n+    for mono_item in mono_items {\n+        match mono_item.instantiation_mode(cx.tcx) {\n+            InstantiationMode::GloballyShared { .. } => {}\n+            InstantiationMode::LocalCopy => continue,\n+        }\n+\n+        let characteristic_def_id = characteristic_def_id_of_mono_item(cx.tcx, mono_item);\n+        let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n+\n+        let codegen_unit_name = match characteristic_def_id {\n+            Some(def_id) => compute_codegen_unit_name(\n+                cx.tcx,\n+                cgu_name_builder,\n+                def_id,\n+                is_volatile,\n+                cgu_name_cache,\n+            ),\n+            None => fallback_cgu_name(cgu_name_builder),\n+        };\n+\n+        let codegen_unit = codegen_units\n+            .entry(codegen_unit_name)\n+            .or_insert_with(|| CodegenUnit::new(codegen_unit_name));\n+\n+        let mut can_be_internalized = true;\n+        let (linkage, visibility) = mono_item_linkage_and_visibility(\n+            cx.tcx,\n+            &mono_item,\n+            &mut can_be_internalized,\n+            export_generics,\n+        );\n+        if visibility == Visibility::Hidden && can_be_internalized {\n+            internalization_candidates.insert(mono_item);\n+        }\n+\n+        codegen_unit.items_mut().insert(mono_item, (linkage, visibility));\n+        roots.insert(mono_item);\n+    }\n+\n+    // Always ensure we have at least one CGU; otherwise, if we have a\n+    // crate with just types (for example), we could wind up with no CGU.\n+    if codegen_units.is_empty() {\n+        let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n+        codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n+    }\n+\n+    let codegen_units = codegen_units.into_values().collect();\n+    PlacedRootMonoItems { codegen_units, roots, internalization_candidates }\n+}\n+\n+fn merge_codegen_units<'tcx>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n+) {\n+    assert!(cx.target_cgu_count >= 1);\n+\n+    // Note that at this point in time the `codegen_units` here may not be\n+    // in a deterministic order (but we know they're deterministically the\n+    // same set). We want this merging to produce a deterministic ordering\n+    // of codegen units from the input.\n+    //\n+    // Due to basically how we've implemented the merging below (merge the\n+    // two smallest into each other) we're sure to start off with a\n+    // deterministic order (sorted by name). This'll mean that if two cgus\n+    // have the same size the stable sort below will keep everything nice\n+    // and deterministic.\n+    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n+\n+    // This map keeps track of what got merged into what.\n+    let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n+        codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n+\n+    // Merge the two smallest codegen units until the target size is\n+    // reached.\n+    while codegen_units.len() > cx.target_cgu_count {\n+        // Sort small cgus to the back\n+        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n+        let mut smallest = codegen_units.pop().unwrap();\n+        let second_smallest = codegen_units.last_mut().unwrap();\n+\n+        // Move the mono-items from `smallest` to `second_smallest`\n+        second_smallest.modify_size_estimate(smallest.size_estimate());\n+        for (k, v) in smallest.items_mut().drain() {\n+            second_smallest.items_mut().insert(k, v);\n+        }\n+\n+        // Record that `second_smallest` now contains all the stuff that was\n+        // in `smallest` before.\n+        let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n+        cgu_contents.get_mut(&second_smallest.name()).unwrap().append(&mut consumed_cgu_names);\n+\n+        debug!(\n+            \"CodegenUnit {} merged into CodegenUnit {}\",\n+            smallest.name(),\n+            second_smallest.name()\n+        );\n+    }\n+\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n+\n+    if cx.tcx.sess.opts.incremental.is_some() {\n+        // If we are doing incremental compilation, we want CGU names to\n+        // reflect the path of the source level module they correspond to.\n+        // For CGUs that contain the code of multiple modules because of the\n+        // merging done above, we use a concatenation of the names of all\n+        // contained CGUs.\n+        let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n+            .into_iter()\n+            // This `filter` makes sure we only update the name of CGUs that\n+            // were actually modified by merging.\n+            .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n+            .map(|(current_cgu_name, cgu_contents)| {\n+                let mut cgu_contents: Vec<&str> = cgu_contents.iter().map(|s| s.as_str()).collect();\n+\n+                // Sort the names, so things are deterministic and easy to\n+                // predict. We are sorting primitive `&str`s here so we can\n+                // use unstable sort.\n+                cgu_contents.sort_unstable();\n+\n+                (current_cgu_name, cgu_contents.join(\"--\"))\n+            })\n+            .collect();\n+\n+        for cgu in codegen_units.iter_mut() {\n+            if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n+                if cx.tcx.sess.opts.unstable_opts.human_readable_cgu_names {\n+                    cgu.set_name(Symbol::intern(&new_cgu_name));\n+                } else {\n+                    // If we don't require CGU names to be human-readable,\n+                    // we use a fixed length hash of the composite CGU name\n+                    // instead.\n+                    let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n+                    cgu.set_name(Symbol::intern(&new_cgu_name));\n+                }\n+            }\n+        }\n+    } else {\n+        // If we are compiling non-incrementally we just generate simple CGU\n+        // names containing an index.\n+        for (index, cgu) in codegen_units.iter_mut().enumerate() {\n+            let numbered_codegen_unit_name =\n+                cgu_name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index));\n+            cgu.set_name(numbered_codegen_unit_name);\n+        }\n+    }\n+}\n+\n+/// For symbol internalization, we need to know whether a symbol/mono-item is\n+/// accessed from outside the codegen unit it is defined in. This type is used\n+/// to keep track of that.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+enum MonoItemPlacement {\n+    SingleCgu { cgu_name: Symbol },\n+    MultipleCgus,\n+}\n+\n+fn place_inlined_mono_items<'tcx>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    codegen_units: &mut [CodegenUnit<'tcx>],\n+    roots: FxHashSet<MonoItem<'tcx>>,\n+) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n+    let mut mono_item_placements = FxHashMap::default();\n+\n+    let single_codegen_unit = codegen_units.len() == 1;\n+\n+    for old_codegen_unit in codegen_units.iter_mut() {\n+        // Collect all items that need to be available in this codegen unit.\n+        let mut reachable = FxHashSet::default();\n+        for root in old_codegen_unit.items().keys() {\n+            follow_inlining(*root, cx.inlining_map, &mut reachable);\n+        }\n+\n+        let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n+\n+        // Add all monomorphizations that are not already there.\n+        for mono_item in reachable {\n+            if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n+                // This is a root, just copy it over.\n+                new_codegen_unit.items_mut().insert(mono_item, *linkage);\n+            } else {\n+                if roots.contains(&mono_item) {\n+                    bug!(\n+                        \"GloballyShared mono-item inlined into other CGU: \\\n+                          {:?}\",\n+                        mono_item\n+                    );\n+                }\n+\n+                // This is a CGU-private copy.\n+                new_codegen_unit\n+                    .items_mut()\n+                    .insert(mono_item, (Linkage::Internal, Visibility::Default));\n+            }\n+\n+            if !single_codegen_unit {\n+                // If there is more than one codegen unit, we need to keep track\n+                // in which codegen units each monomorphization is placed.\n+                match mono_item_placements.entry(mono_item) {\n+                    Entry::Occupied(e) => {\n+                        let placement = e.into_mut();\n+                        debug_assert!(match *placement {\n+                            MonoItemPlacement::SingleCgu { cgu_name } => {\n+                                cgu_name != new_codegen_unit.name()\n+                            }\n+                            MonoItemPlacement::MultipleCgus => true,\n+                        });\n+                        *placement = MonoItemPlacement::MultipleCgus;\n+                    }\n+                    Entry::Vacant(e) => {\n+                        e.insert(MonoItemPlacement::SingleCgu {\n+                            cgu_name: new_codegen_unit.name(),\n+                        });\n+                    }\n+                }\n+            }\n+        }\n+\n+        *old_codegen_unit = new_codegen_unit;\n+    }\n+\n+    return mono_item_placements;\n+\n+    fn follow_inlining<'tcx>(\n+        mono_item: MonoItem<'tcx>,\n+        inlining_map: &InliningMap<'tcx>,\n+        visited: &mut FxHashSet<MonoItem<'tcx>>,\n+    ) {\n+        if !visited.insert(mono_item) {\n+            return;\n+        }\n+\n+        inlining_map.with_inlining_candidates(mono_item, |target| {\n+            follow_inlining(target, inlining_map, visited);\n+        });\n+    }\n+}\n+\n+fn internalize_symbols<'tcx>(\n+    cx: &PartitioningCx<'_, 'tcx>,\n+    codegen_units: &mut [CodegenUnit<'tcx>],\n+    mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n+    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+) {\n+    if codegen_units.len() == 1 {\n+        // Fast path for when there is only one codegen unit. In this case we\n+        // can internalize all candidates, since there is nowhere else they\n+        // could be accessed from.\n+        for cgu in codegen_units {\n+            for candidate in &internalization_candidates {\n+                cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    // Build a map from every monomorphization to all the monomorphizations that\n+    // reference it.\n+    let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n+    cx.inlining_map.iter_accesses(|accessor, accessees| {\n+        for accessee in accessees {\n+            accessor_map.entry(*accessee).or_default().push(accessor);\n+        }\n+    });\n+\n+    // For each internalization candidates in each codegen unit, check if it is\n+    // accessed from outside its defining codegen unit.\n+    for cgu in codegen_units {\n+        let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n+\n+        for (accessee, linkage_and_visibility) in cgu.items_mut() {\n+            if !internalization_candidates.contains(accessee) {\n+                // This item is no candidate for internalizing, so skip it.\n+                continue;\n+            }\n+            debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n+\n+            if let Some(accessors) = accessor_map.get(accessee) {\n+                if accessors\n+                    .iter()\n+                    .filter_map(|accessor| {\n+                        // Some accessors might not have been\n+                        // instantiated. We can safely ignore those.\n+                        mono_item_placements.get(accessor)\n+                    })\n+                    .any(|placement| *placement != home_cgu)\n+                {\n+                    // Found an accessor from another CGU, so skip to the next\n+                    // item without marking this one as internal.\n+                    continue;\n+                }\n+            }\n+\n+            // If we got here, we did not find any accesses from other CGUs,\n+            // so it's fine to make this monomorphization internal.\n+            *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n+        }\n+    }\n+}\n+\n+fn characteristic_def_id_of_mono_item<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: MonoItem<'tcx>,\n+) -> Option<DefId> {\n+    match mono_item {\n+        MonoItem::Fn(instance) => {\n+            let def_id = match instance.def {\n+                ty::InstanceDef::Item(def) => def,\n+                ty::InstanceDef::VTableShim(..)\n+                | ty::InstanceDef::ReifyShim(..)\n+                | ty::InstanceDef::FnPtrShim(..)\n+                | ty::InstanceDef::ClosureOnceShim { .. }\n+                | ty::InstanceDef::Intrinsic(..)\n+                | ty::InstanceDef::DropGlue(..)\n+                | ty::InstanceDef::Virtual(..)\n+                | ty::InstanceDef::CloneShim(..)\n+                | ty::InstanceDef::ThreadLocalShim(..)\n+                | ty::InstanceDef::FnPtrAddrShim(..) => return None,\n+            };\n+\n+            // If this is a method, we want to put it into the same module as\n+            // its self-type. If the self-type does not provide a characteristic\n+            // DefId, we use the location of the impl after all.\n+\n+            if tcx.trait_of_item(def_id).is_some() {\n+                let self_ty = instance.substs.type_at(0);\n+                // This is a default implementation of a trait method.\n+                return characteristic_def_id_of_type(self_ty).or(Some(def_id));\n+            }\n+\n+            if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n+                if tcx.sess.opts.incremental.is_some()\n+                    && tcx.trait_id_of_impl(impl_def_id) == tcx.lang_items().drop_trait()\n+                {\n+                    // Put `Drop::drop` into the same cgu as `drop_in_place`\n+                    // since `drop_in_place` is the only thing that can\n+                    // call it.\n+                    return None;\n+                }\n+\n+                // When polymorphization is enabled, methods which do not depend on their generic\n+                // parameters, but the self-type of their impl block do will fail to normalize.\n+                if !tcx.sess.opts.unstable_opts.polymorphize || !instance.has_param() {\n+                    // This is a method within an impl, find out what the self-type is:\n+                    let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n+                        instance.substs,\n+                        ty::ParamEnv::reveal_all(),\n+                        tcx.type_of(impl_def_id),\n+                    );\n+                    if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n+                        return Some(def_id);\n+                    }\n+                }\n+            }\n+\n+            Some(def_id)\n+        }\n+        MonoItem::Static(def_id) => Some(def_id),\n+        MonoItem::GlobalAsm(item_id) => Some(item_id.owner_id.to_def_id()),\n+    }\n+}\n+\n+fn compute_codegen_unit_name(\n+    tcx: TyCtxt<'_>,\n+    name_builder: &mut CodegenUnitNameBuilder<'_>,\n+    def_id: DefId,\n+    volatile: bool,\n+    cache: &mut CguNameCache,\n+) -> Symbol {\n+    // Find the innermost module that is not nested within a function.\n+    let mut current_def_id = def_id;\n+    let mut cgu_def_id = None;\n+    // Walk backwards from the item we want to find the module for.\n+    loop {\n+        if current_def_id.is_crate_root() {\n+            if cgu_def_id.is_none() {\n+                // If we have not found a module yet, take the crate root.\n+                cgu_def_id = Some(def_id.krate.as_def_id());\n+            }\n+            break;\n+        } else if tcx.def_kind(current_def_id) == DefKind::Mod {\n+            if cgu_def_id.is_none() {\n+                cgu_def_id = Some(current_def_id);\n+            }\n+        } else {\n+            // If we encounter something that is not a module, throw away\n+            // any module that we've found so far because we now know that\n+            // it is nested within something else.\n+            cgu_def_id = None;\n+        }\n+\n+        current_def_id = tcx.parent(current_def_id);\n+    }\n+\n+    let cgu_def_id = cgu_def_id.unwrap();\n+\n+    *cache.entry((cgu_def_id, volatile)).or_insert_with(|| {\n+        let def_path = tcx.def_path(cgu_def_id);\n+\n+        let components = def_path.data.iter().map(|part| match part.data.name() {\n+            DefPathDataName::Named(name) => name,\n+            DefPathDataName::Anon { .. } => unreachable!(),\n+        });\n+\n+        let volatile_suffix = volatile.then_some(\"volatile\");\n+\n+        name_builder.build_cgu_name(def_path.krate, components, volatile_suffix)\n+    })\n+}\n+\n+// Anything we can't find a proper codegen unit for goes into this.\n+fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> Symbol {\n+    name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n+}\n+\n+fn mono_item_linkage_and_visibility<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: &MonoItem<'tcx>,\n+    can_be_internalized: &mut bool,\n+    export_generics: bool,\n+) -> (Linkage, Visibility) {\n+    if let Some(explicit_linkage) = mono_item.explicit_linkage(tcx) {\n+        return (explicit_linkage, Visibility::Default);\n+    }\n+    let vis = mono_item_visibility(tcx, mono_item, can_be_internalized, export_generics);\n+    (Linkage::External, vis)\n+}\n+\n+type CguNameCache = FxHashMap<(DefId, bool), Symbol>;\n+\n+fn static_visibility<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    can_be_internalized: &mut bool,\n+    def_id: DefId,\n+) -> Visibility {\n+    if tcx.is_reachable_non_generic(def_id) {\n+        *can_be_internalized = false;\n+        default_visibility(tcx, def_id, false)\n+    } else {\n+        Visibility::Hidden\n+    }\n+}\n+\n+fn mono_item_visibility<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: &MonoItem<'tcx>,\n+    can_be_internalized: &mut bool,\n+    export_generics: bool,\n+) -> Visibility {\n+    let instance = match mono_item {\n+        // This is pretty complicated; see below.\n+        MonoItem::Fn(instance) => instance,\n+\n+        // Misc handling for generics and such, but otherwise:\n+        MonoItem::Static(def_id) => return static_visibility(tcx, can_be_internalized, *def_id),\n+        MonoItem::GlobalAsm(item_id) => {\n+            return static_visibility(tcx, can_be_internalized, item_id.owner_id.to_def_id());\n+        }\n+    };\n+\n+    let def_id = match instance.def {\n+        InstanceDef::Item(def_id) | InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n+\n+        // We match the visibility of statics here\n+        InstanceDef::ThreadLocalShim(def_id) => {\n+            return static_visibility(tcx, can_be_internalized, def_id);\n+        }\n+\n+        // These are all compiler glue and such, never exported, always hidden.\n+        InstanceDef::VTableShim(..)\n+        | InstanceDef::ReifyShim(..)\n+        | InstanceDef::FnPtrShim(..)\n+        | InstanceDef::Virtual(..)\n+        | InstanceDef::Intrinsic(..)\n+        | InstanceDef::ClosureOnceShim { .. }\n+        | InstanceDef::DropGlue(..)\n+        | InstanceDef::CloneShim(..)\n+        | InstanceDef::FnPtrAddrShim(..) => return Visibility::Hidden,\n+    };\n+\n+    // The `start_fn` lang item is actually a monomorphized instance of a\n+    // function in the standard library, used for the `main` function. We don't\n+    // want to export it so we tag it with `Hidden` visibility but this symbol\n+    // is only referenced from the actual `main` symbol which we unfortunately\n+    // don't know anything about during partitioning/collection. As a result we\n+    // forcibly keep this symbol out of the `internalization_candidates` set.\n+    //\n+    // FIXME: eventually we don't want to always force this symbol to have\n+    //        hidden visibility, it should indeed be a candidate for\n+    //        internalization, but we have to understand that it's referenced\n+    //        from the `main` symbol we'll generate later.\n+    //\n+    //        This may be fixable with a new `InstanceDef` perhaps? Unsure!\n+    if tcx.lang_items().start_fn() == Some(def_id) {\n+        *can_be_internalized = false;\n+        return Visibility::Hidden;\n+    }\n+\n+    let is_generic = instance.substs.non_erasable_generics().next().is_some();\n+\n+    // Upstream `DefId` instances get different handling than local ones.\n+    let Some(def_id) = def_id.as_local() else {\n+        return if export_generics && is_generic {\n+            // If it is an upstream monomorphization and we export generics, we must make\n+            // it available to downstream crates.\n+            *can_be_internalized = false;\n+            default_visibility(tcx, def_id, true)\n+        } else {\n+            Visibility::Hidden\n+        };\n+    };\n+\n+    if is_generic {\n+        if export_generics {\n+            if tcx.is_unreachable_local_definition(def_id) {\n+                // This instance cannot be used from another crate.\n+                Visibility::Hidden\n+            } else {\n+                // This instance might be useful in a downstream crate.\n+                *can_be_internalized = false;\n+                default_visibility(tcx, def_id.to_def_id(), true)\n+            }\n+        } else {\n+            // We are not exporting generics or the definition is not reachable\n+            // for downstream crates, we can internalize its instantiations.\n+            Visibility::Hidden\n+        }\n+    } else {\n+        // If this isn't a generic function then we mark this a `Default` if\n+        // this is a reachable item, meaning that it's a symbol other crates may\n+        // access when they link to us.\n+        if tcx.is_reachable_non_generic(def_id.to_def_id()) {\n+            *can_be_internalized = false;\n+            debug_assert!(!is_generic);\n+            return default_visibility(tcx, def_id.to_def_id(), false);\n+        }\n+\n+        // If this isn't reachable then we're gonna tag this with `Hidden`\n+        // visibility. In some situations though we'll want to prevent this\n+        // symbol from being internalized.\n+        //\n+        // There's two categories of items here:\n+        //\n+        // * First is weak lang items. These are basically mechanisms for\n+        //   libcore to forward-reference symbols defined later in crates like\n+        //   the standard library or `#[panic_handler]` definitions. The\n+        //   definition of these weak lang items needs to be referencable by\n+        //   libcore, so we're no longer a candidate for internalization.\n+        //   Removal of these functions can't be done by LLVM but rather must be\n+        //   done by the linker as it's a non-local decision.\n+        //\n+        // * Second is \"std internal symbols\". Currently this is primarily used\n+        //   for allocator symbols. Allocators are a little weird in their\n+        //   implementation, but the idea is that the compiler, at the last\n+        //   minute, defines an allocator with an injected object file. The\n+        //   `alloc` crate references these symbols (`__rust_alloc`) and the\n+        //   definition doesn't get hooked up until a linked crate artifact is\n+        //   generated.\n+        //\n+        //   The symbols synthesized by the compiler (`__rust_alloc`) are thin\n+        //   veneers around the actual implementation, some other symbol which\n+        //   implements the same ABI. These symbols (things like `__rg_alloc`,\n+        //   `__rdl_alloc`, `__rde_alloc`, etc), are all tagged with \"std\n+        //   internal symbols\".\n+        //\n+        //   The std-internal symbols here **should not show up in a dll as an\n+        //   exported interface**, so they return `false` from\n+        //   `is_reachable_non_generic` above and we'll give them `Hidden`\n+        //   visibility below. Like the weak lang items, though, we can't let\n+        //   LLVM internalize them as this decision is left up to the linker to\n+        //   omit them, so prevent them from being internalized.\n+        let attrs = tcx.codegen_fn_attrs(def_id);\n+        if attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n+            *can_be_internalized = false;\n+        }\n+\n+        Visibility::Hidden\n+    }\n+}\n+\n+fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibility {\n+    if !tcx.sess.target.default_hidden_visibility {\n+        return Visibility::Default;\n+    }\n+\n+    // Generic functions never have export-level C.\n+    if is_generic {\n+        return Visibility::Hidden;\n+    }\n+\n+    // Things with export level C don't get instantiated in\n+    // downstream crates.\n+    if !id.is_local() {\n+        return Visibility::Hidden;\n+    }\n+\n+    // C-export level items remain at `Default`, all other internal\n+    // items become `Hidden`.\n+    match tcx.reachable_non_generics(id.krate).get(&id) {\n+        Some(SymbolExportInfo { level: SymbolExportLevel::C, .. }) => Visibility::Default,\n+        _ => Visibility::Hidden,\n+    }\n+}\n+fn debug_dump<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx>, label: &str, cgus: &[CodegenUnit<'tcx>]) {\n+    let dump = move || {\n+        use std::fmt::Write;\n+\n+        let num_cgus = cgus.len();\n+        let max = cgus.iter().map(|cgu| cgu.size_estimate()).max().unwrap();\n+        let min = cgus.iter().map(|cgu| cgu.size_estimate()).min().unwrap();\n+        let ratio = max as f64 / min as f64;\n+\n+        let s = &mut String::new();\n+        let _ = writeln!(\n+            s,\n+            \"{label} ({num_cgus} CodegenUnits, max={max}, min={min}, max/min={ratio:.1}):\"\n+        );\n+        for cgu in cgus {\n+            let _ =\n+                writeln!(s, \"CodegenUnit {} estimated size {}:\", cgu.name(), cgu.size_estimate());\n+\n+            for (mono_item, linkage) in cgu.items() {\n+                let symbol_name = mono_item.symbol_name(tcx).name;\n+                let symbol_hash_start = symbol_name.rfind('h');\n+                let symbol_hash = symbol_hash_start.map_or(\"<no hash>\", |i| &symbol_name[i..]);\n+\n+                let _ = with_no_trimmed_paths!(writeln!(\n+                    s,\n+                    \" - {} [{:?}] [{}] estimated size {}\",\n+                    mono_item,\n+                    linkage,\n+                    symbol_hash,\n+                    mono_item.size_estimate(tcx)\n+                ));\n+            }\n+\n+            let _ = writeln!(s);\n+        }\n+\n+        std::mem::take(s)\n+    };\n+\n+    debug!(\"{}\", dump());\n+}\n+\n+#[inline(never)] // give this a place in the profiler\n+fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'tcx>, mono_items: I)\n+where\n+    I: Iterator<Item = &'a MonoItem<'tcx>>,\n+    'tcx: 'a,\n+{\n+    let _prof_timer = tcx.prof.generic_activity(\"assert_symbols_are_distinct\");\n+\n+    let mut symbols: Vec<_> =\n+        mono_items.map(|mono_item| (mono_item, mono_item.symbol_name(tcx))).collect();\n+\n+    symbols.sort_by_key(|sym| sym.1);\n+\n+    for &[(mono_item1, ref sym1), (mono_item2, ref sym2)] in symbols.array_windows() {\n+        if sym1 == sym2 {\n+            let span1 = mono_item1.local_span(tcx);\n+            let span2 = mono_item2.local_span(tcx);\n+\n+            // Deterministically select one of the spans for error reporting\n+            let span = match (span1, span2) {\n+                (Some(span1), Some(span2)) => {\n+                    Some(if span1.lo().0 > span2.lo().0 { span1 } else { span2 })\n+                }\n+                (span1, span2) => span1.or(span2),\n+            };\n+\n+            tcx.sess.emit_fatal(SymbolAlreadyDefined { span, symbol: sym1.to_string() });\n+        }\n+    }\n+}\n+\n+fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[CodegenUnit<'_>]) {\n+    let collection_mode = match tcx.sess.opts.unstable_opts.print_mono_items {\n+        Some(ref s) => {\n+            let mode = s.to_lowercase();\n+            let mode = mode.trim();\n+            if mode == \"eager\" {\n+                MonoItemCollectionMode::Eager\n+            } else {\n+                if mode != \"lazy\" {\n+                    tcx.sess.emit_warning(UnknownCguCollectionMode { mode });\n+                }\n+\n+                MonoItemCollectionMode::Lazy\n+            }\n+        }\n+        None => {\n+            if tcx.sess.link_dead_code() {\n+                MonoItemCollectionMode::Eager\n+            } else {\n+                MonoItemCollectionMode::Lazy\n+            }\n+        }\n+    };\n+\n+    let (items, inlining_map) = collector::collect_crate_mono_items(tcx, collection_mode);\n+\n+    tcx.sess.abort_if_errors();\n+\n+    let (codegen_units, _) = tcx.sess.time(\"partition_and_assert_distinct_symbols\", || {\n+        sync::join(\n+            || {\n+                let mut codegen_units = partition(\n+                    tcx,\n+                    &mut items.iter().copied(),\n+                    tcx.sess.codegen_units(),\n+                    &inlining_map,\n+                );\n+                codegen_units[0].make_primary();\n+                &*tcx.arena.alloc_from_iter(codegen_units)\n+            },\n+            || assert_symbols_are_distinct(tcx, items.iter()),\n+        )\n+    });\n+\n+    if tcx.prof.enabled() {\n+        // Record CGU size estimates for self-profiling.\n+        for cgu in codegen_units {\n+            tcx.prof.artifact_size(\n+                \"codegen_unit_size_estimate\",\n+                cgu.name().as_str(),\n+                cgu.size_estimate() as u64,\n+            );\n+        }\n+    }\n+\n+    let mono_items: DefIdSet = items\n+        .iter()\n+        .filter_map(|mono_item| match *mono_item {\n+            MonoItem::Fn(ref instance) => Some(instance.def_id()),\n+            MonoItem::Static(def_id) => Some(def_id),\n+            _ => None,\n+        })\n+        .collect();\n+\n+    // Output monomorphization stats per def_id\n+    if let SwitchWithOptPath::Enabled(ref path) = tcx.sess.opts.unstable_opts.dump_mono_stats {\n+        if let Err(err) =\n+            dump_mono_items_stats(tcx, &codegen_units, path, tcx.crate_name(LOCAL_CRATE))\n+        {\n+            tcx.sess.emit_fatal(CouldntDumpMonoStats { error: err.to_string() });\n+        }\n+    }\n+\n+    if tcx.sess.opts.unstable_opts.print_mono_items.is_some() {\n+        let mut item_to_cgus: FxHashMap<_, Vec<_>> = Default::default();\n+\n+        for cgu in codegen_units {\n+            for (&mono_item, &linkage) in cgu.items() {\n+                item_to_cgus.entry(mono_item).or_default().push((cgu.name(), linkage));\n+            }\n+        }\n+\n+        let mut item_keys: Vec<_> = items\n+            .iter()\n+            .map(|i| {\n+                let mut output = with_no_trimmed_paths!(i.to_string());\n+                output.push_str(\" @@\");\n+                let mut empty = Vec::new();\n+                let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n+                cgus.sort_by_key(|(name, _)| *name);\n+                cgus.dedup();\n+                for &(ref cgu_name, (linkage, _)) in cgus.iter() {\n+                    output.push(' ');\n+                    output.push_str(cgu_name.as_str());\n+\n+                    let linkage_abbrev = match linkage {\n+                        Linkage::External => \"External\",\n+                        Linkage::AvailableExternally => \"Available\",\n+                        Linkage::LinkOnceAny => \"OnceAny\",\n+                        Linkage::LinkOnceODR => \"OnceODR\",\n+                        Linkage::WeakAny => \"WeakAny\",\n+                        Linkage::WeakODR => \"WeakODR\",\n+                        Linkage::Appending => \"Appending\",\n+                        Linkage::Internal => \"Internal\",\n+                        Linkage::Private => \"Private\",\n+                        Linkage::ExternalWeak => \"ExternalWeak\",\n+                        Linkage::Common => \"Common\",\n+                    };\n+\n+                    output.push('[');\n+                    output.push_str(linkage_abbrev);\n+                    output.push(']');\n+                }\n+                output\n+            })\n+            .collect();\n+\n+        item_keys.sort();\n+\n+        for item in item_keys {\n+            println!(\"MONO_ITEM {item}\");\n+        }\n+    }\n+\n+    (tcx.arena.alloc(mono_items), codegen_units)\n+}\n+\n+/// Outputs stats about instantiation counts and estimated size, per `MonoItem`'s\n+/// def, to a file in the given output directory.\n+fn dump_mono_items_stats<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    codegen_units: &[CodegenUnit<'tcx>],\n+    output_directory: &Option<PathBuf>,\n+    crate_name: Symbol,\n+) -> Result<(), Box<dyn std::error::Error>> {\n+    let output_directory = if let Some(ref directory) = output_directory {\n+        fs::create_dir_all(directory)?;\n+        directory\n+    } else {\n+        Path::new(\".\")\n+    };\n+\n+    let format = tcx.sess.opts.unstable_opts.dump_mono_stats_format;\n+    let ext = format.extension();\n+    let filename = format!(\"{crate_name}.mono_items.{ext}\");\n+    let output_path = output_directory.join(&filename);\n+    let file = File::create(&output_path)?;\n+    let mut file = BufWriter::new(file);\n+\n+    // Gather instantiated mono items grouped by def_id\n+    let mut items_per_def_id: FxHashMap<_, Vec<_>> = Default::default();\n+    for cgu in codegen_units {\n+        for (&mono_item, _) in cgu.items() {\n+            // Avoid variable-sized compiler-generated shims\n+            if mono_item.is_user_defined() {\n+                items_per_def_id.entry(mono_item.def_id()).or_default().push(mono_item);\n+            }\n+        }\n+    }\n+\n+    #[derive(serde::Serialize)]\n+    struct MonoItem {\n+        name: String,\n+        instantiation_count: usize,\n+        size_estimate: usize,\n+        total_estimate: usize,\n+    }\n+\n+    // Output stats sorted by total instantiated size, from heaviest to lightest\n+    let mut stats: Vec<_> = items_per_def_id\n+        .into_iter()\n+        .map(|(def_id, items)| {\n+            let name = with_no_trimmed_paths!(tcx.def_path_str(def_id));\n+            let instantiation_count = items.len();\n+            let size_estimate = items[0].size_estimate(tcx);\n+            let total_estimate = instantiation_count * size_estimate;\n+            MonoItem { name, instantiation_count, size_estimate, total_estimate }\n+        })\n+        .collect();\n+    stats.sort_unstable_by_key(|item| cmp::Reverse(item.total_estimate));\n+\n+    if !stats.is_empty() {\n+        match format {\n+            DumpMonoStatsFormat::Json => serde_json::to_writer(file, &stats)?,\n+            DumpMonoStatsFormat::Markdown => {\n+                writeln!(\n+                    file,\n+                    \"| Item | Instantiation count | Estimated Cost Per Instantiation | Total Estimated Cost |\"\n+                )?;\n+                writeln!(file, \"| --- | ---: | ---: | ---: |\")?;\n+\n+                for MonoItem { name, instantiation_count, size_estimate, total_estimate } in stats {\n+                    writeln!(\n+                        file,\n+                        \"| `{name}` | {instantiation_count} | {size_estimate} | {total_estimate} |\"\n+                    )?;\n+                }\n+            }\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn codegened_and_inlined_items(tcx: TyCtxt<'_>, (): ()) -> &DefIdSet {\n+    let (items, cgus) = tcx.collect_and_partition_mono_items(());\n+    let mut visited = DefIdSet::default();\n+    let mut result = items.clone();\n+\n+    for cgu in cgus {\n+        for (item, _) in cgu.items() {\n+            if let MonoItem::Fn(ref instance) = item {\n+                let did = instance.def_id();\n+                if !visited.insert(did) {\n+                    continue;\n+                }\n+                let body = tcx.instance_mir(instance.def);\n+                for block in body.basic_blocks.iter() {\n+                    for statement in &block.statements {\n+                        let mir::StatementKind::Coverage(_) = statement.kind else { continue };\n+                        let scope = statement.source_info.scope;\n+                        if let Some(inlined) = scope.inlined_instance(&body.source_scopes) {\n+                            result.insert(inlined.def_id());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    tcx.arena.alloc(result)\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    providers.collect_and_partition_mono_items = collect_and_partition_mono_items;\n+    providers.codegened_and_inlined_items = codegened_and_inlined_items;\n+\n+    providers.is_codegened_item = |tcx, def_id| {\n+        let (all_mono_items, _) = tcx.collect_and_partition_mono_items(());\n+        all_mono_items.contains(&def_id)\n+    };\n+\n+    providers.codegen_unit = |tcx, name| {\n+        let (_, all) = tcx.collect_and_partition_mono_items(());\n+        all.iter()\n+            .find(|cgu| cgu.name() == name)\n+            .unwrap_or_else(|| panic!(\"failed to find cgu with name {name:?}\"))\n+    };\n+}"}, {"sha": "603b3ddc106e931ea2864506243a43b35fd9e819", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "removed", "additions": 0, "deletions": 644, "changes": 644, "blob_url": "https://github.com/rust-lang/rust/blob/f51fca3af344686d734c3ff6b4399642c4f92305/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51fca3af344686d734c3ff6b4399642c4f92305/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=f51fca3af344686d734c3ff6b4399642c4f92305", "patch": "@@ -1,644 +0,0 @@\n-use std::cmp;\n-use std::collections::hash_map::Entry;\n-\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::definitions::DefPathDataName;\n-use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use rustc_middle::middle::exported_symbols::{SymbolExportInfo, SymbolExportLevel};\n-use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder, Linkage, Visibility};\n-use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n-use rustc_middle::ty::print::characteristic_def_id_of_type;\n-use rustc_middle::ty::{self, visit::TypeVisitableExt, InstanceDef, TyCtxt};\n-use rustc_span::symbol::Symbol;\n-\n-use super::PartitioningCx;\n-use crate::collector::InliningMap;\n-use crate::partitioning::{MonoItemPlacement, Partition, PlacedRootMonoItems};\n-\n-pub struct DefaultPartitioning;\n-\n-impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n-    fn place_root_mono_items<I>(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        mono_items: &mut I,\n-    ) -> PlacedRootMonoItems<'tcx>\n-    where\n-        I: Iterator<Item = MonoItem<'tcx>>,\n-    {\n-        let mut roots = FxHashSet::default();\n-        let mut codegen_units = FxHashMap::default();\n-        let is_incremental_build = cx.tcx.sess.opts.incremental.is_some();\n-        let mut internalization_candidates = FxHashSet::default();\n-\n-        // Determine if monomorphizations instantiated in this crate will be made\n-        // available to downstream crates. This depends on whether we are in\n-        // share-generics mode and whether the current crate can even have\n-        // downstream crates.\n-        let export_generics =\n-            cx.tcx.sess.opts.share_generics() && cx.tcx.local_crate_exports_generics();\n-\n-        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n-        let cgu_name_cache = &mut FxHashMap::default();\n-\n-        for mono_item in mono_items {\n-            match mono_item.instantiation_mode(cx.tcx) {\n-                InstantiationMode::GloballyShared { .. } => {}\n-                InstantiationMode::LocalCopy => continue,\n-            }\n-\n-            let characteristic_def_id = characteristic_def_id_of_mono_item(cx.tcx, mono_item);\n-            let is_volatile = is_incremental_build && mono_item.is_generic_fn();\n-\n-            let codegen_unit_name = match characteristic_def_id {\n-                Some(def_id) => compute_codegen_unit_name(\n-                    cx.tcx,\n-                    cgu_name_builder,\n-                    def_id,\n-                    is_volatile,\n-                    cgu_name_cache,\n-                ),\n-                None => fallback_cgu_name(cgu_name_builder),\n-            };\n-\n-            let codegen_unit = codegen_units\n-                .entry(codegen_unit_name)\n-                .or_insert_with(|| CodegenUnit::new(codegen_unit_name));\n-\n-            let mut can_be_internalized = true;\n-            let (linkage, visibility) = mono_item_linkage_and_visibility(\n-                cx.tcx,\n-                &mono_item,\n-                &mut can_be_internalized,\n-                export_generics,\n-            );\n-            if visibility == Visibility::Hidden && can_be_internalized {\n-                internalization_candidates.insert(mono_item);\n-            }\n-\n-            codegen_unit.items_mut().insert(mono_item, (linkage, visibility));\n-            roots.insert(mono_item);\n-        }\n-\n-        // Always ensure we have at least one CGU; otherwise, if we have a\n-        // crate with just types (for example), we could wind up with no CGU.\n-        if codegen_units.is_empty() {\n-            let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n-            codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n-        }\n-\n-        let codegen_units = codegen_units.into_values().collect();\n-        PlacedRootMonoItems { codegen_units, roots, internalization_candidates }\n-    }\n-\n-    fn merge_codegen_units(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n-    ) {\n-        assert!(cx.target_cgu_count >= 1);\n-\n-        // Note that at this point in time the `codegen_units` here may not be\n-        // in a deterministic order (but we know they're deterministically the\n-        // same set). We want this merging to produce a deterministic ordering\n-        // of codegen units from the input.\n-        //\n-        // Due to basically how we've implemented the merging below (merge the\n-        // two smallest into each other) we're sure to start off with a\n-        // deterministic order (sorted by name). This'll mean that if two cgus\n-        // have the same size the stable sort below will keep everything nice\n-        // and deterministic.\n-        codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n-\n-        // This map keeps track of what got merged into what.\n-        let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n-            codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n-\n-        // Merge the two smallest codegen units until the target size is\n-        // reached.\n-        while codegen_units.len() > cx.target_cgu_count {\n-            // Sort small cgus to the back\n-            codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n-            let mut smallest = codegen_units.pop().unwrap();\n-            let second_smallest = codegen_units.last_mut().unwrap();\n-\n-            // Move the mono-items from `smallest` to `second_smallest`\n-            second_smallest.modify_size_estimate(smallest.size_estimate());\n-            for (k, v) in smallest.items_mut().drain() {\n-                second_smallest.items_mut().insert(k, v);\n-            }\n-\n-            // Record that `second_smallest` now contains all the stuff that was\n-            // in `smallest` before.\n-            let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n-            cgu_contents.get_mut(&second_smallest.name()).unwrap().append(&mut consumed_cgu_names);\n-\n-            debug!(\n-                \"CodegenUnit {} merged into CodegenUnit {}\",\n-                smallest.name(),\n-                second_smallest.name()\n-            );\n-        }\n-\n-        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n-\n-        if cx.tcx.sess.opts.incremental.is_some() {\n-            // If we are doing incremental compilation, we want CGU names to\n-            // reflect the path of the source level module they correspond to.\n-            // For CGUs that contain the code of multiple modules because of the\n-            // merging done above, we use a concatenation of the names of all\n-            // contained CGUs.\n-            let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n-                .into_iter()\n-                // This `filter` makes sure we only update the name of CGUs that\n-                // were actually modified by merging.\n-                .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n-                .map(|(current_cgu_name, cgu_contents)| {\n-                    let mut cgu_contents: Vec<&str> =\n-                        cgu_contents.iter().map(|s| s.as_str()).collect();\n-\n-                    // Sort the names, so things are deterministic and easy to\n-                    // predict. We are sorting primitive `&str`s here so we can\n-                    // use unstable sort.\n-                    cgu_contents.sort_unstable();\n-\n-                    (current_cgu_name, cgu_contents.join(\"--\"))\n-                })\n-                .collect();\n-\n-            for cgu in codegen_units.iter_mut() {\n-                if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n-                    if cx.tcx.sess.opts.unstable_opts.human_readable_cgu_names {\n-                        cgu.set_name(Symbol::intern(&new_cgu_name));\n-                    } else {\n-                        // If we don't require CGU names to be human-readable,\n-                        // we use a fixed length hash of the composite CGU name\n-                        // instead.\n-                        let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n-                        cgu.set_name(Symbol::intern(&new_cgu_name));\n-                    }\n-                }\n-            }\n-        } else {\n-            // If we are compiling non-incrementally we just generate simple CGU\n-            // names containing an index.\n-            for (index, cgu) in codegen_units.iter_mut().enumerate() {\n-                let numbered_codegen_unit_name =\n-                    cgu_name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index));\n-                cgu.set_name(numbered_codegen_unit_name);\n-            }\n-        }\n-    }\n-\n-    fn place_inlined_mono_items(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        roots: FxHashSet<MonoItem<'tcx>>,\n-    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n-        let mut mono_item_placements = FxHashMap::default();\n-\n-        let single_codegen_unit = codegen_units.len() == 1;\n-\n-        for old_codegen_unit in codegen_units.iter_mut() {\n-            // Collect all items that need to be available in this codegen unit.\n-            let mut reachable = FxHashSet::default();\n-            for root in old_codegen_unit.items().keys() {\n-                follow_inlining(*root, cx.inlining_map, &mut reachable);\n-            }\n-\n-            let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n-\n-            // Add all monomorphizations that are not already there.\n-            for mono_item in reachable {\n-                if let Some(linkage) = old_codegen_unit.items().get(&mono_item) {\n-                    // This is a root, just copy it over.\n-                    new_codegen_unit.items_mut().insert(mono_item, *linkage);\n-                } else {\n-                    if roots.contains(&mono_item) {\n-                        bug!(\n-                            \"GloballyShared mono-item inlined into other CGU: \\\n-                              {:?}\",\n-                            mono_item\n-                        );\n-                    }\n-\n-                    // This is a CGU-private copy.\n-                    new_codegen_unit\n-                        .items_mut()\n-                        .insert(mono_item, (Linkage::Internal, Visibility::Default));\n-                }\n-\n-                if !single_codegen_unit {\n-                    // If there is more than one codegen unit, we need to keep track\n-                    // in which codegen units each monomorphization is placed.\n-                    match mono_item_placements.entry(mono_item) {\n-                        Entry::Occupied(e) => {\n-                            let placement = e.into_mut();\n-                            debug_assert!(match *placement {\n-                                MonoItemPlacement::SingleCgu { cgu_name } => {\n-                                    cgu_name != new_codegen_unit.name()\n-                                }\n-                                MonoItemPlacement::MultipleCgus => true,\n-                            });\n-                            *placement = MonoItemPlacement::MultipleCgus;\n-                        }\n-                        Entry::Vacant(e) => {\n-                            e.insert(MonoItemPlacement::SingleCgu {\n-                                cgu_name: new_codegen_unit.name(),\n-                            });\n-                        }\n-                    }\n-                }\n-            }\n-\n-            *old_codegen_unit = new_codegen_unit;\n-        }\n-\n-        return mono_item_placements;\n-\n-        fn follow_inlining<'tcx>(\n-            mono_item: MonoItem<'tcx>,\n-            inlining_map: &InliningMap<'tcx>,\n-            visited: &mut FxHashSet<MonoItem<'tcx>>,\n-        ) {\n-            if !visited.insert(mono_item) {\n-                return;\n-            }\n-\n-            inlining_map.with_inlining_candidates(mono_item, |target| {\n-                follow_inlining(target, inlining_map, visited);\n-            });\n-        }\n-    }\n-\n-    fn internalize_symbols(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-    ) {\n-        if codegen_units.len() == 1 {\n-            // Fast path for when there is only one codegen unit. In this case we\n-            // can internalize all candidates, since there is nowhere else they\n-            // could be accessed from.\n-            for cgu in codegen_units {\n-                for candidate in &internalization_candidates {\n-                    cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n-                }\n-            }\n-\n-            return;\n-        }\n-\n-        // Build a map from every monomorphization to all the monomorphizations that\n-        // reference it.\n-        let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = Default::default();\n-        cx.inlining_map.iter_accesses(|accessor, accessees| {\n-            for accessee in accessees {\n-                accessor_map.entry(*accessee).or_default().push(accessor);\n-            }\n-        });\n-\n-        // For each internalization candidates in each codegen unit, check if it is\n-        // accessed from outside its defining codegen unit.\n-        for cgu in codegen_units {\n-            let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n-\n-            for (accessee, linkage_and_visibility) in cgu.items_mut() {\n-                if !internalization_candidates.contains(accessee) {\n-                    // This item is no candidate for internalizing, so skip it.\n-                    continue;\n-                }\n-                debug_assert_eq!(mono_item_placements[accessee], home_cgu);\n-\n-                if let Some(accessors) = accessor_map.get(accessee) {\n-                    if accessors\n-                        .iter()\n-                        .filter_map(|accessor| {\n-                            // Some accessors might not have been\n-                            // instantiated. We can safely ignore those.\n-                            mono_item_placements.get(accessor)\n-                        })\n-                        .any(|placement| *placement != home_cgu)\n-                    {\n-                        // Found an accessor from another CGU, so skip to the next\n-                        // item without marking this one as internal.\n-                        continue;\n-                    }\n-                }\n-\n-                // If we got here, we did not find any accesses from other CGUs,\n-                // so it's fine to make this monomorphization internal.\n-                *linkage_and_visibility = (Linkage::Internal, Visibility::Default);\n-            }\n-        }\n-    }\n-}\n-\n-fn characteristic_def_id_of_mono_item<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_item: MonoItem<'tcx>,\n-) -> Option<DefId> {\n-    match mono_item {\n-        MonoItem::Fn(instance) => {\n-            let def_id = match instance.def {\n-                ty::InstanceDef::Item(def) => def,\n-                ty::InstanceDef::VTableShim(..)\n-                | ty::InstanceDef::ReifyShim(..)\n-                | ty::InstanceDef::FnPtrShim(..)\n-                | ty::InstanceDef::ClosureOnceShim { .. }\n-                | ty::InstanceDef::Intrinsic(..)\n-                | ty::InstanceDef::DropGlue(..)\n-                | ty::InstanceDef::Virtual(..)\n-                | ty::InstanceDef::CloneShim(..)\n-                | ty::InstanceDef::ThreadLocalShim(..)\n-                | ty::InstanceDef::FnPtrAddrShim(..) => return None,\n-            };\n-\n-            // If this is a method, we want to put it into the same module as\n-            // its self-type. If the self-type does not provide a characteristic\n-            // DefId, we use the location of the impl after all.\n-\n-            if tcx.trait_of_item(def_id).is_some() {\n-                let self_ty = instance.substs.type_at(0);\n-                // This is a default implementation of a trait method.\n-                return characteristic_def_id_of_type(self_ty).or(Some(def_id));\n-            }\n-\n-            if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n-                if tcx.sess.opts.incremental.is_some()\n-                    && tcx.trait_id_of_impl(impl_def_id) == tcx.lang_items().drop_trait()\n-                {\n-                    // Put `Drop::drop` into the same cgu as `drop_in_place`\n-                    // since `drop_in_place` is the only thing that can\n-                    // call it.\n-                    return None;\n-                }\n-\n-                // When polymorphization is enabled, methods which do not depend on their generic\n-                // parameters, but the self-type of their impl block do will fail to normalize.\n-                if !tcx.sess.opts.unstable_opts.polymorphize || !instance.has_param() {\n-                    // This is a method within an impl, find out what the self-type is:\n-                    let impl_self_ty = tcx.subst_and_normalize_erasing_regions(\n-                        instance.substs,\n-                        ty::ParamEnv::reveal_all(),\n-                        tcx.type_of(impl_def_id),\n-                    );\n-                    if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n-                        return Some(def_id);\n-                    }\n-                }\n-            }\n-\n-            Some(def_id)\n-        }\n-        MonoItem::Static(def_id) => Some(def_id),\n-        MonoItem::GlobalAsm(item_id) => Some(item_id.owner_id.to_def_id()),\n-    }\n-}\n-\n-fn compute_codegen_unit_name(\n-    tcx: TyCtxt<'_>,\n-    name_builder: &mut CodegenUnitNameBuilder<'_>,\n-    def_id: DefId,\n-    volatile: bool,\n-    cache: &mut CguNameCache,\n-) -> Symbol {\n-    // Find the innermost module that is not nested within a function.\n-    let mut current_def_id = def_id;\n-    let mut cgu_def_id = None;\n-    // Walk backwards from the item we want to find the module for.\n-    loop {\n-        if current_def_id.is_crate_root() {\n-            if cgu_def_id.is_none() {\n-                // If we have not found a module yet, take the crate root.\n-                cgu_def_id = Some(def_id.krate.as_def_id());\n-            }\n-            break;\n-        } else if tcx.def_kind(current_def_id) == DefKind::Mod {\n-            if cgu_def_id.is_none() {\n-                cgu_def_id = Some(current_def_id);\n-            }\n-        } else {\n-            // If we encounter something that is not a module, throw away\n-            // any module that we've found so far because we now know that\n-            // it is nested within something else.\n-            cgu_def_id = None;\n-        }\n-\n-        current_def_id = tcx.parent(current_def_id);\n-    }\n-\n-    let cgu_def_id = cgu_def_id.unwrap();\n-\n-    *cache.entry((cgu_def_id, volatile)).or_insert_with(|| {\n-        let def_path = tcx.def_path(cgu_def_id);\n-\n-        let components = def_path.data.iter().map(|part| match part.data.name() {\n-            DefPathDataName::Named(name) => name,\n-            DefPathDataName::Anon { .. } => unreachable!(),\n-        });\n-\n-        let volatile_suffix = volatile.then_some(\"volatile\");\n-\n-        name_builder.build_cgu_name(def_path.krate, components, volatile_suffix)\n-    })\n-}\n-\n-// Anything we can't find a proper codegen unit for goes into this.\n-fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_>) -> Symbol {\n-    name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n-}\n-\n-fn mono_item_linkage_and_visibility<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_item: &MonoItem<'tcx>,\n-    can_be_internalized: &mut bool,\n-    export_generics: bool,\n-) -> (Linkage, Visibility) {\n-    if let Some(explicit_linkage) = mono_item.explicit_linkage(tcx) {\n-        return (explicit_linkage, Visibility::Default);\n-    }\n-    let vis = mono_item_visibility(tcx, mono_item, can_be_internalized, export_generics);\n-    (Linkage::External, vis)\n-}\n-\n-type CguNameCache = FxHashMap<(DefId, bool), Symbol>;\n-\n-fn static_visibility<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    can_be_internalized: &mut bool,\n-    def_id: DefId,\n-) -> Visibility {\n-    if tcx.is_reachable_non_generic(def_id) {\n-        *can_be_internalized = false;\n-        default_visibility(tcx, def_id, false)\n-    } else {\n-        Visibility::Hidden\n-    }\n-}\n-\n-fn mono_item_visibility<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_item: &MonoItem<'tcx>,\n-    can_be_internalized: &mut bool,\n-    export_generics: bool,\n-) -> Visibility {\n-    let instance = match mono_item {\n-        // This is pretty complicated; see below.\n-        MonoItem::Fn(instance) => instance,\n-\n-        // Misc handling for generics and such, but otherwise:\n-        MonoItem::Static(def_id) => return static_visibility(tcx, can_be_internalized, *def_id),\n-        MonoItem::GlobalAsm(item_id) => {\n-            return static_visibility(tcx, can_be_internalized, item_id.owner_id.to_def_id());\n-        }\n-    };\n-\n-    let def_id = match instance.def {\n-        InstanceDef::Item(def_id) | InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n-\n-        // We match the visibility of statics here\n-        InstanceDef::ThreadLocalShim(def_id) => {\n-            return static_visibility(tcx, can_be_internalized, def_id);\n-        }\n-\n-        // These are all compiler glue and such, never exported, always hidden.\n-        InstanceDef::VTableShim(..)\n-        | InstanceDef::ReifyShim(..)\n-        | InstanceDef::FnPtrShim(..)\n-        | InstanceDef::Virtual(..)\n-        | InstanceDef::Intrinsic(..)\n-        | InstanceDef::ClosureOnceShim { .. }\n-        | InstanceDef::DropGlue(..)\n-        | InstanceDef::CloneShim(..)\n-        | InstanceDef::FnPtrAddrShim(..) => return Visibility::Hidden,\n-    };\n-\n-    // The `start_fn` lang item is actually a monomorphized instance of a\n-    // function in the standard library, used for the `main` function. We don't\n-    // want to export it so we tag it with `Hidden` visibility but this symbol\n-    // is only referenced from the actual `main` symbol which we unfortunately\n-    // don't know anything about during partitioning/collection. As a result we\n-    // forcibly keep this symbol out of the `internalization_candidates` set.\n-    //\n-    // FIXME: eventually we don't want to always force this symbol to have\n-    //        hidden visibility, it should indeed be a candidate for\n-    //        internalization, but we have to understand that it's referenced\n-    //        from the `main` symbol we'll generate later.\n-    //\n-    //        This may be fixable with a new `InstanceDef` perhaps? Unsure!\n-    if tcx.lang_items().start_fn() == Some(def_id) {\n-        *can_be_internalized = false;\n-        return Visibility::Hidden;\n-    }\n-\n-    let is_generic = instance.substs.non_erasable_generics().next().is_some();\n-\n-    // Upstream `DefId` instances get different handling than local ones.\n-    let Some(def_id) = def_id.as_local() else {\n-        return if export_generics && is_generic {\n-            // If it is an upstream monomorphization and we export generics, we must make\n-            // it available to downstream crates.\n-            *can_be_internalized = false;\n-            default_visibility(tcx, def_id, true)\n-        } else {\n-            Visibility::Hidden\n-        };\n-    };\n-\n-    if is_generic {\n-        if export_generics {\n-            if tcx.is_unreachable_local_definition(def_id) {\n-                // This instance cannot be used from another crate.\n-                Visibility::Hidden\n-            } else {\n-                // This instance might be useful in a downstream crate.\n-                *can_be_internalized = false;\n-                default_visibility(tcx, def_id.to_def_id(), true)\n-            }\n-        } else {\n-            // We are not exporting generics or the definition is not reachable\n-            // for downstream crates, we can internalize its instantiations.\n-            Visibility::Hidden\n-        }\n-    } else {\n-        // If this isn't a generic function then we mark this a `Default` if\n-        // this is a reachable item, meaning that it's a symbol other crates may\n-        // access when they link to us.\n-        if tcx.is_reachable_non_generic(def_id.to_def_id()) {\n-            *can_be_internalized = false;\n-            debug_assert!(!is_generic);\n-            return default_visibility(tcx, def_id.to_def_id(), false);\n-        }\n-\n-        // If this isn't reachable then we're gonna tag this with `Hidden`\n-        // visibility. In some situations though we'll want to prevent this\n-        // symbol from being internalized.\n-        //\n-        // There's two categories of items here:\n-        //\n-        // * First is weak lang items. These are basically mechanisms for\n-        //   libcore to forward-reference symbols defined later in crates like\n-        //   the standard library or `#[panic_handler]` definitions. The\n-        //   definition of these weak lang items needs to be referencable by\n-        //   libcore, so we're no longer a candidate for internalization.\n-        //   Removal of these functions can't be done by LLVM but rather must be\n-        //   done by the linker as it's a non-local decision.\n-        //\n-        // * Second is \"std internal symbols\". Currently this is primarily used\n-        //   for allocator symbols. Allocators are a little weird in their\n-        //   implementation, but the idea is that the compiler, at the last\n-        //   minute, defines an allocator with an injected object file. The\n-        //   `alloc` crate references these symbols (`__rust_alloc`) and the\n-        //   definition doesn't get hooked up until a linked crate artifact is\n-        //   generated.\n-        //\n-        //   The symbols synthesized by the compiler (`__rust_alloc`) are thin\n-        //   veneers around the actual implementation, some other symbol which\n-        //   implements the same ABI. These symbols (things like `__rg_alloc`,\n-        //   `__rdl_alloc`, `__rde_alloc`, etc), are all tagged with \"std\n-        //   internal symbols\".\n-        //\n-        //   The std-internal symbols here **should not show up in a dll as an\n-        //   exported interface**, so they return `false` from\n-        //   `is_reachable_non_generic` above and we'll give them `Hidden`\n-        //   visibility below. Like the weak lang items, though, we can't let\n-        //   LLVM internalize them as this decision is left up to the linker to\n-        //   omit them, so prevent them from being internalized.\n-        let attrs = tcx.codegen_fn_attrs(def_id);\n-        if attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n-            *can_be_internalized = false;\n-        }\n-\n-        Visibility::Hidden\n-    }\n-}\n-\n-fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibility {\n-    if !tcx.sess.target.default_hidden_visibility {\n-        return Visibility::Default;\n-    }\n-\n-    // Generic functions never have export-level C.\n-    if is_generic {\n-        return Visibility::Hidden;\n-    }\n-\n-    // Things with export level C don't get instantiated in\n-    // downstream crates.\n-    if !id.is_local() {\n-        return Visibility::Hidden;\n-    }\n-\n-    // C-export level items remain at `Default`, all other internal\n-    // items become `Hidden`.\n-    match tcx.reachable_non_generics(id.krate).get(&id) {\n-        Some(SymbolExportInfo { level: SymbolExportLevel::C, .. }) => Visibility::Default,\n-        _ => Visibility::Hidden,\n-    }\n-}"}, {"sha": "d0b23ca9ea44494dcc9dbe891f998bda48a31dc4", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "removed", "additions": 0, "deletions": 673, "changes": 673, "blob_url": "https://github.com/rust-lang/rust/blob/f51fca3af344686d734c3ff6b4399642c4f92305/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51fca3af344686d734c3ff6b4399642c4f92305/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=f51fca3af344686d734c3ff6b4399642c4f92305", "patch": "@@ -1,673 +0,0 @@\n-//! Partitioning Codegen Units for Incremental Compilation\n-//! ======================================================\n-//!\n-//! The task of this module is to take the complete set of monomorphizations of\n-//! a crate and produce a set of codegen units from it, where a codegen unit\n-//! is a named set of (mono-item, linkage) pairs. That is, this module\n-//! decides which monomorphization appears in which codegen units with which\n-//! linkage. The following paragraphs describe some of the background on the\n-//! partitioning scheme.\n-//!\n-//! The most important opportunity for saving on compilation time with\n-//! incremental compilation is to avoid re-codegenning and re-optimizing code.\n-//! Since the unit of codegen and optimization for LLVM is \"modules\" or, how\n-//! we call them \"codegen units\", the particulars of how much time can be saved\n-//! by incremental compilation are tightly linked to how the output program is\n-//! partitioned into these codegen units prior to passing it to LLVM --\n-//! especially because we have to treat codegen units as opaque entities once\n-//! they are created: There is no way for us to incrementally update an existing\n-//! LLVM module and so we have to build any such module from scratch if it was\n-//! affected by some change in the source code.\n-//!\n-//! From that point of view it would make sense to maximize the number of\n-//! codegen units by, for example, putting each function into its own module.\n-//! That way only those modules would have to be re-compiled that were actually\n-//! affected by some change, minimizing the number of functions that could have\n-//! been re-used but just happened to be located in a module that is\n-//! re-compiled.\n-//!\n-//! However, since LLVM optimization does not work across module boundaries,\n-//! using such a highly granular partitioning would lead to very slow runtime\n-//! code since it would effectively prohibit inlining and other inter-procedure\n-//! optimizations. We want to avoid that as much as possible.\n-//!\n-//! Thus we end up with a trade-off: The bigger the codegen units, the better\n-//! LLVM's optimizer can do its work, but also the smaller the compilation time\n-//! reduction we get from incremental compilation.\n-//!\n-//! Ideally, we would create a partitioning such that there are few big codegen\n-//! units with few interdependencies between them. For now though, we use the\n-//! following heuristic to determine the partitioning:\n-//!\n-//! - There are two codegen units for every source-level module:\n-//! - One for \"stable\", that is non-generic, code\n-//! - One for more \"volatile\" code, i.e., monomorphized instances of functions\n-//!   defined in that module\n-//!\n-//! In order to see why this heuristic makes sense, let's take a look at when a\n-//! codegen unit can get invalidated:\n-//!\n-//! 1. The most straightforward case is when the BODY of a function or global\n-//! changes. Then any codegen unit containing the code for that item has to be\n-//! re-compiled. Note that this includes all codegen units where the function\n-//! has been inlined.\n-//!\n-//! 2. The next case is when the SIGNATURE of a function or global changes. In\n-//! this case, all codegen units containing a REFERENCE to that item have to be\n-//! re-compiled. This is a superset of case 1.\n-//!\n-//! 3. The final and most subtle case is when a REFERENCE to a generic function\n-//! is added or removed somewhere. Even though the definition of the function\n-//! might be unchanged, a new REFERENCE might introduce a new monomorphized\n-//! instance of this function which has to be placed and compiled somewhere.\n-//! Conversely, when removing a REFERENCE, it might have been the last one with\n-//! that particular set of generic arguments and thus we have to remove it.\n-//!\n-//! From the above we see that just using one codegen unit per source-level\n-//! module is not such a good idea, since just adding a REFERENCE to some\n-//! generic item somewhere else would invalidate everything within the module\n-//! containing the generic item. The heuristic above reduces this detrimental\n-//! side-effect of references a little by at least not touching the non-generic\n-//! code of the module.\n-//!\n-//! A Note on Inlining\n-//! ------------------\n-//! As briefly mentioned above, in order for LLVM to be able to inline a\n-//! function call, the body of the function has to be available in the LLVM\n-//! module where the call is made. This has a few consequences for partitioning:\n-//!\n-//! - The partitioning algorithm has to take care of placing functions into all\n-//!   codegen units where they should be available for inlining. It also has to\n-//!   decide on the correct linkage for these functions.\n-//!\n-//! - The partitioning algorithm has to know which functions are likely to get\n-//!   inlined, so it can distribute function instantiations accordingly. Since\n-//!   there is no way of knowing for sure which functions LLVM will decide to\n-//!   inline in the end, we apply a heuristic here: Only functions marked with\n-//!   `#[inline]` are considered for inlining by the partitioner. The current\n-//!   implementation will not try to determine if a function is likely to be\n-//!   inlined by looking at the functions definition.\n-//!\n-//! Note though that as a side-effect of creating a codegen units per\n-//! source-level module, functions from the same module will be available for\n-//! inlining, even when they are not marked `#[inline]`.\n-\n-mod default;\n-\n-use std::cmp;\n-use std::fs::{self, File};\n-use std::io::{BufWriter, Write};\n-use std::path::{Path, PathBuf};\n-\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::sync;\n-use rustc_hir::def_id::{DefIdSet, LOCAL_CRATE};\n-use rustc_middle::mir;\n-use rustc_middle::mir::mono::MonoItem;\n-use rustc_middle::mir::mono::{CodegenUnit, Linkage};\n-use rustc_middle::query::Providers;\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{DumpMonoStatsFormat, SwitchWithOptPath};\n-use rustc_span::symbol::Symbol;\n-\n-use crate::collector::InliningMap;\n-use crate::collector::{self, MonoItemCollectionMode};\n-use crate::errors::{\n-    CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownCguCollectionMode, UnknownPartitionStrategy,\n-};\n-\n-enum Partitioner {\n-    Default(default::DefaultPartitioning),\n-    // Other partitioning strategies can go here.\n-    Unknown,\n-}\n-\n-impl<'tcx> Partition<'tcx> for Partitioner {\n-    fn place_root_mono_items<I>(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        mono_items: &mut I,\n-    ) -> PlacedRootMonoItems<'tcx>\n-    where\n-        I: Iterator<Item = MonoItem<'tcx>>,\n-    {\n-        match self {\n-            Partitioner::Default(partitioner) => partitioner.place_root_mono_items(cx, mono_items),\n-            Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n-        }\n-    }\n-\n-    fn merge_codegen_units(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n-    ) {\n-        match self {\n-            Partitioner::Default(partitioner) => partitioner.merge_codegen_units(cx, codegen_units),\n-            Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n-        }\n-    }\n-\n-    fn place_inlined_mono_items(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        roots: FxHashSet<MonoItem<'tcx>>,\n-    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n-        match self {\n-            Partitioner::Default(partitioner) => {\n-                partitioner.place_inlined_mono_items(cx, codegen_units, roots)\n-            }\n-            Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n-        }\n-    }\n-\n-    fn internalize_symbols(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-    ) {\n-        match self {\n-            Partitioner::Default(partitioner) => partitioner.internalize_symbols(\n-                cx,\n-                codegen_units,\n-                mono_item_placements,\n-                internalization_candidates,\n-            ),\n-            Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n-        }\n-    }\n-}\n-\n-struct PartitioningCx<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    target_cgu_count: usize,\n-    inlining_map: &'a InliningMap<'tcx>,\n-}\n-\n-pub struct PlacedRootMonoItems<'tcx> {\n-    codegen_units: Vec<CodegenUnit<'tcx>>,\n-    roots: FxHashSet<MonoItem<'tcx>>,\n-    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-}\n-\n-trait Partition<'tcx> {\n-    fn place_root_mono_items<I>(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        mono_items: &mut I,\n-    ) -> PlacedRootMonoItems<'tcx>\n-    where\n-        I: Iterator<Item = MonoItem<'tcx>>;\n-\n-    fn merge_codegen_units(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n-    );\n-\n-    fn place_inlined_mono_items(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        roots: FxHashSet<MonoItem<'tcx>>,\n-    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement>;\n-\n-    fn internalize_symbols(\n-        &mut self,\n-        cx: &PartitioningCx<'_, 'tcx>,\n-        codegen_units: &mut [CodegenUnit<'tcx>],\n-        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-    );\n-}\n-\n-fn get_partitioner(tcx: TyCtxt<'_>) -> Partitioner {\n-    let strategy = match &tcx.sess.opts.unstable_opts.cgu_partitioning_strategy {\n-        None => \"default\",\n-        Some(s) => &s[..],\n-    };\n-\n-    match strategy {\n-        \"default\" => Partitioner::Default(default::DefaultPartitioning),\n-        _ => Partitioner::Unknown,\n-    }\n-}\n-\n-fn partition<'tcx, I>(\n-    tcx: TyCtxt<'tcx>,\n-    mono_items: &mut I,\n-    max_cgu_count: usize,\n-    inlining_map: &InliningMap<'tcx>,\n-) -> Vec<CodegenUnit<'tcx>>\n-where\n-    I: Iterator<Item = MonoItem<'tcx>>,\n-{\n-    let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning\");\n-\n-    let mut partitioner = get_partitioner(tcx);\n-    let cx = &PartitioningCx { tcx, target_cgu_count: max_cgu_count, inlining_map };\n-    // In the first step, we place all regular monomorphizations into their\n-    // respective 'home' codegen unit. Regular monomorphizations are all\n-    // functions and statics defined in the local crate.\n-    let PlacedRootMonoItems { mut codegen_units, roots, internalization_candidates } = {\n-        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n-        partitioner.place_root_mono_items(cx, mono_items)\n-    };\n-\n-    for cgu in &mut codegen_units {\n-        cgu.create_size_estimate(tcx);\n-    }\n-\n-    debug_dump(tcx, \"INITIAL PARTITIONING\", &codegen_units);\n-\n-    // Merge until we have at most `max_cgu_count` codegen units.\n-    // `merge_codegen_units` is responsible for updating the CGU size\n-    // estimates.\n-    {\n-        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n-        partitioner.merge_codegen_units(cx, &mut codegen_units);\n-        debug_dump(tcx, \"POST MERGING\", &codegen_units);\n-    }\n-\n-    // In the next step, we use the inlining map to determine which additional\n-    // monomorphizations have to go into each codegen unit. These additional\n-    // monomorphizations can be drop-glue, functions from external crates, and\n-    // local functions the definition of which is marked with `#[inline]`.\n-    let mono_item_placements = {\n-        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n-        partitioner.place_inlined_mono_items(cx, &mut codegen_units, roots)\n-    };\n-\n-    for cgu in &mut codegen_units {\n-        cgu.create_size_estimate(tcx);\n-    }\n-\n-    debug_dump(tcx, \"POST INLINING\", &codegen_units);\n-\n-    // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n-    // more freedom to optimize.\n-    if !tcx.sess.link_dead_code() {\n-        let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n-        partitioner.internalize_symbols(\n-            cx,\n-            &mut codegen_units,\n-            mono_item_placements,\n-            internalization_candidates,\n-        );\n-    }\n-\n-    let instrument_dead_code =\n-        tcx.sess.instrument_coverage() && !tcx.sess.instrument_coverage_except_unused_functions();\n-\n-    if instrument_dead_code {\n-        assert!(\n-            codegen_units.len() > 0,\n-            \"There must be at least one CGU that code coverage data can be generated in.\"\n-        );\n-\n-        // Find the smallest CGU that has exported symbols and put the dead\n-        // function stubs in that CGU. We look for exported symbols to increase\n-        // the likelihood the linker won't throw away the dead functions.\n-        // FIXME(#92165): In order to truly resolve this, we need to make sure\n-        // the object file (CGU) containing the dead function stubs is included\n-        // in the final binary. This will probably require forcing these\n-        // function symbols to be included via `-u` or `/include` linker args.\n-        let mut cgus: Vec<_> = codegen_units.iter_mut().collect();\n-        cgus.sort_by_key(|cgu| cgu.size_estimate());\n-\n-        let dead_code_cgu =\n-            if let Some(cgu) = cgus.into_iter().rev().find(|cgu| {\n-                cgu.items().iter().any(|(_, (linkage, _))| *linkage == Linkage::External)\n-            }) {\n-                cgu\n-            } else {\n-                // If there are no CGUs that have externally linked items,\n-                // then we just pick the first CGU as a fallback.\n-                &mut codegen_units[0]\n-            };\n-        dead_code_cgu.make_code_coverage_dead_code_cgu();\n-    }\n-\n-    // Finally, sort by codegen unit name, so that we get deterministic results.\n-    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n-\n-    debug_dump(tcx, \"FINAL\", &codegen_units);\n-\n-    codegen_units\n-}\n-\n-/// For symbol internalization, we need to know whether a symbol/mono-item is\n-/// accessed from outside the codegen unit it is defined in. This type is used\n-/// to keep track of that.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-enum MonoItemPlacement {\n-    SingleCgu { cgu_name: Symbol },\n-    MultipleCgus,\n-}\n-\n-fn debug_dump<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx>, label: &str, cgus: &[CodegenUnit<'tcx>]) {\n-    let dump = move || {\n-        use std::fmt::Write;\n-\n-        let num_cgus = cgus.len();\n-        let max = cgus.iter().map(|cgu| cgu.size_estimate()).max().unwrap();\n-        let min = cgus.iter().map(|cgu| cgu.size_estimate()).min().unwrap();\n-        let ratio = max as f64 / min as f64;\n-\n-        let s = &mut String::new();\n-        let _ = writeln!(\n-            s,\n-            \"{label} ({num_cgus} CodegenUnits, max={max}, min={min}, max/min={ratio:.1}):\"\n-        );\n-        for cgu in cgus {\n-            let _ =\n-                writeln!(s, \"CodegenUnit {} estimated size {}:\", cgu.name(), cgu.size_estimate());\n-\n-            for (mono_item, linkage) in cgu.items() {\n-                let symbol_name = mono_item.symbol_name(tcx).name;\n-                let symbol_hash_start = symbol_name.rfind('h');\n-                let symbol_hash = symbol_hash_start.map_or(\"<no hash>\", |i| &symbol_name[i..]);\n-\n-                let _ = with_no_trimmed_paths!(writeln!(\n-                    s,\n-                    \" - {} [{:?}] [{}] estimated size {}\",\n-                    mono_item,\n-                    linkage,\n-                    symbol_hash,\n-                    mono_item.size_estimate(tcx)\n-                ));\n-            }\n-\n-            let _ = writeln!(s);\n-        }\n-\n-        std::mem::take(s)\n-    };\n-\n-    debug!(\"{}\", dump());\n-}\n-\n-#[inline(never)] // give this a place in the profiler\n-fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'tcx>, mono_items: I)\n-where\n-    I: Iterator<Item = &'a MonoItem<'tcx>>,\n-    'tcx: 'a,\n-{\n-    let _prof_timer = tcx.prof.generic_activity(\"assert_symbols_are_distinct\");\n-\n-    let mut symbols: Vec<_> =\n-        mono_items.map(|mono_item| (mono_item, mono_item.symbol_name(tcx))).collect();\n-\n-    symbols.sort_by_key(|sym| sym.1);\n-\n-    for &[(mono_item1, ref sym1), (mono_item2, ref sym2)] in symbols.array_windows() {\n-        if sym1 == sym2 {\n-            let span1 = mono_item1.local_span(tcx);\n-            let span2 = mono_item2.local_span(tcx);\n-\n-            // Deterministically select one of the spans for error reporting\n-            let span = match (span1, span2) {\n-                (Some(span1), Some(span2)) => {\n-                    Some(if span1.lo().0 > span2.lo().0 { span1 } else { span2 })\n-                }\n-                (span1, span2) => span1.or(span2),\n-            };\n-\n-            tcx.sess.emit_fatal(SymbolAlreadyDefined { span, symbol: sym1.to_string() });\n-        }\n-    }\n-}\n-\n-fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[CodegenUnit<'_>]) {\n-    let collection_mode = match tcx.sess.opts.unstable_opts.print_mono_items {\n-        Some(ref s) => {\n-            let mode = s.to_lowercase();\n-            let mode = mode.trim();\n-            if mode == \"eager\" {\n-                MonoItemCollectionMode::Eager\n-            } else {\n-                if mode != \"lazy\" {\n-                    tcx.sess.emit_warning(UnknownCguCollectionMode { mode });\n-                }\n-\n-                MonoItemCollectionMode::Lazy\n-            }\n-        }\n-        None => {\n-            if tcx.sess.link_dead_code() {\n-                MonoItemCollectionMode::Eager\n-            } else {\n-                MonoItemCollectionMode::Lazy\n-            }\n-        }\n-    };\n-\n-    let (items, inlining_map) = collector::collect_crate_mono_items(tcx, collection_mode);\n-\n-    tcx.sess.abort_if_errors();\n-\n-    let (codegen_units, _) = tcx.sess.time(\"partition_and_assert_distinct_symbols\", || {\n-        sync::join(\n-            || {\n-                let mut codegen_units = partition(\n-                    tcx,\n-                    &mut items.iter().copied(),\n-                    tcx.sess.codegen_units(),\n-                    &inlining_map,\n-                );\n-                codegen_units[0].make_primary();\n-                &*tcx.arena.alloc_from_iter(codegen_units)\n-            },\n-            || assert_symbols_are_distinct(tcx, items.iter()),\n-        )\n-    });\n-\n-    if tcx.prof.enabled() {\n-        // Record CGU size estimates for self-profiling.\n-        for cgu in codegen_units {\n-            tcx.prof.artifact_size(\n-                \"codegen_unit_size_estimate\",\n-                cgu.name().as_str(),\n-                cgu.size_estimate() as u64,\n-            );\n-        }\n-    }\n-\n-    let mono_items: DefIdSet = items\n-        .iter()\n-        .filter_map(|mono_item| match *mono_item {\n-            MonoItem::Fn(ref instance) => Some(instance.def_id()),\n-            MonoItem::Static(def_id) => Some(def_id),\n-            _ => None,\n-        })\n-        .collect();\n-\n-    // Output monomorphization stats per def_id\n-    if let SwitchWithOptPath::Enabled(ref path) = tcx.sess.opts.unstable_opts.dump_mono_stats {\n-        if let Err(err) =\n-            dump_mono_items_stats(tcx, &codegen_units, path, tcx.crate_name(LOCAL_CRATE))\n-        {\n-            tcx.sess.emit_fatal(CouldntDumpMonoStats { error: err.to_string() });\n-        }\n-    }\n-\n-    if tcx.sess.opts.unstable_opts.print_mono_items.is_some() {\n-        let mut item_to_cgus: FxHashMap<_, Vec<_>> = Default::default();\n-\n-        for cgu in codegen_units {\n-            for (&mono_item, &linkage) in cgu.items() {\n-                item_to_cgus.entry(mono_item).or_default().push((cgu.name(), linkage));\n-            }\n-        }\n-\n-        let mut item_keys: Vec<_> = items\n-            .iter()\n-            .map(|i| {\n-                let mut output = with_no_trimmed_paths!(i.to_string());\n-                output.push_str(\" @@\");\n-                let mut empty = Vec::new();\n-                let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n-                cgus.sort_by_key(|(name, _)| *name);\n-                cgus.dedup();\n-                for &(ref cgu_name, (linkage, _)) in cgus.iter() {\n-                    output.push(' ');\n-                    output.push_str(cgu_name.as_str());\n-\n-                    let linkage_abbrev = match linkage {\n-                        Linkage::External => \"External\",\n-                        Linkage::AvailableExternally => \"Available\",\n-                        Linkage::LinkOnceAny => \"OnceAny\",\n-                        Linkage::LinkOnceODR => \"OnceODR\",\n-                        Linkage::WeakAny => \"WeakAny\",\n-                        Linkage::WeakODR => \"WeakODR\",\n-                        Linkage::Appending => \"Appending\",\n-                        Linkage::Internal => \"Internal\",\n-                        Linkage::Private => \"Private\",\n-                        Linkage::ExternalWeak => \"ExternalWeak\",\n-                        Linkage::Common => \"Common\",\n-                    };\n-\n-                    output.push('[');\n-                    output.push_str(linkage_abbrev);\n-                    output.push(']');\n-                }\n-                output\n-            })\n-            .collect();\n-\n-        item_keys.sort();\n-\n-        for item in item_keys {\n-            println!(\"MONO_ITEM {item}\");\n-        }\n-    }\n-\n-    (tcx.arena.alloc(mono_items), codegen_units)\n-}\n-\n-/// Outputs stats about instantiation counts and estimated size, per `MonoItem`'s\n-/// def, to a file in the given output directory.\n-fn dump_mono_items_stats<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    codegen_units: &[CodegenUnit<'tcx>],\n-    output_directory: &Option<PathBuf>,\n-    crate_name: Symbol,\n-) -> Result<(), Box<dyn std::error::Error>> {\n-    let output_directory = if let Some(ref directory) = output_directory {\n-        fs::create_dir_all(directory)?;\n-        directory\n-    } else {\n-        Path::new(\".\")\n-    };\n-\n-    let format = tcx.sess.opts.unstable_opts.dump_mono_stats_format;\n-    let ext = format.extension();\n-    let filename = format!(\"{crate_name}.mono_items.{ext}\");\n-    let output_path = output_directory.join(&filename);\n-    let file = File::create(&output_path)?;\n-    let mut file = BufWriter::new(file);\n-\n-    // Gather instantiated mono items grouped by def_id\n-    let mut items_per_def_id: FxHashMap<_, Vec<_>> = Default::default();\n-    for cgu in codegen_units {\n-        for (&mono_item, _) in cgu.items() {\n-            // Avoid variable-sized compiler-generated shims\n-            if mono_item.is_user_defined() {\n-                items_per_def_id.entry(mono_item.def_id()).or_default().push(mono_item);\n-            }\n-        }\n-    }\n-\n-    #[derive(serde::Serialize)]\n-    struct MonoItem {\n-        name: String,\n-        instantiation_count: usize,\n-        size_estimate: usize,\n-        total_estimate: usize,\n-    }\n-\n-    // Output stats sorted by total instantiated size, from heaviest to lightest\n-    let mut stats: Vec<_> = items_per_def_id\n-        .into_iter()\n-        .map(|(def_id, items)| {\n-            let name = with_no_trimmed_paths!(tcx.def_path_str(def_id));\n-            let instantiation_count = items.len();\n-            let size_estimate = items[0].size_estimate(tcx);\n-            let total_estimate = instantiation_count * size_estimate;\n-            MonoItem { name, instantiation_count, size_estimate, total_estimate }\n-        })\n-        .collect();\n-    stats.sort_unstable_by_key(|item| cmp::Reverse(item.total_estimate));\n-\n-    if !stats.is_empty() {\n-        match format {\n-            DumpMonoStatsFormat::Json => serde_json::to_writer(file, &stats)?,\n-            DumpMonoStatsFormat::Markdown => {\n-                writeln!(\n-                    file,\n-                    \"| Item | Instantiation count | Estimated Cost Per Instantiation | Total Estimated Cost |\"\n-                )?;\n-                writeln!(file, \"| --- | ---: | ---: | ---: |\")?;\n-\n-                for MonoItem { name, instantiation_count, size_estimate, total_estimate } in stats {\n-                    writeln!(\n-                        file,\n-                        \"| `{name}` | {instantiation_count} | {size_estimate} | {total_estimate} |\"\n-                    )?;\n-                }\n-            }\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n-fn codegened_and_inlined_items(tcx: TyCtxt<'_>, (): ()) -> &DefIdSet {\n-    let (items, cgus) = tcx.collect_and_partition_mono_items(());\n-    let mut visited = DefIdSet::default();\n-    let mut result = items.clone();\n-\n-    for cgu in cgus {\n-        for (item, _) in cgu.items() {\n-            if let MonoItem::Fn(ref instance) = item {\n-                let did = instance.def_id();\n-                if !visited.insert(did) {\n-                    continue;\n-                }\n-                let body = tcx.instance_mir(instance.def);\n-                for block in body.basic_blocks.iter() {\n-                    for statement in &block.statements {\n-                        let mir::StatementKind::Coverage(_) = statement.kind else { continue };\n-                        let scope = statement.source_info.scope;\n-                        if let Some(inlined) = scope.inlined_instance(&body.source_scopes) {\n-                            result.insert(inlined.def_id());\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    tcx.arena.alloc(result)\n-}\n-\n-pub fn provide(providers: &mut Providers) {\n-    providers.collect_and_partition_mono_items = collect_and_partition_mono_items;\n-    providers.codegened_and_inlined_items = codegened_and_inlined_items;\n-\n-    providers.is_codegened_item = |tcx, def_id| {\n-        let (all_mono_items, _) = tcx.collect_and_partition_mono_items(());\n-        all_mono_items.contains(&def_id)\n-    };\n-\n-    providers.codegen_unit = |tcx, name| {\n-        let (_, all) = tcx.collect_and_partition_mono_items(());\n-        all.iter()\n-            .find(|cgu| cgu.name() == name)\n-            .unwrap_or_else(|| panic!(\"failed to find cgu with name {name:?}\"))\n-    };\n-}"}, {"sha": "7cc2b2c880c60bd75931ec04e2a596622619d366", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -1372,8 +1372,6 @@ options! {\n         \"set options for branch target identification and pointer authentication on AArch64\"),\n     cf_protection: CFProtection = (CFProtection::None, parse_cfprotection, [TRACKED],\n         \"instrument control-flow architecture protection\"),\n-    cgu_partitioning_strategy: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"the codegen unit partitioning strategy to use\"),\n     codegen_backend: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"the backend to use\"),\n     combine_cgu: bool = (false, parse_bool, [TRACKED],"}, {"sha": "76b3589b9e4b3c4223c043b0d3afc6d95dc9191b", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -538,29 +538,6 @@ impl<T, const N: usize> [T; N] {\n         drain_array_with(self, |iter| try_from_trusted_iterator(iter.map(f)))\n     }\n \n-    /// 'Zips up' two arrays into a single array of pairs.\n-    ///\n-    /// `zip()` returns a new array where every element is a tuple where the\n-    /// first element comes from the first array, and the second element comes\n-    /// from the second array. In other words, it zips two arrays together,\n-    /// into a single one.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(array_zip)]\n-    /// let x = [1, 2, 3];\n-    /// let y = [4, 5, 6];\n-    /// let z = x.zip(y);\n-    /// assert_eq!(z, [(1, 4), (2, 5), (3, 6)]);\n-    /// ```\n-    #[unstable(feature = \"array_zip\", issue = \"80094\")]\n-    pub fn zip<U>(self, rhs: [U; N]) -> [(T, U); N] {\n-        drain_array_with(self, |lhs| {\n-            drain_array_with(rhs, |rhs| from_trusted_iterator(crate::iter::zip(lhs, rhs)))\n-        })\n-    }\n-\n     /// Returns a slice containing the entire array. Equivalent to `&s[..]`.\n     #[stable(feature = \"array_as_slice\", since = \"1.57.0\")]\n     #[rustc_const_stable(feature = \"array_as_slice\", since = \"1.57.0\")]"}, {"sha": "43c859b00631e5ffdf36aeab37c9a0fb1ba359f9", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -381,7 +381,7 @@ impl StepDescription {\n             eprintln!(\n                 \"note: if you are adding a new Step to bootstrap itself, make sure you register it with `describe!`\"\n             );\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n     }\n }\n@@ -1355,7 +1355,7 @@ impl<'a> Builder<'a> {\n                         \"error: `x.py clippy` requires a host `rustc` toolchain with the `clippy` component\"\n                     );\n                     eprintln!(\"help: try `rustup component add clippy`\");\n-                    crate::detail_exit(1);\n+                    crate::detail_exit_macro!(1);\n                 });\n                 if !t!(std::str::from_utf8(&output.stdout)).contains(\"nightly\") {\n                     rustflags.arg(\"--cfg=bootstrap\");"}, {"sha": "1c66c00eda726f7e5ed3b92d5460f715cdab6f44", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -1686,7 +1686,7 @@ pub fn run_cargo(\n     });\n \n     if !ok {\n-        crate::detail_exit(1);\n+        crate::detail_exit_macro!(1);\n     }\n \n     // Ok now we need to actually find all the files listed in `toplevel`. We've"}, {"sha": "45ad1547eb77159e103d1c6dad1d80b20e3f05f7", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -23,6 +23,7 @@ use crate::channel::{self, GitInfo};\n pub use crate::flags::Subcommand;\n use crate::flags::{Color, Flags, Warnings};\n use crate::util::{exe, output, t};\n+use build_helper::detail_exit_macro;\n use once_cell::sync::OnceCell;\n use serde::{Deserialize, Deserializer};\n use serde_derive::Deserialize;\n@@ -579,7 +580,7 @@ macro_rules! define_config {\n                                         panic!(\"overriding existing option\")\n                                     } else {\n                                         eprintln!(\"overriding existing option: `{}`\", stringify!($field));\n-                                        crate::detail_exit(2);\n+                                        detail_exit_macro!(2);\n                                     }\n                                 } else {\n                                     self.$field = other.$field;\n@@ -678,7 +679,7 @@ impl<T> Merge for Option<T> {\n                             panic!(\"overriding existing option\")\n                         } else {\n                             eprintln!(\"overriding existing option\");\n-                            crate::detail_exit(2);\n+                            detail_exit_macro!(2);\n                         }\n                     } else {\n                         *self = other;\n@@ -944,7 +945,7 @@ impl Config {\n                 .and_then(|table: toml::Value| TomlConfig::deserialize(table))\n                 .unwrap_or_else(|err| {\n                     eprintln!(\"failed to parse TOML configuration '{}': {err}\", file.display());\n-                    crate::detail_exit(2);\n+                    detail_exit_macro!(2);\n                 })\n         }\n         Self::parse_inner(args, get_toml)\n@@ -978,7 +979,7 @@ impl Config {\n             eprintln!(\n                 \"Cannot use both `llvm_bolt_profile_generate` and `llvm_bolt_profile_use` at the same time\"\n             );\n-            crate::detail_exit(1);\n+            detail_exit_macro!(1);\n         }\n \n         // Infer the rest of the configuration.\n@@ -1094,7 +1095,7 @@ impl Config {\n                 }\n             }\n             eprintln!(\"failed to parse override `{option}`: `{err}\");\n-            crate::detail_exit(2)\n+            detail_exit_macro!(2)\n         }\n         toml.merge(override_toml, ReplaceOpt::Override);\n \n@@ -1810,7 +1811,7 @@ impl Config {\n             println!(\"help: maybe your repository history is too shallow?\");\n             println!(\"help: consider disabling `download-rustc`\");\n             println!(\"help: or fetch enough history to include one upstream commit\");\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n \n         // Warn if there were changes to the compiler or standard library since the ancestor commit."}, {"sha": "12780df21757a26b15d20f319e07190d5d11faa2", "filename": "src/bootstrap/download.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Fdownload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Fdownload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -7,14 +7,15 @@ use std::{\n     process::{Command, Stdio},\n };\n \n+use build_helper::util::try_run;\n use once_cell::sync::OnceCell;\n use xz2::bufread::XzDecoder;\n \n use crate::{\n     config::RustfmtMetadata,\n     llvm::detect_llvm_sha,\n     t,\n-    util::{check_run, exe, program_out_of_date, try_run},\n+    util::{check_run, exe, program_out_of_date},\n     Config,\n };\n \n@@ -245,7 +246,7 @@ impl Config {\n             if !help_on_error.is_empty() {\n                 eprintln!(\"{}\", help_on_error);\n             }\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n     }\n "}, {"sha": "dc05f47ee9cd1a8c5f1edebc938fdd5ceaf574e9", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -193,7 +193,7 @@ impl Flags {\n             } else {\n                 panic!(\"No paths available for subcommand `{}`\", subcommand.as_str());\n             }\n-            crate::detail_exit(0);\n+            crate::detail_exit_macro!(0);\n         }\n \n         Flags::parse_from(it)\n@@ -538,7 +538,7 @@ pub fn get_completion<G: clap_complete::Generator>(shell: G, path: &Path) -> Opt\n     } else {\n         std::fs::read_to_string(path).unwrap_or_else(|_| {\n             eprintln!(\"couldn't read {}\", path.display());\n-            crate::detail_exit(1)\n+            crate::detail_exit_macro!(1)\n         })\n     };\n     let mut buf = Vec::new();"}, {"sha": "ebf068b2cb16ee4cc1183daf66106510aaf0fbd7", "filename": "src/bootstrap/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fformat.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -40,7 +40,7 @@ fn rustfmt(src: &Path, rustfmt: &Path, paths: &[PathBuf], check: bool) -> impl F\n                         code, run `./x.py fmt` instead.\",\n                 cmd_debug,\n             );\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n         true\n     }\n@@ -196,7 +196,7 @@ pub fn format(build: &Builder<'_>, check: bool, paths: &[PathBuf]) {\n \n     let rustfmt_path = build.initial_rustfmt().unwrap_or_else(|| {\n         eprintln!(\"./x.py fmt is not supported on this channel\");\n-        crate::detail_exit(1);\n+        crate::detail_exit_macro!(1);\n     });\n     assert!(rustfmt_path.exists(), \"{}\", rustfmt_path.display());\n     let src = build.src.clone();"}, {"sha": "a1aaee68c625ded1c892633d29e7e891f62f5f17", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -27,6 +27,7 @@ use std::process::{Command, Stdio};\n use std::str;\n \n use build_helper::ci::{gha, CiEnv};\n+use build_helper::detail_exit_macro;\n use channel::GitInfo;\n use config::{DryRun, Target};\n use filetime::FileTime;\n@@ -699,7 +700,7 @@ impl Build {\n             for failure in failures.iter() {\n                 eprintln!(\"  - {}\\n\", failure);\n             }\n-            detail_exit(1);\n+            detail_exit_macro!(1);\n         }\n \n         #[cfg(feature = \"build-metrics\")]\n@@ -1482,7 +1483,7 @@ impl Build {\n                 \"Error: Unable to find the stamp file {}, did you try to keep a nonexistent build stage?\",\n                 stamp.display()\n             );\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n \n         let mut paths = Vec::new();\n@@ -1674,7 +1675,7 @@ Alternatively, set `download-ci-llvm = true` in that `[llvm]` section\n to download LLVM rather than building it.\n \"\n                 );\n-                detail_exit(1);\n+                detail_exit_macro!(1);\n             }\n         }\n \n@@ -1739,18 +1740,6 @@ fn chmod(path: &Path, perms: u32) {\n #[cfg(windows)]\n fn chmod(_path: &Path, _perms: u32) {}\n \n-/// If code is not 0 (successful exit status), exit status is 101 (rust's default error code.)\n-/// If the test is running and code is an error code, it will cause a panic.\n-fn detail_exit(code: i32) -> ! {\n-    // if in test and code is an error code, panic with status code provided\n-    if cfg!(test) {\n-        panic!(\"status code: {}\", code);\n-    } else {\n-        // otherwise,exit with provided status code\n-        std::process::exit(code);\n-    }\n-}\n-\n impl Compiler {\n     pub fn with_stage(mut self, stage: u32) -> Compiler {\n         self.stage = stage;"}, {"sha": "872b75f6c1599889a72fd69744501ec722cdb523", "filename": "src/bootstrap/render_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Frender_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Frender_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frender_tests.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn try_run_tests(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n \n     if !run_tests(builder, cmd) {\n         if builder.fail_fast {\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         } else {\n             let mut failures = builder.delayed_failures.borrow_mut();\n             failures.push(format!(\"{cmd:?}\"));"}, {"sha": "8f5ba42736b1ffe6241f6662024696a020360170", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -104,7 +104,7 @@ You should install cmake, or set `download-ci-llvm = true` in the\n than building it.\n \"\n             );\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n     }\n "}, {"sha": "40038df8332105443cf6c7abcf2cca0b8cbdfb22", "filename": "src/bootstrap/setup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -194,7 +194,7 @@ fn setup_config_toml(path: &PathBuf, profile: Profile, config: &Config) {\n             \"note: this will use the configuration in {}\",\n             profile.include_path(&config.src).display()\n         );\n-        crate::detail_exit(1);\n+        crate::detail_exit_macro!(1);\n     }\n \n     let settings = format!(\n@@ -380,7 +380,7 @@ pub fn interactive_path() -> io::Result<Profile> {\n         io::stdin().read_line(&mut input)?;\n         if input.is_empty() {\n             eprintln!(\"EOF on stdin, when expecting answer to question.  Giving up.\");\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n         break match parse_with_abbrev(&input) {\n             Ok(profile) => profile,"}, {"sha": "2924ba0bdf1c7e80b30bffe2e15ab96fd85da41e", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -773,7 +773,7 @@ impl Step for Clippy {\n         }\n \n         if !builder.config.cmd.bless() {\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n \n         let mut cargo = builder.cargo(compiler, Mode::ToolRustc, SourceType::InTree, host, \"run\");\n@@ -1085,7 +1085,7 @@ help: to skip test's attempt to check tidiness, pass `--exclude src/tools/tidy`\n                     PATH = inferred_rustfmt_dir.display(),\n                     CHAN = builder.config.channel,\n                 );\n-                crate::detail_exit(1);\n+                crate::detail_exit_macro!(1);\n             }\n             crate::format::format(&builder, !builder.config.cmd.bless(), &[]);\n         }\n@@ -1108,7 +1108,7 @@ help: to skip test's attempt to check tidiness, pass `--exclude src/tools/tidy`\n                 eprintln!(\n                     \"x.py completions were changed; run `x.py run generate-completions` to update them\"\n                 );\n-                crate::detail_exit(1);\n+                crate::detail_exit_macro!(1);\n             }\n         }\n     }\n@@ -1329,7 +1329,7 @@ help: to test the compiler, use `--stage 1` instead\n help: to test the standard library, use `--stage 0 library/std` instead\n note: if you're sure you want to do this, please open an issue as to why. In the meantime, you can override this with `COMPILETEST_FORCE_STAGE0=1`.\"\n             );\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n \n         let mut compiler = self.compiler;"}, {"sha": "0f0a3bb8775db3bec19573d7917aa28202fcba7d", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -116,7 +116,7 @@ impl Step for ToolBuild {\n \n         if !is_expected {\n             if !is_optional_tool {\n-                crate::detail_exit(1);\n+                crate::detail_exit_macro!(1);\n             } else {\n                 None\n             }"}, {"sha": "9c4d0ea265ddfa0f1b586a80421d904aa890e790", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -91,7 +91,7 @@ fn print_error(tool: &str, submodule: &str) {\n     eprintln!(\"If you do NOT intend to update '{}', please ensure you did not accidentally\", tool);\n     eprintln!(\"change the submodule at '{}'. You may ask your reviewer for the\", submodule);\n     eprintln!(\"proper steps.\");\n-    crate::detail_exit(3);\n+    crate::detail_exit_macro!(3);\n }\n \n fn check_changed_files(toolstates: &HashMap<Box<str>, ToolState>) {\n@@ -106,7 +106,7 @@ fn check_changed_files(toolstates: &HashMap<Box<str>, ToolState>) {\n         Ok(o) => o,\n         Err(e) => {\n             eprintln!(\"Failed to get changed files: {:?}\", e);\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n     };\n \n@@ -177,7 +177,7 @@ impl Step for ToolStateCheck {\n         }\n \n         if did_error {\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n \n         check_changed_files(&toolstates);\n@@ -223,7 +223,7 @@ impl Step for ToolStateCheck {\n         }\n \n         if did_error {\n-            crate::detail_exit(1);\n+            crate::detail_exit_macro!(1);\n         }\n \n         if builder.config.channel == \"nightly\" && env::var_os(\"TOOLSTATE_PUBLISH\").is_some() {"}, {"sha": "e4bbccdb067c2dbf6b922395586ce52b75d3c469", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -3,6 +3,7 @@\n //! Simple things like testing the various filesystem operations here and there,\n //! not a lot of interesting happenings here unfortunately.\n \n+use build_helper::util::{fail, try_run};\n use std::env;\n use std::fs;\n use std::io;\n@@ -230,25 +231,10 @@ pub fn is_valid_test_suite_arg<'a, P: AsRef<Path>>(\n \n pub fn run(cmd: &mut Command, print_cmd_on_fail: bool) {\n     if !try_run(cmd, print_cmd_on_fail) {\n-        crate::detail_exit(1);\n+        crate::detail_exit_macro!(1);\n     }\n }\n \n-pub fn try_run(cmd: &mut Command, print_cmd_on_fail: bool) -> bool {\n-    let status = match cmd.status() {\n-        Ok(status) => status,\n-        Err(e) => fail(&format!(\"failed to execute command: {:?}\\nerror: {}\", cmd, e)),\n-    };\n-    if !status.success() && print_cmd_on_fail {\n-        println!(\n-            \"\\n\\ncommand did not execute successfully: {:?}\\n\\\n-             expected success, got: {}\\n\\n\",\n-            cmd, status\n-        );\n-    }\n-    status.success()\n-}\n-\n pub fn check_run(cmd: &mut Command, print_cmd_on_fail: bool) -> bool {\n     let status = match cmd.status() {\n         Ok(status) => status,\n@@ -269,7 +255,7 @@ pub fn check_run(cmd: &mut Command, print_cmd_on_fail: bool) -> bool {\n \n pub fn run_suppressed(cmd: &mut Command) {\n     if !try_run_suppressed(cmd) {\n-        crate::detail_exit(1);\n+        crate::detail_exit_macro!(1);\n     }\n }\n \n@@ -374,11 +360,6 @@ fn dir_up_to_date(src: &Path, threshold: SystemTime) -> bool {\n     })\n }\n \n-fn fail(s: &str) -> ! {\n-    eprintln!(\"\\n\\n{}\\n\\n\", s);\n-    crate::detail_exit(1);\n-}\n-\n /// Copied from `std::path::absolute` until it stabilizes.\n ///\n /// FIXME: this shouldn't exist."}, {"sha": "5fd867189fd713551ee88c062868e51217720b0b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -1111,8 +1111,8 @@ fn clean_fn_decl_with_args<'tcx>(\n     args: Arguments,\n ) -> FnDecl {\n     let output = match decl.output {\n-        hir::FnRetTy::Return(typ) => Return(clean_ty(typ, cx)),\n-        hir::FnRetTy::DefaultReturn(..) => DefaultReturn,\n+        hir::FnRetTy::Return(typ) => clean_ty(typ, cx),\n+        hir::FnRetTy::DefaultReturn(..) => Type::Tuple(Vec::new()),\n     };\n     FnDecl { inputs: args, output, c_variadic: decl.c_variadic }\n }\n@@ -1126,10 +1126,7 @@ fn clean_fn_decl_from_did_and_sig<'tcx>(\n \n     // We assume all empty tuples are default return type. This theoretically can discard `-> ()`,\n     // but shouldn't change any code meaning.\n-    let output = match clean_middle_ty(sig.output(), cx, None) {\n-        Type::Tuple(inner) if inner.is_empty() => DefaultReturn,\n-        ty => Return(ty),\n-    };\n+    let output = clean_middle_ty(sig.output(), cx, None);\n \n     FnDecl {\n         output,"}, {"sha": "1999a6b671d3a6b2c65232495260318e2b7928d7", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -42,7 +42,6 @@ use crate::formats::item_type::ItemType;\n use crate::html::render::Context;\n use crate::passes::collect_intra_doc_links::UrlFragment;\n \n-pub(crate) use self::FnRetTy::*;\n pub(crate) use self::ItemKind::*;\n pub(crate) use self::SelfTy::*;\n pub(crate) use self::Type::{\n@@ -1353,7 +1352,7 @@ pub(crate) struct Function {\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub(crate) struct FnDecl {\n     pub(crate) inputs: Arguments,\n-    pub(crate) output: FnRetTy,\n+    pub(crate) output: Type,\n     pub(crate) c_variadic: bool,\n }\n \n@@ -1371,18 +1370,16 @@ impl FnDecl {\n     ///\n     /// This function will panic if the return type does not match the expected sugaring for async\n     /// functions.\n-    pub(crate) fn sugared_async_return_type(&self) -> FnRetTy {\n-        match &self.output {\n-            FnRetTy::Return(Type::ImplTrait(bounds)) => match &bounds[0] {\n-                GenericBound::TraitBound(PolyTrait { trait_, .. }, ..) => {\n-                    let bindings = trait_.bindings().unwrap();\n-                    let ret_ty = bindings[0].term();\n-                    let ty = ret_ty.ty().expect(\"Unexpected constant return term\");\n-                    FnRetTy::Return(ty.clone())\n-                }\n-                _ => panic!(\"unexpected desugaring of async function\"),\n-            },\n-            _ => panic!(\"unexpected desugaring of async function\"),\n+    pub(crate) fn sugared_async_return_type(&self) -> Type {\n+        if let Type::ImplTrait(v) = &self.output &&\n+            let [GenericBound::TraitBound(PolyTrait { trait_, .. }, _ )] = &v[..]\n+        {\n+            let bindings = trait_.bindings().unwrap();\n+            let ret_ty = bindings[0].term();\n+            let ty = ret_ty.ty().expect(\"Unexpected constant return term\");\n+            ty.clone()\n+        } else {\n+            panic!(\"unexpected desugaring of async function\")\n         }\n     }\n }\n@@ -1425,21 +1422,6 @@ impl Argument {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub(crate) enum FnRetTy {\n-    Return(Type),\n-    DefaultReturn,\n-}\n-\n-impl FnRetTy {\n-    pub(crate) fn as_return(&self) -> Option<&Type> {\n-        match self {\n-            Return(ret) => Some(ret),\n-            DefaultReturn => None,\n-        }\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n pub(crate) struct Trait {\n     pub(crate) def_id: DefId,\n@@ -1641,6 +1623,10 @@ impl Type {\n         matches!(self, Type::ImplTrait(_))\n     }\n \n+    pub(crate) fn is_unit(&self) -> bool {\n+        matches!(self, Type::Tuple(v) if v.is_empty())\n+    }\n+\n     pub(crate) fn projection(&self) -> Option<(&Type, DefId, PathSegment)> {\n         if let QPath(box QPathData { self_type, trait_, assoc, .. }) = self {\n             Some((self_type, trait_.as_ref()?.def_id(), assoc.clone()))"}, {"sha": "f26d74629dd941c6756afb0017810f6d43dc36cb", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -1257,9 +1257,9 @@ impl clean::Impl {\n                 };\n                 primitive_link_fragment(f, PrimitiveType::Tuple, &format!(\"fn ({name}\u2081, {name}\u2082, \u2026, {name}\u2099{ellipsis})\"), \"#trait-implementations-1\", cx)?;\n                 // Write output.\n-                if let clean::FnRetTy::Return(ty) = &bare_fn.decl.output {\n+                if !bare_fn.decl.output.is_unit() {\n                     write!(f, \" -> \")?;\n-                    fmt_type(ty, f, use_absolute, cx)?;\n+                    fmt_type(&bare_fn.decl.output, f, use_absolute, cx)?;\n                 }\n             } else if let Some(ty) = self.kind.as_blanket_ty() {\n                 fmt_type(ty, f, use_absolute, cx)?;\n@@ -1296,22 +1296,6 @@ impl clean::Arguments {\n     }\n }\n \n-impl clean::FnRetTy {\n-    pub(crate) fn print<'a, 'tcx: 'a>(\n-        &'a self,\n-        cx: &'a Context<'tcx>,\n-    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n-        display_fn(move |f| match self {\n-            clean::Return(clean::Tuple(tys)) if tys.is_empty() => Ok(()),\n-            clean::Return(ty) if f.alternate() => {\n-                write!(f, \" -> {:#}\", ty.print(cx))\n-            }\n-            clean::Return(ty) => write!(f, \" -&gt; {}\", ty.print(cx)),\n-            clean::DefaultReturn => Ok(()),\n-        })\n-    }\n-}\n-\n impl clean::BareFunctionDecl {\n     fn print_hrtb_with_space<'a, 'tcx: 'a>(\n         &'a self,\n@@ -1366,15 +1350,15 @@ impl clean::FnDecl {\n                     \"({args:#}{ellipsis}){arrow:#}\",\n                     args = self.inputs.print(cx),\n                     ellipsis = ellipsis,\n-                    arrow = self.output.print(cx)\n+                    arrow = self.print_output(cx)\n                 )\n             } else {\n                 write!(\n                     f,\n                     \"({args}{ellipsis}){arrow}\",\n                     args = self.inputs.print(cx),\n                     ellipsis = ellipsis,\n-                    arrow = self.output.print(cx)\n+                    arrow = self.print_output(cx)\n                 )\n             }\n         })\n@@ -1464,9 +1448,22 @@ impl clean::FnDecl {\n             Some(n) => write!(f, \"\\n{})\", Indent(n))?,\n         };\n \n-        fmt::Display::fmt(&self.output.print(cx), f)?;\n+        fmt::Display::fmt(&self.print_output(cx), f)?;\n         Ok(())\n     }\n+\n+    pub(crate) fn print_output<'a, 'tcx: 'a>(\n+        &'a self,\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n+        display_fn(move |f| match &self.output {\n+            clean::Tuple(tys) if tys.is_empty() => Ok(()),\n+            ty if f.alternate() => {\n+                write!(f, \" -> {:#}\", ty.print(cx))\n+            }\n+            ty => write!(f, \" -&gt; {}\", ty.print(cx)),\n+        })\n+    }\n }\n \n pub(crate) fn visibility_print_with_space<'a, 'tcx: 'a>("}, {"sha": "a5223bd6309d707b28f5f95b9f3b13e2187ccc74", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -844,7 +844,7 @@ fn assoc_method(\n         + name.as_str().len()\n         + generics_len;\n \n-    let notable_traits = d.output.as_return().and_then(|output| notable_traits_button(output, cx));\n+    let notable_traits = notable_traits_button(&d.output, cx);\n \n     let (indent, indent_str, end_newline) = if parent == ItemType::Trait {\n         header_len += 4;\n@@ -1282,6 +1282,11 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool, tcx: TyCtxt<'_>) ->\n pub(crate) fn notable_traits_button(ty: &clean::Type, cx: &mut Context<'_>) -> Option<String> {\n     let mut has_notable_trait = false;\n \n+    if ty.is_unit() {\n+        // Very common fast path.\n+        return None;\n+    }\n+\n     let did = ty.def_id(cx.cache())?;\n \n     // Box has pass-through impls for Read, Write, Iterator, and Future when the"}, {"sha": "21f61acb2c53f86c569b478b8f2992c1a1ea1765", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -587,8 +587,7 @@ fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &cle\n         + name.as_str().len()\n         + generics_len;\n \n-    let notable_traits =\n-        f.decl.output.as_return().and_then(|output| notable_traits_button(output, cx));\n+    let notable_traits = notable_traits_button(&f.decl.output, cx);\n \n     wrap_item(w, |w| {\n         w.reserve(header_len);\n@@ -1420,30 +1419,36 @@ fn item_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2))\n }\n \n-fn item_proc_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, m: &clean::ProcMacro) {\n-    wrap_item(w, |w| {\n+fn item_proc_macro(\n+    w: &mut impl fmt::Write,\n+    cx: &mut Context<'_>,\n+    it: &clean::Item,\n+    m: &clean::ProcMacro,\n+) {\n+    let mut buffer = Buffer::new();\n+    wrap_item(&mut buffer, |buffer| {\n         let name = it.name.expect(\"proc-macros always have names\");\n         match m.kind {\n             MacroKind::Bang => {\n-                write!(w, \"{}!() {{ /* proc-macro */ }}\", name);\n+                write!(buffer, \"{}!() {{ /* proc-macro */ }}\", name);\n             }\n             MacroKind::Attr => {\n-                write!(w, \"#[{}]\", name);\n+                write!(buffer, \"#[{}]\", name);\n             }\n             MacroKind::Derive => {\n-                write!(w, \"#[derive({})]\", name);\n+                write!(buffer, \"#[derive({})]\", name);\n                 if !m.helpers.is_empty() {\n-                    w.push_str(\"\\n{\\n\");\n-                    w.push_str(\"    // Attributes available to this derive:\\n\");\n+                    buffer.push_str(\"\\n{\\n\");\n+                    buffer.push_str(\"    // Attributes available to this derive:\\n\");\n                     for attr in &m.helpers {\n-                        writeln!(w, \"    #[{}]\", attr);\n+                        writeln!(buffer, \"    #[{}]\", attr);\n                     }\n-                    w.push_str(\"}\\n\");\n+                    buffer.push_str(\"}\\n\");\n                 }\n             }\n         }\n     });\n-    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2))\n+    write!(w, \"{}{}\", buffer.into_inner(), document(cx, it, None, HeadingOffset::H2)).unwrap();\n }\n \n fn item_primitive(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {"}, {"sha": "f34be120d292b94f12acbbfdd4c8bdbaebc26ead", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -7,7 +7,7 @@ use rustc_span::symbol::Symbol;\n use serde::ser::{Serialize, SerializeStruct, Serializer};\n \n use crate::clean;\n-use crate::clean::types::{FnRetTy, Function, Generics, ItemId, Type, WherePredicate};\n+use crate::clean::types::{Function, Generics, ItemId, Type, WherePredicate};\n use crate::formats::cache::{Cache, OrphanImplItem};\n use crate::formats::item_type::ItemType;\n use crate::html::format::join_with_double_colon;\n@@ -656,22 +656,9 @@ fn get_fn_inputs_and_outputs<'tcx>(\n     }\n \n     let mut ret_types = Vec::new();\n-    match decl.output {\n-        FnRetTy::Return(ref return_type) => {\n-            add_generics_and_bounds_as_types(\n-                self_,\n-                generics,\n-                return_type,\n-                tcx,\n-                0,\n-                &mut ret_types,\n-                cache,\n-            );\n-            if ret_types.is_empty() {\n-                ret_types.push(get_index_type(return_type, vec![]));\n-            }\n-        }\n-        _ => {}\n-    };\n+    add_generics_and_bounds_as_types(self_, generics, &decl.output, tcx, 0, &mut ret_types, cache);\n+    if ret_types.is_empty() {\n+        ret_types.push(get_index_type(&decl.output, vec![]));\n+    }\n     (all_types, ret_types)\n }"}, {"sha": "91cd55b1113abd51763e1b95029f3f7ea65e3c39", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -624,10 +624,7 @@ impl FromWithTcx<clean::FnDecl> for FnDecl {\n                 .into_iter()\n                 .map(|arg| (arg.name.to_string(), arg.type_.into_tcx(tcx)))\n                 .collect(),\n-            output: match output {\n-                clean::FnRetTy::Return(t) => Some(t.into_tcx(tcx)),\n-                clean::FnRetTy::DefaultReturn => None,\n-            },\n+            output: if output.is_unit() { None } else { Some(output.into_tcx(tcx)) },\n             c_variadic,\n         }\n     }"}, {"sha": "abb9229fbd51a9bc58605caac389a3ea98d38c0b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -267,6 +267,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let is_no_inline = use_attrs.lists(sym::doc).has_word(sym::no_inline)\n             || use_attrs.lists(sym::doc).has_word(sym::hidden);\n \n+        if is_no_inline {\n+            return false;\n+        }\n+\n         // For cross-crate impl inlining we need to know whether items are\n         // reachable in documentation -- a previously unreachable item can be\n         // made reachable by cross-crate inlining which we're checking here.\n@@ -281,31 +285,38 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         };\n \n         let is_private = !self.cx.cache.effective_visibilities.is_directly_public(tcx, ori_res_did);\n-        let is_hidden = inherits_doc_hidden(tcx, res_did, None);\n+        let is_hidden = tcx.is_doc_hidden(ori_res_did);\n+        let item = tcx.hir().get_by_def_id(res_did);\n \n-        // Only inline if requested or if the item would otherwise be stripped.\n-        if (!please_inline && !is_private && !is_hidden) || is_no_inline {\n-            return false;\n-        }\n-\n-        if !please_inline &&\n-            let Some(item_def_id) = reexport_chain(tcx, def_id, res_did).iter()\n+        if !please_inline {\n+            let inherits_hidden = inherits_doc_hidden(tcx, res_did, None);\n+            // Only inline if requested or if the item would otherwise be stripped.\n+            //\n+            // If it's a doc hidden module, we need to keep it in case some of its inner items\n+            // are re-exported.\n+            if (!is_private && !inherits_hidden) || (\n+                is_hidden &&\n+                !matches!(item, Node::Item(&hir::Item { kind: hir::ItemKind::Mod(_), .. }))\n+            ) {\n+                return false;\n+            } else if let Some(item_def_id) = reexport_chain(tcx, def_id, res_did).iter()\n                 .flat_map(|reexport| reexport.id()).map(|id| id.expect_local())\n                 .chain(iter::once(res_did)).nth(1) &&\n-            item_def_id != def_id &&\n-            self\n-                .cx\n-                .cache\n-                .effective_visibilities\n-                .is_directly_public(tcx, item_def_id.to_def_id()) &&\n-            !inherits_doc_hidden(tcx, item_def_id, None)\n-        {\n-            // The imported item is public and not `doc(hidden)` so no need to inline it.\n-            return false;\n+                item_def_id != def_id &&\n+                self\n+                    .cx\n+                    .cache\n+                    .effective_visibilities\n+                    .is_directly_public(tcx, item_def_id.to_def_id()) &&\n+                !inherits_doc_hidden(tcx, item_def_id, None)\n+            {\n+                // The imported item is public and not `doc(hidden)` so no need to inline it.\n+                return false;\n+            }\n         }\n \n         let is_bang_macro = matches!(\n-            tcx.hir().get_by_def_id(res_did),\n+            item,\n             Node::Item(&hir::Item { kind: hir::ItemKind::Macro(_, MacroKind::Bang), .. })\n         );\n \n@@ -317,12 +328,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             // Bang macros are handled a bit on their because of how they are handled by the\n             // compiler. If they have `#[doc(hidden)]` and the re-export doesn't have\n             // `#[doc(inline)]`, then we don't inline it.\n-            Node::Item(_)\n-                if is_bang_macro\n-                    && !please_inline\n-                    && renamed.is_some()\n-                    && self.cx.tcx.is_doc_hidden(ori_res_did) =>\n-            {\n+            Node::Item(_) if is_bang_macro && !please_inline && renamed.is_some() && is_hidden => {\n                 return false;\n             }\n             Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n@@ -455,6 +461,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                             is_glob,\n                             please_inline,\n                         ) {\n+                            debug!(\"Inlining {:?}\", item.owner_id.def_id);\n                             continue;\n                         }\n                     }"}, {"sha": "3fa970373b3fb85a99923c58cead5a777103a5c2", "filename": "src/tools/build_helper/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Ftools%2Fbuild_helper%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Ftools%2Fbuild_helper%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild_helper%2Fsrc%2Flib.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -1,2 +1,3 @@\n pub mod ci;\n pub mod git;\n+pub mod util;"}, {"sha": "731095023a96e8bbae1a1ef60509552acfd9fea4", "filename": "src/tools/build_helper/src/util.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Ftools%2Fbuild_helper%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Ftools%2Fbuild_helper%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild_helper%2Fsrc%2Futil.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -0,0 +1,41 @@\n+use std::process::Command;\n+\n+/// Invokes `build_helper::util::detail_exit` with `cfg!(test)`\n+#[macro_export]\n+macro_rules! detail_exit_macro {\n+    ($code:expr) => {\n+        build_helper::util::detail_exit($code, cfg!(test));\n+    };\n+}\n+\n+/// If code is not 0 (successful exit status), exit status is 101 (rust's default error code.)\n+/// If `is_test` true and code is an error code, it will cause a panic.\n+pub fn detail_exit(code: i32, is_test: bool) -> ! {\n+    // if in test and code is an error code, panic with status code provided\n+    if is_test {\n+        panic!(\"status code: {}\", code);\n+    } else {\n+        // otherwise,exit with provided status code\n+        std::process::exit(code);\n+    }\n+}\n+\n+pub fn fail(s: &str) -> ! {\n+    eprintln!(\"\\n\\n{}\\n\\n\", s);\n+    detail_exit(1, cfg!(test));\n+}\n+\n+pub fn try_run(cmd: &mut Command, print_cmd_on_fail: bool) -> bool {\n+    let status = match cmd.status() {\n+        Ok(status) => status,\n+        Err(e) => fail(&format!(\"failed to execute command: {:?}\\nerror: {}\", cmd, e)),\n+    };\n+    if !status.success() && print_cmd_on_fail {\n+        println!(\n+            \"\\n\\ncommand did not execute successfully: {:?}\\n\\\n+             expected success, got: {}\\n\\n\",\n+            cmd, status\n+        );\n+    }\n+    status.success()\n+}"}, {"sha": "4cb200ebc7c5f1928287648adfb0c662eaa30373", "filename": "src/tools/rustdoc-gui-test/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Ftools%2Frustdoc-gui-test%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Ftools%2Frustdoc-gui-test%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-gui-test%2FCargo.toml?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -4,6 +4,7 @@ version = \"0.1.0\"\n edition = \"2021\"\n \n [dependencies]\n+build_helper = { path = \"../build_helper\" }\n compiletest = { path = \"../compiletest\" }\n getopts = \"0.2\"\n walkdir = \"2\""}, {"sha": "3f60a90f87a22c154e6a077e59e8dd3334a67d1a", "filename": "src/tools/rustdoc-gui-test/src/main.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Ftools%2Frustdoc-gui-test%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/src%2Ftools%2Frustdoc-gui-test%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-gui-test%2Fsrc%2Fmain.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -1,3 +1,4 @@\n+use build_helper::util::try_run;\n use compiletest::header::TestProps;\n use config::Config;\n use std::path::{Path, PathBuf};\n@@ -60,23 +61,6 @@ fn find_librs<P: AsRef<Path>>(path: P) -> Option<PathBuf> {\n     None\n }\n \n-// FIXME: move `bootstrap::util::try_run` into `build_helper` crate\n-// and use that one instead of creating this function.\n-fn try_run(cmd: &mut Command, print_cmd_on_fail: bool) -> bool {\n-    let status = match cmd.status() {\n-        Ok(status) => status,\n-        Err(e) => panic!(\"failed to execute command: {:?}\\nerror: {}\", cmd, e),\n-    };\n-    if !status.success() && print_cmd_on_fail {\n-        println!(\n-            \"\\n\\ncommand did not execute successfully: {:?}\\n\\\n-             expected success, got: {}\\n\\n\",\n-            cmd, status\n-        );\n-    }\n-    status.success()\n-}\n-\n fn main() {\n     let config = Arc::new(Config::from_args(env::args().collect()));\n \n@@ -143,6 +127,16 @@ If you want to install the `browser-ui-test` dependency, run `npm install browse\n     }\n \n     let mut command = Command::new(&config.nodejs);\n+\n+    if let Ok(current_dir) = env::current_dir() {\n+        let local_node_modules = current_dir.join(\"node_modules\");\n+        if local_node_modules.exists() {\n+            // Link the local node_modules if exists.\n+            // This is useful when we run rustdoc-gui-test from outside of the source root.\n+            env::set_var(\"NODE_PATH\", local_node_modules);\n+        }\n+    }\n+\n     command\n         .arg(config.rust_src.join(\"src/tools/rustdoc-gui/tester.js\"))\n         .arg(\"--jobs\")"}, {"sha": "24f3f43d0787444157b3082985f7c679454141a4", "filename": "tests/codegen/array-map.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/tests%2Fcodegen%2Farray-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/tests%2Fcodegen%2Farray-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Farray-map.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -4,7 +4,6 @@\n // ignore-debug (the extra assertions get in the way)\n \n #![crate_type = \"lib\"]\n-#![feature(array_zip)]\n \n // CHECK-LABEL: @short_integer_map\n #[no_mangle]\n@@ -16,16 +15,6 @@ pub fn short_integer_map(x: [u32; 8]) -> [u32; 8] {\n     x.map(|x| 2 * x + 1)\n }\n \n-// CHECK-LABEL: @short_integer_zip_map\n-#[no_mangle]\n-pub fn short_integer_zip_map(x: [u32; 8], y: [u32; 8]) -> [u32; 8] {\n-    // CHECK: %[[A:.+]] = load <8 x i32>\n-    // CHECK: %[[B:.+]] = load <8 x i32>\n-    // CHECK: sub <8 x i32> %[[B]], %[[A]]\n-    // CHECK: store <8 x i32>\n-    x.zip(y).map(|(x, y)| x - y)\n-}\n-\n // This test is checking that LLVM can SRoA away a bunch of the overhead,\n // like fully moving the iterators to registers.  Notably, previous implementations\n // of `map` ended up `alloca`ing the whole `array::IntoIterator`, meaning both a"}, {"sha": "54392be707f533f3c765f21df76d4783247a5c7d", "filename": "tests/codegen/autovectorize-f32x4.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/tests%2Fcodegen%2Fautovectorize-f32x4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/tests%2Fcodegen%2Fautovectorize-f32x4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fautovectorize-f32x4.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -1,7 +1,6 @@\n // compile-flags: -C opt-level=3 -Z merge-functions=disabled\n // only-x86_64\n #![crate_type = \"lib\"]\n-#![feature(array_zip)]\n \n // CHECK-LABEL: @auto_vectorize_direct\n #[no_mangle]\n@@ -32,12 +31,12 @@ pub fn auto_vectorize_loop(a: [f32; 4], b: [f32; 4]) -> [f32; 4] {\n     c\n }\n \n-// CHECK-LABEL: @auto_vectorize_array_zip_map\n+// CHECK-LABEL: @auto_vectorize_array_from_fn\n #[no_mangle]\n-pub fn auto_vectorize_array_zip_map(a: [f32; 4], b: [f32; 4]) -> [f32; 4] {\n+pub fn auto_vectorize_array_from_fn(a: [f32; 4], b: [f32; 4]) -> [f32; 4] {\n // CHECK: load <4 x float>\n // CHECK: load <4 x float>\n // CHECK: fadd <4 x float>\n // CHECK: store <4 x float>\n-    a.zip(b).map(|(a, b)| a + b)\n+    std::array::from_fn(|i| a[i] + b[i])\n }"}, {"sha": "1e4216d3c0cac46bd9a224114bdf51940b4ae46c", "filename": "tests/rustdoc/reexport-doc-hidden-inside-private.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/tests%2Frustdoc%2Freexport-doc-hidden-inside-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/tests%2Frustdoc%2Freexport-doc-hidden-inside-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexport-doc-hidden-inside-private.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -0,0 +1,16 @@\n+// This test ensures that a re-export of  `#[doc(hidden)]` item inside a private\n+// module will still be displayed (the re-export, not the item).\n+\n+#![crate_name = \"foo\"]\n+\n+mod private_module {\n+    #[doc(hidden)]\n+    pub struct Public;\n+}\n+\n+// @has 'foo/index.html'\n+// @has - '//*[@id=\"reexport.Foo\"]/code' 'pub use crate::private_module::Public as Foo;'\n+pub use crate::private_module::Public as Foo;\n+// Glob re-exports with no visible items should not be displayed.\n+// @count - '//*[@class=\"item-table\"]/li' 1\n+pub use crate::private_module::*;"}, {"sha": "666387e615ef2b426a66a21c6e43e539e25d7795", "filename": "tests/ui/offset-of/offset-of-unsized.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/617d3d6d722c432cdcbf210e6db55c3bdeafe381/tests%2Fui%2Foffset-of%2Foffset-of-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617d3d6d722c432cdcbf210e6db55c3bdeafe381/tests%2Fui%2Foffset-of%2Foffset-of-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foffset-of%2Foffset-of-unsized.rs?ref=617d3d6d722c432cdcbf210e6db55c3bdeafe381", "patch": "@@ -0,0 +1,15 @@\n+// build-pass\n+// regression test for #112051\n+\n+#![feature(offset_of)]\n+\n+struct S<T: ?Sized> {\n+    a: u64,\n+    b: T,\n+}\n+trait Tr {}\n+\n+fn main() {\n+    let _a = core::mem::offset_of!(S<dyn Tr>, a);\n+    let _b = core::mem::offset_of!((u64, dyn Tr), 0);\n+}"}]}