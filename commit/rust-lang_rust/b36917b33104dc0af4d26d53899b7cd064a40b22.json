{"sha": "b36917b33104dc0af4d26d53899b7cd064a40b22", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNjkxN2IzMzEwNGRjMGFmNGQyNmQ1Mzg5OWI3Y2QwNjRhNDBiMjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-18T16:37:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-18T16:37:10Z"}, "message": "Auto merge of #51460 - nikomatsakis:nll-perf-examination-refactor-1, r=pnkfelix\n\nImprove memoization and refactor NLL type check\n\nI have a big branch that is refactoring NLL type check with the goal of introducing canonicalization-based memoization for all of the operations it does. This PR contains an initial prefix of that branch which, I believe, stands alone. It does introduce a few smaller optimizations of its own:\n\n- Skip operations that are trivially a no-op\n- Cache the results of the dropck-outlives computations done by liveness\n- Skip resetting unifications if nothing changed\n\nr? @pnkfelix", "tree": {"sha": "6f781b30387cbb2d331220334840ca49feca7e15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f781b30387cbb2d331220334840ca49feca7e15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b36917b33104dc0af4d26d53899b7cd064a40b22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b36917b33104dc0af4d26d53899b7cd064a40b22", "html_url": "https://github.com/rust-lang/rust/commit/b36917b33104dc0af4d26d53899b7cd064a40b22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b36917b33104dc0af4d26d53899b7cd064a40b22/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "862703e05e275d77b0b594bb5d1a26a6340933f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/862703e05e275d77b0b594bb5d1a26a6340933f2", "html_url": "https://github.com/rust-lang/rust/commit/862703e05e275d77b0b594bb5d1a26a6340933f2"}, {"sha": "2e25bed9b1552a8af58fb3fe21d8db69a6114a18", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e25bed9b1552a8af58fb3fe21d8db69a6114a18", "html_url": "https://github.com/rust-lang/rust/commit/2e25bed9b1552a8af58fb3fe21d8db69a6114a18"}], "stats": {"total": 1166, "additions": 685, "deletions": 481}, "files": [{"sha": "296808cea2bd733fb58b3f171937cc0c9f98652e", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=b36917b33104dc0af4d26d53899b7cd064a40b22", "patch": "@@ -69,6 +69,10 @@ pub struct RegionConstraintCollector<'tcx> {\n     /// would wind up with a fresh stream of region variables that\n     /// have been equated but appear distinct.\n     unification_table: ut::UnificationTable<ut::InPlace<ty::RegionVid>>,\n+\n+    /// a flag set to true when we perform any unifications; this is used\n+    /// to micro-optimize `take_and_reset_data`\n+    any_unifications: bool,\n }\n \n pub type VarInfos = IndexVec<RegionVid, RegionVariableInfo>;\n@@ -234,6 +238,7 @@ pub struct RegionVariableInfo {\n pub struct RegionSnapshot {\n     length: usize,\n     region_snapshot: ut::Snapshot<ut::InPlace<ty::RegionVid>>,\n+    any_unifications: bool,\n }\n \n /// When working with skolemized regions, we often wish to find all of\n@@ -280,6 +285,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             bound_count: 0,\n             undo_log: Vec::new(),\n             unification_table: ut::UnificationTable::new(),\n+            any_unifications: false,\n         }\n     }\n \n@@ -325,6 +331,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             bound_count: _,\n             undo_log: _,\n             unification_table,\n+            any_unifications,\n         } = self;\n \n         // Clear the tables of (lubs, glbs), so that we will create\n@@ -338,7 +345,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         // un-unified\" state. Note that when we unify `a` and `b`, we\n         // also insert `a <= b` and a `b <= a` edges, so the\n         // `RegionConstraintData` contains the relationship here.\n-        unification_table.reset_unifications(|vid| unify_key::RegionVidKey { min_vid: vid });\n+        if *any_unifications {\n+            unification_table.reset_unifications(|vid| unify_key::RegionVidKey { min_vid: vid });\n+            *any_unifications = false;\n+        }\n \n         mem::replace(data, RegionConstraintData::default())\n     }\n@@ -358,6 +368,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         RegionSnapshot {\n             length,\n             region_snapshot: self.unification_table.snapshot(),\n+            any_unifications: self.any_unifications,\n         }\n     }\n \n@@ -385,6 +396,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         let c = self.undo_log.pop().unwrap();\n         assert!(c == OpenSnapshot);\n         self.unification_table.rollback_to(snapshot.region_snapshot);\n+        self.any_unifications = snapshot.any_unifications;\n     }\n \n     fn rollback_undo_entry(&mut self, undo_entry: UndoLogEntry<'tcx>) {\n@@ -623,6 +635,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n             if let (ty::ReVar(sub), ty::ReVar(sup)) = (*sub, *sup) {\n                 self.unification_table.union(sub, sup);\n+                self.any_unifications = true;\n             }\n         }\n     }"}, {"sha": "ad3710e9536f1af1c401821992c3fec0e23476c0", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=b36917b33104dc0af4d26d53899b7cd064a40b22", "patch": "@@ -367,6 +367,11 @@ impl<I: Idx, T> IndexVec<I, T> {\n         IndexVec { raw: Vec::new(), _marker: PhantomData }\n     }\n \n+    #[inline]\n+    pub fn from_raw(raw: Vec<T>) -> Self {\n+        IndexVec { raw, _marker: PhantomData }\n+    }\n+\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> Self {\n         IndexVec { raw: Vec::with_capacity(capacity), _marker: PhantomData }"}, {"sha": "72db9f8da987251f1e69bf71da2de0167349b1d2", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=b36917b33104dc0af4d26d53899b7cd064a40b22", "patch": "@@ -11,6 +11,8 @@\n use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n use borrow_check::nll::facts::AllFacts;\n+use borrow_check::nll::region_infer::{Cause, RegionInferenceContext};\n+use borrow_check::nll::ToRegionVid;\n use rustc::hir;\n use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n@@ -21,9 +23,7 @@ use rustc::mir::{Local, PlaceProjection, ProjectionElem, Statement, Terminator};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts};\n-\n-use super::region_infer::{Cause, RegionInferenceContext};\n-use super::ToRegionVid;\n+use std::iter;\n \n pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n@@ -32,6 +32,7 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     location_table: &LocationTable,\n     mir: &Mir<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n+    liveness_set_from_typeck: &[(ty::Region<'tcx>, Location, Cause)],\n ) {\n     let mut cg = ConstraintGeneration {\n         borrow_set,\n@@ -42,6 +43,8 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n         mir,\n     };\n \n+    cg.add_region_liveness_constraints_from_type_check(liveness_set_from_typeck);\n+\n     for (bb, data) in mir.basic_blocks().iter_enumerated() {\n         cg.visit_basic_block_data(bb, data);\n     }\n@@ -209,7 +212,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n                 self.add_reborrow_constraint(location, region, borrowed_place);\n             }\n \n-            _ => { }\n+            _ => {}\n         }\n \n         self.super_rvalue(rvalue, location);\n@@ -225,6 +228,42 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n }\n \n impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n+    /// The MIR type checker generates region liveness constraints\n+    /// that we also have to respect.\n+    fn add_region_liveness_constraints_from_type_check(\n+        &mut self,\n+        liveness_set: &[(ty::Region<'tcx>, Location, Cause)],\n+    ) {\n+        debug!(\n+            \"add_region_liveness_constraints_from_type_check(liveness_set={} items)\",\n+            liveness_set.len(),\n+        );\n+\n+        let ConstraintGeneration {\n+            regioncx,\n+            location_table,\n+            all_facts,\n+            ..\n+        } = self;\n+\n+        for (region, location, cause) in liveness_set {\n+            debug!(\"generate: {:#?} is live at {:#?}\", region, location);\n+            let region_vid = regioncx.to_region_vid(region);\n+            regioncx.add_live_point(region_vid, *location, &cause);\n+        }\n+\n+        if let Some(all_facts) = all_facts {\n+            all_facts\n+                .region_live_at\n+                .extend(liveness_set.into_iter().flat_map(|(region, location, _)| {\n+                    let r = regioncx.to_region_vid(region);\n+                    let p1 = location_table.start_index(*location);\n+                    let p2 = location_table.mid_index(*location);\n+                    iter::once((r, p1)).chain(iter::once((r, p2)))\n+                }));\n+        }\n+    }\n+\n     /// Some variable with type `live_ty` is \"regular live\" at\n     /// `location` -- i.e., it may be used later. This means that all\n     /// regions appearing in the type `live_ty` must be live at"}, {"sha": "dcb52a3b18a724cf2829b9a5653471815ea2625d", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=b36917b33104dc0af4d26d53899b7cd064a40b22", "patch": "@@ -11,6 +11,7 @@\n use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::{LocationIndex, LocationTable};\n use borrow_check::nll::facts::AllFactsExt;\n+use borrow_check::nll::type_check::MirTypeckRegionConstraints;\n use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n@@ -41,7 +42,6 @@ mod facts;\n mod invalidation;\n crate mod region_infer;\n mod renumber;\n-mod subtype_constraint_generation;\n crate mod type_check;\n mod universal_regions;\n \n@@ -91,53 +91,61 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex>>>,\n     Option<ClosureRegionRequirements<'gcx>>,\n ) {\n+    let mut all_facts = if infcx.tcx.sess.opts.debugging_opts.nll_facts\n+        || infcx.tcx.sess.opts.debugging_opts.polonius\n+    {\n+        Some(AllFacts::default())\n+    } else {\n+        None\n+    };\n+\n     // Run the MIR type-checker.\n     let liveness = &LivenessResults::compute(mir);\n-    let constraint_sets = &type_check::type_check(\n+    let constraint_sets = type_check::type_check(\n         infcx,\n         param_env,\n         mir,\n         def_id,\n         &universal_regions,\n+        location_table,\n         &liveness,\n+        &mut all_facts,\n         flow_inits,\n         move_data,\n     );\n \n-    let mut all_facts = if infcx.tcx.sess.opts.debugging_opts.nll_facts\n-        || infcx.tcx.sess.opts.debugging_opts.polonius\n-    {\n-        Some(AllFacts::default())\n-    } else {\n-        None\n-    };\n-\n     if let Some(all_facts) = &mut all_facts {\n         all_facts\n             .universal_region\n             .extend(universal_regions.universal_regions());\n     }\n \n-    // Create the region inference context, taking ownership of the region inference\n-    // data that was contained in `infcx`.\n+    // Create the region inference context, taking ownership of the\n+    // region inference data that was contained in `infcx`, and the\n+    // base constraints generated by the type-check.\n     let var_origins = infcx.take_region_var_origins();\n-    let mut regioncx = RegionInferenceContext::new(var_origins, universal_regions, mir);\n-\n-    // Generate various constraints.\n-    subtype_constraint_generation::generate(\n-        &mut regioncx,\n-        &mut all_facts,\n-        location_table,\n+    let MirTypeckRegionConstraints {\n+        liveness_set,\n+        outlives_constraints,\n+        type_tests,\n+    } = constraint_sets;\n+    let mut regioncx = RegionInferenceContext::new(\n+        var_origins,\n+        universal_regions,\n         mir,\n-        constraint_sets,\n+        outlives_constraints,\n+        type_tests,\n     );\n+\n+    // Generate various additional constraints.\n     constraint_generation::generate_constraints(\n         infcx,\n         &mut regioncx,\n         &mut all_facts,\n         location_table,\n         &mir,\n         borrow_set,\n+        &liveness_set,\n     );\n     invalidation::generate_invalidates(\n         infcx,"}, {"sha": "6c796ea4c73abe66195dd0d9e533e9ff2bf2721e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=b36917b33104dc0af4d26d53899b7cd064a40b22", "patch": "@@ -14,7 +14,7 @@\n //! context internal state.\n \n use std::io::{self, Write};\n-use super::{Constraint, RegionInferenceContext};\n+use super::{OutlivesConstraint, RegionInferenceContext};\n \n // Room for \"'_#NNNNr\" before things get misaligned.\n // Easy enough to fix if this ever doesn't seem like\n@@ -79,7 +79,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mut constraints: Vec<_> = self.constraints.iter().collect();\n         constraints.sort();\n         for constraint in &constraints {\n-            let Constraint {\n+            let OutlivesConstraint {\n                 sup,\n                 sub,\n                 point,"}, {"sha": "c02e4ff315687f54ef59bf1790d24656c9974309", "filename": "src/librustc_mir/borrow_check/nll/region_infer/graphviz.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs?ref=b36917b33104dc0af4d26d53899b7cd064a40b22", "patch": "@@ -27,7 +27,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n impl<'this, 'tcx> dot::Labeller<'this> for RegionInferenceContext<'tcx> {\n     type Node = RegionVid;\n-    type Edge = Constraint;\n+    type Edge = OutlivesConstraint;\n \n     fn graph_id(&'this self) -> dot::Id<'this> {\n         dot::Id::new(format!(\"RegionInferenceContext\")).unwrap()\n@@ -41,31 +41,31 @@ impl<'this, 'tcx> dot::Labeller<'this> for RegionInferenceContext<'tcx> {\n     fn node_label(&'this self, n: &RegionVid) -> dot::LabelText<'this> {\n         dot::LabelText::LabelStr(format!(\"{:?}\", n).into_cow())\n     }\n-    fn edge_label(&'this self, e: &Constraint) -> dot::LabelText<'this> {\n+    fn edge_label(&'this self, e: &OutlivesConstraint) -> dot::LabelText<'this> {\n         dot::LabelText::LabelStr(format!(\"{:?}\", e.point).into_cow())\n     }\n }\n \n impl<'this, 'tcx> dot::GraphWalk<'this> for RegionInferenceContext<'tcx> {\n     type Node = RegionVid;\n-    type Edge = Constraint;\n+    type Edge = OutlivesConstraint;\n \n     fn nodes(&'this self) -> dot::Nodes<'this, RegionVid> {\n         let vids: Vec<RegionVid> = self.definitions.indices().collect();\n         vids.into_cow()\n     }\n-    fn edges(&'this self) -> dot::Edges<'this, Constraint> {\n+    fn edges(&'this self) -> dot::Edges<'this, OutlivesConstraint> {\n         (&self.constraints.raw[..]).into_cow()\n     }\n \n     // Render `a: b` as `a <- b`, indicating the flow\n     // of data during inference.\n \n-    fn source(&'this self, edge: &Constraint) -> RegionVid {\n+    fn source(&'this self, edge: &OutlivesConstraint) -> RegionVid {\n         edge.sub\n     }\n \n-    fn target(&'this self, edge: &Constraint) -> RegionVid {\n+    fn target(&'this self, edge: &OutlivesConstraint) -> RegionVid {\n         edge.sup\n     }\n }"}, {"sha": "0eeacda467e03336ceac4d643d01beeae507ba7d", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=b36917b33104dc0af4d26d53899b7cd064a40b22", "patch": "@@ -68,7 +68,7 @@ pub struct RegionInferenceContext<'tcx> {\n     dependency_map: Option<IndexVec<RegionVid, Option<ConstraintIndex>>>,\n \n     /// The constraints we have accumulated and used during solving.\n-    constraints: IndexVec<ConstraintIndex, Constraint>,\n+    constraints: IndexVec<ConstraintIndex, OutlivesConstraint>,\n \n     /// Type constraints that we check after solving.\n     type_tests: Vec<TypeTest<'tcx>>,\n@@ -118,19 +118,19 @@ pub(crate) enum Cause {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct Constraint {\n+pub struct OutlivesConstraint {\n     // NB. The ordering here is not significant for correctness, but\n     // it is for convenience. Before we dump the constraints in the\n     // debugging logs, we sort them, and we'd like the \"super region\"\n     // to be first, etc. (In particular, span should remain last.)\n     /// The region SUP must outlive SUB...\n-    sup: RegionVid,\n+    pub sup: RegionVid,\n \n     /// Region that must be outlived.\n-    sub: RegionVid,\n+    pub sub: RegionVid,\n \n     /// At this location.\n-    point: Location,\n+    pub point: Location,\n \n     /// Later on, we thread the constraints onto a linked list\n     /// grouped by their `sub` field. So if you had:\n@@ -140,10 +140,10 @@ pub struct Constraint {\n     /// 0     | `'a: 'b`   | Some(2)\n     /// 1     | `'b: 'c`   | None\n     /// 2     | `'c: 'b`   | None\n-    next: Option<ConstraintIndex>,\n+    pub next: Option<ConstraintIndex>,\n \n     /// Where did this constraint arise?\n-    span: Span,\n+    pub span: Span,\n }\n \n newtype_index!(ConstraintIndex { DEBUG_FORMAT = \"ConstraintIndex({})\" });\n@@ -239,11 +239,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// `num_region_variables` valid inference variables; the first N\n     /// of those will be constant regions representing the free\n     /// regions defined in `universal_regions`.\n+    ///\n+    /// The `outlives_constraints` and `type_tests` are an initial set\n+    /// of constraints produced by the MIR type check.\n     pub(crate) fn new(\n         var_infos: VarInfos,\n         universal_regions: UniversalRegions<'tcx>,\n         mir: &Mir<'tcx>,\n+        outlives_constraints: Vec<OutlivesConstraint>,\n+        type_tests: Vec<TypeTest<'tcx>>,\n     ) -> Self {\n+        // The `next` field should not yet have been initialized:\n+        debug_assert!(outlives_constraints.iter().all(|c| c.next.is_none()));\n+\n         let num_region_variables = var_infos.len();\n         let num_universal_regions = universal_regions.len();\n \n@@ -261,8 +269,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             liveness_constraints: RegionValues::new(elements, num_region_variables),\n             inferred_values: None,\n             dependency_map: None,\n-            constraints: IndexVec::new(),\n-            type_tests: Vec::new(),\n+            constraints: IndexVec::from_raw(outlives_constraints),\n+            type_tests,\n             universal_regions,\n         };\n \n@@ -345,15 +353,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     where\n         R: ToRegionVid,\n     {\n-        let inferred_values = self.inferred_values\n+        let inferred_values = self\n+            .inferred_values\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n         inferred_values.contains(r.to_region_vid(), p)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n     crate fn region_value_str(&self, r: RegionVid) -> String {\n-        let inferred_values = self.inferred_values\n+        let inferred_values = self\n+            .inferred_values\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n \n@@ -387,7 +397,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) {\n         debug!(\"add_outlives({:?}: {:?} @ {:?}\", sup, sub, point);\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n-        self.constraints.push(Constraint {\n+        self.constraints.push(OutlivesConstraint {\n             span,\n             sup,\n             sub,\n@@ -396,11 +406,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         });\n     }\n \n-    /// Add a \"type test\" that must be satisfied.\n-    pub(super) fn add_type_test(&mut self, type_test: TypeTest<'tcx>) {\n-        self.type_tests.push(type_test);\n-    }\n-\n     /// Perform region inference and report errors if we see any\n     /// unsatisfiable constraints. If this is a closure, returns the\n     /// region requirements to propagate to our creator, if any.\n@@ -465,7 +470,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.inferred_values = Some(inferred_values);\n     }\n \n-    #[inline(never)] // ensure dfs is identifiable in profiles\n     fn compute_region_values(&self, _mir: &Mir<'tcx>) -> RegionValues {\n         debug!(\"compute_region_values()\");\n         debug!(\"compute_region_values: constraints={:#?}\", {\n@@ -516,7 +520,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// indices of constraints that need to be re-evaluated when X changes.\n     /// These are constraints like Y: X @ P -- so if X changed, we may\n     /// need to grow Y.\n-    #[inline(never)] // ensure dfs is identifiable in profiles\n     fn build_dependency_map(&mut self) -> IndexVec<RegionVid, Option<ConstraintIndex>> {\n         let mut map = IndexVec::from_elem(None, &self.definitions);\n \n@@ -595,7 +598,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         if self.universal_regions.is_universal_region(r) {\n             return self.definitions[r].external_name;\n         } else {\n-            let inferred_values = self.inferred_values\n+            let inferred_values = self\n+                .inferred_values\n                 .as_ref()\n                 .expect(\"region values not yet inferred\");\n             let upper_bound = self.universal_upper_bound(r);\n@@ -634,8 +638,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // region, which ensures it can be encoded in a `ClosureOutlivesRequirement`.\n         let lower_bound_plus = self.non_local_universal_upper_bound(*lower_bound);\n         assert!(self.universal_regions.is_universal_region(lower_bound_plus));\n-        assert!(!self.universal_regions\n-            .is_local_free_region(lower_bound_plus));\n+        assert!(\n+            !self\n+                .universal_regions\n+                .is_local_free_region(lower_bound_plus)\n+        );\n \n         propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n             subject,\n@@ -663,7 +670,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<ClosureOutlivesSubject<'gcx>> {\n         let tcx = infcx.tcx;\n         let gcx = tcx.global_tcx();\n-        let inferred_values = self.inferred_values\n+        let inferred_values = self\n+            .inferred_values\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n \n@@ -844,7 +852,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             sup_region, sub_region, point\n         );\n \n-        let inferred_values = self.inferred_values\n+        let inferred_values = self\n+            .inferred_values\n             .as_ref()\n             .expect(\"values for regions not yet inferred\");\n \n@@ -911,7 +920,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) {\n         // The universal regions are always found in a prefix of the\n         // full list.\n-        let universal_definitions = self.definitions\n+        let universal_definitions = self\n+            .definitions\n             .iter_enumerated()\n             .take_while(|(_, fr_definition)| fr_definition.is_universal);\n \n@@ -1139,7 +1149,7 @@ impl<'tcx> RegionDefinition<'tcx> {\n     }\n }\n \n-impl fmt::Debug for Constraint {\n+impl fmt::Debug for OutlivesConstraint {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n         write!(\n             formatter,"}, {"sha": "9db19085a39654b630dc4833d9a4b09fb2c45c70", "filename": "src/librustc_mir/borrow_check/nll/subtype_constraint_generation.rs", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/862703e05e275d77b0b594bb5d1a26a6340933f2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs?ref=862703e05e275d77b0b594bb5d1a26a6340933f2", "patch": "@@ -1,199 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use borrow_check::location::LocationTable;\n-use borrow_check::nll::facts::AllFacts;\n-use rustc::infer::region_constraints::Constraint;\n-use rustc::infer::region_constraints::RegionConstraintData;\n-use rustc::infer::region_constraints::{Verify, VerifyBound};\n-use rustc::mir::{Location, Mir};\n-use rustc::ty;\n-use std::iter;\n-use syntax::codemap::Span;\n-\n-use super::region_infer::{RegionInferenceContext, RegionTest, TypeTest};\n-use super::type_check::Locations;\n-use super::type_check::MirTypeckRegionConstraints;\n-use super::type_check::OutlivesSet;\n-\n-/// When the MIR type-checker executes, it validates all the types in\n-/// the MIR, and in the process generates a set of constraints that\n-/// must hold regarding the regions in the MIR, along with locations\n-/// *where* they must hold. This code takes those constriants and adds\n-/// them into the NLL `RegionInferenceContext`.\n-pub(super) fn generate<'tcx>(\n-    regioncx: &mut RegionInferenceContext<'tcx>,\n-    all_facts: &mut Option<AllFacts>,\n-    location_table: &LocationTable,\n-    mir: &Mir<'tcx>,\n-    constraints: &MirTypeckRegionConstraints<'tcx>,\n-) {\n-    SubtypeConstraintGenerator {\n-        regioncx,\n-        location_table,\n-        mir,\n-    }.generate(constraints, all_facts);\n-}\n-\n-struct SubtypeConstraintGenerator<'cx, 'tcx: 'cx> {\n-    regioncx: &'cx mut RegionInferenceContext<'tcx>,\n-    location_table: &'cx LocationTable,\n-    mir: &'cx Mir<'tcx>,\n-}\n-\n-impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n-    fn generate(\n-        &mut self,\n-        constraints: &MirTypeckRegionConstraints<'tcx>,\n-        all_facts: &mut Option<AllFacts>,\n-    ) {\n-        let MirTypeckRegionConstraints {\n-            liveness_set,\n-            outlives_sets,\n-        } = constraints;\n-\n-        debug!(\n-            \"generate(liveness_set={} items, outlives_sets={} items)\",\n-            liveness_set.len(),\n-            outlives_sets.len()\n-        );\n-\n-        for (region, location, cause) in liveness_set {\n-            debug!(\"generate: {:#?} is live at {:#?}\", region, location);\n-            let region_vid = self.to_region_vid(region);\n-            self.regioncx.add_live_point(region_vid, *location, &cause);\n-        }\n-\n-        if let Some(all_facts) = all_facts {\n-            all_facts\n-                .region_live_at\n-                .extend(liveness_set.into_iter().flat_map(|(region, location, _)| {\n-                    let r = self.to_region_vid(region);\n-                    let p1 = self.location_table.start_index(*location);\n-                    let p2 = self.location_table.mid_index(*location);\n-                    iter::once((r, p1)).chain(iter::once((r, p2)))\n-                }));\n-        }\n-\n-        for OutlivesSet { locations, data } in outlives_sets {\n-            debug!(\"generate: constraints at: {:#?}\", locations);\n-            let RegionConstraintData {\n-                constraints,\n-                verifys,\n-                givens,\n-            } = data;\n-\n-            let span = self.mir\n-                .source_info(locations.from_location().unwrap_or(Location::START))\n-                .span;\n-\n-            let at_location = locations.at_location().unwrap_or(Location::START);\n-\n-            for constraint in constraints.keys() {\n-                debug!(\"generate: constraint: {:?}\", constraint);\n-                let (a_vid, b_vid) = match constraint {\n-                    Constraint::VarSubVar(a_vid, b_vid) => (*a_vid, *b_vid),\n-                    Constraint::RegSubVar(a_r, b_vid) => (self.to_region_vid(a_r), *b_vid),\n-                    Constraint::VarSubReg(a_vid, b_r) => (*a_vid, self.to_region_vid(b_r)),\n-                    Constraint::RegSubReg(a_r, b_r) => {\n-                        (self.to_region_vid(a_r), self.to_region_vid(b_r))\n-                    }\n-                };\n-\n-                // We have the constraint that `a_vid <= b_vid`. Add\n-                // `b_vid: a_vid` to our region checker. Note that we\n-                // reverse direction, because `regioncx` talks about\n-                // \"outlives\" (`>=`) whereas the region constraints\n-                // talk about `<=`.\n-                self.regioncx.add_outlives(span, b_vid, a_vid, at_location);\n-\n-                // In the new analysis, all outlives relations etc\n-                // \"take effect\" at the mid point of the statement\n-                // that requires them, so ignore the `at_location`.\n-                if let Some(all_facts) = all_facts {\n-                    if let Some(from_location) = locations.from_location() {\n-                        all_facts.outlives.push((\n-                            b_vid,\n-                            a_vid,\n-                            self.location_table.mid_index(from_location),\n-                        ));\n-                    } else {\n-                        for location in self.location_table.all_points() {\n-                            all_facts.outlives.push((b_vid, a_vid, location));\n-                        }\n-                    }\n-                }\n-            }\n-\n-            for verify in verifys {\n-                let type_test = self.verify_to_type_test(verify, span, locations);\n-                self.regioncx.add_type_test(type_test);\n-            }\n-\n-            assert!(\n-                givens.is_empty(),\n-                \"MIR type-checker does not use givens (thank goodness)\"\n-            );\n-        }\n-    }\n-\n-    fn verify_to_type_test(\n-        &self,\n-        verify: &Verify<'tcx>,\n-        span: Span,\n-        locations: &Locations,\n-    ) -> TypeTest<'tcx> {\n-        let generic_kind = verify.kind;\n-\n-        let lower_bound = self.to_region_vid(verify.region);\n-\n-        let point = locations.at_location().unwrap_or(Location::START);\n-\n-        let test = self.verify_bound_to_region_test(&verify.bound);\n-\n-        TypeTest {\n-            generic_kind,\n-            lower_bound,\n-            point,\n-            span,\n-            test,\n-        }\n-    }\n-\n-    fn verify_bound_to_region_test(&self, verify_bound: &VerifyBound<'tcx>) -> RegionTest {\n-        match verify_bound {\n-            VerifyBound::AnyRegion(regions) => RegionTest::IsOutlivedByAnyRegionIn(\n-                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n-            ),\n-\n-            VerifyBound::AllRegions(regions) => RegionTest::IsOutlivedByAllRegionsIn(\n-                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n-            ),\n-\n-            VerifyBound::AnyBound(bounds) => RegionTest::Any(\n-                bounds\n-                    .iter()\n-                    .map(|b| self.verify_bound_to_region_test(b))\n-                    .collect(),\n-            ),\n-\n-            VerifyBound::AllBounds(bounds) => RegionTest::All(\n-                bounds\n-                    .iter()\n-                    .map(|b| self.verify_bound_to_region_test(b))\n-                    .collect(),\n-            ),\n-        }\n-    }\n-\n-    fn to_region_vid(&self, r: ty::Region<'tcx>) -> ty::RegionVid {\n-        self.regioncx.to_region_vid(r)\n-    }\n-}"}, {"sha": "06aaf6810faa3662984ba0dab079f57420e69579", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=b36917b33104dc0af4d26d53899b7cd064a40b22", "patch": "@@ -0,0 +1,190 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::location::LocationTable;\n+use borrow_check::nll::facts::AllFacts;\n+use borrow_check::nll::region_infer::{OutlivesConstraint, RegionTest, TypeTest};\n+use borrow_check::nll::type_check::Locations;\n+use borrow_check::nll::universal_regions::UniversalRegions;\n+use rustc::infer::region_constraints::Constraint;\n+use rustc::infer::region_constraints::RegionConstraintData;\n+use rustc::infer::region_constraints::{Verify, VerifyBound};\n+use rustc::mir::{Location, Mir};\n+use rustc::ty;\n+use syntax::codemap::Span;\n+\n+crate struct ConstraintConversion<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    universal_regions: &'a UniversalRegions<'tcx>,\n+    location_table: &'a LocationTable,\n+    outlives_constraints: &'a mut Vec<OutlivesConstraint>,\n+    type_tests: &'a mut Vec<TypeTest<'tcx>>,\n+    all_facts: &'a mut Option<AllFacts>,\n+\n+}\n+\n+impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n+    crate fn new(\n+        mir: &'a Mir<'tcx>,\n+        universal_regions: &'a UniversalRegions<'tcx>,\n+        location_table: &'a LocationTable,\n+        outlives_constraints: &'a mut Vec<OutlivesConstraint>,\n+        type_tests: &'a mut Vec<TypeTest<'tcx>>,\n+        all_facts: &'a mut Option<AllFacts>,\n+    ) -> Self {\n+        Self {\n+            mir,\n+            universal_regions,\n+            location_table,\n+            outlives_constraints,\n+            type_tests,\n+            all_facts,\n+        }\n+    }\n+\n+    crate fn convert(\n+        &mut self,\n+        locations: Locations,\n+        data: &RegionConstraintData<'tcx>,\n+    ) {\n+        debug!(\"generate: constraints at: {:#?}\", locations);\n+        let RegionConstraintData {\n+            constraints,\n+            verifys,\n+            givens,\n+        } = data;\n+\n+        let span = self\n+            .mir\n+            .source_info(locations.from_location().unwrap_or(Location::START))\n+            .span;\n+\n+        let at_location = locations.at_location().unwrap_or(Location::START);\n+\n+        for constraint in constraints.keys() {\n+            debug!(\"generate: constraint: {:?}\", constraint);\n+            let (a_vid, b_vid) = match constraint {\n+                Constraint::VarSubVar(a_vid, b_vid) => (*a_vid, *b_vid),\n+                Constraint::RegSubVar(a_r, b_vid) => (self.to_region_vid(a_r), *b_vid),\n+                Constraint::VarSubReg(a_vid, b_r) => (*a_vid, self.to_region_vid(b_r)),\n+                Constraint::RegSubReg(a_r, b_r) => {\n+                    (self.to_region_vid(a_r), self.to_region_vid(b_r))\n+                }\n+            };\n+\n+            // We have the constraint that `a_vid <= b_vid`. Add\n+            // `b_vid: a_vid` to our region checker. Note that we\n+            // reverse direction, because `regioncx` talks about\n+            // \"outlives\" (`>=`) whereas the region constraints\n+            // talk about `<=`.\n+            self.add_outlives(span, b_vid, a_vid, at_location);\n+\n+            // In the new analysis, all outlives relations etc\n+            // \"take effect\" at the mid point of the statement\n+            // that requires them, so ignore the `at_location`.\n+            if let Some(all_facts) = &mut self.all_facts {\n+                if let Some(from_location) = locations.from_location() {\n+                    all_facts.outlives.push((\n+                        b_vid,\n+                        a_vid,\n+                        self.location_table.mid_index(from_location),\n+                    ));\n+                } else {\n+                    for location in self.location_table.all_points() {\n+                        all_facts.outlives.push((b_vid, a_vid, location));\n+                    }\n+                }\n+            }\n+        }\n+\n+        for verify in verifys {\n+            let type_test = self.verify_to_type_test(verify, span, locations);\n+            self.add_type_test(type_test);\n+        }\n+\n+        assert!(\n+            givens.is_empty(),\n+            \"MIR type-checker does not use givens (thank goodness)\"\n+        );\n+    }\n+\n+    fn verify_to_type_test(\n+        &self,\n+        verify: &Verify<'tcx>,\n+        span: Span,\n+        locations: Locations,\n+    ) -> TypeTest<'tcx> {\n+        let generic_kind = verify.kind;\n+\n+        let lower_bound = self.to_region_vid(verify.region);\n+\n+        let point = locations.at_location().unwrap_or(Location::START);\n+\n+        let test = self.verify_bound_to_region_test(&verify.bound);\n+\n+        TypeTest {\n+            generic_kind,\n+            lower_bound,\n+            point,\n+            span,\n+            test,\n+        }\n+    }\n+\n+    fn verify_bound_to_region_test(&self, verify_bound: &VerifyBound<'tcx>) -> RegionTest {\n+        match verify_bound {\n+            VerifyBound::AnyRegion(regions) => RegionTest::IsOutlivedByAnyRegionIn(\n+                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n+            ),\n+\n+            VerifyBound::AllRegions(regions) => RegionTest::IsOutlivedByAllRegionsIn(\n+                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n+            ),\n+\n+            VerifyBound::AnyBound(bounds) => RegionTest::Any(\n+                bounds\n+                    .iter()\n+                    .map(|b| self.verify_bound_to_region_test(b))\n+                    .collect(),\n+            ),\n+\n+            VerifyBound::AllBounds(bounds) => RegionTest::All(\n+                bounds\n+                    .iter()\n+                    .map(|b| self.verify_bound_to_region_test(b))\n+                    .collect(),\n+            ),\n+        }\n+    }\n+\n+    fn to_region_vid(&self, r: ty::Region<'tcx>) -> ty::RegionVid {\n+        self.universal_regions.to_region_vid(r)\n+    }\n+\n+    fn add_outlives(\n+        &mut self,\n+        span: Span,\n+        sup: ty::RegionVid,\n+        sub: ty::RegionVid,\n+        point: Location,\n+    ) {\n+        self.outlives_constraints.push(OutlivesConstraint {\n+            span,\n+            sub,\n+            sup,\n+            point,\n+            next: None,\n+        });\n+    }\n+\n+    fn add_type_test(&mut self, type_test: TypeTest<'tcx>) {\n+        self.type_tests.push(type_test);\n+    }\n+}"}, {"sha": "d44eed65201cd91112c3ed96ffd607a9a6b8875f", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 78, "deletions": 64, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=b36917b33104dc0af4d26d53899b7cd064a40b22", "patch": "@@ -21,11 +21,11 @@ use borrow_check::nll::renumber;\n use borrow_check::nll::universal_regions::UniversalRegions;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferOk;\n-use rustc::ty::Ty;\n-use rustc::ty::subst::Subst;\n-use rustc::mir::*;\n use rustc::mir::visit::TyContext;\n-use rustc::traits::PredicateObligations;\n+use rustc::mir::*;\n+use rustc::traits::{ObligationCause, PredicateObligations};\n+use rustc::ty::subst::Subst;\n+use rustc::ty::Ty;\n \n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -56,8 +56,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n \n         assert!(\n-            mir.yield_ty.is_some() && universal_regions.yield_ty.is_some() ||\n-            mir.yield_ty.is_none() && universal_regions.yield_ty.is_none()\n+            mir.yield_ty.is_some() && universal_regions.yield_ty.is_some()\n+                || mir.yield_ty.is_none() && universal_regions.yield_ty.is_none()\n         );\n         if let Some(mir_yield_ty) = mir.yield_ty {\n             let ur_yield_ty = universal_regions.yield_ty.unwrap();\n@@ -76,57 +76,67 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             output_ty\n         );\n         let mir_output_ty = mir.local_decls[RETURN_PLACE].ty;\n-        let anon_type_map = self.fully_perform_op(Locations::All, |cx| {\n-            let mut obligations = ObligationAccumulator::default();\n-\n-            let (output_ty, anon_type_map) = obligations.add(infcx.instantiate_anon_types(\n-                mir_def_id,\n-                cx.body_id,\n-                cx.param_env,\n-                &output_ty,\n-            ));\n-            debug!(\n-                \"equate_inputs_and_outputs: instantiated output_ty={:?}\",\n-                output_ty\n-            );\n-            debug!(\n-                \"equate_inputs_and_outputs: anon_type_map={:#?}\",\n-                anon_type_map\n-            );\n-\n-            debug!(\n-                \"equate_inputs_and_outputs: mir_output_ty={:?}\",\n-                mir_output_ty\n-            );\n-            obligations.add(infcx\n-                .at(&cx.misc(cx.last_span), cx.param_env)\n-                .eq(output_ty, mir_output_ty)?);\n-\n-            for (&anon_def_id, anon_decl) in &anon_type_map {\n-                let anon_defn_ty = tcx.type_of(anon_def_id);\n-                let anon_defn_ty = anon_defn_ty.subst(tcx, anon_decl.substs);\n-                let anon_defn_ty = renumber::renumber_regions(\n-                    cx.infcx,\n-                    TyContext::Location(Location::START),\n-                    &anon_defn_ty,\n-                );\n-                debug!(\n-                    \"equate_inputs_and_outputs: concrete_ty={:?}\",\n-                    anon_decl.concrete_ty\n-                );\n-                debug!(\"equate_inputs_and_outputs: anon_defn_ty={:?}\", anon_defn_ty);\n-                obligations.add(infcx\n-                    .at(&cx.misc(cx.last_span), cx.param_env)\n-                    .eq(anon_decl.concrete_ty, anon_defn_ty)?);\n-            }\n-\n-            debug!(\"equate_inputs_and_outputs: equated\");\n-\n-            Ok(InferOk {\n-                value: Some(anon_type_map),\n-                obligations: obligations.into_vec(),\n-            })\n-        }).unwrap_or_else(|terr| {\n+        let anon_type_map =\n+            self.fully_perform_op(\n+                Locations::All,\n+                || format!(\"input_output\"),\n+                |cx| {\n+                    let mut obligations = ObligationAccumulator::default();\n+\n+                    let dummy_body_id = ObligationCause::dummy().body_id;\n+                    let (output_ty, anon_type_map) = obligations.add(infcx.instantiate_anon_types(\n+                        mir_def_id,\n+                        dummy_body_id,\n+                        cx.param_env,\n+                        &output_ty,\n+                    ));\n+                    debug!(\n+                        \"equate_inputs_and_outputs: instantiated output_ty={:?}\",\n+                        output_ty\n+                    );\n+                    debug!(\n+                        \"equate_inputs_and_outputs: anon_type_map={:#?}\",\n+                        anon_type_map\n+                    );\n+\n+                    debug!(\n+                        \"equate_inputs_and_outputs: mir_output_ty={:?}\",\n+                        mir_output_ty\n+                    );\n+                    obligations.add(\n+                        infcx\n+                            .at(&ObligationCause::dummy(), cx.param_env)\n+                            .eq(output_ty, mir_output_ty)?,\n+                    );\n+\n+                    for (&anon_def_id, anon_decl) in &anon_type_map {\n+                        let anon_defn_ty = tcx.type_of(anon_def_id);\n+                        let anon_defn_ty = anon_defn_ty.subst(tcx, anon_decl.substs);\n+                        let anon_defn_ty = renumber::renumber_regions(\n+                            cx.infcx,\n+                            TyContext::Location(Location::START),\n+                            &anon_defn_ty,\n+                        );\n+                        debug!(\n+                            \"equate_inputs_and_outputs: concrete_ty={:?}\",\n+                            anon_decl.concrete_ty\n+                        );\n+                        debug!(\"equate_inputs_and_outputs: anon_defn_ty={:?}\", anon_defn_ty);\n+                        obligations.add(\n+                            infcx\n+                                .at(&ObligationCause::dummy(), cx.param_env)\n+                                .eq(anon_decl.concrete_ty, anon_defn_ty)?,\n+                        );\n+                    }\n+\n+                    debug!(\"equate_inputs_and_outputs: equated\");\n+\n+                    Ok(InferOk {\n+                        value: Some(anon_type_map),\n+                        obligations: obligations.into_vec(),\n+                    })\n+                },\n+            ).unwrap_or_else(|terr| {\n                 span_mirbug!(\n                     self,\n                     Location::START,\n@@ -143,13 +153,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         // prove that `T: Iterator` where `T` is the type we\n         // instantiated it with).\n         if let Some(anon_type_map) = anon_type_map {\n-            self.fully_perform_op(Locations::All, |_cx| {\n-                infcx.constrain_anon_types(&anon_type_map, universal_regions);\n-                Ok(InferOk {\n-                    value: (),\n-                    obligations: vec![],\n-                })\n-            }).unwrap();\n+            self.fully_perform_op(\n+                Locations::All,\n+                || format!(\"anon_type_map\"),\n+                |_cx| {\n+                    infcx.constrain_anon_types(&anon_type_map, universal_regions);\n+                    Ok(InferOk {\n+                        value: (),\n+                        obligations: vec![],\n+                    })\n+                },\n+            ).unwrap();\n         }\n     }\n "}, {"sha": "80f5fe4184f9db508757dd51fd05f566fce0d1f1", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 61, "deletions": 52, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=b36917b33104dc0af4d26d53899b7cd064a40b22", "patch": "@@ -8,15 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dataflow::{FlowAtLocation, FlowsAtLocation};\n use borrow_check::nll::region_infer::Cause;\n-use dataflow::MaybeInitializedPlaces;\n+use borrow_check::nll::type_check::AtLocation;\n use dataflow::move_paths::{HasMoveData, MoveData};\n-use rustc::mir::{BasicBlock, Location, Mir};\n+use dataflow::MaybeInitializedPlaces;\n+use dataflow::{FlowAtLocation, FlowsAtLocation};\n+use rustc::infer::region_constraints::RegionConstraintData;\n use rustc::mir::Local;\n-use rustc::ty::{Ty, TyCtxt, TypeFoldable};\n-use rustc::infer::InferOk;\n-use borrow_check::nll::type_check::AtLocation;\n+use rustc::mir::{BasicBlock, Location, Mir};\n+use rustc::traits::ObligationCause;\n+use rustc::ty::subst::Kind;\n+use rustc::ty::{Ty, TypeFoldable};\n+use rustc_data_structures::fx::FxHashMap;\n+use std::rc::Rc;\n use util::liveness::LivenessResults;\n \n use super::TypeChecker;\n@@ -36,14 +40,13 @@ pub(super) fn generate<'gcx, 'tcx>(\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) {\n-    let tcx = cx.tcx();\n     let mut generator = TypeLivenessGenerator {\n         cx,\n-        tcx,\n         mir,\n         liveness,\n         flow_inits,\n         move_data,\n+        drop_data: FxHashMap(),\n     };\n \n     for bb in mir.basic_blocks().indices() {\n@@ -59,11 +62,16 @@ where\n     'gcx: 'tcx,\n {\n     cx: &'gen mut TypeChecker<'typeck, 'gcx, 'tcx>,\n-    tcx: TyCtxt<'typeck, 'gcx, 'tcx>,\n     mir: &'gen Mir<'tcx>,\n     liveness: &'gen LivenessResults,\n     flow_inits: &'gen mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n     move_data: &'gen MoveData<'tcx>,\n+    drop_data: FxHashMap<Ty<'tcx>, DropData<'tcx>>,\n+}\n+\n+struct DropData<'tcx> {\n+    dropped_kinds: Vec<Kind<'tcx>>,\n+    region_constraint_data: Option<Rc<RegionConstraintData<'tcx>>>,\n }\n \n impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx> {\n@@ -80,7 +88,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n                 for live_local in live_locals.iter() {\n                     let live_local_ty = self.mir.local_decls[live_local].ty;\n                     let cause = Cause::LiveVar(live_local, location);\n-                    self.push_type_live_constraint(live_local_ty, location, cause);\n+                    Self::push_type_live_constraint(&mut self.cx, live_local_ty, location, cause);\n                 }\n             });\n \n@@ -148,17 +156,21 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n     /// `location` -- i.e., it may be used later. This means that all\n     /// regions appearing in the type `live_ty` must be live at\n     /// `location`.\n-    fn push_type_live_constraint<T>(&mut self, value: T, location: Location, cause: Cause)\n-    where\n+    fn push_type_live_constraint<T>(\n+        cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n+        value: T,\n+        location: Location,\n+        cause: Cause,\n+    ) where\n         T: TypeFoldable<'tcx>,\n     {\n         debug!(\n             \"push_type_live_constraint(live_ty={:?}, location={:?})\",\n             value, location\n         );\n \n-        self.tcx.for_each_free_region(&value, |live_region| {\n-            self.cx\n+        cx.tcx().for_each_free_region(&value, |live_region| {\n+            cx\n                 .constraints\n                 .liveness_set\n                 .push((live_region, location, cause.clone()));\n@@ -181,47 +193,44 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n             dropped_local, dropped_ty, location\n         );\n \n-        // If we end visiting the same type twice (usually due to a cycle involving\n-        // associated types), we need to ensure that its region types match up with the type\n-        // we added to the 'known' map the first time around. For this reason, we need\n-        // our infcx to hold onto its calculated region constraints after each call\n-        // to dtorck_constraint_for_ty. Otherwise, normalizing the corresponding associated\n-        // type will end up instantiating the type with a new set of inference variables\n-        // Since this new type will never be in 'known', we end up looping forever.\n-        //\n-        // For this reason, we avoid calling TypeChecker.normalize, instead doing all normalization\n-        // ourselves in one large 'fully_perform_op' callback.\n-        let kind_constraints = self.cx\n-            .fully_perform_op(location.at_self(), |cx| {\n-                let span = cx.last_span;\n-\n-                let mut final_obligations = Vec::new();\n-                let mut kind_constraints = Vec::new();\n-\n-                let InferOk {\n-                    value: kinds,\n-                    obligations,\n-                } = cx.infcx\n-                    .at(&cx.misc(span), cx.param_env)\n-                    .dropck_outlives(dropped_ty);\n-                for kind in kinds {\n-                    // All things in the `outlives` array may be touched by\n-                    // the destructor and must be live at this point.\n-                    let cause = Cause::DropVar(dropped_local, location);\n-                    kind_constraints.push((kind, location, cause));\n-                }\n+        let drop_data = self.drop_data.entry(dropped_ty).or_insert_with({\n+            let cx = &mut self.cx;\n+            move || Self::compute_drop_data(cx, dropped_ty)\n+        });\n \n-                final_obligations.extend(obligations);\n+        if let Some(data) = &drop_data.region_constraint_data {\n+            self.cx\n+                .push_region_constraints(location.at_self(), data.clone());\n+        }\n \n-                Ok(InferOk {\n-                    value: kind_constraints,\n-                    obligations: final_obligations,\n-                })\n-            })\n-            .unwrap();\n+        // All things in the `outlives` array may be touched by\n+        // the destructor and must be live at this point.\n+        let cause = Cause::DropVar(dropped_local, location);\n+        for &kind in &drop_data.dropped_kinds {\n+            Self::push_type_live_constraint(&mut self.cx, kind, location, cause);\n+        }\n+    }\n \n-        for (kind, location, cause) in kind_constraints {\n-            self.push_type_live_constraint(kind, location, cause);\n+    fn compute_drop_data(\n+        cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n+        dropped_ty: Ty<'tcx>,\n+    ) -> DropData<'tcx> {\n+        debug!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty,);\n+\n+        let (dropped_kinds, region_constraint_data) =\n+            cx.fully_perform_op_and_get_region_constraint_data(\n+                || format!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty),\n+                |cx| {\n+                    Ok(cx\n+                        .infcx\n+                        .at(&ObligationCause::dummy(), cx.param_env)\n+                        .dropck_outlives(dropped_ty))\n+                },\n+            ).unwrap();\n+\n+        DropData {\n+            dropped_kinds,\n+            region_constraint_data,\n         }\n     }\n }"}, {"sha": "d25cec7979140cdee49791fcfd523fe1c72bdfb6", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 216, "deletions": 99, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=b36917b33104dc0af4d26d53899b7cd064a40b22", "patch": "@@ -11,26 +11,28 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n #![allow(unreachable_code)]\n \n+use borrow_check::location::LocationTable;\n+use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::Cause;\n-use borrow_check::nll::region_infer::ClosureRegionRequirementsExt;\n+use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, OutlivesConstraint, TypeTest};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n use rustc::hir::def_id::DefId;\n use rustc::infer::region_constraints::{GenericKind, RegionConstraintData};\n use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n+use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::*;\n use rustc::traits::query::NoSolution;\n-use rustc::traits::{self, Normalized, TraitEngine};\n+use rustc::traits::{self, ObligationCause, Normalized, TraitEngine};\n use rustc::ty::error::TypeError;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeVariants};\n use std::fmt;\n-use syntax::ast;\n+use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n use transform::{MirPass, MirSource};\n use util::liveness::LivenessResults;\n@@ -45,7 +47,7 @@ macro_rules! span_mirbug {\n             $context.last_span,\n             &format!(\n                 \"broken MIR in {:?} ({:?}): {}\",\n-                $context.body_id,\n+                $context.mir_def_id,\n                 $elem,\n                 format_args!($($message)*),\n             ),\n@@ -62,6 +64,7 @@ macro_rules! span_mirbug_and_err {\n     })\n }\n \n+mod constraint_conversion;\n mod input_output;\n mod liveness;\n \n@@ -100,19 +103,25 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     mir: &Mir<'tcx>,\n     mir_def_id: DefId,\n     universal_regions: &UniversalRegions<'tcx>,\n+    location_table: &LocationTable,\n     liveness: &LivenessResults,\n+    all_facts: &mut Option<AllFacts>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) -> MirTypeckRegionConstraints<'tcx> {\n-    let body_id = infcx.tcx.hir.as_local_node_id(mir_def_id).unwrap();\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     type_check_internal(\n         infcx,\n-        body_id,\n+        mir_def_id,\n         param_env,\n         mir,\n         &universal_regions.region_bound_pairs,\n         Some(implicit_region_bound),\n+        Some(BorrowCheckContext {\n+            universal_regions,\n+            location_table,\n+            all_facts,\n+        }),\n         &mut |cx| {\n             liveness::generate(cx, mir, liveness, flow_inits, move_data);\n \n@@ -123,19 +132,22 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n \n fn type_check_internal<'gcx, 'tcx>(\n     infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-    body_id: ast::NodeId,\n+    mir_def_id: DefId,\n     param_env: ty::ParamEnv<'gcx>,\n     mir: &Mir<'tcx>,\n     region_bound_pairs: &[(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n+    borrowck_context: Option<BorrowCheckContext<'_, 'tcx>>,\n     extra: &mut dyn FnMut(&mut TypeChecker<'_, 'gcx, 'tcx>),\n ) -> MirTypeckRegionConstraints<'tcx> {\n     let mut checker = TypeChecker::new(\n         infcx,\n-        body_id,\n+        mir_def_id,\n         param_env,\n         region_bound_pairs,\n         implicit_region_bound,\n+        borrowck_context,\n+        mir,\n     );\n     let errors_reported = {\n         let mut verifier = TypeVerifier::new(&mut checker, mir);\n@@ -173,7 +185,7 @@ struct TypeVerifier<'a, 'b: 'a, 'gcx: 'b + 'tcx, 'tcx: 'b> {\n     cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     last_span: Span,\n-    body_id: ast::NodeId,\n+    mir_def_id: DefId,\n     errors_reported: bool,\n }\n \n@@ -221,7 +233,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn new(cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n         TypeVerifier {\n             mir,\n-            body_id: cx.body_id,\n+            mir_def_id: cx.mir_def_id,\n             cx,\n             last_span: mir.span,\n             errors_reported: false,\n@@ -300,7 +312,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n         debug!(\"sanitize_constant: expected_ty={:?}\", expected_ty);\n \n-        if let Err(terr) = self.cx\n+        if let Err(terr) = self\n+            .cx\n             .eq_types(expected_ty, constant.ty, location.at_self())\n         {\n             span_mirbug!(\n@@ -580,42 +593,37 @@ struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n     last_span: Span,\n-    body_id: ast::NodeId,\n+    mir_def_id: DefId,\n     region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     constraints: MirTypeckRegionConstraints<'tcx>,\n+    borrowck_context: Option<BorrowCheckContext<'a, 'tcx>>,\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+struct BorrowCheckContext<'a, 'tcx: 'a> {\n+    universal_regions: &'a UniversalRegions<'tcx>,\n+    location_table: &'a LocationTable,\n+    all_facts: &'a mut Option<AllFacts>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n /// program to be considered well-typed.\n #[derive(Default)]\n-pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n+crate struct MirTypeckRegionConstraints<'tcx> {\n     /// In general, the type-checker is not responsible for enforcing\n     /// liveness constraints; this job falls to the region inferencer,\n     /// which performs a liveness analysis. However, in some limited\n     /// cases, the MIR type-checker creates temporary regions that do\n     /// not otherwise appear in the MIR -- in particular, the\n     /// late-bound regions that it instantiates at call-sites -- and\n     /// hence it must report on their liveness constraints.\n-    pub liveness_set: Vec<(ty::Region<'tcx>, Location, Cause)>,\n-\n-    /// During the course of type-checking, we will accumulate region\n-    /// constraints due to performing subtyping operations or solving\n-    /// traits. These are accumulated into this vector for later use.\n-    pub outlives_sets: Vec<OutlivesSet<'tcx>>,\n-}\n+    crate liveness_set: Vec<(ty::Region<'tcx>, Location, Cause)>,\n \n-/// Outlives relationships between regions and types created at a\n-/// particular point within the control-flow graph.\n-pub struct OutlivesSet<'tcx> {\n-    /// The locations associated with these constraints.\n-    pub locations: Locations,\n+    crate outlives_constraints: Vec<OutlivesConstraint>,\n \n-    /// Constraints generated. In terms of the NLL RFC, when you have\n-    /// a constraint `R1: R2 @ P`, the data in there specifies things\n-    /// like `R1: R2`.\n-    pub data: RegionConstraintData<'tcx>,\n+    crate type_tests: Vec<TypeTest<'tcx>>,\n }\n \n /// The `Locations` type summarizes *where* region constraints are\n@@ -667,7 +675,7 @@ pub enum Locations {\n         /// NLL RFC, when you have a constraint `R1: R2 @ P`, this field\n         /// is the `P` value.\n         at_location: Location,\n-    }\n+    },\n }\n \n impl Locations {\n@@ -689,37 +697,99 @@ impl Locations {\n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn new(\n         infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-        body_id: ast::NodeId,\n+        mir_def_id: DefId,\n         param_env: ty::ParamEnv<'gcx>,\n         region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n+        borrowck_context: Option<BorrowCheckContext<'a, 'tcx>>,\n+        mir: &'a Mir<'tcx>,\n     ) -> Self {\n         TypeChecker {\n             infcx,\n             last_span: DUMMY_SP,\n-            body_id,\n+            mir_def_id,\n             param_env,\n             region_bound_pairs,\n             implicit_region_bound,\n+            borrowck_context,\n+            mir,\n             reported_errors: FxHashSet(),\n             constraints: MirTypeckRegionConstraints::default(),\n         }\n     }\n \n-    fn misc(&self, span: Span) -> traits::ObligationCause<'tcx> {\n-        traits::ObligationCause::misc(span, self.body_id)\n+    /// Given some operation `op` that manipulates types, proves\n+    /// predicates, or otherwise uses the inference context, executes\n+    /// `op` and then executes all the further obligations that `op`\n+    /// returns. This will yield a set of outlives constraints amongst\n+    /// regions which are extracted and stored as having occured at\n+    /// `locations`.\n+    ///\n+    /// **Any `rustc::infer` operations that might generate region\n+    /// constraints should occur within this method so that those\n+    /// constraints can be properly localized!**\n+    fn fully_perform_op<R>(\n+        &mut self,\n+        locations: Locations,\n+        describe_op: impl Fn() -> String,\n+        op: impl FnOnce(&mut Self) -> InferResult<'tcx, R>,\n+    ) -> Result<R, TypeError<'tcx>> {\n+        let (r, opt_data) = self.fully_perform_op_and_get_region_constraint_data(\n+            || format!(\"{} at {:?}\", describe_op(), locations),\n+            op,\n+        )?;\n+\n+        if let Some(data) = opt_data {\n+            self.push_region_constraints(locations, data);\n+        }\n+\n+        Ok(r)\n     }\n \n-    fn fully_perform_op<OP, R>(\n+    fn push_region_constraints(\n         &mut self,\n         locations: Locations,\n-        op: OP,\n-    ) -> Result<R, TypeError<'tcx>>\n-    where\n-        OP: FnOnce(&mut Self) -> InferResult<'tcx, R>,\n-    {\n+        data: Rc<RegionConstraintData<'tcx>>,\n+    ) {\n+        debug!(\n+            \"push_region_constraints: constraints generated at {:?} are {:#?}\",\n+            locations, data\n+        );\n+\n+        if let Some(borrowck_context) = &mut self.borrowck_context {\n+            constraint_conversion::ConstraintConversion::new(\n+                self.mir,\n+                borrowck_context.universal_regions,\n+                borrowck_context.location_table,\n+                &mut self.constraints.outlives_constraints,\n+                &mut self.constraints.type_tests,\n+                &mut borrowck_context.all_facts,\n+            ).convert(locations, &data);\n+        }\n+    }\n+\n+    /// Helper for `fully_perform_op`, but also used on its own\n+    /// sometimes to enable better caching: executes `op` fully (along\n+    /// with resulting obligations) and returns the full set of region\n+    /// obligations. If the same `op` were to be performed at some\n+    /// other location, then the same set of region obligations would\n+    /// be generated there, so this can be useful for caching.\n+    fn fully_perform_op_and_get_region_constraint_data<R>(\n+        &mut self,\n+        describe_op: impl Fn() -> String,\n+        op: impl FnOnce(&mut Self) -> InferResult<'tcx, R>,\n+    ) -> Result<(R, Option<Rc<RegionConstraintData<'tcx>>>), TypeError<'tcx>> {\n+        if cfg!(debug_assertions) {\n+            info!(\n+                \"fully_perform_op_and_get_region_constraint_data({})\",\n+                describe_op(),\n+            );\n+        }\n+\n         let mut fulfill_cx = TraitEngine::new(self.infcx.tcx);\n+        let dummy_body_id = ObligationCause::dummy().body_id;\n         let InferOk { value, obligations } = self.infcx.commit_if_ok(|_| op(self))?;\n+        debug_assert!(obligations.iter().all(|o| o.cause.body_id == dummy_body_id));\n         fulfill_cx.register_predicate_obligations(self.infcx, obligations);\n         if let Err(e) = fulfill_cx.select_all_or_error(self.infcx) {\n             span_mirbug!(self, \"\", \"errors selecting obligation: {:?}\", e);\n@@ -729,21 +799,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             self.region_bound_pairs,\n             self.implicit_region_bound,\n             self.param_env,\n-            self.body_id,\n+            dummy_body_id,\n         );\n \n         let data = self.infcx.take_and_reset_region_constraints();\n-        if !data.is_empty() {\n-            debug!(\n-                \"fully_perform_op: constraints generated at {:?} are {:#?}\",\n-                locations, data\n-            );\n-            self.constraints\n-                .outlives_sets\n-                .push(OutlivesSet { locations, data });\n+        if data.is_empty() {\n+            Ok((value, None))\n+        } else {\n+            Ok((value, Some(Rc::new(data))))\n         }\n-\n-        Ok(value)\n     }\n \n     fn sub_types(\n@@ -752,19 +816,37 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         sup: Ty<'tcx>,\n         locations: Locations,\n     ) -> UnitResult<'tcx> {\n-        self.fully_perform_op(locations, |this| {\n-            this.infcx\n-                .at(&this.misc(this.last_span), this.param_env)\n-                .sup(sup, sub)\n-        })\n+        // Micro-optimization.\n+        if sub == sup {\n+            return Ok(());\n+        }\n+\n+        self.fully_perform_op(\n+            locations,\n+            || format!(\"sub_types({:?} <: {:?})\", sub, sup),\n+            |this| {\n+                this.infcx\n+                    .at(&ObligationCause::dummy(), this.param_env)\n+                    .sup(sup, sub)\n+            },\n+        )\n     }\n \n     fn eq_types(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, locations: Locations) -> UnitResult<'tcx> {\n-        self.fully_perform_op(locations, |this| {\n-            this.infcx\n-                .at(&this.misc(this.last_span), this.param_env)\n-                .eq(b, a)\n-        })\n+        // Micro-optimization.\n+        if a == b {\n+            return Ok(());\n+        }\n+\n+        self.fully_perform_op(\n+            locations,\n+            || format!(\"eq_types({:?} = {:?})\", a, b),\n+            |this| {\n+                this.infcx\n+                    .at(&ObligationCause::dummy(), this.param_env)\n+                    .eq(b, a)\n+            },\n+        )\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -819,7 +901,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n             StatementKind::UserAssertTy(ref c_ty, ref local) => {\n                 let local_ty = mir.local_decls()[*local].ty;\n-                let (ty, _) = self.infcx\n+                let (ty, _) = self\n+                    .infcx\n                     .instantiate_canonical_with_fresh_inference_vars(stmt.source_info.span, c_ty);\n                 debug!(\n                     \"check_stmt: user_assert_ty ty={:?} local_ty={:?}\",\n@@ -1431,9 +1514,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             };\n             let operand_ty = operand.ty(mir, tcx);\n-            if let Err(terr) =\n-                self.sub_types(operand_ty, field_ty, location.at_self())\n-            {\n+            if let Err(terr) = self.sub_types(operand_ty, field_ty, location.at_self()) {\n                 span_mirbug!(\n                     self,\n                     rvalue,\n@@ -1487,9 +1568,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 if let Some(closure_region_requirements) =\n                     tcx.mir_borrowck(*def_id).closure_requirements\n                 {\n+                    let dummy_body_id = ObligationCause::dummy().body_id;\n                     closure_region_requirements.apply_requirements(\n                         self.infcx,\n-                        self.body_id,\n+                        dummy_body_id,\n                         location,\n                         *def_id,\n                         *substs,\n@@ -1522,27 +1604,44 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn prove_predicates<T>(&mut self, predicates: T, location: Location)\n     where\n-        T: IntoIterator<Item = ty::Predicate<'tcx>>,\n-        T::IntoIter: Clone,\n+        T: IntoIterator<Item = ty::Predicate<'tcx>> + Clone,\n     {\n-        let predicates = predicates.into_iter();\n+        let cause = ObligationCause::dummy();\n+        let obligations: Vec<_> = predicates\n+            .into_iter()\n+            .map(|p| traits::Obligation::new(cause.clone(), self.param_env, p))\n+            .collect();\n+\n+        // Micro-optimization\n+        if obligations.is_empty() {\n+            return;\n+        }\n+\n+        // This intermediate vector is mildly unfortunate, in that we\n+        // sometimes create it even when logging is disabled, but only\n+        // if debug-info is enabled, and I doubt it is actually\n+        // expensive. -nmatsakis\n+        let predicates_vec: Vec<_> = if cfg!(debug_assertions) {\n+            obligations.iter().map(|o| o.predicate).collect()\n+        } else {\n+            Vec::new()\n+        };\n \n         debug!(\n             \"prove_predicates(predicates={:?}, location={:?})\",\n-            predicates.clone().collect::<Vec<_>>(),\n-            location,\n+            predicates_vec, location,\n         );\n-        self.fully_perform_op(location.at_self(), |this| {\n-            let cause = this.misc(this.last_span);\n-            let obligations = predicates\n-                .into_iter()\n-                .map(|p| traits::Obligation::new(cause.clone(), this.param_env, p))\n-                .collect();\n-            Ok(InferOk {\n-                value: (),\n-                obligations,\n-            })\n-        }).unwrap()\n+\n+        self.fully_perform_op(\n+            location.at_self(),\n+            || format!(\"prove_predicates({:?})\", predicates_vec),\n+            |_this| {\n+                Ok(InferOk {\n+                    value: (),\n+                    obligations,\n+                })\n+            },\n+        ).unwrap()\n     }\n \n     fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n@@ -1575,21 +1674,31 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     where\n         T: fmt::Debug + TypeFoldable<'tcx>,\n     {\n+        // Micro-optimization: avoid work when we don't have to\n+        if !value.has_projections() {\n+            return value.clone();\n+        }\n+\n         debug!(\"normalize(value={:?}, location={:?})\", value, location);\n-        self.fully_perform_op(location.to_locations(), |this| {\n-            let Normalized { value, obligations } = this.infcx\n-                .at(&this.misc(this.last_span), this.param_env)\n-                .normalize(value)\n-                .unwrap_or_else(|NoSolution| {\n-                    span_bug!(\n-                        this.last_span,\n-                        \"normalization of `{:?}` failed at {:?}\",\n-                        value,\n-                        location,\n-                    );\n-                });\n-            Ok(InferOk { value, obligations })\n-        }).unwrap()\n+        self.fully_perform_op(\n+            location.to_locations(),\n+            || format!(\"normalize(value={:?})\", value),\n+            |this| {\n+                let Normalized { value, obligations } = this\n+                    .infcx\n+                    .at(&ObligationCause::dummy(), this.param_env)\n+                    .normalize(value)\n+                    .unwrap_or_else(|NoSolution| {\n+                        span_bug!(\n+                            this.last_span,\n+                            \"normalization of `{:?}` failed at {:?}\",\n+                            value,\n+                            location,\n+                        );\n+                    });\n+                Ok(InferOk { value, obligations })\n+            },\n+        ).unwrap()\n     }\n }\n \n@@ -1598,7 +1707,6 @@ pub struct TypeckMir;\n impl MirPass for TypeckMir {\n     fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n         let def_id = src.def_id;\n-        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n         debug!(\"run_pass: {:?}\", def_id);\n \n         // When NLL is enabled, the borrow checker runs the typeck\n@@ -1614,7 +1722,16 @@ impl MirPass for TypeckMir {\n         }\n         let param_env = tcx.param_env(def_id);\n         tcx.infer_ctxt().enter(|infcx| {\n-            let _ = type_check_internal(&infcx, id, param_env, mir, &[], None, &mut |_| ());\n+            let _ = type_check_internal(\n+                &infcx,\n+                def_id,\n+                param_env,\n+                mir,\n+                &[],\n+                None,\n+                None,\n+                &mut |_| (),\n+            );\n \n             // For verification purposes, we just ignore the resulting\n             // region constraint sets. Not our problem. =)"}, {"sha": "5dd1889ef95bc6c731402f6542016c9135f168e6", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr?ref=b36917b33104dc0af4d26d53899b7cd064a40b22", "patch": "@@ -24,16 +24,15 @@ LL | |     });\n    = note: where '_#1r: '_#0r\n \n error: free region `ReFree(DefId(0/0:6 ~ propagate_approximated_shorter_to_static_no_bound[317d]::supply[0]), BrNamed(crate0:DefIndex(1:16), 'a))` does not outlive free region `ReStatic`\n-  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:45:47\n+  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:45:5\n    |\n-LL |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n-   |  _______________________________________________^\n+LL | /     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n LL | |         //~^ ERROR does not outlive free region\n LL | |\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll\n LL | |     });\n-   | |_____^\n+   | |______^\n \n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:44:1"}, {"sha": "e44df9c7af1c2e184c0119cfaa0dfc620ccfeecb", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b36917b33104dc0af4d26d53899b7cd064a40b22/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr?ref=b36917b33104dc0af4d26d53899b7cd064a40b22", "patch": "@@ -24,16 +24,15 @@ LL | |     });\n    = note: where '_#1r: '_#0r\n \n error: free region `ReFree(DefId(0/0:6 ~ propagate_approximated_shorter_to_static_wrong_bound[317d]::supply[0]), BrNamed(crate0:DefIndex(1:16), 'a))` does not outlive free region `ReStatic`\n-  --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:48:47\n+  --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:48:5\n    |\n-LL |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-   |  _______________________________________________^\n+LL | /     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n LL | |         //~^ ERROR does not outlive free region\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get())\n LL | |         //~^ WARNING not reporting region error due to nll\n LL | |     });\n-   | |_____^\n+   | |______^\n \n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:47:1"}]}