{"sha": "dcbd418b1c228addbe0dd14893c6ae9692aab8fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjYmQ0MThiMWMyMjhhZGRiZTBkZDE0ODkzYzZhZTk2OTJhYWI4ZmQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-19T04:36:13Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-29T22:57:33Z"}, "message": "save-analysis: handle absolute paths properly", "tree": {"sha": "6a4491f446d6f83a9c0dcce9e9879e5e93ab4351", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a4491f446d6f83a9c0dcce9e9879e5e93ab4351"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcbd418b1c228addbe0dd14893c6ae9692aab8fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcbd418b1c228addbe0dd14893c6ae9692aab8fd", "html_url": "https://github.com/rust-lang/rust/commit/dcbd418b1c228addbe0dd14893c6ae9692aab8fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcbd418b1c228addbe0dd14893c6ae9692aab8fd/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1174550191970b0af762f4289c85d499da52d299", "url": "https://api.github.com/repos/rust-lang/rust/commits/1174550191970b0af762f4289c85d499da52d299", "html_url": "https://github.com/rust-lang/rust/commit/1174550191970b0af762f4289c85d499da52d299"}], "stats": {"total": 71, "additions": 43, "deletions": 28}, "files": [{"sha": "f97b785f40f573a0b4291fb172ff0e823d5054b0", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 43, "deletions": 28, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd418b1c228addbe0dd14893c6ae9692aab8fd/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd418b1c228addbe0dd14893c6ae9692aab8fd/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=dcbd418b1c228addbe0dd14893c6ae9692aab8fd", "patch": "@@ -124,22 +124,33 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let mut result: Vec<(Span, String)> = vec!();\n \n         let mut segs = vec!();\n-        for (seg, span) in path.segments.iter().zip(spans.iter()) {\n+        for (i, (seg, span)) in path.segments.iter().zip(spans.iter()).enumerate() {\n             segs.push(seg.clone());\n             let sub_path = ast::Path{span: *span, // span for the last segment\n                                      global: path.global,\n                                      segments: segs};\n-            let qualname = path_to_string(&sub_path);\n+            let qualname = if i == 0 && path.global {\n+                let mut result = \"::\".to_string();\n+                result.push_str(&path_to_string(&sub_path)[]);\n+                result\n+            } else {\n+                path_to_string(&sub_path)\n+            };\n             result.push((*span, qualname));\n             segs = sub_path.segments;\n         }\n \n         result\n     }\n \n-    fn write_sub_paths(&mut self, path: &ast::Path) {\n+    fn write_sub_paths(&mut self, path: &ast::Path, global: bool) {\n         let sub_paths = self.process_path_prefixes(path);\n-        for &(ref span, ref qualname) in sub_paths.iter() {\n+        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n+            let qualname = if i == 0 && global && !path.global {\n+                format!(\"::{}\", qualname)\n+            } else {\n+                qualname.clone()\n+            };\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n                                      &qualname[],\n@@ -149,15 +160,20 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n     // As write_sub_paths, but does not process the last ident in the path (assuming it\n     // will be processed elsewhere).\n-    fn write_sub_paths_truncated(&mut self, path: &ast::Path) {\n+    fn write_sub_paths_truncated(&mut self, path: &ast::Path, global: bool) {\n         let sub_paths = self.process_path_prefixes(path);\n         let len = sub_paths.len();\n         if len <= 1 {\n             return;\n         }\n \n-        let sub_paths = &sub_paths[.. (len-1)];\n-        for &(ref span, ref qualname) in sub_paths.iter() {\n+        let sub_paths = sub_paths[..len-1];\n+        for (i, &(ref span, ref qualname)) in sub_paths.iter().enumerate() {\n+            let qualname = if i == 0 && global && !path.global {\n+                format!(\"::{}\", qualname)\n+            } else {\n+                qualname.clone()\n+            };\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n                                      &qualname[],\n@@ -276,8 +292,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let mut scope_id;\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in followed by the method's name.\n-        let mut qualname = match ty::impl_of_method(&self.analysis.ty_cx,\n-                                                    ast_util::local_def(method.id)) {\n+        let qualname = match ty::impl_of_method(&self.analysis.ty_cx,\n+                                                ast_util::local_def(method.id)) {\n             Some(impl_id) => match self.analysis.ty_cx.map.get(impl_id.node) {\n                 NodeItem(item) => {\n                     scope_id = item.id;\n@@ -339,7 +355,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             },\n         };\n \n-        qualname.push_str(get_ident(method.pe_ident()).get());\n+        let qualname = format!(\"::{}{}\", qualname, get_ident(method.pe_ident()).get());\n         let qualname = &qualname[];\n \n         // record the decl for this def (if it has one)\n@@ -434,7 +450,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     }\n \n     // Dump generic params bindings, then visit_generics\n-    fn process_generic_params(&mut self, generics:&ast::Generics,\n+    fn process_generic_params(&mut self,\n+                              generics:&ast::Generics,\n                               full_span: Span,\n                               prefix: &str,\n                               id: NodeId) {\n@@ -464,7 +481,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                   decl: &ast::FnDecl,\n                   ty_params: &ast::Generics,\n                   body: &ast::Block) {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Fn);\n         self.fmt.fn_str(item.span,\n@@ -496,7 +513,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                       mt: ast::Mutability,\n                       expr: &ast::Expr)\n     {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n         // If the variable is immutable, save the initialising expression.\n         let value = match mt {\n@@ -524,7 +541,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                       typ: &ast::Ty,\n                       expr: &ast::Expr)\n     {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n         let sub_span = self.span.sub_span_after_keyword(item.span,\n                                                         keywords::Const);\n@@ -546,7 +563,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                       item: &ast::Item,\n                       def: &ast::StructDef,\n                       ty_params: &ast::Generics) {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n         let ctor_id = match def.ctor_id {\n             Some(node_id) => node_id,\n@@ -575,7 +592,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     item: &ast::Item,\n                     enum_definition: &ast::EnumDef,\n                     ty_params: &ast::Generics) {\n-        let enum_name = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let enum_name = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n         let val = self.span.snippet(item.span);\n         match self.span.sub_span_after_keyword(item.span, keywords::Enum) {\n             Some(sub_span) => self.fmt.enum_str(item.span,\n@@ -701,7 +718,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                      generics: &ast::Generics,\n                      trait_refs: &OwnedSlice<ast::TyParamBound>,\n                      methods: &Vec<ast::TraitItem>) {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n         self.fmt.trait_str(item.span,\n@@ -750,7 +767,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     fn process_mod(&mut self,\n                    item: &ast::Item,  // The module in question, represented as an item.\n                    m: &ast::Mod) {\n-        let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n         let cm = self.sess.codemap();\n         let filename = cm.span_to_filename(m.inner);\n@@ -855,7 +872,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefConst(..) |\n             def::DefStruct(_) |\n             def::DefVariant(..) |\n-            def::DefFn(..) => self.write_sub_paths_truncated(path),\n+            def::DefFn(..) => self.write_sub_paths_truncated(path, false),\n             _ => {},\n         }\n     }\n@@ -883,7 +900,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             None => ()\n         }\n \n-        self.write_sub_paths_truncated(path);\n+        self.write_sub_paths_truncated(path, false);\n \n         for field in fields.iter() {\n             match struct_def {\n@@ -1069,7 +1086,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                                mod_id,\n                                                get_ident(ident).get(),\n                                                self.cur_scope);\n-                        self.write_sub_paths_truncated(path);\n+                        self.write_sub_paths_truncated(path, true);\n                     }\n                     ast::ViewPathGlob(ref path) => {\n                         // Make a comma-separated list of names of imported modules.\n@@ -1092,7 +1109,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                               item.id,\n                                               name_string.as_slice(),\n                                               self.cur_scope);\n-                        self.write_sub_paths(path);\n+                        self.write_sub_paths(path, true);\n                     }\n                     ast::ViewPathList(ref path, ref list) => {\n                         for plid in list.iter() {\n@@ -1116,7 +1133,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                             }\n                         }\n \n-                        self.write_sub_paths(path);\n+                        self.write_sub_paths(path, true);\n                     }\n                 }\n             }\n@@ -1163,7 +1180,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.process_trait(item, generics, trait_refs, methods),\n             ast::ItemMod(ref m) => self.process_mod(item, m),\n             ast::ItemTy(ref ty, ref ty_params) => {\n-                let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n+                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n                 let value = ty_to_string(&**ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n                 self.fmt.typedef_str(item.span,\n@@ -1223,9 +1240,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                                            ast_util::local_def(method_type.id)) {\n                     Some(def_id) => {\n                         scope_id = def_id.node;\n-                        let mut s = ty::item_path_str(&self.analysis.ty_cx, def_id);\n-                        s.push_str(\"::\");\n-                        s\n+                        format!(\"::{}::\", ty::item_path_str(&self.analysis.ty_cx, def_id))\n                     },\n                     None => {\n                         self.sess.span_bug(method_type.span,\n@@ -1282,7 +1297,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     None => ()\n                 }\n \n-                self.write_sub_paths_truncated(path);\n+                self.write_sub_paths_truncated(path, false);\n \n                 visit::walk_path(self, path);\n             },"}]}