{"sha": "6aa432d86b7e4fb691600032ebdf6f2301152447", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYTQzMmQ4NmI3ZTRmYjY5MTYwMDAzMmViZGY2ZjIzMDExNTI0NDc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-03-17T09:41:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-17T09:41:30Z"}, "message": "Merge #3580\n\n3580: More error-resilient MBE expansion r=matklad a=flodiebold\n\nThis is the beginning of an attempt to make macro-by-example expansion more resilient, so that we still get an expansion even if no rule exactly matches, with the goal to make completion work better in macro calls.\r\n\r\n The general idea is to make everything return `(T, Option<ExpandError>)` instead of `Result<T, ExpandError>`; and then to try each macro arm in turn, and somehow choose the 'best' matching rule if none matches without errors. Finding that 'best' match isn't done yet; I'm currently counting how many tokens were consumed from the args before an error, but it also needs to take into account whether there were further patterns that had nothing to match.\r\n\r\nI'll continue this later, but I'm interested whether you think this is the right path, @matklad & @edwin0cheng.\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "aa012212c11e43a95547f553b5116922631f9896", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa012212c11e43a95547f553b5116922631f9896"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6aa432d86b7e4fb691600032ebdf6f2301152447", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJecJtKCRBK7hj4Ov3rIwAAdHIIACz7ueB8MELNfovH/Xny/6cr\nJV4vOEX6gzoMs82w4fBp7wyAEoDDG4LFZ6M2u3DAZGvMZTOkM7XP8QyzqUpZTId9\n/7rNi9yJl4f1H9/KKceGqQTn4uZaRuZ6lWoxVS4y8g4dSY6WXbNeZtr35b3rO9TG\nyMB1kldCDYBCqq01d/rVbWQpEnfrGPbopKflldubdxpCNGZgAbaZ9t46du9aPV6o\nrnKY8e8pwS9Mgs2RY5SugKh9Ee3SWbCoOsZj3lMx35qPPHaiZcz7IPjO0/yVDJOA\neNhFe7dttvFyM12GVAwUEhob0YTJYJ0oasZMop1XhMVnvoiqZkAeeHE91jjiShA=\n=2mSt\n-----END PGP SIGNATURE-----\n", "payload": "tree aa012212c11e43a95547f553b5116922631f9896\nparent cf4ae9aa591729dde25a7df3fa5c22ca0fd94145\nparent 6c20d7e979b967eb20207414c0a0bf875bbcb98d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1584438090 +0000\ncommitter GitHub <noreply@github.com> 1584438090 +0000\n\nMerge #3580\n\n3580: More error-resilient MBE expansion r=matklad a=flodiebold\n\nThis is the beginning of an attempt to make macro-by-example expansion more resilient, so that we still get an expansion even if no rule exactly matches, with the goal to make completion work better in macro calls.\r\n\r\n The general idea is to make everything return `(T, Option<ExpandError>)` instead of `Result<T, ExpandError>`; and then to try each macro arm in turn, and somehow choose the 'best' matching rule if none matches without errors. Finding that 'best' match isn't done yet; I'm currently counting how many tokens were consumed from the args before an error, but it also needs to take into account whether there were further patterns that had nothing to match.\r\n\r\nI'll continue this later, but I'm interested whether you think this is the right path, @matklad & @edwin0cheng.\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6aa432d86b7e4fb691600032ebdf6f2301152447", "html_url": "https://github.com/rust-lang/rust/commit/6aa432d86b7e4fb691600032ebdf6f2301152447", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6aa432d86b7e4fb691600032ebdf6f2301152447/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf4ae9aa591729dde25a7df3fa5c22ca0fd94145", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf4ae9aa591729dde25a7df3fa5c22ca0fd94145", "html_url": "https://github.com/rust-lang/rust/commit/cf4ae9aa591729dde25a7df3fa5c22ca0fd94145"}, {"sha": "6c20d7e979b967eb20207414c0a0bf875bbcb98d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c20d7e979b967eb20207414c0a0bf875bbcb98d", "html_url": "https://github.com/rust-lang/rust/commit/6c20d7e979b967eb20207414c0a0bf875bbcb98d"}], "stats": {"total": 652, "additions": 471, "deletions": 181}, "files": [{"sha": "d171d2dfd1db4f880a715b5d66317181858248a1", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 53, "deletions": 46, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=6aa432d86b7e4fb691600032ebdf6f2301152447", "patch": "@@ -2,7 +2,7 @@\n \n use std::sync::Arc;\n \n-use mbe::MacroRules;\n+use mbe::{ExpandResult, MacroRules};\n use ra_db::{salsa, SourceDatabase};\n use ra_parser::FragmentKind;\n use ra_prof::profile;\n@@ -27,11 +27,12 @@ impl TokenExpander {\n         db: &dyn AstDatabase,\n         id: LazyMacroId,\n         tt: &tt::Subtree,\n-    ) -> Result<tt::Subtree, mbe::ExpandError> {\n+    ) -> mbe::ExpandResult<tt::Subtree> {\n         match self {\n             TokenExpander::MacroRules(it) => it.expand(tt),\n-            TokenExpander::Builtin(it) => it.expand(db, id, tt),\n-            TokenExpander::BuiltinDerive(it) => it.expand(db, id, tt),\n+            // FIXME switch these to ExpandResult as well\n+            TokenExpander::Builtin(it) => it.expand(db, id, tt).into(),\n+            TokenExpander::BuiltinDerive(it) => it.expand(db, id, tt).into(),\n         }\n     }\n \n@@ -66,7 +67,7 @@ pub trait AstDatabase: SourceDatabase {\n     fn macro_def(&self, id: MacroDefId) -> Option<Arc<(TokenExpander, mbe::TokenMap)>>;\n     fn parse_macro(&self, macro_file: MacroFile)\n         -> Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)>;\n-    fn macro_expand(&self, macro_call: MacroCallId) -> Result<Arc<tt::Subtree>, String>;\n+    fn macro_expand(&self, macro_call: MacroCallId) -> (Option<Arc<tt::Subtree>>, Option<String>);\n \n     #[salsa::interned]\n     fn intern_eager_expansion(&self, eager: EagerCallLoc) -> EagerMacroId;\n@@ -153,7 +154,7 @@ pub(crate) fn macro_arg(\n pub(crate) fn macro_expand(\n     db: &dyn AstDatabase,\n     id: MacroCallId,\n-) -> Result<Arc<tt::Subtree>, String> {\n+) -> (Option<Arc<tt::Subtree>>, Option<String>) {\n     macro_expand_with_arg(db, id, None)\n }\n \n@@ -174,31 +175,38 @@ fn macro_expand_with_arg(\n     db: &dyn AstDatabase,\n     id: MacroCallId,\n     arg: Option<Arc<(tt::Subtree, mbe::TokenMap)>>,\n-) -> Result<Arc<tt::Subtree>, String> {\n+) -> (Option<Arc<tt::Subtree>>, Option<String>) {\n     let lazy_id = match id {\n         MacroCallId::LazyMacro(id) => id,\n         MacroCallId::EagerMacro(id) => {\n             if arg.is_some() {\n-                return Err(\n-                    \"hypothetical macro expansion not implemented for eager macro\".to_owned()\n+                return (\n+                    None,\n+                    Some(\"hypothetical macro expansion not implemented for eager macro\".to_owned()),\n                 );\n             } else {\n-                return Ok(db.lookup_intern_eager_expansion(id).subtree);\n+                return (Some(db.lookup_intern_eager_expansion(id).subtree), None);\n             }\n         }\n     };\n \n     let loc = db.lookup_intern_macro(lazy_id);\n-    let macro_arg = arg.or_else(|| db.macro_arg(id)).ok_or(\"Fail to args in to tt::TokenTree\")?;\n+    let macro_arg = match arg.or_else(|| db.macro_arg(id)) {\n+        Some(it) => it,\n+        None => return (None, Some(\"Fail to args in to tt::TokenTree\".into())),\n+    };\n \n-    let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n-    let tt = macro_rules.0.expand(db, lazy_id, &macro_arg.0).map_err(|err| format!(\"{:?}\", err))?;\n+    let macro_rules = match db.macro_def(loc.def) {\n+        Some(it) => it,\n+        None => return (None, Some(\"Fail to find macro definition\".into())),\n+    };\n+    let ExpandResult(tt, err) = macro_rules.0.expand(db, lazy_id, &macro_arg.0);\n     // Set a hard limit for the expanded tt\n     let count = tt.count();\n     if count > 65536 {\n-        return Err(format!(\"Total tokens count exceed limit : count = {}\", count));\n+        return (None, Some(format!(\"Total tokens count exceed limit : count = {}\", count)));\n     }\n-    Ok(Arc::new(tt))\n+    (Some(Arc::new(tt)), err.map(|e| format!(\"{:?}\", e)))\n }\n \n pub(crate) fn parse_or_expand(db: &dyn AstDatabase, file_id: HirFileId) -> Option<SyntaxNode> {\n@@ -225,42 +233,41 @@ pub fn parse_macro_with_arg(\n     let _p = profile(\"parse_macro_query\");\n \n     let macro_call_id = macro_file.macro_call_id;\n-    let expansion = if let Some(arg) = arg {\n+    let (tt, err) = if let Some(arg) = arg {\n         macro_expand_with_arg(db, macro_call_id, Some(arg))\n     } else {\n         db.macro_expand(macro_call_id)\n     };\n-    let tt = expansion\n-        .map_err(|err| {\n-            // Note:\n-            // The final goal we would like to make all parse_macro success,\n-            // such that the following log will not call anyway.\n-            match macro_call_id {\n-                MacroCallId::LazyMacro(id) => {\n-                    let loc: MacroCallLoc = db.lookup_intern_macro(id);\n-                    let node = loc.kind.node(db);\n-\n-                    // collect parent information for warning log\n-                    let parents = std::iter::successors(loc.kind.file_id().call_node(db), |it| {\n-                        it.file_id.call_node(db)\n-                    })\n-                    .map(|n| format!(\"{:#}\", n.value))\n-                    .collect::<Vec<_>>()\n-                    .join(\"\\n\");\n-\n-                    log::warn!(\n-                        \"fail on macro_parse: (reason: {} macro_call: {:#}) parents: {}\",\n-                        err,\n-                        node.value,\n-                        parents\n-                    );\n-                }\n-                _ => {\n-                    log::warn!(\"fail on macro_parse: (reason: {})\", err);\n-                }\n+    if let Some(err) = err {\n+        // Note:\n+        // The final goal we would like to make all parse_macro success,\n+        // such that the following log will not call anyway.\n+        match macro_call_id {\n+            MacroCallId::LazyMacro(id) => {\n+                let loc: MacroCallLoc = db.lookup_intern_macro(id);\n+                let node = loc.kind.node(db);\n+\n+                // collect parent information for warning log\n+                let parents = std::iter::successors(loc.kind.file_id().call_node(db), |it| {\n+                    it.file_id.call_node(db)\n+                })\n+                .map(|n| format!(\"{:#}\", n.value))\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\");\n+\n+                log::warn!(\n+                    \"fail on macro_parse: (reason: {} macro_call: {:#}) parents: {}\",\n+                    err,\n+                    node.value,\n+                    parents\n+                );\n+            }\n+            _ => {\n+                log::warn!(\"fail on macro_parse: (reason: {})\", err);\n             }\n-        })\n-        .ok()?;\n+        }\n+    };\n+    let tt = tt?;\n \n     let fragment_kind = to_fragment_kind(db, macro_call_id);\n "}, {"sha": "2e309a379148db319426418b2f574d7f483b25c3", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=6aa432d86b7e4fb691600032ebdf6f2301152447", "patch": "@@ -462,7 +462,7 @@ fn main() {\n fn infer_builtin_macros_include() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs \n+//- /main.rs\n #[rustc_builtin_macro]\n macro_rules! include {() => {}}\n \n@@ -483,7 +483,7 @@ fn bar() -> u32 {0}\n fn infer_builtin_macros_include_concat() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs \n+//- /main.rs\n #[rustc_builtin_macro]\n macro_rules! include {() => {}}\n \n@@ -507,7 +507,7 @@ fn bar() -> u32 {0}\n fn infer_builtin_macros_include_concat_with_bad_env_should_failed() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs \n+//- /main.rs\n #[rustc_builtin_macro]\n macro_rules! include {() => {}}\n \n@@ -534,7 +534,7 @@ fn bar() -> u32 {0}\n fn infer_builtin_macros_include_itself_should_failed() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs \n+//- /main.rs\n #[rustc_builtin_macro]\n macro_rules! include {() => {}}\n "}, {"sha": "82ec169135b70557038b4cd499de861d60435b86", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=6aa432d86b7e4fb691600032ebdf6f2301152447", "patch": "@@ -720,7 +720,18 @@ mod tests {\n                 }\n                 \",\n             ),\n-            @r###\"[]\"###\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [156; 156),\n+                delete: [156; 156),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###\n         );\n     }\n \n@@ -751,6 +762,43 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn macro_expansion_resilient() {\n+        assert_debug_snapshot!(\n+            do_ref_completion(\n+                r\"\n+                macro_rules! dbg {\n+                    () => {};\n+                    ($val:expr) => {\n+                        match $val { tmp => { tmp } }\n+                    };\n+                    // Trailing comma with single argument is ignored\n+                    ($val:expr,) => { $crate::dbg!($val) };\n+                    ($($val:expr),+ $(,)?) => {\n+                        ($($crate::dbg!($val)),+,)\n+                    };\n+                }\n+                struct A { the_field: u32 }\n+                fn foo(a: A) {\n+                    dbg!(a.<|>)\n+                }\n+                \",\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [552; 552),\n+                delete: [552; 552),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn test_method_completion_3547() {\n         assert_debug_snapshot!("}, {"sha": "cb84bb93489d125a5540a635c9c940c8351d851e", "filename": "crates/ra_ide/src/completion/complete_pattern.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs?ref=6aa432d86b7e4fb691600032ebdf6f2301152447", "patch": "@@ -89,7 +89,6 @@ mod tests {\n \n     #[test]\n     fn completes_in_simple_macro_call() {\n-        // FIXME: doesn't work yet because of missing error recovery in macro expansion\n         let completions = complete(\n             r\"\n             macro_rules! m { ($e:expr) => { $e } }\n@@ -102,6 +101,16 @@ mod tests {\n             }\n             \",\n         );\n-        assert_debug_snapshot!(completions, @r###\"[]\"###);\n+        assert_debug_snapshot!(completions, @r###\"\n+        [\n+            CompletionItem {\n+                label: \"E\",\n+                source_range: [151; 151),\n+                delete: [151; 151),\n+                insert: \"E\",\n+                kind: Enum,\n+            },\n+        ]\n+        \"###);\n     }\n }"}, {"sha": "81d3cc1b66f5c4c35ef45d9dfcc7ac9a7b2f9215", "filename": "crates/ra_ide/src/completion/complete_scope.rs", "status": "modified", "additions": 91, "deletions": 1, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=6aa432d86b7e4fb691600032ebdf6f2301152447", "patch": "@@ -811,7 +811,44 @@ mod tests {\n                 }\n                 \"\n             ),\n-            @\"[]\"\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"m!\",\n+                source_range: [145; 145),\n+                delete: [145; 145),\n+                insert: \"m!($0)\",\n+                kind: Macro,\n+                detail: \"macro_rules! m\",\n+            },\n+            CompletionItem {\n+                label: \"quux(\u2026)\",\n+                source_range: [145; 145),\n+                delete: [145; 145),\n+                insert: \"quux(${1:x})$0\",\n+                kind: Function,\n+                lookup: \"quux\",\n+                detail: \"fn quux(x: i32)\",\n+                trigger_call_info: true,\n+            },\n+            CompletionItem {\n+                label: \"x\",\n+                source_range: [145; 145),\n+                delete: [145; 145),\n+                insert: \"x\",\n+                kind: Binding,\n+                detail: \"i32\",\n+            },\n+            CompletionItem {\n+                label: \"y\",\n+                source_range: [145; 145),\n+                delete: [145; 145),\n+                insert: \"y\",\n+                kind: Binding,\n+                detail: \"i32\",\n+            },\n+        ]\n+        \"###\n         );\n     }\n \n@@ -868,6 +905,59 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn completes_in_simple_macro_without_closing_parens() {\n+        assert_debug_snapshot!(\n+                    do_reference_completion(\n+                        r\"\n+                macro_rules! m { ($e:expr) => { $e } }\n+                fn quux(x: i32) {\n+                    let y = 92;\n+                    m!(x<|>\n+                }\n+                \"\n+                    ),\n+                    @r###\"\n+        [\n+            CompletionItem {\n+                label: \"m!\",\n+                source_range: [145; 146),\n+                delete: [145; 146),\n+                insert: \"m!($0)\",\n+                kind: Macro,\n+                detail: \"macro_rules! m\",\n+            },\n+            CompletionItem {\n+                label: \"quux(\u2026)\",\n+                source_range: [145; 146),\n+                delete: [145; 146),\n+                insert: \"quux(${1:x})$0\",\n+                kind: Function,\n+                lookup: \"quux\",\n+                detail: \"fn quux(x: i32)\",\n+                trigger_call_info: true,\n+            },\n+            CompletionItem {\n+                label: \"x\",\n+                source_range: [145; 146),\n+                delete: [145; 146),\n+                insert: \"x\",\n+                kind: Binding,\n+                detail: \"i32\",\n+            },\n+            CompletionItem {\n+                label: \"y\",\n+                source_range: [145; 146),\n+                delete: [145; 146),\n+                insert: \"y\",\n+                kind: Binding,\n+                detail: \"i32\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn completes_unresolved_uses() {\n         assert_debug_snapshot!("}, {"sha": "54589a2a8327898f6e8c942e8455654a27af5c83", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=6aa432d86b7e4fb691600032ebdf6f2301152447", "patch": "@@ -135,7 +135,7 @@ impl<'a> CompletionContext<'a> {\n                 ),\n             ) {\n                 let new_offset = hypothetical_expansion.1.text_range().start();\n-                if new_offset >= actual_expansion.text_range().end() {\n+                if new_offset > actual_expansion.text_range().end() {\n                     break;\n                 }\n                 original_file = actual_expansion;"}, {"sha": "e58526f31f50d637cf2b7cc84214aa41feb03fe1", "filename": "crates/ra_ide/src/expand_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs?ref=6aa432d86b7e4fb691600032ebdf6f2301152447", "patch": "@@ -259,7 +259,7 @@ fn some_thing() -> u32 {\n         );\n \n         assert_eq!(res.name, \"foo\");\n-        assert_snapshot!(res.expansion, @r###\"bar!()\"###);\n+        assert_snapshot!(res.expansion, @r###\"\"###);\n     }\n \n     #[test]"}, {"sha": "6a9037bfc83621eb92e127f5128bdbef657bbf0c", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=6aa432d86b7e4fb691600032ebdf6f2301152447", "patch": "@@ -150,7 +150,7 @@ impl MacroRules {\n         Ok(MacroRules { rules, shift: Shift::new(tt) })\n     }\n \n-    pub fn expand(&self, tt: &tt::Subtree) -> Result<tt::Subtree, ExpandError> {\n+    pub fn expand(&self, tt: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n         // apply shift\n         let mut tt = tt.clone();\n         self.shift.shift_all(&mut tt);\n@@ -209,5 +209,35 @@ fn validate(pattern: &tt::Subtree) -> Result<(), ParseError> {\n     Ok(())\n }\n \n+pub struct ExpandResult<T>(pub T, pub Option<ExpandError>);\n+\n+impl<T> ExpandResult<T> {\n+    pub fn ok(t: T) -> ExpandResult<T> {\n+        ExpandResult(t, None)\n+    }\n+\n+    pub fn only_err(err: ExpandError) -> ExpandResult<T>\n+    where\n+        T: Default,\n+    {\n+        ExpandResult(Default::default(), Some(err))\n+    }\n+\n+    pub fn map<U>(self, f: impl FnOnce(T) -> U) -> ExpandResult<U> {\n+        ExpandResult(f(self.0), self.1)\n+    }\n+\n+    pub fn result(self) -> Result<T, ExpandError> {\n+        self.1.map(Err).unwrap_or(Ok(self.0))\n+    }\n+}\n+\n+impl<T: Default> From<Result<T, ExpandError>> for ExpandResult<T> {\n+    fn from(result: Result<T, ExpandError>) -> ExpandResult<T> {\n+        result\n+            .map_or_else(|e| ExpandResult(Default::default(), Some(e)), |it| ExpandResult(it, None))\n+    }\n+}\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "b1eacf1242c811470b6b4b937c05e754fe0a9d47", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 45, "deletions": 16, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=6aa432d86b7e4fb691600032ebdf6f2301152447", "patch": "@@ -8,19 +8,51 @@ mod transcriber;\n use ra_syntax::SmolStr;\n use rustc_hash::FxHashMap;\n \n-use crate::ExpandError;\n+use crate::{ExpandError, ExpandResult};\n \n-pub(crate) fn expand(\n-    rules: &crate::MacroRules,\n-    input: &tt::Subtree,\n-) -> Result<tt::Subtree, ExpandError> {\n-    rules.rules.iter().find_map(|it| expand_rule(it, input).ok()).ok_or(ExpandError::NoMatchingRule)\n+pub(crate) fn expand(rules: &crate::MacroRules, input: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n+    expand_rules(&rules.rules, input)\n }\n \n-fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> Result<tt::Subtree, ExpandError> {\n-    let bindings = matcher::match_(&rule.lhs, input)?;\n-    let res = transcriber::transcribe(&rule.rhs, &bindings)?;\n-    Ok(res)\n+fn expand_rules(rules: &[crate::Rule], input: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n+    let mut match_: Option<(matcher::Match, &crate::Rule)> = None;\n+    for rule in rules {\n+        let new_match = match matcher::match_(&rule.lhs, input) {\n+            Ok(m) => m,\n+            Err(_e) => {\n+                // error in pattern parsing\n+                continue;\n+            }\n+        };\n+        if new_match.err.is_none() {\n+            // If we find a rule that applies without errors, we're done.\n+            // Unconditionally returning the transcription here makes the\n+            // `test_repeat_bad_var` test fail.\n+            let ExpandResult(res, transcribe_err) =\n+                transcriber::transcribe(&rule.rhs, &new_match.bindings);\n+            if transcribe_err.is_none() {\n+                return ExpandResult::ok(res);\n+            }\n+        }\n+        // Use the rule if we matched more tokens, or had fewer errors\n+        if let Some((prev_match, _)) = &match_ {\n+            if (new_match.unmatched_tts, new_match.err_count)\n+                < (prev_match.unmatched_tts, prev_match.err_count)\n+            {\n+                match_ = Some((new_match, rule));\n+            }\n+        } else {\n+            match_ = Some((new_match, rule));\n+        }\n+    }\n+    if let Some((match_, rule)) = match_ {\n+        // if we got here, there was no match without errors\n+        let ExpandResult(result, transcribe_err) =\n+            transcriber::transcribe(&rule.rhs, &match_.bindings);\n+        ExpandResult(result, match_.err.or(transcribe_err))\n+    } else {\n+        ExpandResult(tt::Subtree::default(), Some(ExpandError::NoMatchingRule))\n+    }\n }\n \n /// The actual algorithm for expansion is not too hard, but is pretty tricky.\n@@ -111,7 +143,7 @@ mod tests {\n     }\n \n     fn assert_err(macro_body: &str, invocation: &str, err: ExpandError) {\n-        assert_eq!(expand_first(&create_rules(&format_macro(macro_body)), invocation), Err(err));\n+        assert_eq!(expand_first(&create_rules(&format_macro(macro_body)), invocation).1, Some(err));\n     }\n \n     fn format_macro(macro_body: &str) -> String {\n@@ -135,17 +167,14 @@ mod tests {\n         crate::MacroRules::parse(&definition_tt).unwrap()\n     }\n \n-    fn expand_first(\n-        rules: &crate::MacroRules,\n-        invocation: &str,\n-    ) -> Result<tt::Subtree, ExpandError> {\n+    fn expand_first(rules: &crate::MacroRules, invocation: &str) -> ExpandResult<tt::Subtree> {\n         let source_file = ast::SourceFile::parse(invocation).ok().unwrap();\n         let macro_invocation =\n             source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n         let (invocation_tt, _) =\n             ast_to_token_tree(&macro_invocation.token_tree().unwrap()).unwrap();\n \n-        expand_rule(&rules.rules[0], &invocation_tt)\n+        expand_rules(&rules.rules, &invocation_tt)\n     }\n }"}, {"sha": "2579382da8dad14d2ef5f3744113bc320d482588", "filename": "crates/ra_mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 136, "deletions": 76, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=6aa432d86b7e4fb691600032ebdf6f2301152447", "patch": "@@ -8,6 +8,7 @@ use crate::{\n     ExpandError,\n };\n \n+use super::ExpandResult;\n use ra_parser::{FragmentKind::*, TreeSink};\n use ra_syntax::{SmolStr, SyntaxKind};\n use tt::buffer::{Cursor, TokenBuffer};\n@@ -58,36 +59,61 @@ macro_rules! err {\n     };\n }\n \n-macro_rules! bail {\n-    ($($tt:tt)*) => {\n-        return Err(err!($($tt)*))\n-    };\n+#[derive(Debug, Default)]\n+pub(super) struct Match {\n+    pub bindings: Bindings,\n+    /// We currently just keep the first error and count the rest to compare matches.\n+    pub err: Option<ExpandError>,\n+    pub err_count: usize,\n+    /// How many top-level token trees were left to match.\n+    pub unmatched_tts: usize,\n }\n \n-pub(super) fn match_(pattern: &tt::Subtree, src: &tt::Subtree) -> Result<Bindings, ExpandError> {\n+impl Match {\n+    pub fn add_err(&mut self, err: ExpandError) {\n+        let prev_err = self.err.take();\n+        self.err = prev_err.or(Some(err));\n+        self.err_count += 1;\n+    }\n+}\n+\n+// General note: These functions have two channels to return errors, a `Result`\n+// return value and the `&mut Match`. The returned Result is for pattern parsing\n+// errors; if a branch of the macro definition doesn't parse, it doesn't make\n+// sense to try using it. Matching errors are added to the `Match`. It might\n+// make sense to make pattern parsing a separate step?\n+\n+pub(super) fn match_(pattern: &tt::Subtree, src: &tt::Subtree) -> Result<Match, ExpandError> {\n     assert!(pattern.delimiter == None);\n \n-    let mut res = Bindings::default();\n+    let mut res = Match::default();\n     let mut src = TtIter::new(src);\n \n     match_subtree(&mut res, pattern, &mut src)?;\n \n     if src.len() > 0 {\n-        bail!(\"leftover tokens\");\n+        res.unmatched_tts += src.len();\n+        res.add_err(err!(\"leftover tokens\"));\n     }\n \n     Ok(res)\n }\n \n fn match_subtree(\n-    bindings: &mut Bindings,\n+    res: &mut Match,\n     pattern: &tt::Subtree,\n     src: &mut TtIter,\n ) -> Result<(), ExpandError> {\n     for op in parse_pattern(pattern) {\n         match op? {\n             Op::TokenTree(tt::TokenTree::Leaf(lhs)) => {\n-                let rhs = src.expect_leaf().map_err(|()| err!(\"expected leaf: `{}`\", lhs))?;\n+                let rhs = match src.expect_leaf() {\n+                    Ok(l) => l,\n+                    Err(()) => {\n+                        res.add_err(err!(\"expected leaf: `{}`\", lhs));\n+                        continue;\n+                    }\n+                };\n                 match (lhs, rhs) {\n                     (\n                         tt::Leaf::Punct(tt::Punct { char: lhs, .. }),\n@@ -101,31 +127,51 @@ fn match_subtree(\n                         tt::Leaf::Literal(tt::Literal { text: lhs, .. }),\n                         tt::Leaf::Literal(tt::Literal { text: rhs, .. }),\n                     ) if lhs == rhs => (),\n-                    _ => return Err(ExpandError::UnexpectedToken),\n+                    _ => {\n+                        res.add_err(ExpandError::UnexpectedToken);\n+                    }\n                 }\n             }\n             Op::TokenTree(tt::TokenTree::Subtree(lhs)) => {\n-                let rhs = src.expect_subtree().map_err(|()| err!(\"expected subtree\"))?;\n+                let rhs = match src.expect_subtree() {\n+                    Ok(s) => s,\n+                    Err(()) => {\n+                        res.add_err(err!(\"expected subtree\"));\n+                        continue;\n+                    }\n+                };\n                 if lhs.delimiter_kind() != rhs.delimiter_kind() {\n-                    bail!(\"mismatched delimiter\")\n+                    res.add_err(err!(\"mismatched delimiter\"));\n+                    continue;\n                 }\n                 let mut src = TtIter::new(rhs);\n-                match_subtree(bindings, lhs, &mut src)?;\n+                match_subtree(res, lhs, &mut src)?;\n                 if src.len() > 0 {\n-                    bail!(\"leftover tokens\");\n+                    res.add_err(err!(\"leftover tokens\"));\n                 }\n             }\n             Op::Var { name, kind } => {\n-                let kind = kind.as_ref().ok_or(ExpandError::UnexpectedToken)?;\n-                match match_meta_var(kind.as_str(), src)? {\n+                let kind = match kind {\n+                    Some(k) => k,\n+                    None => {\n+                        res.add_err(ExpandError::UnexpectedToken);\n+                        continue;\n+                    }\n+                };\n+                let ExpandResult(matched, match_err) = match_meta_var(kind.as_str(), src);\n+                match matched {\n                     Some(fragment) => {\n-                        bindings.inner.insert(name.clone(), Binding::Fragment(fragment));\n+                        res.bindings.inner.insert(name.clone(), Binding::Fragment(fragment));\n                     }\n-                    None => bindings.push_optional(name),\n+                    None if match_err.is_none() => res.bindings.push_optional(name),\n+                    _ => {}\n+                }\n+                if let Some(err) = match_err {\n+                    res.add_err(err);\n                 }\n             }\n             Op::Repeat { subtree, kind, separator } => {\n-                match_repeat(bindings, subtree, kind, separator, src)?\n+                match_repeat(res, subtree, kind, separator, src)?;\n             }\n         }\n     }\n@@ -221,7 +267,7 @@ impl<'a> TtIter<'a> {\n     pub(crate) fn expect_fragment(\n         &mut self,\n         fragment_kind: ra_parser::FragmentKind,\n-    ) -> Result<tt::TokenTree, ()> {\n+    ) -> ExpandResult<Option<tt::TokenTree>> {\n         pub(crate) struct OffsetTokenSink<'a> {\n             pub(crate) cursor: Cursor<'a>,\n             pub(crate) error: bool,\n@@ -246,45 +292,51 @@ impl<'a> TtIter<'a> {\n \n         ra_parser::parse_fragment(&mut src, &mut sink, fragment_kind);\n \n+        let mut err = None;\n         if !sink.cursor.is_root() || sink.error {\n-            // FIXME better recovery in this case would help completion inside macros immensely\n-            return Err(());\n+            err = Some(err!(\"expected {:?}\", fragment_kind));\n         }\n \n         let mut curr = buffer.begin();\n         let mut res = vec![];\n \n-        while curr != sink.cursor {\n-            if let Some(token) = curr.token_tree() {\n-                res.push(token);\n+        if sink.cursor.is_root() {\n+            while curr != sink.cursor {\n+                if let Some(token) = curr.token_tree() {\n+                    res.push(token);\n+                }\n+                curr = curr.bump();\n             }\n-            curr = curr.bump();\n         }\n         self.inner = self.inner.as_slice()[res.len()..].iter();\n-        match res.len() {\n-            0 => Err(()),\n-            1 => Ok(res[0].clone()),\n-            _ => Ok(tt::TokenTree::Subtree(tt::Subtree {\n+        if res.len() == 0 && err.is_none() {\n+            err = Some(err!(\"no tokens consumed\"));\n+        }\n+        let res = match res.len() {\n+            1 => Some(res[0].clone()),\n+            0 => None,\n+            _ => Some(tt::TokenTree::Subtree(tt::Subtree {\n                 delimiter: None,\n                 token_trees: res.into_iter().cloned().collect(),\n             })),\n-        }\n+        };\n+        ExpandResult(res, err)\n     }\n \n     pub(crate) fn eat_vis(&mut self) -> Option<tt::TokenTree> {\n         let mut fork = self.clone();\n         match fork.expect_fragment(Visibility) {\n-            Ok(tt) => {\n+            ExpandResult(tt, None) => {\n                 *self = fork;\n-                Some(tt)\n+                tt\n             }\n-            Err(()) => None,\n+            ExpandResult(_, Some(_)) => None,\n         }\n     }\n }\n \n pub(super) fn match_repeat(\n-    bindings: &mut Bindings,\n+    res: &mut Match,\n     pattern: &tt::Subtree,\n     kind: RepeatKind,\n     separator: Option<Separator>,\n@@ -304,44 +356,54 @@ pub(super) fn match_repeat(\n             }\n         }\n \n-        let mut nested = Bindings::default();\n-        match match_subtree(&mut nested, pattern, &mut fork) {\n-            Ok(()) => {\n-                limit -= 1;\n-                if limit == 0 {\n-                    log::warn!(\"match_lhs excced in repeat pattern exceed limit => {:#?}\\n{:#?}\\n{:#?}\\n{:#?}\", pattern, src, kind, separator);\n-                    break;\n-                }\n-                *src = fork;\n+        let mut nested = Match::default();\n+        match_subtree(&mut nested, pattern, &mut fork)?;\n+        if nested.err.is_none() {\n+            limit -= 1;\n+            if limit == 0 {\n+                log::warn!(\n+                    \"match_lhs exceeded repeat pattern limit => {:#?}\\n{:#?}\\n{:#?}\\n{:#?}\",\n+                    pattern,\n+                    src,\n+                    kind,\n+                    separator\n+                );\n+                break;\n+            }\n+            *src = fork;\n \n-                bindings.push_nested(counter, nested)?;\n-                counter += 1;\n-                if counter == 1 {\n-                    if let RepeatKind::ZeroOrOne = kind {\n-                        break;\n-                    }\n+            if let Err(err) = res.bindings.push_nested(counter, nested.bindings) {\n+                res.add_err(err);\n+            }\n+            counter += 1;\n+            if counter == 1 {\n+                if let RepeatKind::ZeroOrOne = kind {\n+                    break;\n                 }\n             }\n-            Err(_) => break,\n+        } else {\n+            break;\n         }\n     }\n \n     match (kind, counter) {\n-        (RepeatKind::OneOrMore, 0) => return Err(ExpandError::UnexpectedToken),\n+        (RepeatKind::OneOrMore, 0) => {\n+            res.add_err(ExpandError::UnexpectedToken);\n+        }\n         (_, 0) => {\n             // Collect all empty variables in subtrees\n             let mut vars = Vec::new();\n             collect_vars(&mut vars, pattern)?;\n             for var in vars {\n-                bindings.push_empty(&var)\n+                res.bindings.push_empty(&var)\n             }\n         }\n         _ => (),\n     }\n     Ok(())\n }\n \n-fn match_meta_var(kind: &str, input: &mut TtIter) -> Result<Option<Fragment>, ExpandError> {\n+fn match_meta_var(kind: &str, input: &mut TtIter) -> ExpandResult<Option<Fragment>> {\n     let fragment = match kind {\n         \"path\" => Path,\n         \"expr\" => Expr,\n@@ -352,34 +414,32 @@ fn match_meta_var(kind: &str, input: &mut TtIter) -> Result<Option<Fragment>, Ex\n         \"meta\" => MetaItem,\n         \"item\" => Item,\n         _ => {\n-            let tt = match kind {\n-                \"ident\" => {\n-                    let ident = input.expect_ident().map_err(|()| err!(\"expected ident\"))?.clone();\n-                    tt::Leaf::from(ident).into()\n-                }\n-                \"tt\" => input.expect_tt().map_err(|()| err!())?.clone(),\n-                \"lifetime\" => {\n-                    let ident = input.expect_lifetime().map_err(|()| err!())?;\n-                    tt::Leaf::Ident(ident.clone()).into()\n-                }\n-                \"literal\" => {\n-                    let literal = input.expect_literal().map_err(|()| err!())?.clone();\n-                    tt::Leaf::from(literal).into()\n-                }\n+            let tt_result = match kind {\n+                \"ident\" => input\n+                    .expect_ident()\n+                    .map(|ident| Some(tt::Leaf::from(ident.clone()).into()))\n+                    .map_err(|()| err!(\"expected ident\")),\n+                \"tt\" => input.expect_tt().map(Some).map_err(|()| err!()),\n+                \"lifetime\" => input\n+                    .expect_lifetime()\n+                    .map(|ident| Some(tt::Leaf::Ident(ident.clone()).into()))\n+                    .map_err(|()| err!(\"expected lifetime\")),\n+                \"literal\" => input\n+                    .expect_literal()\n+                    .map(|literal| Some(tt::Leaf::from(literal.clone()).into()))\n+                    .map_err(|()| err!()),\n                 // `vis` is optional\n                 \"vis\" => match input.eat_vis() {\n-                    Some(vis) => vis,\n-                    None => return Ok(None),\n+                    Some(vis) => Ok(Some(vis)),\n+                    None => Ok(None),\n                 },\n-                _ => return Err(ExpandError::UnexpectedToken),\n+                _ => Err(ExpandError::UnexpectedToken),\n             };\n-            return Ok(Some(Fragment::Tokens(tt)));\n+            return tt_result.map(|it| it.map(Fragment::Tokens)).into();\n         }\n     };\n-    let tt =\n-        input.expect_fragment(fragment).map_err(|()| err!(\"fragment did not parse as {}\", kind))?;\n-    let fragment = if kind == \"expr\" { Fragment::Ast(tt) } else { Fragment::Tokens(tt) };\n-    Ok(Some(fragment))\n+    let result = input.expect_fragment(fragment);\n+    result.map(|tt| if kind == \"expr\" { tt.map(Fragment::Ast) } else { tt.map(Fragment::Tokens) })\n }\n \n fn collect_vars(buf: &mut Vec<SmolStr>, pattern: &tt::Subtree) -> Result<(), ExpandError> {"}, {"sha": "4b173edd3f9103b6eb7b84d474d51884d97cb25b", "filename": "crates/ra_mbe/src/mbe_expander/transcriber.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=6aa432d86b7e4fb691600032ebdf6f2301152447", "patch": "@@ -3,6 +3,7 @@\n \n use ra_syntax::SmolStr;\n \n+use super::ExpandResult;\n use crate::{\n     mbe_expander::{Binding, Bindings, Fragment},\n     parser::{parse_template, Op, RepeatKind, Separator},\n@@ -49,10 +50,7 @@ impl Bindings {\n     }\n }\n \n-pub(super) fn transcribe(\n-    template: &tt::Subtree,\n-    bindings: &Bindings,\n-) -> Result<tt::Subtree, ExpandError> {\n+pub(super) fn transcribe(template: &tt::Subtree, bindings: &Bindings) -> ExpandResult<tt::Subtree> {\n     assert!(template.delimiter == None);\n     let mut ctx = ExpandCtx { bindings: &bindings, nesting: Vec::new() };\n     expand_subtree(&mut ctx, template)\n@@ -75,35 +73,46 @@ struct ExpandCtx<'a> {\n     nesting: Vec<NestingState>,\n }\n \n-fn expand_subtree(ctx: &mut ExpandCtx, template: &tt::Subtree) -> Result<tt::Subtree, ExpandError> {\n+fn expand_subtree(ctx: &mut ExpandCtx, template: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n     let mut buf: Vec<tt::TokenTree> = Vec::new();\n+    let mut err = None;\n     for op in parse_template(template) {\n-        match op? {\n+        let op = match op {\n+            Ok(op) => op,\n+            Err(e) => {\n+                err = Some(e);\n+                break;\n+            }\n+        };\n+        match op {\n             Op::TokenTree(tt @ tt::TokenTree::Leaf(..)) => buf.push(tt.clone()),\n             Op::TokenTree(tt::TokenTree::Subtree(tt)) => {\n-                let tt = expand_subtree(ctx, tt)?;\n+                let ExpandResult(tt, e) = expand_subtree(ctx, tt);\n+                err = err.or(e);\n                 buf.push(tt.into());\n             }\n             Op::Var { name, kind: _ } => {\n-                let fragment = expand_var(ctx, name)?;\n+                let ExpandResult(fragment, e) = expand_var(ctx, name);\n+                err = err.or(e);\n                 push_fragment(&mut buf, fragment);\n             }\n             Op::Repeat { subtree, kind, separator } => {\n-                let fragment = expand_repeat(ctx, subtree, kind, separator)?;\n+                let ExpandResult(fragment, e) = expand_repeat(ctx, subtree, kind, separator);\n+                err = err.or(e);\n                 push_fragment(&mut buf, fragment)\n             }\n         }\n     }\n-    Ok(tt::Subtree { delimiter: template.delimiter, token_trees: buf })\n+    ExpandResult(tt::Subtree { delimiter: template.delimiter, token_trees: buf }, err)\n }\n \n-fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> Result<Fragment, ExpandError> {\n-    let res = if v == \"crate\" {\n+fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> ExpandResult<Fragment> {\n+    if v == \"crate\" {\n         // We simply produce identifier `$crate` here. And it will be resolved when lowering ast to Path.\n         let tt =\n             tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: tt::TokenId::unspecified() })\n                 .into();\n-        Fragment::Tokens(tt)\n+        ExpandResult::ok(Fragment::Tokens(tt))\n     } else if !ctx.bindings.contains(v) {\n         // Note that it is possible to have a `$var` inside a macro which is not bound.\n         // For example:\n@@ -132,29 +141,31 @@ fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> Result<Fragment, ExpandError>\n             ],\n         }\n         .into();\n-        Fragment::Tokens(tt)\n+        ExpandResult::ok(Fragment::Tokens(tt))\n     } else {\n-        ctx.bindings.get(&v, &mut ctx.nesting)?.clone()\n-    };\n-    Ok(res)\n+        ctx.bindings.get(&v, &mut ctx.nesting).map_or_else(\n+            |e| ExpandResult(Fragment::Tokens(tt::TokenTree::empty()), Some(e)),\n+            |b| ExpandResult::ok(b.clone()),\n+        )\n+    }\n }\n \n fn expand_repeat(\n     ctx: &mut ExpandCtx,\n     template: &tt::Subtree,\n     kind: RepeatKind,\n     separator: Option<Separator>,\n-) -> Result<Fragment, ExpandError> {\n+) -> ExpandResult<Fragment> {\n     let mut buf: Vec<tt::TokenTree> = Vec::new();\n     ctx.nesting.push(NestingState { idx: 0, at_end: false, hit: false });\n     // Dirty hack to make macro-expansion terminate.\n-    // This should be replaced by a propper macro-by-example implementation\n+    // This should be replaced by a proper macro-by-example implementation\n     let limit = 65536;\n     let mut has_seps = 0;\n     let mut counter = 0;\n \n     loop {\n-        let res = expand_subtree(ctx, template);\n+        let ExpandResult(mut t, e) = expand_subtree(ctx, template);\n         let nesting_state = ctx.nesting.last_mut().unwrap();\n         if nesting_state.at_end || !nesting_state.hit {\n             break;\n@@ -172,10 +183,10 @@ fn expand_repeat(\n             break;\n         }\n \n-        let mut t = match res {\n-            Ok(t) => t,\n-            Err(_) => continue,\n-        };\n+        if e.is_some() {\n+            continue;\n+        }\n+\n         t.delimiter = None;\n         push_subtree(&mut buf, t);\n \n@@ -209,14 +220,14 @@ fn expand_repeat(\n         buf.pop();\n     }\n \n-    if RepeatKind::OneOrMore == kind && counter == 0 {\n-        return Err(ExpandError::UnexpectedToken);\n-    }\n-\n     // Check if it is a single token subtree without any delimiter\n     // e.g {Delimiter:None> ['>'] /Delimiter:None>}\n     let tt = tt::Subtree { delimiter: None, token_trees: buf }.into();\n-    Ok(Fragment::Tokens(tt))\n+\n+    if RepeatKind::OneOrMore == kind && counter == 0 {\n+        return ExpandResult(Fragment::Tokens(tt), Some(ExpandError::UnexpectedToken));\n+    }\n+    ExpandResult::ok(Fragment::Tokens(tt))\n }\n \n fn push_fragment(buf: &mut Vec<tt::TokenTree>, fragment: Fragment) {"}, {"sha": "44f3819388bda96e503f02577855bbf14a747b18", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=6aa432d86b7e4fb691600032ebdf6f2301152447", "patch": "@@ -1430,7 +1430,7 @@ impl MacroFixture {\n         let (invocation_tt, _) =\n             ast_to_token_tree(&macro_invocation.token_tree().unwrap()).unwrap();\n \n-        self.rules.expand(&invocation_tt)\n+        self.rules.expand(&invocation_tt).result()\n     }\n \n     fn assert_expand_err(&self, invocation: &str, err: &ExpandError) {\n@@ -1662,5 +1662,5 @@ fn test_expand_bad_literal() {\n         macro_rules! foo { ($i:literal) => {}; }\n     \"#,\n     )\n-    .assert_expand_err(r#\"foo!(&k\");\"#, &ExpandError::NoMatchingRule);\n+    .assert_expand_err(r#\"foo!(&k\");\"#, &ExpandError::BindingError(\"\".to_string()));\n }"}, {"sha": "2335d99b3ae2a88e61e6cf6b9620d6b3f9a4e9c8", "filename": "crates/ra_parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=6aa432d86b7e4fb691600032ebdf6f2301152447", "patch": "@@ -61,7 +61,7 @@ pub(super) const ATOM_EXPR_FIRST: TokenSet =\n         LIFETIME,\n     ]);\n \n-const EXPR_RECOVERY_SET: TokenSet = token_set![LET_KW];\n+const EXPR_RECOVERY_SET: TokenSet = token_set![LET_KW, R_DOLLAR];\n \n pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<(CompletedMarker, BlockLike)> {\n     if let Some(m) = literal(p) {"}, {"sha": "1e2fb8b913b8da9a640bb0efedf864faec1645fb", "filename": "crates/ra_tt/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_tt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa432d86b7e4fb691600032ebdf6f2301152447/crates%2Fra_tt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tt%2Fsrc%2Flib.rs?ref=6aa432d86b7e4fb691600032ebdf6f2301152447", "patch": "@@ -40,6 +40,12 @@ pub enum TokenTree {\n }\n impl_froms!(TokenTree: Leaf, Subtree);\n \n+impl TokenTree {\n+    pub fn empty() -> Self {\n+        TokenTree::Subtree(Subtree::default())\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Leaf {\n     Literal(Literal),"}]}