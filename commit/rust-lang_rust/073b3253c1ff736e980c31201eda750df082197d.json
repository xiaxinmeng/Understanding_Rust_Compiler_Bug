{"sha": "073b3253c1ff736e980c31201eda750df082197d", "node_id": "C_kwDOAAsO6NoAKDA3M2IzMjUzYzFmZjczNmU5ODBjMzEyMDFlZGE3NTBkZjA4MjE5N2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-14T14:29:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-14T14:29:37Z"}, "message": "Auto merge of #12556 - DorianListens:dscheidt/generic-extract, r=Veykril\n\nfix: Support generics in extract_function assist\n\nThis change attempts to resolve issue #7636: Extract into Function does not\ncreate a generic function with constraints when extracting generic code.\n\nIn `FunctionBody::analyze_container`, we now traverse the `ancestors` in search\nof `AnyHasGenericParams`, and attach any `GenericParamList`s and `WhereClause`s\nwe find to the `ContainerInfo`.\n\nLater, in `format_function`, we collect all the `GenericParam`s and\n`WherePred`s from the container, and filter them to keep only types matching\n`TypeParam`s used within the newly extracted function body or param list. We\ncan then include the new `GenericParamList` and `WhereClause` in the new\nfunction definition.\n\nThis change only impacts `TypeParam`s. `LifetimeParam`s and `ConstParam`s are\nout of scope for this change.\n\nI've never contributed to this project before, but I did try to follow the style guide. I believe that this change represents an improvement over the status quo, but I think it's also fair to argue that it doesn't fully \"fix\" the linked issue. I'm totally open to merging this as is, or going further to try to make a more complete solution. Also: if there are other unit or integration tests I should add, please let me know where to look!", "tree": {"sha": "5276fb404a33a35785c1050e0d86d732cfc5fd43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5276fb404a33a35785c1050e0d86d732cfc5fd43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/073b3253c1ff736e980c31201eda750df082197d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/073b3253c1ff736e980c31201eda750df082197d", "html_url": "https://github.com/rust-lang/rust/commit/073b3253c1ff736e980c31201eda750df082197d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/073b3253c1ff736e980c31201eda750df082197d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbba1d7acbd84435e63d185d57c2d88e88f489ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbba1d7acbd84435e63d185d57c2d88e88f489ee", "html_url": "https://github.com/rust-lang/rust/commit/fbba1d7acbd84435e63d185d57c2d88e88f489ee"}, {"sha": "796641b5d85d06f2884e28971a358421976aefaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/796641b5d85d06f2884e28971a358421976aefaa", "html_url": "https://github.com/rust-lang/rust/commit/796641b5d85d06f2884e28971a358421976aefaa"}], "stats": {"total": 474, "additions": 467, "deletions": 7}, "files": [{"sha": "86124b68b51bf53c6ec84479bc84fb20aa033692", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/073b3253c1ff736e980c31201eda750df082197d/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073b3253c1ff736e980c31201eda750df082197d/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=073b3253c1ff736e980c31201eda750df082197d", "patch": "@@ -3307,6 +3307,15 @@ impl Type {\n         let tys = hir_ty::replace_errors_with_variables(&(self.ty.clone(), to.ty.clone()));\n         hir_ty::could_coerce(db, self.env.clone(), &tys)\n     }\n+\n+    pub fn as_type_param(&self, db: &dyn HirDatabase) -> Option<TypeParam> {\n+        match self.ty.kind(Interner) {\n+            TyKind::Placeholder(p) => Some(TypeParam {\n+                id: TypeParamId::from_unchecked(hir_ty::from_placeholder_idx(db, *p)),\n+            }),\n+            _ => None,\n+        }\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "94b638d4c600ec10cc8c6608c2ef68e9b9f16438", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 458, "deletions": 7, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/073b3253c1ff736e980c31201eda750df082197d/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073b3253c1ff736e980c31201eda750df082197d/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=073b3253c1ff736e980c31201eda750df082197d", "patch": "@@ -2,7 +2,9 @@ use std::iter;\n \n use ast::make;\n use either::Either;\n-use hir::{HasSource, HirDisplay, InFile, Local, ModuleDef, Semantics, TypeInfo};\n+use hir::{\n+    HasSource, HirDisplay, InFile, Local, ModuleDef, PathResolution, Semantics, TypeInfo, TypeParam,\n+};\n use ide_db::{\n     defs::{Definition, NameRefClass},\n     famous_defs::FamousDefs,\n@@ -18,7 +20,7 @@ use syntax::{\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n-        AstNode,\n+        AstNode, HasGenericParams,\n     },\n     match_ast, ted, SyntaxElement,\n     SyntaxKind::{self, COMMENT},\n@@ -294,6 +296,8 @@ struct ContainerInfo {\n     parent_loop: Option<SyntaxNode>,\n     /// The function's return type, const's type etc.\n     ret_type: Option<hir::Type>,\n+    generic_param_lists: Vec<ast::GenericParamList>,\n+    where_clauses: Vec<ast::WhereClause>,\n }\n \n /// Control flow that is exported from extracted function\n@@ -517,6 +521,24 @@ impl FunctionBody {\n         }\n     }\n \n+    fn descendants(&self) -> impl Iterator<Item = SyntaxNode> {\n+        match self {\n+            FunctionBody::Expr(expr) => expr.syntax().descendants(),\n+            FunctionBody::Span { parent, .. } => parent.syntax().descendants(),\n+        }\n+    }\n+\n+    fn descendant_paths(&self) -> impl Iterator<Item = ast::Path> {\n+        self.descendants().filter_map(|node| {\n+            match_ast! {\n+                match node {\n+                    ast::Path(it) => Some(it),\n+                    _ => None\n+                }\n+            }\n+        })\n+    }\n+\n     fn from_expr(expr: ast::Expr) -> Option<Self> {\n         match expr {\n             ast::Expr::BreakExpr(it) => it.expr().map(Self::Expr),\n@@ -731,6 +753,7 @@ impl FunctionBody {\n                 parent_loop.get_or_insert(loop_.syntax().clone());\n             }\n         };\n+\n         let (is_const, expr, ty) = loop {\n             let anc = ancestors.next()?;\n             break match_ast! {\n@@ -798,7 +821,20 @@ impl FunctionBody {\n             container_tail.zip(self.tail_expr()).map_or(false, |(container_tail, body_tail)| {\n                 container_tail.syntax().text_range().contains_range(body_tail.syntax().text_range())\n             });\n-        Some(ContainerInfo { is_in_tail, is_const, parent_loop, ret_type: ty })\n+\n+        let parent = self.parent()?;\n+        let parents = generic_parents(&parent);\n+        let generic_param_lists = parents.iter().filter_map(|it| it.generic_param_list()).collect();\n+        let where_clauses = parents.iter().filter_map(|it| it.where_clause()).collect();\n+\n+        Some(ContainerInfo {\n+            is_in_tail,\n+            is_const,\n+            parent_loop,\n+            ret_type: ty,\n+            generic_param_lists,\n+            where_clauses,\n+        })\n     }\n \n     fn return_ty(&self, ctx: &AssistContext) -> Option<RetType> {\n@@ -955,6 +991,56 @@ impl FunctionBody {\n     }\n }\n \n+enum GenericParent {\n+    Fn(ast::Fn),\n+    Impl(ast::Impl),\n+    Trait(ast::Trait),\n+}\n+\n+impl GenericParent {\n+    fn generic_param_list(&self) -> Option<ast::GenericParamList> {\n+        match self {\n+            GenericParent::Fn(fn_) => fn_.generic_param_list(),\n+            GenericParent::Impl(impl_) => impl_.generic_param_list(),\n+            GenericParent::Trait(trait_) => trait_.generic_param_list(),\n+        }\n+    }\n+\n+    fn where_clause(&self) -> Option<ast::WhereClause> {\n+        match self {\n+            GenericParent::Fn(fn_) => fn_.where_clause(),\n+            GenericParent::Impl(impl_) => impl_.where_clause(),\n+            GenericParent::Trait(trait_) => trait_.where_clause(),\n+        }\n+    }\n+}\n+\n+/// Search `parent`'s ancestors for items with potentially applicable generic parameters\n+fn generic_parents(parent: &SyntaxNode) -> Vec<GenericParent> {\n+    let mut list = Vec::new();\n+    if let Some(parent_item) = parent.ancestors().find_map(ast::Item::cast) {\n+        match parent_item {\n+            ast::Item::Fn(ref fn_) => {\n+                if let Some(parent_parent) = parent_item\n+                    .syntax()\n+                    .parent()\n+                    .and_then(|it| it.parent())\n+                    .and_then(ast::Item::cast)\n+                {\n+                    match parent_parent {\n+                        ast::Item::Impl(impl_) => list.push(GenericParent::Impl(impl_)),\n+                        ast::Item::Trait(trait_) => list.push(GenericParent::Trait(trait_)),\n+                        _ => (),\n+                    }\n+                }\n+                list.push(GenericParent::Fn(fn_.clone()));\n+            }\n+            _ => (),\n+        }\n+    }\n+    list\n+}\n+\n /// checks if relevant var is used with `&mut` access inside body\n fn has_exclusive_usages(ctx: &AssistContext, usages: &LocalUsages, body: &FunctionBody) -> bool {\n     usages\n@@ -1362,37 +1448,154 @@ fn format_function(\n     let const_kw = if fun.mods.is_const { \"const \" } else { \"\" };\n     let async_kw = if fun.control_flow.is_async { \"async \" } else { \"\" };\n     let unsafe_kw = if fun.control_flow.is_unsafe { \"unsafe \" } else { \"\" };\n+    let (generic_params, where_clause) = make_generic_params_and_where_clause(ctx, fun);\n     match ctx.config.snippet_cap {\n         Some(_) => format_to!(\n             fn_def,\n-            \"\\n\\n{}{}{}{}fn $0{}{}\",\n+            \"\\n\\n{}{}{}{}fn $0{}\",\n             new_indent,\n             const_kw,\n             async_kw,\n             unsafe_kw,\n             fun.name,\n-            params\n         ),\n         None => format_to!(\n             fn_def,\n-            \"\\n\\n{}{}{}{}fn {}{}\",\n+            \"\\n\\n{}{}{}{}fn {}\",\n             new_indent,\n             const_kw,\n             async_kw,\n             unsafe_kw,\n             fun.name,\n-            params\n         ),\n     }\n+\n+    if let Some(generic_params) = generic_params {\n+        format_to!(fn_def, \"{}\", generic_params);\n+    }\n+\n+    format_to!(fn_def, \"{}\", params);\n+\n     if let Some(ret_ty) = ret_ty {\n         format_to!(fn_def, \" {}\", ret_ty);\n     }\n+\n+    if let Some(where_clause) = where_clause {\n+        format_to!(fn_def, \" {}\", where_clause);\n+    }\n+\n     format_to!(fn_def, \" {}\", body);\n \n     fn_def\n }\n \n+fn make_generic_params_and_where_clause(\n+    ctx: &AssistContext,\n+    fun: &Function,\n+) -> (Option<ast::GenericParamList>, Option<ast::WhereClause>) {\n+    let used_type_params = fun.type_params(ctx);\n+\n+    let generic_param_list = make_generic_param_list(ctx, fun, &used_type_params);\n+    let where_clause = make_where_clause(ctx, fun, &used_type_params);\n+\n+    (generic_param_list, where_clause)\n+}\n+\n+fn make_generic_param_list(\n+    ctx: &AssistContext,\n+    fun: &Function,\n+    used_type_params: &[TypeParam],\n+) -> Option<ast::GenericParamList> {\n+    let mut generic_params = fun\n+        .mods\n+        .generic_param_lists\n+        .iter()\n+        .flat_map(|parent_params| {\n+            parent_params\n+                .generic_params()\n+                .filter(|param| param_is_required(ctx, param, used_type_params))\n+        })\n+        .peekable();\n+\n+    if generic_params.peek().is_some() {\n+        Some(make::generic_param_list(generic_params))\n+    } else {\n+        None\n+    }\n+}\n+\n+fn param_is_required(\n+    ctx: &AssistContext,\n+    param: &ast::GenericParam,\n+    used_type_params: &[TypeParam],\n+) -> bool {\n+    match param {\n+        ast::GenericParam::ConstParam(_) | ast::GenericParam::LifetimeParam(_) => false,\n+        ast::GenericParam::TypeParam(type_param) => match &ctx.sema.to_def(type_param) {\n+            Some(def) => used_type_params.contains(def),\n+            _ => false,\n+        },\n+    }\n+}\n+\n+fn make_where_clause(\n+    ctx: &AssistContext,\n+    fun: &Function,\n+    used_type_params: &[TypeParam],\n+) -> Option<ast::WhereClause> {\n+    let mut predicates = fun\n+        .mods\n+        .where_clauses\n+        .iter()\n+        .flat_map(|parent_where_clause| {\n+            parent_where_clause\n+                .predicates()\n+                .filter(|pred| pred_is_required(ctx, pred, used_type_params))\n+        })\n+        .peekable();\n+\n+    if predicates.peek().is_some() {\n+        Some(make::where_clause(predicates))\n+    } else {\n+        None\n+    }\n+}\n+\n+fn pred_is_required(\n+    ctx: &AssistContext,\n+    pred: &ast::WherePred,\n+    used_type_params: &[TypeParam],\n+) -> bool {\n+    match resolved_type_param(ctx, pred) {\n+        Some(it) => used_type_params.contains(&it),\n+        None => false,\n+    }\n+}\n+\n+fn resolved_type_param(ctx: &AssistContext, pred: &ast::WherePred) -> Option<TypeParam> {\n+    let path = match pred.ty()? {\n+        ast::Type::PathType(path_type) => path_type.path(),\n+        _ => None,\n+    }?;\n+\n+    match ctx.sema.resolve_path(&path)? {\n+        PathResolution::TypeParam(type_param) => Some(type_param),\n+        _ => None,\n+    }\n+}\n+\n impl Function {\n+    /// Collect all the `TypeParam`s used in the `body` and `params`.\n+    fn type_params(&self, ctx: &AssistContext) -> Vec<TypeParam> {\n+        let type_params_in_descendant_paths =\n+            self.body.descendant_paths().filter_map(|it| match ctx.sema.resolve_path(&it) {\n+                Some(PathResolution::TypeParam(type_param)) => Some(type_param),\n+                _ => None,\n+            });\n+        let type_params_in_params = self.params.iter().filter_map(|p| p.ty.as_type_param(ctx.db()));\n+        type_params_in_descendant_paths.chain(type_params_in_params).collect()\n+    }\n+\n     fn make_param_list(&self, ctx: &AssistContext, module: hir::Module) -> ast::ParamList {\n         let self_param = self.self_param.clone();\n         let params = self.params.iter().map(|param| param.to_param(ctx, module));\n@@ -4872,6 +5075,254 @@ fn parent(factor: i32) {\n fn $0fun_name(v: &[i32; 3], factor: i32) {\n     v.iter().map(|it| it * factor);\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn preserve_generics() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func<T: Debug>(i: T) {\n+    $0foo(i);$0\n+}\n+\"#,\n+            r#\"\n+fn func<T: Debug>(i: T) {\n+    fun_name(i);\n+}\n+\n+fn $0fun_name<T: Debug>(i: T) {\n+    foo(i);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn preserve_generics_from_body() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func<T: Default>() -> T {\n+    $0T::default()$0\n+}\n+\"#,\n+            r#\"\n+fn func<T: Default>() -> T {\n+    fun_name()\n+}\n+\n+fn $0fun_name<T: Default>() -> T {\n+    T::default()\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn filter_unused_generics() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func<T: Debug, U: Copy>(i: T, u: U) {\n+    bar(u);\n+    $0foo(i);$0\n+}\n+\"#,\n+            r#\"\n+fn func<T: Debug, U: Copy>(i: T, u: U) {\n+    bar(u);\n+    fun_name(i);\n+}\n+\n+fn $0fun_name<T: Debug>(i: T) {\n+    foo(i);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn empty_generic_param_list() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func<T: Debug>(t: T, i: u32) {\n+    bar(t);\n+    $0foo(i);$0\n+}\n+\"#,\n+            r#\"\n+fn func<T: Debug>(t: T, i: u32) {\n+    bar(t);\n+    fun_name(i);\n+}\n+\n+fn $0fun_name(i: u32) {\n+    foo(i);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn preserve_where_clause() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func<T>(i: T) where T: Debug {\n+    $0foo(i);$0\n+}\n+\"#,\n+            r#\"\n+fn func<T>(i: T) where T: Debug {\n+    fun_name(i);\n+}\n+\n+fn $0fun_name<T>(i: T) where T: Debug {\n+    foo(i);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn filter_unused_where_clause() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func<T, U>(i: T, u: U) where T: Debug, U: Copy {\n+    bar(u);\n+    $0foo(i);$0\n+}\n+\"#,\n+            r#\"\n+fn func<T, U>(i: T, u: U) where T: Debug, U: Copy {\n+    bar(u);\n+    fun_name(i);\n+}\n+\n+fn $0fun_name<T>(i: T) where T: Debug {\n+    foo(i);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn nested_generics() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct<T: Into<i32>>(T);\n+impl <T: Into<i32> + Copy> Struct<T> {\n+    fn func<V: Into<i32>>(&self, v: V) -> i32 {\n+        let t = self.0;\n+        $0t.into() + v.into()$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct<T: Into<i32>>(T);\n+impl <T: Into<i32> + Copy> Struct<T> {\n+    fn func<V: Into<i32>>(&self, v: V) -> i32 {\n+        let t = self.0;\n+        fun_name(t, v)\n+    }\n+}\n+\n+fn $0fun_name<T: Into<i32> + Copy, V: Into<i32>>(t: T, v: V) -> i32 {\n+    t.into() + v.into()\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn filters_unused_nested_generics() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct<T: Into<i32>, U: Debug>(T, U);\n+impl <T: Into<i32> + Copy, U: Debug> Struct<T, U> {\n+    fn func<V: Into<i32>>(&self, v: V) -> i32 {\n+        let t = self.0;\n+        $0t.into() + v.into()$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct<T: Into<i32>, U: Debug>(T, U);\n+impl <T: Into<i32> + Copy, U: Debug> Struct<T, U> {\n+    fn func<V: Into<i32>>(&self, v: V) -> i32 {\n+        let t = self.0;\n+        fun_name(t, v)\n+    }\n+}\n+\n+fn $0fun_name<T: Into<i32> + Copy, V: Into<i32>>(t: T, v: V) -> i32 {\n+    t.into() + v.into()\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn nested_where_clauses() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct<T>(T) where T: Into<i32>;\n+impl <T> Struct<T> where T: Into<i32> + Copy {\n+    fn func<V>(&self, v: V) -> i32 where V: Into<i32> {\n+        let t = self.0;\n+        $0t.into() + v.into()$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct<T>(T) where T: Into<i32>;\n+impl <T> Struct<T> where T: Into<i32> + Copy {\n+    fn func<V>(&self, v: V) -> i32 where V: Into<i32> {\n+        let t = self.0;\n+        fun_name(t, v)\n+    }\n+}\n+\n+fn $0fun_name<T, V>(t: T, v: V) -> i32 where T: Into<i32> + Copy, V: Into<i32> {\n+    t.into() + v.into()\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn filters_unused_nested_where_clauses() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct<T, U>(T, U) where T: Into<i32>, U: Debug;\n+impl <T, U> Struct<T, U> where T: Into<i32> + Copy, U: Debug {\n+    fn func<V>(&self, v: V) -> i32 where V: Into<i32> {\n+        let t = self.0;\n+        $0t.into() + v.into()$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct<T, U>(T, U) where T: Into<i32>, U: Debug;\n+impl <T, U> Struct<T, U> where T: Into<i32> + Copy, U: Debug {\n+    fn func<V>(&self, v: V) -> i32 where V: Into<i32> {\n+        let t = self.0;\n+        fun_name(t, v)\n+    }\n+}\n+\n+fn $0fun_name<T, V>(t: T, v: V) -> i32 where T: Into<i32> + Copy, V: Into<i32> {\n+    t.into() + v.into()\n+}\n \"#,\n         );\n     }"}]}