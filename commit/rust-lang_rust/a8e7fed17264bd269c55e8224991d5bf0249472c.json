{"sha": "a8e7fed17264bd269c55e8224991d5bf0249472c", "node_id": "C_kwDOAAsO6NoAKGE4ZTdmZWQxNzI2NGJkMjY5YzU1ZTgyMjQ5OTFkNWJmMDI0OTQ3MmM", "commit": {"author": {"name": "ThibsG", "email": "thibsg@pm.me", "date": "2021-11-28T08:50:34Z"}, "committer": {"name": "ThibsG", "email": "thibsg@pm.me", "date": "2021-11-28T09:22:15Z"}, "message": "Add a note about type annotation on closure param", "tree": {"sha": "5d742173d7f8f070c514cf90218a9789d941b08f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d742173d7f8f070c514cf90218a9789d941b08f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8e7fed17264bd269c55e8224991d5bf0249472c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8e7fed17264bd269c55e8224991d5bf0249472c", "html_url": "https://github.com/rust-lang/rust/commit/a8e7fed17264bd269c55e8224991d5bf0249472c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8e7fed17264bd269c55e8224991d5bf0249472c/comments", "author": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "917fdb11e45c5b2d0b43566d3736fc34ad917294", "url": "https://api.github.com/repos/rust-lang/rust/commits/917fdb11e45c5b2d0b43566d3736fc34ad917294", "html_url": "https://github.com/rust-lang/rust/commit/917fdb11e45c5b2d0b43566d3736fc34ad917294"}], "stats": {"total": 18, "additions": 10, "deletions": 8}, "files": [{"sha": "872942685f0d126cb01dfb6e492aab6b7d5a74e0", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a8e7fed17264bd269c55e8224991d5bf0249472c/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8e7fed17264bd269c55e8224991d5bf0249472c/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=a8e7fed17264bd269c55e8224991d5bf0249472c", "patch": "@@ -737,12 +737,14 @@ pub struct DerefClosure {\n /// such as explicit deref and borrowing cases.\n /// Returns `None` if no such use cases have been triggered in closure body\n ///\n-/// note: this only works on single line immutable closures with one exactly one input parameter.\n+/// note: this only works on single line immutable closures with exactly one input parameter.\n pub fn deref_closure_args<'tcx>(cx: &LateContext<'_>, closure: &'tcx hir::Expr<'_>) -> Option<DerefClosure> {\n     if let hir::ExprKind::Closure(_, fn_decl, body_id, ..) = closure.kind {\n         let closure_body = cx.tcx.hir().body(body_id);\n-        // is closure arg a double reference (i.e.: `|x: &&i32| ...`)\n-        let closure_arg_is_double_ref = if let TyKind::Rptr(_, MutTy { ty, .. }) = fn_decl.inputs[0].kind {\n+        // is closure arg a type annotated double reference (i.e.: `|x: &&i32| ...`)\n+        // a type annotation is present if param `kind` is different from `TyKind::Infer`\n+        let closure_arg_is_type_annotated_double_ref = if let TyKind::Rptr(_, MutTy { ty, .. }) = fn_decl.inputs[0].kind\n+        {\n             matches!(ty.kind, TyKind::Rptr(_, MutTy { .. }))\n         } else {\n             false\n@@ -751,7 +753,7 @@ pub fn deref_closure_args<'tcx>(cx: &LateContext<'_>, closure: &'tcx hir::Expr<'\n         let mut visitor = DerefDelegate {\n             cx,\n             closure_span: closure.span,\n-            closure_arg_is_double_ref,\n+            closure_arg_is_type_annotated_double_ref,\n             next_pos: closure.span.lo(),\n             suggestion_start: String::new(),\n             applicability: Applicability::MaybeIncorrect,\n@@ -780,8 +782,8 @@ struct DerefDelegate<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     /// The span of the input closure to adapt\n     closure_span: Span,\n-    /// Indicates if the arg of the closure is a double reference\n-    closure_arg_is_double_ref: bool,\n+    /// Indicates if the arg of the closure is a type annotated double reference\n+    closure_arg_is_type_annotated_double_ref: bool,\n     /// last position of the span to gradually build the suggestion\n     next_pos: BytePos,\n     /// starting part of the gradually built suggestion\n@@ -799,7 +801,7 @@ impl DerefDelegate<'_, 'tcx> {\n         let end_span = Span::new(self.next_pos, self.closure_span.hi(), self.closure_span.ctxt(), None);\n         let end_snip = snippet_with_applicability(self.cx, end_span, \"..\", &mut self.applicability);\n         let sugg = format!(\"{}{}\", self.suggestion_start, end_snip);\n-        if self.closure_arg_is_double_ref {\n+        if self.closure_arg_is_type_annotated_double_ref {\n             sugg.replacen('&', \"\", 1)\n         } else {\n             sugg\n@@ -889,7 +891,7 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n                                 // and if the item is already a double ref\n                                 let ident_sugg = if !call_args.is_empty()\n                                     && !takes_arg_by_double_ref\n-                                    && (self.closure_arg_is_double_ref || has_field_or_index_projection)\n+                                    && (self.closure_arg_is_type_annotated_double_ref || has_field_or_index_projection)\n                                 {\n                                     let ident = if has_field_or_index_projection {\n                                         ident_str_with_proj"}]}