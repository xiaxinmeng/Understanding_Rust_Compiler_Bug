{"sha": "b8bb2e118e9815316320f946ef3fc7e6909ed7c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YmIyZTExOGU5ODE1MzE2MzIwZjk0NmVmM2ZjN2U2OTA5ZWQ3Yzk=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-04-05T21:18:44Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-05T21:54:48Z"}, "message": "Further on the path toward self-awareness.\n\nMostly:\n\n  * Merciless refactoring of trans.rs so that trans_call can work for\n    self-calls as well as other kinds of calls\n\nAlso:\n\n  * Various changes to go with having idents, rather than exprs, in\n    expr_call_self AST nodes\n  * Added missing case for SELF token to token.to_str()", "tree": {"sha": "6b550692b0b086bde56c621f5ffd428e7dcc1b08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b550692b0b086bde56c621f5ffd428e7dcc1b08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8bb2e118e9815316320f946ef3fc7e6909ed7c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8bb2e118e9815316320f946ef3fc7e6909ed7c9", "html_url": "https://github.com/rust-lang/rust/commit/b8bb2e118e9815316320f946ef3fc7e6909ed7c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8bb2e118e9815316320f946ef3fc7e6909ed7c9/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8703c8067fb8a22ec9b296efea162aac3e7f9521", "url": "https://api.github.com/repos/rust-lang/rust/commits/8703c8067fb8a22ec9b296efea162aac3e7f9521", "html_url": "https://github.com/rust-lang/rust/commit/8703c8067fb8a22ec9b296efea162aac3e7f9521"}], "stats": {"total": 217, "additions": 99, "deletions": 118}, "files": [{"sha": "d41e6d6068684cebf72698fb21e63458f7e19c1d", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8bb2e118e9815316320f946ef3fc7e6909ed7c9/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bb2e118e9815316320f946ef3fc7e6909ed7c9/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=b8bb2e118e9815316320f946ef3fc7e6909ed7c9", "patch": "@@ -258,7 +258,7 @@ tag expr_ {\n     expr_tup(vec[elt], ann);\n     expr_rec(vec[field], option.t[@expr], ann);\n     expr_call(@expr, vec[@expr], ann);\n-    expr_call_self(@expr, vec[@expr], ann);\n+    expr_call_self(ident, vec[@expr], ann);\n     expr_bind(@expr, vec[option.t[@expr]], ann);\n     expr_spawn(spawn_dom, option.t[str], @expr, vec[@expr], ann);\n     expr_binary(binop, @expr, @expr, ann);"}, {"sha": "31e470be84b6fe8aeb1c320149279a6e59ee77fd", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8bb2e118e9815316320f946ef3fc7e6909ed7c9/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bb2e118e9815316320f946ef3fc7e6909ed7c9/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=b8bb2e118e9815316320f946ef3fc7e6909ed7c9", "patch": "@@ -887,10 +887,12 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n         }\n \n         case (token.SELF) {\n+            log \"parsing a self-call...\";\n+\n             p.bump();\n             expect(p, token.DOT);\n             // The rest is a call expression.\n-            auto e = parse_bottom_expr(p);\n+            auto e = parse_ident(p);\n             auto pf = parse_expr;\n             auto es = parse_seq[@ast.expr](token.LPAREN,\n                                            token.RPAREN,"}, {"sha": "dcfafadf202a57239472748eaab0571695810a30", "filename": "src/comp/front/token.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8bb2e118e9815316320f946ef3fc7e6909ed7c9/src%2Fcomp%2Ffront%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bb2e118e9815316320f946ef3fc7e6909ed7c9/src%2Fcomp%2Ffront%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftoken.rs?ref=b8bb2e118e9815316320f946ef3fc7e6909ed7c9", "patch": "@@ -348,6 +348,8 @@ fn to_str(token t) -> str {\n \n         /* Object type */\n         case (OBJ) { ret \"obj\"; }\n+        case (SELF) { ret \"self\"; }\n+\n \n         /* Comm and task types */\n         case (CHAN) { ret \"chan\"; }"}, {"sha": "77c898366afdec172f778119fe04923ffbf396f1", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b8bb2e118e9815316320f946ef3fc7e6909ed7c9/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bb2e118e9815316320f946ef3fc7e6909ed7c9/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=b8bb2e118e9815316320f946ef3fc7e6909ed7c9", "patch": "@@ -88,7 +88,7 @@ type ast_fold[ENV] =\n          ann a) -> @expr)                         fold_expr_call,\n \n      (fn(&ENV e, &span sp,\n-         @expr f, vec[@expr] args,\n+         ident id, vec[@expr] args,\n          ann a) -> @expr)                         fold_expr_call_self,\n \n      (fn(&ENV e, &span sp,\n@@ -566,10 +566,9 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n             ret fld.fold_expr_call(env_, e.span, ff, aargs, t);\n         }\n \n-        case (ast.expr_call_self(?f, ?args, ?t)) {\n-            auto ff = fold_expr(env_, fld, f);\n+        case (ast.expr_call_self(?ident, ?args, ?t)) {\n             auto aargs = fold_exprs(env_, fld, args);\n-            ret fld.fold_expr_call_self(env_, e.span, ff, aargs, t);\n+            ret fld.fold_expr_call_self(env_, e.span, ident, aargs, t);\n         }\n \n         case (ast.expr_bind(?f, ?args_opt, ?t)) {\n@@ -1185,9 +1184,9 @@ fn identity_fold_expr_call[ENV](&ENV env, &span sp, @expr f,\n     ret @respan(sp, ast.expr_call(f, args, a));\n }\n \n-fn identity_fold_expr_call_self[ENV](&ENV env, &span sp, @expr f,\n+fn identity_fold_expr_call_self[ENV](&ENV env, &span sp, ident id,\n                                 vec[@expr] args, ann a) -> @expr {\n-    ret @respan(sp, ast.expr_call_self(f, args, a));\n+    ret @respan(sp, ast.expr_call_self(id, args, a));\n }\n \n fn identity_fold_expr_bind[ENV](&ENV env, &span sp, @expr f,"}, {"sha": "b61aa244ad5f3685247f8d7a705bf19233afd924", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 70, "deletions": 108, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/b8bb2e118e9815316320f946ef3fc7e6909ed7c9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bb2e118e9815316320f946ef3fc7e6909ed7c9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b8bb2e118e9815316320f946ef3fc7e6909ed7c9", "patch": "@@ -12,6 +12,7 @@ import std.option.none;\n \n import front.ast;\n import front.creader;\n+import pretty.pprust;\n import driver.session;\n import middle.ty;\n import back.x86;\n@@ -114,12 +115,14 @@ state type crate_ctxt = rec(session.session sess,\n                             vec[str] path,\n                             std.sha1.sha1 sha);\n \n+type self_vt = rec(ValueRef v, @ty.t t);\n+\n state type fn_ctxt = rec(ValueRef llfn,\n                          ValueRef lltaskptr,\n                          ValueRef llenv,\n                          ValueRef llretptr,\n                          mutable BasicBlockRef llallocas,\n-                         mutable option.t[ValueRef] llself,\n+                         mutable option.t[self_vt] llself,\n                          mutable option.t[ValueRef] lliterbody,\n                          hashmap[ast.def_id, ValueRef] llargs,\n                          hashmap[ast.def_id, ValueRef] llobjfields,\n@@ -3783,12 +3786,12 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n     fail;\n }\n \n-fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n+fn trans_field(@block_ctxt cx, &ast.span sp, ValueRef v, @ty.t t0,\n                &ast.ident field, &ast.ann ann) -> lval_result {\n-    auto r = trans_expr(cx, base);\n-    auto t = ty.expr_ty(base);\n-    r = autoderef(r.bcx, r.val, t);\n-    t = autoderefed_ty(t);\n+\n+    auto r = autoderef(cx, v, t0);\n+    auto t = autoderefed_ty(t0);\n+\n     alt (t.struct) {\n         case (ty.ty_tup(_)) {\n             let uint ix = ty.field_num(cx.fcx.ccx.sess, sp, field);\n@@ -3881,11 +3884,30 @@ fn trans_lval(@block_ctxt cx, @ast.expr e) -> lval_result {\n             ret trans_path(cx, p, dopt, ann);\n         }\n         case (ast.expr_field(?base, ?ident, ?ann)) {\n-            ret trans_field(cx, e.span, base, ident, ann);\n+            auto r = trans_expr(cx, base);\n+            auto t = ty.expr_ty(base);\n+            ret trans_field(r.bcx, e.span, r.val, t, ident, ann);\n         }\n         case (ast.expr_index(?base, ?idx, ?ann)) {\n             ret trans_index(cx, e.span, base, idx, ann);\n         }\n+\n+        // Kind of bizarre to pass an *entire* self-call here...but let's try\n+        // it\n+        case (ast.expr_call_self(?ident, _, ?ann)) {\n+            alt (cx.fcx.llself) {\n+                case (some[self_vt](?s_vt)) {\n+                    auto r =  s_vt.v;\n+                    auto t =  s_vt.t;\n+                    ret trans_field(cx, e.span, r, t, ident, ann);\n+                }\n+                case (_) {\n+                    // Shouldn't happen.\n+                    fail;\n+                }\n+\n+            }\n+        }\n         case (_) { cx.fcx.ccx.sess.unimpl(\"expr variant in trans_lval\"); }\n     }\n     fail;\n@@ -4462,70 +4484,6 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n     ret res(bcx, retval);\n }\n \n-fn trans_call_self(@block_ctxt cx, @ast.expr f,\n-                   option.t[ValueRef] lliterbody,\n-                   vec[@ast.expr] args,\n-                   &ast.ann ann) -> result {\n-    log \"translating a self-call\";\n-\n-    auto f_res = trans_lval(cx, f);\n-    auto faddr = f_res.res.val;\n-    auto llenv = C_null(T_opaque_closure_ptr(cx.fcx.ccx.tn));\n-\n-    alt (f_res.llobj) {\n-        case (some[ValueRef](_)) {\n-            // It's a vtbl entry.\n-            faddr = f_res.res.bcx.build.Load(faddr);\n-        }\n-        case (none[ValueRef]) {\n-            // It's a closure.\n-            auto bcx = f_res.res.bcx;\n-            auto pair = faddr;\n-            faddr = bcx.build.GEP(pair, vec(C_int(0),\n-                                            C_int(abi.fn_field_code)));\n-            faddr = bcx.build.Load(faddr);\n-\n-            auto llclosure = bcx.build.GEP(pair,\n-                                           vec(C_int(0),\n-                                               C_int(abi.fn_field_box)));\n-            llenv = bcx.build.Load(llclosure);\n-        }\n-    }\n-    auto fn_ty = ty.expr_ty(f);\n-    auto ret_ty = ty.ann_to_type(ann);\n-    auto args_res = trans_args(f_res.res.bcx,\n-                               llenv, f_res.llobj,\n-                               f_res.generic,\n-                               lliterbody,\n-                               args, fn_ty);\n-\n-    auto bcx = args_res._0;\n-    auto llargs = args_res._1;\n-    auto llretslot = args_res._2;\n-\n-    /*\n-    log \"calling: \" + val_str(cx.fcx.ccx.tn, faddr);\n-\n-    for (ValueRef arg in llargs) {\n-        log \"arg: \" + val_str(cx.fcx.ccx.tn, arg);\n-    }\n-    */\n-\n-    bcx.build.FastCall(faddr, llargs);\n-    auto retval = C_nil();\n-\n-    if (!ty.type_is_nil(ret_ty)) {\n-        retval = load_scalar_or_boxed(bcx, llretslot, ret_ty);\n-        // Retval doesn't correspond to anything really tangible in the frame,\n-        // but it's a ref all the same, so we put a note here to drop it when\n-        // we're done in this scope.\n-        find_scope_cx(cx).cleanups +=\n-            vec(clean(bind drop_ty(_, retval, ret_ty)));\n-    }\n-\n-    ret res(bcx, retval);\n-}\n-\n fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n              &ast.ann ann) -> result {\n     auto bcx = cx;\n@@ -4762,8 +4720,9 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             ret trans_call(cx, f, none[ValueRef], args, ann);\n         }\n \n-        case (ast.expr_call_self(?f, ?args, ?ann)) {\n-            ret trans_call_self(cx, f, none[ValueRef], args, ann);\n+        case (ast.expr_call_self(?ident, ?args, ?ann)) {\n+            // A weird hack to make self-calls work.\n+            ret trans_call(cx, e, none[ValueRef], args, ann);\n         }\n \n         case (ast.expr_cast(?e, _, ?ann)) {\n@@ -5473,7 +5432,7 @@ fn new_fn_ctxt(@crate_ctxt cx,\n              llenv=llenv,\n              llretptr=llretptr,\n              mutable llallocas = llallocas,\n-             mutable llself=none[ValueRef],\n+             mutable llself=none[self_vt],\n              mutable lliterbody=none[ValueRef],\n              llargs=llargs,\n              llobjfields=llobjfields,\n@@ -5492,27 +5451,24 @@ fn new_fn_ctxt(@crate_ctxt cx,\n \n fn create_llargs_for_fn_args(&@fn_ctxt cx,\n                              ast.proto proto,\n-                             option.t[TypeRef] ty_self,\n+                             option.t[tup(TypeRef, @ty.t)] ty_self,\n                              @ty.t ret_ty,\n                              &vec[ast.arg] args,\n                              &vec[ast.ty_param] ty_params) {\n \n-    alt (ty_self) {\n-        case (some[TypeRef](_)) {\n-            cx.llself = some[ValueRef](cx.llenv);\n-        }\n-        case (_) {\n-        }\n-    }\n-\n     auto arg_n = 3u;\n \n-    if (ty_self == none[TypeRef]) {\n-        for (ast.ty_param tp in ty_params) {\n-            auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n-            check (llarg as int != 0);\n-            cx.lltydescs.insert(tp.id, llarg);\n-            arg_n += 1u;\n+    alt (ty_self) {\n+        case (some[tup(TypeRef, @ty.t)](?tt)) {\n+            cx.llself = some[self_vt](rec(v = cx.llenv, t = tt._1));\n+        }\n+        case (none[tup(TypeRef, @ty.t)]) {\n+            for (ast.ty_param tp in ty_params) {\n+                auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n+                check (llarg as int != 0);\n+                cx.lltydescs.insert(tp.id, llarg);\n+                arg_n += 1u;\n+            }\n         }\n     }\n \n@@ -5536,17 +5492,17 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n // were passed and whatnot. Apparently mem2reg will mop up.\n \n fn copy_any_self_to_alloca(@fn_ctxt fcx,\n-                           option.t[TypeRef] ty_self) {\n+                           option.t[tup(TypeRef, @ty.t)] ty_self) {\n \n     auto bcx = llallocas_block_ctxt(fcx);\n \n     alt (fcx.llself) {\n-        case (some[ValueRef](?self_v)) {\n+        case (some[self_vt](?s_vt)) {\n             alt (ty_self) {\n-                case (some[TypeRef](?self_t)) {\n-                    auto a = alloca(bcx, self_t);\n-                    bcx.build.Store(self_v, a);\n-                    fcx.llself = some[ValueRef](a);\n+                case (some[tup(TypeRef, @ty.t)](?tt)) {\n+                    auto a = alloca(bcx, tt._0);\n+                    bcx.build.Store(s_vt.v, a);\n+                    fcx.llself = some[self_vt](rec(v = a, t = s_vt.t));\n                 }\n             }\n         }\n@@ -5608,7 +5564,7 @@ fn ret_ty_of_fn(ast.ann ann) -> @ty.t {\n     ret ret_ty_of_fn_ty(ty.ann_to_type(ann));\n }\n \n-fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, ValueRef llself) {\n+fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n     auto bcx = llallocas_block_ctxt(fcx);\n \n     let vec[@ty.t] field_tys = vec();\n@@ -5625,7 +5581,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, ValueRef llself) {\n     let TypeRef llobj_box_ty = T_obj_ptr(bcx.fcx.ccx.tn, n_typarams);\n \n     auto box_cell =\n-        bcx.build.GEP(llself,\n+        bcx.build.GEP(llself.v,\n                       vec(C_int(0),\n                           C_int(abi.obj_field_box)));\n \n@@ -5678,7 +5634,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, ValueRef llself) {\n }\n \n fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n-            option.t[TypeRef] ty_self,\n+            option.t[tup(TypeRef, @ty.t)] ty_self,\n             &vec[ast.ty_param] ty_params, &ast.ann ann) {\n \n     auto llfndecl = cx.item_ids.get(fid);\n@@ -5691,7 +5647,7 @@ fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n     copy_any_self_to_alloca(fcx, ty_self);\n \n     alt (fcx.llself) {\n-        case (some[ValueRef](?llself)) {\n+        case (some[self_vt](?llself)) {\n             populate_fn_ctxt_from_llself(fcx, llself);\n         }\n         case (_) {\n@@ -5714,7 +5670,9 @@ fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n     new_builder(fcx.llallocas).Br(lltop);\n }\n \n-fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n+fn trans_vtbl(@crate_ctxt cx, \n+              TypeRef llself_ty,\n+              @ty.t self_ty,\n               &ast._obj ob,\n               &vec[ast.ty_param] ty_params) -> ValueRef {\n     let vec[ValueRef] methods = vec();\n@@ -5732,7 +5690,7 @@ fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n         alt (node_ann_type(cx, m.node.ann).struct) {\n             case (ty.ty_fn(?proto, ?inputs, ?output)) {\n                 llfnty = type_of_fn_full(cx, proto,\n-                                         some[TypeRef](self_ty),\n+                                         some[TypeRef](llself_ty),\n                                          inputs, output,\n                                          _vec.len[ast.ty_param](ty_params));\n             }\n@@ -5744,7 +5702,8 @@ fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n         cx.item_ids.insert(m.node.id, llfn);\n         cx.item_symbols.insert(m.node.id, s);\n \n-        trans_fn(mcx, m.node.meth, m.node.id, some[TypeRef](self_ty),\n+        trans_fn(mcx, m.node.meth, m.node.id, \n+                 some[tup(TypeRef, @ty.t)](tup(llself_ty, self_ty)),\n                  ty_params, m.node.ann);\n         methods += vec(llfn);\n     }\n@@ -5775,7 +5734,8 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n \n     auto fcx = new_fn_ctxt(cx, llctor_decl);\n     create_llargs_for_fn_args(fcx, ast.proto_fn,\n-                              none[TypeRef], ret_ty_of_fn(ann),\n+                              none[tup(TypeRef, @ty.t)], \n+                              ret_ty_of_fn(ann),\n                               fn_args, ty_params);\n \n     let vec[ty.arg] arg_tys = arg_tys_of_fn(ann);\n@@ -5784,9 +5744,10 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n-    auto llself_ty = type_of(cx, ret_ty_of_fn(ann));\n+    auto self_ty = ret_ty_of_fn(ann);\n+    auto llself_ty = type_of(cx, self_ty);\n     auto pair = bcx.fcx.llretptr;\n-    auto vtbl = trans_vtbl(cx, llself_ty, ob, ty_params);\n+    auto vtbl = trans_vtbl(cx, llself_ty, self_ty, ob, ty_params);\n     auto pair_vtbl = bcx.build.GEP(pair,\n                                    vec(C_int(0),\n                                        C_int(abi.obj_field_vtbl)));\n@@ -5907,7 +5868,8 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n     auto fcx = new_fn_ctxt(cx, llfndecl);\n \n     create_llargs_for_fn_args(fcx, ast.proto_fn,\n-                              none[TypeRef], ret_ty_of_fn(variant.node.ann),\n+                              none[tup(TypeRef, @ty.t)], \n+                              ret_ty_of_fn(variant.node.ann),\n                               fn_args, ty_params);\n \n     let vec[@ty.t] ty_param_substs = vec();\n@@ -5995,7 +5957,7 @@ fn trans_item(@crate_ctxt cx, &ast.item item) {\n     alt (item.node) {\n         case (ast.item_fn(?name, ?f, ?tps, ?fid, ?ann)) {\n             auto sub_cx = extend_path(cx, name);\n-            trans_fn(sub_cx, f, fid, none[TypeRef], tps, ann);\n+            trans_fn(sub_cx, f, fid, none[tup(TypeRef, @ty.t)], tps, ann);\n         }\n         case (ast.item_obj(?name, ?ob, ?tps, ?oid, ?ann)) {\n             auto sub_cx = @rec(obj_typarams=tps,\n@@ -6803,7 +6765,7 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n                     llenv=C_null(T_ptr(T_nil())),\n                     llretptr=C_null(T_ptr(T_nil())),\n                     mutable llallocas = llallocas,\n-                    mutable llself=none[ValueRef],\n+                    mutable llself=none[self_vt],\n                     mutable lliterbody=none[ValueRef],\n                     llargs=new_def_hash[ValueRef](),\n                     llobjfields=new_def_hash[ValueRef](),"}, {"sha": "e105c7a910697a1151332cb71974d0a6b9349c2a", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b8bb2e118e9815316320f946ef3fc7e6909ed7c9/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bb2e118e9815316320f946ef3fc7e6909ed7c9/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=b8bb2e118e9815316320f946ef3fc7e6909ed7c9", "patch": "@@ -2110,6 +2110,18 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                         ast.expr_call(f_1, args_1, ann));\n         }\n \n+        case (ast.expr_call_self(?ident, ?args, _)) {\n+            // FIXME: What's to check here?\n+\n+            // FIXME: These two lines are ripped off from the expr_call case;\n+            // what should they be really?\n+            auto rt_1 = plain_ty(ty.ty_nil);\n+            auto ann = triv_ann(rt_1);\n+\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_call_self(ident, args, ann));\n+        }\n+\n         case (ast.expr_spawn(?dom, ?name, ?f, ?args, _)) {\n             auto result = check_call(fcx, f, args);\n             auto f_1 = result._0;"}, {"sha": "7e0fb6cb7c94d664b4c3be83a536d4f8e83d3308", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8bb2e118e9815316320f946ef3fc7e6909ed7c9/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8bb2e118e9815316320f946ef3fc7e6909ed7c9/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=b8bb2e118e9815316320f946ef3fc7e6909ed7c9", "patch": "@@ -454,9 +454,9 @@ impure fn print_expr(ps s, &@ast.expr expr) {\n             commasep_exprs(s, args);\n             pclose(s);\n         }\n-        case (ast.expr_call_self(?func,?args,_)) {\n+        case (ast.expr_call_self(?ident,?args,_)) {\n             wrd(s.s, \"self.\");\n-            print_expr(s, func);\n+            print_ident(s, ident);\n             popen(s);\n             commasep_exprs(s, args);\n             pclose(s);\n@@ -723,6 +723,10 @@ impure fn print_decl(ps s, @ast.decl decl) {\n     end(s.s);\n }\n \n+impure fn print_ident(ps s, ast.ident ident) {\n+    wrd(s.s, ident);\n+}\n+\n impure fn print_for_decl(ps s, @ast.decl decl) {\n     alt (decl.node) {\n         case (ast.decl_local(?loc)) {"}]}