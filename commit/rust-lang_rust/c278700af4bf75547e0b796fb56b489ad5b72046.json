{"sha": "c278700af4bf75547e0b796fb56b489ad5b72046", "node_id": "C_kwDOAAsO6NoAKGMyNzg3MDBhZjRiZjc1NTQ3ZTBiNzk2ZmI1NmI0ODlhZDViNzIwNDY", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2022-10-12T15:57:05Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2022-10-12T21:09:23Z"}, "message": "tidy: error if a lang feature is already present\n\nIf a lang feature gets declared twice, like for example as\na result of a mistake during stabilization, emit an error\nin tidy. Library features already have this logic.", "tree": {"sha": "15fc0eb7b515107e2cd90ca93e4aa95c40fc44bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15fc0eb7b515107e2cd90ca93e4aa95c40fc44bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c278700af4bf75547e0b796fb56b489ad5b72046", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c278700af4bf75547e0b796fb56b489ad5b72046", "html_url": "https://github.com/rust-lang/rust/commit/c278700af4bf75547e0b796fb56b489ad5b72046", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c278700af4bf75547e0b796fb56b489ad5b72046/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0983a9aac889d16722a12602ac678051e62c3fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0983a9aac889d16722a12602ac678051e62c3fb", "html_url": "https://github.com/rust-lang/rust/commit/c0983a9aac889d16722a12602ac678051e62c3fb"}], "stats": {"total": 263, "additions": 137, "deletions": 126}, "files": [{"sha": "f10ecf5f201e32e83b4c72e1583057a18922d7d5", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 137, "deletions": 126, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/c278700af4bf75547e0b796fb56b489ad5b72046/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c278700af4bf75547e0b796fb56b489ad5b72046/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=c278700af4bf75547e0b796fb56b489ad5b72046", "patch": "@@ -10,7 +10,7 @@\n //! * Language features in a group are sorted by feature name.\n \n use crate::walk::{filter_dirs, walk, walk_many};\n-use std::collections::HashMap;\n+use std::collections::hash_map::{Entry, HashMap};\n use std::fmt;\n use std::fs;\n use std::num::NonZeroU32;\n@@ -280,13 +280,14 @@ fn test_filen_gate(filen_underscore: &str, features: &mut Features) -> bool {\n }\n \n pub fn collect_lang_features(base_compiler_path: &Path, bad: &mut bool) -> Features {\n-    let mut all = collect_lang_features_in(base_compiler_path, \"active.rs\", bad);\n-    all.extend(collect_lang_features_in(base_compiler_path, \"accepted.rs\", bad));\n-    all.extend(collect_lang_features_in(base_compiler_path, \"removed.rs\", bad));\n-    all\n+    let mut features = Features::new();\n+    collect_lang_features_in(&mut features, base_compiler_path, \"active.rs\", bad);\n+    collect_lang_features_in(&mut features, base_compiler_path, \"accepted.rs\", bad);\n+    collect_lang_features_in(&mut features, base_compiler_path, \"removed.rs\", bad);\n+    features\n }\n \n-fn collect_lang_features_in(base: &Path, file: &str, bad: &mut bool) -> Features {\n+fn collect_lang_features_in(features: &mut Features, base: &Path, file: &str, bad: &mut bool) {\n     let path = base.join(\"rustc_feature\").join(\"src\").join(file);\n     let contents = t!(fs::read_to_string(&path));\n \n@@ -298,135 +299,145 @@ fn collect_lang_features_in(base: &Path, file: &str, bad: &mut bool) -> Features\n     let mut in_feature_group = false;\n     let mut prev_names = vec![];\n \n-    contents\n-        .lines()\n-        .zip(1..)\n-        .filter_map(|(line, line_number)| {\n-            let line = line.trim();\n-\n-            // Within -start and -end, the tracking issue can be omitted.\n-            match line {\n-                \"// no-tracking-issue-start\" => {\n-                    next_feature_omits_tracking_issue = true;\n-                    return None;\n-                }\n-                \"// no-tracking-issue-end\" => {\n-                    next_feature_omits_tracking_issue = false;\n-                    return None;\n-                }\n-                _ => {}\n+    let lines = contents.lines().zip(1..);\n+    for (line, line_number) in lines {\n+        let line = line.trim();\n+\n+        // Within -start and -end, the tracking issue can be omitted.\n+        match line {\n+            \"// no-tracking-issue-start\" => {\n+                next_feature_omits_tracking_issue = true;\n+                continue;\n             }\n+            \"// no-tracking-issue-end\" => {\n+                next_feature_omits_tracking_issue = false;\n+                continue;\n+            }\n+            _ => {}\n+        }\n \n-            if line.starts_with(FEATURE_GROUP_START_PREFIX) {\n-                if in_feature_group {\n-                    tidy_error!(\n-                        bad,\n-                        \"{}:{}: \\\n+        if line.starts_with(FEATURE_GROUP_START_PREFIX) {\n+            if in_feature_group {\n+                tidy_error!(\n+                    bad,\n+                    \"{}:{}: \\\n                         new feature group is started without ending the previous one\",\n-                        path.display(),\n-                        line_number,\n-                    );\n-                }\n-\n-                in_feature_group = true;\n-                prev_names = vec![];\n-                return None;\n-            } else if line.starts_with(FEATURE_GROUP_END_PREFIX) {\n-                in_feature_group = false;\n-                prev_names = vec![];\n-                return None;\n+                    path.display(),\n+                    line_number,\n+                );\n             }\n \n-            let mut parts = line.split(',');\n-            let level = match parts.next().map(|l| l.trim().trim_start_matches('(')) {\n-                Some(\"active\") => Status::Unstable,\n-                Some(\"incomplete\") => Status::Unstable,\n-                Some(\"removed\") => Status::Removed,\n-                Some(\"accepted\") => Status::Stable,\n-                _ => return None,\n-            };\n-            let name = parts.next().unwrap().trim();\n-\n-            let since_str = parts.next().unwrap().trim().trim_matches('\"');\n-            let since = match since_str.parse() {\n-                Ok(since) => Some(since),\n-                Err(err) => {\n-                    tidy_error!(\n-                        bad,\n-                        \"{}:{}: failed to parse since: {} ({:?})\",\n-                        path.display(),\n-                        line_number,\n-                        since_str,\n-                        err,\n-                    );\n-                    None\n-                }\n-            };\n-            if in_feature_group {\n-                if prev_names.last() > Some(&name) {\n-                    // This assumes the user adds the feature name at the end of the list, as we're\n-                    // not looking ahead.\n-                    let correct_index = match prev_names.binary_search(&name) {\n-                        Ok(_) => {\n-                            // This only occurs when the feature name has already been declared.\n-                            tidy_error!(\n-                                bad,\n-                                \"{}:{}: duplicate feature {}\",\n-                                path.display(),\n-                                line_number,\n-                                name,\n-                            );\n-                            // skip any additional checks for this line\n-                            return None;\n-                        }\n-                        Err(index) => index,\n-                    };\n+            in_feature_group = true;\n+            prev_names = vec![];\n+            continue;\n+        } else if line.starts_with(FEATURE_GROUP_END_PREFIX) {\n+            in_feature_group = false;\n+            prev_names = vec![];\n+            continue;\n+        }\n \n-                    let correct_placement = if correct_index == 0 {\n-                        \"at the beginning of the feature group\".to_owned()\n-                    } else if correct_index == prev_names.len() {\n-                        // I don't believe this is reachable given the above assumption, but it\n-                        // doesn't hurt to be safe.\n-                        \"at the end of the feature group\".to_owned()\n-                    } else {\n-                        format!(\n-                            \"between {} and {}\",\n-                            prev_names[correct_index - 1],\n-                            prev_names[correct_index],\n-                        )\n-                    };\n+        let mut parts = line.split(',');\n+        let level = match parts.next().map(|l| l.trim().trim_start_matches('(')) {\n+            Some(\"active\") => Status::Unstable,\n+            Some(\"incomplete\") => Status::Unstable,\n+            Some(\"removed\") => Status::Removed,\n+            Some(\"accepted\") => Status::Stable,\n+            _ => continue,\n+        };\n+        let name = parts.next().unwrap().trim();\n+\n+        let since_str = parts.next().unwrap().trim().trim_matches('\"');\n+        let since = match since_str.parse() {\n+            Ok(since) => Some(since),\n+            Err(err) => {\n+                tidy_error!(\n+                    bad,\n+                    \"{}:{}: failed to parse since: {} ({:?})\",\n+                    path.display(),\n+                    line_number,\n+                    since_str,\n+                    err,\n+                );\n+                None\n+            }\n+        };\n+        if in_feature_group {\n+            if prev_names.last() > Some(&name) {\n+                // This assumes the user adds the feature name at the end of the list, as we're\n+                // not looking ahead.\n+                let correct_index = match prev_names.binary_search(&name) {\n+                    Ok(_) => {\n+                        // This only occurs when the feature name has already been declared.\n+                        tidy_error!(\n+                            bad,\n+                            \"{}:{}: duplicate feature {}\",\n+                            path.display(),\n+                            line_number,\n+                            name,\n+                        );\n+                        // skip any additional checks for this line\n+                        continue;\n+                    }\n+                    Err(index) => index,\n+                };\n \n-                    tidy_error!(\n-                        bad,\n-                        \"{}:{}: feature {} is not sorted by feature name (should be {})\",\n-                        path.display(),\n-                        line_number,\n-                        name,\n-                        correct_placement,\n-                    );\n-                }\n-                prev_names.push(name);\n+                let correct_placement = if correct_index == 0 {\n+                    \"at the beginning of the feature group\".to_owned()\n+                } else if correct_index == prev_names.len() {\n+                    // I don't believe this is reachable given the above assumption, but it\n+                    // doesn't hurt to be safe.\n+                    \"at the end of the feature group\".to_owned()\n+                } else {\n+                    format!(\n+                        \"between {} and {}\",\n+                        prev_names[correct_index - 1],\n+                        prev_names[correct_index],\n+                    )\n+                };\n+\n+                tidy_error!(\n+                    bad,\n+                    \"{}:{}: feature {} is not sorted by feature name (should be {})\",\n+                    path.display(),\n+                    line_number,\n+                    name,\n+                    correct_placement,\n+                );\n             }\n+            prev_names.push(name);\n+        }\n \n-            let issue_str = parts.next().unwrap().trim();\n-            let tracking_issue = if issue_str.starts_with(\"None\") {\n-                if level == Status::Unstable && !next_feature_omits_tracking_issue {\n-                    tidy_error!(\n-                        bad,\n-                        \"{}:{}: no tracking issue for feature {}\",\n-                        path.display(),\n-                        line_number,\n-                        name,\n-                    );\n-                }\n-                None\n-            } else {\n-                let s = issue_str.split('(').nth(1).unwrap().split(')').next().unwrap();\n-                Some(s.parse().unwrap())\n-            };\n-            Some((name.to_owned(), Feature { level, since, has_gate_test: false, tracking_issue }))\n-        })\n-        .collect()\n+        let issue_str = parts.next().unwrap().trim();\n+        let tracking_issue = if issue_str.starts_with(\"None\") {\n+            if level == Status::Unstable && !next_feature_omits_tracking_issue {\n+                tidy_error!(\n+                    bad,\n+                    \"{}:{}: no tracking issue for feature {}\",\n+                    path.display(),\n+                    line_number,\n+                    name,\n+                );\n+            }\n+            None\n+        } else {\n+            let s = issue_str.split('(').nth(1).unwrap().split(')').next().unwrap();\n+            Some(s.parse().unwrap())\n+        };\n+        match features.entry(name.to_owned()) {\n+            Entry::Occupied(e) => {\n+                tidy_error!(\n+                    bad,\n+                    \"{}:{} feature {name} already specified with status '{}'\",\n+                    path.display(),\n+                    line_number,\n+                    e.get().level,\n+                );\n+            }\n+            Entry::Vacant(e) => {\n+                e.insert(Feature { level, since, has_gate_test: false, tracking_issue });\n+            }\n+        }\n+    }\n }\n \n fn get_and_check_lib_features("}]}