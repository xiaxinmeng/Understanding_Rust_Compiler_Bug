{"sha": "80a2867ea736007397aa2fbaa0e4c539c80e162c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYTI4NjdlYTczNjAwNzM5N2FhMmZiYWEwZTRjNTM5YzgwZTE2MmM=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-12T22:55:51Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-17T19:26:47Z"}, "message": "libstd: Deprecate _equiv methods\n\nThis commit deprecates the `_equiv` family of methods on `HashMap` and\n`HashSet` by instead generalizing the \"normal\" methods like `get` and\n`remove` to use the new `std::borrow` infrastructure.\n\n[breaking-change]", "tree": {"sha": "d65213d4904627724c933c67c00a2ac4699e0c81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d65213d4904627724c933c67c00a2ac4699e0c81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80a2867ea736007397aa2fbaa0e4c539c80e162c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80a2867ea736007397aa2fbaa0e4c539c80e162c", "html_url": "https://github.com/rust-lang/rust/commit/80a2867ea736007397aa2fbaa0e4c539c80e162c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80a2867ea736007397aa2fbaa0e4c539c80e162c/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5eec666c8c4be3706a79755e6cb1119990390c79", "url": "https://api.github.com/repos/rust-lang/rust/commits/5eec666c8c4be3706a79755e6cb1119990390c79", "html_url": "https://github.com/rust-lang/rust/commit/5eec666c8c4be3706a79755e6cb1119990390c79"}], "stats": {"total": 207, "additions": 84, "deletions": 123}, "files": [{"sha": "2eee6976339cea7d2e296851f6024a645d7f5f30", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 62, "deletions": 80, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/80a2867ea736007397aa2fbaa0e4c539c80e162c/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a2867ea736007397aa2fbaa0e4c539c80e162c/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=80a2867ea736007397aa2fbaa0e4c539c80e162c", "patch": "@@ -14,6 +14,7 @@ pub use self::Entry::*;\n use self::SearchResult::*;\n use self::VacantEntryState::*;\n \n+use borrow::BorrowFrom;\n use clone::Clone;\n use cmp::{max, Eq, Equiv, PartialEq};\n use default::Default;\n@@ -142,7 +143,7 @@ impl DefaultResizePolicy {\n // about the size of rust executables.\n //\n // Annotate exceedingly likely branches in `table::make_hash`\n-// and `search_hashed_generic` to reduce instruction cache pressure\n+// and `search_hashed` to reduce instruction cache pressure\n // and mispredictions once it becomes possible (blocked on issue #11092).\n //\n // Shrinking the table could simply reallocate in place after moving buckets\n@@ -286,10 +287,10 @@ pub struct HashMap<K, V, H = RandomSipHasher> {\n }\n \n /// Search for a pre-hashed key.\n-fn search_hashed_generic<K, V, M: Deref<RawTable<K, V>>>(table: M,\n-                                                         hash: &SafeHash,\n-                                                         is_match: |&K| -> bool)\n-                                                         -> SearchResult<K, V, M> {\n+fn search_hashed<K, V, M: Deref<RawTable<K, V>>>(table: M,\n+                                                 hash: &SafeHash,\n+                                                 is_match: |&K| -> bool)\n+                                                 -> SearchResult<K, V, M> {\n     let size = table.size();\n     let mut probe = Bucket::new(table, hash);\n     let ib = probe.index();\n@@ -325,11 +326,6 @@ fn search_hashed_generic<K, V, M: Deref<RawTable<K, V>>>(table: M,\n     TableRef(probe.into_table())\n }\n \n-fn search_hashed<K: Eq, V, M: Deref<RawTable<K, V>>>(table: M, hash: &SafeHash, k: &K)\n-                                                     -> SearchResult<K, V, M> {\n-    search_hashed_generic(table, hash, |k_| *k == *k_)\n-}\n-\n fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n     let (empty, retkey, retval) = starting_bucket.take();\n     let mut gap = match empty.gap_peek() {\n@@ -432,26 +428,32 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     fn search_equiv<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a self, q: &Q)\n                     -> Option<FullBucketImm<'a, K, V>> {\n         let hash = self.make_hash(q);\n-        search_hashed_generic(&self.table, &hash, |k| q.equiv(k)).into_option()\n+        search_hashed(&self.table, &hash, |k| q.equiv(k)).into_option()\n     }\n \n     fn search_equiv_mut<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a mut self, q: &Q)\n                     -> Option<FullBucketMut<'a, K, V>> {\n         let hash = self.make_hash(q);\n-        search_hashed_generic(&mut self.table, &hash, |k| q.equiv(k)).into_option()\n+        search_hashed(&mut self.table, &hash, |k| q.equiv(k)).into_option()\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n     /// If you already have the hash for the key lying around, use\n     /// search_hashed.\n-    fn search<'a>(&'a self, k: &K) -> Option<FullBucketImm<'a, K, V>> {\n-        let hash = self.make_hash(k);\n-        search_hashed(&self.table, &hash, k).into_option()\n+    fn search<'a, Sized? Q>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n+        where Q: BorrowFrom<K> + Eq + Hash<S>\n+    {\n+        let hash = self.make_hash(q);\n+        search_hashed(&self.table, &hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+            .into_option()\n     }\n \n-    fn search_mut<'a>(&'a mut self, k: &K) -> Option<FullBucketMut<'a, K, V>> {\n-        let hash = self.make_hash(k);\n-        search_hashed(&mut self.table, &hash, k).into_option()\n+    fn search_mut<'a, Sized? Q>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n+        where Q: BorrowFrom<K> + Eq + Hash<S>\n+    {\n+        let hash = self.make_hash(q);\n+        search_hashed(&mut self.table, &hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+            .into_option()\n     }\n \n     // The caller should ensure that invariants by Robin Hood Hashing hold.\n@@ -748,18 +750,14 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Return true if the map contains a value for the specified key,\n-    /// using equivalence.\n-    ///\n-    /// See [pop_equiv](#method.pop_equiv) for an extended example.\n+    /// Deprecated: use `contains_key` and `BorrowFrom` instead.\n+    #[deprecated = \"use contains_key and BorrowFrom instead\"]\n     pub fn contains_key_equiv<Sized? Q: Hash<S> + Equiv<K>>(&self, key: &Q) -> bool {\n         self.search_equiv(key).is_some()\n     }\n \n-    /// Return the value corresponding to the key in the map, using\n-    /// equivalence.\n-    ///\n-    /// See [pop_equiv](#method.pop_equiv) for an extended example.\n+    /// Deprecated: use `get` and `BorrowFrom` instead.\n+    #[deprecated = \"use get and BorrowFrom instead\"]\n     pub fn find_equiv<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n         match self.search_equiv(k) {\n             None      => None,\n@@ -770,52 +768,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Remove an equivalent key from the map, returning the value at the\n-    /// key if the key was previously in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// This is a slightly silly example where we define the number's\n-    /// parity as the equivalence class. It is important that the\n-    /// values hash the same, which is why we implement `Hash`.\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::hash::Hash;\n-    /// use std::hash::sip::SipState;\n-    ///\n-    /// #[deriving(Eq, PartialEq)]\n-    /// struct EvenOrOdd {\n-    ///     num: uint\n-    /// };\n-    ///\n-    /// impl Hash for EvenOrOdd {\n-    ///     fn hash(&self, state: &mut SipState) {\n-    ///         let parity = self.num % 2;\n-    ///         parity.hash(state);\n-    ///     }\n-    /// }\n-    ///\n-    /// impl Equiv<EvenOrOdd> for EvenOrOdd {\n-    ///     fn equiv(&self, other: &EvenOrOdd) -> bool {\n-    ///         self.num % 2 == other.num % 2\n-    ///     }\n-    /// }\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(EvenOrOdd { num: 3 }, \"foo\");\n-    ///\n-    /// assert!(map.contains_key_equiv(&EvenOrOdd { num: 1 }));\n-    /// assert!(!map.contains_key_equiv(&EvenOrOdd { num: 4 }));\n-    ///\n-    /// assert_eq!(map.find_equiv(&EvenOrOdd { num: 5 }), Some(&\"foo\"));\n-    /// assert_eq!(map.find_equiv(&EvenOrOdd { num: 2 }), None);\n-    ///\n-    /// assert_eq!(map.pop_equiv(&EvenOrOdd { num: 1 }), Some(\"foo\"));\n-    /// assert_eq!(map.pop_equiv(&EvenOrOdd { num: 2 }), None);\n-    ///\n-    /// ```\n-    #[experimental]\n+    /// Deprecated: use `remove` and `BorrowFrom` instead.\n+    #[deprecated = \"use remove and BorrowFrom instead\"]\n     pub fn pop_equiv<Sized? Q:Hash<S> + Equiv<K>>(&mut self, k: &Q) -> Option<V> {\n         if self.table.size() == 0 {\n             return None\n@@ -1036,6 +990,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n     /// Returns a reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -1047,7 +1005,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get(&self, k: &K) -> Option<&V> {\n+    pub fn get<Sized? Q>(&self, k: &Q) -> Option<&V>\n+        where Q: Hash<S> + Eq + BorrowFrom<K>\n+    {\n         self.search(k).map(|bucket| {\n             let (_, v) = bucket.into_refs();\n             v\n@@ -1056,6 +1016,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n     /// Returns true if the map contains a value for the specified key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -1067,7 +1031,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains_key(&self, k: &K) -> bool {\n+    pub fn contains_key<Sized? Q>(&self, k: &Q) -> bool\n+        where Q: Hash<S> + Eq + BorrowFrom<K>\n+    {\n         self.search(k).is_some()\n     }\n \n@@ -1079,6 +1045,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n \n     /// Returns a mutable reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -1093,7 +1063,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get_mut(&mut self, k: &K) -> Option<&mut V> {\n+    pub fn get_mut<Sized? Q>(&mut self, k: &Q) -> Option<&mut V>\n+        where Q: Hash<S> + Eq + BorrowFrom<K>\n+    {\n         match self.search_mut(k) {\n             Some(bucket) => {\n                 let (_, v) = bucket.into_mut_refs();\n@@ -1147,6 +1119,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -1158,7 +1134,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, k: &K) -> Option<V> {\n+    pub fn remove<Sized? Q>(&mut self, k: &Q) -> Option<V>\n+        where Q: Hash<S> + Eq + BorrowFrom<K>\n+    {\n         if self.table.size() == 0 {\n             return None\n         }\n@@ -1271,16 +1249,20 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H>\n     }\n }\n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Index<K, V> for HashMap<K, V, H> {\n+impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> Index<Q, V> for HashMap<K, V, H>\n+    where Q: BorrowFrom<K> + Hash<S> + Eq\n+{\n     #[inline]\n-    fn index<'a>(&'a self, index: &K) -> &'a V {\n+    fn index<'a>(&'a self, index: &Q) -> &'a V {\n         self.get(index).expect(\"no entry found for key\")\n     }\n }\n \n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> IndexMut<K, V> for HashMap<K, V, H> {\n+impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> IndexMut<Q, V> for HashMap<K, V, H>\n+    where Q: BorrowFrom<K> + Hash<S> + Eq\n+{\n     #[inline]\n-    fn index_mut<'a>(&'a mut self, index: &K) -> &'a mut V {\n+    fn index_mut<'a>(&'a mut self, index: &Q) -> &'a mut V {\n         match self.get_mut(index) {\n             Some(v) => v,\n             None => panic!(\"no entry found for key\")"}, {"sha": "2fbcb464358b3c76170609de03524e5d5b40caab", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 22, "deletions": 43, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/80a2867ea736007397aa2fbaa0e4c539c80e162c/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a2867ea736007397aa2fbaa0e4c539c80e162c/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=80a2867ea736007397aa2fbaa0e4c539c80e162c", "patch": "@@ -10,6 +10,7 @@\n //\n // ignore-lexer-test FIXME #15883\n \n+use borrow::BorrowFrom;\n use cmp::{Eq, Equiv, PartialEq};\n use core::kinds::Sized;\n use default::Default;\n@@ -184,47 +185,9 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n         self.map.reserve(n)\n     }\n \n-    /// Returns true if the hash set contains a value equivalent to the\n-    /// given query value.\n-    ///\n-    /// # Example\n-    ///\n-    /// This is a slightly silly example where we define the number's\n-    /// parity as the equivalance class. It is important that the\n-    /// values hash the same, which is why we implement `Hash`.\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// use std::hash::Hash;\n-    /// use std::hash::sip::SipState;\n-    ///\n-    /// #[deriving(Eq, PartialEq)]\n-    /// struct EvenOrOdd {\n-    ///     num: uint\n-    /// };\n-    ///\n-    /// impl Hash for EvenOrOdd {\n-    ///     fn hash(&self, state: &mut SipState) {\n-    ///         let parity = self.num % 2;\n-    ///         parity.hash(state);\n-    ///     }\n-    /// }\n-    ///\n-    /// impl Equiv<EvenOrOdd> for EvenOrOdd {\n-    ///     fn equiv(&self, other: &EvenOrOdd) -> bool {\n-    ///         self.num % 2 == other.num % 2\n-    ///     }\n-    /// }\n-    ///\n-    /// let mut set = HashSet::new();\n-    /// set.insert(EvenOrOdd { num: 3u });\n-    ///\n-    /// assert!(set.contains_equiv(&EvenOrOdd { num: 3u }));\n-    /// assert!(set.contains_equiv(&EvenOrOdd { num: 5u }));\n-    /// assert!(!set.contains_equiv(&EvenOrOdd { num: 4u }));\n-    /// assert!(!set.contains_equiv(&EvenOrOdd { num: 2u }));\n-    ///\n-    /// ```\n+    /// Deprecated: use `contains` and `BorrowFrom`.\n+    #[deprecated = \"use contains and BorrowFrom\"]\n+    #[allow(deprecated)]\n     pub fn contains_equiv<Sized? Q: Hash<S> + Equiv<T>>(&self, value: &Q) -> bool {\n       self.map.contains_key_equiv(value)\n     }\n@@ -427,6 +390,10 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n \n     /// Returns `true` if the set contains a value.\n     ///\n+    /// The value may be any borrowed form of the set's value type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -437,7 +404,11 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n+    pub fn contains<Sized? Q>(&self, value: &Q) -> bool\n+        where Q: BorrowFrom<T> + Hash<S> + Eq\n+    {\n+        self.map.contains_key(value)\n+    }\n \n     /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n@@ -527,6 +498,10 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n     ///\n+    /// The value may be any borrowed form of the set's value type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -539,7 +514,11 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value).is_some() }\n+    pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool\n+        where Q: BorrowFrom<T> + Hash<S> + Eq\n+    {\n+        self.map.remove(value).is_some()\n+    }\n }\n \n impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {"}]}