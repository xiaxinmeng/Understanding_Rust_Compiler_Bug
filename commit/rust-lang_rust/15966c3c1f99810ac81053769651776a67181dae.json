{"sha": "15966c3c1f99810ac81053769651776a67181dae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1OTY2YzNjMWY5OTgxMGFjODEwNTM3Njk2NTE3NzZhNjcxODFkYWU=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-01T04:42:55Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-01T17:34:39Z"}, "message": "Remove iotest macro\n\nThis commit removes the `iotest!` macro from `std::io`. The macro was\nprimarily used to ensure that all io-related tests were run on both\nlibnative and libgreen/librustuv. However, now that the librustuv stack\nis being removed, the macro is no longer needed.\n\nSee the [runtime removal\nRFC](https://github.com/rust-lang/rfcs/pull/230) for more context.\n\n[breaking-change]", "tree": {"sha": "d26545a52ea1054efe27f856ab616c64548c6127", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d26545a52ea1054efe27f856ab616c64548c6127"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15966c3c1f99810ac81053769651776a67181dae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15966c3c1f99810ac81053769651776a67181dae", "html_url": "https://github.com/rust-lang/rust/commit/15966c3c1f99810ac81053769651776a67181dae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15966c3c1f99810ac81053769651776a67181dae/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60b859ab8ac8c48b7adbefe81d0e5d3c772b080a", "url": "https://api.github.com/repos/rust-lang/rust/commits/60b859ab8ac8c48b7adbefe81d0e5d3c772b080a", "html_url": "https://github.com/rust-lang/rust/commit/60b859ab8ac8c48b7adbefe81d0e5d3c772b080a"}], "stats": {"total": 1031, "additions": 604, "deletions": 427}, "files": [{"sha": "f777460e66a4538dca42541e3d238ae7314481d5", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 115, "deletions": 79, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -948,9 +948,7 @@ mod test {\n     use io::{SeekSet, SeekCur, SeekEnd, Read, Open, ReadWrite};\n     use io;\n     use str;\n-    use io::fs::{File, rmdir, mkdir, readdir, rmdir_recursive,\n-                 mkdir_recursive, copy, unlink, stat, symlink, link,\n-                 readlink, chmod, lstat, change_file_times};\n+    use io::fs::*;\n     use path::Path;\n     use io;\n     use ops::Drop;\n@@ -1002,7 +1000,8 @@ mod test {\n         TempDir(ret)\n     }\n \n-    iotest!(fn file_test_io_smoke_test() {\n+    #[test]\n+    fn file_test_io_smoke_test() {\n         let message = \"it's alright. have a good time\";\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_rt_io_file_test.txt\");\n@@ -1020,9 +1019,10 @@ mod test {\n             assert_eq!(read_str.as_slice(), message);\n         }\n         check!(unlink(filename));\n-    })\n+    }\n \n-    iotest!(fn invalid_path_raises() {\n+    #[test]\n+    fn invalid_path_raises() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n         let result = File::open_mode(filename, Open, Read);\n@@ -1032,9 +1032,10 @@ mod test {\n             error!(result, \"no such file or directory\");\n         }\n         error!(result, format!(\"path={}; mode=open; access=read\", filename.display()));\n-    })\n+    }\n \n-    iotest!(fn file_test_iounlinking_invalid_path_should_raise_condition() {\n+    #[test]\n+    fn file_test_iounlinking_invalid_path_should_raise_condition() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n \n@@ -1045,9 +1046,10 @@ mod test {\n             error!(result, \"no such file or directory\");\n         }\n         error!(result, format!(\"path={}\", filename.display()));\n-    })\n+    }\n \n-    iotest!(fn file_test_io_non_positional_read() {\n+    #[test]\n+    fn file_test_io_non_positional_read() {\n         let message: &str = \"ten-four\";\n         let mut read_mem = [0, .. 8];\n         let tmpdir = tmpdir();\n@@ -1070,9 +1072,10 @@ mod test {\n         check!(unlink(filename));\n         let read_str = str::from_utf8(read_mem).unwrap();\n         assert_eq!(read_str, message);\n-    })\n+    }\n \n-    iotest!(fn file_test_io_seek_and_tell_smoke_test() {\n+    #[test]\n+    fn file_test_io_seek_and_tell_smoke_test() {\n         let message = \"ten-four\";\n         let mut read_mem = [0, .. 4];\n         let set_cursor = 4 as u64;\n@@ -1096,9 +1099,10 @@ mod test {\n         assert_eq!(read_str, message.slice(4, 8));\n         assert_eq!(tell_pos_pre_read, set_cursor);\n         assert_eq!(tell_pos_post_read, message.len() as u64);\n-    })\n+    }\n \n-    iotest!(fn file_test_io_seek_and_write() {\n+    #[test]\n+    fn file_test_io_seek_and_write() {\n         let initial_msg =   \"food-is-yummy\";\n         let overwrite_msg =    \"-the-bar!!\";\n         let final_msg =     \"foo-the-bar!!\";\n@@ -1119,9 +1123,10 @@ mod test {\n         check!(unlink(filename));\n         let read_str = str::from_utf8(read_mem).unwrap();\n         assert!(read_str.as_slice() == final_msg.as_slice());\n-    })\n+    }\n \n-    iotest!(fn file_test_io_seek_shakedown() {\n+    #[test]\n+    fn file_test_io_seek_shakedown() {\n         use str;          // 01234567890123\n         let initial_msg =   \"qwer-asdf-zxcv\";\n         let chunk_one: &str = \"qwer\";\n@@ -1150,9 +1155,10 @@ mod test {\n             assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_one);\n         }\n         check!(unlink(filename));\n-    })\n+    }\n \n-    iotest!(fn file_test_stat_is_correct_on_is_file() {\n+    #[test]\n+    fn file_test_stat_is_correct_on_is_file() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_file.txt\");\n         {\n@@ -1168,9 +1174,10 @@ mod test {\n         let stat_res_meth = check!(filename.stat());\n         assert_eq!(stat_res_meth.kind, io::TypeFile);\n         check!(unlink(filename));\n-    })\n+    }\n \n-    iotest!(fn file_test_stat_is_correct_on_is_dir() {\n+    #[test]\n+    fn file_test_stat_is_correct_on_is_dir() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n         check!(mkdir(filename, io::UserRWX));\n@@ -1179,26 +1186,29 @@ mod test {\n         let stat_res_meth = check!(filename.stat());\n         assert!(stat_res_meth.kind == io::TypeDirectory);\n         check!(rmdir(filename));\n-    })\n+    }\n \n-    iotest!(fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n+    #[test]\n+    fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n         check!(mkdir(dir, io::UserRWX));\n         assert!(dir.is_file() == false);\n         check!(rmdir(dir));\n-    })\n+    }\n \n-    iotest!(fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n+    #[test]\n+    fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n         let tmpdir = tmpdir();\n         let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n         check!(File::create(file).write(b\"foo\"));\n         assert!(file.exists());\n         check!(unlink(file));\n         assert!(!file.exists());\n-    })\n+    }\n \n-    iotest!(fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n+    #[test]\n+    fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"before_and_after_dir\");\n         assert!(!dir.exists());\n@@ -1207,9 +1217,10 @@ mod test {\n         assert!(dir.is_dir());\n         check!(rmdir(dir));\n         assert!(!dir.exists());\n-    })\n+    }\n \n-    iotest!(fn file_test_directoryinfo_readdir() {\n+    #[test]\n+    fn file_test_directoryinfo_readdir() {\n         use str;\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"di_readdir\");\n@@ -1238,9 +1249,10 @@ mod test {\n             check!(unlink(f));\n         }\n         check!(rmdir(dir));\n-    })\n+    }\n \n-    iotest!(fn file_test_walk_dir() {\n+    #[test]\n+    fn file_test_walk_dir() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"walk_dir\");\n         check!(mkdir(dir, io::UserRWX));\n@@ -1264,16 +1276,18 @@ mod test {\n         }\n \n         check!(rmdir_recursive(dir));\n-    })\n+    }\n \n-    iotest!(fn recursive_mkdir() {\n+    #[test]\n+    fn recursive_mkdir() {\n         let tmpdir = tmpdir();\n         let dir = tmpdir.join(\"d1/d2\");\n         check!(mkdir_recursive(&dir, io::UserRWX));\n         assert!(dir.is_dir())\n-    })\n+    }\n \n-    iotest!(fn recursive_mkdir_failure() {\n+    #[test]\n+    fn recursive_mkdir_failure() {\n         let tmpdir = tmpdir();\n         let dir = tmpdir.join(\"d1\");\n         let file = dir.join(\"f1\");\n@@ -1287,15 +1301,17 @@ mod test {\n         error!(result, \"couldn't create directory\");\n         error!(result, \"mode=0700\");\n         error!(result, format!(\"path={}\", file.display()));\n-    })\n+    }\n \n-    iotest!(fn recursive_mkdir_slash() {\n+    #[test]\n+    fn recursive_mkdir_slash() {\n         check!(mkdir_recursive(&Path::new(\"/\"), io::UserRWX));\n-    })\n+    }\n \n     // FIXME(#12795) depends on lstat to work on windows\n     #[cfg(not(windows))]\n-    iotest!(fn recursive_rmdir() {\n+    #[test]\n+    fn recursive_rmdir() {\n         let tmpdir = tmpdir();\n         let d1 = tmpdir.join(\"d1\");\n         let dt = d1.join(\"t\");\n@@ -1310,9 +1326,10 @@ mod test {\n \n         assert!(!d1.is_dir());\n         assert!(canary.exists());\n-    })\n+    }\n \n-    iotest!(fn unicode_path_is_dir() {\n+    #[test]\n+    fn unicode_path_is_dir() {\n         assert!(Path::new(\".\").is_dir());\n         assert!(!Path::new(\"test/stdtest/fs.rs\").is_dir());\n \n@@ -1328,9 +1345,10 @@ mod test {\n         check!(File::create(&filepath)); // ignore return; touch only\n         assert!(!filepath.is_dir());\n         assert!(filepath.exists());\n-    })\n+    }\n \n-    iotest!(fn unicode_path_exists() {\n+    #[test]\n+    fn unicode_path_exists() {\n         assert!(Path::new(\".\").exists());\n         assert!(!Path::new(\"test/nonexistent-bogus-path\").exists());\n \n@@ -1340,9 +1358,10 @@ mod test {\n         check!(mkdir(&unicode, io::UserRWX));\n         assert!(unicode.exists());\n         assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n-    })\n+    }\n \n-    iotest!(fn copy_file_does_not_exist() {\n+    #[test]\n+    fn copy_file_does_not_exist() {\n         let from = Path::new(\"test/nonexistent-bogus-path\");\n         let to = Path::new(\"test/other-bogus-path\");\n \n@@ -1358,9 +1377,10 @@ mod test {\n                 assert!(!to.exists());\n             }\n         }\n-    })\n+    }\n \n-    iotest!(fn copy_file_ok() {\n+    #[test]\n+    fn copy_file_ok() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n@@ -1371,19 +1391,21 @@ mod test {\n         assert_eq!(contents.as_slice(), b\"hello\");\n \n         assert_eq!(check!(input.stat()).perm, check!(out.stat()).perm);\n-    })\n+    }\n \n-    iotest!(fn copy_file_dst_dir() {\n+    #[test]\n+    fn copy_file_dst_dir() {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n \n         check!(File::create(&out));\n         match copy(&out, tmpdir.path()) {\n             Ok(..) => fail!(), Err(..) => {}\n         }\n-    })\n+    }\n \n-    iotest!(fn copy_file_dst_exists() {\n+    #[test]\n+    fn copy_file_dst_exists() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in\");\n         let output = tmpdir.join(\"out\");\n@@ -1394,19 +1416,21 @@ mod test {\n \n         assert_eq!(check!(File::open(&output).read_to_end()),\n                    (Vec::from_slice(b\"foo\")));\n-    })\n+    }\n \n-    iotest!(fn copy_file_src_dir() {\n+    #[test]\n+    fn copy_file_src_dir() {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n \n         match copy(tmpdir.path(), &out) {\n             Ok(..) => fail!(), Err(..) => {}\n         }\n         assert!(!out.exists());\n-    })\n+    }\n \n-    iotest!(fn copy_file_preserves_perm_bits() {\n+    #[test]\n+    fn copy_file_preserves_perm_bits() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n@@ -1418,10 +1442,11 @@ mod test {\n \n         check!(chmod(&input, io::UserFile));\n         check!(chmod(&out, io::UserFile));\n-    })\n+    }\n \n     #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n-    iotest!(fn symlinks_work() {\n+    #[test]\n+    fn symlinks_work() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n@@ -1435,25 +1460,28 @@ mod test {\n         assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n         assert_eq!(check!(File::open(&out).read_to_end()),\n                    (Vec::from_slice(b\"foobar\")));\n-    })\n+    }\n \n     #[cfg(not(windows))] // apparently windows doesn't like symlinks\n-    iotest!(fn symlink_noexist() {\n+    #[test]\n+    fn symlink_noexist() {\n         let tmpdir = tmpdir();\n         // symlinks can point to things that don't exist\n         check!(symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")));\n         assert!(check!(readlink(&tmpdir.join(\"bar\"))) == tmpdir.join(\"foo\"));\n-    })\n+    }\n \n-    iotest!(fn readlink_not_symlink() {\n+    #[test]\n+    fn readlink_not_symlink() {\n         let tmpdir = tmpdir();\n         match readlink(tmpdir.path()) {\n             Ok(..) => fail!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n-    })\n+    }\n \n-    iotest!(fn links_work() {\n+    #[test]\n+    fn links_work() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n@@ -1481,9 +1509,10 @@ mod test {\n             Ok(..) => fail!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n-    })\n+    }\n \n-    iotest!(fn chmod_works() {\n+    #[test]\n+    fn chmod_works() {\n         let tmpdir = tmpdir();\n         let file = tmpdir.join(\"in.txt\");\n \n@@ -1498,9 +1527,10 @@ mod test {\n         }\n \n         check!(chmod(&file, io::UserFile));\n-    })\n+    }\n \n-    iotest!(fn sync_doesnt_kill_anything() {\n+    #[test]\n+    fn sync_doesnt_kill_anything() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n@@ -1511,9 +1541,10 @@ mod test {\n         check!(file.fsync());\n         check!(file.datasync());\n         drop(file);\n-    })\n+    }\n \n-    iotest!(fn truncate_works() {\n+    #[test]\n+    fn truncate_works() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n@@ -1542,9 +1573,10 @@ mod test {\n         assert_eq!(check!(File::open(&path).read_to_end()),\n                    (Vec::from_slice(b\"fo\\0\\0\\0\\0wut\")));\n         drop(file);\n-    })\n+    }\n \n-    iotest!(fn open_flavors() {\n+    #[test]\n+    fn open_flavors() {\n         let tmpdir = tmpdir();\n \n         match File::open_mode(&tmpdir.join(\"a\"), io::Open, io::Read) {\n@@ -1602,9 +1634,10 @@ mod test {\n         }\n         assert!(check!(stat(&tmpdir.join(\"h\"))).size == 3,\n                 \"truncate didn't truncate\");\n-    })\n+    }\n \n-    iotest!(fn utime() {\n+    #[test]\n+    fn utime() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"a\");\n         check!(File::create(&path));\n@@ -1613,18 +1646,20 @@ mod test {\n         check!(change_file_times(&path, 100000, 200000));\n         assert_eq!(check!(path.stat()).accessed, 100000);\n         assert_eq!(check!(path.stat()).modified, 200000);\n-    })\n+    }\n \n-    iotest!(fn utime_noexist() {\n+    #[test]\n+    fn utime_noexist() {\n         let tmpdir = tmpdir();\n \n         match change_file_times(&tmpdir.join(\"a\"), 100, 200) {\n             Ok(..) => fail!(),\n             Err(..) => {}\n         }\n-    })\n+    }\n \n-    iotest!(fn binary_file() {\n+    #[test]\n+    fn binary_file() {\n         use rand::{StdRng, Rng};\n \n         let mut bytes = [0, ..1024];\n@@ -1635,13 +1670,14 @@ mod test {\n         check!(File::create(&tmpdir.join(\"test\")).write(bytes));\n         let actual = check!(File::open(&tmpdir.join(\"test\")).read_to_end());\n         assert!(actual.as_slice() == bytes);\n-    })\n+    }\n \n-    iotest!(fn unlink_readonly() {\n+    #[test]\n+    fn unlink_readonly() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"file\");\n         check!(File::create(&path));\n         check!(chmod(&path, io::UserRead));\n         check!(unlink(&path));\n-    })\n+    }\n }"}, {"sha": "2191a682d3641e0d6fcec9dc2919bef1567cdf22", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -265,9 +265,6 @@ pub use self::buffered::{BufferedReader, BufferedWriter, BufferedStream,\n                          LineBufferedWriter};\n pub use self::comm_adapters::{ChanReader, ChanWriter};\n \n-// this comes first to get the iotest! macro\n-pub mod test;\n-\n mod buffered;\n mod comm_adapters;\n mod mem;\n@@ -280,6 +277,7 @@ pub mod pipe;\n pub mod process;\n pub mod signal;\n pub mod stdio;\n+pub mod test;\n pub mod timer;\n pub mod util;\n "}, {"sha": "27241f9bfa55951410e9163676d5f5a71e2e718a", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -125,19 +125,27 @@ fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n // permission without help of apk\n #[cfg(all(test, not(target_os = \"android\")))]\n mod test {\n-    iotest!(fn dns_smoke_test() {\n+    use super::*;\n+    use io::net::tcp::*;\n+    use io::net::ip::*;\n+    use io::net::udp::*;\n+\n+    #[test]\n+    fn dns_smoke_test() {\n         let ipaddrs = get_host_addresses(\"localhost\").unwrap();\n         let mut found_local = false;\n         let local_addr = &Ipv4Addr(127, 0, 0, 1);\n         for addr in ipaddrs.iter() {\n             found_local = found_local || addr == local_addr;\n         }\n         assert!(found_local);\n-    })\n+    }\n \n-    iotest!(fn issue_10663() {\n+    #[ignore]\n+    #[test]\n+    fn issue_10663() {\n         // Something should happen here, but this certainly shouldn't cause\n         // everything to die. The actual outcome we don't care too much about.\n         get_host_addresses(\"example.com\").unwrap();\n-    } #[ignore])\n+    }\n }"}, {"sha": "3f8069468f653506a4f3479ec809d9bf68f66e64", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 86, "deletions": 54, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -257,6 +257,8 @@ mod tests {\n     use super::*;\n     use io::*;\n     use io::test::*;\n+    use io::fs::PathExtensions;\n+    use time::Duration;\n \n     pub fn smalltest(server: proc(UnixStream):Send, client: proc(UnixStream):Send) {\n         let path1 = next_test_unix();\n@@ -277,7 +279,8 @@ mod tests {\n         }\n     }\n \n-    iotest!(fn bind_error() {\n+    #[test]\n+    fn bind_error() {\n         let path = \"path/to/nowhere\";\n         match UnixListener::bind(&path) {\n             Ok(..) => fail!(),\n@@ -286,9 +289,10 @@ mod tests {\n                         e.kind == InvalidInput);\n             }\n         }\n-    })\n+    }\n \n-    iotest!(fn connect_error() {\n+    #[test]\n+    fn connect_error() {\n         let path = if cfg!(windows) {\n             r\"\\\\.\\pipe\\this_should_not_exist_ever\"\n         } else {\n@@ -300,29 +304,33 @@ mod tests {\n                 assert!(e.kind == FileNotFound || e.kind == OtherIoError);\n             }\n         }\n-    })\n+    }\n \n-    iotest!(fn smoke() {\n+    #[test]\n+    fn smoke() {\n         smalltest(proc(mut server) {\n             let mut buf = [0];\n             server.read(buf).unwrap();\n             assert!(buf[0] == 99);\n         }, proc(mut client) {\n             client.write([99]).unwrap();\n         })\n-    })\n+    }\n \n-    iotest!(fn read_eof() {\n+    #[cfg_attr(windows, ignore)] // FIXME(#12516)\n+    #[test]\n+    fn read_eof() {\n         smalltest(proc(mut server) {\n             let mut buf = [0];\n             assert!(server.read(buf).is_err());\n             assert!(server.read(buf).is_err());\n         }, proc(_client) {\n             // drop the client\n         })\n-    } #[cfg_attr(windows, ignore)]) // FIXME(#12516)\n+    }\n \n-    iotest!(fn write_begone() {\n+    #[test]\n+    fn write_begone() {\n         smalltest(proc(mut server) {\n             let buf = [0];\n             loop {\n@@ -340,9 +348,10 @@ mod tests {\n         }, proc(_client) {\n             // drop the client\n         })\n-    })\n+    }\n \n-    iotest!(fn accept_lots() {\n+    #[test]\n+    fn accept_lots() {\n         let times = 10;\n         let path1 = next_test_unix();\n         let path2 = path1.clone();\n@@ -371,16 +380,18 @@ mod tests {\n             }\n             assert_eq!(buf[0], 100);\n         }\n-    })\n+    }\n \n     #[cfg(unix)]\n-    iotest!(fn path_exists() {\n+    #[test]\n+    fn path_exists() {\n         let path = next_test_unix();\n         let _acceptor = UnixListener::bind(&path).listen();\n         assert!(path.exists());\n-    })\n+    }\n \n-    iotest!(fn unix_clone_smoke() {\n+    #[test]\n+    fn unix_clone_smoke() {\n         let addr = next_test_unix();\n         let mut acceptor = UnixListener::bind(&addr).listen();\n \n@@ -414,9 +425,10 @@ mod tests {\n         assert_eq!(s1.read(buf), Ok(1));\n         debug!(\"reader done\");\n         rx2.recv();\n-    })\n+    }\n \n-    iotest!(fn unix_clone_two_read() {\n+    #[test]\n+    fn unix_clone_two_read() {\n         let addr = next_test_unix();\n         let mut acceptor = UnixListener::bind(&addr).listen();\n         let (tx1, rx) = channel();\n@@ -446,9 +458,10 @@ mod tests {\n         tx1.send(());\n \n         rx.recv();\n-    })\n+    }\n \n-    iotest!(fn unix_clone_two_write() {\n+    #[test]\n+    fn unix_clone_two_write() {\n         let addr = next_test_unix();\n         let mut acceptor = UnixListener::bind(&addr).listen();\n \n@@ -471,25 +484,30 @@ mod tests {\n         s1.write([2]).unwrap();\n \n         rx.recv();\n-    })\n+    }\n \n-    iotest!(fn drop_removes_listener_path() {\n+    #[cfg(not(windows))]\n+    #[test]\n+    fn drop_removes_listener_path() {\n         let path = next_test_unix();\n         let l = UnixListener::bind(&path).unwrap();\n         assert!(path.exists());\n         drop(l);\n         assert!(!path.exists());\n-    } #[cfg(not(windows))])\n+    }\n \n-    iotest!(fn drop_removes_acceptor_path() {\n+    #[cfg(not(windows))]\n+    #[test]\n+    fn drop_removes_acceptor_path() {\n         let path = next_test_unix();\n         let l = UnixListener::bind(&path).unwrap();\n         assert!(path.exists());\n         drop(l.listen().unwrap());\n         assert!(!path.exists());\n-    } #[cfg(not(windows))])\n+    }\n \n-    iotest!(fn accept_timeout() {\n+    #[test]\n+    fn accept_timeout() {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n \n@@ -527,32 +545,37 @@ mod tests {\n             drop(UnixStream::connect(&addr2).unwrap());\n         });\n         a.accept().unwrap();\n-    })\n+    }\n \n-    iotest!(fn connect_timeout_error() {\n+    #[test]\n+    fn connect_timeout_error() {\n         let addr = next_test_unix();\n         assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(100)).is_err());\n-    })\n+    }\n \n-    iotest!(fn connect_timeout_success() {\n+    #[test]\n+    fn connect_timeout_success() {\n         let addr = next_test_unix();\n         let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n         assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(100)).is_ok());\n-    })\n+    }\n \n-    iotest!(fn connect_timeout_zero() {\n+    #[test]\n+    fn connect_timeout_zero() {\n         let addr = next_test_unix();\n         let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n         assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(0)).is_err());\n-    })\n+    }\n \n-    iotest!(fn connect_timeout_negative() {\n+    #[test]\n+    fn connect_timeout_negative() {\n         let addr = next_test_unix();\n         let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n         assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(-1)).is_err());\n-    })\n+    }\n \n-    iotest!(fn close_readwrite_smoke() {\n+    #[test]\n+    fn close_readwrite_smoke() {\n         let addr = next_test_unix();\n         let a = UnixListener::bind(&addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n@@ -586,9 +609,10 @@ mod tests {\n         let _ = s2.close_write();\n         let _ = s3.close_read();\n         let _ = s3.close_write();\n-    })\n+    }\n \n-    iotest!(fn close_read_wakes_up() {\n+    #[test]\n+    fn close_read_wakes_up() {\n         let addr = next_test_unix();\n         let a = UnixListener::bind(&addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n@@ -611,9 +635,10 @@ mod tests {\n \n         // this test will never finish if the child doesn't wake up\n         rx.recv();\n-    })\n+    }\n \n-    iotest!(fn readwrite_timeouts() {\n+    #[test]\n+    fn readwrite_timeouts() {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n@@ -648,9 +673,10 @@ mod tests {\n         tx.send(());\n         s.set_timeout(None);\n         assert_eq!(s.read([0, 0]), Ok(1));\n-    })\n+    }\n \n-    iotest!(fn read_timeouts() {\n+    #[test]\n+    fn read_timeouts() {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n@@ -676,9 +702,10 @@ mod tests {\n         for _ in range(0u, 100) {\n             assert!(s.write([0, ..128 * 1024]).is_ok());\n         }\n-    })\n+    }\n \n-    iotest!(fn write_timeouts() {\n+    #[test]\n+    fn write_timeouts() {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n@@ -702,9 +729,10 @@ mod tests {\n \n         tx.send(());\n         assert!(s.read([0]).is_ok());\n-    })\n+    }\n \n-    iotest!(fn timeout_concurrent_read() {\n+    #[test]\n+    fn timeout_concurrent_read() {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n@@ -729,10 +757,11 @@ mod tests {\n         tx.send(());\n \n         rx2.recv();\n-    })\n+    }\n \n     #[cfg(not(windows))]\n-    iotest!(fn clone_accept_smoke() {\n+    #[test]\n+    fn clone_accept_smoke() {\n         let addr = next_test_unix();\n         let l = UnixListener::bind(&addr);\n         let mut a = l.listen().unwrap();\n@@ -749,10 +778,11 @@ mod tests {\n         assert!(a.accept().is_ok());\n         drop(a);\n         assert!(a2.accept().is_ok());\n-    })\n+    }\n \n     #[cfg(not(windows))] // FIXME #17553\n-    iotest!(fn clone_accept_concurrent() {\n+    #[test]\n+    fn clone_accept_concurrent() {\n         let addr = next_test_unix();\n         let l = UnixListener::bind(&addr);\n         let a = l.listen().unwrap();\n@@ -774,18 +804,20 @@ mod tests {\n \n         assert!(rx.recv().is_ok());\n         assert!(rx.recv().is_ok());\n-    })\n+    }\n \n-    iotest!(fn close_accept_smoke() {\n+    #[test]\n+    fn close_accept_smoke() {\n         let addr = next_test_unix();\n         let l = UnixListener::bind(&addr);\n         let mut a = l.listen().unwrap();\n \n         a.close_accept().unwrap();\n         assert_eq!(a.accept().err().unwrap().kind, EndOfFile);\n-    })\n+    }\n \n-    iotest!(fn close_accept_concurrent() {\n+    #[test]\n+    fn close_accept_concurrent() {\n         let addr = next_test_unix();\n         let l = UnixListener::bind(&addr);\n         let a = l.listen().unwrap();\n@@ -799,5 +831,5 @@ mod tests {\n         a2.close_accept().unwrap();\n \n         assert_eq!(rx.recv().err().unwrap().kind, EndOfFile);\n-    })\n+    }\n }"}, {"sha": "cbd02abff7d2a20b35746be2e7c089a0c9a502b3", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 128, "deletions": 83, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -523,26 +523,33 @@ impl Clone for TcpAcceptor {\n #[allow(experimental)]\n mod test {\n     use super::*;\n-    use io::net::ip::SocketAddr;\n+    use io::net::tcp::*;\n+    use io::net::ip::*;\n+    use io::net::udp::*;\n     use io::*;\n+    use io::test::*;\n     use prelude::*;\n \n     // FIXME #11530 this fails on android because tests are run as root\n-    iotest!(fn bind_error() {\n+    #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n+    #[test]\n+    fn bind_error() {\n         match TcpListener::bind(\"0.0.0.0\", 1) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.kind, PermissionDenied),\n         }\n-    } #[cfg_attr(any(windows, target_os = \"android\"), ignore)])\n+    }\n \n-    iotest!(fn connect_error() {\n+    #[test]\n+    fn connect_error() {\n         match TcpStream::connect(\"0.0.0.0\", 1) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.kind, ConnectionRefused),\n         }\n-    })\n+    }\n \n-    iotest!(fn listen_ip4_localhost() {\n+    #[test]\n+    fn listen_ip4_localhost() {\n         let socket_addr = next_test_ip4();\n         let ip_str = socket_addr.ip.to_string();\n         let port = socket_addr.port;\n@@ -558,9 +565,10 @@ mod test {\n         let mut buf = [0];\n         stream.read(buf).unwrap();\n         assert!(buf[0] == 144);\n-    })\n+    }\n \n-    iotest!(fn connect_localhost() {\n+    #[test]\n+    fn connect_localhost() {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -575,9 +583,10 @@ mod test {\n         let mut buf = [0];\n         stream.read(buf).unwrap();\n         assert!(buf[0] == 64);\n-    })\n+    }\n \n-    iotest!(fn connect_ip4_loopback() {\n+    #[test]\n+    fn connect_ip4_loopback() {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -592,9 +601,10 @@ mod test {\n         let mut buf = [0];\n         stream.read(buf).unwrap();\n         assert!(buf[0] == 44);\n-    })\n+    }\n \n-    iotest!(fn connect_ip6_loopback() {\n+    #[test]\n+    fn connect_ip6_loopback() {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -609,9 +619,10 @@ mod test {\n         let mut buf = [0];\n         stream.read(buf).unwrap();\n         assert!(buf[0] == 66);\n-    })\n+    }\n \n-    iotest!(fn smoke_test_ip4() {\n+    #[test]\n+    fn smoke_test_ip4() {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -626,9 +637,10 @@ mod test {\n         let mut buf = [0];\n         stream.read(buf).unwrap();\n         assert!(buf[0] == 99);\n-    })\n+    }\n \n-    iotest!(fn smoke_test_ip6() {\n+    #[test]\n+    fn smoke_test_ip6() {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -643,9 +655,10 @@ mod test {\n         let mut buf = [0];\n         stream.read(buf).unwrap();\n         assert!(buf[0] == 99);\n-    })\n+    }\n \n-    iotest!(fn read_eof_ip4() {\n+    #[test]\n+    fn read_eof_ip4() {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -660,9 +673,10 @@ mod test {\n         let mut buf = [0];\n         let nread = stream.read(buf);\n         assert!(nread.is_err());\n-    })\n+    }\n \n-    iotest!(fn read_eof_ip6() {\n+    #[test]\n+    fn read_eof_ip6() {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -677,9 +691,10 @@ mod test {\n         let mut buf = [0];\n         let nread = stream.read(buf);\n         assert!(nread.is_err());\n-    })\n+    }\n \n-    iotest!(fn read_eof_twice_ip4() {\n+    #[test]\n+    fn read_eof_twice_ip4() {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -702,9 +717,10 @@ mod test {\n                         \"unknown kind: {}\", e.kind);\n             }\n         }\n-    })\n+    }\n \n-    iotest!(fn read_eof_twice_ip6() {\n+    #[test]\n+    fn read_eof_twice_ip6() {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -727,9 +743,10 @@ mod test {\n                         \"unknown kind: {}\", e.kind);\n             }\n         }\n-    })\n+    }\n \n-    iotest!(fn write_close_ip4() {\n+    #[test]\n+    fn write_close_ip4() {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -754,9 +771,10 @@ mod test {\n                 }\n             }\n         }\n-    })\n+    }\n \n-    iotest!(fn write_close_ip6() {\n+    #[test]\n+    fn write_close_ip6() {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -781,9 +799,10 @@ mod test {\n                 }\n             }\n         }\n-    })\n+    }\n \n-    iotest!(fn multiple_connect_serial_ip4() {\n+    #[test]\n+    fn multiple_connect_serial_ip4() {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -802,9 +821,10 @@ mod test {\n             stream.read(buf).unwrap();\n             assert_eq!(buf[0], 99);\n         }\n-    })\n+    }\n \n-    iotest!(fn multiple_connect_serial_ip6() {\n+    #[test]\n+    fn multiple_connect_serial_ip6() {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -823,9 +843,10 @@ mod test {\n             stream.read(buf).unwrap();\n             assert_eq!(buf[0], 99);\n         }\n-    })\n+    }\n \n-    iotest!(fn multiple_connect_interleaved_greedy_schedule_ip4() {\n+    #[test]\n+    fn multiple_connect_interleaved_greedy_schedule_ip4() {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -862,9 +883,10 @@ mod test {\n                 stream.write([i as u8]).unwrap();\n             });\n         }\n-    })\n+    }\n \n-    iotest!(fn multiple_connect_interleaved_greedy_schedule_ip6() {\n+    #[test]\n+    fn multiple_connect_interleaved_greedy_schedule_ip6() {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -901,9 +923,10 @@ mod test {\n                 stream.write([i as u8]).unwrap();\n             });\n         }\n-    })\n+    }\n \n-    iotest!(fn multiple_connect_interleaved_lazy_schedule_ip4() {\n+    #[test]\n+    fn multiple_connect_interleaved_lazy_schedule_ip4() {\n         static MAX: int = 10;\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_string();\n@@ -940,9 +963,10 @@ mod test {\n                 stream.write([99]).unwrap();\n             });\n         }\n-    })\n+    }\n \n-    iotest!(fn multiple_connect_interleaved_lazy_schedule_ip6() {\n+    #[test]\n+    fn multiple_connect_interleaved_lazy_schedule_ip6() {\n         static MAX: int = 10;\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_string();\n@@ -979,7 +1003,7 @@ mod test {\n                 stream.write([99]).unwrap();\n             });\n         }\n-    })\n+    }\n \n     pub fn socket_name(addr: SocketAddr) {\n         let ip_str = addr.ip.to_string();\n@@ -1015,18 +1039,21 @@ mod test {\n         assert_eq!(addr, peer_name.unwrap());\n     }\n \n-    iotest!(fn socket_and_peer_name_ip4() {\n+    #[test]\n+    fn socket_and_peer_name_ip4() {\n         peer_name(next_test_ip4());\n         socket_name(next_test_ip4());\n-    })\n+    }\n \n-    iotest!(fn socket_and_peer_name_ip6() {\n+    #[test]\n+    fn socket_and_peer_name_ip6() {\n         // FIXME: peer name is not consistent\n         //peer_name(next_test_ip6());\n         socket_name(next_test_ip6());\n-    })\n+    }\n \n-    iotest!(fn partial_read() {\n+    #[test]\n+    fn partial_read() {\n         let addr = next_test_ip4();\n         let port = addr.port;\n         let (tx, rx) = channel();\n@@ -1048,9 +1075,10 @@ mod test {\n         assert_eq!(c.read(b), Ok(1));\n         c.write([1]).unwrap();\n         rx.recv();\n-    })\n+    }\n \n-    iotest!(fn double_bind() {\n+    #[test]\n+    fn double_bind() {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -1063,9 +1091,10 @@ mod test {\n                         \"unknown error: {} {}\", e, e.kind);\n             }\n         }\n-    })\n+    }\n \n-    iotest!(fn fast_rebind() {\n+    #[test]\n+    fn fast_rebind() {\n         let addr = next_test_ip4();\n         let port = addr.port;\n         let (tx, rx) = channel();\n@@ -1090,9 +1119,10 @@ mod test {\n             // Close listener\n         }\n         let _listener = TcpListener::bind(addr.ip.to_string().as_slice(), port);\n-    })\n+    }\n \n-    iotest!(fn tcp_clone_smoke() {\n+    #[test]\n+    fn tcp_clone_smoke() {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -1121,9 +1151,10 @@ mod test {\n         let mut buf = [0, 0];\n         assert_eq!(s1.read(buf), Ok(1));\n         rx2.recv();\n-    })\n+    }\n \n-    iotest!(fn tcp_clone_two_read() {\n+    #[test]\n+    fn tcp_clone_two_read() {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -1155,9 +1186,10 @@ mod test {\n         tx1.send(());\n \n         rx.recv();\n-    })\n+    }\n \n-    iotest!(fn tcp_clone_two_write() {\n+    #[test]\n+    fn tcp_clone_two_write() {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -1182,9 +1214,10 @@ mod test {\n         s1.write([2]).unwrap();\n \n         rx.recv();\n-    })\n+    }\n \n-    iotest!(fn shutdown_smoke() {\n+    #[test]\n+    fn shutdown_smoke() {\n         use rt::rtio::RtioTcpStream;\n \n         let addr = next_test_ip4();\n@@ -1202,9 +1235,10 @@ mod test {\n         assert!(s.obj.close_write().is_ok());\n         assert!(s.write([1]).is_err());\n         assert_eq!(s.read_to_end(), Ok(vec!(1)));\n-    })\n+    }\n \n-    iotest!(fn accept_timeout() {\n+    #[test]\n+    fn accept_timeout() {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -1249,9 +1283,10 @@ mod test {\n                                     port).unwrap());\n         });\n         a.accept().unwrap();\n-    })\n+    }\n \n-    iotest!(fn close_readwrite_smoke() {\n+    #[test]\n+    fn close_readwrite_smoke() {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -1287,9 +1322,10 @@ mod test {\n         let _ = s2.close_write();\n         let _ = s3.close_read();\n         let _ = s3.close_write();\n-    })\n+    }\n \n-    iotest!(fn close_read_wakes_up() {\n+    #[test]\n+    fn close_read_wakes_up() {\n         let addr = next_test_ip4();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -1314,9 +1350,10 @@ mod test {\n \n         // this test will never finish if the child doesn't wake up\n         rx.recv();\n-    })\n+    }\n \n-    iotest!(fn readwrite_timeouts() {\n+    #[test]\n+    fn readwrite_timeouts() {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -1348,9 +1385,10 @@ mod test {\n         tx.send(());\n         s.set_timeout(None);\n         assert_eq!(s.read([0, 0]), Ok(1));\n-    })\n+    }\n \n-    iotest!(fn read_timeouts() {\n+    #[test]\n+    fn read_timeouts() {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -1378,9 +1416,10 @@ mod test {\n         for _ in range(0i, 100) {\n             assert!(s.write([0, ..128 * 1024]).is_ok());\n         }\n-    })\n+    }\n \n-    iotest!(fn write_timeouts() {\n+    #[test]\n+    fn write_timeouts() {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -1407,9 +1446,10 @@ mod test {\n \n         tx.send(());\n         assert!(s.read([0]).is_ok());\n-    })\n+    }\n \n-    iotest!(fn timeout_concurrent_read() {\n+    #[test]\n+    fn timeout_concurrent_read() {\n         let addr = next_test_ip6();\n         let ip_str = addr.ip.to_string();\n         let port = addr.port;\n@@ -1436,9 +1476,10 @@ mod test {\n         tx.send(());\n \n         rx2.recv();\n-    })\n+    }\n \n-    iotest!(fn clone_while_reading() {\n+    #[test]\n+    fn clone_while_reading() {\n         let addr = next_test_ip6();\n         let listen = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n         let mut accept = listen.listen().unwrap();\n@@ -1476,9 +1517,10 @@ mod test {\n         tx.send(());\n         rxdone.recv();\n         rxdone.recv();\n-    })\n+    }\n \n-    iotest!(fn clone_accept_smoke() {\n+    #[test]\n+    fn clone_accept_smoke() {\n         let addr = next_test_ip4();\n         let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n         let mut a = l.listen().unwrap();\n@@ -1493,9 +1535,10 @@ mod test {\n \n         assert!(a.accept().is_ok());\n         assert!(a2.accept().is_ok());\n-    })\n+    }\n \n-    iotest!(fn clone_accept_concurrent() {\n+    #[test]\n+    fn clone_accept_concurrent() {\n         let addr = next_test_ip4();\n         let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n         let a = l.listen().unwrap();\n@@ -1516,18 +1559,20 @@ mod test {\n \n         assert!(rx.recv().is_ok());\n         assert!(rx.recv().is_ok());\n-    })\n+    }\n \n-    iotest!(fn close_accept_smoke() {\n+    #[test]\n+    fn close_accept_smoke() {\n         let addr = next_test_ip4();\n         let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n         let mut a = l.listen().unwrap();\n \n         a.close_accept().unwrap();\n         assert_eq!(a.accept().err().unwrap().kind, EndOfFile);\n-    })\n+    }\n \n-    iotest!(fn close_accept_concurrent() {\n+    #[test]\n+    fn close_accept_concurrent() {\n         let addr = next_test_ip4();\n         let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n         let a = l.listen().unwrap();\n@@ -1541,5 +1586,5 @@ mod test {\n         a2.close_accept().unwrap();\n \n         assert_eq!(rx.recv().err().unwrap().kind, EndOfFile);\n-    })\n+    }\n }"}, {"sha": "3ba8765fc3e215cf7797fc0b544c88eff32e2a8c", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -264,18 +264,24 @@ impl Writer for UdpStream {\n #[allow(experimental)]\n mod test {\n     use super::*;\n-    use io::net::ip::{SocketAddr};\n+    use prelude::*;\n+    use io::*;\n+    use io::net::ip::*;\n+    use io::test::*;\n \n     // FIXME #11530 this fails on android because tests are run as root\n-    iotest!(fn bind_error() {\n+    #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n+    #[test]\n+    fn bind_error() {\n         let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n         match UdpSocket::bind(addr) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.kind, PermissionDenied),\n         }\n-    } #[cfg_attr(any(windows, target_os = \"android\"), ignore)])\n+    }\n \n-    iotest!(fn socket_smoke_test_ip4() {\n+    #[test]\n+    fn socket_smoke_test_ip4() {\n         let server_ip = next_test_ip4();\n         let client_ip = next_test_ip4();\n         let (tx1, rx1) = channel();\n@@ -308,9 +314,10 @@ mod test {\n             Err(..) => fail!()\n         }\n         rx2.recv();\n-    })\n+    }\n \n-    iotest!(fn socket_smoke_test_ip6() {\n+    #[test]\n+    fn socket_smoke_test_ip6() {\n         let server_ip = next_test_ip6();\n         let client_ip = next_test_ip6();\n         let (tx, rx) = channel::<()>();\n@@ -340,9 +347,10 @@ mod test {\n             }\n             Err(..) => fail!()\n         }\n-    })\n+    }\n \n-    iotest!(fn stream_smoke_test_ip4() {\n+    #[test]\n+    fn stream_smoke_test_ip4() {\n         let server_ip = next_test_ip4();\n         let client_ip = next_test_ip4();\n         let (tx1, rx1) = channel();\n@@ -378,9 +386,10 @@ mod test {\n             Err(..) => fail!()\n         }\n         rx2.recv();\n-    })\n+    }\n \n-    iotest!(fn stream_smoke_test_ip6() {\n+    #[test]\n+    fn stream_smoke_test_ip6() {\n         let server_ip = next_test_ip6();\n         let client_ip = next_test_ip6();\n         let (tx1, rx1) = channel();\n@@ -416,7 +425,7 @@ mod test {\n             Err(..) => fail!()\n         }\n         rx2.recv();\n-    })\n+    }\n \n     pub fn socket_name(addr: SocketAddr) {\n         let server = UdpSocket::bind(addr);\n@@ -431,15 +440,18 @@ mod test {\n         assert_eq!(addr, so_name.unwrap());\n     }\n \n-    iotest!(fn socket_name_ip4() {\n+    #[test]\n+    fn socket_name_ip4() {\n         socket_name(next_test_ip4());\n-    })\n+    }\n \n-    iotest!(fn socket_name_ip6() {\n+    #[test]\n+    fn socket_name_ip6() {\n         socket_name(next_test_ip6());\n-    })\n+    }\n \n-    iotest!(fn udp_clone_smoke() {\n+    #[test]\n+    fn udp_clone_smoke() {\n         let addr1 = next_test_ip4();\n         let addr2 = next_test_ip4();\n         let mut sock1 = UdpSocket::bind(addr1).unwrap();\n@@ -467,9 +479,10 @@ mod test {\n         let mut buf = [0, 0];\n         assert_eq!(sock1.recv_from(buf), Ok((1, addr2)));\n         rx2.recv();\n-    })\n+    }\n \n-    iotest!(fn udp_clone_two_read() {\n+    #[test]\n+    fn udp_clone_two_read() {\n         let addr1 = next_test_ip4();\n         let addr2 = next_test_ip4();\n         let mut sock1 = UdpSocket::bind(addr1).unwrap();\n@@ -500,9 +513,10 @@ mod test {\n         tx1.send(());\n \n         rx.recv();\n-    })\n+    }\n \n-    iotest!(fn udp_clone_two_write() {\n+    #[test]\n+    fn udp_clone_two_write() {\n         let addr1 = next_test_ip4();\n         let addr2 = next_test_ip4();\n         let mut sock1 = UdpSocket::bind(addr1).unwrap();\n@@ -543,10 +557,11 @@ mod test {\n \n         rx.recv();\n         serv_rx.recv();\n-    })\n+    }\n \n     #[cfg(not(windows))] // FIXME #17553\n-    iotest!(fn recv_from_timeout() {\n+    #[test]\n+    fn recv_from_timeout() {\n         let addr1 = next_test_ip4();\n         let addr2 = next_test_ip4();\n         let mut a = UdpSocket::bind(addr1).unwrap();\n@@ -580,9 +595,10 @@ mod test {\n \n         // Make sure the child didn't die\n         rx2.recv();\n-    })\n+    }\n \n-    iotest!(fn send_to_timeout() {\n+    #[test]\n+    fn send_to_timeout() {\n         let addr1 = next_test_ip4();\n         let addr2 = next_test_ip4();\n         let mut a = UdpSocket::bind(addr1).unwrap();\n@@ -596,5 +612,5 @@ mod test {\n                 Err(e) => fail!(\"other error: {}\", e),\n             }\n         }\n-    })\n+    }\n }"}, {"sha": "d7d478bd458c8b37e6bd94738cad3aee1acb0b45", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -118,7 +118,11 @@ impl Writer for PipeStream {\n \n #[cfg(test)]\n mod test {\n-    iotest!(fn partial_read() {\n+    use super::*;\n+    use prelude::*;\n+\n+    #[test]\n+    fn partial_read() {\n         use os;\n         use io::pipe::PipeStream;\n \n@@ -135,5 +139,5 @@ mod test {\n         let mut buf = [0, ..10];\n         input.read(buf).unwrap();\n         tx.send(());\n-    })\n+    }\n }"}, {"sha": "5220e5c984ab71fd2547c74d2f3bdf3e67a9214b", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 107, "deletions": 66, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -662,47 +662,60 @@ impl Drop for Process {\n \n #[cfg(test)]\n mod tests {\n+    #![allow(unused_imports)]\n+\n     extern crate native;\n-    use io::process::{Command, Process};\n+\n+    use super::*;\n     use prelude::*;\n+    use io::timer::*;\n+    use io::*;\n+    use io::fs::PathExtensions;\n+    use time::Duration;\n+    use str;\n+    use rt::running_on_valgrind;\n \n     // FIXME(#10380) these tests should not all be ignored on android.\n \n     #[cfg(not(target_os=\"android\"))]\n-    iotest!(fn smoke() {\n+    #[test]\n+    fn smoke() {\n         let p = Command::new(\"true\").spawn();\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.wait().unwrap().success());\n-    })\n+    }\n \n     #[cfg(not(target_os=\"android\"))]\n-    iotest!(fn smoke_failure() {\n+    #[test]\n+    fn smoke_failure() {\n         match Command::new(\"if-this-is-a-binary-then-the-world-has-ended\").spawn() {\n             Ok(..) => fail!(),\n             Err(..) => {}\n         }\n-    })\n+    }\n \n     #[cfg(not(target_os=\"android\"))]\n-    iotest!(fn exit_reported_right() {\n+    #[test]\n+    fn exit_reported_right() {\n         let p = Command::new(\"false\").spawn();\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.wait().unwrap().matches_exit_status(1));\n         drop(p.wait().clone());\n-    })\n+    }\n \n     #[cfg(all(unix, not(target_os=\"android\")))]\n-    iotest!(fn signal_reported_right() {\n+    #[test]\n+    fn signal_reported_right() {\n         let p = Command::new(\"/bin/sh\").arg(\"-c\").arg(\"kill -1 $$\").spawn();\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n         match p.wait().unwrap() {\n             process::ExitSignal(1) => {},\n             result => fail!(\"not terminated by signal 1 (instead, {})\", result),\n         }\n-    })\n+    }\n \n     pub fn read_all(input: &mut Reader) -> String {\n         input.read_to_string().unwrap()\n@@ -719,23 +732,26 @@ mod tests {\n     }\n \n     #[cfg(not(target_os=\"android\"))]\n-    iotest!(fn stdout_works() {\n+    #[test]\n+    fn stdout_works() {\n         let mut cmd = Command::new(\"echo\");\n         cmd.arg(\"foobar\").stdout(CreatePipe(false, true));\n         assert_eq!(run_output(cmd), \"foobar\\n\".to_string());\n-    })\n+    }\n \n     #[cfg(all(unix, not(target_os=\"android\")))]\n-    iotest!(fn set_cwd_works() {\n+    #[test]\n+    fn set_cwd_works() {\n         let mut cmd = Command::new(\"/bin/sh\");\n         cmd.arg(\"-c\").arg(\"pwd\")\n            .cwd(&Path::new(\"/\"))\n            .stdout(CreatePipe(false, true));\n         assert_eq!(run_output(cmd), \"/\\n\".to_string());\n-    })\n+    }\n \n     #[cfg(all(unix, not(target_os=\"android\")))]\n-    iotest!(fn stdin_works() {\n+    #[test]\n+    fn stdin_works() {\n         let mut p = Command::new(\"/bin/sh\")\n                             .arg(\"-c\").arg(\"read line; echo $line\")\n                             .stdin(CreatePipe(true, false))\n@@ -746,58 +762,65 @@ mod tests {\n         let out = read_all(p.stdout.get_mut_ref() as &mut Reader);\n         assert!(p.wait().unwrap().success());\n         assert_eq!(out, \"foobar\\n\".to_string());\n-    })\n+    }\n \n     #[cfg(not(target_os=\"android\"))]\n-    iotest!(fn detach_works() {\n+    #[test]\n+    fn detach_works() {\n         let mut p = Command::new(\"true\").detached().spawn().unwrap();\n         assert!(p.wait().unwrap().success());\n-    })\n+    }\n \n     #[cfg(windows)]\n-    iotest!(fn uid_fails_on_windows() {\n+    #[test]\n+    fn uid_fails_on_windows() {\n         assert!(Command::new(\"test\").uid(10).spawn().is_err());\n-    })\n+    }\n \n     #[cfg(all(unix, not(target_os=\"android\")))]\n-    iotest!(fn uid_works() {\n+    #[test]\n+    fn uid_works() {\n         use libc;\n         let mut p = Command::new(\"/bin/sh\")\n                             .arg(\"-c\").arg(\"true\")\n                             .uid(unsafe { libc::getuid() as uint })\n                             .gid(unsafe { libc::getgid() as uint })\n                             .spawn().unwrap();\n         assert!(p.wait().unwrap().success());\n-    })\n+    }\n \n     #[cfg(all(unix, not(target_os=\"android\")))]\n-    iotest!(fn uid_to_root_fails() {\n+    #[test]\n+    fn uid_to_root_fails() {\n         use libc;\n \n         // if we're already root, this isn't a valid test. Most of the bots run\n         // as non-root though (android is an exception).\n         if unsafe { libc::getuid() == 0 } { return }\n         assert!(Command::new(\"/bin/ls\").uid(0).gid(0).spawn().is_err());\n-    })\n+    }\n \n     #[cfg(not(target_os=\"android\"))]\n-    iotest!(fn test_process_status() {\n+    #[test]\n+    fn test_process_status() {\n         let mut status = Command::new(\"false\").status().unwrap();\n         assert!(status.matches_exit_status(1));\n \n         status = Command::new(\"true\").status().unwrap();\n         assert!(status.success());\n-    })\n+    }\n \n-    iotest!(fn test_process_output_fail_to_start() {\n+    #[test]\n+    fn test_process_output_fail_to_start() {\n         match Command::new(\"/no-binary-by-this-name-should-exist\").output() {\n             Err(e) => assert_eq!(e.kind, FileNotFound),\n             Ok(..) => fail!()\n         }\n-    })\n+    }\n \n     #[cfg(not(target_os=\"android\"))]\n-    iotest!(fn test_process_output_output() {\n+    #[test]\n+    fn test_process_output_output() {\n         let ProcessOutput {status, output, error}\n              = Command::new(\"echo\").arg(\"hello\").output().unwrap();\n         let output_str = str::from_utf8(output.as_slice()).unwrap();\n@@ -808,33 +831,37 @@ mod tests {\n         if !running_on_valgrind() {\n             assert_eq!(error, Vec::new());\n         }\n-    })\n+    }\n \n     #[cfg(not(target_os=\"android\"))]\n-    iotest!(fn test_process_output_error() {\n+    #[test]\n+    fn test_process_output_error() {\n         let ProcessOutput {status, output, error}\n              = Command::new(\"mkdir\").arg(\".\").output().unwrap();\n \n         assert!(status.matches_exit_status(1));\n         assert_eq!(output, Vec::new());\n         assert!(!error.is_empty());\n-    })\n+    }\n \n     #[cfg(not(target_os=\"android\"))]\n-    iotest!(fn test_finish_once() {\n+    #[test]\n+    fn test_finish_once() {\n         let mut prog = Command::new(\"false\").spawn().unwrap();\n         assert!(prog.wait().unwrap().matches_exit_status(1));\n-    })\n+    }\n \n     #[cfg(not(target_os=\"android\"))]\n-    iotest!(fn test_finish_twice() {\n+    #[test]\n+    fn test_finish_twice() {\n         let mut prog = Command::new(\"false\").spawn().unwrap();\n         assert!(prog.wait().unwrap().matches_exit_status(1));\n         assert!(prog.wait().unwrap().matches_exit_status(1));\n-    })\n+    }\n \n     #[cfg(not(target_os=\"android\"))]\n-    iotest!(fn test_wait_with_output_once() {\n+    #[test]\n+    fn test_wait_with_output_once() {\n         let prog = Command::new(\"echo\").arg(\"hello\").spawn().unwrap();\n         let ProcessOutput {status, output, error} = prog.wait_with_output().unwrap();\n         let output_str = str::from_utf8(output.as_slice()).unwrap();\n@@ -845,7 +872,7 @@ mod tests {\n         if !running_on_valgrind() {\n             assert_eq!(error, Vec::new());\n         }\n-    })\n+    }\n \n     #[cfg(all(unix, not(target_os=\"android\")))]\n     pub fn pwd_cmd() -> Command {\n@@ -865,7 +892,8 @@ mod tests {\n         cmd\n     }\n \n-    iotest!(fn test_keep_current_working_dir() {\n+    #[test]\n+    fn test_keep_current_working_dir() {\n         use os;\n         let prog = pwd_cmd().spawn().unwrap();\n \n@@ -878,9 +906,10 @@ mod tests {\n \n         assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n         assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n-    })\n+    }\n \n-    iotest!(fn test_change_working_directory() {\n+    #[test]\n+    fn test_change_working_directory() {\n         use os;\n         // test changing to the parent of os::getcwd() because we know\n         // the path exists (and os::getcwd() is not expected to be root)\n@@ -895,7 +924,7 @@ mod tests {\n \n         assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n         assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n-    })\n+    }\n \n     #[cfg(all(unix, not(target_os=\"android\")))]\n     pub fn env_cmd() -> Command {\n@@ -916,7 +945,8 @@ mod tests {\n     }\n \n     #[cfg(not(target_os=\"android\"))]\n-    iotest!(fn test_inherit_env() {\n+    #[test]\n+    fn test_inherit_env() {\n         use os;\n         if running_on_valgrind() { return; }\n \n@@ -930,9 +960,10 @@ mod tests {\n                     output.as_slice()\n                           .contains(format!(\"{}={}\", *k, *v).as_slice()));\n         }\n-    })\n+    }\n     #[cfg(target_os=\"android\")]\n-    iotest!(fn test_inherit_env() {\n+    #[test]\n+    fn test_inherit_env() {\n         use os;\n         if running_on_valgrind() { return; }\n \n@@ -953,9 +984,10 @@ mod tests {\n                                                 *v).as_slice()));\n             }\n         }\n-    })\n+    }\n \n-    iotest!(fn test_override_env() {\n+    #[test]\n+    fn test_override_env() {\n         use os;\n         let mut new_env = vec![(\"RUN_TEST_NEW_ENV\", \"123\")];\n \n@@ -978,18 +1010,20 @@ mod tests {\n \n         assert!(output.as_slice().contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n-    })\n+    }\n \n-    iotest!(fn test_add_to_env() {\n+    #[test]\n+    fn test_add_to_env() {\n         let prog = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").spawn().unwrap();\n         let result = prog.wait_with_output().unwrap();\n         let output = str::from_utf8_lossy(result.output.as_slice()).into_string();\n \n         assert!(output.as_slice().contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n-    })\n+    }\n \n-    iotest!(fn test_remove_from_env() {\n+    #[test]\n+    fn test_remove_from_env() {\n         use os;\n \n         // save original environment\n@@ -1012,7 +1046,7 @@ mod tests {\n \n         assert!(!output.as_slice().contains(\"RUN_TEST_NEW_ENV\"),\n                 \"found RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n-    })\n+    }\n \n     #[cfg(unix)]\n     pub fn sleeper() -> Process {\n@@ -1026,20 +1060,23 @@ mod tests {\n         Command::new(\"ping\").arg(\"127.0.0.1\").arg(\"-n\").arg(\"1000\").spawn().unwrap()\n     }\n \n-    iotest!(fn test_kill() {\n+    #[test]\n+    fn test_kill() {\n         let mut p = sleeper();\n         Process::kill(p.id(), PleaseExitSignal).unwrap();\n         assert!(!p.wait().unwrap().success());\n-    })\n+    }\n \n-    iotest!(fn test_exists() {\n+    #[test]\n+    fn test_exists() {\n         let mut p = sleeper();\n         assert!(Process::kill(p.id(), 0).is_ok());\n         p.signal_kill().unwrap();\n         assert!(!p.wait().unwrap().success());\n-    })\n+    }\n \n-    iotest!(fn test_zero() {\n+    #[test]\n+    fn test_zero() {\n         let mut p = sleeper();\n         p.signal_kill().unwrap();\n         for _ in range(0i, 20) {\n@@ -1050,19 +1087,21 @@ mod tests {\n             timer::sleep(Duration::milliseconds(100));\n         }\n         fail!(\"never saw the child go away\");\n-    })\n+    }\n \n-    iotest!(fn wait_timeout() {\n+    #[test]\n+    fn wait_timeout() {\n         let mut p = sleeper();\n         p.set_timeout(Some(10));\n         assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n         assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n         p.signal_kill().unwrap();\n         p.set_timeout(None);\n         assert!(p.wait().is_ok());\n-    })\n+    }\n \n-    iotest!(fn wait_timeout2() {\n+    #[test]\n+    fn wait_timeout2() {\n         let (tx, rx) = channel();\n         let tx2 = tx.clone();\n         spawn(proc() {\n@@ -1081,19 +1120,21 @@ mod tests {\n         });\n         rx.recv();\n         rx.recv();\n-    })\n+    }\n \n-    iotest!(fn forget() {\n+    #[test]\n+    fn forget() {\n         let p = sleeper();\n         let id = p.id();\n         p.forget();\n         assert!(Process::kill(id, 0).is_ok());\n         assert!(Process::kill(id, PleaseExitSignal).is_ok());\n-    })\n+    }\n \n-    iotest!(fn dont_close_fd_on_command_spawn() {\n+    #[test]\n+    fn dont_close_fd_on_command_spawn() {\n         use std::rt::rtio::{Truncate, Write};\n-        use native::io::file;\n+        use self::native::io::file;\n \n         let path = if cfg!(windows) {\n             Path::new(\"NUL\")\n@@ -1110,7 +1151,7 @@ mod tests {\n         let _ = cmd.stdout(InheritFd(fdes.fd()));\n         assert!(cmd.status().unwrap().success());\n         assert!(fdes.inner_write(\"extra write\\n\".as_bytes()).is_ok());\n-    })\n+    }\n \n     #[test]\n     #[cfg(windows)]"}, {"sha": "b174f19f19822d70ae41b232363da7cd2f9d4347", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -382,14 +382,17 @@ impl Writer for StdWriter {\n \n #[cfg(test)]\n mod tests {\n-    iotest!(fn smoke() {\n+    use super::*;\n+    use prelude::*;\n+\n+    fn smoke() {\n         // Just make sure we can acquire handles\n         stdin();\n         stdout();\n         stderr();\n-    })\n+    }\n \n-    iotest!(fn capture_stdout() {\n+    fn capture_stdout() {\n         use io::{ChanReader, ChanWriter};\n \n         let (tx, rx) = channel();\n@@ -399,9 +402,9 @@ mod tests {\n             println!(\"hello!\");\n         });\n         assert_eq!(r.read_to_string().unwrap(), \"hello!\\n\".to_string());\n-    })\n+    }\n \n-    iotest!(fn capture_stderr() {\n+    fn capture_stderr() {\n         use realstd::comm::channel;\n         use realstd::io::{Writer, ChanReader, ChanWriter, Reader};\n \n@@ -413,5 +416,5 @@ mod tests {\n         });\n         let s = r.read_to_string().unwrap();\n         assert!(s.as_slice().contains(\"my special message\"));\n-    })\n+    }\n }"}, {"sha": "1a47e20f5858083964fa85265a4d100185be21ec", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -18,42 +18,6 @@ use prelude::*;\n use std::io::net::ip::*;\n use sync::atomic::{AtomicUint, INIT_ATOMIC_UINT, Relaxed};\n \n-macro_rules! iotest (\n-    { fn $name:ident() $b:block $(#[$a:meta])* } => (\n-        mod $name {\n-            #![allow(unused_imports)]\n-\n-            use super::super::*;\n-            use super::*;\n-            use io;\n-            use prelude::*;\n-            use io::*;\n-            use io::fs::*;\n-            use io::test::*;\n-            use io::net::tcp::*;\n-            use io::net::ip::*;\n-            use io::net::udp::*;\n-            #[cfg(unix)]\n-            use io::net::pipe::*;\n-            use io::timer::*;\n-            use io::process::*;\n-            use rt::running_on_valgrind;\n-            use str;\n-            use time::Duration;\n-\n-            fn f() $b\n-\n-            $(#[$a])* #[test] fn green() { f() }\n-            $(#[$a])* #[test] fn native() {\n-                use native;\n-                let (tx, rx) = channel();\n-                native::task::spawn(proc() { tx.send(f()) });\n-                rx.recv();\n-            }\n-        }\n-    )\n-)\n-\n /// Get a port number, starting at 9600, for use in tests\n pub fn next_test_port() -> u16 {\n     static mut next_offset: AtomicUint = INIT_ATOMIC_UINT;"}, {"sha": "55d4073154eeaa3deface073070643ff003f658f", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 94, "deletions": 57, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -232,55 +232,70 @@ fn in_ms_u64(d: Duration) -> u64 {\n \n #[cfg(test)]\n mod test {\n-    iotest!(fn test_io_timer_sleep_simple() {\n+    use super::*;\n+    use time::Duration;\n+    use task::spawn;\n+    use io::*;\n+    use prelude::*;\n+\n+    #[test]\n+    fn test_io_timer_sleep_simple() {\n         let mut timer = Timer::new().unwrap();\n         timer.sleep(Duration::milliseconds(1));\n-    })\n+    }\n \n-    iotest!(fn test_io_timer_sleep_oneshot() {\n+    #[test]\n+    fn test_io_timer_sleep_oneshot() {\n         let mut timer = Timer::new().unwrap();\n         timer.oneshot(Duration::milliseconds(1)).recv();\n-    })\n+    }\n \n-    iotest!(fn test_io_timer_sleep_oneshot_forget() {\n+    #[test]\n+    fn test_io_timer_sleep_oneshot_forget() {\n         let mut timer = Timer::new().unwrap();\n         timer.oneshot(Duration::milliseconds(100000000));\n-    })\n+    }\n \n-    iotest!(fn oneshot_twice() {\n+    #[test]\n+    fn oneshot_twice() {\n         let mut timer = Timer::new().unwrap();\n         let rx1 = timer.oneshot(Duration::milliseconds(10000));\n         let rx = timer.oneshot(Duration::milliseconds(1));\n         rx.recv();\n         assert_eq!(rx1.recv_opt(), Err(()));\n-    })\n+    }\n \n-    iotest!(fn test_io_timer_oneshot_then_sleep() {\n+    #[test]\n+    fn test_io_timer_oneshot_then_sleep() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.oneshot(Duration::milliseconds(100000000));\n         timer.sleep(Duration::milliseconds(1)); // this should invalidate rx\n \n         assert_eq!(rx.recv_opt(), Err(()));\n-    })\n+    }\n \n-    iotest!(fn test_io_timer_sleep_periodic() {\n+    #[test]\n+    fn test_io_timer_sleep_periodic() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.periodic(Duration::milliseconds(1));\n         rx.recv();\n         rx.recv();\n         rx.recv();\n-    })\n+    }\n \n-    iotest!(fn test_io_timer_sleep_periodic_forget() {\n+    #[test]\n+    fn test_io_timer_sleep_periodic_forget() {\n         let mut timer = Timer::new().unwrap();\n         timer.periodic(Duration::milliseconds(100000000));\n-    })\n+    }\n \n-    iotest!(fn test_io_timer_sleep_standalone() {\n-        sleep(Duration::milliseconds(1))\n-    })\n+    #[test]\n+    fn test_io_timer_sleep_standalone() {\n+        super::sleep(Duration::milliseconds(1))\n+    }\n \n-    iotest!(fn oneshot() {\n+    #[test]\n+    fn oneshot() {\n         let mut timer = Timer::new().unwrap();\n \n         let rx = timer.oneshot(Duration::milliseconds(1));\n@@ -290,52 +305,62 @@ mod test {\n         let rx = timer.oneshot(Duration::milliseconds(1));\n         rx.recv();\n         assert!(rx.recv_opt().is_err());\n-    })\n+    }\n \n-    iotest!(fn override() {\n+    #[test]\n+    fn override() {\n         let mut timer = Timer::new().unwrap();\n         let orx = timer.oneshot(Duration::milliseconds(100));\n         let prx = timer.periodic(Duration::milliseconds(100));\n         timer.sleep(Duration::milliseconds(1));\n         assert_eq!(orx.recv_opt(), Err(()));\n         assert_eq!(prx.recv_opt(), Err(()));\n         timer.oneshot(Duration::milliseconds(1)).recv();\n-    })\n+    }\n \n-    iotest!(fn period() {\n+    #[test]\n+    fn period() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.periodic(Duration::milliseconds(1));\n         rx.recv();\n         rx.recv();\n         let rx2 = timer.periodic(Duration::milliseconds(1));\n         rx2.recv();\n         rx2.recv();\n-    })\n+    }\n \n-    iotest!(fn sleep() {\n+    #[test]\n+    fn sleep() {\n         let mut timer = Timer::new().unwrap();\n         timer.sleep(Duration::milliseconds(1));\n         timer.sleep(Duration::milliseconds(1));\n-    })\n+    }\n \n-    iotest!(fn oneshot_fail() {\n+    #[test]\n+    #[should_fail]\n+    fn oneshot_fail() {\n         let mut timer = Timer::new().unwrap();\n         let _rx = timer.oneshot(Duration::milliseconds(1));\n         fail!();\n-    } #[should_fail])\n+    }\n \n-    iotest!(fn period_fail() {\n+    #[test]\n+    #[should_fail]\n+    fn period_fail() {\n         let mut timer = Timer::new().unwrap();\n         let _rx = timer.periodic(Duration::milliseconds(1));\n         fail!();\n-    } #[should_fail])\n+    }\n \n-    iotest!(fn normal_fail() {\n+    #[test]\n+    #[should_fail]\n+    fn normal_fail() {\n         let _timer = Timer::new().unwrap();\n         fail!();\n-    } #[should_fail])\n+    }\n \n-    iotest!(fn closing_channel_during_drop_doesnt_kill_everything() {\n+    #[test]\n+    fn closing_channel_during_drop_doesnt_kill_everything() {\n         // see issue #10375\n         let mut timer = Timer::new().unwrap();\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n@@ -346,9 +371,10 @@ mod test {\n \n         // when we drop the TimerWatcher we're going to destroy the channel,\n         // which must wake up the task on the other end\n-    })\n+    }\n \n-    iotest!(fn reset_doesnt_switch_tasks() {\n+    #[test]\n+    fn reset_doesnt_switch_tasks() {\n         // similar test to the one above.\n         let mut timer = Timer::new().unwrap();\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n@@ -358,9 +384,10 @@ mod test {\n         });\n \n         timer.oneshot(Duration::milliseconds(1));\n-    })\n+    }\n \n-    iotest!(fn reset_doesnt_switch_tasks2() {\n+    #[test]\n+    fn reset_doesnt_switch_tasks2() {\n         // similar test to the one above.\n         let mut timer = Timer::new().unwrap();\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n@@ -370,80 +397,90 @@ mod test {\n         });\n \n         timer.sleep(Duration::milliseconds(1));\n-    })\n+    }\n \n-    iotest!(fn sender_goes_away_oneshot() {\n+    #[test]\n+    fn sender_goes_away_oneshot() {\n         let rx = {\n             let mut timer = Timer::new().unwrap();\n             timer.oneshot(Duration::milliseconds(1000))\n         };\n         assert_eq!(rx.recv_opt(), Err(()));\n-    })\n+    }\n \n-    iotest!(fn sender_goes_away_period() {\n+    #[test]\n+    fn sender_goes_away_period() {\n         let rx = {\n             let mut timer = Timer::new().unwrap();\n             timer.periodic(Duration::milliseconds(1000))\n         };\n         assert_eq!(rx.recv_opt(), Err(()));\n-    })\n+    }\n \n-    iotest!(fn receiver_goes_away_oneshot() {\n+    #[test]\n+    fn receiver_goes_away_oneshot() {\n         let mut timer1 = Timer::new().unwrap();\n         timer1.oneshot(Duration::milliseconds(1));\n         let mut timer2 = Timer::new().unwrap();\n         // while sleeping, the previous timer should fire and not have its\n         // callback do something terrible.\n         timer2.sleep(Duration::milliseconds(2));\n-    })\n+    }\n \n-    iotest!(fn receiver_goes_away_period() {\n+    #[test]\n+    fn receiver_goes_away_period() {\n         let mut timer1 = Timer::new().unwrap();\n         timer1.periodic(Duration::milliseconds(1));\n         let mut timer2 = Timer::new().unwrap();\n         // while sleeping, the previous timer should fire and not have its\n         // callback do something terrible.\n         timer2.sleep(Duration::milliseconds(2));\n-    })\n+    }\n \n-    iotest!(fn sleep_zero() {\n+    #[test]\n+    fn sleep_zero() {\n         let mut timer = Timer::new().unwrap();\n         timer.sleep(Duration::milliseconds(0));\n-    })\n+    }\n \n-    iotest!(fn sleep_negative() {\n+    #[test]\n+    fn sleep_negative() {\n         let mut timer = Timer::new().unwrap();\n         timer.sleep(Duration::milliseconds(-1000000));\n-    })\n+    }\n \n-    iotest!(fn oneshot_zero() {\n+    #[test]\n+    fn oneshot_zero() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.oneshot(Duration::milliseconds(0));\n         rx.recv();\n-    })\n+    }\n \n-    iotest!(fn oneshot_negative() {\n+    #[test]\n+    fn oneshot_negative() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.oneshot(Duration::milliseconds(-1000000));\n         rx.recv();\n-    })\n+    }\n \n-    iotest!(fn periodic_zero() {\n+    #[test]\n+    fn periodic_zero() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.periodic(Duration::milliseconds(0));\n         rx.recv();\n         rx.recv();\n         rx.recv();\n         rx.recv();\n-    })\n+    }\n \n-    iotest!(fn periodic_negative() {\n+    #[test]\n+    fn periodic_negative() {\n         let mut timer = Timer::new().unwrap();\n         let rx = timer.periodic(Duration::milliseconds(-1000000));\n         rx.recv();\n         rx.recv();\n         rx.recv();\n         rx.recv();\n-    })\n+    }\n \n }"}, {"sha": "6aaf91dee16c99ab89fe870f9cedcfe82ea92341", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -20,12 +20,8 @@\n \n extern crate libc;\n \n-extern crate native;\n-\n use std::io::{Process, Command, timer};\n use std::time::Duration;\n-\n-use libc;\n use std::str;\n \n macro_rules! succeed( ($e:expr) => ("}, {"sha": "c3aba9e8dc954e6f4ac2b60a3aa816b3ff07b870", "filename": "src/test/run-pass/issue-12684.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Ftest%2Frun-pass%2Fissue-12684.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Ftest%2Frun-pass%2Fissue-12684.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12684.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -11,7 +11,7 @@\n use std::time::Duration;\n \n fn main() {\n-    native::task::spawn(proc() customtask());\n+    std::task::spawn(proc() customtask());\n }\n \n fn customtask() {"}, {"sha": "569d4acb4c610c2087250698b75d7e64c33cfd3c", "filename": "src/test/run-pass/process-detach.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-detach.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-windows\n-// ignore-android\n+// ignore-test\n+\n+// FIXME: this test is being ignored until signals are implemented\n \n // This test ensures that the 'detach' field on processes does the right thing.\n // By detaching the child process, they should be put into a separate process"}, {"sha": "e186f63e0a45e00f357682a8bbc3b3e1f4e1c447", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15966c3c1f99810ac81053769651776a67181dae/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15966c3c1f99810ac81053769651776a67181dae/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=15966c3c1f99810ac81053769651776a67181dae", "patch": "@@ -30,17 +30,13 @@ use std::time::Duration;\n \n #[cfg_attr(target_os = \"freebsd\", ignore)]\n fn eventual_timeout() {\n-    use native;\n     let addr = next_test_ip4();\n     let host = addr.ip.to_string();\n     let port = addr.port;\n \n-    // Use a native task to receive connections because it turns out libuv is\n-    // really good at accepting connections and will likely run out of file\n-    // descriptors before timing out.\n     let (tx1, rx1) = channel();\n     let (_tx2, rx2) = channel::<()>();\n-    native::task::spawn(proc() {\n+    std::task::spawn(proc() {\n         let _l = TcpListener::bind(host.as_slice(), port).unwrap().listen();\n         tx1.send(());\n         let _ = rx2.recv_opt();"}]}