{"sha": "7cb74ed1917cc982830d6b7b7bac7e8a7f4d271c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjYjc0ZWQxOTE3Y2M5ODI4MzBkNmI3YjdiYWM3ZThhN2Y0ZDI3MWM=", "commit": {"author": {"name": "Tunahan Karlibas", "email": "dvt.tnhn.krlbs@gmail.com", "date": "2020-12-08T22:17:02Z"}, "committer": {"name": "Tunahan Karlibas", "email": "dvt.tnhn.krlbs@gmail.com", "date": "2020-12-08T22:17:02Z"}, "message": "Remove memoization leftovers\ncloses #79667", "tree": {"sha": "fc869670533670be3f08da87e21d7ee27f7ef3bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc869670533670be3f08da87e21d7ee27f7ef3bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cb74ed1917cc982830d6b7b7bac7e8a7f4d271c", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEjRc1/OFrtBrFGXTf7MSWjcnUU94FAl/P+3QACgkQ7MSWjcnU\nU943FBAAtwxqebsAp16bb3uB2KVS8BriCg9UqoqQH7whrmrbjUqnaP48MoywWLjM\n9F0vgbyjnogMlXiINq+TRGS+hJ3e8lPZ+GLQbuO3O0QN/Nk1PWm2oRPNSB6T7YSi\nRguk9ROiXz3YXeymxwTvADX7IVuqX2sdF8IaVTu9ljFej1oNbY5qACU2QxMBxaOs\nFDGRjFGnn1ZRscv0KxUGL7zFEfC/xh2Su+ZJI4QTN8S0iSosUHjwMASYqA5rUnQN\n2UGGBp9W5IpDuahWQYplgAJThwQ5GTjGx1j+rW3wi7D58mTfljbmwsBbODYjoDON\nZ1A4Fx6Go6TSrfmLublKm3LPEFpthzskWyyUSwQDxqSjzpUkCyDp4OawvlHsjbR4\nyvfqDhcXAGxRlrkeDIY40VnLse5H5EziFStVcpIioiC6BRoW2kWXhixxlAW4xmTJ\nHvFhjwNP4S+9XzeQcj6xy/H6DyJ+i8Uh1kb1RcZVVLHPp//mojPILLHcU5J8knxV\nG/krLt46k6nm8gApVKddH6iLI6fzwF5RBErvVXxYjL0LnZcVIDRTlwSzX0XjVW4m\nnwqLWtjaEVdgzHG2QCePV+SIFppBCRLwc4skoY0BTNdnvSk+2LfcPnP1wez+JJxn\nloh5hfHoX0b0yZNnWtOuqEqnG1Xk/KrVPhK6dqUdmOYWyk+NskA=\n=i1lw\n-----END PGP SIGNATURE-----", "payload": "tree fc869670533670be3f08da87e21d7ee27f7ef3bb\nparent 5e6e1e33a11d140a4d70f946730137f241224eb3\nauthor Tunahan Karlibas <dvt.tnhn.krlbs@gmail.com> 1607465822 +0300\ncommitter Tunahan Karlibas <dvt.tnhn.krlbs@gmail.com> 1607465822 +0300\n\nRemove memoization leftovers\ncloses #79667\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cb74ed1917cc982830d6b7b7bac7e8a7f4d271c", "html_url": "https://github.com/rust-lang/rust/commit/7cb74ed1917cc982830d6b7b7bac7e8a7f4d271c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cb74ed1917cc982830d6b7b7bac7e8a7f4d271c/comments", "author": null, "committer": null, "parents": [{"sha": "5e6e1e33a11d140a4d70f946730137f241224eb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e6e1e33a11d140a4d70f946730137f241224eb3", "html_url": "https://github.com/rust-lang/rust/commit/5e6e1e33a11d140a4d70f946730137f241224eb3"}], "stats": {"total": 63, "additions": 4, "deletions": 59}, "files": [{"sha": "cc5f5dda7d495d103fba5937307fca226ebd6d21", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 4, "deletions": 59, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7cb74ed1917cc982830d6b7b7bac7e8a7f4d271c/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cb74ed1917cc982830d6b7b7bac7e8a7f4d271c/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=7cb74ed1917cc982830d6b7b7bac7e8a7f4d271c", "patch": "@@ -1,6 +1,4 @@\n use rustc_middle::mir;\n-use rustc_middle::ty::layout::HasTyCtxt;\n-use rustc_middle::ty::InstanceDef;\n use rustc_middle::ty::{self, Ty};\n use std::borrow::Borrow;\n use std::collections::hash_map::Entry;\n@@ -17,60 +15,13 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_target::abi::{Align, Size};\n \n use crate::interpret::{\n-    self, compile_time_machine, AllocId, Allocation, Frame, GlobalId, ImmTy, InterpCx,\n-    InterpResult, Memory, OpTy, PlaceTy, Pointer, Scalar,\n+    self, compile_time_machine, AllocId, Allocation, Frame, ImmTy, InterpCx, InterpResult, Memory,\n+    OpTy, PlaceTy, Pointer, Scalar,\n };\n \n use super::error::*;\n \n impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n-    /// Evaluate a const function where all arguments (if any) are zero-sized types.\n-    /// The evaluation is memoized thanks to the query system.\n-    ///\n-    /// Returns `true` if the call has been evaluated.\n-    fn try_eval_const_fn_call(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n-        args: &[OpTy<'tcx>],\n-    ) -> InterpResult<'tcx, bool> {\n-        trace!(\"try_eval_const_fn_call: {:?}\", instance);\n-        // Because `#[track_caller]` adds an implicit non-ZST argument, we also cannot\n-        // perform this optimization on items tagged with it.\n-        if instance.def.requires_caller_location(self.tcx()) {\n-            return Ok(false);\n-        }\n-        // Only memoize instrinsics. This was added in #79594 while adding the `const_allocate` intrinsic.\n-        // We only memoize intrinsics because it would be unsound to memoize functions\n-        // which might interact with the heap.\n-        // Additionally, const_allocate intrinsic is impure and thus should not be memoized;\n-        // it will not be memoized because it has non-ZST args\n-        if !matches!(instance.def, InstanceDef::Intrinsic(_)) {\n-            return Ok(false);\n-        }\n-        // For the moment we only do this for functions which take no arguments\n-        // (or all arguments are ZSTs) so that we don't memoize too much.\n-        if args.iter().any(|a| !a.layout.is_zst()) {\n-            return Ok(false);\n-        }\n-\n-        let dest = match ret {\n-            Some((dest, _)) => dest,\n-            // Don't memoize diverging function calls.\n-            None => return Ok(false),\n-        };\n-\n-        let gid = GlobalId { instance, promoted: None };\n-\n-        let place = self.eval_to_allocation(gid)?;\n-\n-        self.copy_op(place.into(), dest)?;\n-\n-        self.return_to_block(ret.map(|r| r.1))?;\n-        trace!(\"{:?}\", self.dump_place(*dest));\n-        Ok(true)\n-    }\n-\n     /// \"Intercept\" a function call to a panic-related function\n     /// because we have something special to do for it.\n     /// If this returns successfully (`Ok`), the function should just be evaluated normally.\n@@ -253,7 +204,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n-        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        _ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock>, // unwinding is not supported in consts\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n@@ -263,13 +214,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             // Execution might have wandered off into other crates, so we cannot do a stability-\n             // sensitive check here.  But we can at least rule out functions that are not const\n             // at all.\n-            if ecx.tcx.is_const_fn_raw(def.did) {\n-                // If this function is a `const fn` then under certain circumstances we\n-                // can evaluate call via the query system, thus memoizing all future calls.\n-                if ecx.try_eval_const_fn_call(instance, ret, args)? {\n-                    return Ok(None);\n-                }\n-            } else {\n+            if !ecx.tcx.is_const_fn_raw(def.did) {\n                 // Some functions we support even if they are non-const -- but avoid testing\n                 // that for const fn!\n                 ecx.hook_panic_fn(instance, args)?;"}]}