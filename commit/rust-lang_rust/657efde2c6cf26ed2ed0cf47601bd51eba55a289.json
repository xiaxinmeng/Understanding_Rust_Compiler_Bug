{"sha": "657efde2c6cf26ed2ed0cf47601bd51eba55a289", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1N2VmZGUyYzZjZjI2ZWQyZWQwY2Y0NzYwMWJkNTFlYmE1NWEyODk=", "commit": {"author": {"name": "Oliver Schneider", "email": "github6541940@oli-obk.de", "date": "2015-05-23T17:03:18Z"}, "committer": {"name": "Oliver Schneider", "email": "github6541940@oli-obk.de", "date": "2015-05-23T17:03:18Z"}, "message": "Rollup merge of #25687 - tamird:num-self-cleanup, r=Gankro\n\nCleanup extracted from #25684. r? @alexcrichton", "tree": {"sha": "85c7fbe8c073488564dcbb08f5a0bd96e0fa3a73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85c7fbe8c073488564dcbb08f5a0bd96e0fa3a73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/657efde2c6cf26ed2ed0cf47601bd51eba55a289", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/657efde2c6cf26ed2ed0cf47601bd51eba55a289", "html_url": "https://github.com/rust-lang/rust/commit/657efde2c6cf26ed2ed0cf47601bd51eba55a289", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/657efde2c6cf26ed2ed0cf47601bd51eba55a289/comments", "author": null, "committer": null, "parents": [{"sha": "0c74a73bd588c0a496b20f751a3b36f34210c69d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c74a73bd588c0a496b20f751a3b36f34210c69d", "html_url": "https://github.com/rust-lang/rust/commit/0c74a73bd588c0a496b20f751a3b36f34210c69d"}, {"sha": "cf11c261f0a1293a71ab0d579f4047525dbf8cef", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf11c261f0a1293a71ab0d579f4047525dbf8cef", "html_url": "https://github.com/rust-lang/rust/commit/cf11c261f0a1293a71ab0d579f4047525dbf8cef"}], "stats": {"total": 228, "additions": 114, "deletions": 114}, "files": [{"sha": "bf26022692d09362562d55c1a2d86bae11904d89", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 114, "deletions": 114, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/657efde2c6cf26ed2ed0cf47601bd51eba55a289/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/657efde2c6cf26ed2ed0cf47601bd51eba55a289/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=657efde2c6cf26ed2ed0cf47601bd51eba55a289", "patch": "@@ -73,11 +73,11 @@ macro_rules! zero_one_impl {\n     ($($t:ty)*) => ($(\n         impl Zero for $t {\n             #[inline]\n-            fn zero() -> $t { 0 }\n+            fn zero() -> Self { 0 }\n         }\n         impl One for $t {\n             #[inline]\n-            fn one() -> $t { 1 }\n+            fn one() -> Self { 1 }\n         }\n     )*)\n }\n@@ -87,20 +87,20 @@ macro_rules! zero_one_impl_float {\n     ($($t:ty)*) => ($(\n         impl Zero for $t {\n             #[inline]\n-            fn zero() -> $t { 0.0 }\n+            fn zero() -> Self { 0.0 }\n         }\n         impl One for $t {\n             #[inline]\n-            fn one() -> $t { 1.0 }\n+            fn one() -> Self { 1.0 }\n         }\n     )*)\n }\n zero_one_impl_float! { f32 f64 }\n \n macro_rules! checked_op {\n-    ($T:ty, $U:ty, $op:path, $x:expr, $y:expr) => {{\n+    ($U:ty, $op:path, $x:expr, $y:expr) => {{\n         let (result, overflowed) = unsafe { $op($x as $U, $y as $U) };\n-        if overflowed { None } else { Some(result as $T) }\n+        if overflowed { None } else { Some(result as Self) }\n     }}\n }\n \n@@ -110,22 +110,22 @@ unsafe fn bswap8(x: u8) -> u8 { x }\n \n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n-    ($T:ident = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n+    ($ActualT:ty, $UnsignedT:ty, $BITS:expr,\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n         /// Returns the smallest value that can be represented by this integer type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn min_value() -> $T {\n-            (-1 as $T) << ($BITS - 1)\n+        pub fn min_value() -> Self {\n+            (-1 as Self) << ($BITS - 1)\n         }\n \n         /// Returns the largest value that can be represented by this integer type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn max_value() -> $T {\n-            let min = $T::min_value(); !min\n+        pub fn max_value() -> Self {\n+            let min = Self::min_value(); !min\n         }\n \n         /// Converts a string slice in a given base to an integer.\n@@ -139,7 +139,7 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n-        pub fn from_str_radix(src: &str, radix: u32) -> Result<$T, ParseIntError> {\n+        pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n             from_str_radix(src, radix)\n         }\n \n@@ -216,8 +216,8 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn rotate_left(self, n: u32) -> $T {\n-            (self as $UnsignedT).rotate_left(n) as $T\n+        pub fn rotate_left(self, n: u32) -> Self {\n+            (self as $UnsignedT).rotate_left(n) as Self\n         }\n \n         /// Shifts the bits to the right by a specified amount, `n`,\n@@ -234,8 +234,8 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn rotate_right(self, n: u32) -> $T {\n-            (self as $UnsignedT).rotate_right(n) as $T\n+        pub fn rotate_right(self, n: u32) -> Self {\n+            (self as $UnsignedT).rotate_right(n) as Self\n         }\n \n         /// Reverses the byte order of the integer.\n@@ -250,8 +250,8 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn swap_bytes(self) -> $T {\n-            (self as $UnsignedT).swap_bytes() as $T\n+        pub fn swap_bytes(self) -> Self {\n+            (self as $UnsignedT).swap_bytes() as Self\n         }\n \n         /// Converts an integer from big endian to the target's endianness.\n@@ -272,7 +272,7 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn from_be(x: $T) -> $T {\n+        pub fn from_be(x: Self) -> Self {\n             if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n         }\n \n@@ -294,7 +294,7 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn from_le(x: $T) -> $T {\n+        pub fn from_le(x: Self) -> Self {\n             if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n         }\n \n@@ -316,7 +316,7 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn to_be(self) -> $T { // or not to be?\n+        pub fn to_be(self) -> Self { // or not to be?\n             if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n         }\n \n@@ -338,7 +338,7 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn to_le(self) -> $T {\n+        pub fn to_le(self) -> Self {\n             if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n         }\n \n@@ -353,8 +353,8 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_add(self, other: $T) -> Option<$T> {\n-            checked_op!($T, $ActualT, $add_with_overflow, self, other)\n+        pub fn checked_add(self, other: Self) -> Option<Self> {\n+            checked_op!($ActualT, $add_with_overflow, self, other)\n         }\n \n         /// Checked integer subtraction. Computes `self - other`, returning\n@@ -368,8 +368,8 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_sub(self, other: $T) -> Option<$T> {\n-            checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n+        pub fn checked_sub(self, other: Self) -> Option<Self> {\n+            checked_op!($ActualT, $sub_with_overflow, self, other)\n         }\n \n         /// Checked integer multiplication. Computes `self * other`, returning\n@@ -383,8 +383,8 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_mul(self, other: $T) -> Option<$T> {\n-            checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n+        pub fn checked_mul(self, other: Self) -> Option<Self> {\n+            checked_op!($ActualT, $mul_with_overflow, self, other)\n         }\n \n         /// Checked integer division. Computes `self / other`, returning `None`\n@@ -399,10 +399,10 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_div(self, v: $T) -> Option<$T> {\n+        pub fn checked_div(self, v: Self) -> Option<Self> {\n             match v {\n                 0   => None,\n-               -1 if self == <$T>::min_value()\n+               -1 if self == Self::min_value()\n                     => None,\n                 v   => Some(self / v),\n             }\n@@ -412,31 +412,31 @@ macro_rules! int_impl {\n         /// the numeric bounds instead of overflowing.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_add(self, other: $T) -> $T {\n+        pub fn saturating_add(self, other: Self) -> Self {\n             match self.checked_add(other) {\n                 Some(x)                       => x,\n-                None if other >= <$T as Zero>::zero() => <$T>::max_value(),\n-                None => <$T>::min_value(),\n+                None if other >= Self::zero() => Self::max_value(),\n+                None => Self::min_value(),\n             }\n         }\n \n         /// Saturating integer subtraction. Computes `self - other`, saturating\n         /// at the numeric bounds instead of overflowing.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_sub(self, other: $T) -> $T {\n+        pub fn saturating_sub(self, other: Self) -> Self {\n             match self.checked_sub(other) {\n                 Some(x)                      => x,\n-                None if other >= <$T as Zero>::zero() => <$T>::min_value(),\n-                None => <$T>::max_value(),\n+                None if other >= Self::zero() => Self::min_value(),\n+                None => Self::max_value(),\n             }\n         }\n \n         /// Wrapping (modular) addition. Computes `self + other`,\n         /// wrapping around at the boundary of the type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn wrapping_add(self, rhs: $T) -> $T {\n+        pub fn wrapping_add(self, rhs: Self) -> Self {\n             unsafe {\n                 intrinsics::overflowing_add(self, rhs)\n             }\n@@ -446,7 +446,7 @@ macro_rules! int_impl {\n         /// wrapping around at the boundary of the type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn wrapping_sub(self, rhs: $T) -> $T {\n+        pub fn wrapping_sub(self, rhs: Self) -> Self {\n             unsafe {\n                 intrinsics::overflowing_sub(self, rhs)\n             }\n@@ -456,7 +456,7 @@ macro_rules! int_impl {\n         /// other`, wrapping around at the boundary of the type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn wrapping_mul(self, rhs: $T) -> $T {\n+        pub fn wrapping_mul(self, rhs: Self) -> Self {\n             unsafe {\n                 intrinsics::overflowing_mul(self, rhs)\n             }\n@@ -473,7 +473,7 @@ macro_rules! int_impl {\n         /// itself..\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_div(self, rhs: $T) -> $T {\n+        pub fn wrapping_div(self, rhs: Self) -> Self {\n             self.overflowing_div(rhs).0\n         }\n \n@@ -486,7 +486,7 @@ macro_rules! int_impl {\n         /// minimal value). In such a case, this function returns `0`.\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_rem(self, rhs: $T) -> $T {\n+        pub fn wrapping_rem(self, rhs: Self) -> Self {\n             self.overflowing_rem(rhs).0\n         }\n \n@@ -500,7 +500,7 @@ macro_rules! int_impl {\n         /// a case, this function returns `MIN` itself.\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_neg(self) -> $T {\n+        pub fn wrapping_neg(self) -> Self {\n             self.overflowing_neg().0\n         }\n \n@@ -509,7 +509,7 @@ macro_rules! int_impl {\n         /// would cause the shift to exceed the bitwidth of the type.\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_shl(self, rhs: u32) -> $T {\n+        pub fn wrapping_shl(self, rhs: u32) -> Self {\n             self.overflowing_shl(rhs).0\n         }\n \n@@ -518,7 +518,7 @@ macro_rules! int_impl {\n         /// would cause the shift to exceed the bitwidth of the type.\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_shr(self, rhs: u32) -> $T {\n+        pub fn wrapping_shr(self, rhs: u32) -> Self {\n             self.overflowing_shr(rhs).0\n         }\n \n@@ -533,9 +533,9 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn pow(self, mut exp: u32) -> $T {\n+        pub fn pow(self, mut exp: u32) -> Self {\n             let mut base = self;\n-            let mut acc = <$T as One>::one();\n+            let mut acc = Self::one();\n \n             let mut prev_base = self;\n             let mut base_oflo = false;\n@@ -569,7 +569,7 @@ macro_rules! int_impl {\n         /// optimized code will return `i32::min_value()` without a panic.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn abs(self) -> $T {\n+        pub fn abs(self) -> Self {\n             if self.is_negative() {\n                 // Note that the #[inline] above means that the overflow\n                 // semantics of this negation depend on the crate we're being\n@@ -587,7 +587,7 @@ macro_rules! int_impl {\n         /// - `-1` if the number is negative\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn signum(self) -> $T {\n+        pub fn signum(self) -> Self {\n             match self {\n                 n if n > 0 =>  1,\n                 0          =>  0,\n@@ -611,31 +611,31 @@ macro_rules! int_impl {\n \n #[lang = \"i8\"]\n impl i8 {\n-    int_impl! { i8 = i8, u8, 8,\n+    int_impl! { i8, u8, 8,\n         intrinsics::i8_add_with_overflow,\n         intrinsics::i8_sub_with_overflow,\n         intrinsics::i8_mul_with_overflow }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n-    int_impl! { i16 = i16, u16, 16,\n+    int_impl! { i16, u16, 16,\n         intrinsics::i16_add_with_overflow,\n         intrinsics::i16_sub_with_overflow,\n         intrinsics::i16_mul_with_overflow }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n-    int_impl! { i32 = i32, u32, 32,\n+    int_impl! { i32, u32, 32,\n         intrinsics::i32_add_with_overflow,\n         intrinsics::i32_sub_with_overflow,\n         intrinsics::i32_mul_with_overflow }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n-    int_impl! { i64 = i64, u64, 64,\n+    int_impl! { i64, u64, 64,\n         intrinsics::i64_add_with_overflow,\n         intrinsics::i64_sub_with_overflow,\n         intrinsics::i64_mul_with_overflow }\n@@ -644,7 +644,7 @@ impl i64 {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize = i32, u32, 32,\n+    int_impl! { i32, u32, 32,\n         intrinsics::i32_add_with_overflow,\n         intrinsics::i32_sub_with_overflow,\n         intrinsics::i32_mul_with_overflow }\n@@ -653,15 +653,15 @@ impl isize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize = i64, u64, 64,\n+    int_impl! { i64, u64, 64,\n         intrinsics::i64_add_with_overflow,\n         intrinsics::i64_sub_with_overflow,\n         intrinsics::i64_mul_with_overflow }\n }\n \n // `Int` + `UnsignedInt` implemented for signed integers\n macro_rules! uint_impl {\n-    ($T:ty = $ActualT:ty, $BITS:expr,\n+    ($ActualT:ty, $BITS:expr,\n      $ctpop:path,\n      $ctlz:path,\n      $cttz:path,\n@@ -671,11 +671,11 @@ macro_rules! uint_impl {\n      $mul_with_overflow:path) => {\n         /// Returns the smallest value that can be represented by this integer type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        pub fn min_value() -> $T { 0 }\n+        pub fn min_value() -> Self { 0 }\n \n         /// Returns the largest value that can be represented by this integer type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        pub fn max_value() -> $T { !0 }\n+        pub fn max_value() -> Self { !0 }\n \n         /// Converts a string slice in a given base to an integer.\n         ///\n@@ -692,7 +692,7 @@ macro_rules! uint_impl {\n         /// Otherwise, `Ok(n)` where `n` is the integer represented by `src`.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n-        pub fn from_str_radix(src: &str, radix: u32) -> Result<$T, ParseIntError> {\n+        pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n             from_str_radix(src, radix)\n         }\n \n@@ -784,7 +784,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn rotate_left(self, n: u32) -> $T {\n+        pub fn rotate_left(self, n: u32) -> Self {\n             // Protect against undefined behaviour for over-long bit shifts\n             let n = n % $BITS;\n             (self << n) | (self >> (($BITS - n) % $BITS))\n@@ -804,7 +804,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn rotate_right(self, n: u32) -> $T {\n+        pub fn rotate_right(self, n: u32) -> Self {\n             // Protect against undefined behaviour for over-long bit shifts\n             let n = n % $BITS;\n             (self >> n) | (self << (($BITS - n) % $BITS))\n@@ -822,8 +822,8 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn swap_bytes(self) -> $T {\n-            unsafe { $bswap(self as $ActualT) as $T }\n+        pub fn swap_bytes(self) -> Self {\n+            unsafe { $bswap(self as $ActualT) as Self }\n         }\n \n         /// Converts an integer from big endian to the target's endianness.\n@@ -844,7 +844,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn from_be(x: $T) -> $T {\n+        pub fn from_be(x: Self) -> Self {\n             if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n         }\n \n@@ -866,7 +866,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn from_le(x: $T) -> $T {\n+        pub fn from_le(x: Self) -> Self {\n             if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n         }\n \n@@ -888,7 +888,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn to_be(self) -> $T { // or not to be?\n+        pub fn to_be(self) -> Self { // or not to be?\n             if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n         }\n \n@@ -910,7 +910,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn to_le(self) -> $T {\n+        pub fn to_le(self) -> Self {\n             if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n         }\n \n@@ -925,8 +925,8 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_add(self, other: $T) -> Option<$T> {\n-            checked_op!($T, $ActualT, $add_with_overflow, self, other)\n+        pub fn checked_add(self, other: Self) -> Option<Self> {\n+            checked_op!($ActualT, $add_with_overflow, self, other)\n         }\n \n         /// Checked integer subtraction. Computes `self - other`, returning\n@@ -940,8 +940,8 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_sub(self, other: $T) -> Option<$T> {\n-            checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n+        pub fn checked_sub(self, other: Self) -> Option<Self> {\n+            checked_op!($ActualT, $sub_with_overflow, self, other)\n         }\n \n         /// Checked integer multiplication. Computes `self * other`, returning\n@@ -955,8 +955,8 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_mul(self, other: $T) -> Option<$T> {\n-            checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n+        pub fn checked_mul(self, other: Self) -> Option<Self> {\n+            checked_op!($ActualT, $mul_with_overflow, self, other)\n         }\n \n         /// Checked integer division. Computes `self / other`, returning `None`\n@@ -971,7 +971,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_div(self, v: $T) -> Option<$T> {\n+        pub fn checked_div(self, v: Self) -> Option<Self> {\n             match v {\n                 0 => None,\n                 v => Some(self / v),\n@@ -982,31 +982,31 @@ macro_rules! uint_impl {\n         /// the numeric bounds instead of overflowing.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_add(self, other: $T) -> $T {\n+        pub fn saturating_add(self, other: Self) -> Self {\n             match self.checked_add(other) {\n                 Some(x)                       => x,\n-                None if other >= <$T as Zero>::zero() => <$T>::max_value(),\n-                None => <$T>::min_value(),\n+                None if other >= Self::zero() => Self::max_value(),\n+                None => Self::min_value(),\n             }\n         }\n \n         /// Saturating integer subtraction. Computes `self - other`, saturating\n         /// at the numeric bounds instead of overflowing.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_sub(self, other: $T) -> $T {\n+        pub fn saturating_sub(self, other: Self) -> Self {\n             match self.checked_sub(other) {\n                 Some(x)                       => x,\n-                None if other >= <$T as Zero>::zero() => <$T>::min_value(),\n-                None => <$T>::max_value(),\n+                None if other >= Self::zero() => Self::min_value(),\n+                None => Self::max_value(),\n             }\n         }\n \n         /// Wrapping (modular) addition. Computes `self + other`,\n         /// wrapping around at the boundary of the type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn wrapping_add(self, rhs: $T) -> $T {\n+        pub fn wrapping_add(self, rhs: Self) -> Self {\n             unsafe {\n                 intrinsics::overflowing_add(self, rhs)\n             }\n@@ -1016,7 +1016,7 @@ macro_rules! uint_impl {\n         /// wrapping around at the boundary of the type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn wrapping_sub(self, rhs: $T) -> $T {\n+        pub fn wrapping_sub(self, rhs: Self) -> Self {\n             unsafe {\n                 intrinsics::overflowing_sub(self, rhs)\n             }\n@@ -1026,7 +1026,7 @@ macro_rules! uint_impl {\n         /// other`, wrapping around at the boundary of the type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn wrapping_mul(self, rhs: $T) -> $T {\n+        pub fn wrapping_mul(self, rhs: Self) -> Self {\n             unsafe {\n                 intrinsics::overflowing_mul(self, rhs)\n             }\n@@ -1043,7 +1043,7 @@ macro_rules! uint_impl {\n         /// itself..\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_div(self, rhs: $T) -> $T {\n+        pub fn wrapping_div(self, rhs: Self) -> Self {\n             self.overflowing_div(rhs).0\n         }\n \n@@ -1056,7 +1056,7 @@ macro_rules! uint_impl {\n         /// minimal value). In such a case, this function returns `0`.\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_rem(self, rhs: $T) -> $T {\n+        pub fn wrapping_rem(self, rhs: Self) -> Self {\n             self.overflowing_rem(rhs).0\n         }\n \n@@ -1070,7 +1070,7 @@ macro_rules! uint_impl {\n         /// a case, this function returns `MIN` itself.\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_neg(self) -> $T {\n+        pub fn wrapping_neg(self) -> Self {\n             self.overflowing_neg().0\n         }\n \n@@ -1079,7 +1079,7 @@ macro_rules! uint_impl {\n         /// would cause the shift to exceed the bitwidth of the type.\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_shl(self, rhs: u32) -> $T {\n+        pub fn wrapping_shl(self, rhs: u32) -> Self {\n             self.overflowing_shl(rhs).0\n         }\n \n@@ -1088,7 +1088,7 @@ macro_rules! uint_impl {\n         /// would cause the shift to exceed the bitwidth of the type.\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_shr(self, rhs: u32) -> $T {\n+        pub fn wrapping_shr(self, rhs: u32) -> Self {\n             self.overflowing_shr(rhs).0\n         }\n \n@@ -1101,9 +1101,9 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn pow(self, mut exp: u32) -> $T {\n+        pub fn pow(self, mut exp: u32) -> Self {\n             let mut base = self;\n-            let mut acc = <$T as One>::one();\n+            let mut acc = Self::one();\n \n             let mut prev_base = self;\n             let mut base_oflo = false;\n@@ -1131,25 +1131,25 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn is_power_of_two(self) -> bool {\n-            (self.wrapping_sub(<$T as One>::one())) & self == <$T as Zero>::zero() &&\n-                !(self == <$T as Zero>::zero())\n+            (self.wrapping_sub(Self::one())) & self == Self::zero() &&\n+                !(self == Self::zero())\n         }\n \n         /// Returns the smallest power of two greater than or equal to `self`.\n         /// Unspecified behavior on overflow.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn next_power_of_two(self) -> $T {\n-            let bits = size_of::<$T>() * 8;\n-            let one: $T = <$T as One>::one();\n+        pub fn next_power_of_two(self) -> Self {\n+            let bits = size_of::<Self>() * 8;\n+            let one: Self = Self::one();\n             one << ((bits - self.wrapping_sub(one).leading_zeros() as usize) % bits)\n         }\n \n         /// Returns the smallest power of two greater than or equal to `n`. If\n         /// the next power of two is greater than the type's maximum value,\n         /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        pub fn checked_next_power_of_two(self) -> Option<$T> {\n+        pub fn checked_next_power_of_two(self) -> Option<Self> {\n             let npot = self.next_power_of_two();\n             if npot >= self {\n                 Some(npot)\n@@ -1162,7 +1162,7 @@ macro_rules! uint_impl {\n \n #[lang = \"u8\"]\n impl u8 {\n-    uint_impl! { u8 = u8, 8,\n+    uint_impl! { u8, 8,\n         intrinsics::ctpop8,\n         intrinsics::ctlz8,\n         intrinsics::cttz8,\n@@ -1174,7 +1174,7 @@ impl u8 {\n \n #[lang = \"u16\"]\n impl u16 {\n-    uint_impl! { u16 = u16, 16,\n+    uint_impl! { u16, 16,\n         intrinsics::ctpop16,\n         intrinsics::ctlz16,\n         intrinsics::cttz16,\n@@ -1186,7 +1186,7 @@ impl u16 {\n \n #[lang = \"u32\"]\n impl u32 {\n-    uint_impl! { u32 = u32, 32,\n+    uint_impl! { u32, 32,\n         intrinsics::ctpop32,\n         intrinsics::ctlz32,\n         intrinsics::cttz32,\n@@ -1199,7 +1199,7 @@ impl u32 {\n \n #[lang = \"u64\"]\n impl u64 {\n-    uint_impl! { u64 = u64, 64,\n+    uint_impl! { u64, 64,\n         intrinsics::ctpop64,\n         intrinsics::ctlz64,\n         intrinsics::cttz64,\n@@ -1212,7 +1212,7 @@ impl u64 {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize = u32, 32,\n+    uint_impl! { u32, 32,\n         intrinsics::ctpop32,\n         intrinsics::ctlz32,\n         intrinsics::cttz32,\n@@ -1225,7 +1225,7 @@ impl usize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize = u64, 64,\n+    uint_impl! { u64, 64,\n         intrinsics::ctpop64,\n         intrinsics::ctlz64,\n         intrinsics::cttz64,\n@@ -1362,9 +1362,9 @@ pub trait Float {\n }\n \n macro_rules! from_str_float_impl {\n-    ($T:ident) => {\n+    ($t:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl FromStr for $T {\n+        impl FromStr for $t {\n             type Err = ParseFloatError;\n \n             /// Converts a string in base 10 to a float.\n@@ -1395,8 +1395,8 @@ macro_rules! from_str_float_impl {\n             /// number represented by `src`.\n             #[inline]\n             #[allow(deprecated)]\n-            fn from_str(src: &str) -> Result<$T, ParseFloatError> {\n-                $T::from_str_radix(src, 10)\n+            fn from_str(src: &str) -> Result<Self, ParseFloatError> {\n+                Self::from_str_radix(src, 10)\n             }\n         }\n     }\n@@ -1405,12 +1405,12 @@ from_str_float_impl!(f32);\n from_str_float_impl!(f64);\n \n macro_rules! from_str_radix_int_impl {\n-    ($($T:ident)*) => {$(\n+    ($($t:ty)*) => {$(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n-        impl FromStr for $T {\n+        impl FromStr for $t {\n             type Err = ParseIntError;\n-            fn from_str(src: &str) -> Result<$T, ParseIntError> {\n+            fn from_str(src: &str) -> Result<Self, ParseIntError> {\n                 from_str_radix(src, 10)\n             }\n         }\n@@ -1428,17 +1428,17 @@ trait FromStrRadixHelper: PartialOrd + Copy {\n }\n \n macro_rules! doit {\n-    ($($t:ident)*) => ($(impl FromStrRadixHelper for $t {\n-        fn min_value() -> Self { <$t>::min_value() }\n-        fn from_u32(u: u32) -> Self { u as $t }\n+    ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {\n+        fn min_value() -> Self { Self::min_value() }\n+        fn from_u32(u: u32) -> Self { u as Self }\n         fn checked_mul(&self, other: u32) -> Option<Self> {\n-            <$t>::checked_mul(*self, other as $t)\n+            Self::checked_mul(*self, other as Self)\n         }\n         fn checked_sub(&self, other: u32) -> Option<Self> {\n-            <$t>::checked_sub(*self, other as $t)\n+            Self::checked_sub(*self, other as Self)\n         }\n         fn checked_add(&self, other: u32) -> Option<Self> {\n-            <$t>::checked_add(*self, other as $t)\n+            Self::checked_add(*self, other as Self)\n         }\n     })*)\n }"}]}