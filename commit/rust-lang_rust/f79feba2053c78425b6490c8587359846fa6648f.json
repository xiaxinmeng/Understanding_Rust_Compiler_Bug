{"sha": "f79feba2053c78425b6490c8587359846fa6648f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3OWZlYmEyMDUzYzc4NDI1YjY0OTBjODU4NzM1OTg0NmZhNjY0OGY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-04T21:23:11Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-28T00:55:37Z"}, "message": "rustc_typeck: pass all lifetimes through AstConv::opt_ast_region_to_region.", "tree": {"sha": "de234924a90d50b8c69dd81bc993e8ea24d2797d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de234924a90d50b8c69dd81bc993e8ea24d2797d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f79feba2053c78425b6490c8587359846fa6648f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f79feba2053c78425b6490c8587359846fa6648f", "html_url": "https://github.com/rust-lang/rust/commit/f79feba2053c78425b6490c8587359846fa6648f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f79feba2053c78425b6490c8587359846fa6648f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f559f8c33634670a8113091fe71080b21562031", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f559f8c33634670a8113091fe71080b21562031", "html_url": "https://github.com/rust-lang/rust/commit/4f559f8c33634670a8113091fe71080b21562031"}], "stats": {"total": 259, "additions": 129, "deletions": 130}, "files": [{"sha": "0a836a8ba22297bfb11d7fec4bf8ec8d278a2145", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/f79feba2053c78425b6490c8587359846fa6648f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f79feba2053c78425b6490c8587359846fa6648f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f79feba2053c78425b6490c8587359846fa6648f", "patch": "@@ -64,7 +64,7 @@ use require_c_abi_if_variadic;\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope,\n              ElisionFailureInfo, ElidedLifetime};\n-use rscope::{AnonTypeScope, MaybeWithAnonTypes};\n+use rscope::{AnonTypeScope, MaybeWithAnonTypes, ExplicitRscope};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::{NodeMap, FxHashSet};\n \n@@ -161,70 +161,6 @@ struct ConvertedBinding<'tcx> {\n /// This type must not appear anywhere in other converted types.\n const TRAIT_OBJECT_DUMMY_SELF: ty::TypeVariants<'static> = ty::TyInfer(ty::FreshTy(0));\n \n-pub fn ast_region_to_region<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                            lifetime: &hir::Lifetime)\n-                                            -> &'tcx ty::Region {\n-    let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n-        None => {\n-            // should have been recorded by the `resolve_lifetime` pass\n-            span_bug!(lifetime.span, \"unresolved lifetime\");\n-        }\n-\n-        Some(&rl::DefStaticRegion) => {\n-            ty::ReStatic\n-        }\n-\n-        Some(&rl::DefLateBoundRegion(debruijn, id)) => {\n-            // If this region is declared on a function, it will have\n-            // an entry in `late_bound`, but if it comes from\n-            // `for<'a>` in some type or something, it won't\n-            // necessarily have one. In that case though, we won't be\n-            // changed from late to early bound, so we can just\n-            // substitute false.\n-            let issue_32330 = tcx.named_region_map\n-                                 .late_bound\n-                                 .get(&id)\n-                                 .cloned()\n-                                 .unwrap_or(ty::Issue32330::WontChange);\n-            ty::ReLateBound(debruijn, ty::BrNamed(tcx.hir.local_def_id(id),\n-                                                  lifetime.name,\n-                                                  issue_32330))\n-        }\n-\n-        Some(&rl::DefEarlyBoundRegion(index, _)) => {\n-            ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                index: index,\n-                name: lifetime.name\n-            })\n-        }\n-\n-        Some(&rl::DefFreeRegion(scope, id)) => {\n-            // As in DefLateBoundRegion above, could be missing for some late-bound\n-            // regions, but also for early-bound regions.\n-            let issue_32330 = tcx.named_region_map\n-                                 .late_bound\n-                                 .get(&id)\n-                                 .cloned()\n-                                 .unwrap_or(ty::Issue32330::WontChange);\n-            ty::ReFree(ty::FreeRegion {\n-                    scope: scope.to_code_extent(&tcx.region_maps),\n-                    bound_region: ty::BrNamed(tcx.hir.local_def_id(id),\n-                                              lifetime.name,\n-                                              issue_32330)\n-            })\n-\n-                // (*) -- not late-bound, won't change\n-        }\n-    };\n-\n-    debug!(\"ast_region_to_region(lifetime={:?} id={}) yields {:?}\",\n-           lifetime,\n-           lifetime.id,\n-           r);\n-\n-    tcx.mk_region(r)\n-}\n-\n fn report_elision_failure(\n     tcx: TyCtxt,\n     db: &mut DiagnosticBuilder,\n@@ -296,38 +232,98 @@ fn report_elision_failure(\n }\n \n impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n-    pub fn opt_ast_region_to_region(&self,\n+    pub fn ast_region_to_region(&self, lifetime: &hir::Lifetime) -> &'tcx ty::Region {\n+        self.opt_ast_region_to_region(&ExplicitRscope, lifetime.span, Some(lifetime), None)\n+    }\n+\n+    fn try_opt_ast_region_to_region(&self,\n         rscope: &RegionScope,\n         default_span: Span,\n-        opt_lifetime: &Option<hir::Lifetime>) -> &'tcx ty::Region\n+        opt_lifetime: Option<&hir::Lifetime>,\n+        def: Option<&ty::RegionParameterDef>)\n+        -> Result<&'tcx ty::Region, Option<Vec<ElisionFailureInfo>>>\n     {\n-        let r = match *opt_lifetime {\n-            Some(ref lifetime) => {\n-                ast_region_to_region(self.tcx(), lifetime)\n+        let tcx = self.tcx();\n+        let name = opt_lifetime.map(|l| l.name);\n+        let resolved = opt_lifetime.and_then(|l| tcx.named_region_map.defs.get(&l.id));\n+        let r = tcx.mk_region(match resolved {\n+            Some(&rl::DefStaticRegion) => {\n+                ty::ReStatic\n             }\n \n-            None => {\n-                self.tcx().mk_region(rscope.anon_region(default_span).unwrap_or_else(|params| {\n-                    let ampersand_span = Span { hi: default_span.lo, ..default_span};\n+            Some(&rl::DefLateBoundRegion(debruijn, id)) => {\n+                // If this region is declared on a function, it will have\n+                // an entry in `late_bound`, but if it comes from\n+                // `for<'a>` in some type or something, it won't\n+                // necessarily have one. In that case though, we won't be\n+                // changed from late to early bound, so we can just\n+                // substitute false.\n+                let issue_32330 = tcx.named_region_map\n+                                     .late_bound\n+                                     .get(&id)\n+                                     .cloned()\n+                                     .unwrap_or(ty::Issue32330::WontChange);\n+                ty::ReLateBound(debruijn, ty::BrNamed(tcx.hir.local_def_id(id),\n+                                                      name.unwrap(),\n+                                                      issue_32330))\n+            }\n+\n+            Some(&rl::DefEarlyBoundRegion(index, _)) => {\n+                ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                    index: index,\n+                    name: name.unwrap()\n+                })\n+            }\n \n-                    let mut err = struct_span_err!(self.tcx().sess, ampersand_span, E0106,\n-                                                 \"missing lifetime specifier\");\n-                    err.span_label(ampersand_span, &format!(\"expected lifetime parameter\"));\n+            Some(&rl::DefFreeRegion(scope, id)) => {\n+                // As in DefLateBoundRegion above, could be missing for some late-bound\n+                // regions, but also for early-bound regions.\n+                let issue_32330 = tcx.named_region_map\n+                                     .late_bound\n+                                     .get(&id)\n+                                     .cloned()\n+                                     .unwrap_or(ty::Issue32330::WontChange);\n+                ty::ReFree(ty::FreeRegion {\n+                        scope: scope.to_code_extent(&tcx.region_maps),\n+                        bound_region: ty::BrNamed(tcx.hir.local_def_id(id),\n+                                                  name.unwrap(),\n+                                                  issue_32330)\n+                })\n \n-                    if let Some(params) = params {\n-                        report_elision_failure(self.tcx(), &mut err, params);\n-                    }\n-                    err.emit();\n-                    ty::ReStatic\n-                }))\n+                    // (*) -- not late-bound, won't change\n             }\n-        };\n+\n+            None => rscope.anon_region(default_span, def)?\n+        });\n \n         debug!(\"opt_ast_region_to_region(opt_lifetime={:?}) yields {:?}\",\n                 opt_lifetime,\n                 r);\n \n-        r\n+        Ok(r)\n+    }\n+\n+    pub fn opt_ast_region_to_region(&self,\n+        rscope: &RegionScope,\n+        default_span: Span,\n+        opt_lifetime: Option<&hir::Lifetime>,\n+        def: Option<&ty::RegionParameterDef>) -> &'tcx ty::Region\n+    {\n+        let tcx = self.tcx();\n+        self.try_opt_ast_region_to_region(rscope, default_span, opt_lifetime, def)\n+            .unwrap_or_else(|params| {\n+                let ampersand_span = Span { hi: default_span.lo, ..default_span};\n+\n+                let mut err = struct_span_err!(tcx.sess, ampersand_span, E0106,\n+                                               \"missing lifetime specifier\");\n+                err.span_label(ampersand_span, &format!(\"expected lifetime parameter\"));\n+\n+                if let Some(params) = params {\n+                    report_elision_failure(tcx, &mut err, params);\n+                }\n+                err.emit();\n+                tcx.mk_region(ty::ReStatic)\n+            })\n     }\n \n     /// Given a path `path` that refers to an item `I` with the declared generics `decl_generics`,\n@@ -408,25 +404,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n         let expected_num_region_params = decl_generics.regions.len();\n         let supplied_num_region_params = lifetimes.len();\n-        let regions = if expected_num_region_params == supplied_num_region_params {\n-            lifetimes.iter().map(|l| *ast_region_to_region(tcx, l)).collect()\n-        } else {\n-            let anon_regions = (0..expected_num_region_params).map(|_| {\n-                rscope.anon_region(span)\n-            }).collect::<Result<Vec<_>, _>>();\n-\n-            if supplied_num_region_params != 0 || anon_regions.is_err() {\n+        let has_exact_lifetimes = expected_num_region_params == supplied_num_region_params;\n+        let mut can_report_lifetime_count_mismatch = !has_exact_lifetimes;\n+        let mut maybe_report_lifetime_count_mismatch = || {\n+            if can_report_lifetime_count_mismatch {\n+                can_report_lifetime_count_mismatch = false;\n                 report_lifetime_number_error(tcx, span,\n                                              supplied_num_region_params,\n                                              expected_num_region_params);\n             }\n-\n-            match anon_regions {\n-                Ok(anon_regions) => anon_regions,\n-                Err(_) => (0..expected_num_region_params).map(|_| ty::ReStatic).collect()\n-            }\n         };\n \n+        if supplied_num_region_params != 0 {\n+            maybe_report_lifetime_count_mismatch();\n+        }\n+\n         // If a self-type was declared, one should be provided.\n         assert_eq!(decl_generics.has_self, self_ty.is_some());\n \n@@ -452,7 +444,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let mut output_assoc_binding = None;\n         let substs = Substs::for_item(tcx, def_id, |def, _| {\n             let i = def.index as usize - self_ty.is_some() as usize;\n-            tcx.mk_region(regions[i])\n+            let l = if has_exact_lifetimes {\n+                Some(&lifetimes[i])\n+            } else {\n+                None\n+            };\n+            self.try_opt_ast_region_to_region(rscope, span, l, Some(def)).unwrap_or_else(|_| {\n+                maybe_report_lifetime_count_mismatch();\n+                tcx.mk_region(ty::ReStatic)\n+            })\n         }, |def, substs| {\n             let i = def.index as usize;\n \n@@ -1472,7 +1472,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 })\n             }\n             hir::TyRptr(ref region, ref mt) => {\n-                let r = self.opt_ast_region_to_region(rscope, ast_ty.span, region);\n+                let r = self.opt_ast_region_to_region(rscope, ast_ty.span, region.as_ref(), None);\n                 debug!(\"TyRef r={:?}\", r);\n                 let rscope1 =\n                     &ObjectLifetimeDefaultRscope::new(\n@@ -1823,7 +1823,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         if let Some(&r) = explicit_region_bounds.get(0) {\n             // Explicitly specified region bound. Use that.\n-            return Some(ast_region_to_region(tcx, r));\n+            return Some(self.ast_region_to_region(r));\n         }\n \n         if let Some(principal) = existential_predicates.principal() {"}, {"sha": "e7544c10be3e74a065fae8eb799aa7fa52f334d8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f79feba2053c78425b6490c8587359846fa6648f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f79feba2053c78425b6490c8587359846fa6648f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f79feba2053c78425b6490c8587359846fa6648f", "patch": "@@ -80,7 +80,7 @@ pub use self::Expectation::*;\n pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::TupleArgumentsFlag::*;\n \n-use astconv::{AstConv, ast_region_to_region};\n+use astconv::AstConv;\n use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n use hir::def::{Def, CtorKind};\n@@ -1466,9 +1466,13 @@ impl<'a, 'gcx, 'tcx> RegionScope for FnCtxt<'a, 'gcx, 'tcx> {\n         *self.next_region_var(infer::MiscVariable(span))\n     }\n \n-    fn anon_region(&self, span: Span)\n+    fn anon_region(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n                    -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>> {\n-        Ok(*self.next_region_var(infer::MiscVariable(span)))\n+        let v = match def {\n+            Some(def) => infer::EarlyBoundRegion(span, def.name),\n+            None => infer::MiscVariable(span)\n+        };\n+        Ok(*self.next_region_var(v))\n     }\n }\n \n@@ -4404,11 +4408,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 None => &[]\n             };\n \n-            if let Some(ast_lifetime) = lifetimes.get(i) {\n-                ast_region_to_region(self.tcx, ast_lifetime)\n-            } else {\n-                self.region_var_for_def(span, def)\n-            }\n+            AstConv::opt_ast_region_to_region(self, self, span, lifetimes.get(i), Some(def))\n         }, |def, substs| {\n             let mut i = def.index as usize;\n "}, {"sha": "f954d2a5d616885e04e0836d0dd525755086a2bf", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f79feba2053c78425b6490c8587359846fa6648f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f79feba2053c78425b6490c8587359846fa6648f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f79feba2053c78425b6490c8587359846fa6648f", "patch": "@@ -57,7 +57,7 @@ There are some shortcomings in this design:\n \n */\n \n-use astconv::{AstConv, ast_region_to_region, Bounds, PartitionedBounds, partition_bounds};\n+use astconv::{AstConv, Bounds, PartitionedBounds, partition_bounds};\n use lint;\n use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n@@ -1472,7 +1472,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 index: own_start + i as u32,\n                 def_id: tcx.hir.local_def_id(l.lifetime.id),\n                 bounds: l.bounds.iter().map(|l| {\n-                    ast_region_to_region(tcx, l)\n+                    AstConv::ast_region_to_region(&ccx.icx(&()), l)\n                 }).collect(),\n                 pure_wrt_drop: l.pure_wrt_drop,\n             }\n@@ -1765,7 +1765,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             name: param.lifetime.name\n         }));\n         for bound in &param.bounds {\n-            let bound_region = ast_region_to_region(ccx.tcx, bound);\n+            let bound_region = AstConv::ast_region_to_region(&ccx.icx(&()), bound);\n             let outlives = ty::Binder(ty::OutlivesPredicate(region, bound_region));\n             predicates.push(outlives.to_predicate());\n         }\n@@ -1816,7 +1816,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                         }\n \n                         &hir::TyParamBound::RegionTyParamBound(ref lifetime) => {\n-                            let region = ast_region_to_region(tcx, lifetime);\n+                            let region = AstConv::ast_region_to_region(&ccx.icx(&()), lifetime);\n                             let pred = ty::Binder(ty::OutlivesPredicate(ty, region));\n                             predicates.push(ty::Predicate::TypeOutlives(pred))\n                         }\n@@ -1825,9 +1825,9 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             }\n \n             &hir::WherePredicate::RegionPredicate(ref region_pred) => {\n-                let r1 = ast_region_to_region(tcx, &region_pred.lifetime);\n+                let r1 = AstConv::ast_region_to_region(&ccx.icx(&()), &region_pred.lifetime);\n                 for bound in &region_pred.bounds {\n-                    let r2 = ast_region_to_region(tcx, bound);\n+                    let r2 = AstConv::ast_region_to_region(&ccx.icx(&()), bound);\n                     let pred = ty::Binder(ty::OutlivesPredicate(r1, r2));\n                     predicates.push(ty::Predicate::RegionOutlives(pred))\n                 }\n@@ -1935,7 +1935,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                       hir::TraitTyParamBound(..) =>\n                           None,\n                       hir::RegionTyParamBound(ref lifetime) =>\n-                          Some(ast_region_to_region(ccx.tcx, lifetime)),\n+                          Some(AstConv::ast_region_to_region(&ccx.icx(&()), lifetime)),\n                   }\n               })\n               .collect()\n@@ -1981,7 +1981,6 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n                                         span: Span)\n                                         -> Bounds<'tcx>\n {\n-    let tcx = astconv.tcx();\n     let PartitionedBounds {\n         trait_bounds,\n         region_bounds\n@@ -1998,7 +1997,7 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n     }).collect();\n \n     let region_bounds = region_bounds.into_iter().map(|r| {\n-        ast_region_to_region(tcx, r)\n+        astconv.ast_region_to_region(r)\n     }).collect();\n \n     trait_bounds.sort_by(|a,b| a.def_id().cmp(&b.def_id()));\n@@ -2040,7 +2039,7 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                        .collect()\n         }\n         hir::RegionTyParamBound(ref lifetime) => {\n-            let region = ast_region_to_region(astconv.tcx(), lifetime);\n+            let region = astconv.ast_region_to_region(lifetime);\n             let pred = ty::Binder(ty::OutlivesPredicate(param_ty, region));\n             vec![ty::Predicate::TypeOutlives(pred)]\n         }"}, {"sha": "2ad1a7c3d685f07f2797358c75a2e3e89e0c762f", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f79feba2053c78425b6490c8587359846fa6648f/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f79feba2053c78425b6490c8587359846fa6648f/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=f79feba2053c78425b6490c8587359846fa6648f", "patch": "@@ -41,7 +41,7 @@ pub type ElidedLifetime = Result<ty::Region, Option<Vec<ElisionFailureInfo>>>;\n /// can return `Err(())` to indicate that this is not a scope in which\n /// regions can legally be omitted.\n pub trait RegionScope {\n-    fn anon_region(&self, span: Span)\n+    fn anon_region(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n                     -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>>;\n \n     /// If an object omits any explicit lifetime bound, and none can\n@@ -115,9 +115,9 @@ impl<R: RegionScope> RegionScope for MaybeWithAnonTypes<R> {\n         self.base_scope.object_lifetime_default(span)\n     }\n \n-    fn anon_region(&self, span: Span)\n+    fn anon_region(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n                    -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>> {\n-        self.base_scope.anon_region(span)\n+        self.base_scope.anon_region(span, def)\n     }\n \n     fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n@@ -135,7 +135,7 @@ impl<R: RegionScope> RegionScope for MaybeWithAnonTypes<R> {\n pub struct ExplicitRscope;\n \n impl RegionScope for ExplicitRscope {\n-    fn anon_region(&self, _span: Span)\n+    fn anon_region(&self, _span: Span, _: Option<&ty::RegionParameterDef>)\n                    -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>> {\n         Err(None)\n     }\n@@ -159,7 +159,7 @@ impl UnelidableRscope {\n }\n \n impl RegionScope for UnelidableRscope {\n-    fn anon_region(&self, _span: Span)\n+    fn anon_region(&self, _span: Span, _: Option<&ty::RegionParameterDef>)\n                    -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>> {\n         Err(self.0.clone())\n     }\n@@ -199,7 +199,7 @@ impl RegionScope for ElidableRscope {\n         ty::ReStatic\n     }\n \n-    fn anon_region(&self, _span: Span)\n+    fn anon_region(&self, _span: Span, _: Option<&ty::RegionParameterDef>)\n                    -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>>\n     {\n         Ok(self.default)\n@@ -221,7 +221,7 @@ impl<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> StaticRscope<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> RegionScope for StaticRscope<'a, 'gcx, 'tcx> {\n-    fn anon_region(&self, span: Span)\n+    fn anon_region(&self, span: Span, _: Option<&ty::RegionParameterDef>)\n                    -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>> {\n         if !self.tcx.sess.features.borrow().static_in_const {\n             self.tcx\n@@ -269,7 +269,7 @@ impl RegionScope for BindingRscope {\n         ty::ReStatic\n     }\n \n-    fn anon_region(&self, _: Span)\n+    fn anon_region(&self, _: Span, _: Option<&ty::RegionParameterDef>)\n                    -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>>\n     {\n         let idx = self.anon_bindings.get();\n@@ -315,10 +315,10 @@ impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> {\n         self.base_scope.base_object_lifetime_default(span)\n     }\n \n-    fn anon_region(&self, span: Span)\n+    fn anon_region(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n                    -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>>\n     {\n-        self.base_scope.anon_region(span)\n+        self.base_scope.anon_region(span, def)\n     }\n \n     fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n@@ -348,10 +348,10 @@ impl<'r> RegionScope for ShiftedRscope<'r> {\n         ty::fold::shift_region(self.base_scope.base_object_lifetime_default(span), 1)\n     }\n \n-    fn anon_region(&self, span: Span)\n+    fn anon_region(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n                    -> Result<ty::Region, Option<Vec<ElisionFailureInfo>>>\n     {\n-        self.base_scope.anon_region(span).map(|r| ty::fold::shift_region(r, 1))\n+        self.base_scope.anon_region(span, def).map(|r| ty::fold::shift_region(r, 1))\n     }\n \n     fn anon_type_scope(&self) -> Option<AnonTypeScope> {"}]}