{"sha": "5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlYmQ3YzUwYTBiOTIzNmFmNDM4OWIwMGM5N2IwMGE1OWQ5ZmE3NDc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-09T18:51:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-09T18:51:18Z"}, "message": "Rollup merge of #37614 - keeperofdakeys:proc_macro, r=jseyfried\n\nmacros 1.1: Allow proc_macro functions to declare attributes to be mark as used\n\nThis PR allows proc macro functions to declare attribute names that should be marked as used when attached to the deriving item. There are a few questions for this PR.\n\n- Currently this uses a separate attribute named `#[proc_macro_attributes(..)]`, is this the best choice?\n- In order to make this work, the `check_attribute` function had to be modified to not error on attributes marked as used. This is a pretty large change in semantics, is there a better way to do this?\n- I've got a few clones where I don't know if I need them (like turning `item` into a `TokenStream`), can these be avoided?\n- Is switching to `MultiItemDecorator` the right thing here?\n\nAlso fixes https://github.com/rust-lang/rust/issues/37563.", "tree": {"sha": "7ae11942986307fad0aa452b5ee4a9db0cb89e9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ae11942986307fad0aa452b5ee4a9db0cb89e9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "html_url": "https://github.com/rust-lang/rust/commit/5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d2ffa06ea4e04dbda99d7038e9afd04c040b472", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d2ffa06ea4e04dbda99d7038e9afd04c040b472", "html_url": "https://github.com/rust-lang/rust/commit/3d2ffa06ea4e04dbda99d7038e9afd04c040b472"}, {"sha": "134ef4f7933b87efdc04eac3e8d9a530d56d9cfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/134ef4f7933b87efdc04eac3e8d9a530d56d9cfe", "html_url": "https://github.com/rust-lang/rust/commit/134ef4f7933b87efdc04eac3e8d9a530d56d9cfe"}], "stats": {"total": 370, "additions": 298, "deletions": 72}, "files": [{"sha": "5ee9fecfb21b3ce0d9b70aead5a85a72da01c546", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -95,7 +95,8 @@ pub mod __internal {\n     pub trait Registry {\n         fn register_custom_derive(&mut self,\n                                   trait_name: &str,\n-                                  expand: fn(TokenStream) -> TokenStream);\n+                                  expand: fn(TokenStream) -> TokenStream,\n+                                  attributes: &[&'static str]);\n     }\n \n     // Emulate scoped_thread_local!() here essentially"}, {"sha": "d3fd638d6b5ff5a3f29056e8449008e0e9b2ebba", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -19,7 +19,7 @@ use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n use syntax::ast;\n use syntax::attr;\n-use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n+use syntax::feature_gate::{BUILTIN_ATTRIBUTES, AttributeType};\n use syntax::parse::token::keywords;\n use syntax::ptr::P;\n use syntax_pos::Span;\n@@ -245,7 +245,7 @@ impl LateLintPass for UnusedAttributes {\n         debug!(\"checking attribute: {:?}\", attr);\n \n         // Note that check_name() marks the attribute as used if it matches.\n-        for &(ref name, ty, _) in KNOWN_ATTRIBUTES {\n+        for &(ref name, ty, _) in BUILTIN_ATTRIBUTES {\n             match ty {\n                 AttributeType::Whitelisted if attr.check_name(name) => {\n                     debug!(\"{:?} is Whitelisted\", name);\n@@ -267,7 +267,7 @@ impl LateLintPass for UnusedAttributes {\n             debug!(\"Emitting warning for: {:?}\", attr);\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n             // Is it a builtin attribute that must be used at the crate level?\n-            let known_crate = KNOWN_ATTRIBUTES.iter()\n+            let known_crate = BUILTIN_ATTRIBUTES.iter()\n                 .find(|&&(name, ty, _)| attr.name() == name && ty == AttributeType::CrateLevel)\n                 .is_some();\n "}, {"sha": "4385f024b4139ce727c3fd99a9fcf77ee92e95cf", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -624,8 +624,12 @@ impl<'a> CrateLoader<'a> {\n         impl Registry for MyRegistrar {\n             fn register_custom_derive(&mut self,\n                                       trait_name: &str,\n-                                      expand: fn(TokenStream) -> TokenStream) {\n-                let derive = SyntaxExtension::CustomDerive(Box::new(CustomDerive::new(expand)));\n+                                      expand: fn(TokenStream) -> TokenStream,\n+                                      attributes: &[&'static str]) {\n+                let attrs = attributes.iter().map(|s| InternedString::new(s)).collect();\n+                let derive = SyntaxExtension::CustomDerive(\n+                    Box::new(CustomDerive::new(expand, attrs))\n+                );\n                 self.0.push((intern(trait_name), derive));\n             }\n         }"}, {"sha": "57a936bf9b0cf40c09b082571f186e698c28ab0a", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -32,7 +32,8 @@ use std::cell::{RefCell, Cell};\n use std::collections::HashSet;\n \n thread_local! {\n-    static USED_ATTRS: RefCell<Vec<u64>> = RefCell::new(Vec::new())\n+    static USED_ATTRS: RefCell<Vec<u64>> = RefCell::new(Vec::new());\n+    static KNOWN_ATTRS: RefCell<Vec<u64>> = RefCell::new(Vec::new());\n }\n \n enum AttrError {\n@@ -81,6 +82,29 @@ pub fn is_used(attr: &Attribute) -> bool {\n     })\n }\n \n+pub fn mark_known(attr: &Attribute) {\n+    debug!(\"Marking {:?} as known.\", attr);\n+    let AttrId(id) = attr.node.id;\n+    KNOWN_ATTRS.with(|slot| {\n+        let idx = (id / 64) as usize;\n+        let shift = id % 64;\n+        if slot.borrow().len() <= idx {\n+            slot.borrow_mut().resize(idx + 1, 0);\n+        }\n+        slot.borrow_mut()[idx] |= 1 << shift;\n+    });\n+}\n+\n+pub fn is_known(attr: &Attribute) -> bool {\n+    let AttrId(id) = attr.node.id;\n+    KNOWN_ATTRS.with(|slot| {\n+        let idx = (id / 64) as usize;\n+        let shift = id % 64;\n+        slot.borrow().get(idx).map(|bits| bits & (1 << shift) != 0)\n+            .unwrap_or(false)\n+    })\n+}\n+\n impl NestedMetaItem {\n     /// Returns the MetaItem if self is a NestedMetaItemKind::MetaItem.\n     pub fn meta_item(&self) -> Option<&P<MetaItem>> {"}, {"sha": "a6493872338fa43595b6ec6e677bda679e491a6a", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -421,11 +421,11 @@ macro_rules! cfg_fn {\n }\n \n pub fn deprecated_attributes() -> Vec<&'static (&'static str, AttributeType, AttributeGate)> {\n-    KNOWN_ATTRIBUTES.iter().filter(|a| a.2.is_deprecated()).collect()\n+    BUILTIN_ATTRIBUTES.iter().filter(|a| a.2.is_deprecated()).collect()\n }\n \n // Attributes that have a special meaning to rustc or rustdoc\n-pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGate)] = &[\n+pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGate)] = &[\n     // Normal attributes\n \n     (\"warn\", Normal, Ungated),\n@@ -800,12 +800,12 @@ impl<'a> Context<'a> {\n     fn check_attribute(&self, attr: &ast::Attribute, is_macro: bool) {\n         debug!(\"check_attribute(attr = {:?})\", attr);\n         let name = &*attr.name();\n-        for &(n, ty, ref gateage) in KNOWN_ATTRIBUTES {\n+        for &(n, ty, ref gateage) in BUILTIN_ATTRIBUTES {\n             if n == name {\n                 if let &Gated(_, ref name, ref desc, ref has_feature) = gateage {\n                     gate_feature_fn!(self, has_feature, attr.span, name, desc);\n                 }\n-                debug!(\"check_attribute: {:?} is known, {:?}, {:?}\", name, ty, gateage);\n+                debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", name, ty, gateage);\n                 return;\n             }\n         }\n@@ -825,6 +825,8 @@ impl<'a> Context<'a> {\n                            are reserved for internal compiler diagnostics\");\n         } else if name.starts_with(\"derive_\") {\n             gate_feature!(self, custom_derive, attr.span, EXPLAIN_DERIVE_UNDERSCORE);\n+        } else if attr::is_known(attr) {\n+            debug!(\"check_attribute: {:?} is known\", name);\n         } else {\n             // Only run the custom attribute lint during regular\n             // feature gate checking. Macro gating runs"}, {"sha": "3305c1eae2b00ee6106ae8fab877fcddc4d2b463", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -12,28 +12,43 @@ use std::panic;\n \n use errors::FatalError;\n use proc_macro::{TokenStream, __internal};\n-use syntax::ast::{self, ItemKind};\n-use syntax::codemap::{ExpnInfo, MacroAttribute, NameAndSpan, Span};\n+use syntax::ast::{self, ItemKind, Attribute};\n+use syntax::attr::{mark_used, mark_known};\n+use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::fold::Folder;\n-use syntax::parse::token::intern;\n-use syntax::print::pprust;\n+use syntax::parse::token::InternedString;\n+use syntax::visit::Visitor;\n+\n+struct MarkAttrs<'a>(&'a [InternedString]);\n+\n+impl<'a> Visitor for MarkAttrs<'a> {\n+    fn visit_attribute(&mut self, attr: &Attribute) {\n+        if self.0.contains(&attr.name()) {\n+            mark_used(attr);\n+            mark_known(attr);\n+        }\n+    }\n+}\n \n pub struct CustomDerive {\n     inner: fn(TokenStream) -> TokenStream,\n+    attrs: Vec<InternedString>,\n }\n \n impl CustomDerive {\n-    pub fn new(inner: fn(TokenStream) -> TokenStream) -> CustomDerive {\n-        CustomDerive { inner: inner }\n+    pub fn new(inner: fn(TokenStream) -> TokenStream,\n+               attrs: Vec<InternedString>)\n+               -> CustomDerive {\n+        CustomDerive { inner: inner, attrs: attrs }\n     }\n }\n \n impl MultiItemModifier for CustomDerive {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               span: Span,\n-              meta_item: &ast::MetaItem,\n+              _meta_item: &ast::MetaItem,\n               item: Annotatable)\n               -> Vec<Annotatable> {\n         let item = match item {\n@@ -47,31 +62,23 @@ impl MultiItemModifier for CustomDerive {\n         };\n         match item.node {\n             ItemKind::Struct(..) |\n-            ItemKind::Enum(..) => {}\n+            ItemKind::Enum(..) => {},\n             _ => {\n                 ecx.span_err(span, \"custom derive attributes may only be \\\n                                     applied to struct/enum items\");\n                 return Vec::new()\n             }\n         }\n \n-        let input_span = Span {\n-            expn_id: ecx.codemap().record_expansion(ExpnInfo {\n-                call_site: span,\n-                callee: NameAndSpan {\n-                    format: MacroAttribute(intern(&pprust::meta_item_to_string(meta_item))),\n-                    span: Some(span),\n-                    allow_internal_unstable: true,\n-                },\n-            }),\n-            ..item.span\n-        };\n-        let input = __internal::new_token_stream(item);\n+        // Mark attributes as known, and used.\n+        MarkAttrs(&self.attrs).visit_item(&item);\n+\n+        let input = __internal::new_token_stream(item.clone());\n         let res = __internal::set_parse_sess(&ecx.parse_sess, || {\n             let inner = self.inner;\n             panic::catch_unwind(panic::AssertUnwindSafe(|| inner(input)))\n         });\n-        let item = match res {\n+        let new_items = match res {\n             Ok(stream) => __internal::token_stream_items(stream),\n             Err(e) => {\n                 let msg = \"custom derive attribute panicked\";\n@@ -88,12 +95,13 @@ impl MultiItemModifier for CustomDerive {\n             }\n         };\n \n-        // Right now we have no knowledge of spans at all in custom derive\n-        // macros, everything is just parsed as a string. Reassign all spans to\n-        // the input `item` for better errors here.\n-        item.into_iter().flat_map(|item| {\n-            ChangeSpan { span: input_span }.fold_item(item)\n-        }).map(Annotatable::Item).collect()\n+        let mut res = vec![Annotatable::Item(item)];\n+        // Reassign spans of all expanded items to the input `item`\n+        // for better errors here.\n+        res.extend(new_items.into_iter().flat_map(|item| {\n+            ChangeSpan { span: span }.fold_item(item)\n+        }).map(Annotatable::Item));\n+        res\n     }\n }\n "}, {"sha": "d6d31200a994fcbc29d99422c4c21c56e48085f0", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 52, "deletions": 15, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -30,6 +30,7 @@ struct CustomDerive {\n     trait_name: InternedString,\n     function_name: Ident,\n     span: Span,\n+    attrs: Vec<InternedString>,\n }\n \n struct CollectCustomDerives<'a> {\n@@ -144,7 +145,8 @@ impl<'a> Visitor for CollectCustomDerives<'a> {\n         }\n \n         // Once we've located the `#[proc_macro_derive]` attribute, verify\n-        // that it's of the form `#[proc_macro_derive(Foo)]`\n+        // that it's of the form `#[proc_macro_derive(Foo)]` or\n+        // `#[proc_macro_derive(Foo, attributes(A, ..))]`\n         let list = match attr.meta_item_list() {\n             Some(list) => list,\n             None => {\n@@ -154,38 +156,69 @@ impl<'a> Visitor for CollectCustomDerives<'a> {\n                 return\n             }\n         };\n-        if list.len() != 1 {\n+        if list.len() != 1 && list.len() != 2 {\n             self.handler.span_err(attr.span(),\n-                                  \"attribute must only have one argument\");\n+                                  \"attribute must have either one or two arguments\");\n             return\n         }\n-        let attr = &list[0];\n-        let trait_name = match attr.name() {\n+        let trait_attr = &list[0];\n+        let attributes_attr = list.get(1);\n+        let trait_name = match trait_attr.name() {\n             Some(name) => name,\n             _ => {\n-                self.handler.span_err(attr.span(), \"not a meta item\");\n+                self.handler.span_err(trait_attr.span(), \"not a meta item\");\n                 return\n             }\n         };\n-        if !attr.is_word() {\n-            self.handler.span_err(attr.span(), \"must only be one word\");\n+        if !trait_attr.is_word() {\n+            self.handler.span_err(trait_attr.span(), \"must only be one word\");\n         }\n \n         if deriving::is_builtin_trait(&trait_name) {\n-            self.handler.span_err(attr.span(),\n+            self.handler.span_err(trait_attr.span(),\n                                   \"cannot override a built-in #[derive] mode\");\n         }\n \n         if self.derives.iter().any(|d| d.trait_name == trait_name) {\n-            self.handler.span_err(attr.span(),\n+            self.handler.span_err(trait_attr.span(),\n                                   \"derive mode defined twice in this crate\");\n         }\n \n+        let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n+            if !attr.check_name(\"attributes\") {\n+                self.handler.span_err(attr.span(), \"second argument must be `attributes`\")\n+            }\n+            attr.meta_item_list().unwrap_or_else(|| {\n+                self.handler.span_err(attr.span(),\n+                                      \"attribute must be of form: \\\n+                                       `attributes(foo, bar)`\");\n+                &[]\n+            }).into_iter().filter_map(|attr| {\n+                let name = match attr.name() {\n+                    Some(name) => name,\n+                    _ => {\n+                        self.handler.span_err(attr.span(), \"not a meta item\");\n+                        return None;\n+                    },\n+                };\n+\n+                if !attr.is_word() {\n+                    self.handler.span_err(attr.span(), \"must only be one word\");\n+                    return None;\n+                }\n+\n+                Some(name)\n+            }).collect()\n+        } else {\n+            Vec::new()\n+        };\n+\n         if self.in_root {\n             self.derives.push(CustomDerive {\n                 span: item.span,\n                 trait_name: trait_name,\n                 function_name: item.ident,\n+                attrs: proc_attrs,\n             });\n         } else {\n             let msg = \"functions tagged with `#[proc_macro_derive]` must \\\n@@ -219,8 +252,8 @@ impl<'a> Visitor for CollectCustomDerives<'a> {\n //\n //          #[plugin_registrar]\n //          fn registrar(registrar: &mut Registry) {\n-//              registrar.register_custom_derive($name_trait1, ::$name1);\n-//              registrar.register_custom_derive($name_trait2, ::$name2);\n+//              registrar.register_custom_derive($name_trait1, ::$name1, &[]);\n+//              registrar.register_custom_derive($name_trait2, ::$name2, &[\"attribute_name\"]);\n //              // ...\n //          }\n //      }\n@@ -249,14 +282,18 @@ fn mk_registrar(cx: &mut ExtCtxt,\n     let stmts = custom_derives.iter().map(|cd| {\n         let path = cx.path_global(cd.span, vec![cd.function_name]);\n         let trait_name = cx.expr_str(cd.span, cd.trait_name.clone());\n-        (path, trait_name)\n-    }).map(|(path, trait_name)| {\n+        let attrs = cx.expr_vec_slice(\n+            span,\n+            cd.attrs.iter().map(|s| cx.expr_str(cd.span, s.clone())).collect::<Vec<_>>()\n+        );\n+        (path, trait_name, attrs)\n+    }).map(|(path, trait_name, attrs)| {\n         let registrar = cx.expr_ident(span, registrar);\n         let ufcs_path = cx.path(span, vec![proc_macro, __internal, registry,\n                                            register_custom_derive]);\n         cx.expr_call(span,\n                      cx.expr_path(ufcs_path),\n-                     vec![registrar, trait_name, cx.expr_path(path)])\n+                     vec![registrar, trait_name, cx.expr_path(path), attrs])\n     }).map(|expr| {\n         cx.stmt_expr(expr)\n     }).collect::<Vec<_>>();"}, {"sha": "e22339694f9b002b910a138a6ce500e521229991", "filename": "src/test/compile-fail-fulldeps/proc-macro/attribute.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -33,8 +33,8 @@ pub fn foo3(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n     input\n }\n \n-#[proc_macro_derive(b, c)]\n-//~^ ERROR: attribute must only have one argument\n+#[proc_macro_derive(b, c, d)]\n+//~^ ERROR: attribute must have either one or two arguments\n pub fn foo4(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n     input\n }\n@@ -44,3 +44,21 @@ pub fn foo4(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n pub fn foo5(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n     input\n }\n+\n+#[proc_macro_derive(f, attributes(g = \"h\"))]\n+//~^ ERROR: must only be one word\n+pub fn foo6(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n+    input\n+}\n+\n+#[proc_macro_derive(i, attributes(j(k)))]\n+//~^ ERROR: must only be one word\n+pub fn foo7(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n+    input\n+}\n+\n+#[proc_macro_derive(l, attributes(m), n)]\n+//~^ ERROR: attribute must have either one or two arguments\n+pub fn foo8(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n+    input\n+}"}, {"sha": "70b778b1030e7eb21228e345452b8a0a38718f9a", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/derive-b.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(proc_macro)]\n+#![feature(proc_macro_lib)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(B, attributes(B))]\n+pub fn derive_b(input: TokenStream) -> TokenStream {\n+    \"\".parse().unwrap()\n+}"}, {"sha": "4f4ed90f8fca2be697a1c707da5218aaa2431ad5", "filename": "src/test/compile-fail-fulldeps/proc-macro/expand-to-unstable-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fexpand-to-unstable-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fexpand-to-unstable-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fexpand-to-unstable-2.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -17,8 +17,8 @@\n extern crate derive_unstable_2;\n \n #[derive(Unstable)]\n-struct A;\n //~^ ERROR: reserved for internal compiler\n+struct A;\n \n fn main() {\n     foo();"}, {"sha": "84ac776a765a2631f6505e54340482f7c1bfc620", "filename": "src/test/compile-fail-fulldeps/proc-macro/expand-to-unstable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fexpand-to-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fexpand-to-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fexpand-to-unstable.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -17,8 +17,8 @@\n extern crate derive_unstable;\n \n #[derive(Unstable)]\n-struct A;\n //~^ ERROR: use of unstable library feature\n+struct A;\n \n fn main() {\n     unsafe { foo(); }"}, {"sha": "2a68accf91f714ca5b824bde2e339382f5578632", "filename": "src/test/compile-fail-fulldeps/proc-macro/item-error.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fitem-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fitem-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fitem-error.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-b.rs\n+\n+#![feature(proc_macro)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate derive_b;\n+\n+#[derive(B)]\n+struct A {\n+    a: &u64\n+//~^ ERROR: missing lifetime specifier\n+}\n+\n+fn main() {\n+}"}, {"sha": "651a277d4abd5eab31d98efce63c2ec8282046b2", "filename": "src/test/compile-fail-fulldeps/proc-macro/proc-macro-attributes.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-b.rs\n+\n+#![feature(proc_macro)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate derive_b;\n+\n+#[derive(B)]\n+#[B]\n+#[C] //~ ERROR: The attribute `C` is currently unknown to the compiler\n+#[B(D)]\n+#[B(E = \"foo\")]\n+struct B;\n+\n+fn main() {}"}, {"sha": "1d34049db249fa74ef531728ef38a0712bfbf604", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/add-impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fadd-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fadd-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fadd-impl.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -21,13 +21,12 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(AddImpl)]\n // #[cfg(proc_macro)]\n pub fn derive(input: TokenStream) -> TokenStream {\n-    (input.to_string() + \"\n-        impl B {\n+    \"impl B {\n             fn foo(&self) {}\n         }\n \n         fn foo() {}\n \n         mod bar { pub fn foo() {} }\n-    \").parse().unwrap()\n+    \".parse().unwrap()\n }"}, {"sha": "7260bc4a5e7bb275b72059598f2c2ba56f56f954", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/append-impl.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fappend-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fappend-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fappend-impl.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -21,11 +21,8 @@ use proc_macro::TokenStream;\n \n #[proc_macro_derive(Append)]\n pub fn derive_a(input: TokenStream) -> TokenStream {\n-    let mut input = input.to_string();\n-    input.push_str(\"\n-        impl Append for A {\n-            fn foo(&self) {}\n-        }\n-    \");\n-    input.parse().unwrap()\n+    \"impl Append for A {\n+         fn foo(&self) {}\n+     }\n+    \".parse().unwrap()\n }"}, {"sha": "eaada5542274c148ac528e51b6ab56ca7c75dcd2", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-a.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -23,5 +23,5 @@ pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n     assert!(input.contains(\"struct A;\"));\n     assert!(input.contains(\"#[derive(Debug, PartialEq, Eq, Copy, Clone)]\"));\n-    \"#[derive(Debug, PartialEq, Eq, Copy, Clone)] struct A;\".parse().unwrap()\n+    \"\".parse().unwrap()\n }"}, {"sha": "a02b798c8023e3b21bd58b2d15861664c693d685", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-b.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-b.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro)]\n+#![feature(proc_macro_lib)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(B, attributes(B, C))]\n+pub fn derive(input: TokenStream) -> TokenStream {\n+    let input = input.to_string();\n+    assert!(input.contains(\"#[B]\"));\n+    assert!(input.contains(\"struct B {\"));\n+    assert!(input.contains(\"#[C]\"));\n+    assert!(input.contains(\"#[derive(Debug, PartialEq, Eq, Copy, Clone)]\"));\n+    \"\".parse().unwrap()\n+}"}, {"sha": "bc8a0d575913b083a695b0a13fe4d11263c8dcd0", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-same-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -21,7 +21,7 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(AToB)]\n pub fn derive1(input: TokenStream) -> TokenStream {\n     println!(\"input1: {:?}\", input.to_string());\n-    assert_eq!(input.to_string(), \"#[derive(BToC)]\\nstruct A;\\n\");\n+    assert_eq!(input.to_string(), \"struct A;\\n\");\n     \"#[derive(BToC)] struct B;\".parse().unwrap()\n }\n "}, {"sha": "50eaf035962f13acdf8090a0fc1e7e250afb1401", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/expand-with-a-macro.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -24,8 +24,6 @@ pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n     assert!(input.contains(\"struct A;\"));\n     r#\"\n-        struct A;\n-\n         impl A {\n             fn a(&self) {\n                 panic!(\"hello\");"}, {"sha": "f5bb93f012490d32f75fdb55dc68fcca8cf46b54", "filename": "src/test/run-pass-fulldeps/proc-macro/derive-b.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-b.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-b.rs\n+// ignore-stage1\n+\n+#![feature(proc_macro)]\n+\n+#[macro_use]\n+extern crate derive_b;\n+\n+#[derive(Debug, PartialEq, B, Eq, Copy, Clone)]\n+#[B]\n+struct B {\n+    #[C]\n+    a: u64\n+}\n+\n+fn main() {\n+    B { a: 3 };\n+    assert_eq!(B { a: 3 }, B { a: 3 });\n+    let b = B { a: 3 };\n+    let _d = b;\n+    let _e = b;\n+}"}, {"sha": "608f86bca576899a7ce06a11419baecb4c67869c", "filename": "src/test/run-pass-fulldeps/proc-macro/derive-same-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-same-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebd7c50a0b9236af4389b00c97b00a59d9fa747/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-same-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fderive-same-struct.rs?ref=5ebd7c50a0b9236af4389b00c97b00a59d9fa747", "patch": "@@ -15,7 +15,7 @@\n #[macro_use]\n extern crate derive_same_struct;\n \n-#[derive(AToB, BToC)]\n+#[derive(AToB)]\n struct A;\n \n fn main() {"}]}