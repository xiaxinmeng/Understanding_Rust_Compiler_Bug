{"sha": "edebf77e0090195bf80c0d8cda821e1bf9d03053", "node_id": "C_kwDOAAsO6NoAKGVkZWJmNzdlMDA5MDE5NWJmODBjMGQ4Y2RhODIxZTFiZjlkMDMwNTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-02T13:36:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-02T13:36:27Z"}, "message": "Auto merge of #89408 - Mark-Simulacrum:fix-query-nondet, r=petrochenkov\n\nAvoid nondeterminism in trimmed_def_paths\n\nPreviously this query depended on the global interning order of Symbols, which\nmeant that irrelevant changes could influence the query and cause\nrecompilations. This commit ensures that the return set is stable and will not\nbe affected by the global order by deterministically (in lexicographic order)\nchoosing a name to use if there are multiple names for a single DefId.\n\nThis should fix the cause of the [regressions] in #83343.\n\n[regressions]: https://perf.rust-lang.org/compare.html?start=9620f3a84b079decfdc2e557be007580b097fe43&end=addb4da686a97da46159f0123cb6cdc2ce3d7fdb", "tree": {"sha": "60939fe2b181727d17aef64d96edf9830b39caaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60939fe2b181727d17aef64d96edf9830b39caaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edebf77e0090195bf80c0d8cda821e1bf9d03053", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edebf77e0090195bf80c0d8cda821e1bf9d03053", "html_url": "https://github.com/rust-lang/rust/commit/edebf77e0090195bf80c0d8cda821e1bf9d03053", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edebf77e0090195bf80c0d8cda821e1bf9d03053/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b27661eb33c74cb514dba059b47d86b6582ac1c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b27661eb33c74cb514dba059b47d86b6582ac1c2", "html_url": "https://github.com/rust-lang/rust/commit/b27661eb33c74cb514dba059b47d86b6582ac1c2"}, {"sha": "56fcf0725a164f16b9d7f1ff8fe2f3d6b4aab3db", "url": "https://api.github.com/repos/rust-lang/rust/commits/56fcf0725a164f16b9d7f1ff8fe2f3d6b4aab3db", "html_url": "https://github.com/rust-lang/rust/commit/56fcf0725a164f16b9d7f1ff8fe2f3d6b4aab3db"}], "stats": {"total": 25, "additions": 23, "deletions": 2}, "files": [{"sha": "f8a476266d657c07c9df10d89b4466418c58c203", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/edebf77e0090195bf80c0d8cda821e1bf9d03053/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edebf77e0090195bf80c0d8cda821e1bf9d03053/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=edebf77e0090195bf80c0d8cda821e1bf9d03053", "patch": "@@ -2408,7 +2408,7 @@ fn for_each_def(tcx: TyCtxt<'_>, mut collect_fn: impl for<'b> FnMut(&'b Ident, N\n ///\n /// The implementation uses similar import discovery logic to that of 'use' suggestions.\n fn trimmed_def_paths(tcx: TyCtxt<'_>, (): ()) -> FxHashMap<DefId, Symbol> {\n-    let mut map = FxHashMap::default();\n+    let mut map: FxHashMap<DefId, Symbol> = FxHashMap::default();\n \n     if let TrimmedDefPaths::GoodPath = tcx.sess.opts.trimmed_def_paths {\n         // For good paths causing this bug, the `rustc_middle::ty::print::with_no_trimmed_paths`\n@@ -2446,8 +2446,29 @@ fn trimmed_def_paths(tcx: TyCtxt<'_>, (): ()) -> FxHashMap<DefId, Symbol> {\n     });\n \n     for ((_, symbol), opt_def_id) in unique_symbols_rev.drain() {\n+        use std::collections::hash_map::Entry::{Occupied, Vacant};\n+\n         if let Some(def_id) = opt_def_id {\n-            map.insert(def_id, symbol);\n+            match map.entry(def_id) {\n+                Occupied(mut v) => {\n+                    // A single DefId can be known under multiple names (e.g.,\n+                    // with a `pub use ... as ...;`). We need to ensure that the\n+                    // name placed in this map is chosen deterministically, so\n+                    // if we find multiple names (`symbol`) resolving to the\n+                    // same `def_id`, we prefer the lexicographically smallest\n+                    // name.\n+                    //\n+                    // Any stable ordering would be fine here though.\n+                    if *v.get() != symbol {\n+                        if v.get().as_str() > symbol.as_str() {\n+                            v.insert(symbol);\n+                        }\n+                    }\n+                }\n+                Vacant(v) => {\n+                    v.insert(symbol);\n+                }\n+            }\n         }\n     }\n "}]}