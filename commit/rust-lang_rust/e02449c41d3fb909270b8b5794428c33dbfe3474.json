{"sha": "e02449c41d3fb909270b8b5794428c33dbfe3474", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMjQ0OWM0MWQzZmI5MDkyNzBiOGI1Nzk0NDI4YzMzZGJmZTM0NzQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-22T18:57:26Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-22T18:57:26Z"}, "message": "Merge pull request #4571 from thestinger/container\n\nmore work on container traits", "tree": {"sha": "808bcaf8d181903d2e82c0cd7702055a0c8cfbfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/808bcaf8d181903d2e82c0cd7702055a0c8cfbfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e02449c41d3fb909270b8b5794428c33dbfe3474", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e02449c41d3fb909270b8b5794428c33dbfe3474", "html_url": "https://github.com/rust-lang/rust/commit/e02449c41d3fb909270b8b5794428c33dbfe3474", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e02449c41d3fb909270b8b5794428c33dbfe3474/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c276daeb9fe3876c2a37ab2122de5d3ab1e2d23", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c276daeb9fe3876c2a37ab2122de5d3ab1e2d23", "html_url": "https://github.com/rust-lang/rust/commit/0c276daeb9fe3876c2a37ab2122de5d3ab1e2d23"}, {"sha": "6f4d86ed904ed7ae04edc4226a0a1c2d39067d57", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f4d86ed904ed7ae04edc4226a0a1c2d39067d57", "html_url": "https://github.com/rust-lang/rust/commit/6f4d86ed904ed7ae04edc4226a0a1c2d39067d57"}], "stats": {"total": 311, "additions": 191, "deletions": 120}, "files": [{"sha": "062416838cc49cc350857c3b31ffd39aef5fdb19", "filename": "src/libcore/container.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e02449c41d3fb909270b8b5794428c33dbfe3474/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02449c41d3fb909270b8b5794428c33dbfe3474/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=e02449c41d3fb909270b8b5794428c33dbfe3474", "patch": "@@ -10,7 +10,46 @@\n \n //! Container traits\n \n-pub trait Set<T> {\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n+pub trait Container {\n+    /// Return the number of elements in the container\n+    pure fn len(&self) -> uint;\n+\n+    /// Return true if the container contains no elements\n+    pure fn is_empty(&self) -> bool;\n+}\n+\n+pub trait Mutable: Container {\n+    /// Clear the container, removing all values.\n+    fn clear(&mut self);\n+}\n+\n+pub trait Map<K, V>: Mutable {\n+    /// Return true if the map contains a value for the specified key\n+    pure fn contains_key(&self, key: &K) -> bool;\n+\n+    /// Visit all key-value pairs\n+    pure fn each(&self, f: fn(&K, &V) -> bool);\n+\n+    /// Visit all keys\n+    pure fn each_key(&self, f: fn(&K) -> bool);\n+\n+    /// Visit all values\n+    pure fn each_value(&self, f: fn(&V) -> bool);\n+\n+    /// Insert a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Return true if the key did\n+    /// not already exist in the map.\n+    fn insert(&mut self, key: K, value: V) -> bool;\n+\n+    /// Remove a key-value pair from the map. Return true if the key\n+    /// was present in the map, otherwise false.\n+    fn remove(&mut self, key: &K) -> bool;\n+}\n+\n+pub trait Set<T>: Mutable {\n     /// Return true if the set contains a value\n     pure fn contains(&self, value: &T) -> bool;\n "}, {"sha": "dc4e24c4f8a3c882ab696c71611214fe6709865e", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 54, "deletions": 72, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/e02449c41d3fb909270b8b5794428c33dbfe3474/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02449c41d3fb909270b8b5794428c33dbfe3474/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=e02449c41d3fb909270b8b5794428c33dbfe3474", "patch": "@@ -23,31 +23,10 @@ use hash::Hash;\n use prelude::*;\n use to_bytes::IterBytes;\n \n-pub trait SendMap<K:Eq Hash, V: Copy> {\n-    // FIXME(#3148)  ^^^^ once find_ref() works, we can drop V:copy\n-\n-    fn insert(&mut self, k: K, +v: V) -> bool;\n-    fn remove(&mut self, k: &K) -> bool;\n-    fn pop(&mut self, k: &K) -> Option<V>;\n-    fn swap(&mut self, k: K, +v: V) -> Option<V>;\n-    fn consume(&mut self, f: fn(K, V));\n-    fn clear(&mut self);\n-    pure fn len(&const self) -> uint;\n-    pure fn is_empty(&const self) -> bool;\n-    pure fn contains_key(&const self, k: &K) -> bool;\n-    pure fn each(&self, blk: fn(k: &K, v: &V) -> bool);\n-    pure fn each_key_ref(&self, blk: fn(k: &K) -> bool);\n-    pure fn each_value_ref(&self, blk: fn(v: &V) -> bool);\n-    pure fn find(&const self, k: &K) -> Option<V>;\n-    pure fn get(&const self, k: &K) -> V;\n-    pure fn find_ref(&self, k: &K) -> Option<&self/V>;\n-    pure fn get_ref(&self, k: &K) -> &self/V;\n-}\n-\n /// Open addressing with linear probing.\n pub mod linear {\n     use iter::BaseIter;\n-    use container::Set;\n+    use container::{Container, Mutable, Map, Set};\n     use cmp::Eq;\n     use cmp;\n     use hash::Hash;\n@@ -279,7 +258,48 @@ pub mod linear {\n         }\n     }\n \n-    impl<K:Hash IterBytes Eq,V> LinearMap<K,V> {\n+    impl <K: Hash IterBytes Eq, V> LinearMap<K, V>: Container {\n+        pure fn len(&self) -> uint { self.size }\n+        pure fn is_empty(&self) -> bool { self.len() == 0 }\n+    }\n+\n+    impl <K: Hash IterBytes Eq, V> LinearMap<K, V>: Mutable {\n+        fn clear(&mut self) {\n+            for uint::range(0, self.buckets.len()) |idx| {\n+                self.buckets[idx] = None;\n+            }\n+            self.size = 0;\n+        }\n+    }\n+\n+    impl <K: Hash IterBytes Eq, V> LinearMap<K, V>: Map<K, V> {\n+        pure fn contains_key(&self, k: &K) -> bool {\n+            match self.bucket_for_key(self.buckets, k) {\n+                FoundEntry(_) => {true}\n+                TableFull | FoundHole(_) => {false}\n+            }\n+        }\n+\n+        pure fn each(&self, blk: fn(k: &K, v: &V) -> bool) {\n+            for vec::each(self.buckets) |slot| {\n+                let mut broke = false;\n+                do slot.iter |bucket| {\n+                    if !blk(&bucket.key, &bucket.value) {\n+                        broke = true; // FIXME(#3064) just write \"break;\"\n+                    }\n+                }\n+                if broke { break; }\n+            }\n+        }\n+\n+        pure fn each_key(&self, blk: fn(k: &K) -> bool) {\n+            self.each(|k, _v| blk(k))\n+        }\n+\n+        pure fn each_value(&self, blk: fn(v: &V) -> bool) {\n+            self.each(|_k, v| blk(v))\n+        }\n+\n         fn insert(&mut self, k: K, v: V) -> bool {\n             if self.size >= self.resize_at {\n                 // n.b.: We could also do this after searching, so\n@@ -301,7 +321,9 @@ pub mod linear {\n                 None => false,\n             }\n         }\n+    }\n \n+    impl<K:Hash IterBytes Eq,V> LinearMap<K,V> {\n         fn pop(&mut self, k: &K) -> Option<V> {\n             let hash = k.hash_keyed(self.k0, self.k1) as uint;\n             self.pop_internal(hash, k)\n@@ -347,29 +369,6 @@ pub mod linear {\n             }\n         }\n \n-        fn clear(&mut self) {\n-            for uint::range(0, self.buckets.len()) |idx| {\n-                self.buckets[idx] = None;\n-            }\n-            self.size = 0;\n-        }\n-\n-        pure fn len(&const self) -> uint {\n-            self.size\n-        }\n-\n-        pure fn is_empty(&const self) -> bool {\n-            self.len() == 0\n-        }\n-\n-        pure fn contains_key(&const self,\n-                        k: &K) -> bool {\n-            match self.bucket_for_key(self.buckets, k) {\n-                FoundEntry(_) => {true}\n-                TableFull | FoundHole(_) => {false}\n-            }\n-        }\n-\n         pure fn find_ref(&self, k: &K) -> Option<&self/V> {\n             match self.bucket_for_key(self.buckets, k) {\n                 FoundEntry(idx) => {\n@@ -396,26 +395,6 @@ pub mod linear {\n                 None => fail fmt!(\"No entry found for key: %?\", k),\n             }\n         }\n-\n-        pure fn each(&self, blk: fn(k: &K, v: &V) -> bool) {\n-            for vec::each(self.buckets) |slot| {\n-                let mut broke = false;\n-                do slot.iter |bucket| {\n-                    if !blk(&bucket.key, &bucket.value) {\n-                        broke = true; // FIXME(#3064) just write \"break;\"\n-                    }\n-                }\n-                if broke { break; }\n-            }\n-        }\n-\n-        pure fn each_key(&self, blk: fn(k: &K) -> bool) {\n-            self.each(|k, _v| blk(k))\n-        }\n-\n-        pure fn each_value(&self, blk: fn(v: &V) -> bool) {\n-            self.each(|_k, v| blk(v))\n-        }\n     }\n \n     impl<K:Hash IterBytes Eq, V: Copy> LinearMap<K,V> {\n@@ -482,6 +461,15 @@ pub mod linear {\n         }\n     }\n \n+    impl <T: Hash IterBytes Eq> LinearSet<T>: Container {\n+        pure fn len(&self) -> uint { self.map.len() }\n+        pure fn is_empty(&self) -> bool { self.map.is_empty() }\n+    }\n+\n+    impl <T: Hash IterBytes Eq> LinearSet<T>: Mutable {\n+        fn clear(&mut self) { self.map.clear() }\n+    }\n+\n     impl <T: Hash IterBytes Eq> LinearSet<T>: Set<T> {\n         /// Return true if the set contains a value\n         pure fn contains(&self, value: &T) -> bool {\n@@ -500,12 +488,6 @@ pub mod linear {\n     impl <T: Hash IterBytes Eq> LinearSet<T> {\n         /// Create an empty LinearSet\n         static fn new() -> LinearSet<T> { LinearSet{map: LinearMap()} }\n-\n-        /// Return the number of elements in the set\n-        pure fn len(&self) -> uint { self.map.len() }\n-\n-        /// Return true if the set contains no elements\n-        pure fn is_empty(&self) -> bool { self.map.is_empty() }\n     }\n }\n "}, {"sha": "ee78fafb60bad7ad811a07ce46e5fbd02fcfeb6c", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e02449c41d3fb909270b8b5794428c33dbfe3474/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02449c41d3fb909270b8b5794428c33dbfe3474/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=e02449c41d3fb909270b8b5794428c33dbfe3474", "patch": "@@ -10,6 +10,7 @@\n \n //! A priority queue implemented with a binary heap\n \n+use core::container::{Container, Mutable};\n use core::cmp::Ord;\n use core::prelude::*;\n use core::ptr::addr_of;\n@@ -24,6 +25,19 @@ pub struct PriorityQueue <T: Ord>{\n     priv data: ~[T],\n }\n \n+impl <T: Ord> PriorityQueue<T>: Container {\n+    /// Returns the length of the queue\n+    pure fn len(&self) -> uint { self.data.len() }\n+\n+    /// Returns true if a queue contains no elements\n+    pure fn is_empty(&self) -> bool { self.data.is_empty() }\n+}\n+\n+impl <T: Ord> PriorityQueue<T>: Mutable {\n+    /// Drop all items from the queue\n+    fn clear(&mut self) { self.data.truncate(0) }\n+}\n+\n impl <T: Ord> PriorityQueue<T> {\n     /// Returns the greatest item in the queue - fails if empty\n     pure fn top(&self) -> &self/T { &self.data[0] }\n@@ -33,12 +47,6 @@ impl <T: Ord> PriorityQueue<T> {\n         if self.is_empty() { None } else { Some(self.top()) }\n     }\n \n-    /// Returns the length of the queue\n-    pure fn len(&self) -> uint { self.data.len() }\n-\n-    /// Returns true if a queue contains no elements\n-    pure fn is_empty(&self) -> bool { self.data.is_empty() }\n-\n     /// Returns true if a queue contains some elements\n     pure fn is_not_empty(&self) -> bool { self.data.is_not_empty() }\n \n@@ -51,9 +59,6 @@ impl <T: Ord> PriorityQueue<T> {\n         vec::reserve_at_least(&mut self.data, n)\n     }\n \n-    /// Drop all items from the queue\n-    fn clear(&mut self) { self.data.truncate(0) }\n-\n     /// Pop the greatest item from the queue - fails if empty\n     fn pop(&mut self) -> T {\n         let mut item = self.data.pop();"}, {"sha": "0bb8738773c92ca9d1dae0ec716a7517dd9ee0ac", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 83, "deletions": 38, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/e02449c41d3fb909270b8b5794428c33dbfe3474/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02449c41d3fb909270b8b5794428c33dbfe3474/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=e02449c41d3fb909270b8b5794428c33dbfe3474", "patch": "@@ -14,7 +14,7 @@\n \n #[forbid(deprecated_mode)];\n \n-use core::container::Set;\n+use core::container::{Container, Mutable, Map, Set};\n use core::cmp::{Eq, Ord};\n use core::option::{Option, Some, None};\n use core::prelude::*;\n@@ -64,23 +64,30 @@ impl <K: Eq Ord, V: Eq> TreeMap<K, V>: Eq {\n             true\n         }\n     }\n-    pure fn ne(&self, other: &TreeMap<K, V>) -> bool {\n-        !self.eq(other)\n-    }\n+    pure fn ne(&self, other: &TreeMap<K, V>) -> bool { !self.eq(other) }\n }\n \n-impl <K: Ord, V> TreeMap<K, V> {\n-    /// Create an empty TreeMap\n-    static pure fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n-\n+impl <K: Ord, V> TreeMap<K, V>: Container {\n     /// Return the number of elements in the map\n     pure fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n     pure fn is_empty(&self) -> bool { self.root.is_none() }\n+}\n \n-    /// Return true if the map contains some elements\n-    pure fn is_not_empty(&self) -> bool { self.root.is_some() }\n+impl <K: Ord, V> TreeMap<K, V>: Mutable {\n+    /// Clear the map, removing all key-value pairs.\n+    fn clear(&mut self) {\n+        self.root = None;\n+        self.length = 0\n+    }\n+}\n+\n+impl <K: Ord, V> TreeMap<K, V>: Map<K, V> {\n+    /// Return true if the map contains a value for the specified key\n+    pure fn contains_key(&self, key: &K) -> bool {\n+        self.find(key).is_some()\n+    }\n \n     /// Visit all key-value pairs in order\n     pure fn each(&self, f: fn(&K, &V) -> bool) { each(&self.root, f) }\n@@ -91,6 +98,31 @@ impl <K: Ord, V> TreeMap<K, V> {\n     /// Visit all values in order\n     pure fn each_value(&self, f: fn(&V) -> bool) { self.each(|_, v| f(v)) }\n \n+    /// Insert a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Return true if the key did\n+    /// not already exist in the map.\n+    fn insert(&mut self, key: K, value: V) -> bool {\n+        let ret = insert(&mut self.root, key, value);\n+        if ret { self.length += 1 }\n+        ret\n+    }\n+\n+    /// Remove a key-value pair from the map. Return true if the key\n+    /// was present in the map, otherwise false.\n+    fn remove(&mut self, key: &K) -> bool {\n+        let ret = remove(&mut self.root, key);\n+        if ret { self.length -= 1 }\n+        ret\n+    }\n+}\n+\n+impl <K: Ord, V> TreeMap<K, V> {\n+    /// Create an empty TreeMap\n+    static pure fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n+\n+    /// Return true if the map contains some elements\n+    pure fn is_not_empty(&self) -> bool { self.root.is_some() }\n+\n     /// Visit all key-value pairs in reverse order\n     pure fn each_reverse(&self, f: fn(&K, &V) -> bool) {\n         each_reverse(&self.root, f);\n@@ -106,11 +138,6 @@ impl <K: Ord, V> TreeMap<K, V> {\n         self.each_reverse(|_, v| f(v))\n     }\n \n-    /// Return true if the map contains a value for the specified key\n-    pure fn contains_key(&self, key: &K) -> bool {\n-        self.find(key).is_some()\n-    }\n-\n     /// Return the value corresponding to the key in the map\n     pure fn find(&self, key: &K) -> Option<&self/V> {\n         let mut current: &self/Option<~TreeNode<K, V>> = &self.root;\n@@ -131,23 +158,6 @@ impl <K: Ord, V> TreeMap<K, V> {\n         }\n     }\n \n-    /// Insert a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Return true if the key did\n-    /// not already exist in the map.\n-    fn insert(&mut self, key: K, value: V) -> bool {\n-        let ret = insert(&mut self.root, key, value);\n-        if ret { self.length += 1 }\n-        ret\n-    }\n-\n-    /// Remove a key-value pair from the map. Return true if the key\n-    /// was present in the map, otherwise false.\n-    fn remove(&mut self, key: &K) -> bool {\n-        let ret = remove(&mut self.root, key);\n-        if ret { self.length -= 1 }\n-        ret\n-    }\n-\n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n     pure fn iter(&self) -> TreeMapIterator/&self<K, V> {\n@@ -198,6 +208,19 @@ impl <T: Eq Ord> TreeSet<T>: Eq {\n     pure fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }\n }\n \n+impl <T: Ord> TreeSet<T>: Container {\n+    /// Return the number of elements in the map\n+    pure fn len(&self) -> uint { self.map.len() }\n+\n+    /// Return true if the map contains no elements\n+    pure fn is_empty(&self) -> bool { self.map.is_empty() }\n+}\n+\n+impl <T: Ord> TreeSet<T>: Mutable {\n+    /// Clear the set, removing all values.\n+    fn clear(&mut self) { self.map.clear() }\n+}\n+\n impl <T: Ord> TreeSet<T>: Set<T> {\n     /// Return true if the set contains a value\n     pure fn contains(&self, value: &T) -> bool {\n@@ -217,12 +240,6 @@ impl <T: Ord> TreeSet<T> {\n     /// Create an empty TreeSet\n     static pure fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n-    /// Return the number of elements in the set\n-    pure fn len(&self) -> uint { self.map.len() }\n-\n-    /// Return true if the set contains no elements\n-    pure fn is_empty(&self) -> bool { self.map.is_empty() }\n-\n     /// Return true if the set contains some elements\n     pure fn is_not_empty(&self) -> bool { self.map.is_not_empty() }\n \n@@ -626,6 +643,20 @@ mod test_treemap {\n         assert m.find(&2).unwrap() == &11;\n     }\n \n+    #[test]\n+    fn test_clear() {\n+        let mut m = TreeMap::new();\n+        m.clear();\n+        assert m.insert(5, 11);\n+        assert m.insert(12, -3);\n+        assert m.insert(19, 2);\n+        m.clear();\n+        assert m.find(&5).is_none();\n+        assert m.find(&12).is_none();\n+        assert m.find(&19).is_none();\n+        assert m.is_empty();\n+    }\n+\n     #[test]\n     fn u8_map() {\n         let mut m = TreeMap::new();\n@@ -846,6 +877,20 @@ mod test_treemap {\n mod test_set {\n     use super::*;\n \n+    #[test]\n+    fn test_clear() {\n+        let mut s = TreeSet::new();\n+        s.clear();\n+        assert s.insert(5);\n+        assert s.insert(12);\n+        assert s.insert(19);\n+        s.clear();\n+        assert !s.contains(&5);\n+        assert !s.contains(&12);\n+        assert !s.contains(&19);\n+        assert s.is_empty();\n+    }\n+\n     #[test]\n     fn test_disjoint() {\n         let mut xs = TreeSet::new();"}]}