{"sha": "1d3517907727ecd6fea3fc7132c4ae55b2d06958", "node_id": "C_kwDOAAsO6NoAKDFkMzUxNzkwNzcyN2VjZDZmZWEzZmM3MTMyYzRhZTU1YjJkMDY5NTg", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-04-12T06:46:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-12T06:46:56Z"}, "message": "Rollup merge of #95320 - JakobDegen:mir-docs, r=oli-obk\n\nDocument the current MIR semantics that are clear from existing code\n\nThis PR adds documentation to places, operands, rvalues, statementkinds, and terminatorkinds that describes their existing semantics and requirements. In many places the semantics depend on the Rust memory model or other T-Lang decisions - when this is the case, it is just noted as such with links to UCG issues where possible. I'm hopeful that none of the documentation added here can be used to justify optimizations that depend on the memory model. The documentation for places and operands probably comes closest to running afoul of this - if people think that it cannot be merged as is, it can definitely also be taken out.\n\nThe goal here is to only document parts of MIR that seem to be decided already, or are at least depended on by existing code. That leaves quite a number of open questions - those are marked as \"needs clarification.\" I'm not sure what to do with those in this PR - we obviously can't decide all these questions here. Should I just leave them in as is? Take them out? Keep them in but as `//` instead of `///` comments?\n\nIf this is too big to review at once, I can split this up.\n\nr? rust-lang/mir-opt", "tree": {"sha": "2349d7cdcec33ef35b5994d1028b591d22e0bb9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2349d7cdcec33ef35b5994d1028b591d22e0bb9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d3517907727ecd6fea3fc7132c4ae55b2d06958", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiVSBgCRBK7hj4Ov3rIwAAvH8IAJKmt6BvOGrzMq/2Pb6ectOh\nJIWN97bdyX6zUf47J9ddFLHz/sjEQzhhNz9GT5L9L5XHaUc4rbOAbeo2K+3zny7E\nqaO5lLXooFF/LkVIvdsFo7kDDWM+qkwcXz36o1tnrpHW+k/7C/mwprFqlCuRpRWx\nADlLH5vscf9fXb5OnLqogC55xLPF71bxfuopdHc7MfoWHIoWXoQkedmJRh40yxLn\nf5gAOVsTv/216xKQx6uTak5FLn72FViXQlySxslyc9mWkOEVzIRTYGu3rxm+8cKi\n5DBu/KK2jE9BoF2cRX71nbCJRl1yXe3hTSAqp2Sz1TscIOkXbUGJ4DwjZ5Ehpgg=\n=t4ju\n-----END PGP SIGNATURE-----\n", "payload": "tree 2349d7cdcec33ef35b5994d1028b591d22e0bb9b\nparent b8f4cb6231dc7d4ff9afe62de798af0dc18ae835\nparent 8732bf5db372e3b9297e854ce71851bbc6a90893\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1649746016 +0200\ncommitter GitHub <noreply@github.com> 1649746016 +0200\n\nRollup merge of #95320 - JakobDegen:mir-docs, r=oli-obk\n\nDocument the current MIR semantics that are clear from existing code\n\nThis PR adds documentation to places, operands, rvalues, statementkinds, and terminatorkinds that describes their existing semantics and requirements. In many places the semantics depend on the Rust memory model or other T-Lang decisions - when this is the case, it is just noted as such with links to UCG issues where possible. I'm hopeful that none of the documentation added here can be used to justify optimizations that depend on the memory model. The documentation for places and operands probably comes closest to running afoul of this - if people think that it cannot be merged as is, it can definitely also be taken out.\n\nThe goal here is to only document parts of MIR that seem to be decided already, or are at least depended on by existing code. That leaves quite a number of open questions - those are marked as \"needs clarification.\" I'm not sure what to do with those in this PR - we obviously can't decide all these questions here. Should I just leave them in as is? Take them out? Keep them in but as `//` instead of `///` comments?\n\nIf this is too big to review at once, I can split this up.\n\nr? rust-lang/mir-opt\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d3517907727ecd6fea3fc7132c4ae55b2d06958", "html_url": "https://github.com/rust-lang/rust/commit/1d3517907727ecd6fea3fc7132c4ae55b2d06958", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d3517907727ecd6fea3fc7132c4ae55b2d06958/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8f4cb6231dc7d4ff9afe62de798af0dc18ae835", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8f4cb6231dc7d4ff9afe62de798af0dc18ae835", "html_url": "https://github.com/rust-lang/rust/commit/b8f4cb6231dc7d4ff9afe62de798af0dc18ae835"}, {"sha": "8732bf5db372e3b9297e854ce71851bbc6a90893", "url": "https://api.github.com/repos/rust-lang/rust/commits/8732bf5db372e3b9297e854ce71851bbc6a90893", "html_url": "https://github.com/rust-lang/rust/commit/8732bf5db372e3b9297e854ce71851bbc6a90893"}], "stats": {"total": 778, "additions": 633, "deletions": 145}, "files": [{"sha": "01af95851357e481da64e819bfc32bb2e785ca08", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 185, "deletions": 44, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/1d3517907727ecd6fea3fc7132c4ae55b2d06958/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3517907727ecd6fea3fc7132c4ae55b2d06958/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=1d3517907727ecd6fea3fc7132c4ae55b2d06958", "patch": "@@ -3,15 +3,14 @@\n use rustc_index::bit_set::BitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::mir::traversal;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{\n-    AggregateKind, BasicBlock, Body, BorrowKind, Local, Location, MirPass, MirPhase, Operand,\n-    PlaceElem, PlaceRef, ProjectionElem, Rvalue, SourceScope, Statement, StatementKind, Terminator,\n-    TerminatorKind, START_BLOCK,\n+    traversal, AggregateKind, BasicBlock, BinOp, Body, BorrowKind, Local, Location, MirPass,\n+    MirPhase, Operand, Place, PlaceElem, PlaceRef, ProjectionElem, Rvalue, SourceScope, Statement,\n+    StatementKind, Terminator, TerminatorKind, UnOp, START_BLOCK,\n };\n use rustc_middle::ty::fold::BottomUpFolder;\n-use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeFoldable};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n use rustc_mir_dataflow::storage::AlwaysLiveLocals;\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n@@ -36,6 +35,13 @@ pub struct Validator {\n \n impl<'tcx> MirPass<'tcx> for Validator {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        // FIXME(JakobDegen): These bodies never instantiated in codegend anyway, so it's not\n+        // terribly important that they pass the validator. However, I think other passes might\n+        // still see them, in which case they might be surprised. It would probably be better if we\n+        // didn't put this through the MIR pipeline at all.\n+        if matches!(body.source.instance, InstanceDef::Intrinsic(..) | InstanceDef::Virtual(..)) {\n+            return;\n+        }\n         let def_id = body.source.def_id();\n         let param_env = tcx.param_env(def_id);\n         let mir_phase = self.mir_phase;\n@@ -240,58 +246,179 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n         self.super_projection_elem(local, proj_base, elem, context, location);\n     }\n \n-    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n-        match &statement.kind {\n-            StatementKind::Assign(box (dest, rvalue)) => {\n-                // LHS and RHS of the assignment must have the same type.\n-                let left_ty = dest.ty(&self.body.local_decls, self.tcx).ty;\n-                let right_ty = rvalue.ty(&self.body.local_decls, self.tcx);\n-                if !self.mir_assign_valid_types(right_ty, left_ty) {\n+    fn visit_place(&mut self, place: &Place<'tcx>, _: PlaceContext, _: Location) {\n+        // Set off any `bug!`s in the type computation code\n+        let _ = place.ty(&self.body.local_decls, self.tcx);\n+    }\n+\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        macro_rules! check_kinds {\n+            ($t:expr, $text:literal, $($patterns:tt)*) => {\n+                if !matches!(($t).kind(), $($patterns)*) {\n+                    self.fail(location, format!($text, $t));\n+                }\n+            };\n+        }\n+        match rvalue {\n+            Rvalue::Use(_) => {}\n+            Rvalue::Aggregate(agg_kind, _) => {\n+                let disallowed = match **agg_kind {\n+                    AggregateKind::Array(..) => false,\n+                    AggregateKind::Generator(..) => self.mir_phase >= MirPhase::GeneratorsLowered,\n+                    _ => self.mir_phase >= MirPhase::Deaggregated,\n+                };\n+                if disallowed {\n                     self.fail(\n                         location,\n-                        format!(\n-                            \"encountered `{:?}` with incompatible types:\\n\\\n-                            left-hand side has type: {}\\n\\\n-                            right-hand side has type: {}\",\n-                            statement.kind, left_ty, right_ty,\n-                        ),\n+                        format!(\"{:?} have been lowered to field assignments\", rvalue),\n+                    )\n+                }\n+            }\n+            Rvalue::Ref(_, BorrowKind::Shallow, _) => {\n+                if self.mir_phase >= MirPhase::DropsLowered {\n+                    self.fail(\n+                        location,\n+                        \"`Assign` statement with a `Shallow` borrow should have been removed after drop lowering phase\",\n                     );\n                 }\n-                match rvalue {\n-                    // The sides of an assignment must not alias. Currently this just checks whether the places\n-                    // are identical.\n-                    Rvalue::Use(Operand::Copy(src) | Operand::Move(src)) => {\n-                        if dest == src {\n+            }\n+            Rvalue::Len(p) => {\n+                let pty = p.ty(&self.body.local_decls, self.tcx).ty;\n+                check_kinds!(\n+                    pty,\n+                    \"Cannot compute length of non-array type {:?}\",\n+                    ty::Array(..) | ty::Slice(..)\n+                );\n+            }\n+            Rvalue::BinaryOp(op, vals) | Rvalue::CheckedBinaryOp(op, vals) => {\n+                use BinOp::*;\n+                let a = vals.0.ty(&self.body.local_decls, self.tcx);\n+                let b = vals.1.ty(&self.body.local_decls, self.tcx);\n+                match op {\n+                    Offset => {\n+                        check_kinds!(a, \"Cannot offset non-pointer type {:?}\", ty::RawPtr(..));\n+                        if b != self.tcx.types.isize && b != self.tcx.types.usize {\n+                            self.fail(location, format!(\"Cannot offset by non-isize type {:?}\", b));\n+                        }\n+                    }\n+                    Eq | Lt | Le | Ne | Ge | Gt => {\n+                        for x in [a, b] {\n+                            check_kinds!(\n+                                x,\n+                                \"Cannot compare type {:?}\",\n+                                ty::Bool\n+                                    | ty::Char\n+                                    | ty::Int(..)\n+                                    | ty::Uint(..)\n+                                    | ty::Float(..)\n+                                    | ty::RawPtr(..)\n+                                    | ty::FnPtr(..)\n+                            )\n+                        }\n+                        // None of the possible types have lifetimes, so we can just compare\n+                        // directly\n+                        if a != b {\n                             self.fail(\n                                 location,\n-                                \"encountered `Assign` statement with overlapping memory\",\n+                                format!(\"Cannot compare unequal types {:?} and {:?}\", a, b),\n                             );\n                         }\n                     }\n-                    Rvalue::Aggregate(agg_kind, _) => {\n-                        let disallowed = match **agg_kind {\n-                            AggregateKind::Array(..) => false,\n-                            AggregateKind::Generator(..) => {\n-                                self.mir_phase >= MirPhase::GeneratorsLowered\n-                            }\n-                            _ => self.mir_phase >= MirPhase::Deaggregated,\n-                        };\n-                        if disallowed {\n+                    Shl | Shr => {\n+                        for x in [a, b] {\n+                            check_kinds!(\n+                                x,\n+                                \"Cannot shift non-integer type {:?}\",\n+                                ty::Uint(..) | ty::Int(..)\n+                            )\n+                        }\n+                    }\n+                    BitAnd | BitOr | BitXor => {\n+                        for x in [a, b] {\n+                            check_kinds!(\n+                                x,\n+                                \"Cannot perform bitwise op on type {:?}\",\n+                                ty::Uint(..) | ty::Int(..) | ty::Bool\n+                            )\n+                        }\n+                        if a != b {\n                             self.fail(\n                                 location,\n-                                format!(\"{:?} have been lowered to field assignments\", rvalue),\n-                            )\n+                                format!(\n+                                    \"Cannot perform bitwise op on unequal types {:?} and {:?}\",\n+                                    a, b\n+                                ),\n+                            );\n                         }\n                     }\n-                    Rvalue::Ref(_, BorrowKind::Shallow, _) => {\n-                        if self.mir_phase >= MirPhase::DropsLowered {\n+                    Add | Sub | Mul | Div | Rem => {\n+                        for x in [a, b] {\n+                            check_kinds!(\n+                                x,\n+                                \"Cannot perform op on type {:?}\",\n+                                ty::Uint(..) | ty::Int(..) | ty::Float(..)\n+                            )\n+                        }\n+                        if a != b {\n                             self.fail(\n                                 location,\n-                                \"`Assign` statement with a `Shallow` borrow should have been removed after drop lowering phase\",\n+                                format!(\"Cannot perform op on unequal types {:?} and {:?}\", a, b),\n                             );\n                         }\n                     }\n-                    _ => {}\n+                }\n+            }\n+            Rvalue::UnaryOp(op, operand) => {\n+                let a = operand.ty(&self.body.local_decls, self.tcx);\n+                match op {\n+                    UnOp::Neg => {\n+                        check_kinds!(a, \"Cannot negate type {:?}\", ty::Int(..) | ty::Float(..))\n+                    }\n+                    UnOp::Not => {\n+                        check_kinds!(\n+                            a,\n+                            \"Cannot binary not type {:?}\",\n+                            ty::Int(..) | ty::Uint(..) | ty::Bool\n+                        );\n+                    }\n+                }\n+            }\n+            Rvalue::ShallowInitBox(operand, _) => {\n+                let a = operand.ty(&self.body.local_decls, self.tcx);\n+                check_kinds!(a, \"Cannot shallow init type {:?}\", ty::RawPtr(..));\n+            }\n+            _ => {}\n+        }\n+        self.super_rvalue(rvalue, location);\n+    }\n+\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+        match &statement.kind {\n+            StatementKind::Assign(box (dest, rvalue)) => {\n+                // LHS and RHS of the assignment must have the same type.\n+                let left_ty = dest.ty(&self.body.local_decls, self.tcx).ty;\n+                let right_ty = rvalue.ty(&self.body.local_decls, self.tcx);\n+                if !self.mir_assign_valid_types(right_ty, left_ty) {\n+                    self.fail(\n+                        location,\n+                        format!(\n+                            \"encountered `{:?}` with incompatible types:\\n\\\n+                            left-hand side has type: {}\\n\\\n+                            right-hand side has type: {}\",\n+                            statement.kind, left_ty, right_ty,\n+                        ),\n+                    );\n+                }\n+                // FIXME(JakobDegen): Check this for all rvalues, not just this one.\n+                if let Rvalue::Use(Operand::Copy(src) | Operand::Move(src)) = rvalue {\n+                    // The sides of an assignment must not alias. Currently this just checks whether\n+                    // the places are identical.\n+                    if dest == src {\n+                        self.fail(\n+                            location,\n+                            \"encountered `Assign` statement with overlapping memory\",\n+                        );\n+                    }\n                 }\n             }\n             StatementKind::AscribeUserType(..) => {\n@@ -512,6 +639,9 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::Yield { resume, drop, .. } => {\n+                if self.body.generator.is_none() {\n+                    self.fail(location, \"`Yield` cannot appear outside generator bodies\");\n+                }\n                 if self.mir_phase >= MirPhase::GeneratorsLowered {\n                     self.fail(location, \"`Yield` should have been replaced by generator lowering\");\n                 }\n@@ -551,18 +681,29 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::GeneratorDrop => {\n+                if self.body.generator.is_none() {\n+                    self.fail(location, \"`GeneratorDrop` cannot appear outside generator bodies\");\n+                }\n                 if self.mir_phase >= MirPhase::GeneratorsLowered {\n                     self.fail(\n                         location,\n                         \"`GeneratorDrop` should have been replaced by generator lowering\",\n                     );\n                 }\n             }\n-            // Nothing to validate for these.\n-            TerminatorKind::Resume\n-            | TerminatorKind::Abort\n-            | TerminatorKind::Return\n-            | TerminatorKind::Unreachable => {}\n+            TerminatorKind::Resume | TerminatorKind::Abort => {\n+                let bb = location.block;\n+                if !self.body.basic_blocks()[bb].is_cleanup {\n+                    self.fail(location, \"Cannot `Resume` or `Abort` from non-cleanup basic block\")\n+                }\n+            }\n+            TerminatorKind::Return => {\n+                let bb = location.block;\n+                if self.body.basic_blocks()[bb].is_cleanup {\n+                    self.fail(location, \"Cannot `Return` from cleanup basic block\")\n+                }\n+            }\n+            TerminatorKind::Unreachable => {}\n         }\n \n         self.super_terminator(terminator, location);"}, {"sha": "fd2b5f5335f69689407c5041f275536ae33d6b8f", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d3517907727ecd6fea3fc7132c4ae55b2d06958/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3517907727ecd6fea3fc7132c4ae55b2d06958/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=1d3517907727ecd6fea3fc7132c4ae55b2d06958", "patch": "@@ -59,6 +59,7 @@\n #![feature(unwrap_infallible)]\n #![feature(decl_macro)]\n #![feature(drain_filter)]\n+#![feature(intra_doc_pointers)]\n #![recursion_limit = \"512\"]\n #![allow(rustc::potential_query_instability)]\n "}, {"sha": "9f7832c8a64a2486e6435aa02238732941a28996", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 300, "deletions": 53, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/1d3517907727ecd6fea3fc7132c4ae55b2d06958/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3517907727ecd6fea3fc7132c4ae55b2d06958/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=1d3517907727ecd6fea3fc7132c4ae55b2d06958", "patch": "@@ -127,12 +127,24 @@ pub trait MirPass<'tcx> {\n /// The various \"big phases\" that MIR goes through.\n ///\n /// These phases all describe dialects of MIR. Since all MIR uses the same datastructures, the\n-/// dialects forbid certain variants or values in certain phases.\n+/// dialects forbid certain variants or values in certain phases. The sections below summarize the\n+/// changes, but do not document them thoroughly. The full documentation is found in the appropriate\n+/// documentation for the thing the change is affecting.\n ///\n /// Warning: ordering of variants is significant.\n #[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n #[derive(HashStable)]\n pub enum MirPhase {\n+    /// The dialect of MIR used during all phases before `DropsLowered` is the same. This is also\n+    /// the MIR that analysis such as borrowck uses.\n+    ///\n+    /// One important thing to remember about the behavior of this section of MIR is that drop terminators\n+    /// (including drop and replace) are *conditional*. The elaborate drops pass will then replace each\n+    /// instance of a drop terminator with a nop, an unconditional drop, or a drop conditioned on a drop\n+    /// flag. Of course, this means that it is important that the drop elaboration can accurately recognize\n+    /// when things are initialized and when things are de-initialized. That means any code running on this\n+    /// version of MIR must be sure to produce output that drop elaboration can reason about. See the\n+    /// section on the drop terminatorss for more details.\n     Built = 0,\n     // FIXME(oli-obk): it's unclear whether we still need this phase (and its corresponding query).\n     // We used to have this for pre-miri MIR based const eval.\n@@ -162,6 +174,16 @@ pub enum MirPhase {\n     /// And the following variant is allowed:\n     /// * [`StatementKind::SetDiscriminant`]\n     Deaggregated = 4,\n+    /// Before this phase, generators are in the \"source code\" form, featuring `yield` statements\n+    /// and such. With this phase change, they are transformed into a proper state machine. Running\n+    /// optimizations before this change can be potentially dangerous because the source code is to\n+    /// some extent a \"lie.\" In particular, `yield` terminators effectively make the value of all\n+    /// locals visible to the caller. This means that dead store elimination before them, or code\n+    /// motion across them, is not correct in general. This is also exasperated by type checking\n+    /// having pre-computed a list of the types that it thinks are ok to be live across a yield\n+    /// point - this is necessary to decide eg whether autotraits are implemented. Introducing new\n+    /// types across a yield point will lead to ICEs becaues of this.\n+    ///\n     /// Beginning with this phase, the following variants are disallowed:\n     /// * [`TerminatorKind::Yield`](terminator::TerminatorKind::Yield)\n     /// * [`TerminatorKind::GeneratorDrop](terminator::TerminatorKind::GeneratorDrop)\n@@ -1573,18 +1595,45 @@ impl Statement<'_> {\n /// causing an ICE if they are violated.\n #[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable)]\n pub enum StatementKind<'tcx> {\n-    /// Write the RHS Rvalue to the LHS Place.\n+    /// Assign statements roughly correspond to an assignment in Rust proper (`x = ...`) except\n+    /// without the possibility of dropping the previous value (that must be done separately, if at\n+    /// all). The *exact* way this works is undecided. It probably does something like evaluating\n+    /// the LHS to a place and the RHS to a value, and then storing the value to the place. Various\n+    /// parts of this may do type specific things that are more complicated than simply copying\n+    /// bytes.\n+    ///\n+    /// **Needs clarification**: The implication of the above idea would be that assignment implies\n+    /// that the resulting value is initialized. I believe we could commit to this separately from\n+    /// committing to whatever part of the memory model we would need to decide on to make the above\n+    /// paragragh precise. Do we want to?\n+    ///\n+    /// Assignments in which the types of the place and rvalue differ are not well-formed.\n+    ///\n+    /// **Needs clarification**: Do we ever want to worry about non-free (in the body) lifetimes for\n+    /// the typing requirement in post drop-elaboration MIR? I think probably not - I'm not sure we\n+    /// could meaningfully require this anyway. How about free lifetimes? Is ignoring this\n+    /// interesting for optimizations? Do we want to allow such optimizations?\n     ///\n-    /// The LHS place may not overlap with any memory accessed on the RHS.\n+    /// **Needs clarification**: We currently require that the LHS place not overlap with any place\n+    /// read as part of computation of the RHS for some rvalues (generally those not producing\n+    /// primitives). This requirement is under discussion in [#68364]. As a part of this discussion,\n+    /// it is also unclear in what order the components are evaluated.\n+    ///\n+    /// [#68364]: https://github.com/rust-lang/rust/issues/68364\n+    ///\n+    /// See [`Rvalue`] documentation for details on each of those.\n     Assign(Box<(Place<'tcx>, Rvalue<'tcx>)>),\n \n-    /// This represents all the reading that a pattern match may do\n-    /// (e.g., inspecting constants and discriminant values), and the\n-    /// kind of pattern it comes from. This is in order to adapt potential\n-    /// error messages to these specific patterns.\n+    /// This represents all the reading that a pattern match may do (e.g., inspecting constants and\n+    /// discriminant values), and the kind of pattern it comes from. This is in order to adapt\n+    /// potential error messages to these specific patterns.\n     ///\n     /// Note that this also is emitted for regular `let` bindings to ensure that locals that are\n     /// never accessed still get some sanity checks for, e.g., `let x: ! = ..;`\n+    ///\n+    /// When executed at runtime this is a nop.\n+    ///\n+    /// Disallowed after drop elaboration.\n     FakeRead(Box<(FakeReadCause, Place<'tcx>)>),\n \n     /// Write the discriminant for a variant to the enum Place.\n@@ -1599,17 +1648,35 @@ pub enum StatementKind<'tcx> {\n     /// This writes `uninit` bytes to the entire place.\n     Deinit(Box<Place<'tcx>>),\n \n-    /// Start a live range for the storage of the local.\n+    /// `StorageLive` and `StorageDead` statements mark the live range of a local.\n+    ///\n+    /// Using a local before a `StorageLive` or after a `StorageDead` is not well-formed. These\n+    /// statements are not required. If the entire MIR body contains no `StorageLive`/`StorageDead`\n+    /// statements for a particular local, the local is always considered live.\n+    ///\n+    /// More precisely, the MIR validator currently does a `MaybeStorageLiveLocals` analysis to\n+    /// check validity of each use of a local. I believe this is equivalent to requiring for every\n+    /// use of a local, there exist at least one path from the root to that use that contains a\n+    /// `StorageLive` more recently than a `StorageDead`.\n+    ///\n+    /// **Needs clarification**: Is it permitted to have two `StorageLive`s without an intervening\n+    /// `StorageDead`? Two `StorageDead`s without an intervening `StorageLive`? LLVM says poison,\n+    /// yes. If the answer to any of these is \"no,\" is breaking that rule UB or is it an error to\n+    /// have a path in the CFG that might do this?\n     StorageLive(Local),\n \n-    /// End the current live range for the storage of the local.\n+    /// See `StorageLive` above.\n     StorageDead(Local),\n \n-    /// Retag references in the given place, ensuring they got fresh tags. This is\n-    /// part of the Stacked Borrows model. These statements are currently only interpreted\n-    /// by miri and only generated when \"-Z mir-emit-retag\" is passed.\n-    /// See <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/>\n-    /// for more details.\n+    /// Retag references in the given place, ensuring they got fresh tags.\n+    ///\n+    /// This is part of the Stacked Borrows model. These statements are currently only interpreted\n+    /// by miri and only generated when `-Z mir-emit-retag` is passed. See\n+    /// <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/> for\n+    /// more details.\n+    ///\n+    /// For code that is not specific to stacked borrows, you should consider retags to read\n+    /// and modify the place in an opaque way.\n     Retag(RetagKind, Box<Place<'tcx>>),\n \n     /// Encodes a user's type ascription. These need to be preserved\n@@ -1624,6 +1691,10 @@ pub enum StatementKind<'tcx> {\n     /// - `Contravariant` -- requires that `T_y :> T`\n     /// - `Invariant` -- requires that `T_y == T`\n     /// - `Bivariant` -- no effect\n+    ///\n+    /// When executed at runtime this is a nop.\n+    ///\n+    /// Disallowed after drop elaboration.\n     AscribeUserType(Box<(Place<'tcx>, UserTypeProjection)>, ty::Variance),\n \n     /// Marks the start of a \"coverage region\", injected with '-Cinstrument-coverage'. A\n@@ -1633,9 +1704,19 @@ pub enum StatementKind<'tcx> {\n     /// executed.\n     Coverage(Box<Coverage>),\n \n-    /// Denotes a call to the intrinsic function copy_overlapping, where `src_dst` denotes the\n-    /// memory being read from and written to(one field to save memory), and size\n-    /// indicates how many bytes are being copied over.\n+    /// Denotes a call to the intrinsic function `copy_nonoverlapping`.\n+    ///\n+    /// First, all three operands are evaluated. `src` and `dest` must each be a reference, pointer,\n+    /// or `Box` pointing to the same type `T`. `count` must evaluate to a `usize`. Then, `src` and\n+    /// `dest` are dereferenced, and `count * size_of::<T>()` bytes beginning with the first byte of\n+    /// the `src` place are copied to the continguous range of bytes beginning with the first byte\n+    /// of `dest`.\n+    ///\n+    /// **Needs clarification**: In what order are operands computed and dereferenced? It should\n+    /// probably match the order for assignment, but that is also undecided.\n+    ///\n+    /// **Needs clarification**: Is this typed or not, ie is there a typed load and store involved?\n+    /// I vaguely remember Ralf saying somewhere that he thought it should not be.\n     CopyNonOverlapping(Box<CopyNonOverlapping<'tcx>>),\n \n     /// No-op. Useful for deleting instructions without affecting statement indices.\n@@ -1785,8 +1866,82 @@ pub struct CopyNonOverlapping<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Places\n \n-/// A path to a value; something that can be evaluated without\n-/// changing or disturbing program state.\n+/// Places roughly correspond to a \"location in memory.\" Places in MIR are the same mathematical\n+/// object as places in Rust. This of course means that what exactly they are is undecided and part\n+/// of the Rust memory model. However, they will likely contain at least the following pieces of\n+/// information in some form:\n+///\n+///  1. The address in memory that the place refers to.\n+///  2. The provenance with which the place is being accessed.\n+///  3. The type of the place and an optional variant index. See [`PlaceTy`][tcx::PlaceTy].\n+///  4. Optionally, some metadata. This exists if and only if the type of the place is not `Sized`.\n+///\n+/// We'll give a description below of how all pieces of the place except for the provenance are\n+/// calculated. We cannot give a description of the provenance, because that is part of the\n+/// undecided aliasing model - we only include it here at all to acknowledge its existence.\n+///\n+/// Each local naturally corresponds to the place `Place { local, projection: [] }`. This place has\n+/// the address of the local's allocation and the type of the local.\n+///\n+/// **Needs clarification:** Unsized locals seem to present a bit of an issue. Their allocation\n+/// can't actually be created on `StorageLive`, because it's unclear how big to make the allocation.\n+/// Furthermore, MIR produces assignments to unsized locals, although that is not permitted under\n+/// `#![feature(unsized_locals)]` in Rust. Besides just putting \"unsized locals are special and\n+/// different\" in a bunch of places, I (JakobDegen) don't know how to incorporate this behavior into\n+/// the current MIR semantics in a clean way - possibly this needs some design work first.\n+///\n+/// For places that are not locals, ie they have a non-empty list of projections, we define the\n+/// values as a function of the parent place, that is the place with its last [`ProjectionElem`]\n+/// stripped. The way this is computed of course depends on the kind of that last projection\n+/// element:\n+///\n+///  - [`Downcast`](ProjectionElem::Downcast): This projection sets the place's variant index to the\n+///    given one, and makes no other changes. A `Downcast` projection on a place with its variant\n+///    index already set is not well-formed.\n+///  - [`Field`](ProjectionElem::Field): `Field` projections take their parent place and create a\n+///    place referring to one of the fields of the type. The resulting address is the parent\n+///    address, plus the offset of the field. The type becomes the type of the field. If the parent\n+///    was unsized and so had metadata associated with it, then the metadata is retained if the\n+///    field is unsized and thrown out if it is sized.\n+///\n+///    These projections are only legal for tuples, ADTs, closures, and generators. If the ADT or\n+///    generator has more than one variant, the parent place's variant index must be set, indicating\n+///    which variant is being used. If it has just one variant, the variant index may or may not be\n+///    included - the single possible variant is inferred if it is not included.\n+///  - [`ConstantIndex`](ProjectionElem::ConstantIndex): Computes an offset in units of `T` into the\n+///    place as described in the documentation for the `ProjectionElem`. The resulting address is\n+///    the parent's address plus that offset, and the type is `T`. This is only legal if the parent\n+///    place has type `[T;  N]` or `[T]` (*not* `&[T]`). Since such a `T` is always sized, any\n+///    resulting metadata is thrown out.\n+///  - [`Subslice`](ProjectionElem::Subslice): This projection calculates an offset and a new\n+///    address in a similar manner as `ConstantIndex`. It is also only legal on `[T; N]` and `[T]`.\n+///    However, this yields a `Place` of type `[T]`, and additionally sets the metadata to be the\n+///    length of the subslice.\n+///  - [`Index`](ProjectionElem::Index): Like `ConstantIndex`, only legal on `[T; N]` or `[T]`.\n+///    However, `Index` additionally takes a local from which the value of the index is computed at\n+///    runtime. Computing the value of the index involves interpreting the `Local` as a\n+///    `Place { local, projection: [] }`, and then computing its value as if done via\n+///    [`Operand::Copy`]. The array/slice is then indexed with the resulting value. The local must\n+///    have type `usize`.\n+///  - [`Deref`](ProjectionElem::Deref): Derefs are the last type of projection, and the most\n+///    complicated. They are only legal on parent places that are references, pointers, or `Box`. A\n+///    `Deref` projection begins by loading a value from the parent place, as if by\n+///    [`Operand::Copy`]. It then dereferences the resulting pointer, creating a place of the\n+///    pointee's type. The resulting address is the address that was stored in the pointer. If the\n+///    pointee type is unsized, the pointer additionally stored the value of the metadata.\n+///\n+/// Computing a place may cause UB. One possibility is that the pointer used for a `Deref` may not\n+/// be suitably aligned. Another possibility is that the place is not in bounds, meaning it does not\n+/// point to an actual allocation.\n+///\n+/// However, if this is actually UB and when the UB kicks in is undecided. This is being discussed\n+/// in [UCG#319]. The options include that every place must obey those rules, that only some places\n+/// must obey them, or that places impose no rules of their own.\n+///\n+/// [UCG#319]: https://github.com/rust-lang/unsafe-code-guidelines/issues/319\n+///\n+/// Rust currently requires that every place obey those two rules. This is checked by MIRI and taken\n+/// advantage of by codegen (via `gep inbounds`). That is possibly subject to change.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, HashStable)]\n pub struct Place<'tcx> {\n     pub local: Local,\n@@ -2155,24 +2310,39 @@ pub struct SourceScopeLocalData {\n ///////////////////////////////////////////////////////////////////////////\n // Operands\n \n-/// These are values that can appear inside an rvalue. They are intentionally\n-/// limited to prevent rvalues from being nested in one another.\n+/// An operand in MIR represents a \"value\" in Rust, the definition of which is undecided and part of\n+/// the memory model. One proposal for a definition of values can be found [on UCG][value-def].\n+///\n+/// [value-def]: https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\n+///\n+/// The most common way to create values is via loading a place. Loading a place is an operation\n+/// which reads the memory of the place and converts it to a value. This is a fundamentally *typed*\n+/// operation. The nature of the value produced depends on the type of the conversion. Furthermore,\n+/// there may be other effects: if the type has a validity constraint loading the place might be UB\n+/// if the validity constraint is not met.\n+///\n+/// **Needs clarification:** Ralf proposes that loading a place not have side-effects.\n+/// This is what is implemented in miri today. Are these the semantics we want for MIR? Is this\n+/// something we can even decide without knowing more about Rust's memory model?\n+///\n+/// **Needs clarifiation:** Is loading a place that has its variant index set well-formed? Miri\n+/// currently implements it, but it seems like this may be something to check against in the\n+/// validator.\n #[derive(Clone, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n pub enum Operand<'tcx> {\n-    /// Copy: The value must be available for use afterwards.\n-    ///\n-    /// This implies that the type of the place must be `Copy`; this is true\n-    /// by construction during build, but also checked by the MIR type checker.\n+    /// Creates a value by loading the given place. The type of the place must be `Copy`\n     Copy(Place<'tcx>),\n \n-    /// Move: The value (including old borrows of it) will not be used again.\n+    /// Creates a value by performing loading the place, just like the `Copy` operand.\n+    ///\n+    /// This *may* additionally overwrite the place with `uninit` bytes, depending on how we decide\n+    /// in [UCG#188]. You should not emit MIR that may attempt a subsequent second load of this\n+    /// place without first re-initializing it.\n     ///\n-    /// Safe for values of all types (modulo future developments towards `?Move`).\n-    /// Correct usage patterns are enforced by the borrow checker for safe code.\n-    /// `Copy` may be converted to `Move` to enable \"last-use\" optimizations.\n+    /// [UCG#188]: https://github.com/rust-lang/unsafe-code-guidelines/issues/188\n     Move(Place<'tcx>),\n \n-    /// Synthesizes a constant value.\n+    /// Constants are already semantically values, and remain unchanged.\n     Constant(Box<Constant<'tcx>>),\n }\n \n@@ -2280,57 +2450,134 @@ impl<'tcx> Operand<'tcx> {\n #[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n /// The various kinds of rvalues that can appear in MIR.\n ///\n-/// Not all of these are allowed at every [`MirPhase`]. Check the documentation there to see which\n-/// ones you do not have to worry about. The MIR validator will generally enforce such restrictions,\n-/// causing an ICE if they are violated.\n+/// Not all of these are allowed at every [`MirPhase`] - when this is the case, it's stated below.\n+///\n+/// Computing any rvalue begins by evaluating the places and operands in some order (**Needs\n+/// clarification**: Which order?). These are then used to produce a \"value\" - the same kind of\n+/// value that an [`Operand`] produces.\n pub enum Rvalue<'tcx> {\n-    /// x (either a move or copy, depending on type of x)\n+    /// Yields the operand unchanged\n     Use(Operand<'tcx>),\n \n-    /// [x; 32]\n+    /// Creates an array where each element is the value of the operand.\n+    ///\n+    /// This is the cause of a bug in the case where the repetition count is zero because the value\n+    /// is not dropped, see [#74836].\n+    ///\n+    /// Corresponds to source code like `[x; 32]`.\n+    ///\n+    /// [#74836]: https://github.com/rust-lang/rust/issues/74836\n     Repeat(Operand<'tcx>, ty::Const<'tcx>),\n \n-    /// &x or &mut x\n+    /// Creates a reference of the indicated kind to the place.\n+    ///\n+    /// There is not much to document here, because besides the obvious parts the semantics of this\n+    /// are essentially entirely a part of the aliasing model. There are many UCG issues discussing\n+    /// exactly what the behavior of this operation should be.\n+    ///\n+    /// `Shallow` borrows are disallowed after drop lowering.\n     Ref(Region<'tcx>, BorrowKind, Place<'tcx>),\n \n-    /// Accessing a thread local static. This is inherently a runtime operation, even if llvm\n-    /// treats it as an access to a static. This `Rvalue` yields a reference to the thread local\n-    /// static.\n+    /// Creates a pointer/reference to the given thread local.\n+    ///\n+    /// The yielded type is a `*mut T` if the static is mutable, otherwise if the static is extern a\n+    /// `*const T`, and if neither of those apply a `&T`.\n+    ///\n+    /// **Note:** This is a runtime operation that actually executes code and is in this sense more\n+    /// like a function call. Also, eliminating dead stores of this rvalue causes `fn main() {}` to\n+    /// SIGILL for some reason that I (JakobDegen) never got a chance to look into.\n+    ///\n+    /// **Needs clarification**: Are there weird additional semantics here related to the runtime\n+    /// nature of this operation?\n     ThreadLocalRef(DefId),\n \n-    /// Create a raw pointer to the given place\n-    /// Can be generated by raw address of expressions (`&raw const x`),\n-    /// or when casting a reference to a raw pointer.\n+    /// Creates a pointer with the indicated mutability to the place.\n+    ///\n+    /// This is generated by pointer casts like `&v as *const _` or raw address of expressions like\n+    /// `&raw v` or `addr_of!(v)`.\n+    ///\n+    /// Like with references, the semantics of this operation are heavily dependent on the aliasing\n+    /// model.\n     AddressOf(Mutability, Place<'tcx>),\n \n-    /// length of a `[X]` or `[X;n]` value\n+    /// Yields the length of the place, as a `usize`.\n+    ///\n+    /// If the type of the place is an array, this is the array length. For slices (`[T]`, not\n+    /// `&[T]`) this accesses the place's metadata to determine the length. This rvalue is\n+    /// ill-formed for places of other types.\n     Len(Place<'tcx>),\n \n+    /// Performs essentially all of the casts that can be performed via `as`.\n+    ///\n+    /// This allows for casts from/to a variety of types.\n+    ///\n+    /// **FIXME**: Document exactly which `CastKind`s allow which types of casts. Figure out why\n+    /// `ArrayToPointer` and `MutToConstPointer` are special.\n     Cast(CastKind, Operand<'tcx>, Ty<'tcx>),\n \n+    /// * `Offset` has the same semantics as [`offset`](pointer::offset), except that the second\n+    ///   parameter may be a `usize` as well.\n+    /// * The comparison operations accept `bool`s, `char`s, signed or unsigned integers, floats,\n+    ///   raw pointers, or function pointers of matching types and return a `bool`.\n+    /// * Left and right shift operations accept signed or unsigned integers not necessarily of the\n+    ///   same type and return a value of the same type as their LHS. Like in Rust, the RHS is\n+    ///   truncated as needed.\n+    /// * The `Bit*` operations accept signed integers, unsigned integers, or bools with matching\n+    ///   types and return a value of that type.\n+    /// * The remaining operations accept signed integers, unsigned integers, or floats with\n+    ///   matching types and return a value of that type.\n     BinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),\n+\n+    /// Same as `BinaryOp`, but yields `(T, bool)` instead of `T`. In addition to performing the\n+    /// same computation as the matching `BinaryOp`, checks if the infinite precison result would be\n+    /// unequal to the actual result and sets the `bool` if this is the case.\n+    ///\n+    /// This only supports addition, subtraction, multiplication, and shift operations on integers.\n     CheckedBinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),\n \n+    /// Computes a value as described by the operation.\n     NullaryOp(NullOp, Ty<'tcx>),\n+\n+    /// Exactly like `BinaryOp`, but less operands.\n+    ///\n+    /// Also does two's-complement arithmetic. Negation requires a signed integer or a float;\n+    /// bitwise not requires a signed integer, unsigned integer, or bool. Both operation kinds\n+    /// return a value with the same type as their operand.\n     UnaryOp(UnOp, Operand<'tcx>),\n \n-    /// Read the discriminant of an ADT.\n+    /// Computes the discriminant of the place, returning it as an integer of type\n+    /// [`discriminant_ty`].\n+    ///\n+    /// The validity requirements for the underlying value are undecided for this rvalue, see\n+    /// [#91095]. Note too that the value of the discriminant is not the same thing as the\n+    /// variant index; use [`discriminant_for_variant`] to convert.\n+    ///\n+    /// For types defined in the source code as enums, this is well behaved. This is also well\n+    /// formed for other types, but yields no particular value - there is no reason it couldn't be\n+    /// defined to yield eg zero though.\n     ///\n-    /// Undefined (i.e., no effort is made to make it defined, but there\u2019s no reason why it cannot\n-    /// be defined to return, say, a 0) if ADT is not an enum.\n+    /// [`discriminant_ty`]: crate::ty::Ty::discriminant_ty\n+    /// [#91095]: https://github.com/rust-lang/rust/issues/91095\n+    /// [`discriminant_for_variant`]: crate::ty::Ty::discriminant_for_variant\n     Discriminant(Place<'tcx>),\n \n-    /// Creates an aggregate value, like a tuple or struct. This is\n-    /// only needed because we want to distinguish `dest = Foo { x:\n-    /// ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case\n-    /// that `Foo` has a destructor. These rvalues can be optimized\n-    /// away after type-checking and before lowering.\n+    /// Creates an aggregate value, like a tuple or struct.\n+    ///\n+    /// This is needed because dataflow analysis needs to distinguish\n+    /// `dest = Foo { x: ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case that `Foo`\n+    /// has a destructor.\n+    ///\n+    /// Disallowed after deaggregation for all aggregate kinds except `Array` and `Generator`. After\n+    /// generator lowering, `Generator` aggregate kinds are disallowed too.\n     Aggregate(Box<AggregateKind<'tcx>>, Vec<Operand<'tcx>>),\n \n     /// Transmutes a `*mut u8` into shallow-initialized `Box<T>`.\n     ///\n-    /// This is different a normal transmute because dataflow analysis will treat the box\n-    /// as initialized but its content as uninitialized.\n+    /// This is different from a normal transmute because dataflow analysis will treat the box as\n+    /// initialized but its content as uninitialized. Like other pointer casts, this in general\n+    /// affects alias analysis.\n+    ///\n+    /// Disallowed after drop elaboration.\n     ShallowInitBox(Operand<'tcx>, Ty<'tcx>),\n }\n "}, {"sha": "597ade42236842c10ba0cb8b4675c87f44779021", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d3517907727ecd6fea3fc7132c4ae55b2d06958/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3517907727ecd6fea3fc7132c4ae55b2d06958/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=1d3517907727ecd6fea3fc7132c4ae55b2d06958", "patch": "@@ -76,6 +76,9 @@ impl<'tcx> PlaceTy<'tcx> {\n         V: ::std::fmt::Debug,\n         T: ::std::fmt::Debug + Copy,\n     {\n+        if self.variant_index.is_some() && !matches!(elem, ProjectionElem::Field(..)) {\n+            bug!(\"cannot use non field projection on downcasted place\")\n+        }\n         let answer = match *elem {\n             ProjectionElem::Deref => {\n                 let ty = self"}, {"sha": "cc08857463d5869301f8831865d10654fa01b573", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 123, "deletions": 27, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/1d3517907727ecd6fea3fc7132c4ae55b2d06958/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3517907727ecd6fea3fc7132c4ae55b2d06958/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=1d3517907727ecd6fea3fc7132c4ae55b2d06958", "patch": "@@ -105,13 +105,34 @@ impl<'a> Iterator for SwitchTargetsIter<'a> {\n \n impl<'a> ExactSizeIterator for SwitchTargetsIter<'a> {}\n \n+/// A note on unwinding: Panics may occur during the execution of some terminators. Depending on the\n+/// `-C panic` flag, this may either cause the program to abort or the call stack to unwind. Such\n+/// terminators have a `cleanup: Option<BasicBlock>` field on them. If stack unwinding occurs, then\n+/// once the current function is reached, execution continues at the given basic block, if any. If\n+/// `cleanup` is `None` then no cleanup is performed, and the stack continues unwinding. This is\n+/// equivalent to the execution of a `Resume` terminator.\n+///\n+/// The basic block pointed to by a `cleanup` field must have its `cleanup` flag set. `cleanup`\n+/// basic blocks have a couple restrictions:\n+///  1. All `cleanup` fields in them must be `None`.\n+///  2. `Return` terminators are not allowed in them. `Abort` and `Unwind` terminators are.\n+///  3. All other basic blocks (in the current body) that are reachable from `cleanup` basic blocks\n+///     must also be `cleanup`. This is a part of the type system and checked statically, so it is\n+///     still an error to have such an edge in the CFG even if it's known that it won't be taken at\n+///     runtime.\n #[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n pub enum TerminatorKind<'tcx> {\n-    /// Block should have one successor in the graph; we jump there.\n+    /// Block has one successor; we continue execution there.\n     Goto { target: BasicBlock },\n \n-    /// Operand evaluates to an integer; jump depending on its value\n-    /// to one of the targets, and otherwise fallback to `otherwise`.\n+    /// Switches based on the computed value.\n+    ///\n+    /// First, evaluates the `discr` operand. The type of the operand must be a signed or unsigned\n+    /// integer, char, or bool, and must match the given type. Then, if the list of switch targets\n+    /// contains the computed value, continues execution at the associated basic block. Otherwise,\n+    /// continues execution at the \"otherwise\" basic block.\n+    ///\n+    /// Target values may not appear more than once.\n     SwitchInt {\n         /// The discriminant value being tested.\n         discr: Operand<'tcx>,\n@@ -124,29 +145,62 @@ pub enum TerminatorKind<'tcx> {\n         targets: SwitchTargets,\n     },\n \n-    /// Indicates that the landing pad is finished and unwinding should\n-    /// continue. Emitted by `build::scope::diverge_cleanup`.\n+    /// Indicates that the landing pad is finished and that the process should continue unwinding.\n+    ///\n+    /// Like a return, this marks the end of this invocation of the function.\n+    ///\n+    /// Only permitted in cleanup blocks. `Resume` is not permitted with `-C unwind=abort` after\n+    /// deaggregation runs.\n     Resume,\n \n-    /// Indicates that the landing pad is finished and that the process\n-    /// should abort. Used to prevent unwinding for foreign items.\n+    /// Indicates that the landing pad is finished and that the process should abort.\n+    ///\n+    /// Used to prevent unwinding for foreign items or with `-C unwind=abort`. Only permitted in\n+    /// cleanup blocks.\n     Abort,\n \n-    /// Indicates a normal return. The return place should have\n-    /// been filled in before this executes. This can occur multiple times\n-    /// in different basic blocks.\n+    /// Returns from the function.\n+    ///\n+    /// Like function calls, the exact semantics of returns in Rust are unclear. Returning very\n+    /// likely at least assigns the value currently in the return place (`_0`) to the place\n+    /// specified in the associated `Call` terminator in the calling function, as if assigned via\n+    /// `dest = move _0`. It might additionally do other things, like have side-effects in the\n+    /// aliasing model.\n+    ///\n+    /// If the body is a generator body, this has slightly different semantics; it instead causes a\n+    /// `GeneratorState::Returned(_0)` to be created (as if by an `Aggregate` rvalue) and assigned\n+    /// to the return place.\n     Return,\n \n     /// Indicates a terminator that can never be reached.\n+    ///\n+    /// Executing this terminator is UB.\n     Unreachable,\n \n-    /// Drop the `Place`.\n+    /// The behavior of this statement differs significantly before and after drop elaboration.\n+    /// After drop elaboration, `Drop` executes the drop glue for the specified place, after which\n+    /// it continues execution/unwinds at the given basic blocks. It is possible that executing drop\n+    /// glue is special - this would be part of Rust's memory model. (**FIXME**: due we have an\n+    /// issue tracking if drop glue has any interesting semantics in addition to those of a function\n+    /// call?)\n+    ///\n+    /// `Drop` before drop elaboration is a *conditional* execution of the drop glue. Specifically, the\n+    /// `Drop` will be executed if...\n+    ///\n+    /// **Needs clarification**: End of that sentence. This in effect should document the exact\n+    /// behavior of drop elaboration. The following sounds vaguely right, but I'm not quite sure:\n+    ///\n+    /// > The drop glue is executed if, among all statements executed within this `Body`, an assignment to\n+    /// > the place or one of its \"parents\" occurred more recently than a move out of it. This does not\n+    /// > consider indirect assignments.\n     Drop { place: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n \n-    /// Drop the `Place` and assign the new value over it. This ensures\n-    /// that the assignment to `P` occurs *even if* the destructor for\n-    /// place unwinds. Its semantics are best explained by the\n-    /// elaboration:\n+    /// Drops the place and assigns a new value to it.\n+    ///\n+    /// This first performs the exact same operation as the pre drop-elaboration `Drop` terminator;\n+    /// it then additionally assigns the `value` to the `place` as if by an assignment statement.\n+    /// This assignment occurs both in the unwind and the regular code paths. The semantics are best\n+    /// explained by the elaboration:\n     ///\n     /// ```\n     /// BB0 {\n@@ -170,15 +224,24 @@ pub enum TerminatorKind<'tcx> {\n     /// }\n     /// ```\n     ///\n-    /// Note that DropAndReplace is eliminated as part of the `ElaborateDrops` pass.\n+    /// Disallowed after drop elaboration.\n     DropAndReplace {\n         place: Place<'tcx>,\n         value: Operand<'tcx>,\n         target: BasicBlock,\n         unwind: Option<BasicBlock>,\n     },\n \n-    /// Block ends with a call of a function.\n+    /// Roughly speaking, evaluates the `func` operand and the arguments, and starts execution of\n+    /// the referred to function. The operand types must match the argument types of the function.\n+    /// The return place type must match the return type. The type of the `func` operand must be\n+    /// callable, meaning either a function pointer, a function type, or a closure type.\n+    ///\n+    /// **Needs clarification**: The exact semantics of this. Current backends rely on `move`\n+    /// operands not aliasing the return place. It is unclear how this is justified in MIR, see\n+    /// [#71117].\n+    ///\n+    /// [#71117]: https://github.com/rust-lang/rust/issues/71117\n     Call {\n         /// The function that\u2019s being called.\n         func: Operand<'tcx>,\n@@ -187,7 +250,7 @@ pub enum TerminatorKind<'tcx> {\n         /// This allows the memory occupied by \"by-value\" arguments to be\n         /// reused across function calls without duplicating the contents.\n         args: Vec<Operand<'tcx>>,\n-        /// Destination for the return value. If some, the call is converging.\n+        /// Destination for the return value. If none, the call necessarily diverges.\n         destination: Option<(Place<'tcx>, BasicBlock)>,\n         /// Cleanups to be done if the call unwinds.\n         cleanup: Option<BasicBlock>,\n@@ -199,8 +262,12 @@ pub enum TerminatorKind<'tcx> {\n         fn_span: Span,\n     },\n \n-    /// Jump to the target if the condition has the expected value,\n-    /// otherwise panic with a message and a cleanup target.\n+    /// Evaluates the operand, which must have type `bool`. If it is not equal to `expected`,\n+    /// initiates a panic. Initiating a panic corresponds to a `Call` terminator with some\n+    /// unspecified constant as the function to call, all the operands stored in the `AssertMessage`\n+    /// as parameters, and `None` for the destination. Keep in mind that the `cleanup` path is not\n+    /// necessarily executed even in the case of a panic, for example in `-C panic=abort`. If the\n+    /// assertion does not fail, execution continues at the specified basic block.\n     Assert {\n         cond: Operand<'tcx>,\n         expected: bool,\n@@ -209,7 +276,18 @@ pub enum TerminatorKind<'tcx> {\n         cleanup: Option<BasicBlock>,\n     },\n \n-    /// A suspend point.\n+    /// Marks a suspend point.\n+    ///\n+    /// Like `Return` terminators in generator bodies, this computes `value` and then a\n+    /// `GeneratorState::Yielded(value)` as if by `Aggregate` rvalue. That value is then assigned to\n+    /// the return place of the function calling this one, and execution continues in the calling\n+    /// function. When next invoked with the same first argument, execution of this function\n+    /// continues at the `resume` basic block, with the second argument written to the `resume_arg`\n+    /// place. If the generator is dropped before then, the `drop` basic block is invoked.\n+    ///\n+    /// Not permitted in bodies that are not generator bodies, or after generator lowering.\n+    ///\n+    /// **Needs clarification**: What about the evaluation order of the `resume_arg` and `value`?\n     Yield {\n         /// The value to return.\n         value: Operand<'tcx>,\n@@ -221,21 +299,39 @@ pub enum TerminatorKind<'tcx> {\n         drop: Option<BasicBlock>,\n     },\n \n-    /// Indicates the end of the dropping of a generator.\n+    /// Indicates the end of dropping a generator.\n+    ///\n+    /// Semantically just a `return` (from the generators drop glue). Only permitted in the same situations\n+    /// as `yield`.\n+    ///\n+    /// **Needs clarification**: Is that even correct? The generator drop code is always confusing\n+    /// to me, because it's not even really in the current body.\n+    ///\n+    /// **Needs clarification**: Are there type system constraints on these terminators? Should\n+    /// there be a \"block type\" like `cleanup` blocks for them?\n     GeneratorDrop,\n \n-    /// A block where control flow only ever takes one real path, but borrowck\n-    /// needs to be more conservative.\n+    /// A block where control flow only ever takes one real path, but borrowck needs to be more\n+    /// conservative.\n+    ///\n+    /// At runtime this is semantically just a goto.\n+    ///\n+    /// Disallowed after drop elaboration.\n     FalseEdge {\n         /// The target normal control flow will take.\n         real_target: BasicBlock,\n         /// A block control flow could conceptually jump to, but won't in\n         /// practice.\n         imaginary_target: BasicBlock,\n     },\n-    /// A terminator for blocks that only take one path in reality, but where we\n-    /// reserve the right to unwind in borrowck, even if it won't happen in practice.\n-    /// This can arise in infinite loops with no function calls for example.\n+\n+    /// A terminator for blocks that only take one path in reality, but where we reserve the right\n+    /// to unwind in borrowck, even if it won't happen in practice. This can arise in infinite loops\n+    /// with no function calls for example.\n+    ///\n+    /// At runtime this is semantically just a goto.\n+    ///\n+    /// Disallowed after drop elaboration.\n     FalseUnwind {\n         /// The target normal control flow will take.\n         real_target: BasicBlock,"}, {"sha": "eab51b65f1a19a6e868dbe6b4c24221a5d7b917e", "filename": "src/test/mir-opt/lower_intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d3517907727ecd6fea3fc7132c4ae55b2d06958/src%2Ftest%2Fmir-opt%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3517907727ecd6fea3fc7132c4ae55b2d06958/src%2Ftest%2Fmir-opt%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_intrinsics.rs?ref=1d3517907727ecd6fea3fc7132c4ae55b2d06958", "patch": "@@ -3,7 +3,7 @@\n #![crate_type = \"lib\"]\n \n // EMIT_MIR lower_intrinsics.wrapping.LowerIntrinsics.diff\n-pub fn wrapping<T: Copy>(a: T, b: T) {\n+pub fn wrapping(a: i32, b: i32) {\n     let _x = core::intrinsics::wrapping_add(a, b);\n     let _y = core::intrinsics::wrapping_sub(a, b);\n     let _z = core::intrinsics::wrapping_mul(a, b);"}, {"sha": "5a0286bad2fb7cba37a66835507b7496a3a41101", "filename": "src/test/mir-opt/lower_intrinsics.wrapping.LowerIntrinsics.diff", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1d3517907727ecd6fea3fc7132c4ae55b2d06958/src%2Ftest%2Fmir-opt%2Flower_intrinsics.wrapping.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/1d3517907727ecd6fea3fc7132c4ae55b2d06958/src%2Ftest%2Fmir-opt%2Flower_intrinsics.wrapping.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_intrinsics.wrapping.LowerIntrinsics.diff?ref=1d3517907727ecd6fea3fc7132c4ae55b2d06958", "patch": "@@ -1,23 +1,23 @@\n - // MIR for `wrapping` before LowerIntrinsics\n + // MIR for `wrapping` after LowerIntrinsics\n   \n-  fn wrapping(_1: T, _2: T) -> () {\n-      debug a => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:6:26: 6:27\n-      debug b => _2;                       // in scope 0 at $DIR/lower_intrinsics.rs:6:32: 6:33\n-      let mut _0: ();                      // return place in scope 0 at $DIR/lower_intrinsics.rs:6:38: 6:38\n-      let _3: T;                           // in scope 0 at $DIR/lower_intrinsics.rs:7:9: 7:11\n-      let mut _4: T;                       // in scope 0 at $DIR/lower_intrinsics.rs:7:45: 7:46\n-      let mut _5: T;                       // in scope 0 at $DIR/lower_intrinsics.rs:7:48: 7:49\n-      let mut _7: T;                       // in scope 0 at $DIR/lower_intrinsics.rs:8:45: 8:46\n-      let mut _8: T;                       // in scope 0 at $DIR/lower_intrinsics.rs:8:48: 8:49\n-      let mut _10: T;                      // in scope 0 at $DIR/lower_intrinsics.rs:9:45: 9:46\n-      let mut _11: T;                      // in scope 0 at $DIR/lower_intrinsics.rs:9:48: 9:49\n+  fn wrapping(_1: i32, _2: i32) -> () {\n+      debug a => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:6:17: 6:18\n+      debug b => _2;                       // in scope 0 at $DIR/lower_intrinsics.rs:6:25: 6:26\n+      let mut _0: ();                      // return place in scope 0 at $DIR/lower_intrinsics.rs:6:33: 6:33\n+      let _3: i32;                         // in scope 0 at $DIR/lower_intrinsics.rs:7:9: 7:11\n+      let mut _4: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:7:45: 7:46\n+      let mut _5: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:7:48: 7:49\n+      let mut _7: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:8:45: 8:46\n+      let mut _8: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:8:48: 8:49\n+      let mut _10: i32;                    // in scope 0 at $DIR/lower_intrinsics.rs:9:45: 9:46\n+      let mut _11: i32;                    // in scope 0 at $DIR/lower_intrinsics.rs:9:48: 9:49\n       scope 1 {\n           debug _x => _3;                  // in scope 1 at $DIR/lower_intrinsics.rs:7:9: 7:11\n-          let _6: T;                       // in scope 1 at $DIR/lower_intrinsics.rs:8:9: 8:11\n+          let _6: i32;                     // in scope 1 at $DIR/lower_intrinsics.rs:8:9: 8:11\n           scope 2 {\n               debug _y => _6;              // in scope 2 at $DIR/lower_intrinsics.rs:8:9: 8:11\n-              let _9: T;                   // in scope 2 at $DIR/lower_intrinsics.rs:9:9: 9:11\n+              let _9: i32;                 // in scope 2 at $DIR/lower_intrinsics.rs:9:9: 9:11\n               scope 3 {\n                   debug _z => _9;          // in scope 3 at $DIR/lower_intrinsics.rs:9:9: 9:11\n               }\n@@ -30,10 +30,10 @@\n           _4 = _1;                         // scope 0 at $DIR/lower_intrinsics.rs:7:45: 7:46\n           StorageLive(_5);                 // scope 0 at $DIR/lower_intrinsics.rs:7:48: 7:49\n           _5 = _2;                         // scope 0 at $DIR/lower_intrinsics.rs:7:48: 7:49\n--         _3 = wrapping_add::<T>(move _4, move _5) -> bb1; // scope 0 at $DIR/lower_intrinsics.rs:7:14: 7:50\n+-         _3 = wrapping_add::<i32>(move _4, move _5) -> bb1; // scope 0 at $DIR/lower_intrinsics.rs:7:14: 7:50\n -                                          // mir::Constant\n -                                          // + span: $DIR/lower_intrinsics.rs:7:14: 7:44\n--                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(T, T) -> T {wrapping_add::<T>}, val: Value(Scalar(<ZST>)) }\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {wrapping_add::<i32>}, val: Value(Scalar(<ZST>)) }\n +         _3 = Add(move _4, move _5);      // scope 0 at $DIR/lower_intrinsics.rs:7:14: 7:50\n +         goto -> bb1;                     // scope 0 at $DIR/lower_intrinsics.rs:7:14: 7:50\n       }\n@@ -46,10 +46,10 @@\n           _7 = _1;                         // scope 1 at $DIR/lower_intrinsics.rs:8:45: 8:46\n           StorageLive(_8);                 // scope 1 at $DIR/lower_intrinsics.rs:8:48: 8:49\n           _8 = _2;                         // scope 1 at $DIR/lower_intrinsics.rs:8:48: 8:49\n--         _6 = wrapping_sub::<T>(move _7, move _8) -> bb2; // scope 1 at $DIR/lower_intrinsics.rs:8:14: 8:50\n+-         _6 = wrapping_sub::<i32>(move _7, move _8) -> bb2; // scope 1 at $DIR/lower_intrinsics.rs:8:14: 8:50\n -                                          // mir::Constant\n -                                          // + span: $DIR/lower_intrinsics.rs:8:14: 8:44\n--                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(T, T) -> T {wrapping_sub::<T>}, val: Value(Scalar(<ZST>)) }\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {wrapping_sub::<i32>}, val: Value(Scalar(<ZST>)) }\n +         _6 = Sub(move _7, move _8);      // scope 1 at $DIR/lower_intrinsics.rs:8:14: 8:50\n +         goto -> bb2;                     // scope 1 at $DIR/lower_intrinsics.rs:8:14: 8:50\n       }\n@@ -62,18 +62,18 @@\n           _10 = _1;                        // scope 2 at $DIR/lower_intrinsics.rs:9:45: 9:46\n           StorageLive(_11);                // scope 2 at $DIR/lower_intrinsics.rs:9:48: 9:49\n           _11 = _2;                        // scope 2 at $DIR/lower_intrinsics.rs:9:48: 9:49\n--         _9 = wrapping_mul::<T>(move _10, move _11) -> bb3; // scope 2 at $DIR/lower_intrinsics.rs:9:14: 9:50\n+-         _9 = wrapping_mul::<i32>(move _10, move _11) -> bb3; // scope 2 at $DIR/lower_intrinsics.rs:9:14: 9:50\n -                                          // mir::Constant\n -                                          // + span: $DIR/lower_intrinsics.rs:9:14: 9:44\n--                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(T, T) -> T {wrapping_mul::<T>}, val: Value(Scalar(<ZST>)) }\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {wrapping_mul::<i32>}, val: Value(Scalar(<ZST>)) }\n +         _9 = Mul(move _10, move _11);    // scope 2 at $DIR/lower_intrinsics.rs:9:14: 9:50\n +         goto -> bb3;                     // scope 2 at $DIR/lower_intrinsics.rs:9:14: 9:50\n       }\n   \n       bb3: {\n           StorageDead(_11);                // scope 2 at $DIR/lower_intrinsics.rs:9:49: 9:50\n           StorageDead(_10);                // scope 2 at $DIR/lower_intrinsics.rs:9:49: 9:50\n-          _0 = const ();                   // scope 0 at $DIR/lower_intrinsics.rs:6:38: 10:2\n+          _0 = const ();                   // scope 0 at $DIR/lower_intrinsics.rs:6:33: 10:2\n           StorageDead(_9);                 // scope 2 at $DIR/lower_intrinsics.rs:10:1: 10:2\n           StorageDead(_6);                 // scope 1 at $DIR/lower_intrinsics.rs:10:1: 10:2\n           StorageDead(_3);                 // scope 0 at $DIR/lower_intrinsics.rs:10:1: 10:2"}]}