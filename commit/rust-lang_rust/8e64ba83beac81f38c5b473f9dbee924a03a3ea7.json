{"sha": "8e64ba83beac81f38c5b473f9dbee924a03a3ea7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNjRiYTgzYmVhYzgxZjM4YzViNDczZjlkYmVlOTI0YTAzYTNlYTc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-09T11:36:10Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-20T19:04:52Z"}, "message": "extract `constrain_anon_types` to the `InferCtxt`\n\nNo funtional change.", "tree": {"sha": "96201cfab613652c1f666ced34a4a754f2f4c2db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96201cfab613652c1f666ced34a4a754f2f4c2db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e64ba83beac81f38c5b473f9dbee924a03a3ea7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e64ba83beac81f38c5b473f9dbee924a03a3ea7", "html_url": "https://github.com/rust-lang/rust/commit/8e64ba83beac81f38c5b473f9dbee924a03a3ea7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e64ba83beac81f38c5b473f9dbee924a03a3ea7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e96f4be03d791715b20855f700862c3b532e713b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e96f4be03d791715b20855f700862c3b532e713b", "html_url": "https://github.com/rust-lang/rust/commit/e96f4be03d791715b20855f700862c3b532e713b"}], "stats": {"total": 495, "additions": 289, "deletions": 206}, "files": [{"sha": "74daeb837c929d10796d57954e347abe39521dbb", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 261, "deletions": 1, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/8e64ba83beac81f38c5b473f9dbee924a03a3ea7/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e64ba83beac81f38c5b473f9dbee924a03a3ea7/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=8e64ba83beac81f38c5b473f9dbee924a03a3ea7", "patch": "@@ -9,11 +9,13 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use infer::{InferCtxt, InferOk, TypeVariableOrigin};\n+use infer::{self, InferCtxt, InferOk, TypeVariableOrigin};\n+use infer::outlives::free_region_map::FreeRegionRelations;\n use syntax::ast;\n use traits::{self, PredicateObligation};\n use ty::{self, Ty};\n use ty::fold::{BottomUpFolder, TypeFoldable};\n+use ty::outlives::Component;\n use ty::subst::Substs;\n use util::nodemap::DefIdMap;\n \n@@ -115,6 +117,264 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             obligations: instantiator.obligations,\n         }\n     }\n+\n+    /// Given the map `anon_types` containing the existential `impl\n+    /// Trait` types whose underlying, hidden types are being\n+    /// inferred, this method adds constraints to the regions\n+    /// appearing in those underlying hidden types to ensure that they\n+    /// at least do not refer to random scopes within the current\n+    /// function. These constraints are not (quite) sufficient to\n+    /// guarantee that the regions are actually legal values; that\n+    /// final condition is imposed after region inference is done.\n+    ///\n+    /// # The Problem\n+    ///\n+    /// Let's work through an example to explain how it works.  Assume\n+    /// the current function is as follows:\n+    ///\n+    ///     fn foo<'a, 'b>(..) -> (impl Bar<'a>, impl Bar<'b>)\n+    ///\n+    /// Here, we have two `impl Trait` types whose values are being\n+    /// inferred (the `impl Bar<'a>` and the `impl\n+    /// Bar<'b>`). Conceptually, this is sugar for a setup where we\n+    /// define underlying abstract types (`Foo1`, `Foo2`) and then, in\n+    /// the return type of `foo`, we *reference* those definitions:\n+    ///\n+    ///     abstract type Foo1<'x>: Bar<'x>;\n+    ///     abstract type Foo2<'x>: Bar<'x>;\n+    ///     fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n+    ///                        //  ^^^^ ^^\n+    ///                        //  |    |\n+    ///                        //  |    substs\n+    ///                        //  def_id\n+    ///\n+    /// As indicating in the comments above, each of those references\n+    /// is (in the compiler) basically a substitution (`substs`)\n+    /// applied to the type of a suitable `def_id` (which identifies\n+    /// `Foo1` or `Foo2`).\n+    ///\n+    /// Now, at this point in compilation, what we have done is to\n+    /// replace each of the references (`Foo1<'a>`, `Foo2<'b>`) with\n+    /// fresh inference variables C1 and C2. We wish to use the values\n+    /// of these variables to infer the underlying types of `Foo1` and\n+    /// `Foo2`.  That is, this gives rise to higher-order (pattern) unification\n+    /// constraints like:\n+    ///\n+    ///     for<'a> (Foo1<'a> = C1)\n+    ///     for<'b> (Foo1<'b> = C2)\n+    ///\n+    /// For these equation to be satisfiable, the types `C1` and `C2`\n+    /// can only refer to a limited set of regions. For example, `C1`\n+    /// can only refer to `'static` and `'a`, and `C2` can only refer\n+    /// to `'static` and `'b`. The job of this function is to impose that\n+    /// constraint.\n+    ///\n+    /// Up to this point, C1 and C2 are basically just random type\n+    /// inference variables, and hence they may contain arbitrary\n+    /// regions. In fact, it is fairly likely that they do! Consider\n+    /// this possible definition of `foo`:\n+    ///\n+    ///     fn foo<'a, 'b>(x: &'a i32, y: &'b i32) -> (impl Bar<'a>, impl Bar<'b>) {\n+    ///         (&*x, &*y)\n+    ///     }\n+    ///\n+    /// Here, the values for the concrete types of the two impl\n+    /// traits will include inference variables:\n+    ///\n+    ///     &'0 i32\n+    ///     &'1 i32\n+    ///\n+    /// Ordinarily, the subtyping rules would ensure that these are\n+    /// sufficiently large. But since `impl Bar<'a>` isn't a specific\n+    /// type per se, we don't get such constraints by default.  This\n+    /// is where this function comes into play. It adds extra\n+    /// constraints to ensure that all the regions which appear in the\n+    /// inferred type are regions that could validly appear.\n+    ///\n+    /// This is actually a bit of a tricky constraint in general. We\n+    /// want to say that each variable (e.g., `'0``) can only take on\n+    /// values that were supplied as arguments to the abstract type\n+    /// (e.g., `'a` for `Foo1<'a>`) or `'static`, which is always in\n+    /// scope. We don't have a constraint quite of this kind in the current\n+    /// region checker.\n+    ///\n+    /// # The Solution\n+    ///\n+    /// We make use of the constraint that we *do* have in the `<=`\n+    /// relation. To do that, we find the \"minimum\" of all the\n+    /// arguments that appear in the substs: that is, some region\n+    /// which is less than all the others. In the case of `Foo1<'a>`,\n+    /// that would be `'a` (it's the only choice, after all). Then we\n+    /// apply that as a least bound to the variables (e.g., `'a <=\n+    /// '0`).\n+    ///\n+    /// In some cases, there is no minimum. Consider this example:\n+    ///\n+    ///    fn baz<'a, 'b>() -> impl Trait<'a, 'b> { ... }\n+    ///\n+    /// Here we would report an error, because `'a` and `'b` have no\n+    /// relation to one another.\n+    ///\n+    /// # The `free_region_relations` parameter\n+    ///\n+    /// The `free_region_relations` argument is used to find the\n+    /// \"minimum\" of the regions supplied to a given abstract type.\n+    /// It must be a relation that can answer whether `'a <= 'b`,\n+    /// where `'a` and `'b` are regions that appear in the \"substs\"\n+    /// for the abstract type references (the `<'a>` in `Foo1<'a>`).\n+    ///\n+    /// Note that we do not impose the constraints based on the\n+    /// generic regions from the `Foo1` definition (e.g., `'x`). This\n+    /// is because the constraints we are imposing here is basically\n+    /// the concern of the one generating the constraining type C1,\n+    /// which is the current function. It also means that we can\n+    /// take \"implied bounds\" into account in some cases:\n+    ///\n+    ///     trait SomeTrait<'a, 'b> { }\n+    ///     fn foo<'a, 'b>(_: &'a &'b u32) -> impl SomeTrait<'a, 'b> { .. }\n+    ///\n+    /// Here, the fact that `'b: 'a` is known only because of the\n+    /// implied bounds from the `&'a &'b u32` parameter, and is not\n+    /// \"inherent\" to the abstract type definition.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `anon_types` -- the map produced by `instantiate_anon_types`\n+    /// - `free_region_relations` -- something that can be used to relate\n+    ///   the free regions (`'a`) that appear in the impl trait.\n+    pub fn constrain_anon_types<FRR: FreeRegionRelations<'tcx>>(\n+        &self,\n+        anon_types: &AnonTypeMap<'tcx>,\n+        free_region_relations: &FRR,\n+    ) {\n+        debug!(\"constrain_anon_types()\");\n+\n+        for (&def_id, anon_defn) in anon_types {\n+            self.constrain_anon_type(def_id, anon_defn, free_region_relations);\n+        }\n+    }\n+\n+    fn constrain_anon_type<FRR: FreeRegionRelations<'tcx>>(\n+        &self,\n+        def_id: DefId,\n+        anon_defn: &AnonTypeDecl<'tcx>,\n+        free_region_relations: &FRR,\n+    ) {\n+        debug!(\"constrain_anon_type()\");\n+        debug!(\"constrain_anon_type: def_id={:?}\", def_id);\n+        debug!(\"constrain_anon_type: anon_defn={:#?}\", anon_defn);\n+\n+        let concrete_ty = self.resolve_type_vars_if_possible(&anon_defn.concrete_ty);\n+\n+        debug!(\"constrain_anon_type: concrete_ty={:?}\", concrete_ty);\n+\n+        let abstract_type_generics = self.tcx.generics_of(def_id);\n+\n+        let span = self.tcx.def_span(def_id);\n+\n+        // If there are required region bounds, we can just skip\n+        // ahead.  There will already be a registered region\n+        // obligation related `concrete_ty` to those regions.\n+        if anon_defn.has_required_region_bounds {\n+            return;\n+        }\n+\n+        // There were no `required_region_bounds`,\n+        // so we have to search for a `least_region`.\n+        // Go through all the regions used as arguments to the\n+        // abstract type. These are the parameters to the abstract\n+        // type; so in our example above, `substs` would contain\n+        // `['a]` for the first impl trait and `'b` for the\n+        // second.\n+        let mut least_region = None;\n+        for region_def in &abstract_type_generics.regions {\n+            // Find the index of this region in the list of substitutions.\n+            let index = region_def.index as usize;\n+\n+            // Get the value supplied for this region from the substs.\n+            let subst_arg = anon_defn.substs[index].as_region().unwrap();\n+\n+            // Compute the least upper bound of it with the other regions.\n+            debug!(\"constrain_anon_types: least_region={:?}\", least_region);\n+            debug!(\"constrain_anon_types: subst_arg={:?}\", subst_arg);\n+            match least_region {\n+                None => least_region = Some(subst_arg),\n+                Some(lr) => {\n+                    if free_region_relations.sub_free_regions(lr, subst_arg) {\n+                        // keep the current least region\n+                    } else if free_region_relations.sub_free_regions(subst_arg, lr) {\n+                        // switch to `subst_arg`\n+                        least_region = Some(subst_arg);\n+                    } else {\n+                        // There are two regions (`lr` and\n+                        // `subst_arg`) which are not relatable. We can't\n+                        // find a best choice.\n+                        self.tcx\n+                            .sess\n+                            .struct_span_err(span, \"ambiguous lifetime bound in `impl Trait`\")\n+                            .span_label(\n+                                span,\n+                                format!(\"neither `{}` nor `{}` outlives the other\", lr, subst_arg),\n+                            )\n+                            .emit();\n+\n+                        least_region = Some(self.tcx.mk_region(ty::ReEmpty));\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let least_region = least_region.unwrap_or(self.tcx.types.re_static);\n+        debug!(\"constrain_anon_types: least_region={:?}\", least_region);\n+\n+        // Require that the type `concrete_ty` outlives\n+        // `least_region`, modulo any type parameters that appear\n+        // in the type, which we ignore. This is because impl\n+        // trait values are assumed to capture all the in-scope\n+        // type parameters. This little loop here just invokes\n+        // `outlives` repeatedly, draining all the nested\n+        // obligations that result.\n+        let mut types = vec![concrete_ty];\n+        let bound_region = |r| self.sub_regions(infer::CallReturn(span), least_region, r);\n+        while let Some(ty) = types.pop() {\n+            let mut components = self.tcx.outlives_components(ty);\n+            while let Some(component) = components.pop() {\n+                match component {\n+                    Component::Region(r) => {\n+                        bound_region(r);\n+                    }\n+\n+                    Component::Param(_) => {\n+                        // ignore type parameters like `T`, they are captured\n+                        // implicitly by the `impl Trait`\n+                    }\n+\n+                    Component::UnresolvedInferenceVariable(_) => {\n+                        // we should get an error that more type\n+                        // annotations are needed in this case\n+                        self.tcx\n+                            .sess\n+                            .delay_span_bug(span, \"unresolved inf var in anon\");\n+                    }\n+\n+                    Component::Projection(ty::ProjectionTy {\n+                        substs,\n+                        item_def_id: _,\n+                    }) => {\n+                        for r in substs.regions() {\n+                            bound_region(r);\n+                        }\n+                        types.extend(substs.types());\n+                    }\n+\n+                    Component::EscapingProjection(more_components) => {\n+                        components.extend(more_components);\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n struct Instantiator<'a, 'gcx: 'tcx, 'tcx: 'a> {"}, {"sha": "6163ec1642001f603e4a7e53690596652a53a77f", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8e64ba83beac81f38c5b473f9dbee924a03a3ea7/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e64ba83beac81f38c5b473f9dbee924a03a3ea7/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=8e64ba83beac81f38c5b473f9dbee924a03a3ea7", "patch": "@@ -38,20 +38,6 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         }\n     }\n \n-    /// Tests whether `r_a <= r_b`. Both must be free regions or\n-    /// `'static`.\n-    pub fn sub_free_regions<'a, 'gcx>(&self,\n-                                      r_a: Region<'tcx>,\n-                                      r_b: Region<'tcx>)\n-                                      -> bool {\n-        assert!(is_free_or_static(r_a) && is_free_or_static(r_b));\n-        if let ty::ReStatic = r_b {\n-            true // `'a <= 'static` is just always true, and not stored in the relation explicitly\n-        } else {\n-            r_a == r_b || self.relation.contains(&r_a, &r_b)\n-        }\n-    }\n-\n     /// Compute the least-upper-bound of two free regions. In some\n     /// cases, this is more conservative than necessary, in order to\n     /// avoid making arbitrary choices. See\n@@ -75,6 +61,29 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     }\n }\n \n+/// The NLL region handling code represents free region relations in a\n+/// slightly different way; this trait allows functions to be abstract\n+/// over which version is in use.\n+pub trait FreeRegionRelations<'tcx> {\n+    /// Tests whether `r_a <= r_b`. Both must be free regions or\n+    /// `'static`.\n+    fn sub_free_regions(&self, shorter: ty::Region<'tcx>, longer: ty::Region<'tcx>) -> bool;\n+}\n+\n+impl<'tcx> FreeRegionRelations<'tcx> for FreeRegionMap<'tcx> {\n+    fn sub_free_regions(&self,\n+                        r_a: Region<'tcx>,\n+                        r_b: Region<'tcx>)\n+                        -> bool {\n+        assert!(is_free_or_static(r_a) && is_free_or_static(r_b));\n+        if let ty::ReStatic = r_b {\n+            true // `'a <= 'static` is just always true, and not stored in the relation explicitly\n+        } else {\n+            r_a == r_b || self.relation.contains(&r_a, &r_b)\n+        }\n+    }\n+}\n+\n fn is_free(r: Region) -> bool {\n     match *r {\n         ty::ReEarlyBound(_) | ty::ReFree(_) => true,"}, {"sha": "1341e3515d571d794762312a4a68d6fb74def6f8", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e64ba83beac81f38c5b473f9dbee924a03a3ea7/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e64ba83beac81f38c5b473f9dbee924a03a3ea7/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=8e64ba83beac81f38c5b473f9dbee924a03a3ea7", "patch": "@@ -15,7 +15,7 @@\n //! `TransitiveRelation` type and use that to decide when one free\n //! region outlives another and so forth.\n \n-use infer::outlives::free_region_map::FreeRegionMap;\n+use infer::outlives::free_region_map::{FreeRegionMap, FreeRegionRelations};\n use hir::def_id::DefId;\n use middle::region;\n use ty::{self, TyCtxt, Region};"}, {"sha": "97352783db85aa46603cbd06cf5126f6b0ab4f6a", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 190, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/8e64ba83beac81f38c5b473f9dbee924a03a3ea7/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e64ba83beac81f38c5b473f9dbee924a03a3ea7/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=8e64ba83beac81f38c5b473f9dbee924a03a3ea7", "patch": "@@ -93,7 +93,6 @@ use rustc::ty::{self, Ty};\n use rustc::infer;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::ty::adjustment;\n-use rustc::ty::outlives::Component;\n \n use std::mem;\n use std::ops::Deref;\n@@ -344,7 +343,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                                        body_hir_id,\n                                        call_site_region);\n \n-        self.constrain_anon_types();\n+        self.constrain_anon_types(\n+            &self.fcx.anon_types.borrow(),\n+            self.outlives_environment.free_region_map(),\n+        );\n     }\n \n     fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n@@ -363,194 +365,6 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             self.body_id);\n     }\n \n-    /// Go through each of the existential `impl Trait` types that\n-    /// appear in the function signature. For example, if the current\n-    /// function is as follows:\n-    ///\n-    ///     fn foo<'a, 'b>(..) -> (impl Bar<'a>, impl Bar<'b>)\n-    ///\n-    /// we would iterate through the `impl Bar<'a>` and the\n-    /// `impl Bar<'b>` here. Remember that each of them has\n-    /// their own \"abstract type\" definition created for them. As\n-    /// we iterate, we have a `def_id` that corresponds to this\n-    /// definition, and a set of substitutions `substs` that are\n-    /// being supplied to this abstract typed definition in the\n-    /// signature:\n-    ///\n-    ///     abstract type Foo1<'x>: Bar<'x>;\n-    ///     abstract type Foo2<'x>: Bar<'x>;\n-    ///     fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n-    ///                            ^^^^ ^^ substs\n-    ///                            def_id\n-    ///\n-    /// In addition, for each of the types we will have a type\n-    /// variable `concrete_ty` containing the concrete type that\n-    /// this function uses for `Foo1` and `Foo2`. That is,\n-    /// conceptually, there is a constraint like:\n-    ///\n-    ///     for<'a> (Foo1<'a> = C)\n-    ///\n-    /// where `C` is `concrete_ty`. For this equation to be satisfiable,\n-    /// the type `C` can only refer to two regions: `'static` and `'a`.\n-    ///\n-    /// The problem is that this type `C` may contain arbitrary\n-    /// region variables. In fact, it is fairly likely that it\n-    /// does!  Consider this possible definition of `foo`:\n-    ///\n-    ///     fn foo<'a, 'b>(x: &'a i32, y: &'b i32) -> (impl Bar<'a>, impl Bar<'b>) {\n-    ///         (&*x, &*y)\n-    ///     }\n-    ///\n-    /// Here, the values for the concrete types of the two impl\n-    /// traits will include inference variables:\n-    ///\n-    ///     &'0 i32\n-    ///     &'1 i32\n-    ///\n-    /// Ordinarily, the subtyping rules would ensure that these are\n-    /// sufficiently large.  But since `impl Bar<'a>` isn't a specific\n-    /// type per se, we don't get such constraints by default.  This\n-    /// is where this function comes into play. It adds extra\n-    /// constraints to ensure that all the regions which appear in the\n-    /// inferred type are regions that could validly appear.\n-    ///\n-    /// This is actually a bit of a tricky constraint in general. We\n-    /// want to say that each variable (e.g., `'0``) can only take on\n-    /// values that were supplied as arguments to the abstract type\n-    /// (e.g., `'a` for `Foo1<'a>`) or `'static`, which is always in\n-    /// scope. We don't have a constraint quite of this kind in the current\n-    /// region checker.\n-    ///\n-    /// What we *do* have is the `<=` relation. So what we do is to\n-    /// find the LUB of all the arguments that appear in the substs:\n-    /// in this case, that would be `LUB('a) = 'a`, and then we apply\n-    /// that as a least bound to the variables (e.g., `'a <= '0`).\n-    ///\n-    /// In some cases this is pretty suboptimal. Consider this example:\n-    ///\n-    ///    fn baz<'a, 'b>() -> impl Trait<'a, 'b> { ... }\n-    ///\n-    /// Here, the regions `'a` and `'b` appear in the substitutions,\n-    /// so we would generate `LUB('a, 'b)` as a kind of \"minimal upper\n-    /// bound\", but that turns out be `'static` -- which is clearly\n-    /// too strict!\n-    fn constrain_anon_types(&mut self) {\n-        debug!(\"constrain_anon_types()\");\n-\n-        for (&def_id, anon_defn) in self.fcx.anon_types.borrow().iter() {\n-            let concrete_ty = self.resolve_type(anon_defn.concrete_ty);\n-\n-            debug!(\"constrain_anon_types: def_id={:?}\", def_id);\n-            debug!(\"constrain_anon_types: anon_defn={:#?}\", anon_defn);\n-            debug!(\"constrain_anon_types: concrete_ty={:?}\", concrete_ty);\n-\n-            let abstract_type_generics = self.tcx.generics_of(def_id);\n-\n-            let span = self.tcx.def_span(def_id);\n-\n-            // If there are required region bounds, we can just skip\n-            // ahead.  There will already be a registered region\n-            // obligation related `concrete_ty` to those regions.\n-            if anon_defn.has_required_region_bounds {\n-                continue;\n-            }\n-\n-            // There were no `required_region_bounds`,\n-            // so we have to search for a `least_region`.\n-            // Go through all the regions used as arguments to the\n-            // abstract type. These are the parameters to the abstract\n-            // type; so in our example above, `substs` would contain\n-            // `['a]` for the first impl trait and `'b` for the\n-            // second.\n-            let mut least_region = None;\n-            for region_def in &abstract_type_generics.regions {\n-                // Find the index of this region in the list of substitutions.\n-                let index = region_def.index as usize;\n-\n-                // Get the value supplied for this region from the substs.\n-                let subst_arg = anon_defn.substs[index].as_region().unwrap();\n-\n-                // Compute the least upper bound of it with the other regions.\n-                debug!(\"constrain_anon_types: least_region={:?}\", least_region);\n-                debug!(\"constrain_anon_types: subst_arg={:?}\", subst_arg);\n-                match least_region {\n-                    None => least_region = Some(subst_arg),\n-                    Some(lr) => {\n-                        if self.outlives_environment\n-                               .free_region_map()\n-                               .sub_free_regions(lr, subst_arg) {\n-                            // keep the current least region\n-                        } else if self.outlives_environment\n-                                      .free_region_map()\n-                                      .sub_free_regions(subst_arg, lr) {\n-                            // switch to `subst_arg`\n-                            least_region = Some(subst_arg);\n-                        } else {\n-                            // There are two regions (`lr` and\n-                            // `subst_arg`) which are not relatable. We can't\n-                            // find a best choice.\n-                            self.tcx\n-                                .sess\n-                                .struct_span_err(span, \"ambiguous lifetime bound in `impl Trait`\")\n-                                .span_label(span,\n-                                            format!(\"neither `{}` nor `{}` outlives the other\",\n-                                                    lr, subst_arg))\n-                                .emit();\n-\n-                            least_region = Some(self.tcx.mk_region(ty::ReEmpty));\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            let least_region = least_region.unwrap_or(self.tcx.types.re_static);\n-            debug!(\"constrain_anon_types: least_region={:?}\", least_region);\n-\n-            // Require that the type `concrete_ty` outlives\n-            // `least_region`, modulo any type parameters that appear\n-            // in the type, which we ignore. This is because impl\n-            // trait values are assumed to capture all the in-scope\n-            // type parameters. This little loop here just invokes\n-            // `outlives` repeatedly, draining all the nested\n-            // obligations that result.\n-            let mut types = vec![concrete_ty];\n-            let bound_region = |r| self.sub_regions(infer::CallReturn(span), least_region, r);\n-            while let Some(ty) = types.pop() {\n-                let mut components = self.tcx.outlives_components(ty);\n-                while let Some(component) = components.pop() {\n-                    match component {\n-                        Component::Region(r) => {\n-                            bound_region(r);\n-                        }\n-\n-                        Component::Param(_) => {\n-                            // ignore type parameters like `T`, they are captured\n-                            // implicitly by the `impl Trait`\n-                        }\n-\n-                        Component::UnresolvedInferenceVariable(_) => {\n-                            // we should get an error that more type\n-                            // annotations are needed in this case\n-                            self.tcx.sess.delay_span_bug(span, \"unresolved inf var in anon\");\n-                        }\n-\n-                        Component::Projection(ty::ProjectionTy { substs, item_def_id: _ }) => {\n-                            for r in substs.regions() {\n-                                bound_region(r);\n-                            }\n-                            types.extend(substs.types());\n-                        }\n-\n-                        Component::EscapingProjection(more_components) => {\n-                            components.extend(more_components);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn resolve_regions_and_report_errors(&self) {\n         self.fcx.resolve_regions_and_report_errors(self.subject_def_id,\n                                                    &self.region_scope_tree,"}]}