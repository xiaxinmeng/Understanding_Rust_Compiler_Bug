{"sha": "770231e54d0266406791bab1fda7e300d074ebda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3MDIzMWU1NGQwMjY2NDA2NzkxYmFiMWZkYTdlMzAwZDA3NGViZGE=", "commit": {"author": {"name": "Mateusz Miku\u0142a", "email": "mati865@gmail.com", "date": "2020-08-31T16:21:58Z"}, "committer": {"name": "Mateusz Miku\u0142a", "email": "mati865@gmail.com", "date": "2020-09-01T17:52:39Z"}, "message": "Replace MinGW library hack with heuristic controlling link mode", "tree": {"sha": "1447441923edf71c57dddd8d6a52e1a58977aeeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1447441923edf71c57dddd8d6a52e1a58977aeeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/770231e54d0266406791bab1fda7e300d074ebda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/770231e54d0266406791bab1fda7e300d074ebda", "html_url": "https://github.com/rust-lang/rust/commit/770231e54d0266406791bab1fda7e300d074ebda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/770231e54d0266406791bab1fda7e300d074ebda/comments", "author": {"login": "mati865", "id": 1174646, "node_id": "MDQ6VXNlcjExNzQ2NDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1174646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mati865", "html_url": "https://github.com/mati865", "followers_url": "https://api.github.com/users/mati865/followers", "following_url": "https://api.github.com/users/mati865/following{/other_user}", "gists_url": "https://api.github.com/users/mati865/gists{/gist_id}", "starred_url": "https://api.github.com/users/mati865/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mati865/subscriptions", "organizations_url": "https://api.github.com/users/mati865/orgs", "repos_url": "https://api.github.com/users/mati865/repos", "events_url": "https://api.github.com/users/mati865/events{/privacy}", "received_events_url": "https://api.github.com/users/mati865/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mati865", "id": 1174646, "node_id": "MDQ6VXNlcjExNzQ2NDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1174646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mati865", "html_url": "https://github.com/mati865", "followers_url": "https://api.github.com/users/mati865/followers", "following_url": "https://api.github.com/users/mati865/following{/other_user}", "gists_url": "https://api.github.com/users/mati865/gists{/gist_id}", "starred_url": "https://api.github.com/users/mati865/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mati865/subscriptions", "organizations_url": "https://api.github.com/users/mati865/orgs", "repos_url": "https://api.github.com/users/mati865/repos", "events_url": "https://api.github.com/users/mati865/events{/privacy}", "received_events_url": "https://api.github.com/users/mati865/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23f0ccfe5d9999a54dfcc4f5ba953981ba092aa7", "url": "https://api.github.com/repos/rust-lang/rust/commits/23f0ccfe5d9999a54dfcc4f5ba953981ba092aa7", "html_url": "https://github.com/rust-lang/rust/commit/23f0ccfe5d9999a54dfcc4f5ba953981ba092aa7"}], "stats": {"total": 117, "additions": 25, "deletions": 92}, "files": [{"sha": "7a8af4f0ac68f8f60bb8f7925c44ef4e2f0fbe71", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 25, "deletions": 92, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/770231e54d0266406791bab1fda7e300d074ebda/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/770231e54d0266406791bab1fda7e300d074ebda/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=770231e54d0266406791bab1fda7e300d074ebda", "patch": "@@ -1014,86 +1014,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n     }\n }\n \n-// Because windows-gnu target is meant to be self-contained for pure Rust code it bundles\n-// own mingw-w64 libraries. These libraries are usually not compatible with mingw-w64\n-// installed in the system. This breaks many cases where Rust is mixed with other languages\n-// (e.g. *-sys crates).\n-// We prefer system mingw-w64 libraries if they are available to avoid this issue.\n-fn get_crt_libs_path(sess: &Session) -> Option<PathBuf> {\n-    fn find_exe_in_path<P>(exe_name: P) -> Option<PathBuf>\n-    where\n-        P: AsRef<Path>,\n-    {\n-        for dir in env::split_paths(&env::var_os(\"PATH\")?) {\n-            let full_path = dir.join(&exe_name);\n-            if full_path.is_file() {\n-                return Some(fix_windows_verbatim_for_gcc(&full_path));\n-            }\n-        }\n-        None\n-    }\n-\n-    fn probe(sess: &Session) -> Option<PathBuf> {\n-        if let (linker, LinkerFlavor::Gcc) = linker_and_flavor(&sess) {\n-            let linker_path = if cfg!(windows) && linker.extension().is_none() {\n-                linker.with_extension(\"exe\")\n-            } else {\n-                linker\n-            };\n-            if let Some(linker_path) = find_exe_in_path(linker_path) {\n-                let mingw_arch = match &sess.target.target.arch {\n-                    x if x == \"x86\" => \"i686\",\n-                    x => x,\n-                };\n-                let mingw_bits = &sess.target.target.target_pointer_width;\n-                let mingw_dir = format!(\"{}-w64-mingw32\", mingw_arch);\n-                // Here we have path/bin/gcc but we need path/\n-                let mut path = linker_path;\n-                path.pop();\n-                path.pop();\n-                // Loosely based on Clang MinGW driver\n-                let probe_paths = vec![\n-                    path.join(&mingw_dir).join(\"lib\"),                // Typical path\n-                    path.join(&mingw_dir).join(\"sys-root/mingw/lib\"), // Rare path\n-                    path.join(format!(\n-                        \"lib/mingw/tools/install/mingw{}/{}/lib\",\n-                        &mingw_bits, &mingw_dir\n-                    )), // Chocolatey is creative\n-                ];\n-                for probe_path in probe_paths {\n-                    if probe_path.join(\"crt2.o\").exists() {\n-                        return Some(probe_path);\n-                    };\n-                }\n-            };\n-        };\n-        None\n-    }\n-\n-    let mut system_library_path = sess.system_library_path.borrow_mut();\n-    match &*system_library_path {\n-        Some(Some(compiler_libs_path)) => Some(compiler_libs_path.clone()),\n-        Some(None) => None,\n-        None => {\n-            let path = probe(sess);\n-            *system_library_path = Some(path.clone());\n-            path\n-        }\n-    }\n-}\n-\n fn get_object_file_path(sess: &Session, name: &str, self_contained: bool) -> PathBuf {\n-    // prefer system {,dll}crt2.o libs, see get_crt_libs_path comment for more details\n-    if sess.opts.cg.link_self_contained.is_none()\n-        && sess.target.target.llvm_target.contains(\"windows-gnu\")\n-    {\n-        if let Some(compiler_libs_path) = get_crt_libs_path(sess) {\n-            let file_path = compiler_libs_path.join(name);\n-            if file_path.exists() {\n-                return file_path;\n-            }\n-        }\n-    }\n     let fs = sess.target_filesearch(PathKind::Native);\n     let file_path = fs.get_lib_path().join(name);\n     if file_path.exists() {\n@@ -1286,6 +1207,28 @@ fn link_output_kind(sess: &Session, crate_type: CrateType) -> LinkOutputKind {\n     }\n }\n \n+// Returns true if linker is located within sysroot\n+fn detect_self_contained_mingw(sess: &Session) -> bool {\n+    let (linker, _) = linker_and_flavor(&sess);\n+    // Assume `-C linker=rust-lld` as self-contained mode\n+    if linker == Path::new(\"rust-lld\") {\n+        return true;\n+    }\n+    let linker_with_extension = if cfg!(windows) && linker.extension().is_none() {\n+        linker.with_extension(\"exe\")\n+    } else {\n+        linker\n+    };\n+    for dir in env::split_paths(&env::var_os(\"PATH\").unwrap_or_default()) {\n+        let full_path = dir.join(&linker_with_extension);\n+        // If linker comes from sysroot assume self-contained mode\n+        if full_path.is_file() && !full_path.starts_with(&sess.sysroot) {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n /// Whether we link to our own CRT objects instead of relying on gcc to pull them.\n /// We only provide such support for a very limited number of targets.\n fn crt_objects_fallback(sess: &Session, crate_type: CrateType) -> bool {\n@@ -1298,10 +1241,10 @@ fn crt_objects_fallback(sess: &Session, crate_type: CrateType) -> bool {\n         // based on host and linker path, for example.\n         // (https://github.com/rust-lang/rust/pull/71769#issuecomment-626330237).\n         Some(CrtObjectsFallback::Musl) => sess.crt_static(Some(crate_type)),\n-        // FIXME: Find some heuristic for \"native mingw toolchain is available\",\n-        // likely based on `get_crt_libs_path` (https://github.com/rust-lang/rust/pull/67429).\n         Some(CrtObjectsFallback::Mingw) => {\n-            sess.host == sess.target.target && sess.target.target.target_vendor != \"uwp\"\n+            sess.host == sess.target.target\n+                && sess.target.target.target_vendor != \"uwp\"\n+                && detect_self_contained_mingw(&sess)\n         }\n         // FIXME: Figure out cases in which WASM needs to link with a native toolchain.\n         Some(CrtObjectsFallback::Wasm) => true,\n@@ -1498,16 +1441,6 @@ fn link_local_crate_native_libs_and_dependent_crate_libs<'a, B: ArchiveBuilder<'\n \n /// Add sysroot and other globally set directories to the directory search list.\n fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session, self_contained: bool) {\n-    // Prefer system mingw-w64 libs, see get_crt_libs_path comment for more details.\n-    if sess.opts.cg.link_self_contained.is_none()\n-        && cfg!(windows)\n-        && sess.target.target.llvm_target.contains(\"windows-gnu\")\n-    {\n-        if let Some(compiler_libs_path) = get_crt_libs_path(sess) {\n-            cmd.include_path(&compiler_libs_path);\n-        }\n-    }\n-\n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n     let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();"}]}