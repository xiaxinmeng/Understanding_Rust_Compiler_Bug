{"sha": "386ba3ae63bd0d642af3349c25370605f5200a05", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NmJhM2FlNjNiZDBkNjQyYWYzMzQ5YzI1MzcwNjA1ZjUyMDBhMDU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-07T06:37:14Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-07T06:37:14Z"}, "message": "Further work on vec-append. Almost working.", "tree": {"sha": "f6a7ce93bb15c3a3dee0074abef2c2db12224783", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6a7ce93bb15c3a3dee0074abef2c2db12224783"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/386ba3ae63bd0d642af3349c25370605f5200a05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/386ba3ae63bd0d642af3349c25370605f5200a05", "html_url": "https://github.com/rust-lang/rust/commit/386ba3ae63bd0d642af3349c25370605f5200a05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/386ba3ae63bd0d642af3349c25370605f5200a05/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d39da6f97819becd9ea41c194b5f0daa178814fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/d39da6f97819becd9ea41c194b5f0daa178814fe", "html_url": "https://github.com/rust-lang/rust/commit/d39da6f97819becd9ea41c194b5f0daa178814fe"}], "stats": {"total": 180, "additions": 135, "deletions": 45}, "files": [{"sha": "de9aadae0287d0c379706a728e5ccdb5fe71cb50", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 135, "deletions": 45, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/386ba3ae63bd0d642af3349c25370605f5200a05/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/386ba3ae63bd0d642af3349c25370605f5200a05/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=386ba3ae63bd0d642af3349c25370605f5200a05", "patch": "@@ -1723,6 +1723,8 @@ fn mk_plain_tag(ast.def_id tid) -> @ty.t {\n }\n \n \n+type val_fn = fn(@block_ctxt cx, ValueRef v) -> result;\n+\n type val_and_ty_fn = fn(@block_ctxt cx, ValueRef v, @ty.t t) -> result;\n \n type val_pair_and_ty_fn =\n@@ -1922,23 +1924,17 @@ fn iter_structural_ty_full(@block_ctxt cx,\n     ret r;\n }\n \n-// Iterates through a pair of sequences, until the src* hits the src_lim*.\n-fn iter_sequence_pair_inner(@block_ctxt cx,\n-                            ValueRef dst,     // elt*\n-                            ValueRef src,     // elt*\n-                            ValueRef src_lim, // elt*\n-                            @ty.t elt_ty,\n-                            val_pair_and_ty_fn f) -> result {\n+// Iterates through a pointer range, until the src* hits the src_lim*.\n+fn iter_sequence_raw(@block_ctxt cx,\n+                     ValueRef src,     // elt*\n+                     ValueRef src_lim, // elt*\n+                     ValueRef elt_sz,\n+                     val_fn f) -> result {\n \n     auto bcx = cx;\n \n-    auto llunit_ty = type_of(cx.fcx.ccx, elt_ty);\n-    auto unit_sz = size_of(bcx, elt_ty);\n-    bcx = unit_sz.bcx;\n-\n     let ValueRef src_int = vp2i(bcx, src);\n     let ValueRef src_lim_int = vp2i(bcx, src_lim);\n-    let ValueRef dst_int = vp2i(bcx, dst);\n \n     auto cond_cx = new_scope_block_ctxt(cx, \"sequence-iter cond\");\n     auto body_cx = new_scope_block_ctxt(cx, \"sequence-iter body\");\n@@ -1948,33 +1944,23 @@ fn iter_sequence_pair_inner(@block_ctxt cx,\n \n     let ValueRef src_curr = cond_cx.build.Phi(T_int(),\n                                               vec(src_int), vec(bcx.llbb));\n-    let ValueRef dst_curr = cond_cx.build.Phi(T_int(),\n-                                              vec(dst_int), vec(bcx.llbb));\n \n-    auto end_test = cond_cx.build.ICmp(lib.llvm.LLVMIntNE,\n+    auto end_test = cond_cx.build.ICmp(lib.llvm.LLVMIntULT,\n                                        src_curr, src_lim_int);\n \n     cond_cx.build.CondBr(end_test, body_cx.llbb, next_cx.llbb);\n \n-    auto src_curr_ptr = vi2p(body_cx, src_curr, T_ptr(llunit_ty));\n-    auto dst_curr_ptr = vi2p(body_cx, dst_curr, T_ptr(llunit_ty));\n+    auto src_curr_ptr = vi2p(body_cx, src_curr, T_ptr(T_i8()));\n \n-    auto body_res = f(body_cx,\n-                      dst_curr_ptr,\n-                      load_scalar_or_boxed(body_cx, src_curr_ptr, elt_ty),\n-                      elt_ty);\n+    auto body_res = f(body_cx, src_curr_ptr);\n     body_cx = body_res.bcx;\n \n-    auto src_next = body_cx.build.Add(src_curr, unit_sz.val);\n-    auto dst_next = body_cx.build.Add(dst_curr, unit_sz.val);\n+    auto src_next = body_cx.build.Add(src_curr, elt_sz);\n     body_cx.build.Br(cond_cx.llbb);\n \n     cond_cx.build.AddIncomingToPhi(src_curr, vec(src_next),\n                                    vec(body_cx.llbb));\n \n-    cond_cx.build.AddIncomingToPhi(dst_curr, vec(dst_next),\n-                                   vec(body_cx.llbb));\n-\n     ret res(next_cx, C_nil());\n }\n \n@@ -1985,15 +1971,17 @@ fn iter_sequence_inner(@block_ctxt cx,\n                        @ty.t elt_ty,\n                        val_and_ty_fn f) -> result {\n     fn adaptor_fn(val_and_ty_fn f,\n+                  @ty.t elt_ty,\n                   @block_ctxt cx,\n-                  ValueRef av,\n-                  ValueRef bv,\n-                  @ty.t t) -> result {\n-        ret f(cx, bv, t);\n+                  ValueRef v) -> result {\n+        auto llty = type_of(cx.fcx.ccx, elt_ty);\n+        auto p = cx.build.PointerCast(v, T_ptr(llty));\n+        ret f(cx, load_scalar_or_boxed(cx, p, elt_ty), elt_ty);\n     }\n \n-    be iter_sequence_pair_inner(cx, src, src, src_lim, elt_ty,\n-                                bind adaptor_fn(f, _, _, _, _));\n+    auto elt_sz = size_of(cx, elt_ty);\n+    be iter_sequence_raw(elt_sz.bcx, src, src_lim, elt_sz.val,\n+                         bind adaptor_fn(f, elt_ty, _, _));\n }\n \n \n@@ -5475,34 +5463,136 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n \n     auto bcx = new_top_block_ctxt(fcx);\n \n+    auto lldst_vec = bcx.build.Load(lldst_vec_ptr);\n+\n     // First the dst vec needs to grow to accommodate the src vec.\n     // To do this we have to figure out how many bytes to add.\n-    auto n_bytes =\n-        bcx.build.Load(bcx.build.GEP(llsrc_vec,\n-                                     vec(C_int(0),\n-                                         C_int(abi.vec_elt_fill))));\n \n-    n_bytes = bcx.build.Select(llskipnull,\n-                               bcx.build.Sub(n_bytes, C_int(1)),\n-                               n_bytes);\n+    fn vec_fill(@block_ctxt bcx, ValueRef v) -> ValueRef {\n+        ret bcx.build.Load(bcx.build.GEP(v, vec(C_int(0),\n+                                                C_int(abi.vec_elt_fill))));\n+    }\n+\n+    fn put_vec_fill(@block_ctxt bcx, ValueRef v, ValueRef fill) -> ValueRef {\n+        ret bcx.build.Store(fill,\n+                            bcx.build.GEP(v,\n+                                          vec(C_int(0),\n+                                              C_int(abi.vec_elt_fill))));\n+    }\n \n+    fn vec_fill_adjusted(@block_ctxt bcx, ValueRef v,\n+                         ValueRef skipnull) -> ValueRef {\n+        auto f = bcx.build.Load(bcx.build.GEP(v,\n+                                              vec(C_int(0),\n+                                                  C_int(abi.vec_elt_fill))));\n+        ret bcx.build.Select(skipnull, bcx.build.Sub(f, C_int(1)), f);\n+    }\n \n-    auto llneed_copy_ptr = bcx.build.Alloca(T_int());\n+    fn vec_p0(@block_ctxt bcx, ValueRef v) -> ValueRef {\n+        auto p = bcx.build.GEP(v, vec(C_int(0),\n+                                      C_int(abi.vec_elt_data)));\n+        ret bcx.build.PointerCast(p, T_ptr(T_i8()));\n+    }\n+\n+\n+    fn vec_p1(@block_ctxt bcx, ValueRef v) -> ValueRef {\n+        auto len = vec_fill(bcx, v);\n+        ret bcx.build.GEP(vec_p0(bcx, v), vec(len));\n+    }\n+\n+    fn vec_p1_adjusted(@block_ctxt bcx, ValueRef v,\n+                       ValueRef skipnull) -> ValueRef {\n+        auto len = vec_fill_adjusted(bcx, v, skipnull);\n+        ret bcx.build.GEP(vec_p0(bcx, v), vec(len));\n+    }\n+\n+\n+    auto llcopy_dst_ptr = bcx.build.Alloca(T_int());\n     auto llnew_vec_res =\n         trans_upcall(bcx, \"upcall_vec_grow\",\n-                     vec(vp2i(bcx, bcx.build.Load(lldst_vec_ptr)),\n-                         n_bytes,\n-                         vp2i(bcx, llneed_copy_ptr),\n+                     vec(vp2i(bcx, lldst_vec),\n+                         vec_fill_adjusted(bcx, llsrc_vec, llskipnull),\n+                         vp2i(bcx, llcopy_dst_ptr),\n                          vp2i(bcx, llvec_tydesc)));\n \n     bcx = llnew_vec_res.bcx;\n     auto llnew_vec = vi2p(bcx, llnew_vec_res.val,\n                           T_opaque_vec_ptr());\n \n+    put_vec_fill(bcx, llnew_vec, C_int(0));\n \n-    // FIXME: complete this.\n+    auto copy_dst_cx = new_sub_block_ctxt(bcx, \"copy new <- dst\");\n+    auto copy_src_cx = new_sub_block_ctxt(bcx, \"copy new <- src\");\n \n-    bcx.build.RetVoid();\n+    auto pp0 = bcx.build.Alloca(T_ptr(T_i8()));\n+    bcx.build.Store(vec_p0(bcx, llnew_vec), pp0);\n+\n+    bcx.build.CondBr(bcx.build.TruncOrBitCast\n+                     (bcx.build.Load(llcopy_dst_ptr),\n+                      T_i1()),\n+                     copy_dst_cx.llbb,\n+                     copy_src_cx.llbb);\n+\n+\n+    fn copy_elts(@block_ctxt cx,\n+                 ValueRef elt_tydesc,\n+                 ValueRef dst,\n+                 ValueRef src,\n+                 ValueRef n_bytes) -> result {\n+\n+        auto src_lim = cx.build.GEP(src, vec(n_bytes));\n+\n+        auto elt_llsz =\n+            cx.build.Load(cx.build.GEP(elt_tydesc,\n+                                       vec(C_int(0),\n+                                           C_int(abi.tydesc_field_size))));\n+\n+        fn take_one(ValueRef elt_tydesc,\n+                    @block_ctxt cx, ValueRef v) -> result {\n+            call_tydesc_glue_full(cx, v,\n+                                  elt_tydesc,\n+                                  abi.tydesc_field_take_glue_off);\n+            ret res(cx, v);\n+        }\n+\n+        auto bcx = iter_sequence_raw(cx, src, src_lim,\n+                                     elt_llsz, bind take_one(elt_tydesc,\n+                                                             _, _)).bcx;\n+\n+        ret call_memcpy(bcx, dst, src, n_bytes);\n+    }\n+\n+    // Copy any dst elements in, omitting null if doing str.\n+    auto n_bytes = vec_fill_adjusted(copy_dst_cx, lldst_vec, llskipnull);\n+    copy_dst_cx = copy_elts(copy_dst_cx,\n+                            llelt_tydesc,\n+                            copy_dst_cx.build.Load(pp0),\n+                            vec_p0(copy_dst_cx, lldst_vec),\n+                            n_bytes).bcx;\n+\n+    put_vec_fill(copy_dst_cx, llnew_vec, n_bytes);\n+    copy_dst_cx.build.Store(vec_p1_adjusted(copy_dst_cx,\n+                                            llnew_vec, llskipnull),\n+                            pp0);\n+    copy_dst_cx.build.Br(copy_src_cx.llbb);\n+\n+\n+    // Copy any src elements in, carrying along null if doing str.\n+    n_bytes = vec_fill(copy_src_cx, llsrc_vec);\n+    copy_src_cx = copy_elts(copy_src_cx,\n+                            llelt_tydesc,\n+                            copy_src_cx.build.Load(pp0),\n+                            vec_p0(copy_src_cx, llsrc_vec),\n+                            n_bytes).bcx;\n+\n+    put_vec_fill(copy_src_cx, llnew_vec,\n+                 copy_src_cx.build.Add(vec_fill(copy_src_cx,\n+                                                llnew_vec),\n+                                        n_bytes));\n+\n+    // Write new_vec back through the alias we were given.\n+    copy_src_cx.build.Store(llnew_vec, lldst_vec_ptr);\n+    copy_src_cx.build.RetVoid();\n }\n \n "}]}