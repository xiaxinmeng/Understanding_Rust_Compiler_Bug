{"sha": "8d71a6bf0ca51ae099a5b470afdb957bca321441", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNzFhNmJmMGNhNTFhZTA5OWE1YjQ3MGFmZGI5NTdiY2EzMjE0NDE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-10T09:49:13Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-10T14:10:28Z"}, "message": "Scale token generation back", "tree": {"sha": "453aefb2a8fa3e554871f83b19b93017bf88b2ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/453aefb2a8fa3e554871f83b19b93017bf88b2ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d71a6bf0ca51ae099a5b470afdb957bca321441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d71a6bf0ca51ae099a5b470afdb957bca321441", "html_url": "https://github.com/rust-lang/rust/commit/8d71a6bf0ca51ae099a5b470afdb957bca321441", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d71a6bf0ca51ae099a5b470afdb957bca321441/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "779f06ed77e868b9409a1724f736a045415d4922", "url": "https://api.github.com/repos/rust-lang/rust/commits/779f06ed77e868b9409a1724f736a045415d4922", "html_url": "https://github.com/rust-lang/rust/commit/779f06ed77e868b9409a1724f736a045415d4922"}], "stats": {"total": 683, "additions": 136, "deletions": 547}, "files": [{"sha": "6622eadb2da1fd9bf2275a57634306306cfbc35c", "filename": "crates/ra_assists/src/handlers/add_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d71a6bf0ca51ae099a5b470afdb957bca321441/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d71a6bf0ca51ae099a5b470afdb957bca321441/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs?ref=8d71a6bf0ca51ae099a5b470afdb957bca321441", "patch": "@@ -1,5 +1,5 @@\n use ra_syntax::{\n-    ast::{self, AstNode, AstToken, NameOwner, TypeParamsOwner},\n+    ast::{self, AstNode, NameOwner, TypeParamsOwner},\n     TextUnit,\n };\n use stdx::{format_to, SepBy};"}, {"sha": "240b19fa378c5432c4d2023ddf5e083072f1a863", "filename": "crates/ra_assists/src/handlers/add_new.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d71a6bf0ca51ae099a5b470afdb957bca321441/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d71a6bf0ca51ae099a5b470afdb957bca321441/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs?ref=8d71a6bf0ca51ae099a5b470afdb957bca321441", "patch": "@@ -1,8 +1,7 @@\n use hir::Adt;\n use ra_syntax::{\n     ast::{\n-        self, AstNode, AstToken, NameOwner, StructKind, TypeAscriptionOwner, TypeParamsOwner,\n-        VisibilityOwner,\n+        self, AstNode, NameOwner, StructKind, TypeAscriptionOwner, TypeParamsOwner, VisibilityOwner,\n     },\n     TextUnit, T,\n };"}, {"sha": "1dd4ce34a74cd3b14909a9e8741663ae7b582edf", "filename": "crates/ra_parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8d71a6bf0ca51ae099a5b470afdb957bca321441/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d71a6bf0ca51ae099a5b470afdb957bca321441/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=8d71a6bf0ca51ae099a5b470afdb957bca321441", "patch": "@@ -655,4 +655,10 @@ macro_rules! T {\n     ( raw ) => {\n         $crate::SyntaxKind::RAW_KW\n     };\n+    ( lifetime ) => {\n+        $crate::SyntaxKind::LIFETIME\n+    };\n+    ( ident ) => {\n+        $crate::SyntaxKind::IDENT\n+    };\n }"}, {"sha": "03d94170dab8971d40bd1b14029a483dd1fe3ba2", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8d71a6bf0ca51ae099a5b470afdb957bca321441/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d71a6bf0ca51ae099a5b470afdb957bca321441/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=8d71a6bf0ca51ae099a5b470afdb957bca321441", "patch": "@@ -21,11 +21,7 @@ impl ast::NameRef {\n     }\n \n     pub fn as_tuple_field(&self) -> Option<usize> {\n-        if let Some(ast::NameRefToken::IntNumber(token)) = self.name_ref_token_token() {\n-            token.text().as_str().parse().ok()\n-        } else {\n-            None\n-        }\n+        self.text().parse().ok()\n     }\n }\n \n@@ -315,7 +311,7 @@ pub enum TypeBoundKind {\n     /// for<'a> ...\n     ForType(ast::ForType),\n     /// 'a\n-    Lifetime(ast::Lifetime),\n+    Lifetime(SyntaxToken),\n }\n \n impl ast::TypeBound {\n@@ -401,15 +397,15 @@ impl ast::RangePat {\n     pub fn start(&self) -> Option<ast::Pat> {\n         self.syntax()\n             .children_with_tokens()\n-            .take_while(|it| !ast::RangeSeparator::can_cast(it.kind()))\n+            .take_while(|it| !(it.kind() == T![..] || it.kind() == T![..=]))\n             .filter_map(|it| it.into_node())\n             .find_map(ast::Pat::cast)\n     }\n \n     pub fn end(&self) -> Option<ast::Pat> {\n         self.syntax()\n             .children_with_tokens()\n-            .skip_while(|it| !ast::RangeSeparator::can_cast(it.kind()))\n+            .skip_while(|it| !(it.kind() == T![..] || it.kind() == T![..=]))\n             .filter_map(|it| it.into_node())\n             .find_map(ast::Pat::cast)\n     }"}, {"sha": "d67d733b1875350d731bc73674d0a2ed79007bff", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 65, "deletions": 59, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/8d71a6bf0ca51ae099a5b470afdb957bca321441/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d71a6bf0ca51ae099a5b470afdb957bca321441/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=8d71a6bf0ca51ae099a5b470afdb957bca321441", "patch": "@@ -1,6 +1,5 @@\n //! Generated file, do not edit by hand, see `xtask/src/codegen`\n \n-use super::tokens::*;\n use crate::{\n     ast::{self, support, AstChildren, AstNode},\n     SyntaxKind::{self, *},\n@@ -463,7 +462,7 @@ impl ImplDef {\n     pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![const]) }\n     pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![unsafe]) }\n     pub fn impl_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![impl]) }\n-    pub fn excl_token(&self) -> Option<Excl> { support::token(&self.syntax) }\n+    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![!]) }\n     pub fn for_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![for]) }\n     pub fn item_list(&self) -> Option<ItemList> { support::child(&self.syntax) }\n }\n@@ -523,7 +522,7 @@ impl AstNode for NeverType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl NeverType {\n-    pub fn excl_token(&self) -> Option<Excl> { support::token(&self.syntax) }\n+    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![!]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathType {\n@@ -559,7 +558,7 @@ impl AstNode for PointerType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl PointerType {\n-    pub fn star_token(&self) -> Option<Star> { support::token(&self.syntax) }\n+    pub fn star_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![*]) }\n     pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![const]) }\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n@@ -622,8 +621,10 @@ impl AstNode for ReferenceType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ReferenceType {\n-    pub fn amp_token(&self) -> Option<Amp> { support::token(&self.syntax) }\n-    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![&]) }\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token2(&self.syntax, T![lifetime])\n+    }\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n@@ -643,7 +644,7 @@ impl AstNode for PlaceholderType {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl PlaceholderType {\n-    pub fn underscore_token(&self) -> Option<Underscore> { support::token(&self.syntax) }\n+    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![_]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct FnPointerType {\n@@ -955,7 +956,9 @@ impl ContinueExpr {\n     pub fn continue_token(&self) -> Option<SyntaxToken> {\n         support::token2(&self.syntax, T![continue])\n     }\n-    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token2(&self.syntax, T![lifetime])\n+    }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BreakExpr {\n@@ -975,7 +978,9 @@ impl AstNode for BreakExpr {\n impl ast::AttrsOwner for BreakExpr {}\n impl BreakExpr {\n     pub fn break_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![break]) }\n-    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token2(&self.syntax, T![lifetime])\n+    }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -994,7 +999,9 @@ impl AstNode for Label {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Label {\n-    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token2(&self.syntax, T![lifetime])\n+    }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BlockExpr {\n@@ -1074,7 +1081,7 @@ impl ast::AttrsOwner for MethodCallExpr {}\n impl ast::ArgListOwner for MethodCallExpr {}\n impl MethodCallExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot_token(&self) -> Option<Dot> { support::token(&self.syntax) }\n+    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![.]) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n }\n@@ -1116,7 +1123,7 @@ impl AstNode for FieldExpr {\n impl ast::AttrsOwner for FieldExpr {}\n impl FieldExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot_token(&self) -> Option<Dot> { support::token(&self.syntax) }\n+    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![.]) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1137,7 +1144,7 @@ impl AstNode for AwaitExpr {\n impl ast::AttrsOwner for AwaitExpr {}\n impl AwaitExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot_token(&self) -> Option<Dot> { support::token(&self.syntax) }\n+    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![.]) }\n     pub fn await_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![await]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1198,7 +1205,7 @@ impl AstNode for RefExpr {\n }\n impl ast::AttrsOwner for RefExpr {}\n impl RefExpr {\n-    pub fn amp_token(&self) -> Option<Amp> { support::token(&self.syntax) }\n+    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![&]) }\n     pub fn raw_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![raw]) }\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n@@ -1220,7 +1227,6 @@ impl AstNode for PrefixExpr {\n }\n impl ast::AttrsOwner for PrefixExpr {}\n impl PrefixExpr {\n-    pub fn prefix_op_token(&self) -> Option<PrefixOp> { support::token(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1259,9 +1265,7 @@ impl AstNode for RangeExpr {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl ast::AttrsOwner for RangeExpr {}\n-impl RangeExpr {\n-    pub fn range_op_token(&self) -> Option<RangeOp> { support::token(&self.syntax) }\n-}\n+impl RangeExpr {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct BinExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1294,9 +1298,7 @@ impl AstNode for Literal {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl Literal {\n-    pub fn literal_token_token(&self) -> Option<LiteralToken> { support::token(&self.syntax) }\n-}\n+impl Literal {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchExpr {\n     pub(crate) syntax: SyntaxNode,\n@@ -1358,7 +1360,7 @@ impl ast::AttrsOwner for MatchArm {}\n impl MatchArm {\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n     pub fn guard(&self) -> Option<MatchGuard> { support::child(&self.syntax) }\n-    pub fn fat_arrow_token(&self) -> Option<FatArrow> { support::token(&self.syntax) }\n+    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![=>]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1417,7 +1419,7 @@ impl AstNode for RecordFieldList {\n impl RecordFieldList {\n     pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['{']) }\n     pub fn fields(&self) -> AstChildren<RecordField> { support::children(&self.syntax) }\n-    pub fn dotdot_token(&self) -> Option<Dotdot> { support::token(&self.syntax) }\n+    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![..]) }\n     pub fn spread(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['}']) }\n }\n@@ -1439,7 +1441,7 @@ impl AstNode for RecordField {\n impl ast::AttrsOwner for RecordField {}\n impl RecordField {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn colon_token(&self) -> Option<Colon> { support::token(&self.syntax) }\n+    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![:]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1496,7 +1498,7 @@ impl AstNode for RefPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl RefPat {\n-    pub fn amp_token(&self) -> Option<Amp> { support::token(&self.syntax) }\n+    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![&]) }\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n@@ -1539,7 +1541,7 @@ impl ast::NameOwner for BindPat {}\n impl BindPat {\n     pub fn ref_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![ref]) }\n     pub fn mut_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![mut]) }\n-    pub fn at_token(&self) -> Option<At> { support::token(&self.syntax) }\n+    pub fn at_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![@]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1558,7 +1560,7 @@ impl AstNode for PlaceholderPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl PlaceholderPat {\n-    pub fn underscore_token(&self) -> Option<Underscore> { support::token(&self.syntax) }\n+    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![_]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct DotDotPat {\n@@ -1576,7 +1578,7 @@ impl AstNode for DotDotPat {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl DotDotPat {\n-    pub fn dotdot_token(&self) -> Option<Dotdot> { support::token(&self.syntax) }\n+    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![..]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PathPat {\n@@ -1631,9 +1633,7 @@ impl AstNode for RangePat {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl RangePat {\n-    pub fn range_separator_token(&self) -> Option<RangeSeparator> { support::token(&self.syntax) }\n-}\n+impl RangePat {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LiteralPat {\n     pub(crate) syntax: SyntaxNode,\n@@ -1713,7 +1713,7 @@ impl RecordFieldPatList {\n         support::children(&self.syntax)\n     }\n     pub fn bind_pats(&self) -> AstChildren<BindPat> { support::children(&self.syntax) }\n-    pub fn dotdot_token(&self) -> Option<Dotdot> { support::token(&self.syntax) }\n+    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![..]) }\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1734,7 +1734,7 @@ impl AstNode for RecordFieldPat {\n impl ast::AttrsOwner for RecordFieldPat {}\n impl ast::NameOwner for RecordFieldPat {}\n impl RecordFieldPat {\n-    pub fn colon_token(&self) -> Option<Colon> { support::token(&self.syntax) }\n+    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![:]) }\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1815,7 +1815,7 @@ impl AstNode for Name {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Name {\n-    pub fn ident_token(&self) -> Option<Ident> { support::token(&self.syntax) }\n+    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![ident]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NameRef {\n@@ -1832,9 +1832,7 @@ impl AstNode for NameRef {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl NameRef {\n-    pub fn name_ref_token_token(&self) -> Option<NameRefToken> { support::token(&self.syntax) }\n-}\n+impl NameRef {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCall {\n     pub(crate) syntax: SyntaxNode,\n@@ -1855,7 +1853,7 @@ impl ast::AttrsOwner for MacroCall {}\n impl ast::DocCommentsOwner for MacroCall {}\n impl MacroCall {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn excl_token(&self) -> Option<Excl> { support::token(&self.syntax) }\n+    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![!]) }\n     pub fn token_tree(&self) -> Option<TokenTree> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![;]) }\n }\n@@ -1875,8 +1873,8 @@ impl AstNode for Attr {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl Attr {\n-    pub fn pound_token(&self) -> Option<Pound> { support::token(&self.syntax) }\n-    pub fn excl_token(&self) -> Option<Excl> { support::token(&self.syntax) }\n+    pub fn pound_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![#]) }\n+    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![!]) }\n     pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T!['[']) }\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![=]) }\n@@ -1915,12 +1913,12 @@ impl AstNode for TypeParamList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TypeParamList {\n-    pub fn l_angle_token(&self) -> Option<LAngle> { support::token(&self.syntax) }\n+    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![<]) }\n     pub fn generic_params(&self) -> AstChildren<GenericParam> { support::children(&self.syntax) }\n     pub fn type_params(&self) -> AstChildren<TypeParam> { support::children(&self.syntax) }\n     pub fn lifetime_params(&self) -> AstChildren<LifetimeParam> { support::children(&self.syntax) }\n     pub fn const_params(&self) -> AstChildren<ConstParam> { support::children(&self.syntax) }\n-    pub fn r_angle_token(&self) -> Option<RAngle> { support::token(&self.syntax) }\n+    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![>]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeParam {\n@@ -1983,7 +1981,9 @@ impl AstNode for LifetimeParam {\n }\n impl ast::AttrsOwner for LifetimeParam {}\n impl LifetimeParam {\n-    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token2(&self.syntax, T![lifetime])\n+    }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeBound {\n@@ -2001,7 +2001,9 @@ impl AstNode for TypeBound {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TypeBound {\n-    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token2(&self.syntax, T![lifetime])\n+    }\n     pub fn const_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![const]) }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n@@ -2040,7 +2042,9 @@ impl AstNode for WherePred {\n }\n impl ast::TypeBoundsOwner for WherePred {}\n impl WherePred {\n-    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token2(&self.syntax, T![lifetime])\n+    }\n     pub fn type_ref(&self) -> Option<TypeRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2077,9 +2081,7 @@ impl AstNode for Abi {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl Abi {\n-    pub fn string_token(&self) -> Option<String> { support::token(&self.syntax) }\n-}\n+impl Abi {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ExprStmt {\n     pub(crate) syntax: SyntaxNode,\n@@ -2207,8 +2209,10 @@ impl AstNode for SelfParam {\n impl ast::TypeAscriptionOwner for SelfParam {}\n impl ast::AttrsOwner for SelfParam {}\n impl SelfParam {\n-    pub fn amp_token(&self) -> Option<Amp> { support::token(&self.syntax) }\n-    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![&]) }\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token2(&self.syntax, T![lifetime])\n+    }\n     pub fn self_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![self]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2230,7 +2234,7 @@ impl ast::TypeAscriptionOwner for Param {}\n impl ast::AttrsOwner for Param {}\n impl Param {\n     pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn dotdotdot_token(&self) -> Option<Dotdotdot> { support::token(&self.syntax) }\n+    pub fn dotdotdot_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![...]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseItem {\n@@ -2270,7 +2274,7 @@ impl AstNode for UseTree {\n }\n impl UseTree {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn star_token(&self) -> Option<Star> { support::token(&self.syntax) }\n+    pub fn star_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![*]) }\n     pub fn use_tree_list(&self) -> Option<UseTreeList> { support::child(&self.syntax) }\n     pub fn alias(&self) -> Option<Alias> { support::child(&self.syntax) }\n }\n@@ -2391,14 +2395,14 @@ impl AstNode for PathSegment {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl PathSegment {\n-    pub fn coloncolon_token(&self) -> Option<Coloncolon> { support::token(&self.syntax) }\n-    pub fn l_angle_token(&self) -> Option<LAngle> { support::token(&self.syntax) }\n+    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![::]) }\n+    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![<]) }\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n     pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n     pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n     pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n     pub fn path_type(&self) -> Option<PathType> { support::child(&self.syntax) }\n-    pub fn r_angle_token(&self) -> Option<RAngle> { support::token(&self.syntax) }\n+    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![>]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArgList {\n@@ -2416,14 +2420,14 @@ impl AstNode for TypeArgList {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl TypeArgList {\n-    pub fn coloncolon_token(&self) -> Option<Coloncolon> { support::token(&self.syntax) }\n-    pub fn l_angle_token(&self) -> Option<LAngle> { support::token(&self.syntax) }\n+    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![::]) }\n+    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![<]) }\n     pub fn generic_args(&self) -> AstChildren<GenericArg> { support::children(&self.syntax) }\n     pub fn type_args(&self) -> AstChildren<TypeArg> { support::children(&self.syntax) }\n     pub fn lifetime_args(&self) -> AstChildren<LifetimeArg> { support::children(&self.syntax) }\n     pub fn assoc_type_args(&self) -> AstChildren<AssocTypeArg> { support::children(&self.syntax) }\n     pub fn const_args(&self) -> AstChildren<ConstArg> { support::children(&self.syntax) }\n-    pub fn r_angle_token(&self) -> Option<RAngle> { support::token(&self.syntax) }\n+    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token2(&self.syntax, T![>]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArg {\n@@ -2480,7 +2484,9 @@ impl AstNode for LifetimeArg {\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl LifetimeArg {\n-    pub fn lifetime_token(&self) -> Option<Lifetime> { support::token(&self.syntax) }\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token2(&self.syntax, T![lifetime])\n+    }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ConstArg {"}, {"sha": "293f91c2e9ed4422eb4696135f86ca5e919a2ea3", "filename": "crates/ra_syntax/src/ast/generated/tokens.rs", "status": "modified", "additions": 0, "deletions": 239, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/8d71a6bf0ca51ae099a5b470afdb957bca321441/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d71a6bf0ca51ae099a5b470afdb957bca321441/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs?ref=8d71a6bf0ca51ae099a5b470afdb957bca321441", "patch": "@@ -1365,242 +1365,3 @@ impl AstToken for RDollar {\n     }\n     fn syntax(&self) -> &SyntaxToken { &self.syntax }\n }\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum RangeSeparator {\n-    Dotdot(Dotdot),\n-    Dotdotdot(Dotdotdot),\n-    Dotdoteq(Dotdoteq),\n-}\n-impl From<Dotdot> for RangeSeparator {\n-    fn from(node: Dotdot) -> RangeSeparator { RangeSeparator::Dotdot(node) }\n-}\n-impl From<Dotdotdot> for RangeSeparator {\n-    fn from(node: Dotdotdot) -> RangeSeparator { RangeSeparator::Dotdotdot(node) }\n-}\n-impl From<Dotdoteq> for RangeSeparator {\n-    fn from(node: Dotdoteq) -> RangeSeparator { RangeSeparator::Dotdoteq(node) }\n-}\n-impl std::fmt::Display for RangeSeparator {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl AstToken for RangeSeparator {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            DOTDOT | DOTDOTDOT | DOTDOTEQ => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            DOTDOT => RangeSeparator::Dotdot(Dotdot { syntax }),\n-            DOTDOTDOT => RangeSeparator::Dotdotdot(Dotdotdot { syntax }),\n-            DOTDOTEQ => RangeSeparator::Dotdoteq(Dotdoteq { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        match self {\n-            RangeSeparator::Dotdot(it) => &it.syntax,\n-            RangeSeparator::Dotdotdot(it) => &it.syntax,\n-            RangeSeparator::Dotdoteq(it) => &it.syntax,\n-        }\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum PrefixOp {\n-    Minus(Minus),\n-    Excl(Excl),\n-    Star(Star),\n-}\n-impl From<Minus> for PrefixOp {\n-    fn from(node: Minus) -> PrefixOp { PrefixOp::Minus(node) }\n-}\n-impl From<Excl> for PrefixOp {\n-    fn from(node: Excl) -> PrefixOp { PrefixOp::Excl(node) }\n-}\n-impl From<Star> for PrefixOp {\n-    fn from(node: Star) -> PrefixOp { PrefixOp::Star(node) }\n-}\n-impl std::fmt::Display for PrefixOp {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl AstToken for PrefixOp {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            MINUS | EXCL | STAR => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            MINUS => PrefixOp::Minus(Minus { syntax }),\n-            EXCL => PrefixOp::Excl(Excl { syntax }),\n-            STAR => PrefixOp::Star(Star { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        match self {\n-            PrefixOp::Minus(it) => &it.syntax,\n-            PrefixOp::Excl(it) => &it.syntax,\n-            PrefixOp::Star(it) => &it.syntax,\n-        }\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum RangeOp {\n-    Dotdot(Dotdot),\n-    Dotdoteq(Dotdoteq),\n-}\n-impl From<Dotdot> for RangeOp {\n-    fn from(node: Dotdot) -> RangeOp { RangeOp::Dotdot(node) }\n-}\n-impl From<Dotdoteq> for RangeOp {\n-    fn from(node: Dotdoteq) -> RangeOp { RangeOp::Dotdoteq(node) }\n-}\n-impl std::fmt::Display for RangeOp {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl AstToken for RangeOp {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            DOTDOT | DOTDOTEQ => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            DOTDOT => RangeOp::Dotdot(Dotdot { syntax }),\n-            DOTDOTEQ => RangeOp::Dotdoteq(Dotdoteq { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        match self {\n-            RangeOp::Dotdot(it) => &it.syntax,\n-            RangeOp::Dotdoteq(it) => &it.syntax,\n-        }\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum LiteralToken {\n-    IntNumber(IntNumber),\n-    FloatNumber(FloatNumber),\n-    String(String),\n-    RawString(RawString),\n-    ByteString(ByteString),\n-    RawByteString(RawByteString),\n-    Char(Char),\n-    Byte(Byte),\n-}\n-impl From<IntNumber> for LiteralToken {\n-    fn from(node: IntNumber) -> LiteralToken { LiteralToken::IntNumber(node) }\n-}\n-impl From<FloatNumber> for LiteralToken {\n-    fn from(node: FloatNumber) -> LiteralToken { LiteralToken::FloatNumber(node) }\n-}\n-impl From<String> for LiteralToken {\n-    fn from(node: String) -> LiteralToken { LiteralToken::String(node) }\n-}\n-impl From<RawString> for LiteralToken {\n-    fn from(node: RawString) -> LiteralToken { LiteralToken::RawString(node) }\n-}\n-impl From<ByteString> for LiteralToken {\n-    fn from(node: ByteString) -> LiteralToken { LiteralToken::ByteString(node) }\n-}\n-impl From<RawByteString> for LiteralToken {\n-    fn from(node: RawByteString) -> LiteralToken { LiteralToken::RawByteString(node) }\n-}\n-impl From<Char> for LiteralToken {\n-    fn from(node: Char) -> LiteralToken { LiteralToken::Char(node) }\n-}\n-impl From<Byte> for LiteralToken {\n-    fn from(node: Byte) -> LiteralToken { LiteralToken::Byte(node) }\n-}\n-impl std::fmt::Display for LiteralToken {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl AstToken for LiteralToken {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            INT_NUMBER | FLOAT_NUMBER | STRING | RAW_STRING | BYTE_STRING | RAW_BYTE_STRING\n-            | CHAR | BYTE => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            INT_NUMBER => LiteralToken::IntNumber(IntNumber { syntax }),\n-            FLOAT_NUMBER => LiteralToken::FloatNumber(FloatNumber { syntax }),\n-            STRING => LiteralToken::String(String { syntax }),\n-            RAW_STRING => LiteralToken::RawString(RawString { syntax }),\n-            BYTE_STRING => LiteralToken::ByteString(ByteString { syntax }),\n-            RAW_BYTE_STRING => LiteralToken::RawByteString(RawByteString { syntax }),\n-            CHAR => LiteralToken::Char(Char { syntax }),\n-            BYTE => LiteralToken::Byte(Byte { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        match self {\n-            LiteralToken::IntNumber(it) => &it.syntax,\n-            LiteralToken::FloatNumber(it) => &it.syntax,\n-            LiteralToken::String(it) => &it.syntax,\n-            LiteralToken::RawString(it) => &it.syntax,\n-            LiteralToken::ByteString(it) => &it.syntax,\n-            LiteralToken::RawByteString(it) => &it.syntax,\n-            LiteralToken::Char(it) => &it.syntax,\n-            LiteralToken::Byte(it) => &it.syntax,\n-        }\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum NameRefToken {\n-    Ident(Ident),\n-    IntNumber(IntNumber),\n-}\n-impl From<Ident> for NameRefToken {\n-    fn from(node: Ident) -> NameRefToken { NameRefToken::Ident(node) }\n-}\n-impl From<IntNumber> for NameRefToken {\n-    fn from(node: IntNumber) -> NameRefToken { NameRefToken::IntNumber(node) }\n-}\n-impl std::fmt::Display for NameRefToken {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl AstToken for NameRefToken {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            IDENT | INT_NUMBER => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            IDENT => NameRefToken::Ident(Ident { syntax }),\n-            INT_NUMBER => NameRefToken::IntNumber(IntNumber { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        match self {\n-            NameRefToken::Ident(it) => &it.syntax,\n-            NameRefToken::IntNumber(it) => &it.syntax,\n-        }\n-    }\n-}"}, {"sha": "554afc76aa7a3e55f453093486b0d691efdcb685", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 40, "deletions": 74, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/8d71a6bf0ca51ae099a5b470afdb957bca321441/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d71a6bf0ca51ae099a5b470afdb957bca321441/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=8d71a6bf0ca51ae099a5b470afdb957bca321441", "patch": "@@ -227,7 +227,6 @@ pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {\n pub(crate) struct AstSrc<'a> {\n     pub(crate) nodes: &'a [AstNodeSrc<'a>],\n     pub(crate) enums: &'a [AstEnumSrc<'a>],\n-    pub(crate) token_enums: &'a [AstEnumSrc<'a>],\n }\n \n pub(crate) struct AstNodeSrc<'a> {\n@@ -415,11 +414,11 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         struct TupleType { T!['('], fields: [TypeRef], T![')'] }\n         struct NeverType { T![!] }\n         struct PathType { Path }\n-        struct PointerType { Star, T![const], T![mut], TypeRef }\n+        struct PointerType { T![*], T![const], T![mut], TypeRef }\n         struct ArrayType { T!['['], TypeRef, T![;], Expr, T![']'] }\n         struct SliceType { T!['['], TypeRef, T![']'] }\n-        struct ReferenceType { Amp, Lifetime, T![mut], TypeRef }\n-        struct PlaceholderType { Underscore }\n+        struct ReferenceType { T![&], T![lifetime], T![mut], TypeRef }\n+        struct PlaceholderType { T![_] }\n         struct FnPointerType { Abi, T![unsafe], T![fn], ParamList, RetType }\n         struct ForType { T![for], TypeParamList, TypeRef }\n         struct ImplTraitType: TypeBoundsOwner { T![impl] }\n@@ -447,33 +446,33 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             iterable: Expr,\n         }\n         struct WhileExpr: AttrsOwner, LoopBodyOwner { T![while], Condition }\n-        struct ContinueExpr: AttrsOwner { T![continue], Lifetime }\n-        struct BreakExpr: AttrsOwner { T![break], Lifetime, Expr }\n-        struct Label { Lifetime }\n+        struct ContinueExpr: AttrsOwner { T![continue], T![lifetime] }\n+        struct BreakExpr: AttrsOwner { T![break], T![lifetime], Expr }\n+        struct Label { T![lifetime] }\n         struct BlockExpr: AttrsOwner { Label, T![unsafe], Block  }\n         struct ReturnExpr: AttrsOwner { Expr }\n         struct CallExpr: ArgListOwner { Expr }\n         struct MethodCallExpr: AttrsOwner, ArgListOwner {\n-            Expr, Dot, NameRef, TypeArgList,\n+            Expr, T![.], NameRef, TypeArgList,\n         }\n         struct IndexExpr: AttrsOwner { T!['['], T![']'] }\n-        struct FieldExpr: AttrsOwner { Expr, Dot, NameRef }\n-        struct AwaitExpr: AttrsOwner { Expr, Dot, T![await] }\n+        struct FieldExpr: AttrsOwner { Expr, T![.], NameRef }\n+        struct AwaitExpr: AttrsOwner { Expr, T![.], T![await] }\n         struct TryExpr: AttrsOwner { T![try], Expr }\n         struct CastExpr: AttrsOwner { Expr, T![as], TypeRef }\n-        struct RefExpr: AttrsOwner { Amp, T![raw], T![mut], Expr }\n-        struct PrefixExpr: AttrsOwner { PrefixOp, Expr }\n+        struct RefExpr: AttrsOwner { T![&], T![raw], T![mut], Expr }\n+        struct PrefixExpr: AttrsOwner { /*PrefixOp,*/ Expr }\n         struct BoxExpr: AttrsOwner { T![box], Expr }\n-        struct RangeExpr: AttrsOwner { RangeOp }\n+        struct RangeExpr: AttrsOwner { /*RangeOp*/ }\n         struct BinExpr: AttrsOwner { /*BinOp*/ }\n-        struct Literal { LiteralToken }\n+        struct Literal { /*LiteralToken*/ }\n \n         struct MatchExpr: AttrsOwner { T![match], Expr, MatchArmList }\n         struct MatchArmList: AttrsOwner { T!['{'], arms: [MatchArm], T!['}'] }\n         struct MatchArm: AttrsOwner {\n             pat: Pat,\n             guard: MatchGuard,\n-            FatArrow,\n+            T![=>],\n             Expr,\n         }\n         struct MatchGuard { T![if], Expr }\n@@ -482,22 +481,22 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         struct RecordFieldList {\n             T!['{'],\n             fields: [RecordField],\n-            Dotdot,\n+            T![..],\n             spread: Expr,\n             T!['}']\n         }\n-        struct RecordField: AttrsOwner { NameRef, Colon, Expr }\n+        struct RecordField: AttrsOwner { NameRef, T![:], Expr }\n \n         struct OrPat { pats: [Pat] }\n         struct ParenPat { T!['('], Pat, T![')'] }\n-        struct RefPat { Amp, T![mut], Pat }\n+        struct RefPat { T![&], T![mut], Pat }\n         struct BoxPat { T![box], Pat }\n-        struct BindPat: AttrsOwner, NameOwner { T![ref], T![mut], At, Pat }\n-        struct PlaceholderPat { Underscore }\n-        struct DotDotPat { Dotdot }\n+        struct BindPat: AttrsOwner, NameOwner { T![ref], T![mut], T![@], Pat }\n+        struct PlaceholderPat { T![_] }\n+        struct DotDotPat { T![..] }\n         struct PathPat { Path }\n         struct SlicePat { T!['['], args: [Pat], T![']'] }\n-        struct RangePat { RangeSeparator }\n+        struct RangePat { /*RangeSeparator*/ }\n         struct LiteralPat { Literal }\n         struct MacroPat { MacroCall }\n \n@@ -507,30 +506,30 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             pats: [RecordInnerPat],\n             record_field_pats: [RecordFieldPat],\n             bind_pats: [BindPat],\n-            Dotdot,\n+            T![..],\n             T!['}']\n         }\n-        struct RecordFieldPat: AttrsOwner, NameOwner { Colon, Pat }\n+        struct RecordFieldPat: AttrsOwner, NameOwner { T![:], Pat }\n \n         struct TupleStructPat { Path, T!['('], args: [Pat], T![')'] }\n         struct TuplePat { T!['('], args: [Pat], T![')'] }\n \n         struct Visibility { T![pub], T![super], T![self], T![crate] }\n-        struct Name { Ident }\n-        struct NameRef { NameRefToken }\n+        struct Name { T![ident] }\n+        struct NameRef { /*NameRefToken*/ }\n \n         struct MacroCall: NameOwner, AttrsOwner,DocCommentsOwner {\n             Path, T![!], TokenTree, T![;]\n         }\n-        struct Attr { Pound, T![!], T!['['], Path, T![=], input: AttrInput, T![']'] }\n+        struct Attr { T![#], T![!], T!['['], Path, T![=], input: AttrInput, T![']'] }\n         struct TokenTree {}\n         struct TypeParamList {\n-            LAngle,\n+            T![<],\n             generic_params: [GenericParam],\n             type_params: [TypeParam],\n             lifetime_params: [LifetimeParam],\n             const_params: [ConstParam],\n-            RAngle\n+            T![>]\n         }\n         struct TypeParam: NameOwner, AttrsOwner, TypeBoundsOwner {\n             T![=],\n@@ -540,12 +539,12 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             T![=],\n             default_val: Expr,\n         }\n-        struct LifetimeParam: AttrsOwner { Lifetime}\n-        struct TypeBound { Lifetime, /* Question,  */ T![const], /* Question,  */ TypeRef}\n+        struct LifetimeParam: AttrsOwner { T![lifetime] }\n+        struct TypeBound { T![lifetime], /* Question,  */ T![const], /* Question,  */ TypeRef}\n         struct TypeBoundList { bounds: [TypeBound] }\n-        struct WherePred: TypeBoundsOwner { Lifetime, TypeRef }\n+        struct WherePred: TypeBoundsOwner { T![lifetime], TypeRef }\n         struct WhereClause { T![where], predicates: [WherePred] }\n-        struct Abi { String }\n+        struct Abi { /*String*/ }\n         struct ExprStmt: AttrsOwner { Expr, T![;] }\n         struct LetStmt: AttrsOwner, TypeAscriptionOwner {\n             T![let],\n@@ -567,17 +566,17 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             params: [Param],\n             T![')']\n         }\n-        struct SelfParam: TypeAscriptionOwner, AttrsOwner { Amp, Lifetime, T![self] }\n+        struct SelfParam: TypeAscriptionOwner, AttrsOwner { T![&], T![lifetime], T![self] }\n         struct Param: TypeAscriptionOwner, AttrsOwner {\n             Pat,\n-            Dotdotdot\n+            T![...]\n         }\n         struct UseItem: AttrsOwner, VisibilityOwner {\n             T![use],\n             UseTree,\n         }\n         struct UseTree {\n-            Path, Star, UseTreeList, Alias\n+            Path, T![*], UseTreeList, Alias\n         }\n         struct Alias: NameOwner { T![as] }\n         struct UseTreeList { T!['{'], use_trees: [UseTree], T!['}'] }\n@@ -594,21 +593,21 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             qualifier: Path,\n         }\n         struct PathSegment {\n-            Coloncolon, LAngle, NameRef, TypeArgList, ParamList, RetType, PathType, RAngle\n+            T![::], T![<], NameRef, TypeArgList, ParamList, RetType, PathType, T![>]\n         }\n         struct TypeArgList {\n-            Coloncolon,\n-            LAngle,\n+            T![::],\n+            T![<],\n             generic_args: [GenericArg],\n             type_args: [TypeArg],\n             lifetime_args: [LifetimeArg],\n             assoc_type_args: [AssocTypeArg],\n             const_args: [ConstArg],\n-            RAngle\n+            T![>]\n         }\n         struct TypeArg { TypeRef }\n         struct AssocTypeArg : TypeBoundsOwner { NameRef, T![=], TypeRef }\n-        struct LifetimeArg { Lifetime }\n+        struct LifetimeArg { T![lifetime] }\n         struct ConstArg { Literal, T![=], BlockExpr }\n \n         struct MacroItems: ModuleItemOwner{ }\n@@ -767,37 +766,4 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             TupleFieldDefList,\n         }\n     },\n-\n-    token_enums: &ast_enums! {\n-        enum RangeSeparator { Dotdot, Dotdotdot, Dotdoteq}\n-\n-        enum PrefixOp {\n-            Minus,\n-            T![!],\n-            Star\n-        }\n-\n-        enum RangeOp {\n-            Dotdot,\n-            Dotdoteq\n-        }\n-\n-        enum LiteralToken {\n-            IntNumber,\n-            FloatNumber,\n-            String,\n-            RawString,\n-            // TrueKw,\n-            // FalseKw,\n-            ByteString,\n-            RawByteString,\n-            Char,\n-            Byte\n-        }\n-\n-        enum NameRefToken {\n-            Ident,\n-            IntNumber\n-        }\n-    },\n };"}, {"sha": "e6ba2009c1f644562538b9c9ffc9254510b1248c", "filename": "xtask/src/codegen.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d71a6bf0ca51ae099a5b470afdb957bca321441/xtask%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d71a6bf0ca51ae099a5b470afdb957bca321441/xtask%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen.rs?ref=8d71a6bf0ca51ae099a5b470afdb957bca321441", "patch": "@@ -24,7 +24,6 @@ const ERR_INLINE_TESTS_DIR: &str = \"crates/ra_syntax/test_data/parser/inline/err\n \n const SYNTAX_KINDS: &str = \"crates/ra_parser/src/syntax_kind/generated.rs\";\n const AST_NODES: &str = \"crates/ra_syntax/src/ast/generated/nodes.rs\";\n-const AST_TOKENS: &str = \"crates/ra_syntax/src/ast/generated/tokens.rs\";\n \n const ASSISTS_DIR: &str = \"crates/ra_assists/src/handlers\";\n const ASSISTS_TESTS: &str = \"crates/ra_assists/src/doc_tests/generated.rs\";"}, {"sha": "ce18f2b8f94827ce1b7b76fe57d725e588269d39", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 19, "deletions": 163, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/8d71a6bf0ca51ae099a5b470afdb957bca321441/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d71a6bf0ca51ae099a5b470afdb957bca321441/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=8d71a6bf0ca51ae099a5b470afdb957bca321441", "patch": "@@ -3,10 +3,7 @@\n //! Specifically, it generates the `SyntaxKind` enum and a number of newtype\n //! wrappers around `SyntaxNode` which implement `ra_syntax::AstNode`.\n \n-use std::{\n-    borrow::Cow,\n-    collections::{BTreeSet, HashSet},\n-};\n+use std::collections::{BTreeSet, HashSet};\n \n use proc_macro2::{Punct, Spacing};\n use quote::{format_ident, quote};\n@@ -26,10 +23,6 @@ pub fn generate_syntax(mode: Mode) -> Result<()> {\n     let contents = generate_nodes(KINDS_SRC, AST_SRC)?;\n     update(ast_nodes_file.as_path(), &contents, mode)?;\n \n-    let ast_tokens_file = project_root().join(codegen::AST_TOKENS);\n-    let contents = generate_tokens(KINDS_SRC, AST_SRC)?;\n-    update(ast_tokens_file.as_path(), &contents, mode)?;\n-\n     Ok(())\n }\n \n@@ -40,147 +33,7 @@ struct ElementKinds {\n     has_tokens: bool,\n }\n \n-fn generate_tokens(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n-    let all_token_kinds: Vec<_> = kinds\n-        .punct\n-        .into_iter()\n-        .map(|(_, kind)| kind)\n-        .copied()\n-        .map(|x| x.into())\n-        .chain(\n-            kinds\n-                .keywords\n-                .into_iter()\n-                .chain(kinds.contextual_keywords.into_iter())\n-                .map(|name| Cow::Owned(format!(\"{}_KW\", to_upper_snake_case(&name)))),\n-        )\n-        .chain(kinds.literals.into_iter().copied().map(|x| x.into()))\n-        .chain(kinds.tokens.into_iter().copied().map(|x| x.into()))\n-        .collect();\n-\n-    let tokens = all_token_kinds.iter().filter_map(|kind_str| {\n-        if kind_str.ends_with(\"_KW\") {\n-            return None;\n-        }\n-        let kind_str = &**kind_str;\n-        let kind = format_ident!(\"{}\", kind_str);\n-        let name = format_ident!(\"{}\", to_pascal_case(kind_str));\n-        let res = quote! {\n-            #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-            pub struct #name {\n-                pub(crate) syntax: SyntaxToken,\n-            }\n-\n-            impl std::fmt::Display for #name {\n-                fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-                    std::fmt::Display::fmt(&self.syntax, f)\n-                }\n-            }\n-\n-            impl AstToken for #name {\n-                fn can_cast(kind: SyntaxKind) -> bool { kind == #kind }\n-                fn cast(syntax: SyntaxToken) -> Option<Self> {\n-                    if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n-                }\n-                fn syntax(&self) -> &SyntaxToken { &self.syntax }\n-            }\n-        };\n-        Some(res)\n-    });\n-\n-    let enums = grammar.token_enums.iter().map(|en| {\n-        let variants = en.variants.iter().map(|var| format_ident!(\"{}\", var)).collect::<Vec<_>>();\n-        let name = format_ident!(\"{}\", en.name);\n-        let kinds = variants\n-            .iter()\n-            .map(|name| format_ident!(\"{}\", to_upper_snake_case(&name.to_string())))\n-            .collect::<Vec<_>>();\n-        assert!(en.traits.is_empty());\n-\n-        quote! {\n-                #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-                pub enum #name {\n-                    #(#variants(#variants),)*\n-                }\n-\n-                #(\n-                impl From<#variants> for #name {\n-                    fn from(node: #variants) -> #name {\n-                        #name::#variants(node)\n-                    }\n-                }\n-                )*\n-\n-                impl std::fmt::Display for #name {\n-                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-                        std::fmt::Display::fmt(self.syntax(), f)\n-                    }\n-                }\n-\n-                impl AstToken for #name {\n-                    fn can_cast(kind: SyntaxKind) -> bool {\n-                        match kind {\n-                            #(#kinds)|* => true,\n-                            _ => false,\n-                        }\n-                    }\n-                    fn cast(syntax: SyntaxToken) -> Option<Self> {\n-                        let res = match syntax.kind() {\n-                            #(\n-                            #kinds => #name::#variants(#variants { syntax }),\n-                            )*\n-                            _ => return None,\n-                        };\n-                        Some(res)\n-                    }\n-                    fn syntax(&self) -> &SyntaxToken {\n-                        match self {\n-                            #(\n-                            #name::#variants(it) => &it.syntax,\n-                            )*\n-                        }\n-                    }\n-                }\n-        }\n-    });\n-\n-    crate::reformat(quote! {\n-        use crate::{SyntaxToken, SyntaxKind::{self, *}, ast::AstToken};\n-\n-        #(#tokens)*\n-        #(#enums)*\n-    })\n-}\n-\n fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n-    let all_token_kinds: Vec<_> = kinds\n-        .punct\n-        .into_iter()\n-        .map(|(_, kind)| kind)\n-        .copied()\n-        .map(|x| x.into())\n-        .chain(\n-            kinds\n-                .keywords\n-                .into_iter()\n-                .chain(kinds.contextual_keywords.into_iter())\n-                .map(|name| Cow::Owned(format!(\"{}_KW\", to_upper_snake_case(&name)))),\n-        )\n-        .chain(kinds.literals.into_iter().copied().map(|x| x.into()))\n-        .chain(kinds.tokens.into_iter().copied().map(|x| x.into()))\n-        .collect();\n-\n-    let mut token_kinds = HashSet::new();\n-    for kind in &all_token_kinds {\n-        let kind = &**kind;\n-        let name = to_pascal_case(kind);\n-        token_kinds.insert(name);\n-    }\n-\n-    for en in grammar.token_enums {\n-        token_kinds.insert(en.name.to_string());\n-    }\n-\n     let nodes = grammar.nodes.iter().map(|node| {\n         let name = format_ident!(\"{}\", node.name);\n         let kind = format_ident!(\"{}\", to_upper_snake_case(&name.to_string()));\n@@ -207,19 +60,9 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n                         }\n                     }\n                 } else {\n-                    let is_token = token_kinds.contains(&ty.to_string());\n-                    if is_token {\n-                        let method_name = format_ident!(\"{}_token\", method_name);\n-                        quote! {\n-                            pub fn #method_name(&self) -> Option<#ty> {\n-                                support::token(&self.syntax)\n-                            }\n-                        }\n-                    } else {\n-                        quote! {\n-                            pub fn #method_name(&self) -> Option<#ty> {\n-                                support::child(&self.syntax)\n-                            }\n+                    quote! {\n+                        pub fn #method_name(&self) -> Option<#ty> {\n+                            support::child(&self.syntax)\n                         }\n                     }\n                 }\n@@ -338,8 +181,6 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n             T,\n         };\n \n-        use super::tokens::*;\n-\n         #(#nodes)*\n         #(#enums)*\n         #(#displays)*\n@@ -456,6 +297,8 @@ fn generate_syntax_kinds(grammar: KindsSrc<'_>) -> Result<String> {\n         macro_rules! T {\n             #((#punctuation_values) => { $crate::SyntaxKind::#punctuation };)*\n             #((#all_keywords_idents) => { $crate::SyntaxKind::#all_keywords };)*\n+            (lifetime) => { $crate::SyntaxKind::LIFETIME };\n+            (ident) => { $crate::SyntaxKind::IDENT };\n         }\n     };\n \n@@ -535,8 +378,21 @@ impl Field<'_> {\n                     \"')'\" => \"r_paren\",\n                     \"'['\" => \"l_brack\",\n                     \"']'\" => \"r_brack\",\n+                    \"<\" => \"l_angle\",\n+                    \">\" => \"r_angle\",\n                     \"=\" => \"eq\",\n                     \"!\" => \"excl\",\n+                    \"*\" => \"star\",\n+                    \"&\" => \"amp\",\n+                    \"_\" => \"underscore\",\n+                    \".\" => \"dot\",\n+                    \"..\" => \"dotdot\",\n+                    \"...\" => \"dotdotdot\",\n+                    \"=>\" => \"fat_arrow\",\n+                    \"@\" => \"at\",\n+                    \":\" => \"colon\",\n+                    \"::\" => \"coloncolon\",\n+                    \"#\" => \"pound\",\n                     _ => name,\n                 };\n                 format_ident!(\"{}_token\", name)"}]}