{"sha": "085790a73a0527a06055ab0823066bc407a52741", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4NTc5MGE3M2EwNTI3YTA2MDU1YWIwODIzMDY2YmM0MDdhNTI3NDE=", "commit": {"author": {"name": "Roy Frostig", "email": "rfrostig@mozilla.com", "date": "2010-08-04T00:52:35Z"}, "committer": {"name": "Roy Frostig", "email": "rfrostig@mozilla.com", "date": "2010-08-04T00:52:35Z"}, "message": "More stdlib hashmap bits (plus some drive-by extras).", "tree": {"sha": "87a68308532ff48ba73bcfb990b82dcc9213746a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87a68308532ff48ba73bcfb990b82dcc9213746a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/085790a73a0527a06055ab0823066bc407a52741", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/085790a73a0527a06055ab0823066bc407a52741", "html_url": "https://github.com/rust-lang/rust/commit/085790a73a0527a06055ab0823066bc407a52741", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/085790a73a0527a06055ab0823066bc407a52741/comments", "author": {"login": "froystig", "id": 123903, "node_id": "MDQ6VXNlcjEyMzkwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/123903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/froystig", "html_url": "https://github.com/froystig", "followers_url": "https://api.github.com/users/froystig/followers", "following_url": "https://api.github.com/users/froystig/following{/other_user}", "gists_url": "https://api.github.com/users/froystig/gists{/gist_id}", "starred_url": "https://api.github.com/users/froystig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/froystig/subscriptions", "organizations_url": "https://api.github.com/users/froystig/orgs", "repos_url": "https://api.github.com/users/froystig/repos", "events_url": "https://api.github.com/users/froystig/events{/privacy}", "received_events_url": "https://api.github.com/users/froystig/received_events", "type": "User", "site_admin": false}, "committer": {"login": "froystig", "id": 123903, "node_id": "MDQ6VXNlcjEyMzkwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/123903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/froystig", "html_url": "https://github.com/froystig", "followers_url": "https://api.github.com/users/froystig/followers", "following_url": "https://api.github.com/users/froystig/following{/other_user}", "gists_url": "https://api.github.com/users/froystig/gists{/gist_id}", "starred_url": "https://api.github.com/users/froystig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/froystig/subscriptions", "organizations_url": "https://api.github.com/users/froystig/orgs", "repos_url": "https://api.github.com/users/froystig/repos", "events_url": "https://api.github.com/users/froystig/events{/privacy}", "received_events_url": "https://api.github.com/users/froystig/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b91933eed28c5b4dee2fc96cd903395247d63d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b91933eed28c5b4dee2fc96cd903395247d63d1", "html_url": "https://github.com/rust-lang/rust/commit/7b91933eed28c5b4dee2fc96cd903395247d63d1"}], "stats": {"total": 123, "additions": 89, "deletions": 34}, "files": [{"sha": "9b756675d882914b3c4ce98292d6c31d3f8c6374", "filename": "src/lib/_int.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/085790a73a0527a06055ab0823066bc407a52741/src%2Flib%2F_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/085790a73a0527a06055ab0823066bc407a52741/src%2Flib%2F_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_int.rs?ref=085790a73a0527a06055ab0823066bc407a52741", "patch": "@@ -13,6 +13,11 @@ fn ne(int x, int y) -> bool { ret x != y; }\n fn ge(int x, int y) -> bool { ret x >= y; }\n fn gt(int x, int y) -> bool { ret x > y; }\n \n+fn positive(int x) -> bool { ret x > 0; }\n+fn negative(int x) -> bool { ret x < 0; }\n+fn nonpositive(int x) -> bool { ret x <= 0; }\n+fn nonnegative(int x) -> bool { ret x >= 0; }\n+\n iter range(mutable int lo, int hi) -> int {\n   while (lo < hi) {\n     put lo;"}, {"sha": "a544aea8871e5123e3377fafee2cdc75421a7da4", "filename": "src/lib/map.rs", "status": "modified", "additions": 76, "deletions": 33, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/085790a73a0527a06055ab0823066bc407a52741/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/085790a73a0527a06055ab0823066bc407a52741/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=085790a73a0527a06055ab0823066bc407a52741", "patch": "@@ -26,7 +26,11 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n   let uint initial_capacity = 32u; // 2^5\n   let util.rational load_factor = rec(num=3, den=4);\n \n-  type bucket[V] = tag(nil(), deleted(), some(V));\n+  type bucket[K, V] = tag(nil(), deleted(), some(K, V));\n+\n+  fn make_buckets[K, V](uint nbkts) -> vec[mutable bucket[K, V]] {\n+    ret _vec.init_elt[mutable bucket[K, V]](nil[K, V](), nbkts);\n+  }\n \n   // Derive two hash functions from the one given by taking the upper\n   // half and lower half of the uint bits.  Our bucket probing\n@@ -57,57 +61,93 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n     ret hashl[K](hasher, nbkts, key) + i * hashr[K](hasher, nbkts, key);\n   }\n \n+  /**\n+   * We attempt to never call this with a full table.  If we do, it\n+   * will fail.\n+   */\n+  fn insert_common[K, V](hashfn[K] hasher,\n+                         vec[mutable bucket[K, V]] bkts,\n+                         uint nbkts,\n+                         &K key,\n+                         &V val)\n+  {\n+    let uint i = 0u;\n+    while (i < nbkts) {\n+      // FIXME (issue #94): as in find_common()\n+      let int j = (hash[K](hasher, nbkts, key, i)) as int;\n+      alt (bkts.(j)) {\n+        case (some[K, V](_, _)) {\n+          i += 1u;\n+        }\n+        case (_) {\n+          bkts.(j) = some[K, V](key, val);\n+          ret;\n+        }\n+      }\n+    }\n+    fail; // full table\n+  }\n+\n   fn find_common[K, V](hashfn[K] hasher,\n-                       vec[mutable bucket[V]] bkts,\n+                       vec[mutable bucket[K, V]] bkts,\n                        uint nbkts,\n                        &K key)\n     -> util.option[V]\n   {\n     let uint i = 0u;\n     while (i < nbkts) {\n-      // Pending fix to issue #94, remove uint coercion.\n+      // FIXME (issue #94):  Pending bugfix, remove uint coercion.\n       let int j = (hash[K](hasher, nbkts, key, i)) as int;\n       alt (bkts.(j)) {\n-        case (some[V](val)) {\n+        case (some[K, V](_, val)) {\n           ret util.some[V](val);\n         }\n-        case (nil[V]()) {\n+        case (nil[K, V]()) {\n           ret util.none[V]();\n         }\n-        case (deleted[V]()) {\n+        case (deleted[K, V]()) {\n           i += 1u;\n         }\n       }\n     }\n     ret util.none[V]();\n   }\n \n+\n+  fn rehash[K, V](hashfn[K] hasher,\n+                  vec[mutable bucket[K, V]] oldbkts, uint noldbkts,\n+                  vec[mutable bucket[K, V]] newbkts, uint nnewbkts)\n+  {\n+    for (bucket[K, V] b in oldbkts) {\n+      alt (b) {\n+        case (some[K, V](k, v)) {\n+          insert_common[K, V](hasher, newbkts, nnewbkts, k, v);\n+        }\n+        case (_) { }\n+      }\n+    }\n+  }\n+\n   obj hashmap[K, V](hashfn[K] hasher,\n                     eqfn[K] eqer,\n-                    mutable vec[mutable bucket[V]] bkts,\n+                    mutable vec[mutable bucket[K, V]] bkts,\n                     mutable uint nbkts,\n                     mutable uint nelts,\n                     util.rational lf)\n   {\n     fn insert(&K key, &V val) {\n-      // FIXME grow the table and rehash if we ought to.\n-      let uint i = 0u;\n-      while (i < nbkts) {\n-        // Issue #94, as in find_common()\n-        let int j = (hash[K](hasher, nbkts, key, i)) as int;\n-        alt (bkts.(j)) {\n-          case (some[V](_)) {\n-            i += 1u;\n-          }\n-          case (_) {\n-            bkts.(j) = some[V](val);\n-            nelts += 1u;\n-            ret;\n-          }\n-        }\n+      let util.rational load = rec(num=(nelts + 1u) as int, den=nbkts as int);\n+      if (!util.rational_leq(load, lf)) {\n+        let uint nnewbkts = _int.next_power_of_two(nbkts + 1u);\n+\n+        // FIXME (issue #94):  Enforce our workaround to issue #94.\n+        check ((nnewbkts as int) > 0);\n+\n+        let vec[mutable bucket[K, V]] newbkts = make_buckets[K, V](nnewbkts);\n+        rehash[K, V](hasher, bkts, nbkts, newbkts, nnewbkts);\n       }\n-      // full table, impossible unless growth is broken. remove after testing.\n-      fail;\n+      insert_common[K, V](hasher, bkts, nbkts, key, val);\n+      nelts += 1u;\n     }\n \n     fn contains_key(&K key) -> bool {\n@@ -131,29 +171,32 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n     fn remove(&K key) -> util.option[V] {\n       let uint i = 0u;\n       while (i < nbkts) {\n-        // Issue #94, as in find_common()\n+        // FIXME (issue #94): as in find_common()\n         let int j = (hash[K](hasher, nbkts, key, i)) as int;\n         alt (bkts.(j)) {\n-          case (some[V](val)) {\n-            bkts.(j) = deleted[V]();\n+          case (some[K, V](_, val)) {\n+            bkts.(j) = deleted[K, V]();\n             ret util.some[V](val);\n           }\n-          case (deleted[V]()) {\n+          case (deleted[K, V]()) {\n             nelts += 1u;\n           }\n-          case (nil[V]()) {\n+          case (nil[K, V]()) {\n             ret util.none[V]();\n           }\n         }\n       }\n       ret util.none[V]();\n     }\n \n-    fn rehash() {}\n+    fn rehash() {\n+      let vec[mutable bucket[K, V]] newbkts = make_buckets[K, V](nbkts);\n+      rehash[K, V](hasher, bkts, nbkts, newbkts, nbkts);\n+      bkts = newbkts;\n+    }\n   }\n \n-  let vec[mutable bucket[V]] bkts =\n-    _vec.init_elt[mutable bucket[V]](nil[V](), initial_capacity);\n+  let vec[mutable bucket[K, V]] bkts = make_buckets[K, V](initial_capacity);\n \n-  ret hashmap[K, V](hasher, eqer, bkts, 0u, 0u, load_factor);\n+  ret hashmap[K, V](hasher, eqer, bkts, initial_capacity, 0u, load_factor);\n }"}, {"sha": "5d0f4b49f8c019034874add2b2eca5711db76978", "filename": "src/lib/util.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/085790a73a0527a06055ab0823066bc407a52741/src%2Flib%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/085790a73a0527a06055ab0823066bc407a52741/src%2Flib%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Futil.rs?ref=085790a73a0527a06055ab0823066bc407a52741", "patch": "@@ -17,4 +17,11 @@ fn id[T](T x) -> T {\n   ret x;\n }\n \n-type rational = rec(int num, int den);\n+/* FIXME (issue #141):  See test/run-pass/constrained-type.rs.  Uncomment\n+ * the constraint once fixed. */\n+type rational = rec(int num, int den); // : _int.positive(*.den);\n+\n+fn rational_leq(&rational x, &rational y) -> bool {\n+  // NB: Uses the fact that rationals have positive denominators WLOG.\n+  ret x.num * y.den <= y.num * x.den;\n+}"}]}