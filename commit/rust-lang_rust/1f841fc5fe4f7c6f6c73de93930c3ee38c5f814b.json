{"sha": "1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b", "node_id": "C_kwDOAAsO6NoAKDFmODQxZmM1ZmU0ZjdjNmY2YzczZGU5MzkzMGMzZWUzOGM1ZjgxNGI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-08T05:47:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-08T05:47:31Z"}, "message": "Rollup merge of #86497 - clarfonthey:nearest_char_boundary, r=scottmcm\n\nAdd {floor,ceil}_char_boundary methods to str\n\nThis is technically already used internally by the standard library in the form of `truncate_to_char_boundary`.\n\nEssentially these are two building blocks to allow for approximate string truncation, where you want to cut off the string at \"approximately\" a given length in bytes but don't know exactly where the character boundaries lie. It's also a good candidate for the standard library as it can easily be done naively, but would be difficult to properly optimise. Although the existing code that's done in error messages is done naively, this code will explicitly only check a window of 4 bytes since we know that a boundary must lie in that range, and because it will make it possible to vectorise.\n\nAlthough this method doesn't take into account graphemes or other properties, this would still be a required building block for splitting that takes those into account. For example, if you wanted to split at a grapheme boundary, you could take your approximate splitting point and then determine the graphemes immediately following and preceeding the split. If you then notice that these two graphemes could be merged, you can decide to either include the whole grapheme or exclude it depending on whether you decide splitting should shrink or expand the string.\n\nThis takes the most conservative approach and just offers the raw indices to the user, and they can decide how to use them. That way, the methods are as useful as possible despite having as few methods as possible.\n\n(Note: I'll add some tests and a tracking issue if it's decided that this is worth including.)", "tree": {"sha": "15eea9ca0ac17b89ed6dcc3d6b4c6a467ab5fc57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15eea9ca0ac17b89ed6dcc3d6b4c6a467ab5fc57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiAgPzCRBK7hj4Ov3rIwAAbIAIACSjWbZDXuf1RxQcEiSwIFfm\nvW9e4Wqgdg9UQJKVtp+2GRlHOWi68hIpRSvznGEuU5qccx+8hl+9AWzVSU2NqEA2\nNR2UTgXtyTyeQH4ez3ncR63IrabkXApGaJD0j9bTFtUBf03/TqCiAslmZv/EmiPC\nH2zMm5D+k9kCmqXXF2/v9SYQXjzsqjGYsSlyTuKSfCO4hlkjWhJQgjwEMgxmxUZa\nEB5LC7tq5kiXK6ukpCeueMWEZLOV2KeteAXjLugiMaXaluXY7L2bG58cT2CREqmP\nwCTLnrx1Si+0F1OJZA8fvKa5G3XqF4YtWlAXFomdaJWl6Juw8Q5rkRKbDOEAZaY=\n=zVMO\n-----END PGP SIGNATURE-----\n", "payload": "tree 15eea9ca0ac17b89ed6dcc3d6b4c6a467ab5fc57\nparent e7cc3bddbe0d0e374d05e7003e662bba1742dbae\nparent edd318c313763d8c4cf3e8cc339f433832d6454a\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1644299251 +0100\ncommitter GitHub <noreply@github.com> 1644299251 +0100\n\nRollup merge of #86497 - clarfonthey:nearest_char_boundary, r=scottmcm\n\nAdd {floor,ceil}_char_boundary methods to str\n\nThis is technically already used internally by the standard library in the form of `truncate_to_char_boundary`.\n\nEssentially these are two building blocks to allow for approximate string truncation, where you want to cut off the string at \"approximately\" a given length in bytes but don't know exactly where the character boundaries lie. It's also a good candidate for the standard library as it can easily be done naively, but would be difficult to properly optimise. Although the existing code that's done in error messages is done naively, this code will explicitly only check a window of 4 bytes since we know that a boundary must lie in that range, and because it will make it possible to vectorise.\n\nAlthough this method doesn't take into account graphemes or other properties, this would still be a required building block for splitting that takes those into account. For example, if you wanted to split at a grapheme boundary, you could take your approximate splitting point and then determine the graphemes immediately following and preceeding the split. If you then notice that these two graphemes could be merged, you can decide to either include the whole grapheme or exclude it depending on whether you decide splitting should shrink or expand the string.\n\nThis takes the most conservative approach and just offers the raw indices to the user, and they can decide how to use them. That way, the methods are as useful as possible despite having as few methods as possible.\n\n(Note: I'll add some tests and a tracking issue if it's decided that this is worth including.)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b", "html_url": "https://github.com/rust-lang/rust/commit/1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "html_url": "https://github.com/rust-lang/rust/commit/e7cc3bddbe0d0e374d05e7003e662bba1742dbae"}, {"sha": "edd318c313763d8c4cf3e8cc339f433832d6454a", "url": "https://api.github.com/repos/rust-lang/rust/commits/edd318c313763d8c4cf3e8cc339f433832d6454a", "html_url": "https://github.com/rust-lang/rust/commit/edd318c313763d8c4cf3e8cc339f433832d6454a"}], "stats": {"total": 199, "additions": 176, "deletions": 23}, "files": [{"sha": "cbb86265233b0bdcc4578ffb210396b135d1f405", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b", "patch": "@@ -29,6 +29,7 @@\n #![feature(binary_heap_as_slice)]\n #![feature(inplace_iteration)]\n #![feature(iter_advance_by)]\n+#![feature(round_char_boundary)]\n #![feature(slice_group_by)]\n #![feature(slice_partition_dedup)]\n #![feature(string_remove_matches)]"}, {"sha": "6b8be2506b64e5bc8d179eaae03798c003ce42f9", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b", "patch": "@@ -2272,3 +2272,95 @@ fn utf8_char_counts() {\n         }\n     }\n }\n+\n+#[test]\n+fn floor_char_boundary() {\n+    fn check_many(s: &str, arg: impl IntoIterator<Item = usize>, ret: usize) {\n+        for idx in arg {\n+            assert_eq!(\n+                s.floor_char_boundary(idx),\n+                ret,\n+                \"{:?}.floor_char_boundary({:?}) != {:?}\",\n+                s,\n+                idx,\n+                ret\n+            );\n+        }\n+    }\n+\n+    // edge case\n+    check_many(\"\", [0, 1, isize::MAX as usize, usize::MAX], 0);\n+\n+    // basic check\n+    check_many(\"x\", [0], 0);\n+    check_many(\"x\", [1, isize::MAX as usize, usize::MAX], 1);\n+\n+    // 1-byte chars\n+    check_many(\"jp\", [0], 0);\n+    check_many(\"jp\", [1], 1);\n+    check_many(\"jp\", 2..4, 2);\n+\n+    // 2-byte chars\n+    check_many(\"\u0135\u01a5\", 0..2, 0);\n+    check_many(\"\u0135\u01a5\", 2..4, 2);\n+    check_many(\"\u0135\u01a5\", 4..6, 4);\n+\n+    // 3-byte chars\n+    check_many(\"\u65e5\u672c\", 0..3, 0);\n+    check_many(\"\u65e5\u672c\", 3..6, 3);\n+    check_many(\"\u65e5\u672c\", 6..8, 6);\n+\n+    // 4-byte chars\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 0..4, 0);\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 4..8, 4);\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 8..10, 8);\n+}\n+\n+#[test]\n+fn ceil_char_boundary() {\n+    fn check_many(s: &str, arg: impl IntoIterator<Item = usize>, ret: usize) {\n+        for idx in arg {\n+            assert_eq!(\n+                s.ceil_char_boundary(idx),\n+                ret,\n+                \"{:?}.ceil_char_boundary({:?}) != {:?}\",\n+                s,\n+                idx,\n+                ret\n+            );\n+        }\n+    }\n+\n+    // edge case\n+    check_many(\"\", [0], 0);\n+\n+    // basic check\n+    check_many(\"x\", [0], 0);\n+    check_many(\"x\", [1], 1);\n+\n+    // 1-byte chars\n+    check_many(\"jp\", [0], 0);\n+    check_many(\"jp\", [1], 1);\n+    check_many(\"jp\", [2], 2);\n+\n+    // 2-byte chars\n+    check_many(\"\u0135\u01a5\", 0..=0, 0);\n+    check_many(\"\u0135\u01a5\", 1..=2, 2);\n+    check_many(\"\u0135\u01a5\", 3..=4, 4);\n+\n+    // 3-byte chars\n+    check_many(\"\u65e5\u672c\", 0..=0, 0);\n+    check_many(\"\u65e5\u672c\", 1..=3, 3);\n+    check_many(\"\u65e5\u672c\", 4..=6, 6);\n+\n+    // 4-byte chars\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 0..=0, 0);\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 1..=4, 4);\n+    check_many(\"\ud83c\uddef\ud83c\uddf5\", 5..=8, 8);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn ceil_char_boundary_above_len_panic() {\n+    let _ = \"x\".ceil_char_boundary(2);\n+}"}, {"sha": "864a253299f6e28b00a58691006b3ccc2f84ada4", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b", "patch": "@@ -809,6 +809,11 @@ impl u8 {\n     pub fn escape_ascii(&self) -> ascii::EscapeDefault {\n         ascii::escape_default(*self)\n     }\n+\n+    pub(crate) fn is_utf8_char_boundary(self) -> bool {\n+        // This is bit magic equivalent to: b < 128 || b >= 192\n+        (self as i8) >= -0x40\n+    }\n }\n \n #[lang = \"u16\"]"}, {"sha": "09709dc3cf6dfbd187f2ecfe020ad0a6a07fbe33", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 78, "deletions": 10, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b", "patch": "@@ -76,15 +76,14 @@ use iter::MatchIndicesInternal;\n use iter::SplitInternal;\n use iter::{MatchesInternal, SplitNInternal};\n \n-use validations::truncate_to_char_boundary;\n-\n #[inline(never)]\n #[cold]\n #[track_caller]\n fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n     const MAX_DISPLAY_LENGTH: usize = 256;\n-    let (truncated, s_trunc) = truncate_to_char_boundary(s, MAX_DISPLAY_LENGTH);\n-    let ellipsis = if truncated { \"[...]\" } else { \"\" };\n+    let trunc_len = s.floor_char_boundary(MAX_DISPLAY_LENGTH);\n+    let s_trunc = &s[..trunc_len];\n+    let ellipsis = if trunc_len < s.len() { \"[...]\" } else { \"\" };\n \n     // 1. out of bounds\n     if begin > s.len() || end > s.len() {\n@@ -105,10 +104,7 @@ fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n     // 3. character boundary\n     let index = if !s.is_char_boundary(begin) { begin } else { end };\n     // find the character\n-    let mut char_start = index;\n-    while !s.is_char_boundary(char_start) {\n-        char_start -= 1;\n-    }\n+    let char_start = s.floor_char_boundary(index);\n     // `char_start` must be less than len and a char boundary\n     let ch = s[char_start..].chars().next().unwrap();\n     let char_range = char_start..char_start + ch.len_utf8();\n@@ -215,8 +211,80 @@ impl str {\n             // code on higher opt-levels. See PR #84751 for more details.\n             None => index == self.len(),\n \n-            // This is bit magic equivalent to: b < 128 || b >= 192\n-            Some(&b) => (b as i8) >= -0x40,\n+            Some(&b) => b.is_utf8_char_boundary(),\n+        }\n+    }\n+\n+    /// Finds the closest `x` not exceeding `index` where `is_char_boundary(x)` is `true`.\n+    ///\n+    /// This method can help you truncate a string so that it's still valid UTF-8, but doesn't\n+    /// exceed a given number of bytes. Note that this is done purely at the character level\n+    /// and can still visually split graphemes, even though the underlying characters aren't\n+    /// split. For example, the emoji \ud83e\uddd1\u200d\ud83d\udd2c (scientist) could be split so that the string only\n+    /// includes \ud83e\uddd1 (person) instead.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(round_char_boundary)]\n+    /// let s = \"\u2764\ufe0f\ud83e\udde1\ud83d\udc9b\ud83d\udc9a\ud83d\udc99\ud83d\udc9c\";\n+    /// assert_eq!(s.len(), 26);\n+    /// assert!(!s.is_char_boundary(13));\n+    ///\n+    /// let closest = s.floor_char_boundary(13);\n+    /// assert_eq!(closest, 10);\n+    /// assert_eq!(&s[..closest], \"\u2764\ufe0f\ud83e\udde1\");\n+    /// ```\n+    #[unstable(feature = \"round_char_boundary\", issue = \"93743\")]\n+    #[inline]\n+    pub fn floor_char_boundary(&self, index: usize) -> usize {\n+        if index >= self.len() {\n+            self.len()\n+        } else {\n+            let lower_bound = index.saturating_sub(3);\n+            let new_index = self.as_bytes()[lower_bound..=index]\n+                .iter()\n+                .rposition(|b| b.is_utf8_char_boundary());\n+\n+            // SAFETY: we know that the character boundary will be within four bytes\n+            unsafe { lower_bound + new_index.unwrap_unchecked() }\n+        }\n+    }\n+\n+    /// Finds the closest `x` not below `index` where `is_char_boundary(x)` is `true`.\n+    ///\n+    /// This method is the natural complement to [`floor_char_boundary`]. See that method\n+    /// for more details.\n+    ///\n+    /// [`floor_char_boundary`]: str::floor_char_boundary\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index > self.len()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(round_char_boundary)]\n+    /// let s = \"\u2764\ufe0f\ud83e\udde1\ud83d\udc9b\ud83d\udc9a\ud83d\udc99\ud83d\udc9c\";\n+    /// assert_eq!(s.len(), 26);\n+    /// assert!(!s.is_char_boundary(13));\n+    ///\n+    /// let closest = s.ceil_char_boundary(13);\n+    /// assert_eq!(closest, 14);\n+    /// assert_eq!(&s[..closest], \"\u2764\ufe0f\ud83e\udde1\ud83d\udc9b\");\n+    /// ```\n+    #[unstable(feature = \"round_char_boundary\", issue = \"93743\")]\n+    #[inline]\n+    pub fn ceil_char_boundary(&self, index: usize) -> usize {\n+        if index > self.len() {\n+            slice_error_fail(self, index, index)\n+        } else {\n+            let upper_bound = Ord::min(index + 4, self.len());\n+            self.as_bytes()[index..upper_bound]\n+                .iter()\n+                .position(|b| b.is_utf8_char_boundary())\n+                .map_or(upper_bound, |pos| pos + index)\n         }\n     }\n "}, {"sha": "0d3dc856be577c44669176a29cb182c6cdc95316", "filename": "library/core/src/str/validations.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs?ref=1f841fc5fe4f7c6f6c73de93930c3ee38c5f814b", "patch": "@@ -273,16 +273,3 @@ pub const fn utf8_char_width(b: u8) -> usize {\n \n /// Mask of the value bits of a continuation byte.\n const CONT_MASK: u8 = 0b0011_1111;\n-\n-// truncate `&str` to length at most equal to `max`\n-// return `true` if it were truncated, and the new str.\n-pub(super) fn truncate_to_char_boundary(s: &str, mut max: usize) -> (bool, &str) {\n-    if max >= s.len() {\n-        (false, s)\n-    } else {\n-        while !s.is_char_boundary(max) {\n-            max -= 1;\n-        }\n-        (true, &s[..max])\n-    }\n-}"}]}