{"sha": "d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1ZDc3YjkzNTFiZGNiN2E5ZmQ3YzZhMjc5NTA5OTBkMzNlZWEyMzI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-16T00:05:20Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-20T22:08:18Z"}, "message": "convert the remaining ast record types into structs\n\nThese are: region,arg,fn_decl,method,_mod,foreign_mod,\nvariant_arg,enum_def_,variant_,trait_ref.", "tree": {"sha": "d5d51cb523cbdd41ce069d1c4478437bf1cfff5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5d51cb523cbdd41ce069d1c4478437bf1cfff5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "html_url": "https://github.com/rust-lang/rust/commit/d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ba7e55a4c42f6a53eccb60d4098b9422dd6e345", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ba7e55a4c42f6a53eccb60d4098b9422dd6e345", "html_url": "https://github.com/rust-lang/rust/commit/5ba7e55a4c42f6a53eccb60d4098b9422dd6e345"}], "stats": {"total": 540, "additions": 335, "deletions": 205}, "files": [{"sha": "e7c78cd48eeefe5ad83829689b121f9af5f44c7c", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -361,7 +361,7 @@ mod test {\n         if with_bin { attrs += ~[make_crate_type_attr(~\"bin\")]; }\n         if with_lib { attrs += ~[make_crate_type_attr(~\"lib\")]; }\n         @ast_util::respan(ast_util::dummy_sp(), ast::crate_ {\n-            module: {view_items: ~[], items: ~[]},\n+            module: ast::_mod { view_items: ~[], items: ~[] },\n             attrs: attrs,\n             config: ~[]\n         })"}, {"sha": "3f75bba7a372d135e257e8e23494ad4b4f07ae8c", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -67,15 +67,14 @@ fn filter_view_item(cx: ctxt, &&view_item: @ast::view_item\n     }\n }\n \n-fn fold_mod(cx: ctxt, m: ast::_mod, fld: fold::ast_fold) ->\n-   ast::_mod {\n+fn fold_mod(cx: ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     let filtered_items = vec::filter_map(m.items, |a| filter_item(cx, *a));\n     let filtered_view_items = vec::filter_map(m.view_items,\n                                               |a| filter_view_item(cx, *a));\n-    return {\n-        view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(*x)),\n-        items: vec::filter_map(filtered_items, |x| fld.fold_item(*x))\n-    };\n+    ast::_mod {\n+        view_items: filtered_view_items.map(|x| fld.fold_view_item(*x)),\n+        items: filtered_items.filter_map(|x| fld.fold_item(*x)),\n+    }\n }\n \n fn filter_foreign_item(cx: ctxt, &&item: @ast::foreign_item) ->\n@@ -85,18 +84,21 @@ fn filter_foreign_item(cx: ctxt, &&item: @ast::foreign_item) ->\n     } else { option::None }\n }\n \n-fn fold_foreign_mod(cx: ctxt, nm: ast::foreign_mod,\n-                   fld: fold::ast_fold) -> ast::foreign_mod {\n+fn fold_foreign_mod(\n+    cx: ctxt,\n+    nm: ast::foreign_mod,\n+    fld: fold::ast_fold\n+) -> ast::foreign_mod {\n     let filtered_items = vec::filter_map(nm.items,\n                                          |a| filter_foreign_item(cx, *a));\n     let filtered_view_items = vec::filter_map(nm.view_items,\n                                               |a| filter_view_item(cx, *a));\n-    return {\n+    ast::foreign_mod {\n         sort: nm.sort,\n         abi: nm.abi,\n         view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(*x)),\n         items: filtered_items\n-    };\n+    }\n }\n \n fn fold_item_underscore(cx: ctxt, +item: ast::item_,"}, {"sha": "6762247aba03f2b4a7078dfb826d0b539aeae4f4", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -62,7 +62,7 @@ fn inject_libcore_ref(sess: Session,\n             };\n \n             let vis = vec::append(~[vi1], crate.module.view_items);\n-            let mut new_module = {\n+            let mut new_module = ast::_mod {\n                 view_items: vis,\n                 ../*bad*/copy crate.module\n             };\n@@ -95,7 +95,7 @@ fn inject_libcore_ref(sess: Session,\n             let vis = vec::append(~[vi2], module.view_items);\n \n             // FIXME #2543: Bad copy.\n-            let new_module = { view_items: vis, ..copy module };\n+            let new_module = ast::_mod { view_items: vis, ..copy module };\n             fold::noop_fold_mod(new_module, fld)\n         },\n         ..*fold::default_ast_fold()"}, {"sha": "6bf05e9dbd964a3d611867bc5effb976534166bf", "filename": "src/librustc/front/intrinsic_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -38,7 +38,7 @@ fn inject_intrinsic(sess: Session, crate: @ast::crate) -> @ast::crate {\n \n     @ast::spanned {\n         node: ast::crate_ {\n-            module: {\n+            module: ast::_mod {\n                 items: items,\n                 .. /*bad*/copy crate.node.module\n             },"}, {"sha": "813dc268d565ab8c59e245bcbe4db60738fc964c", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -97,10 +97,12 @@ fn fold_mod(cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n         } else { item }\n     }\n \n-    let mod_nomain =\n-        {view_items: /*bad*/copy m.view_items,\n-         items: vec::map(m.items, |i| nomain(cx, *i))};\n-    return fold::noop_fold_mod(mod_nomain, fld);\n+    let mod_nomain = ast::_mod {\n+        view_items: /*bad*/copy m.view_items,\n+        items: vec::map(m.items, |i| nomain(cx, *i)),\n+    };\n+\n+    fold::noop_fold_mod(mod_nomain, fld)\n }\n \n fn fold_crate(cx: test_ctxt, c: ast::crate_, fld: fold::ast_fold) ->\n@@ -182,7 +184,10 @@ fn should_fail(i: @ast::item) -> bool {\n \n fn add_test_module(cx: test_ctxt, +m: ast::_mod) -> ast::_mod {\n     let testmod = mk_test_module(cx);\n-    return {items: vec::append_one(/*bad*/copy m.items, testmod),.. m};\n+    ast::_mod {\n+        items: vec::append_one(/*bad*/copy m.items, testmod),\n+        .. m\n+    }\n }\n \n /*\n@@ -213,8 +218,9 @@ fn mk_test_module(cx: test_ctxt) -> @ast::item {\n     // The synthesized main function which will call the console test runner\n     // with our list of tests\n     let mainfn = mk_main(cx);\n-    let testmod: ast::_mod = {\n-        view_items: view_items, items: ~[mainfn, testsfn]\n+    let testmod = ast::_mod {\n+        view_items: view_items,\n+        items: ~[mainfn, testsfn],\n     };\n     let item_ = ast::item_mod(testmod);\n     // This attribute tells resolve to let us call unexported functions\n@@ -276,10 +282,11 @@ fn mk_std(cx: test_ctxt) -> @ast::view_item {\n fn mk_tests(cx: test_ctxt) -> @ast::item {\n     let ret_ty = mk_test_desc_vec_ty(cx);\n \n-    let decl: ast::fn_decl =\n-        {inputs: ~[],\n-         output: ret_ty,\n-         cf: ast::return_val};\n+    let decl = ast::fn_decl {\n+        inputs: ~[],\n+        output: ret_ty,\n+        cf: ast::return_val,\n+    };\n \n     // The vector of test_descs for this crate\n     let test_descs = mk_test_desc_vec(cx);\n@@ -486,7 +493,7 @@ fn mk_test_wrapper(cx: test_ctxt,\n     let call_stmt: ast::stmt = nospan(\n         ast::stmt_semi(@call_expr, cx.sess.next_node_id()));\n \n-    let wrapper_decl: ast::fn_decl = {\n+    let wrapper_decl = ast::fn_decl {\n         inputs: ~[],\n         output: @ast::Ty {\n             id: cx.sess.next_node_id(),\n@@ -521,10 +528,11 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n         span: dummy_sp(),\n     };\n \n-    let decl: ast::fn_decl =\n-        {inputs: ~[],\n-         output: @ret_ty,\n-         cf: ast::return_val};\n+    let decl = ast::fn_decl {\n+        inputs: ~[],\n+        output: @ret_ty,\n+        cf: ast::return_val,\n+    };\n \n     let test_main_call_expr = mk_test_main_call(cx);\n "}, {"sha": "3755c84072c260f0a85f495cc0e569a9e5d9b99a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -1842,13 +1842,17 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n                       llfndecl: ValueRef) {\n     let _icx = ccx.insn_ctxt(\"trans_enum_variant\");\n     // Translate variant arguments to function arguments.\n-    let fn_args = vec::map(args, |varg|\n-        {mode: ast::expl(ast::by_copy),\n-         ty: varg.ty,\n-         pat: ast_util::ident_to_pat(ccx.tcx.sess.next_node_id(),\n-                                     ast_util::dummy_sp(),\n-                                     special_idents::arg),\n-         id: varg.id});\n+    let fn_args = do args.map |varg| {\n+        ast::arg {\n+            mode: ast::expl(ast::by_copy),\n+            ty: varg.ty,\n+            pat: ast_util::ident_to_pat(\n+                ccx.tcx.sess.next_node_id(),\n+                ast_util::dummy_sp(),\n+                special_idents::arg),\n+            id: varg.id,\n+        }\n+    };\n     // XXX: Bad copy of `param_substs`.\n     let fcx = new_fn_ctxt_w_id(ccx, ~[], llfndecl, variant.node.id, None,\n                                copy param_substs, None);\n@@ -1902,7 +1906,7 @@ fn trans_tuple_struct(ccx: @crate_ctxt,\n \n     // Translate struct fields to function arguments.\n     let fn_args = do fields.map |field| {\n-        {\n+        ast::arg {\n             mode: ast::expl(ast::by_copy),\n             ty: field.node.ty,\n             pat: ast_util::ident_to_pat(ccx.tcx.sess.next_node_id(),"}, {"sha": "3215b52794a316d3baefb922763b0b6afab658aa", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -96,7 +96,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     match map_node {\n       ast_map::node_item(@ast::item { node: item_fn(_, _, _, ref body),\n                                       _ }, _) |\n-      ast_map::node_method(@{body: ref body, _}, _, _) => {\n+      ast_map::node_method(@ast::method {body: ref body, _}, _, _) => {\n         handle_body(cx, (*body));\n       }\n       ast_map::node_trait_method(*) => {"}, {"sha": "6bb187b61d1182ef53f390bf0cb69db7a245bec4", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 58, "deletions": 22, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -1107,7 +1107,10 @@ impl prim_ty : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n-type region = {id: node_id, node: region_};\n+struct region {\n+    id: node_id,\n+    node: region_,\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -1194,14 +1197,20 @@ impl Ty : to_bytes::IterBytes {\n \n #[auto_encode]\n #[auto_decode]\n-type arg = {mode: mode, ty: @Ty, pat: @pat, id: node_id};\n+struct arg {\n+    mode: mode,\n+    ty: @Ty,\n+    pat: @pat,\n+    id: node_id,\n+}\n \n #[auto_encode]\n #[auto_decode]\n-type fn_decl =\n-    {inputs: ~[arg],\n-     output: @Ty,\n-     cf: ret_style};\n+struct fn_decl {\n+    inputs: ~[arg],\n+    output: @Ty,\n+    cf: ret_style,\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -1321,15 +1330,26 @@ type self_ty = spanned<self_ty_>;\n \n #[auto_encode]\n #[auto_decode]\n-type method = {ident: ident, attrs: ~[attribute],\n-               tps: ~[ty_param], self_ty: self_ty,\n-               purity: purity, decl: fn_decl, body: blk,\n-               id: node_id, span: span, self_id: node_id,\n-               vis: visibility};\n+struct method {\n+    ident: ident,\n+    attrs: ~[attribute],\n+    tps: ~[ty_param],\n+    self_ty: self_ty,\n+    purity: purity,\n+    decl: fn_decl,\n+    body: blk,\n+    id: node_id,\n+    span: span,\n+    self_id: node_id,\n+    vis: visibility,\n+}\n \n #[auto_encode]\n #[auto_decode]\n-type _mod = {view_items: ~[@view_item], items: ~[@item]};\n+struct _mod {\n+    view_items: ~[@view_item],\n+    items: ~[@item],\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -1367,15 +1387,19 @@ impl foreign_abi : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n-type foreign_mod =\n-    {sort: foreign_mod_sort,\n-     abi: ident,\n-     view_items: ~[@view_item],\n-     items: ~[@foreign_item]};\n+struct foreign_mod {\n+    sort: foreign_mod_sort,\n+    abi: ident,\n+    view_items: ~[@view_item],\n+    items: ~[@foreign_item],\n+}\n \n #[auto_encode]\n #[auto_decode]\n-type variant_arg = {ty: @Ty, id: node_id};\n+struct variant_arg {\n+    ty: @Ty,\n+    id: node_id,\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -1387,16 +1411,25 @@ enum variant_kind {\n \n #[auto_encode]\n #[auto_decode]\n-type enum_def_ = { variants: ~[variant], common: Option<@struct_def> };\n+struct enum_def_ {\n+    variants: ~[variant],\n+    common: Option<@struct_def>,\n+}\n \n #[auto_encode]\n #[auto_decode]\n enum enum_def = enum_def_;\n \n #[auto_encode]\n #[auto_decode]\n-type variant_ = {name: ident, attrs: ~[attribute], kind: variant_kind,\n-                 id: node_id, disr_expr: Option<@expr>, vis: visibility};\n+struct variant_ {\n+    name: ident,\n+    attrs: ~[attribute],\n+    kind: variant_kind,\n+    id: node_id,\n+    disr_expr: Option<@expr>,\n+    vis: visibility,\n+}\n \n type variant = spanned<variant_>;\n \n@@ -1492,7 +1525,10 @@ struct attribute_ {\n  */\n #[auto_encode]\n #[auto_decode]\n-type trait_ref = {path: @path, ref_id: node_id};\n+struct trait_ref {\n+    path: @path,\n+    ref_id: node_id,\n+}\n \n #[auto_encode]\n #[auto_decode]"}, {"sha": "73be0598d69fc2abc8f8cf56c118e57a2e98d85c", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -443,8 +443,11 @@ fn operator_prec(op: ast::binop) -> uint {\n fn dtor_dec() -> fn_decl {\n     let nil_t = @ast::Ty { id: 0, node: ty_nil, span: dummy_sp() };\n     // dtor has no args\n-    {inputs: ~[],\n-     output: nil_t, cf: return_val}\n+    ast::fn_decl {\n+        inputs: ~[],\n+        output: nil_t,\n+        cf: return_val,\n+    }\n }\n \n // ______________________________________________________________________"}, {"sha": "9578a2f6317c5c0d3ef50db36286bf14bf17afc0", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -462,7 +462,7 @@ fn mk_impl(\n         }\n     );\n \n-    let opt_trait = Some(@{\n+    let opt_trait = Some(@ast::trait_ref {\n         path: path,\n         ref_id: cx.next_id(),\n     });\n@@ -581,7 +581,7 @@ fn mk_ser_method(\n     let ty_s = @ast::Ty {\n         id: cx.next_id(),\n         node: ast::ty_rptr(\n-            @{\n+            @ast::region {\n                 id: cx.next_id(),\n                 node: ast::re_anon,\n             },\n@@ -593,7 +593,7 @@ fn mk_ser_method(\n         span: span,\n     };\n \n-    let ser_inputs = ~[{\n+    let ser_inputs = ~[ast::arg {\n         mode: ast::infer(cx.next_id()),\n         ty: ty_s,\n         pat: @ast::pat {\n@@ -613,13 +613,13 @@ fn mk_ser_method(\n         span: span,\n     };\n \n-    let ser_decl = {\n+    let ser_decl = ast::fn_decl {\n         inputs: ser_inputs,\n         output: ser_output,\n         cf: ast::return_val,\n     };\n \n-    @{\n+    @ast::method {\n         ident: cx.ident_of(~\"encode\"),\n         attrs: ~[],\n         tps: ~[],\n@@ -644,7 +644,7 @@ fn mk_deser_method(\n     let ty_d = @ast::Ty {\n         id: cx.next_id(),\n         node: ast::ty_rptr(\n-            @{\n+            @ast::region {\n                 id: cx.next_id(),\n                 node: ast::re_anon,\n             },\n@@ -656,7 +656,7 @@ fn mk_deser_method(\n         span: span,\n     };\n \n-    let deser_inputs = ~[{\n+    let deser_inputs = ~[ast::arg {\n         mode: ast::infer(cx.next_id()),\n         ty: ty_d,\n         pat: @ast::pat {\n@@ -670,13 +670,13 @@ fn mk_deser_method(\n         id: cx.next_id(),\n     }];\n \n-    let deser_decl = {\n+    let deser_decl = ast::fn_decl {\n         inputs: deser_inputs,\n         output: ty,\n         cf: ast::return_val,\n     };\n \n-    @{\n+    @ast::method {\n         ident: cx.ident_of(~\"decode\"),\n         attrs: ~[],\n         tps: ~[],\n@@ -1187,8 +1187,8 @@ fn mk_enum_deser_body(\n     let expr_lambda = cx.expr(\n         span,\n         ast::expr_fn_block(\n-            {\n-                inputs: ~[{\n+            ast::fn_decl {\n+                inputs: ~[ast::arg {\n                     mode: ast::infer(cx.next_id()),\n                     ty: @ast::Ty {\n                         id: cx.next_id(),"}, {"sha": "d17db9ad6aa814890630a4e6722435d2db45a64a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -317,15 +317,15 @@ fn mk_arg(cx: ext_ctxt,\n           ty: @ast::Ty)\n        -> ast::arg {\n     let arg_pat = mk_pat_ident(cx, span, ident);\n-    {\n+    ast::arg {\n         mode: ast::infer(cx.next_id()),\n         ty: ty,\n         pat: arg_pat,\n         id: cx.next_id()\n     }\n }\n fn mk_fn_decl(+inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n-    { inputs: move inputs, output: output, cf: ast::return_val }\n+    ast::fn_decl { inputs: inputs, output: output, cf: ast::return_val }\n }\n fn mk_ty_param(cx: ext_ctxt,\n                ident: ast::ident,"}, {"sha": "d7059fc197783706df22a031e4f5379c3806f84e", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -135,7 +135,7 @@ fn create_eq_method(cx: ext_ctxt,\n                                                      span,\n                                                      type_ident,\n                                                      ty_params);\n-    let arg_region = @{ id: cx.next_id(), node: re_anon };\n+    let arg_region = @ast::region { id: cx.next_id(), node: re_anon };\n     let arg_type = ty_rptr(\n         arg_region,\n         ast::mt { ty: arg_path_type, mutbl: m_imm }\n@@ -168,7 +168,7 @@ fn create_eq_method(cx: ext_ctxt,\n \n     // Create the method.\n     let self_ty = spanned { node: sty_region(m_imm), span: span };\n-    return @{\n+    @ast::method {\n         ident: method_ident,\n         attrs: ~[],\n         tps: ~[],\n@@ -180,7 +180,7 @@ fn create_eq_method(cx: ext_ctxt,\n         span: span,\n         self_id: cx.next_id(),\n         vis: public\n-    };\n+    }\n }\n \n fn create_self_type_with_params(cx: ext_ctxt,\n@@ -234,7 +234,7 @@ fn create_derived_impl(cx: ext_ctxt,\n         types: ~[]\n     };\n     let trait_path = @move trait_path;\n-    let trait_ref = {\n+    let trait_ref = ast::trait_ref {\n         path: trait_path,\n         ref_id: cx.next_id()\n     };\n@@ -319,7 +319,7 @@ fn create_iter_bytes_method(cx: ext_ctxt,\n     // Create the method.\n     let self_ty = spanned { node: sty_region(m_imm), span: span };\n     let method_ident = cx.ident_of(~\"iter_bytes\");\n-    return @{\n+    @ast::method {\n         ident: method_ident,\n         attrs: ~[],\n         tps: ~[],"}, {"sha": "eb571b99b4ee44bd845e184adfe6898e62a439b2", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -119,7 +119,7 @@ fn expand_mod_items(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n         }\n     };\n \n-    return {items: new_items, ..module_};\n+    ast::_mod { items: new_items, ..module_ }\n }\n \n "}, {"sha": "c8c05d27d803a3cd4a07bda929c4c8889e705874", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -198,7 +198,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     }\n \n     fn arg(name: ident, ty: @ast::Ty) -> ast::arg {\n-        {\n+        ast::arg {\n             mode: ast::infer(self.next_id()),\n             ty: ty,\n             pat: @ast::pat {\n@@ -231,9 +231,11 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n \n     fn fn_decl(+inputs: ~[ast::arg],\n                output: @ast::Ty) -> ast::fn_decl {\n-        {inputs: inputs,\n-         output: output,\n-         cf: ast::return_val}\n+        ast::fn_decl {\n+            inputs: inputs,\n+            output: output,\n+            cf: ast::return_val,\n+        }\n     }\n \n     fn item(name: ident,\n@@ -295,15 +297,20 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     fn variant(name: ident,\n                span: span,\n                +tys: ~[@ast::Ty]) -> ast::variant {\n-        let args = tys.map(|ty| {ty: *ty, id: self.next_id()});\n-\n-        spanned { node: { name: name,\n-                          attrs: ~[],\n-                          kind: ast::tuple_variant_kind(args),\n-                          id: self.next_id(),\n-                          disr_expr: None,\n-                          vis: ast::public},\n-                  span: span}\n+        let args = do tys.map |ty| {\n+            ast::variant_arg { ty: *ty, id: self.next_id() }\n+        };\n+\n+        spanned {\n+            node: ast::variant_ {\n+                name: name,\n+                attrs: ~[],\n+                kind: ast::tuple_variant_kind(args),\n+                id: self.next_id(),\n+                disr_expr: None,\n+                vis: ast::public},\n+            span: span,\n+        }\n     }\n \n     fn item_mod(name: ident,\n@@ -336,11 +343,14 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n             span: ast_util::dummy_sp()\n         };\n \n-        self.item(name,\n-                  span,\n-                  ast::item_mod({\n-                      view_items: ~[vi],\n-                      items: items}))\n+        self.item(\n+            name,\n+            span,\n+            ast::item_mod(ast::_mod {\n+                view_items: ~[vi],\n+                items: items,\n+            })\n+        )\n     }\n \n     fn ty_path_ast_builder(path: @ast::path) -> @ast::Ty {"}, {"sha": "306df24e79fbcff8c7b575563512c566b47492df", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -240,11 +240,16 @@ impl state: to_type_decls {\n             items_msg.push(v);\n         }\n \n-        ~[cx.item_enum_poly(name,\n-                            self.span,\n-                            ast::enum_def({ variants: items_msg,\n-                                            common: None }),\n-                            self.ty_params)]\n+        ~[\n+            cx.item_enum_poly(\n+                name,\n+                self.span,\n+                ast::enum_def(enum_def_ {\n+                    variants: items_msg,\n+                    common: None }),\n+                self.ty_params\n+            )\n+        ]\n     }\n \n     fn to_endpoint_decls(cx: ext_ctxt, dir: direction) -> ~[@ast::item] {"}, {"sha": "3582c082b5c061e03d7a0efd8112f575e8c6f711", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 63, "deletions": 44, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -125,10 +125,12 @@ fn fold_attribute_(at: attribute, fld: ast_fold) -> attribute {\n }\n //used in noop_fold_foreign_item and noop_fold_fn_decl\n fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n-    return {mode: a.mode,\n-            ty: fld.fold_ty(a.ty),\n-            pat: fld.fold_pat(a.pat),\n-            id: fld.new_id(a.id)};\n+    ast::arg {\n+        mode: a.mode,\n+        ty: fld.fold_ty(a.ty),\n+        pat: fld.fold_pat(a.pat),\n+        id: fld.new_id(a.id),\n+    }\n }\n //used in noop_fold_expr, and possibly elsewhere in the future\n fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n@@ -139,9 +141,11 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n }\n \n fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n-    return {inputs: vec::map(decl.inputs, |x| fold_arg_(*x, fld) ),\n-         output: fld.fold_ty(decl.output),\n-         cf: decl.cf}\n+    ast::fn_decl {\n+        inputs: decl.inputs.map(|x| fold_arg_(*x, fld)),\n+        output: fld.fold_ty(decl.output),\n+        cf: decl.cf,\n+    }\n }\n \n fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n@@ -189,7 +193,7 @@ fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n             match ni.node {\n                 foreign_item_fn(fdec, purity, typms) => {\n                     foreign_item_fn(\n-                        {\n+                        ast::fn_decl {\n                             inputs: fdec.inputs.map(|a| fold_arg(*a)),\n                             output: fld.fold_ty(fdec.output),\n                             cf: fdec.cf,\n@@ -240,11 +244,11 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           item_ty(t, typms) => item_ty(fld.fold_ty(t),\n                                        fold_ty_params(typms, fld)),\n           item_enum(ref enum_definition, typms) => {\n-            item_enum(ast::enum_def({\n-                variants: vec::map((*enum_definition).variants,\n-                                   |x| fld.fold_variant(*x)),\n-                common: option::map(&(*enum_definition).common,\n-                                    |x| fold_struct_def(*x, fld))\n+            item_enum(ast::enum_def(ast::enum_def_ {\n+                variants: enum_definition.variants.map(\n+                    |x| fld.fold_variant(*x)),\n+                common: enum_definition.common.map(\n+                    |x| fold_struct_def(*x, fld)),\n             }), fold_ty_params(typms, fld))\n           }\n           item_struct(struct_def, typms) => {\n@@ -285,15 +289,18 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n                                             .. dtor.node},\n                   span: dtor.span }\n     };\n-    return @ast::struct_def {\n-        fields: vec::map(struct_def.fields, |f| fold_struct_field(*f, fld)),\n+    @ast::struct_def {\n+        fields: struct_def.fields.map(|f| fold_struct_field(*f, fld)),\n         dtor: dtor,\n-        ctor_id: option::map(&struct_def.ctor_id, |cid| fld.new_id(*cid))\n-    };\n+        ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(*cid)),\n+    }\n }\n \n fn fold_trait_ref(&&p: @trait_ref, fld: ast_fold) -> @trait_ref {\n-    @{path: fld.fold_path(p.path), ref_id: fld.new_id(p.ref_id)}\n+    @ast::trait_ref {\n+        path: fld.fold_path(p.path),\n+        ref_id: fld.new_id(p.ref_id),\n+    }\n }\n \n fn fold_struct_field(&&f: @struct_field, fld: ast_fold) -> @struct_field {\n@@ -304,17 +311,19 @@ fn fold_struct_field(&&f: @struct_field, fld: ast_fold) -> @struct_field {\n }\n \n fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n-    return @{ident: fld.fold_ident(m.ident),\n-          attrs: /* FIXME (#2543) */ copy m.attrs,\n-          tps: fold_ty_params(m.tps, fld),\n-          self_ty: m.self_ty,\n-          purity: m.purity,\n-          decl: fold_fn_decl(m.decl, fld),\n-          body: fld.fold_block(m.body),\n-          id: fld.new_id(m.id),\n-          span: fld.new_span(m.span),\n-          self_id: fld.new_id(m.self_id),\n-          vis: m.vis};\n+    @ast::method {\n+        ident: fld.fold_ident(m.ident),\n+        attrs: /* FIXME (#2543) */ copy m.attrs,\n+        tps: fold_ty_params(m.tps, fld),\n+        self_ty: m.self_ty,\n+        purity: m.purity,\n+        decl: fold_fn_decl(m.decl, fld),\n+        body: fld.fold_block(m.body),\n+        id: fld.new_id(m.id),\n+        span: fld.new_span(m.span),\n+        self_id: fld.new_id(m.self_id),\n+        vis: m.vis,\n+    }\n }\n \n \n@@ -577,20 +586,24 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n \n // ...nor do modules\n fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n-    return {view_items: vec::map(m.view_items, |x| fld.fold_view_item(*x)),\n-         items: vec::filter_map(m.items, |x| fld.fold_item(*x))};\n+    ast::_mod {\n+        view_items: vec::map(m.view_items, |x| fld.fold_view_item(*x)),\n+        items: vec::filter_map(m.items, |x| fld.fold_item(*x)),\n+    }\n }\n \n fn noop_fold_foreign_mod(nm: foreign_mod, fld: ast_fold) -> foreign_mod {\n-    return {sort: nm.sort,\n-            abi: nm.abi,\n-            view_items: vec::map(nm.view_items, |x| fld.fold_view_item(*x)),\n-            items: vec::map(nm.items, |x| fld.fold_foreign_item(*x))}\n+    ast::foreign_mod {\n+        sort: nm.sort,\n+        abi: nm.abi,\n+        view_items: vec::map(nm.view_items, |x| fld.fold_view_item(*x)),\n+        items: vec::map(nm.items, |x| fld.fold_foreign_item(*x)),\n+    }\n }\n \n fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     fn fold_variant_arg_(va: variant_arg, fld: ast_fold) -> variant_arg {\n-        return {ty: fld.fold_ty(va.ty), id: fld.new_id(va.id)};\n+        ast::variant_arg { ty: fld.fold_ty(va.ty), id: fld.new_id(va.id) }\n     }\n     let fold_variant_arg = |x| fold_variant_arg_(x, fld);\n \n@@ -621,8 +634,12 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n                                     |x| fld.fold_variant(*x));\n             let common = option::map(&(*enum_definition).common,\n                                      |x| fold_struct_def(*x, fld));\n-            kind = enum_variant_kind(ast::enum_def({ variants: variants,\n-                                                     common: common }));\n+            kind = enum_variant_kind(\n+                ast::enum_def(ast::enum_def_ {\n+                    variants: variants,\n+                    common: common\n+                })\n+            );\n         }\n     }\n \n@@ -633,12 +650,14 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n       Some(e) => Some(fld.fold_expr(e)),\n       None => None\n     };\n-    return {name: /* FIXME (#2543) */ copy v.name,\n-         attrs: attrs,\n-         kind: kind,\n-         id: fld.new_id(v.id),\n-         disr_expr: de,\n-         vis: v.vis};\n+    ast::variant_ {\n+        name: /* FIXME (#2543) */ copy v.name,\n+        attrs: attrs,\n+        kind: kind,\n+        id: fld.new_id(v.id),\n+        disr_expr: de,\n+        vis: v.vis,\n+    }\n }\n \n fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident {"}, {"sha": "33ae2f22dfe22a0c6577a93e14c9702d9e95545a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 99, "deletions": 56, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d77b9351bdcb7a9fd7c6a27950990d33eea232/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d5d77b9351bdcb7a9fd7c6a27950990d33eea232", "patch": "@@ -383,8 +383,7 @@ impl Parser {\n             p.parse_arg_general(false)\n         };\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n-        return {inputs: inputs, output: ret_ty,\n-                cf: ret_style};\n+        ast::fn_decl { inputs: inputs, output: ret_ty, cf: ret_style }\n     }\n \n     fn parse_trait_methods() -> ~[trait_method] {\n@@ -437,17 +436,19 @@ impl Parser {\n                 let (inner_attrs, body) =\n                     p.parse_inner_attrs_and_block(true);\n                 let attrs = vec::append(attrs, inner_attrs);\n-                provided(@{ident: ident,\n-                           attrs: attrs,\n-                           tps: tps,\n-                           self_ty: self_ty,\n-                           purity: pur,\n-                           decl: d,\n-                           body: body,\n-                           id: p.get_id(),\n-                           span: mk_sp(lo, hi),\n-                           self_id: p.get_id(),\n-                           vis: vis})\n+                provided(@ast::method {\n+                    ident: ident,\n+                    attrs: attrs,\n+                    tps: tps,\n+                    self_ty: self_ty,\n+                    purity: pur,\n+                    decl: d,\n+                    body: body,\n+                    id: p.get_id(),\n+                    span: mk_sp(lo, hi),\n+                    self_id: p.get_id(),\n+                    vis: vis,\n+                })\n               }\n \n               _ => { p.fatal(~\"expected `;` or `}` but found `\" +\n@@ -516,7 +517,7 @@ impl Parser {\n             None => re_anon\n         };\n \n-        @{id: self.get_id(), node: r}\n+        @ast::region { id: self.get_id(), node: r }\n     }\n \n     // Parses something like \"&x\"\n@@ -729,7 +730,7 @@ impl Parser {\n \n         let t = self.parse_ty(false);\n \n-        {mode: m, ty: t, pat: pat, id: self.get_id()}\n+        ast::arg { mode: m, ty: t, pat: pat, id: self.get_id() }\n     }\n \n     fn parse_arg() -> arg_or_capture_item {\n@@ -753,7 +754,12 @@ impl Parser {\n                     span: mk_sp(p.span.lo, p.span.hi),\n                 }\n             };\n-            either::Left({mode: m, ty: t, pat: pat, id: p.get_id()})\n+            either::Left(ast::arg {\n+                mode: m,\n+                ty: t,\n+                pat: pat,\n+                id: p.get_id()\n+            })\n         }\n     }\n \n@@ -1580,18 +1586,18 @@ impl Parser {\n                   }\n                   _ => {\n                     // No argument list - `do foo {`\n-                    ({\n-                        {\n+                    (\n+                        ast::fn_decl {\n                             inputs: ~[],\n                             output: @Ty {\n                                 id: self.get_id(),\n                                 node: ty_infer,\n                                 span: self.span\n                             },\n                             cf: return_val\n-                        }\n-                    },\n-                    @~[])\n+                        },\n+                        @~[]\n+                    )\n                   }\n                 }\n             },\n@@ -2549,9 +2555,14 @@ impl Parser {\n         let capture_clause = @either::rights(args_or_capture_items);\n \n         let (ret_style, ret_ty) = self.parse_ret_ty();\n-        return ({inputs: inputs,\n-                 output: ret_ty,\n-                 cf: ret_style}, capture_clause);\n+        (\n+            ast::fn_decl {\n+                inputs: inputs,\n+                output: ret_ty,\n+                cf: ret_style,\n+            },\n+            capture_clause\n+        )\n     }\n \n     fn is_self_ident() -> bool {\n@@ -2651,7 +2662,7 @@ impl Parser {\n         let capture_clause = @either::rights(args_or_capture_items);\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n \n-        let fn_decl = {\n+        let fn_decl = ast::fn_decl {\n             inputs: inputs,\n             output: ret_ty,\n             cf: ret_style\n@@ -2676,10 +2687,15 @@ impl Parser {\n         } else {\n             @Ty { id: self.get_id(), node: ty_infer, span: self.span }\n         };\n-        return ({inputs: either::lefts(inputs_captures),\n-                 output: output,\n-                 cf: return_val},\n-                @either::rights(inputs_captures));\n+\n+        (\n+            ast::fn_decl {\n+                inputs: either::lefts(inputs_captures),\n+                output: output,\n+                cf: return_val,\n+            },\n+            @either::rights(inputs_captures)\n+        )\n     }\n \n     fn parse_fn_header() -> {ident: ident, tps: ~[ty_param]} {\n@@ -2729,10 +2745,19 @@ impl Parser {\n \n         let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n         let attrs = vec::append(attrs, inner_attrs);\n-        @{ident: ident, attrs: attrs,\n-          tps: tps, self_ty: self_ty, purity: pur, decl: decl,\n-          body: body, id: self.get_id(), span: mk_sp(lo, body.span.hi),\n-          self_id: self.get_id(), vis: visa}\n+        @ast::method {\n+            ident: ident,\n+            attrs: attrs,\n+            tps: tps,\n+            self_ty: self_ty,\n+            purity: pur,\n+            decl: decl,\n+            body: body,\n+            id: self.get_id(),\n+            span: mk_sp(lo, body.span.hi),\n+            self_id: self.get_id(),\n+            vis: visa,\n+        }\n     }\n \n     fn parse_item_trait() -> item_info {\n@@ -2832,8 +2857,10 @@ impl Parser {\n     }\n \n     fn parse_trait_ref() -> @trait_ref {\n-        @{path: self.parse_path_with_tps(false),\n-          ref_id: self.get_id()}\n+        @ast::trait_ref {\n+            path: self.parse_path_with_tps(false),\n+            ref_id: self.get_id(),\n+        }\n     }\n \n     fn parse_trait_ref_list(ket: token::Token) -> ~[@trait_ref] {\n@@ -3065,7 +3092,7 @@ impl Parser {\n             self.fatal(~\"expected item\");\n         }\n \n-        return {view_items: view_items, items: items};\n+        ast::_mod { view_items: view_items, items: items }\n     }\n \n     fn parse_item_const() -> item_info {\n@@ -3117,7 +3144,7 @@ impl Parser {\n                     (item_mod(m), item_mod(n)) => (m, n),\n                     _ => self.bug(~\"parsed mod item should be mod\")\n                 };\n-                let merged_mod = {\n+                let merged_mod = ast::_mod {\n                     view_items: main_mod.view_items + new_mod.view_items,\n                     items: main_mod.items + new_mod.items\n                 };\n@@ -3272,12 +3299,12 @@ impl Parser {\n             initial_attrs = ~[];\n             items.push(self.parse_foreign_item(attrs));\n         }\n-        return {\n+        ast::foreign_mod {\n             sort: sort,\n             abi: move abi,\n             view_items: view_items,\n             items: items\n-        };\n+        }\n     }\n \n     fn parse_item_foreign_mod(lo: BytePos,\n@@ -3473,7 +3500,10 @@ impl Parser {\n                         seq_sep_trailing_disallowed(token::COMMA),\n                         |p| p.parse_ty(false));\n                     for arg_tys.each |ty| {\n-                        args.push({ty: *ty, id: self.get_id()});\n+                        args.push(ast::variant_arg {\n+                            ty: *ty,\n+                            id: self.get_id(),\n+                        });\n                     }\n                     kind = tuple_variant_kind(args);\n                 } else if self.eat(token::EQ) {\n@@ -3486,9 +3516,14 @@ impl Parser {\n                 needs_comma = true;\n             }\n \n-            let vr = {name: ident, attrs: variant_attrs,\n-                      kind: kind, id: self.get_id(),\n-                      disr_expr: disr_expr, vis: vis};\n+            let vr = ast::variant_ {\n+                name: ident,\n+                attrs: variant_attrs,\n+                kind: kind,\n+                id: self.get_id(),\n+                disr_expr: disr_expr,\n+                vis: vis,\n+            };\n             variants.push(spanned(vlo, self.last_span.hi, vr));\n \n             if needs_comma && !self.eat(token::COMMA) { break; }\n@@ -3499,7 +3534,7 @@ impl Parser {\n                         enum\");\n         }\n \n-        return enum_def({ variants: variants, common: common_fields });\n+        enum_def(ast::enum_def_ { variants: variants, common: common_fields })\n     }\n \n     fn parse_item_enum() -> item_info {\n@@ -3511,18 +3546,26 @@ impl Parser {\n             self.bump();\n             let ty = self.parse_ty(false);\n             self.expect(token::SEMI);\n-            let variant =\n-                spanned(ty.span.lo, ty.span.hi,\n-                        {name: id,\n-                         attrs: ~[],\n-                         kind: tuple_variant_kind\n-                            (~[{ty: ty, id: self.get_id()}]),\n-                         id: self.get_id(),\n-                         disr_expr: None,\n-                         vis: public});\n-            return (id, item_enum(enum_def({ variants: ~[variant],\n-                                             common: None }),\n-                                  ty_params), None);\n+            let variant = spanned(ty.span.lo, ty.span.hi, ast::variant_ {\n+                name: id,\n+                attrs: ~[],\n+                kind: tuple_variant_kind(\n+                    ~[ast::variant_arg {ty: ty, id: self.get_id()}]\n+                ),\n+                id: self.get_id(),\n+                disr_expr: None,\n+                vis: public,\n+            });\n+\n+            return (\n+                id,\n+                item_enum(\n+                    enum_def(\n+                        ast::enum_def_ { variants: ~[variant], common: None }\n+                    ),\n+                    ty_params),\n+                None\n+            );\n         }\n         self.expect(token::LBRACE);\n "}]}