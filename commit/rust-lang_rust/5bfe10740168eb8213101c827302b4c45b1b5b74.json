{"sha": "5bfe10740168eb8213101c827302b4c45b1b5b74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViZmUxMDc0MDE2OGViODIxMzEwMWM4MjczMDJiNGM0NWIxYjViNzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-15T16:32:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-15T16:32:06Z"}, "message": "Auto merge of #37132 - petrochenkov:intern, r=alexcrichton\n\nGet rid of double indirection in string interner", "tree": {"sha": "87a212efaa05f0461b26e463fdeabb8718b0c8c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87a212efaa05f0461b26e463fdeabb8718b0c8c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bfe10740168eb8213101c827302b4c45b1b5b74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bfe10740168eb8213101c827302b4c45b1b5b74", "html_url": "https://github.com/rust-lang/rust/commit/5bfe10740168eb8213101c827302b4c45b1b5b74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bfe10740168eb8213101c827302b4c45b1b5b74/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e05e7ee3c19a5594b79d67c8390cef78970be7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e05e7ee3c19a5594b79d67c8390cef78970be7c", "html_url": "https://github.com/rust-lang/rust/commit/8e05e7ee3c19a5594b79d67c8390cef78970be7c"}, {"sha": "348c3fb0851c155f06768e54c44990d39b6eb142", "url": "https://api.github.com/repos/rust-lang/rust/commits/348c3fb0851c155f06768e54c44990d39b6eb142", "html_url": "https://github.com/rust-lang/rust/commit/348c3fb0851c155f06768e54c44990d39b6eb142"}], "stats": {"total": 87, "additions": 48, "deletions": 39}, "files": [{"sha": "740d13c476222a44680a45b70717cd3e83cc1b0b", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5bfe10740168eb8213101c827302b4c45b1b5b74/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bfe10740168eb8213101c827302b4c45b1b5b74/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=5bfe10740168eb8213101c827302b4c45b1b5b74", "patch": "@@ -230,13 +230,14 @@ use core::hash::{Hash, Hasher};\n use core::intrinsics::{abort, assume};\n use core::marker;\n use core::marker::Unsize;\n-use core::mem::{self, align_of_val, forget, size_of_val, uninitialized};\n+use core::mem::{self, align_of_val, forget, size_of, size_of_val, uninitialized};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n use core::ptr::{self, Shared};\n use core::convert::From;\n \n use heap::deallocate;\n+use raw_vec::RawVec;\n \n struct RcBox<T: ?Sized> {\n     strong: Cell<usize>,\n@@ -365,6 +366,31 @@ impl<T> Rc<T> {\n     }\n }\n \n+impl Rc<str> {\n+    /// Constructs a new `Rc<str>` from a string slice.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"rustc_private\",\n+               reason = \"for internal use in rustc\",\n+               issue = \"0\")]\n+    pub fn __from_str(value: &str) -> Rc<str> {\n+        unsafe {\n+            // Allocate enough space for `RcBox<str>`.\n+            let aligned_len = 2 + (value.len() + size_of::<usize>() - 1) / size_of::<usize>();\n+            let vec = RawVec::<usize>::with_capacity(aligned_len);\n+            let ptr = vec.ptr();\n+            forget(vec);\n+            // Initialize fields of `RcBox<str>`.\n+            *ptr.offset(0) = 1; // strong: Cell::new(1)\n+            *ptr.offset(1) = 1; // weak: Cell::new(1)\n+            ptr::copy_nonoverlapping(value.as_ptr(), ptr.offset(2) as *mut u8, value.len());\n+            // Combine the allocation address and the string length into a fat pointer to `RcBox`.\n+            let rcbox_ptr: *mut RcBox<str> = mem::transmute([ptr as usize, value.len()]);\n+            assert!(aligned_len * size_of::<usize>() == size_of_val(&*rcbox_ptr));\n+            Rc { ptr: Shared::new(rcbox_ptr) }\n+        }\n+    }\n+}\n+\n impl<T: ?Sized> Rc<T> {\n     /// Creates a new [`Weak`][weak] pointer to this value.\n     ///"}, {"sha": "89da45e549fb791a7779ebfa959cb770f1d1b9d3", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5bfe10740168eb8213101c827302b4c45b1b5b74/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bfe10740168eb8213101c827302b4c45b1b5b74/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=5bfe10740168eb8213101c827302b4c45b1b5b74", "patch": "@@ -128,7 +128,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n     // Get the string representation of a UniqueTypeId. This method will fail if\n     // the id is unknown.\n-    fn get_unique_type_id_as_string(&self, unique_type_id: UniqueTypeId) -> Rc<String> {\n+    fn get_unique_type_id_as_string(&self, unique_type_id: UniqueTypeId) -> Rc<str> {\n         let UniqueTypeId(interner_key) = unique_type_id;\n         self.unique_id_interner.get(interner_key)\n     }\n@@ -299,7 +299,7 @@ impl<'tcx> TypeMap<'tcx> {\n         // Trim to size before storing permanently\n         unique_type_id.shrink_to_fit();\n \n-        let key = self.unique_id_interner.intern(unique_type_id);\n+        let key = self.unique_id_interner.intern(&unique_type_id);\n         self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n \n         return UniqueTypeId(key);\n@@ -367,7 +367,7 @@ impl<'tcx> TypeMap<'tcx> {\n         let enum_variant_type_id = format!(\"{}::{}\",\n                                            &self.get_unique_type_id_as_string(enum_type_id),\n                                            variant_name);\n-        let interner_key = self.unique_id_interner.intern(enum_variant_type_id);\n+        let interner_key = self.unique_id_interner.intern(&enum_variant_type_id);\n         UniqueTypeId(interner_key)\n     }\n }"}, {"sha": "3d4dd9ec064579758801df1808396fb74ce84c7d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5bfe10740168eb8213101c827302b4c45b1b5b74/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bfe10740168eb8213101c827302b4c45b1b5b74/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5bfe10740168eb8213101c827302b4c45b1b5b74", "patch": "@@ -478,27 +478,20 @@ pub fn clear_ident_interner() {\n /// somehow.\n #[derive(Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]\n pub struct InternedString {\n-    string: Rc<String>,\n+    string: Rc<str>,\n }\n \n impl InternedString {\n     #[inline]\n     pub fn new(string: &'static str) -> InternedString {\n         InternedString {\n-            string: Rc::new(string.to_owned()),\n-        }\n-    }\n-\n-    #[inline]\n-    fn new_from_rc_str(string: Rc<String>) -> InternedString {\n-        InternedString {\n-            string: string,\n+            string: Rc::__from_str(string),\n         }\n     }\n \n     #[inline]\n     pub fn new_from_name(name: ast::Name) -> InternedString {\n-        with_ident_interner(|interner| InternedString::new_from_rc_str(interner.get(name)))\n+        with_ident_interner(|interner| InternedString { string: interner.get(name) })\n     }\n }\n "}, {"sha": "f56c6cedcd18678e4971d48d96b8392a0c6280a0", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5bfe10740168eb8213101c827302b4c45b1b5b74/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bfe10740168eb8213101c827302b4c45b1b5b74/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=5bfe10740168eb8213101c827302b4c45b1b5b74", "patch": "@@ -14,23 +14,13 @@\n \n use ast::Name;\n \n-use std::borrow::Borrow;\n use std::collections::HashMap;\n use std::rc::Rc;\n \n-#[derive(PartialEq, Eq, Hash)]\n-struct RcStr(Rc<String>);\n-\n-impl Borrow<str> for RcStr {\n-    fn borrow(&self) -> &str {\n-        &self.0\n-    }\n-}\n-\n #[derive(Default)]\n pub struct Interner {\n-    names: HashMap<RcStr, Name>,\n-    strings: Vec<Rc<String>>,\n+    names: HashMap<Rc<str>, Name>,\n+    strings: Vec<Rc<str>>,\n }\n \n /// When traits can extend traits, we should extend index<Name,T> to get []\n@@ -47,22 +37,22 @@ impl Interner {\n         this\n     }\n \n-    pub fn intern<T: Borrow<str> + Into<String>>(&mut self, string: T) -> Name {\n-        if let Some(&name) = self.names.get(string.borrow()) {\n+    pub fn intern(&mut self, string: &str) -> Name {\n+        if let Some(&name) = self.names.get(string) {\n             return name;\n         }\n \n         let name = Name(self.strings.len() as u32);\n-        let string = Rc::new(string.into());\n+        let string = Rc::__from_str(string);\n         self.strings.push(string.clone());\n-        self.names.insert(RcStr(string), name);\n+        self.names.insert(string, name);\n         name\n     }\n \n     pub fn gensym(&mut self, string: &str) -> Name {\n         let gensym = Name(self.strings.len() as u32);\n         // leave out of `names` to avoid colliding\n-        self.strings.push(Rc::new(string.to_owned()));\n+        self.strings.push(Rc::__from_str(string));\n         gensym\n     }\n \n@@ -75,7 +65,7 @@ impl Interner {\n         gensym\n     }\n \n-    pub fn get(&self, name: Name) -> Rc<String> {\n+    pub fn get(&self, name: Name) -> Rc<str> {\n         self.strings[name.0 as usize].clone()\n     }\n \n@@ -109,13 +99,13 @@ mod tests {\n         assert_eq!(i.gensym(\"dog\"), Name(4));\n         // gensym tests again with gensym_copy:\n         assert_eq!(i.gensym_copy(Name(2)), Name(5));\n-        assert_eq!(*i.get(Name(5)), \"zebra\");\n+        assert_eq!(&*i.get(Name(5)), \"zebra\");\n         assert_eq!(i.gensym_copy(Name(2)), Name(6));\n-        assert_eq!(*i.get(Name(6)), \"zebra\");\n-        assert_eq!(*i.get(Name(0)), \"dog\");\n-        assert_eq!(*i.get(Name(1)), \"cat\");\n-        assert_eq!(*i.get(Name(2)), \"zebra\");\n-        assert_eq!(*i.get(Name(3)), \"zebra\");\n-        assert_eq!(*i.get(Name(4)), \"dog\");\n+        assert_eq!(&*i.get(Name(6)), \"zebra\");\n+        assert_eq!(&*i.get(Name(0)), \"dog\");\n+        assert_eq!(&*i.get(Name(1)), \"cat\");\n+        assert_eq!(&*i.get(Name(2)), \"zebra\");\n+        assert_eq!(&*i.get(Name(3)), \"zebra\");\n+        assert_eq!(&*i.get(Name(4)), \"dog\");\n     }\n }"}]}