{"sha": "251dd30d77c98cbebd1c68840fce029affe9b6a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1MWRkMzBkNzdjOThjYmViZDFjNjg4NDBmY2UwMjlhZmZlOWI2YTg=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-08-04T17:48:45Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-08-14T23:49:54Z"}, "message": "Improve `manual_map`\nIn some cases check if a borrow made in the scrutinee expression would prevent creating the closure used by `map`", "tree": {"sha": "e1efdac07311d834631939ce5643ed725d88d6ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1efdac07311d834631939ce5643ed725d88d6ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/251dd30d77c98cbebd1c68840fce029affe9b6a8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmEYVqYACgkQ2lnoZDo37QaD5gD/QQ850R+EKq7N+i8B6+CFhaBh\n1R5Hu6W/X+3WFvEGRLcBAM4Oc5d2fy8qtKmEJDokE0iUm26PEHtQOKMG46FYUHkI\n=IRjy\n-----END PGP SIGNATURE-----", "payload": "tree e1efdac07311d834631939ce5643ed725d88d6ea\nparent 4838c78ba4ef784379ae6ec5617479de2a32d3f6\nauthor Jason Newcomb <jsnewcomb@pm.me> 1628099325 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1628984994 -0400\n\nImprove `manual_map`\nIn some cases check if a borrow made in the scrutinee expression would prevent creating the closure used by `map`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/251dd30d77c98cbebd1c68840fce029affe9b6a8", "html_url": "https://github.com/rust-lang/rust/commit/251dd30d77c98cbebd1c68840fce029affe9b6a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/251dd30d77c98cbebd1c68840fce029affe9b6a8/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4838c78ba4ef784379ae6ec5617479de2a32d3f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4838c78ba4ef784379ae6ec5617479de2a32d3f6", "html_url": "https://github.com/rust-lang/rust/commit/4838c78ba4ef784379ae6ec5617479de2a32d3f6"}], "stats": {"total": 165, "additions": 145, "deletions": 20}, "files": [{"sha": "3ea88f52a1ccfded52f7ebf2832855e579c78d4e", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/251dd30d77c98cbebd1c68840fce029affe9b6a8/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251dd30d77c98cbebd1c68840fce029affe9b6a8/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=251dd30d77c98cbebd1c68840fce029affe9b6a8", "patch": "@@ -4,12 +4,14 @@ use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n use clippy_utils::{\n     can_move_expr_to_closure, in_constant, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id,\n-    peel_hir_expr_refs,\n+    peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, MatchSource, Mutability, Pat, PatKind};\n+use rustc_hir::{\n+    def::Res, Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, MatchSource, Mutability, Pat, PatKind, Path, QPath,\n+};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -111,10 +113,6 @@ impl LateLintPass<'_> for ManualMap {\n                 return;\n             }\n \n-            if !can_move_expr_to_closure(cx, some_expr) {\n-                return;\n-            }\n-\n             // Determine which binding mode to use.\n             let explicit_ref = some_pat.contains_explicit_ref_binding();\n             let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n@@ -125,6 +123,32 @@ impl LateLintPass<'_> for ManualMap {\n                 None => \"\",\n             };\n \n+            match can_move_expr_to_closure(cx, some_expr) {\n+                Some(captures) => {\n+                    // Check if captures the closure will need conflict with borrows made in the scrutinee.\n+                    // TODO: check all the references made in the scrutinee expression. This will require interacting\n+                    // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n+                    if let Some(binding_ref_mutability) = binding_ref {\n+                        let e = peel_hir_expr_while(scrutinee, |e| match e.kind {\n+                            ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n+                            _ => None,\n+                        });\n+                        if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n+                            match captures.get(l) {\n+                                Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return,\n+                                Some(CaptureKind::Ref(Mutability::Not))\n+                                    if binding_ref_mutability == Mutability::Mut =>\n+                                {\n+                                    return;\n+                                }\n+                                Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n+                            }\n+                        }\n+                    }\n+                },\n+                None => return,\n+            };\n+\n             let mut app = Applicability::MachineApplicable;\n \n             // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or"}, {"sha": "2655ba6a8e9ddd37546b8110d1a8d1884a60e902", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 103, "deletions": 14, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/251dd30d77c98cbebd1c68840fce029affe9b6a8/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251dd30d77c98cbebd1c68840fce029affe9b6a8/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=251dd30d77c98cbebd1c68840fce029affe9b6a8", "patch": "@@ -67,19 +67,20 @@ use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::hir_id::HirIdSet;\n+use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n use rustc_hir::intravisit::{self, walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{\n     def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl,\n-    ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Node, Param, Pat, PatKind, Path,\n-    PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n+    ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Mutability, Node, Param, Pat,\n+    PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty as rustc_ty;\n-use rustc_middle::ty::{layout::IntegerExt, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n+use rustc_middle::ty::{layout::IntegerExt, DefIdTree, Ty, TyCtxt, TypeAndMut, TypeFoldable};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n@@ -670,8 +671,82 @@ pub fn can_move_expr_to_closure_no_visit(\n     }\n }\n \n-/// Checks if the expression can be moved into a closure as is.\n-pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+/// How a local is captured by a closure\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum CaptureKind {\n+    Value,\n+    Ref(Mutability),\n+}\n+impl std::ops::BitOr for CaptureKind {\n+    type Output = Self;\n+    fn bitor(self, rhs: Self) -> Self::Output {\n+        match (self, rhs) {\n+            (CaptureKind::Value, _) | (_, CaptureKind::Value) => CaptureKind::Value,\n+            (CaptureKind::Ref(Mutability::Mut), CaptureKind::Ref(_))\n+            | (CaptureKind::Ref(_), CaptureKind::Ref(Mutability::Mut)) => CaptureKind::Ref(Mutability::Mut),\n+            (CaptureKind::Ref(Mutability::Not), CaptureKind::Ref(Mutability::Not)) => CaptureKind::Ref(Mutability::Not),\n+        }\n+    }\n+}\n+impl std::ops::BitOrAssign for CaptureKind {\n+    fn bitor_assign(&mut self, rhs: Self) {\n+        *self = *self | rhs;\n+    }\n+}\n+\n+/// Given an expression referencing a local, determines how it would be captured in a closure.\n+/// Note as this will walk up to parent expressions until the capture can be determined it should\n+/// only be used while making a closure somewhere a value is consumed. e.g. a block, match arm, or\n+/// function argument (other than a receiver).\n+pub fn capture_local_usage(cx: &LateContext<'tcx>, e: &Expr<'_>) -> CaptureKind {\n+    debug_assert!(matches!(\n+        e.kind,\n+        ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(_), .. }))\n+    ));\n+\n+    let map = cx.tcx.hir();\n+    let mut child_id = e.hir_id;\n+    let mut capture = CaptureKind::Value;\n+\n+    for (parent_id, parent) in map.parent_iter(e.hir_id) {\n+        if let [Adjustment {\n+            kind: Adjust::Deref(_) | Adjust::Borrow(AutoBorrow::Ref(..)),\n+            target,\n+        }, ref adjust @ ..] = *cx\n+            .typeck_results()\n+            .adjustments()\n+            .get(child_id)\n+            .map_or(&[][..], |x| &**x)\n+        {\n+            if let rustc_ty::RawPtr(TypeAndMut { mutbl: mutability, .. }) | rustc_ty::Ref(_, _, mutability) =\n+                *adjust.last().map_or(target, |a| a.target).kind()\n+            {\n+                return CaptureKind::Ref(mutability);\n+            }\n+        }\n+\n+        if let Node::Expr(e) = parent {\n+            match e.kind {\n+                ExprKind::AddrOf(_, mutability, _) => return CaptureKind::Ref(mutability),\n+                ExprKind::Index(..) | ExprKind::Unary(UnOp::Deref, _) => capture = CaptureKind::Ref(Mutability::Not),\n+                ExprKind::Assign(lhs, ..) | ExprKind::Assign(_, lhs, _) if lhs.hir_id == child_id => {\n+                    return CaptureKind::Ref(Mutability::Mut);\n+                },\n+                _ => break,\n+            }\n+        } else {\n+            break;\n+        }\n+\n+        child_id = parent_id;\n+    }\n+\n+    capture\n+}\n+\n+/// Checks if the expression can be moved into a closure as is. This will return a list of captures\n+/// if so, otherwise, `None`.\n+pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<HirIdMap<CaptureKind>> {\n     struct V<'cx, 'tcx> {\n         cx: &'cx LateContext<'tcx>,\n         // Stack of potential break targets contained in the expression.\n@@ -680,6 +755,9 @@ pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) ->\n         locals: HirIdSet,\n         /// Whether this expression can be turned into a closure.\n         allow_closure: bool,\n+        /// Locals which need to be captured, and whether they need to be by value, reference, or\n+        /// mutable reference.\n+        captures: HirIdMap<CaptureKind>,\n     }\n     impl Visitor<'tcx> for V<'_, 'tcx> {\n         type Map = ErasedMap<'tcx>;\n@@ -691,13 +769,23 @@ pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) ->\n             if !self.allow_closure {\n                 return;\n             }\n-            if let ExprKind::Loop(b, ..) = e.kind {\n-                self.loops.push(e.hir_id);\n-                self.visit_block(b);\n-                self.loops.pop();\n-            } else {\n-                self.allow_closure &= can_move_expr_to_closure_no_visit(self.cx, e, &self.loops, &self.locals);\n-                walk_expr(self, e);\n+\n+            match e.kind {\n+                ExprKind::Path(QPath::Resolved(None, &Path { res: Res::Local(l), .. })) => {\n+                    if !self.locals.contains(&l) {\n+                        let cap = capture_local_usage(self.cx, e);\n+                        self.captures.entry(l).and_modify(|e| *e |= cap).or_insert(cap);\n+                    }\n+                },\n+                ExprKind::Loop(b, ..) => {\n+                    self.loops.push(e.hir_id);\n+                    self.visit_block(b);\n+                    self.loops.pop();\n+                },\n+                _ => {\n+                    self.allow_closure &= can_move_expr_to_closure_no_visit(self.cx, e, &self.loops, &self.locals);\n+                    walk_expr(self, e);\n+                },\n             }\n         }\n \n@@ -713,9 +801,10 @@ pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) ->\n         allow_closure: true,\n         loops: Vec::new(),\n         locals: HirIdSet::default(),\n+        captures: HirIdMap::default(),\n     };\n     v.visit_expr(expr);\n-    v.allow_closure\n+    v.allow_closure.then(|| v.captures)\n }\n \n /// Returns the method names and argument list of nested method call expressions that make up"}, {"sha": "637f0327954373dc7c0c0d2fa3fd385f4b2e558b", "filename": "tests/ui/manual_map_option_2.fixed", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/251dd30d77c98cbebd1c68840fce029affe9b6a8/tests%2Fui%2Fmanual_map_option_2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/251dd30d77c98cbebd1c68840fce029affe9b6a8/tests%2Fui%2Fmanual_map_option_2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.fixed?ref=251dd30d77c98cbebd1c68840fce029affe9b6a8", "patch": "@@ -7,4 +7,10 @@ fn main() {\n             let y = (String::new(), String::new());\n             (x, y.0)\n         });\n+\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some((x.clone(), s)),\n+        None => None,\n+    };\n }"}, {"sha": "98e00604a1b3d11dd91f262d477e13275f2f2a36", "filename": "tests/ui/manual_map_option_2.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/251dd30d77c98cbebd1c68840fce029affe9b6a8/tests%2Fui%2Fmanual_map_option_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251dd30d77c98cbebd1c68840fce029affe9b6a8/tests%2Fui%2Fmanual_map_option_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.rs?ref=251dd30d77c98cbebd1c68840fce029affe9b6a8", "patch": "@@ -10,4 +10,10 @@ fn main() {\n         }),\n         None => None,\n     };\n+\n+    let s = Some(String::new());\n+    let _ = match &s {\n+        Some(x) => Some((x.clone(), s)),\n+        None => None,\n+    };\n }"}]}