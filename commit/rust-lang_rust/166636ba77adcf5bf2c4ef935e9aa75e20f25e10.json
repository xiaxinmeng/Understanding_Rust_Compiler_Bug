{"sha": "166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NjYzNmJhNzdhZGNmNWJmMmM0ZWY5MzVlOWFhNzVlMjBmMjVlMTA=", "commit": {"author": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-18T01:27:53Z"}, "committer": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-18T01:27:53Z"}, "message": "Merge branch 'master' of https://github.com/rust-analyzer/rust-analyzer into feature/themes", "tree": {"sha": "168be1ca55c73b016e20586c08417c608450c92c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/168be1ca55c73b016e20586c08417c608450c92c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "html_url": "https://github.com/rust-lang/rust/commit/166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/comments", "author": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb26df950699586b314731fb70786e0db8eaa049", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb26df950699586b314731fb70786e0db8eaa049", "html_url": "https://github.com/rust-lang/rust/commit/cb26df950699586b314731fb70786e0db8eaa049"}, {"sha": "28c2d74b2150102a8756a5357a5a965d7610bd15", "url": "https://api.github.com/repos/rust-lang/rust/commits/28c2d74b2150102a8756a5357a5a965d7610bd15", "html_url": "https://github.com/rust-lang/rust/commit/28c2d74b2150102a8756a5357a5a965d7610bd15"}], "stats": {"total": 2403, "additions": 1500, "deletions": 903}, "files": [{"sha": "9a04b9462a037fe73c376fb8112bf7d9b59f052e", "filename": ".cargo/config", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/.cargo%2Fconfig", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/.cargo%2Fconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.cargo%2Fconfig?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -1,4 +1,4 @@\n [alias]\n xtask = \"run --package xtask --bin xtask --\"\n-\n install-ra = \"run --package xtask --bin xtask -- install\" # for backwards compat\n+tq = \"test -- -q\""}, {"sha": "fe08edd29b2e1b3fc9e4db87b8f2545d68bca08c", "filename": "Cargo.lock", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -123,7 +123,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n [[package]]\n name = \"chalk-derive\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -133,52 +133,53 @@ dependencies = [\n [[package]]\n name = \"chalk-engine\"\n version = \"0.9.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n dependencies = [\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stacker 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n  \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-macros\"\n version = \"0.1.1\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n dependencies = [\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-rust-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n dependencies = [\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n  \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"petgraph 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -946,7 +947,6 @@ dependencies = [\n  \"ra_hir 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n- \"rustc_lexer 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n ]\n \n@@ -1016,9 +1016,9 @@ name = \"ra_hir\"\n version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n  \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1180,7 +1180,7 @@ dependencies = [\n  \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_parser 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n- \"rowan 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rowan 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_lexer 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smol_str 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1445,7 +1445,7 @@ dependencies = [\n \n [[package]]\n name = \"rowan\"\n-version = \"0.6.2\"\n+version = \"0.6.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1873,12 +1873,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum cargo_metadata 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d2d1617e838936c0d2323a65cc151e03ae19a7678dd24f72bccf27119b90a5d\"\n \"checksum cc 1.0.47 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aa87058dce70a3ff5621797f1506cb837edd02ac4c0ae642b4542dce802908b8\"\n \"checksum cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-\"checksum chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n-\"checksum chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n-\"checksum chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n-\"checksum chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n-\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n-\"checksum chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n+\"checksum chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n+\"checksum chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n+\"checksum chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n+\"checksum chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n+\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n+\"checksum chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n \"checksum chrono 0.4.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8493056968583b0193c1bb04d6f7684586f3726992d6c573261941a895dbd68\"\n \"checksum clicolors-control 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"90082ee5dcdd64dc4e9e0d37fbf3ee325419e39c0092191e0393df65518f741e\"\n \"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f\"\n@@ -1993,7 +1993,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum relative-path 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bedde000f40f2921ce439ea165c9c53fd629bfa115140c72e22aceacb4a21954\"\n \"checksum remove_dir_all 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4a83fa3702a688b9359eccba92d153ac33fd2e8462f9e0e3fdf155239ea7792e\"\n \"checksum ron 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2ece421e0c4129b90e4a35b6f625e472e96c552136f5093a2f4fa2bbb75a62d5\"\n-\"checksum rowan 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dc2b79612dedc9004083a61448eb669d336d56690aab29fbd7249e8c8ab41d8c\"\n+\"checksum rowan 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fc3a6fb2a35518af7cab43ec4e21ca82eb086a8b3bb1739e426dc3923d459607\"\n \"checksum rustc-demangle 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c691c0e608126e00913e33f0ccf3727d5fc84573623b8d65b2df340b5201783\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc_lexer 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c86aae0c77166108c01305ee1a36a1e77289d7dc6ca0a3cd91ff4992de2d16a5\""}, {"sha": "92e3228f05224a9d9510eb109e16e1a9b22f7b19", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -8,6 +8,6 @@ debug = 0\n \n [profile.release]\n incremental = true\n-debug = 1 # only line info\n+debug = 0 # set this to 1 or 2 to get more useful backtraces in debugger\n \n [patch.'crates-io']"}, {"sha": "d287dbb7352d64880a604e80979f5f060082a49d", "filename": "crates/ra_arena/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_arena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_arena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -3,3 +3,6 @@ edition = \"2018\"\n name = \"ra_arena\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n+\n+[lib]\n+doctest = false"}, {"sha": "434e6656cccfbc19c0d98e01e3b43574ccf2fadd", "filename": "crates/ra_assists/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -4,11 +4,13 @@ name = \"ra_assists\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n format-buf = \"1.0.0\"\n join_to_string = \"0.1.3\"\n itertools = \"0.8.0\"\n-rustc_lexer = \"0.1.0\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }"}, {"sha": "0ea84d5488d017676e61c5bf0760c66c73caafeb", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -1,6 +1,5 @@\n //! This module defines `AssistCtx` -- the API surface that is exposed to assists.\n-\n-use hir::db::HirDatabase;\n+use hir::{db::HirDatabase, SourceAnalyzer};\n use ra_db::FileRange;\n use ra_fmt::{leading_indent, reindent};\n use ra_syntax::{\n@@ -113,6 +112,13 @@ impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n     pub(crate) fn covering_element(&self) -> SyntaxElement {\n         find_covering_element(self.source_file.syntax(), self.frange.range)\n     }\n+    pub(crate) fn source_analyzer(\n+        &self,\n+        node: &SyntaxNode,\n+        offset: Option<TextUnit>,\n+    ) -> SourceAnalyzer {\n+        SourceAnalyzer::new(self.db, hir::Source::new(self.frange.file_id.into(), node), offset)\n+    }\n \n     pub(crate) fn covering_node_for_range(&self, range: TextRange) -> SyntaxElement {\n         find_covering_element(self.source_file.syntax(), range)"}, {"sha": "562a096853cbf4da87fbfcbeed285f13158b2599", "filename": "crates/ra_assists/src/assists/add_explicit_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_explicit_type.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -40,7 +40,7 @@ pub(crate) fn add_explicit_type(ctx: AssistCtx<impl HirDatabase>) -> Option<Assi\n     }\n     // Infer type\n     let db = ctx.db;\n-    let analyzer = hir::SourceAnalyzer::new(db, ctx.frange.file_id, stmt.syntax(), None);\n+    let analyzer = ctx.source_analyzer(stmt.syntax(), None);\n     let ty = analyzer.type_of(db, &expr)?;\n     // Assist not applicable if the type is unknown\n     if is_unknown(&ty) {"}, {"sha": "91af161ee0891783bf6c13812d395d78f5b8d6f1", "filename": "crates/ra_assists/src/assists/add_missing_impl_members.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -100,8 +100,7 @@ fn add_missing_impl_members_inner(\n     let impl_item_list = impl_node.item_list()?;\n \n     let trait_def = {\n-        let file_id = ctx.frange.file_id;\n-        let analyzer = hir::SourceAnalyzer::new(ctx.db, file_id, impl_node.syntax(), None);\n+        let analyzer = ctx.source_analyzer(impl_node.syntax(), None);\n \n         resolve_target_trait_def(ctx.db, &analyzer, &impl_node)?\n     };"}, {"sha": "2038afdc6f78beda9046858949ebd043871e4c0d", "filename": "crates/ra_assists/src/assists/add_new.rs", "status": "modified", "additions": 64, "deletions": 5, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -158,9 +158,12 @@ fn find_struct_impl(\n         let same_ty = blk.target_ty(db) == struct_ty;\n         let not_trait_impl = blk.target_trait(db).is_none();\n \n-        found_new_fn = has_new_fn(impl_blk);\n+        if !(same_ty && not_trait_impl) {\n+            return false;\n+        }\n \n-        same_ty && not_trait_impl\n+        found_new_fn = has_new_fn(impl_blk);\n+        true\n     });\n \n     if found_new_fn {\n@@ -186,9 +189,10 @@ fn has_new_fn(imp: &ast::ImplBlock) -> bool {\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n     use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n \n+    use super::*;\n+\n     #[test]\n     #[rustfmt::skip]\n     fn test_add_new() {\n@@ -345,7 +349,7 @@ struct Foo {<|>}\n impl Foo {\n     fn new() -> Self {\n         Self\n-    }    \n+    }\n }\",\n         );\n \n@@ -357,7 +361,7 @@ struct Foo {<|>}\n impl Foo {\n     fn New() -> Self {\n         Self\n-    }    \n+    }\n }\",\n         );\n     }\n@@ -376,4 +380,59 @@ struct EvenMoreIrrelevant;\n struct Foo<'a, T: Foo<'a>> {}\",\n         );\n     }\n+\n+    #[test]\n+    fn test_unrelated_new() {\n+        check_assist(\n+            add_new,\n+            r##\"\n+pub struct AstId<N: AstNode> {\n+    file_id: HirFileId,\n+    file_ast_id: FileAstId<N>,\n+}\n+\n+impl<N: AstNode> AstId<N> {\n+    pub fn new(file_id: HirFileId, file_ast_id: FileAstId<N>) -> AstId<N> {\n+        AstId { file_id, file_ast_id }\n+    }\n+}\n+\n+pub struct Source<T> {\n+    pub file_id: HirFileId,<|>\n+    pub ast: T,\n+}\n+\n+impl<T> Source<T> {\n+    pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n+        Source { file_id: self.file_id, ast: f(self.ast) }\n+    }\n+}\n+\"##,\n+            r##\"\n+pub struct AstId<N: AstNode> {\n+    file_id: HirFileId,\n+    file_ast_id: FileAstId<N>,\n+}\n+\n+impl<N: AstNode> AstId<N> {\n+    pub fn new(file_id: HirFileId, file_ast_id: FileAstId<N>) -> AstId<N> {\n+        AstId { file_id, file_ast_id }\n+    }\n+}\n+\n+pub struct Source<T> {\n+    pub file_id: HirFileId,\n+    pub ast: T,\n+}\n+\n+impl<T> Source<T> {\n+    pub fn new(file_id: HirFileId, ast: T) -> Self { Self { file_id, ast } }<|>\n+\n+    pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n+        Source { file_id: self.file_id, ast: f(self.ast) }\n+    }\n+}\n+\"##,\n+        );\n+    }\n }"}, {"sha": "b851c20823be179fa7ac2b91f38eedf3cce8233b", "filename": "crates/ra_assists/src/assists/fill_match_arms.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -47,8 +47,7 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist\n \n     let expr = match_expr.expr()?;\n     let enum_def = {\n-        let file_id = ctx.frange.file_id;\n-        let analyzer = hir::SourceAnalyzer::new(ctx.db, file_id, expr.syntax(), None);\n+        let analyzer = ctx.source_analyzer(expr.syntax(), None);\n         resolve_enum_def(ctx.db, &analyzer, &expr)?\n     };\n     let variant_list = enum_def.variant_list()?;"}, {"sha": "18a34502ccdd404da9204bdfe7000a1226f0cd6d", "filename": "crates/ra_assists/src/assists/inline_local_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_assists%2Fsrc%2Fassists%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_assists%2Fsrc%2Fassists%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Finline_local_variable.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -45,7 +45,7 @@ pub(crate) fn inline_local_varialbe(ctx: AssistCtx<impl HirDatabase>) -> Option<\n     } else {\n         let_stmt.syntax().text_range()\n     };\n-    let analyzer = hir::SourceAnalyzer::new(ctx.db, ctx.frange.file_id, bind_pat.syntax(), None);\n+    let analyzer = ctx.source_analyzer(bind_pat.syntax(), None);\n     let refs = analyzer.find_all_refs(&bind_pat);\n \n     let mut wrap_in_parens = vec![true; refs.len()];"}, {"sha": "93912a4706686a81cb4cce55358ce3cc03d07105", "filename": "crates/ra_assists/src/assists/raw_string.rs", "status": "modified", "additions": 13, "deletions": 46, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_assists%2Fsrc%2Fassists%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_assists%2Fsrc%2Fassists%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fraw_string.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -1,9 +1,9 @@\n use hir::db::HirDatabase;\n use ra_syntax::{\n+    ast, AstToken,\n     SyntaxKind::{RAW_STRING, STRING},\n-    TextRange, TextUnit,\n+    TextUnit,\n };\n-use rustc_lexer;\n \n use crate::{Assist, AssistCtx, AssistId};\n \n@@ -23,32 +23,16 @@ use crate::{Assist, AssistCtx, AssistId};\n // }\n // ```\n pub(crate) fn make_raw_string(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let token = ctx.find_token_at_offset(STRING)?;\n-    let text = token.text().as_str();\n-    let usual_string_range = find_usual_string_range(text)?;\n-    let start_of_inside = usual_string_range.start().to_usize() + 1;\n-    let end_of_inside = usual_string_range.end().to_usize();\n-    let inside_str = &text[start_of_inside..end_of_inside];\n-    let mut unescaped = String::with_capacity(inside_str.len());\n-    let mut error = Ok(());\n-    rustc_lexer::unescape::unescape_str(\n-        inside_str,\n-        &mut |_, unescaped_char| match unescaped_char {\n-            Ok(c) => unescaped.push(c),\n-            Err(_) => error = Err(()),\n-        },\n-    );\n-    if error.is_err() {\n-        return None;\n-    }\n+    let token = ctx.find_token_at_offset(STRING).and_then(ast::String::cast)?;\n+    let value = token.value()?;\n     ctx.add_assist(AssistId(\"make_raw_string\"), \"make raw string\", |edit| {\n-        edit.target(token.text_range());\n-        let max_hash_streak = count_hashes(&unescaped);\n+        edit.target(token.syntax().text_range());\n+        let max_hash_streak = count_hashes(&value);\n         let mut hashes = String::with_capacity(max_hash_streak + 1);\n         for _ in 0..hashes.capacity() {\n             hashes.push('#');\n         }\n-        edit.replace(token.text_range(), format!(\"r{}\\\"{}\\\"{}\", hashes, unescaped, hashes));\n+        edit.replace(token.syntax().text_range(), format!(\"r{}\\\"{}\\\"{}\", hashes, value, hashes));\n     })\n }\n \n@@ -68,17 +52,13 @@ pub(crate) fn make_raw_string(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist\n // }\n // ```\n pub(crate) fn make_usual_string(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let token = ctx.find_token_at_offset(RAW_STRING)?;\n-    let text = token.text().as_str();\n-    let usual_string_range = find_usual_string_range(text)?;\n+    let token = ctx.find_token_at_offset(RAW_STRING).and_then(ast::RawString::cast)?;\n+    let value = token.value()?;\n     ctx.add_assist(AssistId(\"make_usual_string\"), \"make usual string\", |edit| {\n-        edit.target(token.text_range());\n+        edit.target(token.syntax().text_range());\n         // parse inside string to escape `\"`\n-        let start_of_inside = usual_string_range.start().to_usize() + 1;\n-        let end_of_inside = usual_string_range.end().to_usize();\n-        let inside_str = &text[start_of_inside..end_of_inside];\n-        let escaped = inside_str.escape_default().to_string();\n-        edit.replace(token.text_range(), format!(\"\\\"{}\\\"\", escaped));\n+        let escaped = value.escape_default().to_string();\n+        edit.replace(token.syntax().text_range(), format!(\"\\\"{}\\\"\", escaped));\n     })\n }\n \n@@ -132,6 +112,7 @@ pub(crate) fn remove_hash(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n         edit.target(token.text_range());\n         let result = &text[2..text.len() - 1];\n         let result = if result.starts_with('\\\"') {\n+            // FIXME: this logic is wrong, not only the last has has to handled specially\n             // no more hash, escape\n             let internal_str = &result[1..result.len() - 1];\n             format!(\"\\\"{}\\\"\", internal_str.escape_default().to_string())\n@@ -154,20 +135,6 @@ fn count_hashes(s: &str) -> usize {\n     max_hash_streak\n }\n \n-fn find_usual_string_range(s: &str) -> Option<TextRange> {\n-    let left_quote = s.find('\"')?;\n-    let right_quote = s.rfind('\"')?;\n-    if left_quote == right_quote {\n-        // `s` only contains one quote\n-        None\n-    } else {\n-        Some(TextRange::from_to(\n-            TextUnit::from(left_quote as u32),\n-            TextUnit::from(right_quote as u32),\n-        ))\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n     use super::*;"}, {"sha": "35626d77d2d00b72abe78ddcb9fc3f0ff62b3879", "filename": "crates/ra_batch/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_batch%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_batch%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_batch%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -4,6 +4,9 @@ name = \"ra_batch\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n log = \"0.4.5\"\n rustc-hash = \"1.0\""}, {"sha": "dd5ff88b0de5e7ae946bfe64151269a482a35d1b", "filename": "crates/ra_cfg/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_cfg%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_cfg%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -4,6 +4,9 @@ name = \"ra_cfg\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n rustc-hash = \"1.0.1\"\n "}, {"sha": "3429a3c49fdda5b7cfc471c740f6c65b892fdc78", "filename": "crates/ra_cli/src/analysis_stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fanalysis_stats.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -169,12 +169,12 @@ pub fn run(\n     println!(\n         \"Expressions of unknown type: {} ({}%)\",\n         num_exprs_unknown,\n-        (num_exprs_unknown * 100 / num_exprs)\n+        if num_exprs > 0 { (num_exprs_unknown * 100 / num_exprs) } else { 100 }\n     );\n     println!(\n         \"Expressions of partially unknown type: {} ({}%)\",\n         num_exprs_partially_unknown,\n-        (num_exprs_partially_unknown * 100 / num_exprs)\n+        if num_exprs > 0 { (num_exprs_partially_unknown * 100 / num_exprs) } else { 100 }\n     );\n     println!(\"Type mismatches: {}\", num_type_mismatches);\n     println!(\"Inference: {:?}, {}\", inference_time.elapsed(), ra_prof::memory_usage());"}, {"sha": "4ec09b6d91b2f09bb7e25e34ef637610202ca715", "filename": "crates/ra_db/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -4,6 +4,9 @@ name = \"ra_db\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n salsa = \"0.13.0\"\n relative-path = \"1.0.0\""}, {"sha": "9969d474637ad15b151c4251908d9222e86cde5d", "filename": "crates/ra_fmt/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_fmt%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_fmt%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_fmt%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -5,6 +5,9 @@ version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n publish = false\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n itertools = \"0.8.0\"\n "}, {"sha": "42ddfecc9a4c257e357ca28b857a3ec4f34d4cee", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -4,6 +4,9 @@ name = \"ra_hir\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n arrayvec = \"0.5.1\"\n log = \"0.4.5\"\n@@ -23,9 +26,9 @@ hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n test_utils = { path = \"../test_utils\" }\n ra_prof = { path = \"../ra_prof\" }\n \n-chalk-solve = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"50f9f636123bd88d0cc1b958749981d6702e4d05\" }\n-chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"50f9f636123bd88d0cc1b958749981d6702e4d05\" }\n-chalk-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"50f9f636123bd88d0cc1b958749981d6702e4d05\" }\n+chalk-solve = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\" }\n+chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\" }\n+chalk-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\" }\n lalrpop-intern = \"0.15.1\"\n \n [dev-dependencies]"}, {"sha": "731cc1fffbeae5c36ca23155d2b0842aadaf604a", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -11,7 +11,7 @@ use hir_def::{\n     body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n     type_ref::{Mutability, TypeRef},\n-    CrateModuleId, LocalEnumVariantId, LocalStructFieldId, ModuleId, UnionId,\n+    CrateModuleId, ImplId, LocalEnumVariantId, LocalStructFieldId, ModuleId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n@@ -29,7 +29,6 @@ use crate::{\n         AstItemDef, ConstId, EnumId, FunctionId, MacroDefId, StaticId, StructId, TraitId,\n         TypeAliasId,\n     },\n-    impl_block::ImplBlock,\n     resolve::{Resolver, Scope, TypeNs},\n     traits::TraitData,\n     ty::{InferenceResult, Namespace, TraitRef},\n@@ -243,12 +242,8 @@ impl Module {\n     }\n \n     pub fn impl_blocks(self, db: &impl DefDatabase) -> Vec<ImplBlock> {\n-        let module_impl_blocks = db.impls_in_module(self);\n-        module_impl_blocks\n-            .impls\n-            .iter()\n-            .map(|(impl_id, _)| ImplBlock::from_id(self, impl_id))\n-            .collect()\n+        let def_map = db.crate_def_map(self.id.krate);\n+        def_map[self.id.module_id].impls.iter().copied().map(ImplBlock::from).collect()\n     }\n \n     fn with_module_id(self, module_id: CrateModuleId) -> Module {\n@@ -693,8 +688,7 @@ impl Function {\n \n     /// The containing impl block, if this is a method.\n     pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n-        let module_impls = db.impls_in_module(self.module(db));\n-        ImplBlock::containing(module_impls, self.into())\n+        ImplBlock::containing(db, self.into())\n     }\n \n     /// The containing trait, if this is a trait method definition.\n@@ -759,8 +753,7 @@ impl Const {\n \n     /// The containing impl block, if this is a method.\n     pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n-        let module_impls = db.impls_in_module(self.module(db));\n-        ImplBlock::containing(module_impls, self.into())\n+        ImplBlock::containing(db, self.into())\n     }\n \n     pub fn parent_trait(self, db: &impl DefDatabase) -> Option<Trait> {\n@@ -973,8 +966,7 @@ impl TypeAlias {\n \n     /// The containing impl block, if this is a method.\n     pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n-        let module_impls = db.impls_in_module(self.module(db));\n-        ImplBlock::containing(module_impls, self.into())\n+        ImplBlock::containing(db, self.into())\n     }\n \n     /// The containing trait, if this is a trait method definition.\n@@ -1137,3 +1129,8 @@ pub struct GenericParam {\n     pub(crate) parent: GenericDef,\n     pub(crate) idx: u32,\n }\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ImplBlock {\n+    pub(crate) id: ImplId,\n+}"}, {"sha": "d75d71d6659344e3ab480dadfe337a97f03f0716", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -10,22 +10,23 @@ use crate::{\n     debug::HirDebugDatabase,\n     generics::{GenericDef, GenericParams},\n     ids,\n-    impl_block::{ImplBlock, ImplSourceMap, ModuleImplBlocks},\n     lang_item::{LangItemTarget, LangItems},\n     traits::TraitData,\n     ty::{\n-        method_resolution::CrateImplBlocks, traits::Impl, CallableDef, FnSig, GenericPredicate,\n-        InferenceResult, Namespace, Substs, Ty, TypableDef, TypeCtor,\n+        method_resolution::CrateImplBlocks,\n+        traits::{AssocTyValue, Impl},\n+        CallableDef, FnSig, GenericPredicate, InferenceResult, Namespace, Substs, Ty, TypableDef,\n+        TypeCtor,\n     },\n     type_alias::TypeAliasData,\n-    Const, ConstData, Crate, DefWithBody, FnData, Function, Module, Static, StructField, Trait,\n-    TypeAlias,\n+    Const, ConstData, Crate, DefWithBody, FnData, Function, ImplBlock, Module, Static, StructField,\n+    Trait, TypeAlias,\n };\n \n pub use hir_def::db::{\n     BodyQuery, BodyWithSourceMapQuery, CrateDefMapQuery, DefDatabase2, DefDatabase2Storage,\n-    EnumDataQuery, ExprScopesQuery, InternDatabase, InternDatabaseStorage, RawItemsQuery,\n-    RawItemsWithSourceMapQuery, StructDataQuery,\n+    EnumDataQuery, ExprScopesQuery, ImplDataQuery, InternDatabase, InternDatabaseStorage,\n+    RawItemsQuery, RawItemsWithSourceMapQuery, StructDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, MacroArgQuery, MacroDefQuery, MacroExpandQuery,\n@@ -42,15 +43,6 @@ pub trait DefDatabase: HirDebugDatabase + DefDatabase2 {\n     #[salsa::invoke(crate::traits::TraitItemsIndex::trait_items_index)]\n     fn trait_items_index(&self, module: Module) -> crate::traits::TraitItemsIndex;\n \n-    #[salsa::invoke(ModuleImplBlocks::impls_in_module_with_source_map_query)]\n-    fn impls_in_module_with_source_map(\n-        &self,\n-        module: Module,\n-    ) -> (Arc<ModuleImplBlocks>, Arc<ImplSourceMap>);\n-\n-    #[salsa::invoke(ModuleImplBlocks::impls_in_module_query)]\n-    fn impls_in_module(&self, module: Module) -> Arc<ModuleImplBlocks>;\n-\n     #[salsa::invoke(crate::generics::GenericParams::generic_params_query)]\n     fn generic_params(&self, def: GenericDef) -> Arc<GenericParams>;\n \n@@ -128,27 +120,43 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     #[salsa::interned]\n     fn intern_type_ctor(&self, type_ctor: TypeCtor) -> ids::TypeCtorId;\n     #[salsa::interned]\n-    fn intern_impl(&self, impl_: Impl) -> ids::GlobalImplId;\n+    fn intern_chalk_impl(&self, impl_: Impl) -> ids::GlobalImplId;\n+    #[salsa::interned]\n+    fn intern_assoc_ty_value(&self, assoc_ty_value: AssocTyValue) -> ids::AssocTyValueId;\n \n     #[salsa::invoke(crate::ty::traits::chalk::associated_ty_data_query)]\n-    fn associated_ty_data(&self, id: chalk_ir::TypeId) -> Arc<chalk_rust_ir::AssociatedTyDatum>;\n+    fn associated_ty_data(\n+        &self,\n+        id: chalk_ir::TypeId,\n+    ) -> Arc<chalk_rust_ir::AssociatedTyDatum<chalk_ir::family::ChalkIr>>;\n \n     #[salsa::invoke(crate::ty::traits::chalk::trait_datum_query)]\n     fn trait_datum(\n         &self,\n         krate: Crate,\n         trait_id: chalk_ir::TraitId,\n-    ) -> Arc<chalk_rust_ir::TraitDatum>;\n+    ) -> Arc<chalk_rust_ir::TraitDatum<chalk_ir::family::ChalkIr>>;\n \n     #[salsa::invoke(crate::ty::traits::chalk::struct_datum_query)]\n     fn struct_datum(\n         &self,\n         krate: Crate,\n         struct_id: chalk_ir::StructId,\n-    ) -> Arc<chalk_rust_ir::StructDatum>;\n+    ) -> Arc<chalk_rust_ir::StructDatum<chalk_ir::family::ChalkIr>>;\n \n     #[salsa::invoke(crate::ty::traits::chalk::impl_datum_query)]\n-    fn impl_datum(&self, krate: Crate, impl_id: chalk_ir::ImplId) -> Arc<chalk_rust_ir::ImplDatum>;\n+    fn impl_datum(\n+        &self,\n+        krate: Crate,\n+        impl_id: chalk_ir::ImplId,\n+    ) -> Arc<chalk_rust_ir::ImplDatum<chalk_ir::family::ChalkIr>>;\n+\n+    #[salsa::invoke(crate::ty::traits::chalk::associated_ty_value_query)]\n+    fn associated_ty_value(\n+        &self,\n+        krate: Crate,\n+        id: chalk_rust_ir::AssociatedTyValueId,\n+    ) -> Arc<chalk_rust_ir::AssociatedTyValue<chalk_ir::family::ChalkIr>>;\n \n     #[salsa::invoke(crate::ty::traits::trait_solve_query)]\n     fn trait_solve("}, {"sha": "f2203e99532e0505a46a5fd8b65250f11a34510b", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -3,9 +3,9 @@\n //! It's unclear if we need this long-term, but it's definitelly useful while we\n //! are splitting the hir.\n \n-use hir_def::{AdtId, DefWithBodyId, EnumVariantId, ModuleDefId};\n+use hir_def::{AdtId, AssocItemId, DefWithBodyId, EnumVariantId, ModuleDefId};\n \n-use crate::{Adt, DefWithBody, EnumVariant, ModuleDef};\n+use crate::{Adt, AssocItem, DefWithBody, EnumVariant, ModuleDef};\n \n macro_rules! from_id {\n     ($(($id:path, $ty:path)),*) => {$(\n@@ -27,6 +27,7 @@ from_id![\n     (hir_def::StaticId, crate::Static),\n     (hir_def::ConstId, crate::Const),\n     (hir_def::FunctionId, crate::Function),\n+    (hir_def::ImplId, crate::ImplBlock),\n     (hir_expand::MacroDefId, crate::MacroDef)\n ];\n \n@@ -71,3 +72,13 @@ impl From<DefWithBody> for DefWithBodyId {\n         }\n     }\n }\n+\n+impl From<AssocItemId> for AssocItem {\n+    fn from(def: AssocItemId) -> Self {\n+        match def {\n+            AssocItemId::FunctionId(it) => AssocItem::Function(it.into()),\n+            AssocItemId::TypeAliasId(it) => AssocItem::TypeAlias(it.into()),\n+            AssocItemId::ConstId(it) => AssocItem::Const(it.into()),\n+        }\n+    }\n+}"}, {"sha": "1c26756c978a9dc78da52036612525d8ab66b08a", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -1,7 +1,7 @@\n //! FIXME: write short doc here\n \n use hir_def::{ModuleId, StructId, StructOrUnionId, UnionId};\n-use hir_expand::name::AsName;\n+use hir_expand::{name::AsName, AstId, MacroDefId, MacroDefKind};\n use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n     match_ast,\n@@ -11,8 +11,8 @@ use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     ids::{AstItemDef, LocationCtx},\n     Const, DefWithBody, Enum, EnumVariant, FieldSource, Function, HasBody, HasSource, ImplBlock,\n-    Local, Module, ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias, Union,\n-    VariantDef,\n+    Local, MacroDef, Module, ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias,\n+    Union, VariantDef,\n };\n \n pub trait FromSource: Sized {\n@@ -77,19 +77,28 @@ impl FromSource for TypeAlias {\n         Some(TypeAlias { id })\n     }\n }\n-// FIXME: add impl FromSource for MacroDef\n+\n+impl FromSource for MacroDef {\n+    type Ast = ast::MacroCall;\n+    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+        let kind = MacroDefKind::Declarative;\n+\n+        let module_src = ModuleSource::from_child_node(db, src.as_ref().map(|it| it.syntax()));\n+        let module = Module::from_definition(db, Source::new(src.file_id, module_src))?;\n+        let krate = module.krate().crate_id();\n+\n+        let ast_id = AstId::new(src.file_id, db.ast_id_map(src.file_id).ast_id(&src.ast));\n+\n+        let id: MacroDefId = MacroDefId { krate, ast_id, kind };\n+        Some(MacroDef { id })\n+    }\n+}\n \n impl FromSource for ImplBlock {\n     type Ast = ast::ImplBlock;\n     fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n-        let module_src = crate::ModuleSource::from_child_node(\n-            db,\n-            src.file_id.original_file(db),\n-            &src.ast.syntax(),\n-        );\n-        let module = Module::from_definition(db, Source { file_id: src.file_id, ast: module_src })?;\n-        let impls = module.impl_blocks(db);\n-        impls.into_iter().find(|b| b.source(db) == src)\n+        let id = from_source(db, src)?;\n+        Some(ImplBlock { id })\n     }\n }\n \n@@ -202,9 +211,8 @@ where\n     N: AstNode,\n     DEF: AstItemDef<N>,\n {\n-    let module_src =\n-        crate::ModuleSource::from_child_node(db, src.file_id.original_file(db), &src.ast.syntax());\n-    let module = Module::from_definition(db, Source { file_id: src.file_id, ast: module_src })?;\n+    let module_src = ModuleSource::from_child_node(db, src.as_ref().map(|it| it.syntax()));\n+    let module = Module::from_definition(db, Source::new(src.file_id, module_src))?;\n     let ctx = LocationCtx::new(db, module.id, src.file_id);\n     Some(DEF::from_ast(ctx, &src.ast))\n }"}, {"sha": "2b59365fb6a43a3ffa45286bb2fe628998075789", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -37,3 +37,9 @@ impl_intern_key!(TypeCtorId);\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct GlobalImplId(salsa::InternId);\n impl_intern_key!(GlobalImplId);\n+\n+/// This exists just for Chalk, because it needs a unique ID for each associated\n+/// type value in an impl (even synthetic ones).\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct AssocTyValueId(salsa::InternId);\n+impl_intern_key!(AssocTyValueId);"}, {"sha": "0c2bb8fee3eb15f50e1c658dee2a2c2e108493c5", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 23, "deletions": 237, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -1,88 +1,38 @@\n //! FIXME: write short doc here\n \n-use rustc_hash::FxHashMap;\n-use std::sync::Arc;\n-\n-use hir_def::{attr::Attr, type_ref::TypeRef};\n-use hir_expand::hygiene::Hygiene;\n-use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n-use ra_cfg::CfgOptions;\n-use ra_syntax::{\n-    ast::{self, AstNode},\n-    AstPtr,\n-};\n+use hir_def::{type_ref::TypeRef, AstItemDef};\n+use ra_syntax::ast::{self};\n \n use crate::{\n-    code_model::{Module, ModuleSource},\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     generics::HasGenericParams,\n-    ids::LocationCtx,\n-    ids::MacroCallLoc,\n     resolve::Resolver,\n     ty::Ty,\n-    AssocItem, AstId, Const, Function, HasSource, HirFileId, MacroFileKind, Path, Source, TraitRef,\n-    TypeAlias,\n+    AssocItem, Crate, HasSource, ImplBlock, Module, Source, TraitRef,\n };\n \n-#[derive(Debug, Default, PartialEq, Eq)]\n-pub struct ImplSourceMap {\n-    map: ArenaMap<ImplId, Source<AstPtr<ast::ImplBlock>>>,\n-}\n-\n-impl ImplSourceMap {\n-    fn insert(&mut self, impl_id: ImplId, file_id: HirFileId, impl_block: &ast::ImplBlock) {\n-        let source = Source { file_id, ast: AstPtr::new(impl_block) };\n-        self.map.insert(impl_id, source)\n-    }\n-\n-    pub fn get(&self, db: &impl AstDatabase, impl_id: ImplId) -> Source<ast::ImplBlock> {\n-        let src = self.map[impl_id];\n-        let root = src.file_syntax(db);\n-        src.map(|ptr| ptr.to_node(&root))\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct ImplBlock {\n-    module: Module,\n-    impl_id: ImplId,\n-}\n-\n impl HasSource for ImplBlock {\n     type Ast = ast::ImplBlock;\n     fn source(self, db: &(impl DefDatabase + AstDatabase)) -> Source<ast::ImplBlock> {\n-        let source_map = db.impls_in_module_with_source_map(self.module).1;\n-        source_map.get(db, self.impl_id)\n+        self.id.source(db)\n     }\n }\n \n impl ImplBlock {\n-    pub(crate) fn containing(\n-        module_impl_blocks: Arc<ModuleImplBlocks>,\n-        item: AssocItem,\n-    ) -> Option<ImplBlock> {\n-        let impl_id = *module_impl_blocks.impls_by_def.get(&item)?;\n-        Some(ImplBlock { module: module_impl_blocks.module, impl_id })\n-    }\n-\n-    pub(crate) fn from_id(module: Module, impl_id: ImplId) -> ImplBlock {\n-        ImplBlock { module, impl_id }\n-    }\n-\n-    pub fn id(&self) -> ImplId {\n-        self.impl_id\n-    }\n-\n-    pub fn module(&self) -> Module {\n-        self.module\n+    pub(crate) fn containing(db: &impl DefDatabase, item: AssocItem) -> Option<ImplBlock> {\n+        let module = item.module(db);\n+        let crate_def_map = db.crate_def_map(module.id.krate);\n+        crate_def_map[module.id.module_id].impls.iter().copied().map(ImplBlock::from).find(|it| {\n+            db.impl_data(it.id).items().iter().copied().map(AssocItem::from).any(|it| it == item)\n+        })\n     }\n \n     pub fn target_trait(&self, db: &impl DefDatabase) -> Option<TypeRef> {\n-        db.impls_in_module(self.module).impls[self.impl_id].target_trait().cloned()\n+        db.impl_data(self.id).target_trait().cloned()\n     }\n \n     pub fn target_type(&self, db: &impl DefDatabase) -> TypeRef {\n-        db.impls_in_module(self.module).impls[self.impl_id].target_type().clone()\n+        db.impl_data(self.id).target_type().clone()\n     }\n \n     pub fn target_ty(&self, db: &impl HirDatabase) -> Ty {\n@@ -95,191 +45,27 @@ impl ImplBlock {\n     }\n \n     pub fn items(&self, db: &impl DefDatabase) -> Vec<AssocItem> {\n-        db.impls_in_module(self.module).impls[self.impl_id].items().to_vec()\n+        db.impl_data(self.id).items().iter().map(|it| (*it).into()).collect()\n     }\n \n     pub fn is_negative(&self, db: &impl DefDatabase) -> bool {\n-        db.impls_in_module(self.module).impls[self.impl_id].negative\n+        db.impl_data(self.id).is_negative()\n+    }\n+\n+    pub fn module(&self, db: &impl DefDatabase) -> Module {\n+        self.id.module(db).into()\n+    }\n+\n+    pub fn krate(&self, db: &impl DefDatabase) -> Crate {\n+        Crate { crate_id: self.module(db).id.krate }\n     }\n \n     pub(crate) fn resolver(&self, db: &impl DefDatabase) -> Resolver {\n-        let r = self.module().resolver(db);\n+        let r = self.module(db).resolver(db);\n         // add generic params, if present\n         let p = self.generic_params(db);\n         let r = if !p.params.is_empty() { r.push_generic_params_scope(p) } else { r };\n         let r = r.push_impl_block_scope(self.clone());\n         r\n     }\n }\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct ImplData {\n-    target_trait: Option<TypeRef>,\n-    target_type: TypeRef,\n-    items: Vec<AssocItem>,\n-    negative: bool,\n-}\n-\n-impl ImplData {\n-    pub(crate) fn from_ast(\n-        db: &(impl DefDatabase + AstDatabase),\n-        file_id: HirFileId,\n-        module: Module,\n-        node: &ast::ImplBlock,\n-    ) -> Self {\n-        let target_trait = node.target_trait().map(TypeRef::from_ast);\n-        let target_type = TypeRef::from_ast_opt(node.target_type());\n-        let ctx = LocationCtx::new(db, module.id, file_id);\n-        let negative = node.is_negative();\n-        let items = if let Some(item_list) = node.item_list() {\n-            item_list\n-                .impl_items()\n-                .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => Function { id: ctx.to_def(&it) }.into(),\n-                    ast::ImplItem::ConstDef(it) => Const { id: ctx.to_def(&it) }.into(),\n-                    ast::ImplItem::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(&it) }.into(),\n-                })\n-                .collect()\n-        } else {\n-            Vec::new()\n-        };\n-        ImplData { target_trait, target_type, items, negative }\n-    }\n-\n-    pub fn target_trait(&self) -> Option<&TypeRef> {\n-        self.target_trait.as_ref()\n-    }\n-\n-    pub fn target_type(&self) -> &TypeRef {\n-        &self.target_type\n-    }\n-\n-    pub fn items(&self) -> &[AssocItem] {\n-        &self.items\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct ImplId(pub RawId);\n-impl_arena_id!(ImplId);\n-\n-/// The collection of impl blocks is a two-step process: first we collect the\n-/// blocks per-module; then we build an index of all impl blocks in the crate.\n-/// This way, we avoid having to do this process for the whole crate whenever\n-/// a file is changed; as long as the impl blocks in the file don't change,\n-/// we don't need to do the second step again.\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct ModuleImplBlocks {\n-    pub(crate) module: Module,\n-    pub(crate) impls: Arena<ImplId, ImplData>,\n-    impls_by_def: FxHashMap<AssocItem, ImplId>,\n-}\n-\n-impl ModuleImplBlocks {\n-    pub(crate) fn impls_in_module_with_source_map_query(\n-        db: &(impl DefDatabase + AstDatabase),\n-        module: Module,\n-    ) -> (Arc<ModuleImplBlocks>, Arc<ImplSourceMap>) {\n-        let mut source_map = ImplSourceMap::default();\n-        let crate_graph = db.crate_graph();\n-        let cfg_options = crate_graph.cfg_options(module.id.krate);\n-\n-        let result = ModuleImplBlocks::collect(db, cfg_options, module, &mut source_map);\n-        (Arc::new(result), Arc::new(source_map))\n-    }\n-\n-    pub(crate) fn impls_in_module_query(\n-        db: &impl DefDatabase,\n-        module: Module,\n-    ) -> Arc<ModuleImplBlocks> {\n-        db.impls_in_module_with_source_map(module).0\n-    }\n-\n-    fn collect(\n-        db: &(impl DefDatabase + AstDatabase),\n-        cfg_options: &CfgOptions,\n-        module: Module,\n-        source_map: &mut ImplSourceMap,\n-    ) -> Self {\n-        let mut m = ModuleImplBlocks {\n-            module,\n-            impls: Arena::default(),\n-            impls_by_def: FxHashMap::default(),\n-        };\n-\n-        let src = m.module.definition_source(db);\n-        match &src.ast {\n-            ModuleSource::SourceFile(node) => {\n-                m.collect_from_item_owner(db, cfg_options, source_map, node, src.file_id)\n-            }\n-            ModuleSource::Module(node) => {\n-                let item_list = node.item_list().expect(\"inline module should have item list\");\n-                m.collect_from_item_owner(db, cfg_options, source_map, &item_list, src.file_id)\n-            }\n-        };\n-        m\n-    }\n-\n-    fn collect_from_item_owner(\n-        &mut self,\n-        db: &(impl DefDatabase + AstDatabase),\n-        cfg_options: &CfgOptions,\n-        source_map: &mut ImplSourceMap,\n-        owner: &dyn ast::ModuleItemOwner,\n-        file_id: HirFileId,\n-    ) {\n-        let hygiene = Hygiene::new(db, file_id);\n-        for item in owner.items_with_macros() {\n-            match item {\n-                ast::ItemOrMacro::Item(ast::ModuleItem::ImplBlock(impl_block_ast)) => {\n-                    let attrs = Attr::from_attrs_owner(&impl_block_ast, &hygiene);\n-                    if attrs.map_or(false, |attrs| {\n-                        attrs.iter().any(|attr| attr.is_cfg_enabled(cfg_options) == Some(false))\n-                    }) {\n-                        continue;\n-                    }\n-\n-                    let impl_block = ImplData::from_ast(db, file_id, self.module, &impl_block_ast);\n-                    let id = self.impls.alloc(impl_block);\n-                    for &impl_item in &self.impls[id].items {\n-                        self.impls_by_def.insert(impl_item, id);\n-                    }\n-\n-                    source_map.insert(id, file_id, &impl_block_ast);\n-                }\n-                ast::ItemOrMacro::Item(_) => (),\n-                ast::ItemOrMacro::Macro(macro_call) => {\n-                    let attrs = Attr::from_attrs_owner(&macro_call, &hygiene);\n-                    if attrs.map_or(false, |attrs| {\n-                        attrs.iter().any(|attr| attr.is_cfg_enabled(cfg_options) == Some(false))\n-                    }) {\n-                        continue;\n-                    }\n-\n-                    //FIXME: we should really cut down on the boilerplate required to process a macro\n-                    let ast_id = AstId::new(file_id, db.ast_id_map(file_id).ast_id(&macro_call));\n-                    if let Some(path) =\n-                        macro_call.path().and_then(|path| Path::from_src(path, &hygiene))\n-                    {\n-                        if let Some(def) = self.module.resolver(db).resolve_path_as_macro(db, &path)\n-                        {\n-                            let call_id = db.intern_macro(MacroCallLoc { def: def.id, ast_id });\n-                            let file_id = call_id.as_file(MacroFileKind::Items);\n-                            if let Some(item_list) =\n-                                db.parse_or_expand(file_id).and_then(ast::MacroItems::cast)\n-                            {\n-                                self.collect_from_item_owner(\n-                                    db,\n-                                    cfg_options,\n-                                    source_map,\n-                                    &item_list,\n-                                    file_id,\n-                                )\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "fa2ef8a1739d19d61b536d76e9a2946495d5663d", "filename": "crates/ra_hir/src/lang_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flang_item.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -25,7 +25,7 @@ impl LangItemTarget {\n         Some(match self {\n             LangItemTarget::Enum(e) => e.module(db).krate(),\n             LangItemTarget::Function(f) => f.module(db).krate(),\n-            LangItemTarget::ImplBlock(i) => i.module().krate(),\n+            LangItemTarget::ImplBlock(i) => i.krate(db),\n             LangItemTarget::Static(s) => s.module(db).krate(),\n             LangItemTarget::Struct(s) => s.module(db).krate(),\n             LangItemTarget::Trait(t) => t.module(db).krate(),"}, {"sha": "da33c959152ca3c3aee693878d8939ed5603de8d", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -54,12 +54,11 @@ mod test_db;\n #[cfg(test)]\n mod marks;\n \n-use hir_expand::AstId;\n-\n-use crate::{ids::MacroFileKind, resolve::Resolver};\n+use crate::resolve::Resolver;\n \n pub use crate::{\n     adt::VariantDef,\n+    code_model::ImplBlock,\n     code_model::{\n         attrs::{AttrDef, Attrs},\n         docs::{DocDef, Docs, Documentation},\n@@ -72,7 +71,6 @@ pub use crate::{\n     from_source::FromSource,\n     generics::GenericDef,\n     ids::{HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile},\n-    impl_block::ImplBlock,\n     resolve::ScopeDef,\n     source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n     ty::{"}, {"sha": "79b92180a69decda7fd522e265a21c321b48eb8c", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -15,9 +15,8 @@ use crate::{\n     db::{DefDatabase, HirDatabase},\n     expr::{ExprScopes, PatId, ScopeId},\n     generics::GenericParams,\n-    impl_block::ImplBlock,\n-    Adt, Const, DefWithBody, Enum, EnumVariant, Function, Local, MacroDef, ModuleDef, PerNs,\n-    Static, Struct, Trait, TypeAlias,\n+    Adt, Const, DefWithBody, Enum, EnumVariant, Function, ImplBlock, Local, MacroDef, ModuleDef,\n+    PerNs, Static, Struct, Trait, TypeAlias,\n };\n \n #[derive(Debug, Clone, Default)]"}, {"sha": "f0ed8e2b2506995edec82fc3093a425fd18159a3", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 70, "deletions": 49, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -11,13 +11,12 @@ use hir_def::{\n     expr::{ExprId, PatId},\n     path::known,\n };\n-use hir_expand::{name::AsName, Source};\n-use ra_db::FileId;\n+use hir_expand::{name::AsName, AstId, MacroCallId, MacroCallLoc, MacroFileKind, Source};\n use ra_syntax::{\n     ast::{self, AstNode},\n     match_ast, AstPtr,\n     SyntaxKind::*,\n-    SyntaxNode, SyntaxNodePtr, TextRange, TextUnit,\n+    SyntaxNode, SyntaxNodePtr, SyntaxToken, TextRange, TextUnit,\n };\n \n use crate::{\n@@ -30,52 +29,45 @@ use crate::{\n     HirFileId, Local, MacroDef, Module, Name, Path, Resolver, Static, Struct, Ty,\n };\n \n-fn try_get_resolver_for_node(\n-    db: &impl HirDatabase,\n-    file_id: FileId,\n-    node: &SyntaxNode,\n-) -> Option<Resolver> {\n+fn try_get_resolver_for_node(db: &impl HirDatabase, node: Source<&SyntaxNode>) -> Option<Resolver> {\n     match_ast! {\n-        match node {\n+        match (node.ast) {\n             ast::Module(it) => {\n-                let src = crate::Source { file_id: file_id.into(), ast: it };\n+                let src = node.with_ast(it);\n                 Some(crate::Module::from_declaration(db, src)?.resolver(db))\n             },\n              ast::SourceFile(it) => {\n-                let src =\n-                    crate::Source { file_id: file_id.into(), ast: crate::ModuleSource::SourceFile(it) };\n+                let src = node.with_ast(crate::ModuleSource::SourceFile(it));\n                 Some(crate::Module::from_definition(db, src)?.resolver(db))\n             },\n             ast::StructDef(it) => {\n-                let src = crate::Source { file_id: file_id.into(), ast: it };\n+                let src = node.with_ast(it);\n                 Some(Struct::from_source(db, src)?.resolver(db))\n             },\n             ast::EnumDef(it) => {\n-                let src = crate::Source { file_id: file_id.into(), ast: it };\n+                let src = node.with_ast(it);\n                 Some(Enum::from_source(db, src)?.resolver(db))\n             },\n-            _ => {\n-                if node.kind() == FN_DEF || node.kind() == CONST_DEF || node.kind() == STATIC_DEF {\n-                    Some(def_with_body_from_child_node(db, file_id, node)?.resolver(db))\n-                } else {\n-                    // FIXME add missing cases\n-                    None\n+            _ => match node.ast.kind() {\n+                FN_DEF | CONST_DEF | STATIC_DEF => {\n+                    Some(def_with_body_from_child_node(db, node)?.resolver(db))\n                 }\n-            },\n+                // FIXME add missing cases\n+                _ => None\n+            }\n         }\n     }\n }\n \n fn def_with_body_from_child_node(\n     db: &impl HirDatabase,\n-    file_id: FileId,\n-    node: &SyntaxNode,\n+    child: Source<&SyntaxNode>,\n ) -> Option<DefWithBody> {\n-    let src = crate::ModuleSource::from_child_node(db, file_id, node);\n-    let module = Module::from_definition(db, crate::Source { file_id: file_id.into(), ast: src })?;\n-    let ctx = LocationCtx::new(db, module.id, file_id.into());\n+    let module_source = crate::ModuleSource::from_child_node(db, child);\n+    let module = Module::from_definition(db, Source::new(child.file_id, module_source))?;\n+    let ctx = LocationCtx::new(db, module.id, child.file_id);\n \n-    node.ancestors().find_map(|node| {\n+    child.ast.ancestors().find_map(|node| {\n         match_ast! {\n             match node {\n                 ast::FnDef(def)  => { Some(Function {id: ctx.to_def(&def) }.into()) },\n@@ -91,8 +83,7 @@ fn def_with_body_from_child_node(\n /// original source files. It should not be used inside the HIR itself.\n #[derive(Debug)]\n pub struct SourceAnalyzer {\n-    // FIXME: this doesn't handle macros at all\n-    file_id: FileId,\n+    file_id: HirFileId,\n     resolver: Resolver,\n     body_owner: Option<DefWithBody>,\n     body_source_map: Option<Arc<BodySourceMap>>,\n@@ -135,20 +126,38 @@ pub struct ReferenceDescriptor {\n     pub name: String,\n }\n \n+pub struct Expansion {\n+    macro_call_id: MacroCallId,\n+}\n+\n+impl Expansion {\n+    pub fn map_token_down(\n+        &self,\n+        db: &impl HirDatabase,\n+        token: Source<&SyntaxToken>,\n+    ) -> Option<Source<SyntaxToken>> {\n+        let exp_info = self.file_id().expansion_info(db)?;\n+        exp_info.map_token_down(token)\n+    }\n+\n+    fn file_id(&self) -> HirFileId {\n+        self.macro_call_id.as_file(MacroFileKind::Items)\n+    }\n+}\n+\n impl SourceAnalyzer {\n     pub fn new(\n         db: &impl HirDatabase,\n-        file_id: FileId,\n-        node: &SyntaxNode,\n+        node: Source<&SyntaxNode>,\n         offset: Option<TextUnit>,\n     ) -> SourceAnalyzer {\n-        let def_with_body = def_with_body_from_child_node(db, file_id, node);\n+        let def_with_body = def_with_body_from_child_node(db, node);\n         if let Some(def) = def_with_body {\n             let source_map = def.body_source_map(db);\n             let scopes = def.expr_scopes(db);\n             let scope = match offset {\n-                None => scope_for(&scopes, &source_map, file_id.into(), &node),\n-                Some(offset) => scope_for_offset(&scopes, &source_map, file_id.into(), offset),\n+                None => scope_for(&scopes, &source_map, node),\n+                Some(offset) => scope_for_offset(&scopes, &source_map, node.with_ast(offset)),\n             };\n             let resolver = expr::resolver_for_scope(db, def, scope);\n             SourceAnalyzer {\n@@ -157,30 +166,31 @@ impl SourceAnalyzer {\n                 body_source_map: Some(source_map),\n                 infer: Some(def.infer(db)),\n                 scopes: Some(scopes),\n-                file_id,\n+                file_id: node.file_id,\n             }\n         } else {\n             SourceAnalyzer {\n                 resolver: node\n+                    .ast\n                     .ancestors()\n-                    .find_map(|node| try_get_resolver_for_node(db, file_id, &node))\n+                    .find_map(|it| try_get_resolver_for_node(db, node.with_ast(&it)))\n                     .unwrap_or_default(),\n                 body_owner: None,\n                 body_source_map: None,\n                 infer: None,\n                 scopes: None,\n-                file_id,\n+                file_id: node.file_id,\n             }\n         }\n     }\n \n     fn expr_id(&self, expr: &ast::Expr) -> Option<ExprId> {\n-        let src = Source { file_id: self.file_id.into(), ast: expr };\n+        let src = Source { file_id: self.file_id, ast: expr };\n         self.body_source_map.as_ref()?.node_expr(src)\n     }\n \n     fn pat_id(&self, pat: &ast::Pat) -> Option<PatId> {\n-        let src = Source { file_id: self.file_id.into(), ast: pat };\n+        let src = Source { file_id: self.file_id, ast: pat };\n         self.body_source_map.as_ref()?.node_pat(src)\n     }\n \n@@ -288,7 +298,7 @@ impl SourceAnalyzer {\n         let name = name_ref.as_name();\n         let source_map = self.body_source_map.as_ref()?;\n         let scopes = self.scopes.as_ref()?;\n-        let scope = scope_for(scopes, source_map, self.file_id.into(), name_ref.syntax())?;\n+        let scope = scope_for(scopes, source_map, Source::new(self.file_id, name_ref.syntax()))?;\n         let entry = scopes.resolve_name_in_scope(scope, &name)?;\n         Some(ScopeEntryWithSyntax {\n             name: entry.name().clone(),\n@@ -395,6 +405,13 @@ impl SourceAnalyzer {\n         implements_trait(&canonical_ty, db, &self.resolver, krate, std_future_trait)\n     }\n \n+    pub fn expand(&self, db: &impl HirDatabase, macro_call: &ast::MacroCall) -> Option<Expansion> {\n+        let def = self.resolve_macro_call(db, macro_call)?.id;\n+        let ast_id = AstId::new(self.file_id, db.ast_id_map(self.file_id).ast_id(macro_call));\n+        let macro_call_loc = MacroCallLoc { def, ast_id };\n+        Some(Expansion { macro_call_id: db.intern_macro(macro_call_loc) })\n+    }\n+\n     #[cfg(test)]\n     pub(crate) fn body_source_map(&self) -> Arc<BodySourceMap> {\n         self.body_source_map.clone().unwrap()\n@@ -409,28 +426,27 @@ impl SourceAnalyzer {\n fn scope_for(\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,\n-    file_id: HirFileId,\n-    node: &SyntaxNode,\n+    node: Source<&SyntaxNode>,\n ) -> Option<ScopeId> {\n-    node.ancestors()\n+    node.ast\n+        .ancestors()\n         .filter_map(ast::Expr::cast)\n-        .filter_map(|it| source_map.node_expr(Source { file_id, ast: &it }))\n+        .filter_map(|it| source_map.node_expr(Source::new(node.file_id, &it)))\n         .find_map(|it| scopes.scope_for(it))\n }\n \n fn scope_for_offset(\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,\n-    file_id: HirFileId,\n-    offset: TextUnit,\n+    offset: Source<TextUnit>,\n ) -> Option<ScopeId> {\n     scopes\n         .scope_by_expr()\n         .iter()\n         .filter_map(|(id, scope)| {\n             let source = source_map.expr_syntax(*id)?;\n             // FIXME: correctly handle macro expansion\n-            if source.file_id != file_id {\n+            if source.file_id != offset.file_id {\n                 return None;\n             }\n             let syntax_node_ptr =\n@@ -439,9 +455,14 @@ fn scope_for_offset(\n         })\n         // find containing scope\n         .min_by_key(|(ptr, _scope)| {\n-            (!(ptr.range().start() <= offset && offset <= ptr.range().end()), ptr.range().len())\n+            (\n+                !(ptr.range().start() <= offset.ast && offset.ast <= ptr.range().end()),\n+                ptr.range().len(),\n+            )\n+        })\n+        .map(|(ptr, scope)| {\n+            adjust(scopes, source_map, ptr, offset.file_id, offset.ast).unwrap_or(*scope)\n         })\n-        .map(|(ptr, scope)| adjust(scopes, source_map, ptr, file_id, offset).unwrap_or(*scope))\n }\n \n // XXX: during completion, cursor might be outside of any particular"}, {"sha": "b7f50b714f750b24431d7b1a4df53f60c7504988", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 59, "deletions": 34, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -79,7 +79,7 @@ pub enum TypeCtor {\n     ///\n     /// For example the type of `bar` here:\n     ///\n-    /// ```rust\n+    /// ```\n     /// fn foo() -> i32 { 1 }\n     /// let bar = foo; // bar: fn() -> i32 {foo}\n     /// ```\n@@ -89,7 +89,7 @@ pub enum TypeCtor {\n     ///\n     /// For example the type of `bar` here:\n     ///\n-    /// ```rust\n+    /// ```\n     /// fn foo() -> i32 { 1 }\n     /// let bar: fn() -> i32 = foo;\n     /// ```\n@@ -224,8 +224,8 @@ impl TypeWalk for ProjectionTy {\n         self.parameters.walk(f);\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        self.parameters.walk_mut(f);\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        self.parameters.walk_mut_binders(f, binders);\n     }\n }\n \n@@ -291,6 +291,20 @@ pub enum Ty {\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Substs(Arc<[Ty]>);\n \n+impl TypeWalk for Substs {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        for t in self.0.iter() {\n+            t.walk(f);\n+        }\n+    }\n+\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        for t in make_mut_slice(&mut self.0) {\n+            t.walk_mut_binders(f, binders);\n+        }\n+    }\n+}\n+\n impl Substs {\n     pub fn empty() -> Substs {\n         Substs(Arc::new([]))\n@@ -304,18 +318,6 @@ impl Substs {\n         Substs(self.0[..std::cmp::min(self.0.len(), n)].into())\n     }\n \n-    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        for t in self.0.iter() {\n-            t.walk(f);\n-        }\n-    }\n-\n-    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        for t in make_mut_slice(&mut self.0) {\n-            t.walk_mut(f);\n-        }\n-    }\n-\n     pub fn as_single(&self) -> &Ty {\n         if self.0.len() != 1 {\n             panic!(\"expected substs of len 1, got {:?}\", self);\n@@ -440,8 +442,8 @@ impl TypeWalk for TraitRef {\n         self.substs.walk(f);\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        self.substs.walk_mut(f);\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        self.substs.walk_mut_binders(f, binders);\n     }\n }\n \n@@ -491,10 +493,12 @@ impl TypeWalk for GenericPredicate {\n         }\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n         match self {\n-            GenericPredicate::Implemented(trait_ref) => trait_ref.walk_mut(f),\n-            GenericPredicate::Projection(projection_pred) => projection_pred.walk_mut(f),\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.walk_mut_binders(f, binders),\n+            GenericPredicate::Projection(projection_pred) => {\n+                projection_pred.walk_mut_binders(f, binders)\n+            }\n             GenericPredicate::Error => {}\n         }\n     }\n@@ -544,9 +548,9 @@ impl TypeWalk for FnSig {\n         }\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n         for t in make_mut_slice(&mut self.params_and_return) {\n-            t.walk_mut(f);\n+            t.walk_mut_binders(f, binders);\n         }\n     }\n }\n@@ -671,7 +675,20 @@ impl Ty {\n /// types, similar to Chalk's `Fold` trait.\n pub trait TypeWalk {\n     fn walk(&self, f: &mut impl FnMut(&Ty));\n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty));\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        self.walk_mut_binders(&mut |ty, _binders| f(ty), 0);\n+    }\n+    /// Walk the type, counting entered binders.\n+    ///\n+    /// `Ty::Bound` variables use DeBruijn indexing, which means that 0 refers\n+    /// to the innermost binder, 1 to the next, etc.. So when we want to\n+    /// substitute a certain bound variable, we can't just walk the whole type\n+    /// and blindly replace each instance of a certain index; when we 'enter'\n+    /// things that introduce new bound variables, we have to keep track of\n+    /// that. Currently, the only thing that introduces bound variables on our\n+    /// side are `Ty::Dyn` and `Ty::Opaque`, which each introduce a bound\n+    /// variable for the self type.\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize);\n \n     fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Self\n     where\n@@ -700,14 +717,22 @@ pub trait TypeWalk {\n     }\n \n     /// Substitutes `Ty::Bound` vars (as opposed to type parameters).\n-    fn subst_bound_vars(self, substs: &Substs) -> Self\n+    fn subst_bound_vars(mut self, substs: &Substs) -> Self\n     where\n         Self: Sized,\n     {\n-        self.fold(&mut |ty| match ty {\n-            Ty::Bound(idx) => substs.get(idx as usize).cloned().unwrap_or_else(|| Ty::Bound(idx)),\n-            ty => ty,\n-        })\n+        self.walk_mut_binders(\n+            &mut |ty, binders| match ty {\n+                &mut Ty::Bound(idx) => {\n+                    if idx as usize >= binders && (idx as usize - binders) < substs.len() {\n+                        *ty = substs.0[idx as usize - binders].clone();\n+                    }\n+                }\n+                _ => {}\n+            },\n+            0,\n+        );\n+        self\n     }\n \n     /// Shifts up `Ty::Bound` vars by `n`.\n@@ -748,22 +773,22 @@ impl TypeWalk for Ty {\n         f(self);\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n         match self {\n             Ty::Apply(a_ty) => {\n-                a_ty.parameters.walk_mut(f);\n+                a_ty.parameters.walk_mut_binders(f, binders);\n             }\n             Ty::Projection(p_ty) => {\n-                p_ty.parameters.walk_mut(f);\n+                p_ty.parameters.walk_mut_binders(f, binders);\n             }\n             Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n                 for p in make_mut_slice(predicates) {\n-                    p.walk_mut(f);\n+                    p.walk_mut_binders(f, binders + 1);\n                 }\n             }\n             Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n-        f(self);\n+        f(self, binders);\n     }\n }\n "}, {"sha": "64d9394cf73b8d466d96b2dfc768b48ddf01220f", "filename": "crates/ra_hir/src/ty/infer/unify.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -134,17 +134,19 @@ where\n }\n \n impl<T> Canonicalized<T> {\n-    pub fn decanonicalize_ty(&self, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty {\n-            Ty::Bound(idx) => {\n-                if (idx as usize) < self.free_vars.len() {\n-                    Ty::Infer(self.free_vars[idx as usize])\n-                } else {\n-                    Ty::Bound(idx)\n+    pub fn decanonicalize_ty(&self, mut ty: Ty) -> Ty {\n+        ty.walk_mut_binders(\n+            &mut |ty, binders| match ty {\n+                &mut Ty::Bound(idx) => {\n+                    if idx as usize >= binders && (idx as usize - binders) < self.free_vars.len() {\n+                        *ty = Ty::Infer(self.free_vars[idx as usize - binders]);\n+                    }\n                 }\n-            }\n-            ty => ty,\n-        })\n+                _ => {}\n+            },\n+            0,\n+        );\n+        ty\n     }\n \n     pub fn apply_solution("}, {"sha": "d20aeaacf281bc608520f0f14f78224594a8d847", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 23, "deletions": 63, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -5,16 +5,14 @@\n use std::sync::Arc;\n \n use arrayvec::ArrayVec;\n-use hir_def::CrateModuleId;\n use rustc_hash::FxHashMap;\n \n use crate::{\n     db::HirDatabase,\n-    impl_block::{ImplBlock, ImplId},\n     resolve::Resolver,\n     ty::primitive::{FloatBitness, Uncertain},\n     ty::{Ty, TypeCtor},\n-    AssocItem, Crate, Function, Module, Mutability, Name, Trait,\n+    AssocItem, Crate, Function, ImplBlock, Module, Mutability, Name, Trait,\n };\n \n use super::{autoderef, lower, Canonical, InEnvironment, TraitEnvironment, TraitRef};\n@@ -39,65 +37,46 @@ impl TyFingerprint {\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct CrateImplBlocks {\n-    /// To make sense of the CrateModuleIds, we need the source root.\n-    krate: Crate,\n-    impls: FxHashMap<TyFingerprint, Vec<(CrateModuleId, ImplId)>>,\n-    impls_by_trait: FxHashMap<Trait, Vec<(CrateModuleId, ImplId)>>,\n+    impls: FxHashMap<TyFingerprint, Vec<ImplBlock>>,\n+    impls_by_trait: FxHashMap<Trait, Vec<ImplBlock>>,\n }\n \n impl CrateImplBlocks {\n-    pub fn lookup_impl_blocks<'a>(&'a self, ty: &Ty) -> impl Iterator<Item = ImplBlock> + 'a {\n+    pub(crate) fn impls_in_crate_query(\n+        db: &impl HirDatabase,\n+        krate: Crate,\n+    ) -> Arc<CrateImplBlocks> {\n+        let mut crate_impl_blocks =\n+            CrateImplBlocks { impls: FxHashMap::default(), impls_by_trait: FxHashMap::default() };\n+        if let Some(module) = krate.root_module(db) {\n+            crate_impl_blocks.collect_recursive(db, module);\n+        }\n+        Arc::new(crate_impl_blocks)\n+    }\n+    pub fn lookup_impl_blocks(&self, ty: &Ty) -> impl Iterator<Item = ImplBlock> + '_ {\n         let fingerprint = TyFingerprint::for_impl(ty);\n-        fingerprint.and_then(|f| self.impls.get(&f)).into_iter().flat_map(|i| i.iter()).map(\n-            move |(module_id, impl_id)| {\n-                let module = Module::new(self.krate, *module_id);\n-                ImplBlock::from_id(module, *impl_id)\n-            },\n-        )\n+        fingerprint.and_then(|f| self.impls.get(&f)).into_iter().flatten().copied()\n     }\n \n-    pub fn lookup_impl_blocks_for_trait<'a>(\n-        &'a self,\n-        tr: Trait,\n-    ) -> impl Iterator<Item = ImplBlock> + 'a {\n-        self.impls_by_trait.get(&tr).into_iter().flat_map(|i| i.iter()).map(\n-            move |(module_id, impl_id)| {\n-                let module = Module::new(self.krate, *module_id);\n-                ImplBlock::from_id(module, *impl_id)\n-            },\n-        )\n+    pub fn lookup_impl_blocks_for_trait(&self, tr: Trait) -> impl Iterator<Item = ImplBlock> + '_ {\n+        self.impls_by_trait.get(&tr).into_iter().flatten().copied()\n     }\n \n     pub fn all_impls<'a>(&'a self) -> impl Iterator<Item = ImplBlock> + 'a {\n-        self.impls.values().chain(self.impls_by_trait.values()).flat_map(|i| i.iter()).map(\n-            move |(module_id, impl_id)| {\n-                let module = Module::new(self.krate, *module_id);\n-                ImplBlock::from_id(module, *impl_id)\n-            },\n-        )\n+        self.impls.values().chain(self.impls_by_trait.values()).flatten().copied()\n     }\n \n     fn collect_recursive(&mut self, db: &impl HirDatabase, module: Module) {\n-        let module_impl_blocks = db.impls_in_module(module);\n-\n-        for (impl_id, _) in module_impl_blocks.impls.iter() {\n-            let impl_block = ImplBlock::from_id(module_impl_blocks.module, impl_id);\n-\n+        for impl_block in module.impl_blocks(db) {\n             let target_ty = impl_block.target_ty(db);\n \n             if impl_block.target_trait(db).is_some() {\n                 if let Some(tr) = impl_block.target_trait_ref(db) {\n-                    self.impls_by_trait\n-                        .entry(tr.trait_)\n-                        .or_insert_with(Vec::new)\n-                        .push((module.id.module_id, impl_id));\n+                    self.impls_by_trait.entry(tr.trait_).or_default().push(impl_block);\n                 }\n             } else {\n                 if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n-                    self.impls\n-                        .entry(target_ty_fp)\n-                        .or_insert_with(Vec::new)\n-                        .push((module.id.module_id, impl_id));\n+                    self.impls.entry(target_ty_fp).or_default().push(impl_block);\n                 }\n             }\n         }\n@@ -106,21 +85,6 @@ impl CrateImplBlocks {\n             self.collect_recursive(db, child);\n         }\n     }\n-\n-    pub(crate) fn impls_in_crate_query(\n-        db: &impl HirDatabase,\n-        krate: Crate,\n-    ) -> Arc<CrateImplBlocks> {\n-        let mut crate_impl_blocks = CrateImplBlocks {\n-            krate,\n-            impls: FxHashMap::default(),\n-            impls_by_trait: FxHashMap::default(),\n-        };\n-        if let Some(module) = krate.root_module(db) {\n-            crate_impl_blocks.collect_recursive(db, module);\n-        }\n-        Arc::new(crate_impl_blocks)\n-    }\n }\n \n fn def_crates(db: &impl HirDatabase, cur_crate: Crate, ty: &Ty) -> Option<ArrayVec<[Crate; 2]>> {\n@@ -264,14 +228,10 @@ fn iterate_trait_method_candidates<T>(\n     'traits: for t in traits {\n         let data = t.trait_data(db);\n \n-        // FIXME this is a bit of a hack, since Chalk should say the same thing\n-        // anyway, but currently Chalk doesn't implement `dyn/impl Trait` yet\n-        let inherently_implemented = ty.value.inherent_trait() == Some(t);\n-\n         // we'll be lazy about checking whether the type implements the\n         // trait, but if we find out it doesn't, we'll skip the rest of the\n         // iteration\n-        let mut known_implemented = inherently_implemented;\n+        let mut known_implemented = false;\n         for &item in data.items() {\n             if !is_valid_candidate(db, name, mode, item) {\n                 continue;"}, {"sha": "ca16936796b57045170d13f606d5900d7fac8b32", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 58, "deletions": 14, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -1,3 +1,6 @@\n+mod never_type;\n+mod coercion;\n+\n use std::fmt::Write;\n use std::sync::Arc;\n \n@@ -11,17 +14,14 @@ use ra_syntax::{\n use test_utils::covers;\n \n use crate::{\n-    expr::BodySourceMap, test_db::TestDB, ty::display::HirDisplay, ty::InferenceResult,\n+    expr::BodySourceMap, test_db::TestDB, ty::display::HirDisplay, ty::InferenceResult, Source,\n     SourceAnalyzer,\n };\n \n // These tests compare the inference results for all expressions in a file\n // against snapshots of the expected results using insta. Use cargo-insta to\n // update the snapshots.\n \n-mod never_type;\n-mod coercion;\n-\n #[test]\n fn cfg_impl_block() {\n     let (db, pos) = TestDB::with_position(\n@@ -3983,11 +3983,11 @@ fn test(x: impl Trait<u64>, y: &impl Trait<u64>) {\n     [180; 183) 'bar': fn bar() -> impl Trait<u64>\n     [180; 185) 'bar()': impl Trait<u64>\n     [191; 192) 'x': impl Trait<u64>\n-    [191; 198) 'x.foo()': {unknown}\n+    [191; 198) 'x.foo()': u64\n     [204; 205) 'y': &impl Trait<u64>\n-    [204; 211) 'y.foo()': {unknown}\n+    [204; 211) 'y.foo()': u64\n     [217; 218) 'z': impl Trait<u64>\n-    [217; 224) 'z.foo()': {unknown}\n+    [217; 224) 'z.foo()': u64\n     [230; 231) 'x': impl Trait<u64>\n     [230; 238) 'x.foo2()': i64\n     [244; 245) 'y': &impl Trait<u64>\n@@ -4033,11 +4033,11 @@ fn test(x: dyn Trait<u64>, y: &dyn Trait<u64>) {\n     [177; 180) 'bar': fn bar() -> dyn Trait<u64>\n     [177; 182) 'bar()': dyn Trait<u64>\n     [188; 189) 'x': dyn Trait<u64>\n-    [188; 195) 'x.foo()': {unknown}\n+    [188; 195) 'x.foo()': u64\n     [201; 202) 'y': &dyn Trait<u64>\n-    [201; 208) 'y.foo()': {unknown}\n+    [201; 208) 'y.foo()': u64\n     [214; 215) 'z': dyn Trait<u64>\n-    [214; 221) 'z.foo()': {unknown}\n+    [214; 221) 'z.foo()': u64\n     [227; 228) 'x': dyn Trait<u64>\n     [227; 235) 'x.foo2()': i64\n     [241; 242) 'y': &dyn Trait<u64>\n@@ -4184,6 +4184,49 @@ fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n     );\n }\n \n+#[test]\n+fn impl_trait_assoc_binding_projection_bug() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+pub trait Language {\n+    type Kind;\n+}\n+pub enum RustLanguage {}\n+impl Language for RustLanguage {\n+    type Kind = SyntaxKind;\n+}\n+struct SyntaxNode<L> {}\n+fn foo() -> impl Iterator<Item = SyntaxNode<RustLanguage>> {}\n+\n+trait Clone {\n+    fn clone(&self) -> Self;\n+}\n+\n+fn api_walkthrough() {\n+    for node in foo() {\n+        node.clone()<|>;\n+    }\n+}\n+\n+//- /std.rs crate:std\n+#[prelude_import] use iter::*;\n+mod iter {\n+    trait IntoIterator {\n+        type Item;\n+    }\n+    trait Iterator {\n+        type Item;\n+    }\n+    impl<T: Iterator> IntoIterator for T {\n+        type Item = <T as Iterator>::Item;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"{unknown}\", type_at_pos(&db, pos));\n+}\n+\n #[test]\n fn projection_eq_within_chalk() {\n     // std::env::set_var(\"CHALK_DEBUG\", \"1\");\n@@ -4609,7 +4652,8 @@ fn test<T, U>() where T: Trait<U::Item>, U: Trait<T::Item> {\n fn type_at_pos(db: &TestDB, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();\n-    let analyzer = SourceAnalyzer::new(db, pos.file_id, expr.syntax(), Some(pos.offset));\n+    let analyzer =\n+        SourceAnalyzer::new(db, Source::new(pos.file_id.into(), expr.syntax()), Some(pos.offset));\n     let ty = analyzer.type_of(db, &expr).unwrap();\n     ty.display(db).to_string()\n }\n@@ -4674,7 +4718,7 @@ fn infer(content: &str) -> String {\n \n     for node in source_file.syntax().descendants() {\n         if node.kind() == FN_DEF || node.kind() == CONST_DEF || node.kind() == STATIC_DEF {\n-            let analyzer = SourceAnalyzer::new(&db, file_id, &node, None);\n+            let analyzer = SourceAnalyzer::new(&db, Source::new(file_id.into(), &node), None);\n             infer_def(analyzer.inference_result(), analyzer.body_source_map());\n         }\n     }\n@@ -4715,7 +4759,7 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n         let file = db.parse(pos.file_id).ok().unwrap();\n         let node = file.syntax().token_at_offset(pos.offset).right_biased().unwrap().parent();\n         let events = db.log_executed(|| {\n-            SourceAnalyzer::new(&db, pos.file_id, &node, None);\n+            SourceAnalyzer::new(&db, Source::new(pos.file_id.into(), &node), None);\n         });\n         assert!(format!(\"{:?}\", events).contains(\"infer\"))\n     }\n@@ -4735,7 +4779,7 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n         let file = db.parse(pos.file_id).ok().unwrap();\n         let node = file.syntax().token_at_offset(pos.offset).right_biased().unwrap().parent();\n         let events = db.log_executed(|| {\n-            SourceAnalyzer::new(&db, pos.file_id, &node, None);\n+            SourceAnalyzer::new(&db, Source::new(pos.file_id.into(), &node), None);\n         });\n         assert!(!format!(\"{:?}\", events).contains(\"infer\"), \"{:#?}\", events)\n     }"}, {"sha": "45f72543808791b062749e9e29d13254f1b3a4ba", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -8,7 +8,7 @@ use ra_prof::profile;\n use rustc_hash::FxHashSet;\n \n use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n-use crate::{db::HirDatabase, expr::ExprId, Crate, DefWithBody, ImplBlock, Trait};\n+use crate::{db::HirDatabase, expr::ExprId, Crate, DefWithBody, ImplBlock, Trait, TypeAlias};\n \n use self::chalk::{from_chalk, ToChalk};\n \n@@ -17,7 +17,7 @@ pub(crate) mod chalk;\n #[derive(Debug, Clone)]\n pub struct TraitSolver {\n     krate: Crate,\n-    inner: Arc<Mutex<chalk_solve::Solver>>,\n+    inner: Arc<Mutex<chalk_solve::Solver<ChalkIr>>>,\n }\n \n /// We need eq for salsa\n@@ -34,7 +34,7 @@ impl TraitSolver {\n         &self,\n         db: &impl HirDatabase,\n         goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal<ChalkIr>>>,\n-    ) -> Option<chalk_solve::Solution> {\n+    ) -> Option<chalk_solve::Solution<ChalkIr>> {\n         let context = ChalkContext { db, krate: self.krate };\n         debug!(\"solve goal: {:?}\", goal);\n         let mut solver = match self.inner.lock() {\n@@ -165,9 +165,9 @@ impl TypeWalk for ProjectionPredicate {\n         self.ty.walk(f);\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        self.projection_ty.walk_mut(f);\n-        self.ty.walk_mut(f);\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        self.projection_ty.walk_mut_binders(f, binders);\n+        self.ty.walk_mut_binders(f, binders);\n     }\n }\n \n@@ -188,14 +188,18 @@ pub(crate) fn trait_solve_query(\n     }\n \n     let canonical = goal.to_chalk(db).cast();\n+\n     // We currently don't deal with universes (I think / hope they're not yet\n     // relevant for our use cases?)\n     let u_canonical = chalk_ir::UCanonical { canonical, universes: 1 };\n     let solution = db.trait_solver(krate).solve(db, &u_canonical);\n     solution.map(|solution| solution_from_chalk(db, solution))\n }\n \n-fn solution_from_chalk(db: &impl HirDatabase, solution: chalk_solve::Solution) -> Solution {\n+fn solution_from_chalk(\n+    db: &impl HirDatabase,\n+    solution: chalk_solve::Solution<ChalkIr>,\n+) -> Solution {\n     let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution<ChalkIr>>| {\n         let value = subst\n             .value\n@@ -300,3 +304,14 @@ pub enum Impl {\n     /// Closure types implement the Fn traits synthetically.\n     ClosureFnTraitImpl(ClosureFnTraitImplData),\n }\n+\n+/// An associated type value. Usually this comes from a `type` declaration\n+/// inside an impl block, but for built-in impls we have to synthesize it.\n+/// (We only need this because Chalk wants a unique ID for each of these.)\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum AssocTyValue {\n+    /// A normal assoc type value from an impl block.\n+    TypeAlias(TypeAlias),\n+    /// The output type of the Fn trait implementation.\n+    ClosureFnTraitImplOutput(ClosureFnTraitImplData),\n+}"}, {"sha": "9bf93981a08c3133fed5f0e0b06f8b23881b84d2", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 202, "deletions": 123, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -7,22 +7,19 @@ use chalk_ir::{\n     cast::Cast, family::ChalkIr, Identifier, ImplId, Parameter, PlaceholderIndex, TypeId,\n     TypeKindId, TypeName, UniverseIndex,\n };\n-use chalk_rust_ir::{AssociatedTyDatum, ImplDatum, StructDatum, TraitDatum};\n+use chalk_rust_ir::{AssociatedTyDatum, AssociatedTyValue, ImplDatum, StructDatum, TraitDatum};\n \n use hir_expand::name;\n \n use ra_db::salsa::{InternId, InternKey};\n \n-use super::{Canonical, ChalkContext, Impl, Obligation};\n+use super::{AssocTyValue, Canonical, ChalkContext, Impl, Obligation};\n use crate::{\n     db::HirDatabase,\n     generics::{GenericDef, HasGenericParams},\n     ty::display::HirDisplay,\n-    ty::{\n-        ApplicationTy, GenericPredicate, Namespace, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n-        TypeWalk,\n-    },\n-    AssocItem, Crate, HasBody, ImplBlock, Trait, TypeAlias,\n+    ty::{ApplicationTy, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk},\n+    Crate, HasBody, ImplBlock, Trait, TypeAlias,\n };\n \n /// This represents a trait whose name we could not resolve.\n@@ -59,29 +56,36 @@ impl ToChalk for Ty {\n                     }\n                 };\n                 let parameters = apply_ty.parameters.to_chalk(db);\n-                chalk_ir::ApplicationTy { name, parameters }.cast()\n+                chalk_ir::ApplicationTy { name, parameters }.cast().intern()\n             }\n             Ty::Projection(proj_ty) => {\n                 let associated_ty_id = proj_ty.associated_ty.to_chalk(db);\n                 let parameters = proj_ty.parameters.to_chalk(db);\n-                chalk_ir::ProjectionTy { associated_ty_id, parameters }.cast()\n+                chalk_ir::ProjectionTy { associated_ty_id, parameters }.cast().intern()\n             }\n             Ty::Param { idx, .. } => {\n                 PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }.to_ty::<ChalkIr>()\n             }\n-            Ty::Bound(idx) => chalk_ir::Ty::BoundVar(idx as usize),\n+            Ty::Bound(idx) => chalk_ir::TyData::BoundVar(idx as usize).intern(),\n             Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n-            // FIXME use Chalk's Dyn/Opaque once the bugs with that are fixed\n-            Ty::Unknown | Ty::Dyn(_) | Ty::Opaque(_) => {\n+            Ty::Dyn(predicates) => {\n+                let where_clauses = predicates.iter().cloned().map(|p| p.to_chalk(db)).collect();\n+                chalk_ir::TyData::Dyn(make_binders(where_clauses, 1)).intern()\n+            }\n+            Ty::Opaque(predicates) => {\n+                let where_clauses = predicates.iter().cloned().map(|p| p.to_chalk(db)).collect();\n+                chalk_ir::TyData::Opaque(make_binders(where_clauses, 1)).intern()\n+            }\n+            Ty::Unknown => {\n                 let parameters = Vec::new();\n                 let name = TypeName::Error;\n-                chalk_ir::ApplicationTy { name, parameters }.cast()\n+                chalk_ir::ApplicationTy { name, parameters }.cast().intern()\n             }\n         }\n     }\n     fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty<ChalkIr>) -> Self {\n-        match chalk {\n-            chalk_ir::Ty::Apply(apply_ty) => {\n+        match chalk.data().clone() {\n+            chalk_ir::TyData::Apply(apply_ty) => {\n                 // FIXME this is kind of hacky due to the fact that\n                 // TypeName::Placeholder is a Ty::Param on our side\n                 match apply_ty.name {\n@@ -104,21 +108,21 @@ impl ToChalk for Ty {\n                     }\n                 }\n             }\n-            chalk_ir::Ty::Projection(proj) => {\n+            chalk_ir::TyData::Projection(proj) => {\n                 let associated_ty = from_chalk(db, proj.associated_ty_id);\n                 let parameters = from_chalk(db, proj.parameters);\n                 Ty::Projection(ProjectionTy { associated_ty, parameters })\n             }\n-            chalk_ir::Ty::ForAll(_) => unimplemented!(),\n-            chalk_ir::Ty::BoundVar(idx) => Ty::Bound(idx as u32),\n-            chalk_ir::Ty::InferenceVar(_iv) => Ty::Unknown,\n-            chalk_ir::Ty::Dyn(where_clauses) => {\n+            chalk_ir::TyData::ForAll(_) => unimplemented!(),\n+            chalk_ir::TyData::BoundVar(idx) => Ty::Bound(idx as u32),\n+            chalk_ir::TyData::InferenceVar(_iv) => Ty::Unknown,\n+            chalk_ir::TyData::Dyn(where_clauses) => {\n                 assert_eq!(where_clauses.binders.len(), 1);\n                 let predicates =\n                     where_clauses.value.into_iter().map(|c| from_chalk(db, c)).collect();\n                 Ty::Dyn(predicates)\n             }\n-            chalk_ir::Ty::Opaque(where_clauses) => {\n+            chalk_ir::TyData::Opaque(where_clauses) => {\n                 assert_eq!(where_clauses.binders.len(), 1);\n                 let predicates =\n                     where_clauses.value.into_iter().map(|c| from_chalk(db, c)).collect();\n@@ -191,11 +195,11 @@ impl ToChalk for Impl {\n     type Chalk = chalk_ir::ImplId;\n \n     fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::ImplId {\n-        db.intern_impl(self).into()\n+        db.intern_chalk_impl(self).into()\n     }\n \n     fn from_chalk(db: &impl HirDatabase, impl_id: chalk_ir::ImplId) -> Impl {\n-        db.lookup_intern_impl(impl_id.into())\n+        db.lookup_intern_chalk_impl(impl_id.into())\n     }\n }\n \n@@ -211,6 +215,21 @@ impl ToChalk for TypeAlias {\n     }\n }\n \n+impl ToChalk for AssocTyValue {\n+    type Chalk = chalk_rust_ir::AssociatedTyValueId;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_rust_ir::AssociatedTyValueId {\n+        db.intern_assoc_ty_value(self).into()\n+    }\n+\n+    fn from_chalk(\n+        db: &impl HirDatabase,\n+        assoc_ty_value_id: chalk_rust_ir::AssociatedTyValueId,\n+    ) -> AssocTyValue {\n+        db.lookup_intern_assoc_ty_value(assoc_ty_value_id.into())\n+    }\n+}\n+\n impl ToChalk for GenericPredicate {\n     type Chalk = chalk_ir::QuantifiedWhereClause<ChalkIr>;\n \n@@ -399,20 +418,20 @@ fn convert_where_clauses(\n     result\n }\n \n-impl<'a, DB> chalk_solve::RustIrDatabase for ChalkContext<'a, DB>\n+impl<'a, DB> chalk_solve::RustIrDatabase<ChalkIr> for ChalkContext<'a, DB>\n where\n     DB: HirDatabase,\n {\n-    fn associated_ty_data(&self, id: TypeId) -> Arc<AssociatedTyDatum> {\n+    fn associated_ty_data(&self, id: TypeId) -> Arc<AssociatedTyDatum<ChalkIr>> {\n         self.db.associated_ty_data(id)\n     }\n-    fn trait_datum(&self, trait_id: chalk_ir::TraitId) -> Arc<TraitDatum> {\n+    fn trait_datum(&self, trait_id: chalk_ir::TraitId) -> Arc<TraitDatum<ChalkIr>> {\n         self.db.trait_datum(self.krate, trait_id)\n     }\n-    fn struct_datum(&self, struct_id: chalk_ir::StructId) -> Arc<StructDatum> {\n+    fn struct_datum(&self, struct_id: chalk_ir::StructId) -> Arc<StructDatum<ChalkIr>> {\n         self.db.struct_datum(self.krate, struct_id)\n     }\n-    fn impl_datum(&self, impl_id: ImplId) -> Arc<ImplDatum> {\n+    fn impl_datum(&self, impl_id: ImplId) -> Arc<ImplDatum<ChalkIr>> {\n         self.db.impl_datum(self.krate, impl_id)\n     }\n     fn impls_for_trait(\n@@ -462,13 +481,11 @@ where\n     fn type_name(&self, _id: TypeKindId) -> Identifier {\n         unimplemented!()\n     }\n-    fn split_projection<'p>(\n+    fn associated_ty_value(\n         &self,\n-        projection: &'p chalk_ir::ProjectionTy<ChalkIr>,\n-    ) -> (Arc<AssociatedTyDatum>, &'p [Parameter<ChalkIr>], &'p [Parameter<ChalkIr>]) {\n-        debug!(\"split_projection {:?}\", projection);\n-        // we don't support GATs, so I think this should always be correct currently\n-        (self.db.associated_ty_data(projection.associated_ty_id), &projection.parameters, &[])\n+        id: chalk_rust_ir::AssociatedTyValueId,\n+    ) -> Arc<AssociatedTyValue<ChalkIr>> {\n+        self.db.associated_ty_value(self.krate, id)\n     }\n     fn custom_clauses(&self) -> Vec<chalk_ir::ProgramClause<ChalkIr>> {\n         vec![]\n@@ -485,27 +502,24 @@ where\n pub(crate) fn associated_ty_data_query(\n     db: &impl HirDatabase,\n     id: TypeId,\n-) -> Arc<AssociatedTyDatum> {\n+) -> Arc<AssociatedTyDatum<ChalkIr>> {\n     debug!(\"associated_ty_data {:?}\", id);\n     let type_alias: TypeAlias = from_chalk(db, id);\n     let trait_ = match type_alias.container(db) {\n         Some(crate::Container::Trait(t)) => t,\n         _ => panic!(\"associated type not in trait\"),\n     };\n     let generic_params = type_alias.generic_params(db);\n-    let parameter_kinds = generic_params\n-        .params_including_parent()\n-        .into_iter()\n-        .map(|p| chalk_ir::ParameterKind::Ty(lalrpop_intern::intern(&p.name.to_string())))\n-        .collect();\n+    let bound_data = chalk_rust_ir::AssociatedTyDatumBound {\n+        // FIXME add bounds and where clauses\n+        bounds: vec![],\n+        where_clauses: vec![],\n+    };\n     let datum = AssociatedTyDatum {\n         trait_id: trait_.to_chalk(db),\n         id,\n         name: lalrpop_intern::intern(&type_alias.name(db).to_string()),\n-        parameter_kinds,\n-        // FIXME add bounds and where clauses\n-        bounds: vec![],\n-        where_clauses: vec![],\n+        binders: make_binders(bound_data, generic_params.count_params_including_parent()),\n     };\n     Arc::new(datum)\n }\n@@ -514,36 +528,35 @@ pub(crate) fn trait_datum_query(\n     db: &impl HirDatabase,\n     krate: Crate,\n     trait_id: chalk_ir::TraitId,\n-) -> Arc<TraitDatum> {\n+) -> Arc<TraitDatum<ChalkIr>> {\n     debug!(\"trait_datum {:?}\", trait_id);\n     if trait_id == UNKNOWN_TRAIT {\n-        let trait_datum_bound = chalk_rust_ir::TraitDatumBound {\n-            trait_ref: chalk_ir::TraitRef {\n-                trait_id: UNKNOWN_TRAIT,\n-                parameters: vec![chalk_ir::Ty::BoundVar(0).cast()],\n-            },\n-            associated_ty_ids: Vec::new(),\n-            where_clauses: Vec::new(),\n-        };\n+        let trait_datum_bound = chalk_rust_ir::TraitDatumBound { where_clauses: Vec::new() };\n \n         let flags = chalk_rust_ir::TraitFlags {\n             auto: false,\n             marker: false,\n             upstream: true,\n             fundamental: false,\n             non_enumerable: true,\n+            coinductive: false,\n         };\n-        return Arc::new(TraitDatum { binders: make_binders(trait_datum_bound, 1), flags });\n+        return Arc::new(TraitDatum {\n+            id: trait_id,\n+            binders: make_binders(trait_datum_bound, 1),\n+            flags,\n+            associated_ty_ids: vec![],\n+        });\n     }\n     let trait_: Trait = from_chalk(db, trait_id);\n     debug!(\"trait {:?} = {:?}\", trait_id, trait_.name(db));\n     let generic_params = trait_.generic_params(db);\n     let bound_vars = Substs::bound_vars(&generic_params);\n-    let trait_ref = trait_.trait_ref(db).subst(&bound_vars).to_chalk(db);\n     let flags = chalk_rust_ir::TraitFlags {\n         auto: trait_.is_auto(db),\n         upstream: trait_.module(db).krate() != krate,\n         non_enumerable: true,\n+        coinductive: false, // only relevant for Chalk testing\n         // FIXME set these flags correctly\n         marker: false,\n         fundamental: false,\n@@ -558,18 +571,21 @@ pub(crate) fn trait_datum_query(\n         })\n         .map(|type_alias| type_alias.to_chalk(db))\n         .collect();\n-    let trait_datum_bound =\n-        chalk_rust_ir::TraitDatumBound { trait_ref, where_clauses, associated_ty_ids };\n-    let trait_datum =\n-        TraitDatum { binders: make_binders(trait_datum_bound, bound_vars.len()), flags };\n+    let trait_datum_bound = chalk_rust_ir::TraitDatumBound { where_clauses };\n+    let trait_datum = TraitDatum {\n+        id: trait_id,\n+        binders: make_binders(trait_datum_bound, bound_vars.len()),\n+        flags,\n+        associated_ty_ids,\n+    };\n     Arc::new(trait_datum)\n }\n \n pub(crate) fn struct_datum_query(\n     db: &impl HirDatabase,\n     krate: Crate,\n     struct_id: chalk_ir::StructId,\n-) -> Arc<StructDatum> {\n+) -> Arc<StructDatum<ChalkIr>> {\n     debug!(\"struct_datum {:?}\", struct_id);\n     let type_ctor: TypeCtor = from_chalk(db, struct_id);\n     debug!(\"struct {:?} = {:?}\", struct_id, type_ctor);\n@@ -588,49 +604,41 @@ pub(crate) fn struct_datum_query(\n         // FIXME set fundamental flag correctly\n         fundamental: false,\n     };\n-    let self_ty = chalk_ir::ApplicationTy {\n-        name: TypeName::TypeKindId(type_ctor.to_chalk(db).into()),\n-        parameters: (0..num_params).map(|i| chalk_ir::Ty::BoundVar(i).cast()).collect(),\n-    };\n     let struct_datum_bound = chalk_rust_ir::StructDatumBound {\n-        self_ty,\n         fields: Vec::new(), // FIXME add fields (only relevant for auto traits)\n         where_clauses,\n-        flags,\n     };\n-    let struct_datum = StructDatum { binders: make_binders(struct_datum_bound, num_params) };\n+    let struct_datum =\n+        StructDatum { id: struct_id, binders: make_binders(struct_datum_bound, num_params), flags };\n     Arc::new(struct_datum)\n }\n \n pub(crate) fn impl_datum_query(\n     db: &impl HirDatabase,\n     krate: Crate,\n     impl_id: ImplId,\n-) -> Arc<ImplDatum> {\n+) -> Arc<ImplDatum<ChalkIr>> {\n     let _p = ra_prof::profile(\"impl_datum\");\n     debug!(\"impl_datum {:?}\", impl_id);\n     let impl_: Impl = from_chalk(db, impl_id);\n     match impl_ {\n         Impl::ImplBlock(impl_block) => impl_block_datum(db, krate, impl_id, impl_block),\n-        Impl::ClosureFnTraitImpl(data) => {\n-            closure_fn_trait_impl_datum(db, krate, impl_id, data).unwrap_or_else(invalid_impl_datum)\n-        }\n+        Impl::ClosureFnTraitImpl(data) => closure_fn_trait_impl_datum(db, krate, data),\n     }\n+    .unwrap_or_else(invalid_impl_datum)\n }\n \n fn impl_block_datum(\n     db: &impl HirDatabase,\n     krate: Crate,\n     impl_id: ImplId,\n     impl_block: ImplBlock,\n-) -> Arc<ImplDatum> {\n+) -> Option<Arc<ImplDatum<ChalkIr>>> {\n     let generic_params = impl_block.generic_params(db);\n     let bound_vars = Substs::bound_vars(&generic_params);\n-    let trait_ref = impl_block\n-        .target_trait_ref(db)\n-        .expect(\"FIXME handle unresolved impl block trait ref\")\n-        .subst(&bound_vars);\n-    let impl_type = if impl_block.module().krate() == krate {\n+    let trait_ref = impl_block.target_trait_ref(db)?.subst(&bound_vars);\n+    let trait_ = trait_ref.trait_;\n+    let impl_type = if impl_block.krate(db) == krate {\n         chalk_rust_ir::ImplType::Local\n     } else {\n         chalk_rust_ir::ImplType::External\n@@ -644,76 +652,69 @@ fn impl_block_datum(\n         trait_ref.display(db),\n         where_clauses\n     );\n-    let trait_ = trait_ref.trait_;\n     let trait_ref = trait_ref.to_chalk(db);\n-    let associated_ty_values = impl_block\n-        .items(db)\n-        .into_iter()\n-        .filter_map(|item| match item {\n-            AssocItem::TypeAlias(t) => Some(t),\n-            _ => None,\n-        })\n-        .filter_map(|t| {\n-            let assoc_ty = trait_.associated_type_by_name(db, &t.name(db))?;\n-            let ty = db.type_for_def(t.into(), Namespace::Types).subst(&bound_vars);\n-            Some(chalk_rust_ir::AssociatedTyValue {\n-                impl_id,\n-                associated_ty_id: assoc_ty.to_chalk(db),\n-                value: chalk_ir::Binders {\n-                    value: chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) },\n-                    binders: vec![], // we don't support GATs yet\n-                },\n-            })\n-        })\n-        .collect();\n \n     let polarity = if negative {\n         chalk_rust_ir::Polarity::Negative\n     } else {\n         chalk_rust_ir::Polarity::Positive\n     };\n \n-    let impl_datum_bound =\n-        chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses, associated_ty_values };\n+    let impl_datum_bound = chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses };\n+    let associated_ty_value_ids = impl_block\n+        .items(db)\n+        .into_iter()\n+        .filter_map(|item| match item {\n+            crate::AssocItem::TypeAlias(type_alias) => Some(type_alias),\n+            _ => None,\n+        })\n+        .filter(|type_alias| {\n+            // don't include associated types that don't exist in the trait\n+            trait_.associated_type_by_name(db, &type_alias.name(db)).is_some()\n+        })\n+        .map(|type_alias| AssocTyValue::TypeAlias(type_alias).to_chalk(db))\n+        .collect();\n     debug!(\"impl_datum: {:?}\", impl_datum_bound);\n     let impl_datum = ImplDatum {\n         binders: make_binders(impl_datum_bound, bound_vars.len()),\n         impl_type,\n         polarity,\n+        associated_ty_value_ids,\n     };\n-    Arc::new(impl_datum)\n+    Some(Arc::new(impl_datum))\n }\n \n-fn invalid_impl_datum() -> Arc<ImplDatum> {\n+fn invalid_impl_datum() -> Arc<ImplDatum<ChalkIr>> {\n     let trait_ref = chalk_ir::TraitRef {\n         trait_id: UNKNOWN_TRAIT,\n-        parameters: vec![chalk_ir::Ty::BoundVar(0).cast()],\n-    };\n-    let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n-        trait_ref,\n-        where_clauses: Vec::new(),\n-        associated_ty_values: Vec::new(),\n+        parameters: vec![chalk_ir::TyData::BoundVar(0).cast().intern().cast()],\n     };\n+    let impl_datum_bound = chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses: Vec::new() };\n     let impl_datum = ImplDatum {\n         binders: make_binders(impl_datum_bound, 1),\n         impl_type: chalk_rust_ir::ImplType::External,\n         polarity: chalk_rust_ir::Polarity::Positive,\n+        associated_ty_value_ids: Vec::new(),\n     };\n     Arc::new(impl_datum)\n }\n \n fn closure_fn_trait_impl_datum(\n     db: &impl HirDatabase,\n     krate: Crate,\n-    impl_id: ImplId,\n     data: super::ClosureFnTraitImplData,\n-) -> Option<Arc<ImplDatum>> {\n+) -> Option<Arc<ImplDatum<ChalkIr>>> {\n     // for some closure |X, Y| -> Z:\n     // impl<T, U, V> Fn<(T, U)> for closure<fn(T, U) -> V> { Output = V }\n \n-    let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n     let trait_ = get_fn_trait(db, krate, data.fn_trait)?; // get corresponding fn trait\n \n+    // validate FnOnce trait, since we need it in the assoc ty value definition\n+    // and don't want to return a valid value only to find out later that FnOnce\n+    // is broken\n+    let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n+    fn_once_trait.associated_type_by_name(db, &name::OUTPUT_TYPE)?;\n+\n     let num_args: u16 = match &data.def.body(db)[data.expr] {\n         crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n         _ => {\n@@ -726,7 +727,6 @@ fn closure_fn_trait_impl_datum(\n         TypeCtor::Tuple { cardinality: num_args },\n         Substs::builder(num_args as usize).fill_with_bound_vars(0).build(),\n     );\n-    let output_ty = Ty::Bound(num_args.into());\n     let sig_ty = Ty::apply(\n         TypeCtor::FnPtr { num_args },\n         Substs::builder(num_args as usize + 1).fill_with_bound_vars(0).build(),\n@@ -739,32 +739,99 @@ fn closure_fn_trait_impl_datum(\n         substs: Substs::build_for_def(db, trait_).push(self_ty).push(arg_ty).build(),\n     };\n \n-    let output_ty_id = fn_once_trait.associated_type_by_name(db, &name::OUTPUT_TYPE)?;\n-\n-    let output_ty_value = chalk_rust_ir::AssociatedTyValue {\n-        associated_ty_id: output_ty_id.to_chalk(db),\n-        impl_id,\n-        value: make_binders(\n-            chalk_rust_ir::AssociatedTyValueBound { ty: output_ty.to_chalk(db) },\n-            0,\n-        ),\n-    };\n+    let output_ty_id = AssocTyValue::ClosureFnTraitImplOutput(data.clone()).to_chalk(db);\n \n     let impl_type = chalk_rust_ir::ImplType::External;\n \n     let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n         trait_ref: trait_ref.to_chalk(db),\n         where_clauses: Vec::new(),\n-        associated_ty_values: vec![output_ty_value],\n     };\n     let impl_datum = ImplDatum {\n         binders: make_binders(impl_datum_bound, num_args as usize + 1),\n         impl_type,\n         polarity: chalk_rust_ir::Polarity::Positive,\n+        associated_ty_value_ids: vec![output_ty_id],\n     };\n     Some(Arc::new(impl_datum))\n }\n \n+pub(crate) fn associated_ty_value_query(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    id: chalk_rust_ir::AssociatedTyValueId,\n+) -> Arc<chalk_rust_ir::AssociatedTyValue<ChalkIr>> {\n+    let data: AssocTyValue = from_chalk(db, id);\n+    match data {\n+        AssocTyValue::TypeAlias(type_alias) => {\n+            type_alias_associated_ty_value(db, krate, type_alias)\n+        }\n+        AssocTyValue::ClosureFnTraitImplOutput(data) => {\n+            closure_fn_trait_output_assoc_ty_value(db, krate, data)\n+        }\n+    }\n+}\n+\n+fn type_alias_associated_ty_value(\n+    db: &impl HirDatabase,\n+    _krate: Crate,\n+    type_alias: TypeAlias,\n+) -> Arc<AssociatedTyValue<ChalkIr>> {\n+    let impl_block = type_alias.impl_block(db).expect(\"assoc ty value should be in impl\");\n+    let impl_id = Impl::ImplBlock(impl_block).to_chalk(db);\n+    let trait_ = impl_block\n+        .target_trait_ref(db)\n+        .expect(\"assoc ty value should not exist\") // we don't return any assoc ty values if the impl'd trait can't be resolved\n+        .trait_;\n+    let assoc_ty = trait_\n+        .associated_type_by_name(db, &type_alias.name(db))\n+        .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n+    let generic_params = impl_block.generic_params(db);\n+    let bound_vars = Substs::bound_vars(&generic_params);\n+    let ty = db.type_for_def(type_alias.into(), crate::ty::Namespace::Types).subst(&bound_vars);\n+    let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) };\n+    let value = chalk_rust_ir::AssociatedTyValue {\n+        impl_id,\n+        associated_ty_id: assoc_ty.to_chalk(db),\n+        value: make_binders(value_bound, bound_vars.len()),\n+    };\n+    Arc::new(value)\n+}\n+\n+fn closure_fn_trait_output_assoc_ty_value(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    data: super::ClosureFnTraitImplData,\n+) -> Arc<AssociatedTyValue<ChalkIr>> {\n+    let impl_id = Impl::ClosureFnTraitImpl(data.clone()).to_chalk(db);\n+\n+    let num_args: u16 = match &data.def.body(db)[data.expr] {\n+        crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n+        _ => {\n+            log::warn!(\"closure for closure type {:?} not found\", data);\n+            0\n+        }\n+    };\n+\n+    let output_ty = Ty::Bound(num_args.into());\n+\n+    let fn_once_trait =\n+        get_fn_trait(db, krate, super::FnTrait::FnOnce).expect(\"assoc ty value should not exist\");\n+\n+    let output_ty_id = fn_once_trait\n+        .associated_type_by_name(db, &name::OUTPUT_TYPE)\n+        .expect(\"assoc ty value should not exist\");\n+\n+    let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: output_ty.to_chalk(db) };\n+\n+    let value = chalk_rust_ir::AssociatedTyValue {\n+        associated_ty_id: output_ty_id.to_chalk(db),\n+        impl_id,\n+        value: make_binders(value_bound, num_args as usize + 1),\n+    };\n+    Arc::new(value)\n+}\n+\n fn get_fn_trait(db: &impl HirDatabase, krate: Crate, fn_trait: super::FnTrait) -> Option<Trait> {\n     let target = db.lang_item(krate, fn_trait.lang_item_name().into())?;\n     match target {\n@@ -803,3 +870,15 @@ impl From<crate::ids::GlobalImplId> for chalk_ir::ImplId {\n         chalk_ir::ImplId(id_to_chalk(impl_id))\n     }\n }\n+\n+impl From<chalk_rust_ir::AssociatedTyValueId> for crate::ids::AssocTyValueId {\n+    fn from(id: chalk_rust_ir::AssociatedTyValueId) -> Self {\n+        id_from_chalk(id.0)\n+    }\n+}\n+\n+impl From<crate::ids::AssocTyValueId> for chalk_rust_ir::AssociatedTyValueId {\n+    fn from(assoc_ty_value_id: crate::ids::AssocTyValueId) -> Self {\n+        chalk_rust_ir::AssociatedTyValueId(id_to_chalk(assoc_ty_value_id))\n+    }\n+}"}, {"sha": "7e65f4c1d54005329d9fd41856ad7c23a0e5cddf", "filename": "crates/ra_hir_def/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -4,6 +4,9 @@ name = \"ra_hir_def\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n log = \"0.4.5\"\n once_cell = \"1.0.1\""}, {"sha": "348aca07f13d008ab671b5611b07ae952a713d38", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -8,30 +8,32 @@ use ra_syntax::ast;\n use crate::{\n     adt::{EnumData, StructData},\n     body::{scope::ExprScopes, Body, BodySourceMap},\n+    imp::ImplData,\n     nameres::{\n         raw::{ImportSourceMap, RawItems},\n         CrateDefMap,\n     },\n-    DefWithBodyId, EnumId, StructOrUnionId,\n+    DefWithBodyId, EnumId, ImplId, ItemLoc, StructOrUnionId,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n pub trait InternDatabase: SourceDatabase {\n     #[salsa::interned]\n-    fn intern_function(&self, loc: crate::ItemLoc<ast::FnDef>) -> crate::FunctionId;\n+    fn intern_function(&self, loc: ItemLoc<ast::FnDef>) -> crate::FunctionId;\n     #[salsa::interned]\n-    fn intern_struct_or_union(&self, loc: crate::ItemLoc<ast::StructDef>)\n-        -> crate::StructOrUnionId;\n+    fn intern_struct_or_union(&self, loc: ItemLoc<ast::StructDef>) -> crate::StructOrUnionId;\n     #[salsa::interned]\n-    fn intern_enum(&self, loc: crate::ItemLoc<ast::EnumDef>) -> crate::EnumId;\n+    fn intern_enum(&self, loc: ItemLoc<ast::EnumDef>) -> crate::EnumId;\n     #[salsa::interned]\n-    fn intern_const(&self, loc: crate::ItemLoc<ast::ConstDef>) -> crate::ConstId;\n+    fn intern_const(&self, loc: ItemLoc<ast::ConstDef>) -> crate::ConstId;\n     #[salsa::interned]\n-    fn intern_static(&self, loc: crate::ItemLoc<ast::StaticDef>) -> crate::StaticId;\n+    fn intern_static(&self, loc: ItemLoc<ast::StaticDef>) -> crate::StaticId;\n     #[salsa::interned]\n-    fn intern_trait(&self, loc: crate::ItemLoc<ast::TraitDef>) -> crate::TraitId;\n+    fn intern_trait(&self, loc: ItemLoc<ast::TraitDef>) -> crate::TraitId;\n     #[salsa::interned]\n-    fn intern_type_alias(&self, loc: crate::ItemLoc<ast::TypeAliasDef>) -> crate::TypeAliasId;\n+    fn intern_type_alias(&self, loc: ItemLoc<ast::TypeAliasDef>) -> crate::TypeAliasId;\n+    #[salsa::interned]\n+    fn intern_impl(&self, loc: ItemLoc<ast::ImplBlock>) -> crate::ImplId;\n }\n \n #[salsa::query_group(DefDatabase2Storage)]\n@@ -54,6 +56,9 @@ pub trait DefDatabase2: InternDatabase + AstDatabase {\n     #[salsa::invoke(EnumData::enum_data_query)]\n     fn enum_data(&self, e: EnumId) -> Arc<EnumData>;\n \n+    #[salsa::invoke(ImplData::impl_data_query)]\n+    fn impl_data(&self, e: ImplId) -> Arc<ImplData>;\n+\n     #[salsa::invoke(Body::body_with_source_map_query)]\n     fn body_with_source_map(&self, def: DefWithBodyId) -> (Arc<Body>, Arc<BodySourceMap>);\n "}, {"sha": "717991c405fac6dd683946c67f5eadecc792ac39", "filename": "crates/ra_hir_def/src/imp.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_def%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_def%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fimp.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -0,0 +1,71 @@\n+//! Defines hir-level representation of impls.\n+//!\n+//! The handling is similar, but is not quite the same as for other items,\n+//! because `impl`s don't have names.\n+\n+use std::sync::Arc;\n+\n+use ra_syntax::ast;\n+\n+use crate::{\n+    db::DefDatabase2, type_ref::TypeRef, AssocItemId, AstItemDef, ConstId, FunctionId, ImplId,\n+    LocationCtx, TypeAliasId,\n+};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ImplData {\n+    target_trait: Option<TypeRef>,\n+    target_type: TypeRef,\n+    items: Vec<AssocItemId>,\n+    negative: bool,\n+}\n+\n+impl ImplData {\n+    pub(crate) fn impl_data_query(db: &impl DefDatabase2, id: ImplId) -> Arc<ImplData> {\n+        let src = id.source(db);\n+        let items = db.ast_id_map(src.file_id);\n+\n+        let target_trait = src.ast.target_trait().map(TypeRef::from_ast);\n+        let target_type = TypeRef::from_ast_opt(src.ast.target_type());\n+        let negative = src.ast.is_negative();\n+\n+        let items = if let Some(item_list) = src.ast.item_list() {\n+            let ctx = LocationCtx::new(db, id.module(db), src.file_id);\n+            item_list\n+                .impl_items()\n+                .map(|item_node| match item_node {\n+                    ast::ImplItem::FnDef(it) => {\n+                        FunctionId::from_ast_id(ctx, items.ast_id(&it)).into()\n+                    }\n+                    ast::ImplItem::ConstDef(it) => {\n+                        ConstId::from_ast_id(ctx, items.ast_id(&it)).into()\n+                    }\n+                    ast::ImplItem::TypeAliasDef(it) => {\n+                        TypeAliasId::from_ast_id(ctx, items.ast_id(&it)).into()\n+                    }\n+                })\n+                .collect()\n+        } else {\n+            Vec::new()\n+        };\n+\n+        let res = ImplData { target_trait, target_type, items, negative };\n+        Arc::new(res)\n+    }\n+\n+    pub fn target_trait(&self) -> Option<&TypeRef> {\n+        self.target_trait.as_ref()\n+    }\n+\n+    pub fn target_type(&self) -> &TypeRef {\n+        &self.target_type\n+    }\n+\n+    pub fn items(&self) -> &[AssocItemId] {\n+        &self.items\n+    }\n+\n+    pub fn is_negative(&self) -> bool {\n+        self.negative\n+    }\n+}"}, {"sha": "a240a10b82662d26f14097029b2a9708e827dd83", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -13,6 +13,7 @@ pub mod path;\n pub mod type_ref;\n pub mod builtin_type;\n pub mod adt;\n+pub mod imp;\n pub mod diagnostics;\n pub mod expr;\n pub mod body;\n@@ -77,14 +78,13 @@ impl ModuleSource {\n         }\n     }\n \n-    pub fn from_child_node(\n-        db: &impl db::DefDatabase2,\n-        file_id: FileId,\n-        child: &SyntaxNode,\n-    ) -> ModuleSource {\n-        if let Some(m) = child.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi()) {\n+    pub fn from_child_node(db: &impl db::DefDatabase2, child: Source<&SyntaxNode>) -> ModuleSource {\n+        if let Some(m) =\n+            child.ast.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi())\n+        {\n             ModuleSource::Module(m)\n         } else {\n+            let file_id = child.file_id.original_file(db);\n             let source_file = db.parse(file_id).tree();\n             ModuleSource::SourceFile(source_file)\n         }\n@@ -321,6 +321,18 @@ impl AstItemDef<ast::TypeAliasDef> for TypeAliasId {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ImplId(salsa::InternId);\n+impl_intern_key!(ImplId);\n+impl AstItemDef<ast::ImplBlock> for ImplId {\n+    fn intern(db: &impl InternDatabase, loc: ItemLoc<ast::ImplBlock>) -> Self {\n+        db.intern_impl(loc)\n+    }\n+    fn lookup_intern(self, db: &impl InternDatabase) -> ItemLoc<ast::ImplBlock> {\n+        db.lookup_intern_impl(self)\n+    }\n+}\n+\n macro_rules! impl_froms {\n     ($e:ident: $($v:ident $(($($sv:ident),*))?),*) => {\n         $(\n@@ -384,3 +396,15 @@ pub enum DefWithBodyId {\n }\n \n impl_froms!(DefWithBodyId: FunctionId, ConstId, StaticId);\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub enum AssocItemId {\n+    FunctionId(FunctionId),\n+    ConstId(ConstId),\n+    TypeAliasId(TypeAliasId),\n+}\n+// FIXME: not every function, ... is actually an assoc item. maybe we should make\n+// sure that you can only turn actual assoc items into AssocItemIds. This would\n+// require not implementing From, and instead having some checked way of\n+// casting them, and somehow making the constructors private, which would be annoying.\n+impl_froms!(AssocItemId: FunctionId, ConstId, TypeAliasId);"}, {"sha": "e5b073a0f899c952571a8006e74824d14178c3bc", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -73,7 +73,7 @@ use crate::{\n         diagnostics::DefDiagnostic, path_resolution::ResolveMode, per_ns::PerNs, raw::ImportId,\n     },\n     path::Path,\n-    AstId, CrateModuleId, FunctionId, ModuleDefId, ModuleId, TraitId,\n+    AstId, CrateModuleId, FunctionId, ImplId, ModuleDefId, ModuleId, TraitId,\n };\n \n /// Contains all top-level defs from a macro-expanded crate\n@@ -122,16 +122,17 @@ pub struct ModuleData {\n     ///\n     /// Note that non-inline modules, by definition, live inside non-macro file.\n     pub definition: Option<FileId>,\n+    pub impls: Vec<ImplId>,\n }\n \n-#[derive(Default, Debug, PartialEq, Eq, Clone)]\n+#[derive(Default, Debug, PartialEq, Eq)]\n pub(crate) struct Declarations {\n     fns: FxHashMap<FileAstId<ast::FnDef>, FunctionId>,\n }\n \n-#[derive(Debug, Default, PartialEq, Eq, Clone)]\n+#[derive(Debug, Default, PartialEq, Eq)]\n pub struct ModuleScope {\n-    pub items: FxHashMap<Name, Resolution>,\n+    items: FxHashMap<Name, Resolution>,\n     /// Macros visable in current module in legacy textual scope\n     ///\n     /// For macros invoked by an unquatified identifier like `bar!()`, `legacy_macros` will be searched in first."}, {"sha": "8f426b09775a8cd76a5f9db52b8c64c6ea2ad3bf", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -19,7 +19,7 @@ use crate::{\n         per_ns::PerNs, raw, CrateDefMap, ModuleData, Resolution, ResolveMode,\n     },\n     path::{Path, PathKind},\n-    AdtId, AstId, AstItemDef, ConstId, CrateModuleId, EnumId, EnumVariantId, FunctionId,\n+    AdtId, AstId, AstItemDef, ConstId, CrateModuleId, EnumId, EnumVariantId, FunctionId, ImplId,\n     LocationCtx, ModuleDefId, ModuleId, StaticId, StructId, StructOrUnionId, TraitId, TypeAliasId,\n     UnionId,\n };\n@@ -165,7 +165,7 @@ where\n     /// crate::foo!();\n     /// ```\n     ///\n-    /// Well, this code compiles, bacause the plain path `foo` in `use` is searched\n+    /// Well, this code compiles, because the plain path `foo` in `use` is searched\n     /// in the legacy textual scope only.\n     /// ```rust\n     /// macro_rules! foo { () => {} }\n@@ -571,6 +571,15 @@ where\n                         .push((self.module_id, import_id, self.raw_items[import_id].clone())),\n                     raw::RawItemKind::Def(def) => self.define_def(&self.raw_items[def]),\n                     raw::RawItemKind::Macro(mac) => self.collect_macro(&self.raw_items[mac]),\n+                    raw::RawItemKind::Impl(imp) => {\n+                        let module = ModuleId {\n+                            krate: self.def_collector.def_map.krate,\n+                            module_id: self.module_id,\n+                        };\n+                        let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id);\n+                        let imp_id = ImplId::from_ast_id(ctx, self.raw_items[imp].ast_id);\n+                        self.def_collector.def_map.modules[self.module_id].impls.push(imp_id)\n+                    }\n                 }\n             }\n         }"}, {"sha": "a0a2c7273c6b254a86123886fd4a6e396392f0a0", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -28,6 +28,7 @@ pub struct RawItems {\n     imports: Arena<ImportId, ImportData>,\n     defs: Arena<Def, DefData>,\n     macros: Arena<Macro, MacroData>,\n+    impls: Arena<Impl, ImplData>,\n     /// items for top-level module\n     items: Vec<RawItem>,\n }\n@@ -121,6 +122,13 @@ impl Index<Macro> for RawItems {\n     }\n }\n \n+impl Index<Impl> for RawItems {\n+    type Output = ImplData;\n+    fn index(&self, idx: Impl) -> &ImplData {\n+        &self.impls[idx]\n+    }\n+}\n+\n // Avoid heap allocation on items without attributes.\n type Attrs = Option<Arc<[Attr]>>;\n \n@@ -142,6 +150,7 @@ pub(super) enum RawItemKind {\n     Import(ImportId),\n     Def(Def),\n     Macro(Macro),\n+    Impl(Impl),\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -203,6 +212,15 @@ pub(super) struct MacroData {\n     pub(super) builtin: bool,\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(super) struct Impl(RawId);\n+impl_arena_id!(Impl);\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(super) struct ImplData {\n+    pub(super) ast_id: FileAstId<ast::ImplBlock>,\n+}\n+\n struct RawItemsCollector {\n     raw_items: RawItems,\n     source_ast_id_map: Arc<AstIdMap>,\n@@ -236,8 +254,8 @@ impl RawItemsCollector {\n                 self.add_extern_crate_item(current_module, extern_crate);\n                 return;\n             }\n-            ast::ModuleItem::ImplBlock(_) => {\n-                // impls don't participate in name resolution\n+            ast::ModuleItem::ImplBlock(it) => {\n+                self.add_impl(current_module, it);\n                 return;\n             }\n             ast::ModuleItem::StructDef(it) => {\n@@ -376,6 +394,13 @@ impl RawItemsCollector {\n         self.push_item(current_module, attrs, RawItemKind::Macro(m));\n     }\n \n+    fn add_impl(&mut self, current_module: Option<Module>, imp: ast::ImplBlock) {\n+        let attrs = self.parse_attrs(&imp);\n+        let ast_id = self.source_ast_id_map.ast_id(&imp);\n+        let imp = self.raw_items.impls.alloc(ImplData { ast_id });\n+        self.push_item(current_module, attrs, RawItemKind::Impl(imp))\n+    }\n+\n     fn push_import(\n         &mut self,\n         current_module: Option<Module>,"}, {"sha": "c60152a79984fd4132245ca7f5736f5eaa3aa49c", "filename": "crates/ra_hir_expand/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -4,6 +4,9 @@ name = \"ra_hir_expand\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n log = \"0.4.5\"\n "}, {"sha": "9de7c1ea83751d6df26695dd1e863dc6da26ec5c", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -32,10 +32,17 @@ impl TokenExpander {\n         }\n     }\n \n-    pub fn shift(&self) -> u32 {\n+    pub fn map_id_down(&self, id: tt::TokenId) -> tt::TokenId {\n         match self {\n-            TokenExpander::MacroRules(it) => it.shift(),\n-            TokenExpander::Builtin(_) => 0,\n+            TokenExpander::MacroRules(it) => it.map_id_down(id),\n+            TokenExpander::Builtin(..) => id,\n+        }\n+    }\n+\n+    pub fn map_id_up(&self, id: tt::TokenId) -> (tt::TokenId, mbe::Origin) {\n+        match self {\n+            TokenExpander::MacroRules(it) => it.map_id_up(id),\n+            TokenExpander::Builtin(..) => (id, mbe::Origin::Def),\n         }\n     }\n }"}, {"sha": "57e2e6cb1a4041c109dca171da7ef17bd6598761", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -18,8 +18,9 @@ use std::sync::Arc;\n \n use ra_db::{salsa, CrateId, FileId};\n use ra_syntax::{\n+    algo,\n     ast::{self, AstNode},\n-    SyntaxNode, TextRange, TextUnit,\n+    SyntaxNode, SyntaxToken, TextRange, TextUnit,\n };\n \n use crate::ast_id_map::FileAstId;\n@@ -83,14 +84,21 @@ impl HirFileId {\n                     loc.def.ast_id.to_node(db).token_tree()?.syntax().text_range().start();\n \n                 let macro_def = db.macro_def(loc.def)?;\n-                let shift = macro_def.0.shift();\n-                let exp_map = db.parse_macro(macro_file)?.1;\n+                let (parse, exp_map) = db.parse_macro(macro_file)?;\n+                let expanded = Source::new(self, parse.syntax_node());\n                 let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n \n                 let arg_start = (loc.ast_id.file_id, arg_start);\n                 let def_start = (loc.def.ast_id.file_id, def_start);\n \n-                Some(ExpansionInfo { arg_start, def_start, macro_arg, macro_def, exp_map, shift })\n+                Some(ExpansionInfo {\n+                    expanded,\n+                    arg_start,\n+                    def_start,\n+                    macro_arg,\n+                    macro_def,\n+                    exp_map,\n+                })\n             }\n         }\n     }\n@@ -147,26 +155,42 @@ impl MacroCallId {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n /// ExpansionInfo mainly describes how to map text range between src and expanded macro\n+#[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ExpansionInfo {\n-    pub(crate) arg_start: (HirFileId, TextUnit),\n-    pub(crate) def_start: (HirFileId, TextUnit),\n-    pub(crate) shift: u32,\n+    expanded: Source<SyntaxNode>,\n+    arg_start: (HirFileId, TextUnit),\n+    def_start: (HirFileId, TextUnit),\n \n-    pub(crate) macro_def: Arc<(db::TokenExpander, mbe::TokenMap)>,\n-    pub(crate) macro_arg: Arc<(tt::Subtree, mbe::TokenMap)>,\n-    pub(crate) exp_map: Arc<mbe::RevTokenMap>,\n+    macro_def: Arc<(db::TokenExpander, mbe::TokenMap)>,\n+    macro_arg: Arc<(tt::Subtree, mbe::TokenMap)>,\n+    exp_map: Arc<mbe::RevTokenMap>,\n }\n \n impl ExpansionInfo {\n+    pub fn map_token_down(&self, token: Source<&SyntaxToken>) -> Option<Source<SyntaxToken>> {\n+        assert_eq!(token.file_id, self.arg_start.0);\n+        let range = token.ast.text_range().checked_sub(self.arg_start.1)?;\n+        let token_id = self.macro_arg.1.token_by_range(range)?;\n+        let token_id = self.macro_def.0.map_id_down(token_id);\n+\n+        let range = self.exp_map.range_by_token(token_id)?;\n+\n+        let token = algo::find_covering_element(&self.expanded.ast, range).into_token()?;\n+\n+        Some(self.expanded.with_ast(token))\n+    }\n+\n+    // FIXME: a more correct signature would be\n+    // `pub fn map_token_up(&self, token: Source<&SyntaxToken>) -> Option<Source<SyntaxToken>>`\n     pub fn find_range(&self, from: TextRange) -> Option<(HirFileId, TextRange)> {\n         let token_id = look_in_rev_map(&self.exp_map, from)?;\n \n-        let (token_map, (file_id, start_offset), token_id) = if token_id.0 >= self.shift {\n-            (&self.macro_arg.1, self.arg_start, tt::TokenId(token_id.0 - self.shift).into())\n-        } else {\n-            (&self.macro_def.1, self.def_start, token_id)\n+        let (token_id, origin) = self.macro_def.0.map_id_up(token_id);\n+\n+        let (token_map, (file_id, start_offset)) = match origin {\n+            mbe::Origin::Call => (&self.macro_arg.1, self.arg_start),\n+            mbe::Origin::Def => (&self.macro_def.1, self.def_start),\n         };\n \n         let range = token_map.relative_range_of(token_id)?;\n@@ -223,18 +247,30 @@ impl<N: AstNode> AstId<N> {\n     }\n }\n \n+/// FIXME: https://github.com/matklad/with ?\n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]\n pub struct Source<T> {\n     pub file_id: HirFileId,\n+    // FIXME: this stores all kind of things, not only `ast`.\n+    // There should be a better name...\n     pub ast: T,\n }\n \n impl<T> Source<T> {\n+    pub fn new(file_id: HirFileId, ast: T) -> Source<T> {\n+        Source { file_id, ast }\n+    }\n+\n+    // Similarly, naming here is stupid...\n+    pub fn with_ast<U>(&self, ast: U) -> Source<U> {\n+        Source::new(self.file_id, ast)\n+    }\n+\n     pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n-        Source { file_id: self.file_id, ast: f(self.ast) }\n+        Source::new(self.file_id, f(self.ast))\n     }\n     pub fn as_ref(&self) -> Source<&T> {\n-        Source { file_id: self.file_id, ast: &self.ast }\n+        self.with_ast(&self.ast)\n     }\n     pub fn file_syntax(&self, db: &impl db::AstDatabase) -> SyntaxNode {\n         db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")"}, {"sha": "15346f3881253d944e68b957ee2c1b831c637127", "filename": "crates/ra_ide_api/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -4,6 +4,9 @@ name = \"ra_ide_api\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n+[lib]\n+doctest = false\n+\n [features]\n wasm = []\n "}, {"sha": "41ee81511219bced3e8a43a6cdabfe83424538db", "filename": "crates/ra_ide_api/src/call_info.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -19,7 +19,11 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n     let calling_node = FnCallNode::with_node(&syntax, position.offset)?;\n     let name_ref = calling_node.name_ref()?;\n \n-    let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n+    let analyzer = hir::SourceAnalyzer::new(\n+        db,\n+        hir::Source::new(position.file_id.into(), name_ref.syntax()),\n+        None,\n+    );\n     let (mut call_info, has_self) = match &calling_node {\n         FnCallNode::CallExpr(expr) => {\n             //FIXME: apply subst"}, {"sha": "5c9dec13efae0acec8f928bfbdaeaabed31c0228", "filename": "crates/ra_ide_api/src/change.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -271,7 +271,6 @@ impl RootDatabase {\n         self.query(hir::db::AstIdMapQuery).sweep(sweep);\n \n         self.query(hir::db::RawItemsWithSourceMapQuery).sweep(sweep);\n-        self.query(hir::db::ImplsInModuleWithSourceMapQuery).sweep(sweep);\n         self.query(hir::db::BodyWithSourceMapQuery).sweep(sweep);\n \n         self.query(hir::db::ExprScopesQuery).sweep(sweep);\n@@ -314,8 +313,6 @@ impl RootDatabase {\n             hir::db::RawItemsWithSourceMapQuery\n             hir::db::RawItemsQuery\n             hir::db::CrateDefMapQuery\n-            hir::db::ImplsInModuleWithSourceMapQuery\n-            hir::db::ImplsInModuleQuery\n             hir::db::GenericParamsQuery\n             hir::db::FnDataQuery\n             hir::db::TypeAliasDataQuery\n@@ -340,6 +337,7 @@ impl RootDatabase {\n             hir::db::TraitDatumQuery\n             hir::db::StructDatumQuery\n             hir::db::ImplDatumQuery\n+            hir::db::ImplDataQuery\n             hir::db::TraitSolveQuery\n         ];\n         acc.sort_by_key(|it| std::cmp::Reverse(it.1));"}, {"sha": "0906a4e1b6382d6ddd60be391dbd134d2fd2cb43", "filename": "crates/ra_ide_api/src/completion/completion_context.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -58,8 +58,11 @@ impl<'a> CompletionContext<'a> {\n         );\n         let token =\n             original_parse.tree().syntax().token_at_offset(position.offset).left_biased()?;\n-        let analyzer =\n-            hir::SourceAnalyzer::new(db, position.file_id, &token.parent(), Some(position.offset));\n+        let analyzer = hir::SourceAnalyzer::new(\n+            db,\n+            hir::Source::new(position.file_id.into(), &token.parent()),\n+            Some(position.offset),\n+        );\n         let mut ctx = CompletionContext {\n             db,\n             analyzer,"}, {"sha": "b693a4c313332eec7e4bd91446918b9dea1008f3", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 79, "deletions": 36, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -1,10 +1,11 @@\n //! FIXME: write short doc here\n \n-use ra_db::{FileId, SourceDatabase};\n+use std::iter::successors;\n+\n+use hir::{db::AstDatabase, Source};\n use ra_syntax::{\n-    algo::find_node_at_offset,\n     ast::{self, DocCommentsOwner},\n-    match_ast, AstNode, SyntaxNode,\n+    match_ast, AstNode, SyntaxNode, SyntaxToken,\n };\n \n use crate::{\n@@ -18,17 +19,42 @@ pub(crate) fn goto_definition(\n     db: &RootDatabase,\n     position: FilePosition,\n ) -> Option<RangeInfo<Vec<NavigationTarget>>> {\n-    let parse = db.parse(position.file_id);\n-    let syntax = parse.tree().syntax().clone();\n-    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&syntax, position.offset) {\n-        let navs = reference_definition(db, position.file_id, &name_ref).to_vec();\n-        return Some(RangeInfo::new(name_ref.syntax().text_range(), navs.to_vec()));\n-    }\n-    if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, position.offset) {\n-        let navs = name_definition(db, position.file_id, &name)?;\n-        return Some(RangeInfo::new(name.syntax().text_range(), navs));\n-    }\n-    None\n+    let token = descend_into_macros(db, position)?;\n+\n+    let res = match_ast! {\n+        match (token.ast.parent()) {\n+            ast::NameRef(name_ref) => {\n+                let navs = reference_definition(db, token.with_ast(&name_ref)).to_vec();\n+                RangeInfo::new(name_ref.syntax().text_range(), navs.to_vec())\n+            },\n+            ast::Name(name) => {\n+                let navs = name_definition(db, token.with_ast(&name))?;\n+                RangeInfo::new(name.syntax().text_range(), navs)\n+\n+            },\n+            _ => return None,\n+        }\n+    };\n+\n+    Some(res)\n+}\n+\n+fn descend_into_macros(db: &RootDatabase, position: FilePosition) -> Option<Source<SyntaxToken>> {\n+    let file = db.parse_or_expand(position.file_id.into())?;\n+    let token = file.token_at_offset(position.offset).filter(|it| !it.kind().is_trivia()).next()?;\n+\n+    successors(Some(Source::new(position.file_id.into(), token)), |token| {\n+        let macro_call = token.ast.ancestors().find_map(ast::MacroCall::cast)?;\n+        let tt = macro_call.token_tree()?;\n+        if !token.ast.text_range().is_subrange(&tt.syntax().text_range()) {\n+            return None;\n+        }\n+        let source_analyzer =\n+            hir::SourceAnalyzer::new(db, token.with_ast(token.ast.parent()).as_ref(), None);\n+        let exp = source_analyzer.expand(db, &macro_call)?;\n+        exp.map_token_down(db, token.as_ref())\n+    })\n+    .last()\n }\n \n #[derive(Debug)]\n@@ -49,12 +75,11 @@ impl ReferenceResult {\n \n pub(crate) fn reference_definition(\n     db: &RootDatabase,\n-    file_id: FileId,\n-    name_ref: &ast::NameRef,\n+    name_ref: Source<&ast::NameRef>,\n ) -> ReferenceResult {\n     use self::ReferenceResult::*;\n \n-    let name_kind = classify_name_ref(db, file_id, &name_ref).map(|d| d.kind);\n+    let name_kind = classify_name_ref(db, name_ref).map(|d| d.kind);\n     match name_kind {\n         Some(Macro(mac)) => return Exact(mac.to_nav(db)),\n         Some(Field(field)) => return Exact(field.to_nav(db)),\n@@ -76,7 +101,7 @@ pub(crate) fn reference_definition(\n     };\n \n     // Fallback index based approach:\n-    let navs = crate::symbol_index::index_resolve(db, name_ref)\n+    let navs = crate::symbol_index::index_resolve(db, name_ref.ast)\n         .into_iter()\n         .map(|s| s.to_nav(db))\n         .collect();\n@@ -85,35 +110,34 @@ pub(crate) fn reference_definition(\n \n pub(crate) fn name_definition(\n     db: &RootDatabase,\n-    file_id: FileId,\n-    name: &ast::Name,\n+    name: Source<&ast::Name>,\n ) -> Option<Vec<NavigationTarget>> {\n-    let parent = name.syntax().parent()?;\n+    let parent = name.ast.syntax().parent()?;\n \n     if let Some(module) = ast::Module::cast(parent.clone()) {\n         if module.has_semi() {\n-            let src = hir::Source { file_id: file_id.into(), ast: module };\n+            let src = name.with_ast(module);\n             if let Some(child_module) = hir::Module::from_declaration(db, src) {\n                 let nav = child_module.to_nav(db);\n                 return Some(vec![nav]);\n             }\n         }\n     }\n \n-    if let Some(nav) = named_target(db, file_id, &parent) {\n+    if let Some(nav) = named_target(db, name.with_ast(&parent)) {\n         return Some(vec![nav]);\n     }\n \n     None\n }\n \n-fn named_target(db: &RootDatabase, file_id: FileId, node: &SyntaxNode) -> Option<NavigationTarget> {\n+fn named_target(db: &RootDatabase, node: Source<&SyntaxNode>) -> Option<NavigationTarget> {\n     match_ast! {\n-        match node {\n+        match (node.ast) {\n             ast::StructDef(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    file_id.into(),\n+                    node.file_id,\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n@@ -122,7 +146,7 @@ fn named_target(db: &RootDatabase, file_id: FileId, node: &SyntaxNode) -> Option\n             ast::EnumDef(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    file_id.into(),\n+                    node.file_id,\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n@@ -131,7 +155,7 @@ fn named_target(db: &RootDatabase, file_id: FileId, node: &SyntaxNode) -> Option\n             ast::EnumVariant(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    file_id.into(),\n+                    node.file_id,\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n@@ -140,7 +164,7 @@ fn named_target(db: &RootDatabase, file_id: FileId, node: &SyntaxNode) -> Option\n             ast::FnDef(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    file_id.into(),\n+                    node.file_id,\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n@@ -149,7 +173,7 @@ fn named_target(db: &RootDatabase, file_id: FileId, node: &SyntaxNode) -> Option\n             ast::TypeAliasDef(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    file_id.into(),\n+                    node.file_id,\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n@@ -158,7 +182,7 @@ fn named_target(db: &RootDatabase, file_id: FileId, node: &SyntaxNode) -> Option\n             ast::ConstDef(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    file_id.into(),\n+                    node.file_id,\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n@@ -167,7 +191,7 @@ fn named_target(db: &RootDatabase, file_id: FileId, node: &SyntaxNode) -> Option\n             ast::StaticDef(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    file_id.into(),\n+                    node.file_id,\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n@@ -176,7 +200,7 @@ fn named_target(db: &RootDatabase, file_id: FileId, node: &SyntaxNode) -> Option\n             ast::TraitDef(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    file_id.into(),\n+                    node.file_id,\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n@@ -185,7 +209,7 @@ fn named_target(db: &RootDatabase, file_id: FileId, node: &SyntaxNode) -> Option\n             ast::RecordFieldDef(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    file_id.into(),\n+                    node.file_id,\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n@@ -194,7 +218,7 @@ fn named_target(db: &RootDatabase, file_id: FileId, node: &SyntaxNode) -> Option\n             ast::Module(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    file_id.into(),\n+                    node.file_id,\n                     &it,\n                     it.doc_comment_text(),\n                     it.short_label(),\n@@ -203,7 +227,7 @@ fn named_target(db: &RootDatabase, file_id: FileId, node: &SyntaxNode) -> Option\n             ast::MacroCall(it) => {\n                 Some(NavigationTarget::from_named(\n                     db,\n-                    file_id.into(),\n+                    node.file_id,\n                     &it,\n                     it.doc_comment_text(),\n                     None,\n@@ -677,4 +701,23 @@ mod tests {\n             \"bar MODULE FileId(1) [0; 11) [4; 7)\",\n         );\n     }\n+\n+    #[test]\n+    fn goto_from_macro() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            macro_rules! id {\n+                ($($tt:tt)*) => { $($tt)* }\n+            }\n+            fn foo() {}\n+            id! {\n+                fn bar() {\n+                    fo<|>o();\n+                }\n+            }\n+            \",\n+            \"foo FN_DEF FileId(1) [52; 63) [55; 58)\",\n+        );\n+    }\n }"}, {"sha": "2327cb1e71bde23074bd1dc8f175c9a34e730709", "filename": "crates/ra_ide_api/src/goto_type_definition.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -18,7 +18,8 @@ pub(crate) fn goto_type_definition(\n             .find(|n| ast::Expr::cast(n.clone()).is_some() || ast::Pat::cast(n.clone()).is_some())\n     })?;\n \n-    let analyzer = hir::SourceAnalyzer::new(db, position.file_id, &node, None);\n+    let analyzer =\n+        hir::SourceAnalyzer::new(db, hir::Source::new(position.file_id.into(), &node), None);\n \n     let ty: hir::Ty = if let Some(ty) =\n         ast::Expr::cast(node.clone()).and_then(|e| analyzer.type_of(db, &e))"}, {"sha": "cc25f4c375b3194beacbcf81095bc91f931b76e2", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{Adt, HasSource, HirDisplay};\n+use hir::{Adt, HasSource, HirDisplay, Source};\n use ra_db::SourceDatabase;\n use ra_syntax::{\n     algo::{ancestors_at_offset, find_covering_element, find_node_at_offset},\n@@ -171,7 +171,8 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset)\n     {\n         let mut no_fallback = false;\n-        if let Some(name_kind) = classify_name_ref(db, position.file_id, &name_ref).map(|d| d.kind)\n+        if let Some(name_kind) =\n+            classify_name_ref(db, Source::new(position.file_id.into(), &name_ref)).map(|d| d.kind)\n         {\n             res.extend(hover_text_from_name_kind(db, name_kind, &mut no_fallback))\n         }\n@@ -230,7 +231,8 @@ pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Option<String> {\n         .ancestors()\n         .take_while(|it| it.text_range() == leaf_node.text_range())\n         .find(|it| ast::Expr::cast(it.clone()).is_some() || ast::Pat::cast(it.clone()).is_some())?;\n-    let analyzer = hir::SourceAnalyzer::new(db, frange.file_id, &node, None);\n+    let analyzer =\n+        hir::SourceAnalyzer::new(db, hir::Source::new(frange.file_id.into(), &node), None);\n     let ty = if let Some(ty) = ast::Expr::cast(node.clone()).and_then(|e| analyzer.type_of(db, &e))\n     {\n         ty"}, {"sha": "0cd95984835cf0be9b43e6e9c63fd23cb6285959", "filename": "crates/ra_ide_api/src/inlay_hints.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -32,18 +32,17 @@ fn get_inlay_hints(\n     file_id: FileId,\n     node: &SyntaxNode,\n ) -> Option<Vec<InlayHint>> {\n+    let analyzer = SourceAnalyzer::new(db, hir::Source::new(file_id.into(), node), None);\n     match_ast! {\n         match node {\n             ast::LetStmt(it) => {\n                 if it.ascribed_type().is_some() {\n                     return None;\n                 }\n                 let pat = it.pat()?;\n-                let analyzer = SourceAnalyzer::new(db, file_id, it.syntax(), None);\n                 Some(get_pat_type_hints(db, &analyzer, pat, false))\n             },\n             ast::LambdaExpr(it) => {\n-                let analyzer = SourceAnalyzer::new(db, file_id, it.syntax(), None);\n                 it.param_list().map(|param_list| {\n                     param_list\n                         .params()\n@@ -56,21 +55,17 @@ fn get_inlay_hints(\n             },\n             ast::ForExpr(it) => {\n                 let pat = it.pat()?;\n-                let analyzer = SourceAnalyzer::new(db, file_id, it.syntax(), None);\n                 Some(get_pat_type_hints(db, &analyzer, pat, false))\n             },\n             ast::IfExpr(it) => {\n                 let pat = it.condition()?.pat()?;\n-                let analyzer = SourceAnalyzer::new(db, file_id, it.syntax(), None);\n                 Some(get_pat_type_hints(db, &analyzer, pat, true))\n             },\n             ast::WhileExpr(it) => {\n                 let pat = it.condition()?.pat()?;\n-                let analyzer = SourceAnalyzer::new(db, file_id, it.syntax(), None);\n                 Some(get_pat_type_hints(db, &analyzer, pat, true))\n             },\n             ast::MatchArmList(it) => {\n-                let analyzer = SourceAnalyzer::new(db, file_id, it.syntax(), None);\n                 Some(\n                     it\n                         .arms()"}, {"sha": "1af7e8a9fa9959c531598420bf15ba803123a69f", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -14,6 +14,7 @@ mod name_definition;\n mod rename;\n mod search_scope;\n \n+use hir::Source;\n use once_cell::unsync::Lazy;\n use ra_db::{SourceDatabase, SourceDatabaseExt};\n use ra_prof::profile;\n@@ -114,7 +115,7 @@ fn find_name<'a>(\n         return Some(RangeInfo::new(range, (name.text().to_string(), def)));\n     }\n     let name_ref = find_node_at_offset::<ast::NameRef>(&syntax, position.offset)?;\n-    let def = classify_name_ref(db, position.file_id, &name_ref)?;\n+    let def = classify_name_ref(db, Source::new(position.file_id.into(), &name_ref))?;\n     let range = name_ref.syntax().text_range();\n     Some(RangeInfo::new(range, (name_ref.text().to_string(), def)))\n }\n@@ -146,7 +147,7 @@ fn process_definition(\n                         continue;\n                     }\n                 }\n-                if let Some(d) = classify_name_ref(db, file_id, &name_ref) {\n+                if let Some(d) = classify_name_ref(db, Source::new(file_id.into(), &name_ref)) {\n                     if d == def {\n                         refs.push(FileRange { file_id, range });\n                     }\n@@ -369,6 +370,21 @@ mod tests {\n         assert_eq!(refs.len(), 2);\n     }\n \n+    #[test]\n+    fn test_find_all_refs_macro_def() {\n+        let code = r#\"\n+        #[macro_export]\n+        macro_rules! m1<|> { () => (()) }\n+\n+        fn foo() {\n+            m1();\n+            m1();\n+        }\"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 3);\n+    }\n+\n     fn get_all_refs(text: &str) -> ReferenceSearchResult {\n         let (analysis, position) = single_file_with_position(text);\n         analysis.find_all_refs(position, None).unwrap().unwrap()"}, {"sha": "5ca9da15e1253f6ea829d635b1a7d1cfcf24d5f4", "filename": "crates/ra_ide_api/src/references/classify.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences%2Fclassify.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -21,7 +21,6 @@ pub(crate) fn classify_name(\n     let parent = name.syntax().parent()?;\n     let file_id = file_id.into();\n \n-    // FIXME: add ast::MacroCall(it)\n     match_ast! {\n         match parent {\n             ast::BindPat(it) => {\n@@ -104,22 +103,32 @@ pub(crate) fn classify_name(\n                     Some(from_module_def(db, def.into(), None))\n                 }\n             },\n+            ast::MacroCall(it) => {\n+                let src = hir::Source { file_id, ast: it};\n+                let def = hir::MacroDef::from_source(db, src.clone())?;\n+\n+                let module_src = ModuleSource::from_child_node(db, src.as_ref().map(|it| it.syntax()));\n+                let module = Module::from_definition(db, Source::new(file_id, module_src))?;\n+\n+                Some(NameDefinition {\n+                    visibility: None,\n+                    container: module,\n+                    kind: NameKind::Macro(def),\n+                })\n+            },\n             _ => None,\n         }\n     }\n }\n \n pub(crate) fn classify_name_ref(\n     db: &RootDatabase,\n-    file_id: FileId,\n-    name_ref: &ast::NameRef,\n+    name_ref: Source<&ast::NameRef>,\n ) -> Option<NameDefinition> {\n-    use PathResolution::*;\n-\n     let _p = profile(\"classify_name_ref\");\n \n-    let parent = name_ref.syntax().parent()?;\n-    let analyzer = SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n+    let parent = name_ref.ast.syntax().parent()?;\n+    let analyzer = SourceAnalyzer::new(db, name_ref.map(|it| it.syntax()), None);\n \n     if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n         tested_by!(goto_definition_works_for_methods);\n@@ -139,17 +148,16 @@ pub(crate) fn classify_name_ref(\n         tested_by!(goto_definition_works_for_record_fields);\n         if let Some(record_lit) = record_field.syntax().ancestors().find_map(ast::RecordLit::cast) {\n             let variant_def = analyzer.resolve_record_literal(&record_lit)?;\n-            let hir_path = Path::from_name_ref(name_ref);\n+            let hir_path = Path::from_name_ref(name_ref.ast);\n             let hir_name = hir_path.as_ident()?;\n             let field = variant_def.field(db, hir_name)?;\n             return Some(from_struct_field(db, field));\n         }\n     }\n \n-    let ast = ModuleSource::from_child_node(db, file_id, &parent);\n-    let file_id = file_id.into();\n+    let ast = ModuleSource::from_child_node(db, name_ref.with_ast(&parent));\n     // FIXME: find correct container and visibility for each case\n-    let container = Module::from_definition(db, Source { file_id, ast })?;\n+    let container = Module::from_definition(db, name_ref.with_ast(ast))?;\n     let visibility = None;\n \n     if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n@@ -160,29 +168,29 @@ pub(crate) fn classify_name_ref(\n         }\n     }\n \n-    let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n+    let path = name_ref.ast.syntax().ancestors().find_map(ast::Path::cast)?;\n     let resolved = analyzer.resolve_path(db, &path)?;\n     match resolved {\n-        Def(def) => Some(from_module_def(db, def, Some(container))),\n-        AssocItem(item) => Some(from_assoc_item(db, item)),\n-        Local(local) => {\n+        PathResolution::Def(def) => Some(from_module_def(db, def, Some(container))),\n+        PathResolution::AssocItem(item) => Some(from_assoc_item(db, item)),\n+        PathResolution::Local(local) => {\n             let container = local.module(db);\n             let kind = NameKind::Local(local);\n             Some(NameDefinition { kind, container, visibility: None })\n         }\n-        GenericParam(par) => {\n+        PathResolution::GenericParam(par) => {\n             // FIXME: get generic param def\n             let kind = NameKind::GenericParam(par);\n             Some(NameDefinition { kind, container, visibility })\n         }\n-        Macro(def) => {\n+        PathResolution::Macro(def) => {\n             let kind = NameKind::Macro(def);\n             Some(NameDefinition { kind, container, visibility })\n         }\n-        SelfType(impl_block) => {\n+        PathResolution::SelfType(impl_block) => {\n             let ty = impl_block.target_ty(db);\n             let kind = NameKind::SelfType(ty);\n-            let container = impl_block.module();\n+            let container = impl_block.module(db);\n             Some(NameDefinition { kind, container, visibility })\n         }\n     }"}, {"sha": "8039a5164ebf9eb5b5af82819cd0234c0edbe8f5", "filename": "crates/ra_ide_api/src/runnables.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -1,5 +1,6 @@\n //! FIXME: write short doc here\n \n+use hir::Source;\n use itertools::Itertools;\n use ra_db::SourceDatabase;\n use ra_syntax::{\n@@ -65,9 +66,8 @@ fn runnable_mod(db: &RootDatabase, file_id: FileId, module: ast::Module) -> Opti\n         return None;\n     }\n     let range = module.syntax().text_range();\n-    let src = hir::ModuleSource::from_child_node(db, file_id, &module.syntax());\n-    let module =\n-        hir::Module::from_definition(db, hir::Source { file_id: file_id.into(), ast: src })?;\n+    let src = hir::ModuleSource::from_child_node(db, Source::new(file_id.into(), &module.syntax()));\n+    let module = hir::Module::from_definition(db, Source::new(file_id.into(), src))?;\n \n     let path = module.path_to_root(db).into_iter().rev().filter_map(|it| it.name(db)).join(\"::\");\n     Some(Runnable { range, kind: RunnableKind::TestMod { path } })"}, {"sha": "584657ca261eea36e7bc3a8ab444f038874a3ac1", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_hash::{FxHashMap, FxHashSet};\n \n-use hir::{Mutability, Name};\n+use hir::{Mutability, Name, Source};\n use ra_db::SourceDatabase;\n use ra_prof::profile;\n use ra_syntax::{ast, AstNode, Direction, SyntaxElement, SyntaxKind, SyntaxKind::*, TextRange, T};\n@@ -80,7 +80,8 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                 }\n \n                 let name_ref = node.as_node().cloned().and_then(ast::NameRef::cast).unwrap();\n-                let name_kind = classify_name_ref(db, file_id, &name_ref).map(|d| d.kind);\n+                let name_kind =\n+                    classify_name_ref(db, Source::new(file_id.into(), &name_ref)).map(|d| d.kind);\n \n                 if let Some(Local(local)) = &name_kind {\n                     if let Some(name) = local.name(db) {"}, {"sha": "72dbe06dcc7cd90a41b8dab4df1b3f2c06abe912", "filename": "crates/ra_lsp_server/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_lsp_server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_lsp_server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -4,6 +4,9 @@ name = \"ra_lsp_server\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n threadpool = \"1.7.1\"\n relative-path = \"1.0.0\""}, {"sha": "a3fc01f634baeedc96692152040cc72befea9a2b", "filename": "crates/ra_mbe/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_mbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_mbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -4,6 +4,9 @@ name = \"ra_mbe\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n ra_syntax = { path = \"../ra_syntax\" }\n ra_parser = { path = \"../ra_parser\" }\n@@ -14,4 +17,3 @@ log = \"0.4.5\"\n \n [dev-dependencies]\n test_utils = { path = \"../test_utils\" }\n-"}, {"sha": "58ca95368d9957a12c10792867efcec8afa8f656", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 68, "deletions": 38, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -40,49 +40,75 @@ pub use crate::syntax_bridge::{\n /// and `$()*` have special meaning (see `Var` and `Repeat` data structures)\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct MacroRules {\n-    pub(crate) rules: Vec<Rule>,\n+    rules: Vec<Rule>,\n     /// Highest id of the token we have in TokenMap\n-    pub(crate) shift: u32,\n+    shift: Shift,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n-pub(crate) struct Rule {\n-    pub(crate) lhs: tt::Subtree,\n-    pub(crate) rhs: tt::Subtree,\n+struct Rule {\n+    lhs: tt::Subtree,\n+    rhs: tt::Subtree,\n }\n \n-// Find the max token id inside a subtree\n-fn max_id(subtree: &tt::Subtree) -> Option<u32> {\n-    subtree\n-        .token_trees\n-        .iter()\n-        .filter_map(|tt| match tt {\n-            tt::TokenTree::Subtree(subtree) => max_id(subtree),\n-            tt::TokenTree::Leaf(tt::Leaf::Ident(ident))\n-                if ident.id != tt::TokenId::unspecified() =>\n-            {\n-                Some(ident.id.0)\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+struct Shift(u32);\n+\n+impl Shift {\n+    fn new(tt: &tt::Subtree) -> Shift {\n+        // Note that TokenId is started from zero,\n+        // We have to add 1 to prevent duplication.\n+        let value = max_id(tt).map_or(0, |it| it + 1);\n+        return Shift(value);\n+\n+        // Find the max token id inside a subtree\n+        fn max_id(subtree: &tt::Subtree) -> Option<u32> {\n+            subtree\n+                .token_trees\n+                .iter()\n+                .filter_map(|tt| match tt {\n+                    tt::TokenTree::Subtree(subtree) => max_id(subtree),\n+                    tt::TokenTree::Leaf(tt::Leaf::Ident(ident))\n+                        if ident.id != tt::TokenId::unspecified() =>\n+                    {\n+                        Some(ident.id.0)\n+                    }\n+                    _ => None,\n+                })\n+                .max()\n+        }\n+    }\n+\n+    /// Shift given TokenTree token id\n+    fn shift_all(self, tt: &mut tt::Subtree) {\n+        for t in tt.token_trees.iter_mut() {\n+            match t {\n+                tt::TokenTree::Leaf(leaf) => match leaf {\n+                    tt::Leaf::Ident(ident) => ident.id = self.shift(ident.id),\n+                    _ => (),\n+                },\n+                tt::TokenTree::Subtree(tt) => self.shift_all(tt),\n             }\n-            _ => None,\n-        })\n-        .max()\n-}\n+        }\n+    }\n \n-/// Shift given TokenTree token id\n-fn shift_subtree(tt: &mut tt::Subtree, shift: u32) {\n-    for t in tt.token_trees.iter_mut() {\n-        match t {\n-            tt::TokenTree::Leaf(leaf) => match leaf {\n-                tt::Leaf::Ident(ident) if ident.id != tt::TokenId::unspecified() => {\n-                    ident.id.0 += shift;\n-                }\n-                _ => (),\n-            },\n-            tt::TokenTree::Subtree(tt) => shift_subtree(tt, shift),\n+    fn shift(self, id: tt::TokenId) -> tt::TokenId {\n+        if id == tt::TokenId::unspecified() {\n+            return id;\n         }\n+        tt::TokenId(id.0 + self.0)\n+    }\n+\n+    fn unshift(self, id: tt::TokenId) -> Option<tt::TokenId> {\n+        id.0.checked_sub(self.0).map(tt::TokenId)\n     }\n }\n \n+pub enum Origin {\n+    Def,\n+    Call,\n+}\n+\n impl MacroRules {\n     pub fn parse(tt: &tt::Subtree) -> Result<MacroRules, ParseError> {\n         // Note: this parsing can be implemented using mbe machinery itself, by\n@@ -105,21 +131,25 @@ impl MacroRules {\n             validate(&rule.lhs)?;\n         }\n \n-        // Note that TokenId is started from zero,\n-        // We have to add 1 to prevent duplication.\n-        let shift = max_id(tt).map_or(0, |it| it + 1);\n-        Ok(MacroRules { rules, shift })\n+        Ok(MacroRules { rules, shift: Shift::new(tt) })\n     }\n \n     pub fn expand(&self, tt: &tt::Subtree) -> Result<tt::Subtree, ExpandError> {\n         // apply shift\n         let mut tt = tt.clone();\n-        shift_subtree(&mut tt, self.shift);\n+        self.shift.shift_all(&mut tt);\n         mbe_expander::expand(self, &tt)\n     }\n \n-    pub fn shift(&self) -> u32 {\n-        self.shift\n+    pub fn map_id_down(&self, id: tt::TokenId) -> tt::TokenId {\n+        self.shift.shift(id)\n+    }\n+\n+    pub fn map_id_up(&self, id: tt::TokenId) -> (tt::TokenId, Origin) {\n+        match self.shift.unshift(id) {\n+            Some(id) => (id, Origin::Call),\n+            None => (id, Origin::Def),\n+        }\n     }\n }\n "}, {"sha": "8398c9ac73a4888e2f059fe5fb8456279b1f29c3", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -77,8 +77,14 @@ pub fn token_tree_to_syntax_node(\n }\n \n impl TokenMap {\n-    pub fn relative_range_of(&self, tt: tt::TokenId) -> Option<TextRange> {\n-        let idx = tt.0 as usize;\n+    pub fn token_by_range(&self, relative_range: TextRange) -> Option<tt::TokenId> {\n+        let (idx, _) =\n+            self.tokens.iter().enumerate().find(|(_, range)| **range == relative_range)?;\n+        Some(tt::TokenId(idx as u32))\n+    }\n+\n+    pub fn relative_range_of(&self, token_id: tt::TokenId) -> Option<TextRange> {\n+        let idx = token_id.0 as usize;\n         self.tokens.get(idx).copied()\n     }\n \n@@ -90,6 +96,11 @@ impl TokenMap {\n }\n \n impl RevTokenMap {\n+    pub fn range_by_token(&self, token_id: tt::TokenId) -> Option<TextRange> {\n+        let &(r, _) = self.ranges.iter().find(|(_, tid)| *tid == token_id)?;\n+        Some(r)\n+    }\n+\n     fn add(&mut self, relative_range: TextRange, token_id: tt::TokenId) {\n         self.ranges.push((relative_range, token_id.clone()))\n     }"}, {"sha": "0da581fd53e02778cbe50b5d08dbd21d7066f953", "filename": "crates/ra_parser/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_parser%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_parser%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -5,5 +5,8 @@ version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n publish = false\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n drop_bomb = \"0.1.4\""}, {"sha": "81d4f75f99a4e4748225cd49e672452e4e6ea1af", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 21, "deletions": 30, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -290,6 +290,22 @@ fn expr_bp(p: &mut Parser, r: Restrictions, bp: u8) -> (Option<CompletedMarker>,\n         let m = lhs.precede(p);\n         p.bump(op);\n \n+        if is_range {\n+            // test postfix_range\n+            // fn foo() {\n+            //     let x = 1..;\n+            //     match 1.. { _ => () };\n+            //     match a.b()..S { _ => () };\n+            // }\n+            let has_trailing_expression =\n+                p.at_ts(EXPR_FIRST) && !(r.forbid_structs && p.at(T!['{']));\n+            if !has_trailing_expression {\n+                // no RHS\n+                lhs = m.complete(p, RANGE_EXPR);\n+                break;\n+            }\n+        }\n+\n         expr_bp(p, r, op_bp + 1);\n         lhs = m.complete(p, if is_range { RANGE_EXPR } else { BIN_EXPR });\n     }\n@@ -330,7 +346,7 @@ fn lhs(p: &mut Parser, r: Restrictions) -> Option<(CompletedMarker, BlockLike)>\n                 if p.at(op) {\n                     m = p.start();\n                     p.bump(op);\n-                    if p.at_ts(EXPR_FIRST) {\n+                    if p.at_ts(EXPR_FIRST) && !(r.forbid_structs && p.at(T!['{'])) {\n                         expr_bp(p, r, 2);\n                     }\n                     return Some((m.complete(p, RANGE_EXPR), BlockLike::NotBlock));\n@@ -344,13 +360,7 @@ fn lhs(p: &mut Parser, r: Restrictions) -> Option<(CompletedMarker, BlockLike)>\n             // }\n             //\n             let (lhs, blocklike) = atom::atom_expr(p, r)?;\n-            return Some(postfix_expr(\n-                p,\n-                lhs,\n-                blocklike,\n-                !(r.prefer_stmt && blocklike.is_block()),\n-                r.forbid_structs,\n-            ));\n+            return Some(postfix_expr(p, lhs, blocklike, !(r.prefer_stmt && blocklike.is_block())));\n         }\n     };\n     // parse the interior of the unary expression\n@@ -366,7 +376,6 @@ fn postfix_expr(\n     // `while true {break}; ();`\n     mut block_like: BlockLike,\n     mut allow_calls: bool,\n-    forbid_structs: bool,\n ) -> (CompletedMarker, BlockLike) {\n     loop {\n         lhs = match p.current() {\n@@ -380,7 +389,7 @@ fn postfix_expr(\n             // }\n             T!['('] if allow_calls => call_expr(p, lhs),\n             T!['['] if allow_calls => index_expr(p, lhs),\n-            T![.] => match postfix_dot_expr(p, lhs, forbid_structs) {\n+            T![.] => match postfix_dot_expr(p, lhs) {\n                 Ok(it) => it,\n                 Err(it) => {\n                     lhs = it;\n@@ -398,7 +407,6 @@ fn postfix_expr(\n     fn postfix_dot_expr(\n         p: &mut Parser,\n         lhs: CompletedMarker,\n-        forbid_structs: bool,\n     ) -> Result<CompletedMarker, CompletedMarker> {\n         assert!(p.at(T![.]));\n         if p.nth(1) == IDENT && (p.nth(2) == T!['('] || p.nth_at(2, T![::])) {\n@@ -418,25 +426,8 @@ fn postfix_expr(\n             return Ok(m.complete(p, AWAIT_EXPR));\n         }\n \n-        // test postfix_range\n-        // fn foo() {\n-        //     let x = 1..;\n-        //     match 1.. { _ => () };\n-        //     match a.b()..S { _ => () };\n-        // }\n-        for &(op, la) in &[(T![..=], 3), (T![..], 2)] {\n-            if p.at(op) {\n-                let next_token = p.nth(la);\n-                let has_trailing_expression =\n-                    !(forbid_structs && next_token == T!['{']) && EXPR_FIRST.contains(next_token);\n-                return if has_trailing_expression {\n-                    Err(lhs)\n-                } else {\n-                    let m = lhs.precede(p);\n-                    p.bump(op);\n-                    Ok(m.complete(p, RANGE_EXPR))\n-                };\n-            }\n+        if p.at(T![..=]) || p.at(T![..]) {\n+            return Err(lhs);\n         }\n \n         Ok(field_expr(p, lhs))"}, {"sha": "382e6219a20a5a62197d503ec3fd5c1c4a04f154", "filename": "crates/ra_prof/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_prof%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_prof%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -5,6 +5,9 @@ version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n publish = false\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n once_cell = \"1.0.1\"\n itertools = \"0.8.0\""}, {"sha": "69edc3c66b468853861d3f3bad00cfeeca4d5ce0", "filename": "crates/ra_project_model/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_project_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_project_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -4,6 +4,9 @@ name = \"ra_project_model\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n log = \"0.4.5\"\n rustc-hash = \"1.0\""}, {"sha": "45a18a73f7a6afdcfd38166b70484d20b677746c", "filename": "crates/ra_syntax/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -7,6 +7,9 @@ license = \"MIT OR Apache-2.0\"\n description = \"Comment and whitespace preserving parser for the Rust langauge\"\n repository = \"https://github.com/rust-analyzer/rust-analyzer\"\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n itertools = \"0.8.0\"\n rowan = \"0.6.1\""}, {"sha": "277532a8cbf68fd705d28ec4c548abd9caac99d1", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -16,7 +16,7 @@ use crate::{\n };\n \n pub use self::{\n-    expr_extensions::{ArrayExprKind, BinOp, ElseBranch, LiteralKind, PrefixOp},\n+    expr_extensions::{ArrayExprKind, BinOp, ElseBranch, LiteralKind, PrefixOp, RangeOp},\n     extensions::{FieldKind, PathSegmentKind, SelfParamKind, StructKind, TypeBoundKind},\n     generated::*,\n     tokens::*,"}, {"sha": "7c53aa934400ae411849aa73d784a12bb83b546b", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -189,6 +189,52 @@ impl ast::BinExpr {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum RangeOp {\n+    /// `..`\n+    Exclusive,\n+    /// `..=`\n+    Inclusive,\n+}\n+\n+impl ast::RangeExpr {\n+    fn op_details(&self) -> Option<(usize, SyntaxToken, RangeOp)> {\n+        self.syntax().children_with_tokens().enumerate().find_map(|(ix, child)| {\n+            let token = child.into_token()?;\n+            let bin_op = match token.kind() {\n+                T![..] => RangeOp::Exclusive,\n+                T![..=] => RangeOp::Inclusive,\n+                _ => return None,\n+            };\n+            Some((ix, token, bin_op))\n+        })\n+    }\n+\n+    pub fn op_kind(&self) -> Option<RangeOp> {\n+        self.op_details().map(|t| t.2)\n+    }\n+\n+    pub fn op_token(&self) -> Option<SyntaxToken> {\n+        self.op_details().map(|t| t.1)\n+    }\n+\n+    pub fn start(&self) -> Option<ast::Expr> {\n+        let op_ix = self.op_details()?.0;\n+        self.syntax()\n+            .children_with_tokens()\n+            .take(op_ix)\n+            .find_map(|it| ast::Expr::cast(it.into_node()?))\n+    }\n+\n+    pub fn end(&self) -> Option<ast::Expr> {\n+        let op_ix = self.op_details()?.0;\n+        self.syntax()\n+            .children_with_tokens()\n+            .skip(op_ix + 1)\n+            .find_map(|it| ast::Expr::cast(it.into_node()?))\n+    }\n+}\n+\n impl ast::IndexExpr {\n     pub fn base(&self) -> Option<ast::Expr> {\n         children(self).nth(0)"}, {"sha": "ed8661faf5db94417cfdb649450cc9ecdf529734", "filename": "crates/ra_syntax/src/ast/tokens.rs", "status": "modified", "additions": 85, "deletions": 10, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -2,19 +2,18 @@\n \n use crate::{\n     ast::AstToken,\n-    SyntaxKind::{COMMENT, WHITESPACE},\n-    SyntaxToken,\n+    SyntaxKind::{COMMENT, RAW_STRING, STRING, WHITESPACE},\n+    SyntaxToken, TextRange, TextUnit,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Comment(SyntaxToken);\n \n impl AstToken for Comment {\n     fn cast(token: SyntaxToken) -> Option<Self> {\n-        if token.kind() == COMMENT {\n-            Some(Comment(token))\n-        } else {\n-            None\n+        match token.kind() {\n+            COMMENT => Some(Comment(token)),\n+            _ => None,\n         }\n     }\n     fn syntax(&self) -> &SyntaxToken {\n@@ -94,10 +93,9 @@ pub struct Whitespace(SyntaxToken);\n \n impl AstToken for Whitespace {\n     fn cast(token: SyntaxToken) -> Option<Self> {\n-        if token.kind() == WHITESPACE {\n-            Some(Whitespace(token))\n-        } else {\n-            None\n+        match token.kind() {\n+            WHITESPACE => Some(Whitespace(token)),\n+            _ => None,\n         }\n     }\n     fn syntax(&self) -> &SyntaxToken {\n@@ -111,3 +109,80 @@ impl Whitespace {\n         text.find('\\n').map_or(false, |idx| text[idx + 1..].contains('\\n'))\n     }\n }\n+\n+pub struct String(SyntaxToken);\n+\n+impl AstToken for String {\n+    fn cast(token: SyntaxToken) -> Option<Self> {\n+        match token.kind() {\n+            STRING => Some(String(token)),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        &self.0\n+    }\n+}\n+\n+impl String {\n+    pub fn value(&self) -> Option<std::string::String> {\n+        let text = self.text().as_str();\n+        let usual_string_range = find_usual_string_range(text)?;\n+        let start_of_inside = usual_string_range.start().to_usize() + 1;\n+        let end_of_inside = usual_string_range.end().to_usize();\n+        let inside_str = &text[start_of_inside..end_of_inside];\n+\n+        let mut buf = std::string::String::with_capacity(inside_str.len());\n+        let mut has_error = false;\n+        rustc_lexer::unescape::unescape_str(inside_str, &mut |_, unescaped_char| {\n+            match unescaped_char {\n+                Ok(c) => buf.push(c),\n+                Err(_) => has_error = true,\n+            }\n+        });\n+\n+        if has_error {\n+            return None;\n+        }\n+        Some(buf)\n+    }\n+}\n+\n+pub struct RawString(SyntaxToken);\n+\n+impl AstToken for RawString {\n+    fn cast(token: SyntaxToken) -> Option<Self> {\n+        match token.kind() {\n+            RAW_STRING => Some(RawString(token)),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        &self.0\n+    }\n+}\n+\n+impl RawString {\n+    pub fn value(&self) -> Option<std::string::String> {\n+        let text = self.text().as_str();\n+        let usual_string_range = find_usual_string_range(text)?;\n+        let start_of_inside = usual_string_range.start().to_usize() + 1;\n+        let end_of_inside = usual_string_range.end().to_usize();\n+        let inside_str = &text[start_of_inside..end_of_inside];\n+        Some(inside_str.to_string())\n+    }\n+}\n+\n+fn find_usual_string_range(s: &str) -> Option<TextRange> {\n+    let left_quote = s.find('\"')?;\n+    let right_quote = s.rfind('\"')?;\n+    if left_quote == right_quote {\n+        // `s` only contains one quote\n+        None\n+    } else {\n+        Some(TextRange::from_to(\n+            TextUnit::from(left_quote as u32),\n+            TextUnit::from(right_quote as u32),\n+        ))\n+    }\n+}"}, {"sha": "9931fec84730629c665e122643fb7b0db9f3e6e8", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -176,9 +176,11 @@ impl SourceFile {\n /// ```\n #[macro_export]\n macro_rules! match_ast {\n-    (match $node:ident {\n+    (match $node:ident { $($tt:tt)* }) => { match_ast!(match ($node) { $($tt)* }) };\n+\n+    (match ($node:expr) {\n         $( ast::$ast:ident($it:ident) => $res:block, )*\n-        _ => $catch_all:expr,\n+        _ => $catch_all:expr $(,)?\n     }) => {{\n         $( if let Some($it) = ast::$ast::cast($node.clone()) $res else )*\n         { $catch_all }"}, {"sha": "6c171df8d5e323429e0bb6b7dd15c5d3ba986747", "filename": "crates/ra_syntax/src/syntax_error.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Fsrc%2Fsyntax_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Fsrc%2Fsyntax_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_error.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -83,6 +83,7 @@ pub enum SyntaxErrorKind {\n     InvalidMatchInnerAttr,\n     InvalidTupleIndexFormat,\n     VisibilityNotAllowed,\n+    InclusiveRangeMissingEnd,\n }\n \n impl fmt::Display for SyntaxErrorKind {\n@@ -103,6 +104,9 @@ impl fmt::Display for SyntaxErrorKind {\n             VisibilityNotAllowed => {\n                 write!(f, \"unnecessary visibility qualifier\")\n             }\n+            InclusiveRangeMissingEnd => {\n+                write!(f, \"An inclusive range must have an end expression\")\n+            }\n         }\n     }\n }"}, {"sha": "222ac15f871b2f08ada52b795e8a3fdf9cacc517", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -103,6 +103,7 @@ pub(crate) fn validate(root: &SyntaxNode) -> Vec<SyntaxError> {\n                 ast::FieldExpr(it) => { validate_numeric_name(it.name_ref(), &mut errors) },\n                 ast::RecordField(it) => { validate_numeric_name(it.name_ref(), &mut errors) },\n                 ast::Visibility(it) => { validate_visibility(it, &mut errors) },\n+                ast::RangeExpr(it) => { validate_range_expr(it, &mut errors) },\n                 _ => (),\n             }\n         }\n@@ -227,3 +228,12 @@ fn validate_visibility(vis: ast::Visibility, errors: &mut Vec<SyntaxError>) {\n             .push(SyntaxError::new(SyntaxErrorKind::VisibilityNotAllowed, vis.syntax.text_range()))\n     }\n }\n+\n+fn validate_range_expr(expr: ast::RangeExpr, errors: &mut Vec<SyntaxError>) {\n+    if expr.op_kind() == Some(ast::RangeOp::Inclusive) && expr.end().is_none() {\n+        errors.push(SyntaxError::new(\n+            SyntaxErrorKind::InclusiveRangeMissingEnd,\n+            expr.syntax().text_range(),\n+        ));\n+    }\n+}"}, {"sha": "0b4ed7a2bc20595bcc63c59a9119f8e60afee18b", "filename": "crates/ra_syntax/test_data/parser/err/0038_endless_inclusive_range.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0038_endless_inclusive_range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0038_endless_inclusive_range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0038_endless_inclusive_range.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    0..=;\n+    ..=;\n+}"}, {"sha": "3810b9680a309824016ba1f80b5edc783bec3498", "filename": "crates/ra_syntax/test_data/parser/err/0038_endless_inclusive_range.txt", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0038_endless_inclusive_range.txt", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0038_endless_inclusive_range.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0038_endless_inclusive_range.txt?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -0,0 +1,30 @@\n+SOURCE_FILE@[0; 33)\n+  FN_DEF@[0; 32)\n+    FN_KW@[0; 2) \"fn\"\n+    WHITESPACE@[2; 3) \" \"\n+    NAME@[3; 7)\n+      IDENT@[3; 7) \"main\"\n+    PARAM_LIST@[7; 9)\n+      L_PAREN@[7; 8) \"(\"\n+      R_PAREN@[8; 9) \")\"\n+    WHITESPACE@[9; 10) \" \"\n+    BLOCK_EXPR@[10; 32)\n+      BLOCK@[10; 32)\n+        L_CURLY@[10; 11) \"{\"\n+        WHITESPACE@[11; 16) \"\\n    \"\n+        EXPR_STMT@[16; 21)\n+          RANGE_EXPR@[16; 20)\n+            LITERAL@[16; 17)\n+              INT_NUMBER@[16; 17) \"0\"\n+            DOTDOTEQ@[17; 20) \"..=\"\n+          SEMI@[20; 21) \";\"\n+        WHITESPACE@[21; 26) \"\\n    \"\n+        EXPR_STMT@[26; 30)\n+          RANGE_EXPR@[26; 29)\n+            DOTDOTEQ@[26; 29) \"..=\"\n+          SEMI@[29; 30) \";\"\n+        WHITESPACE@[30; 31) \"\\n\"\n+        R_CURLY@[31; 32) \"}\"\n+  WHITESPACE@[32; 33) \"\\n\"\n+error [16; 20): An inclusive range must have an end expression\n+error [26; 29): An inclusive range must have an end expression"}, {"sha": "f063ffadb3db6a934fcebb7ad69bc2365928d57b", "filename": "crates/ra_syntax/test_data/parser/ok/0060_as_range.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0060_as_range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0060_as_range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0060_as_range.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    0 as usize ..;\n+    1 + 2 as usize ..;\n+}"}, {"sha": "ad0c4a3fef0cd1a19b1d510e3558ec0eccb52779", "filename": "crates/ra_syntax/test_data/parser/ok/0060_as_range.txt", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0060_as_range.txt", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0060_as_range.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0060_as_range.txt?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -0,0 +1,56 @@\n+SOURCE_FILE@[0; 56)\n+  FN_DEF@[0; 55)\n+    FN_KW@[0; 2) \"fn\"\n+    WHITESPACE@[2; 3) \" \"\n+    NAME@[3; 7)\n+      IDENT@[3; 7) \"main\"\n+    PARAM_LIST@[7; 9)\n+      L_PAREN@[7; 8) \"(\"\n+      R_PAREN@[8; 9) \")\"\n+    WHITESPACE@[9; 10) \" \"\n+    BLOCK_EXPR@[10; 55)\n+      BLOCK@[10; 55)\n+        L_CURLY@[10; 11) \"{\"\n+        WHITESPACE@[11; 16) \"\\n    \"\n+        EXPR_STMT@[16; 30)\n+          RANGE_EXPR@[16; 29)\n+            CAST_EXPR@[16; 26)\n+              LITERAL@[16; 17)\n+                INT_NUMBER@[16; 17) \"0\"\n+              WHITESPACE@[17; 18) \" \"\n+              AS_KW@[18; 20) \"as\"\n+              WHITESPACE@[20; 21) \" \"\n+              PATH_TYPE@[21; 26)\n+                PATH@[21; 26)\n+                  PATH_SEGMENT@[21; 26)\n+                    NAME_REF@[21; 26)\n+                      IDENT@[21; 26) \"usize\"\n+            WHITESPACE@[26; 27) \" \"\n+            DOTDOT@[27; 29) \"..\"\n+          SEMI@[29; 30) \";\"\n+        WHITESPACE@[30; 35) \"\\n    \"\n+        EXPR_STMT@[35; 53)\n+          RANGE_EXPR@[35; 52)\n+            BIN_EXPR@[35; 49)\n+              LITERAL@[35; 36)\n+                INT_NUMBER@[35; 36) \"1\"\n+              WHITESPACE@[36; 37) \" \"\n+              PLUS@[37; 38) \"+\"\n+              WHITESPACE@[38; 39) \" \"\n+              CAST_EXPR@[39; 49)\n+                LITERAL@[39; 40)\n+                  INT_NUMBER@[39; 40) \"2\"\n+                WHITESPACE@[40; 41) \" \"\n+                AS_KW@[41; 43) \"as\"\n+                WHITESPACE@[43; 44) \" \"\n+                PATH_TYPE@[44; 49)\n+                  PATH@[44; 49)\n+                    PATH_SEGMENT@[44; 49)\n+                      NAME_REF@[44; 49)\n+                        IDENT@[44; 49) \"usize\"\n+            WHITESPACE@[49; 50) \" \"\n+            DOTDOT@[50; 52) \"..\"\n+          SEMI@[52; 53) \";\"\n+        WHITESPACE@[53; 54) \"\\n\"\n+        R_CURLY@[54; 55) \"}\"\n+  WHITESPACE@[55; 56) \"\\n\""}, {"sha": "2c4ed11e1e5dd438e51e62988ce6356b7bbf10b6", "filename": "crates/ra_syntax/test_data/parser/ok/0061_match_full_range.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0061_match_full_range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0061_match_full_range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0061_match_full_range.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    match .. {\n+    }\n+}"}, {"sha": "bdfac9b76434f9f9dd906b70ce814d23800ee338", "filename": "crates/ra_syntax/test_data/parser/ok/0061_match_full_range.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0061_match_full_range.txt", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0061_match_full_range.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0061_match_full_range.txt?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -0,0 +1,27 @@\n+SOURCE_FILE@[0; 35)\n+  FN_DEF@[0; 34)\n+    FN_KW@[0; 2) \"fn\"\n+    WHITESPACE@[2; 3) \" \"\n+    NAME@[3; 7)\n+      IDENT@[3; 7) \"main\"\n+    PARAM_LIST@[7; 9)\n+      L_PAREN@[7; 8) \"(\"\n+      R_PAREN@[8; 9) \")\"\n+    WHITESPACE@[9; 10) \" \"\n+    BLOCK_EXPR@[10; 34)\n+      BLOCK@[10; 34)\n+        L_CURLY@[10; 11) \"{\"\n+        WHITESPACE@[11; 16) \"\\n    \"\n+        MATCH_EXPR@[16; 32)\n+          MATCH_KW@[16; 21) \"match\"\n+          WHITESPACE@[21; 22) \" \"\n+          RANGE_EXPR@[22; 24)\n+            DOTDOT@[22; 24) \"..\"\n+          WHITESPACE@[24; 25) \" \"\n+          MATCH_ARM_LIST@[25; 32)\n+            L_CURLY@[25; 26) \"{\"\n+            WHITESPACE@[26; 31) \"\\n    \"\n+            R_CURLY@[31; 32) \"}\"\n+        WHITESPACE@[32; 33) \"\\n\"\n+        R_CURLY@[33; 34) \"}\"\n+  WHITESPACE@[34; 35) \"\\n\""}, {"sha": "8573c521a2e067ed9c74c1b075c60fb45779fda5", "filename": "crates/ra_text_edit/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_text_edit%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_text_edit%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -5,6 +5,9 @@ version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n publish = false\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n text_unit = \"0.1.6\"\n "}, {"sha": "b8dceb92a4e9c46fbbcbb533ecf8fff614b8b590", "filename": "crates/ra_tt/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_tt%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_tt%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tt%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -4,6 +4,9 @@ name = \"ra_tt\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n # ideally, `serde` should be enabled by `ra_lsp_server`, but we enable it here\n # to reduce number of compilations"}, {"sha": "094d6d6f440bbb615c922f8abdc97cf0bfb64242", "filename": "crates/ra_vfs_glob/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_vfs_glob%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Fra_vfs_glob%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs_glob%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -4,6 +4,9 @@ name = \"ra_vfs_glob\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n ra_vfs = \"0.5.0\"\n globset = \"0.4.4\""}, {"sha": "a71366cc4a5a68c970dc4c376f0f4403a4db62c1", "filename": "crates/test_utils/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Ftest_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Ftest_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2FCargo.toml?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -4,6 +4,9 @@ name = \"test_utils\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n difference = \"2.0.0\"\n text_unit = \"0.1.2\""}, {"sha": "fe18139477e140d3c9dc6e19061cf444e235e624", "filename": "crates/test_utils/src/marks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fmarks.rs?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -4,7 +4,7 @@\n //! See <https://matklad.github.io/2018/06/18/a-trick-for-test-maintenance.html>\n //! for details, but the TL;DR is that you write your test as\n //!\n-//! ```rust,no_run\n+//! ```\n //! #[test]\n //! fn test_foo() {\n //!     covers!(test_foo);\n@@ -13,7 +13,7 @@\n //!\n //! and in the code under test you write\n //!\n-//! ```rust,no_run\n+//! ```\n //! # use test_utils::tested_by;\n //! # fn some_condition() -> bool { true }\n //! fn foo() {"}, {"sha": "ac59bf60db692fb55641671446817398e1a8c9aa", "filename": "editors/code/src/commands/runnables.ts", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts", "raw_url": "https://github.com/rust-lang/rust/raw/166636ba77adcf5bf2c4ef935e9aa75e20f25e10/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Frunnables.ts?ref=166636ba77adcf5bf2c4ef935e9aa75e20f25e10", "patch": "@@ -161,7 +161,9 @@ export async function startCargoWatch(\n ): Promise<CargoWatchProvider | undefined> {\n     const execPromise = util.promisify(child_process.exec);\n \n-    const { stderr } = await execPromise('cargo watch --version').catch(e => e);\n+    const { stderr, code = 0 } = await execPromise(\n+        'cargo watch --version'\n+    ).catch(e => e);\n \n     if (stderr.includes('no such subcommand: `watch`')) {\n         const msg =\n@@ -201,6 +203,11 @@ export async function startCargoWatch(\n             );\n             return;\n         }\n+    } else if (code !== 0) {\n+        vscode.window.showErrorMessage(\n+            `\\`cargo watch\\` failed with ${code}: ${stderr}`\n+        );\n+        return;\n     }\n \n     const provider = await registerCargoWatchProvider(context.subscriptions);"}]}