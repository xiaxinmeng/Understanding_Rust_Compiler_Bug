{"sha": "9a72afa7dd5689da1844695086d1f89130956a88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNzJhZmE3ZGQ1Njg5ZGExODQ0Njk1MDg2ZDFmODkxMzA5NTZhODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-30T01:21:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-30T01:21:39Z"}, "message": "Auto merge of #83772 - jhpratt:revamp-step-trait, r=Mark-Simulacrum\n\nMake `Step` trait safe to implement\n\nThis PR makes a few modifications to the `Step` trait that I believe better position it for stabilization in the short term. In particular,\n\n1. `unsafe trait TrustedStep` is introduced, indicating that the implementation of `Step` for a given type upholds all stated invariants (which have remained unchanged). This is gated behind a new `trusted_step` feature, as stabilization is realistically blocked on min_specialization.\n2. The `Step` trait is internally specialized on the `TrustedStep` trait, which avoids a serious performance regression.\n3. `TrustedLen` is implemented for `T: TrustedStep` as the latter's invariants subsume the former's.\n4. The `Step` trait is no longer `unsafe`, as the invariants must not be relied upon by unsafe code (unless the type implements `TrustedStep`).\n5. `TrustedStep` is implemented for all types that implement `Step` in the standard library and compiler.\n6. The `step_trait_ext` feature is merged into the `step_trait` feature. I was unable to find any reasoning for the features being split; the `_unchecked` methods need not necessarily be stabilized at the same time, but I think it is useful to have them under the same feature flag.\n\nAll existing implementations of `Step` will be broken, as it is not possible to `unsafe impl` a safe trait. Given this trait only exists on nightly, I feel this breakage is acceptable. The blanket `impl<T: Step> TrustedLen for T` will likely cause some minor breakage, but this should be covered by the equivalent impl for `TrustedStep`.\n\nHopefully these changes are sufficient to place `Step` in decent position for stabilization, which would allow user-defined types to be used with `a..b` syntax.", "tree": {"sha": "7b5673152c292a31fdb25be5bd89b6143f9b7ede", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b5673152c292a31fdb25be5bd89b6143f9b7ede"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a72afa7dd5689da1844695086d1f89130956a88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a72afa7dd5689da1844695086d1f89130956a88", "html_url": "https://github.com/rust-lang/rust/commit/9a72afa7dd5689da1844695086d1f89130956a88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a72afa7dd5689da1844695086d1f89130956a88/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84b1005bfd22e2cb2a4c13b0b81958fe72628354", "url": "https://api.github.com/repos/rust-lang/rust/commits/84b1005bfd22e2cb2a4c13b0b81958fe72628354", "html_url": "https://github.com/rust-lang/rust/commit/84b1005bfd22e2cb2a4c13b0b81958fe72628354"}, {"sha": "741b9a4fa7fcfae4176ff090094bb53786725606", "url": "https://api.github.com/repos/rust-lang/rust/commits/741b9a4fa7fcfae4176ff090094bb53786725606", "html_url": "https://github.com/rust-lang/rust/commit/741b9a4fa7fcfae4176ff090094bb53786725606"}], "stats": {"total": 545, "additions": 423, "deletions": 122}, "files": [{"sha": "14ecf27813d3109bb775b037c81465aa9fc99ba3", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -17,6 +17,8 @@\n #![feature(iter_zip)]\n #![feature(label_break_value)]\n #![feature(nll)]\n+#![feature(min_specialization)]\n+#![feature(trusted_step)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "7f3c410b1ec60bb3bcfbafa7328cc412a599dfb7", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -7,6 +7,8 @@\n #![cfg_attr(bootstrap, feature(extended_key_value_attributes))]\n #![feature(in_band_lifetimes)]\n #![feature(once_cell)]\n+#![feature(min_specialization)]\n+#![feature(trusted_step)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "04d62391c021b6d1256a30f3198507ec711ca74a", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -6,6 +6,7 @@\n #![feature(unboxed_closures)]\n #![feature(test)]\n #![feature(fn_traits)]\n+#![feature(trusted_step)]\n \n pub mod bit_set;\n pub mod vec;"}, {"sha": "3f759f4023b57e71137abfe9140c1a7fa7ac0cfa", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -65,7 +65,7 @@ impl Idx for u32 {\n /// `u32::MAX`. You can also customize things like the `Debug` impl,\n /// what traits are derived, and so forth via the macro.\n #[macro_export]\n-#[allow_internal_unstable(step_trait, step_trait_ext, rustc_attrs)]\n+#[allow_internal_unstable(step_trait, rustc_attrs)]\n macro_rules! newtype_index {\n     // ---- public rules ----\n \n@@ -184,7 +184,7 @@ macro_rules! newtype_index {\n             }\n         }\n \n-        unsafe impl ::std::iter::Step for $type {\n+        impl ::std::iter::Step for $type {\n             #[inline]\n             fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n                 <usize as ::std::iter::Step>::steps_between(\n@@ -204,6 +204,9 @@ macro_rules! newtype_index {\n             }\n         }\n \n+        // Safety: The implementation of `Step` upholds all invariants.\n+        unsafe impl ::std::iter::TrustedStep for $type {}\n+\n         impl From<$type> for u32 {\n             #[inline]\n             fn from(v: $type) -> u32 {"}, {"sha": "6b452bca8e70f65666d44224bc450e4e4e3f0b0b", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -22,6 +22,8 @@\n #![feature(never_type)]\n #![feature(in_band_lifetimes)]\n #![feature(control_flow_enum)]\n+#![feature(min_specialization)]\n+#![feature(trusted_step)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "6f97716e2e0d62e8469157c68c0d0cac1c1b49b5", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -50,6 +50,7 @@\n #![feature(associated_type_defaults)]\n #![feature(iter_zip)]\n #![feature(thread_local_const_init)]\n+#![feature(trusted_step)]\n #![recursion_limit = \"512\"]\n \n #[macro_use]"}, {"sha": "647c368d2bb8227d49dac90da7485b6411cfdf34", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -31,6 +31,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(option_get_or_insert_default)]\n #![feature(once_cell)]\n #![feature(control_flow_enum)]\n+#![feature(trusted_step)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "99b854ff066e3d538d7a2d03cb888c4de29257fa", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -10,6 +10,8 @@\n #![feature(bool_to_option)]\n #![feature(iter_zip)]\n #![feature(once_cell)]\n+#![feature(min_specialization)]\n+#![feature(trusted_step)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "4803148eba91004eb8854ddabea0d1a33a156ffd", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -10,6 +10,8 @@\n #![feature(in_band_lifetimes)]\n #![feature(iter_zip)]\n #![feature(nll)]\n+#![feature(min_specialization)]\n+#![feature(trusted_step)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "7df3804c986d0dd6f40de9d82e4bff225b6af541", "filename": "compiler/rustc_query_system/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Flib.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -6,6 +6,7 @@\n #![feature(iter_zip)]\n #![feature(min_specialization)]\n #![feature(stmt_expr_attributes)]\n+#![feature(trusted_step)]\n \n #[macro_use]\n extern crate tracing;"}, {"sha": "39b7b36b853fb15843000651d258f3f1de7a9bb0", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -21,6 +21,7 @@\n #![feature(nll)]\n #![feature(min_specialization)]\n #![feature(thread_local_const_init)]\n+#![feature(trusted_step)]\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "a40de5ef18e0143e9be763818d99c0767536aedc", "filename": "compiler/rustc_target/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_target%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_target%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Flib.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -14,6 +14,8 @@\n #![feature(never_type)]\n #![feature(associated_type_bounds)]\n #![feature(exhaustive_patterns)]\n+#![feature(min_specialization)]\n+#![feature(trusted_step)]\n \n use std::path::{Path, PathBuf};\n "}, {"sha": "3f4c8a72f1d489fac2dc5487418e4ddf5fb3cb40", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -1,3 +1,6 @@\n+#![feature(min_specialization)]\n+#![feature(trusted_step)]\n+\n #[macro_use]\n extern crate bitflags;\n #[macro_use]"}, {"sha": "bfb27da505eaf54fdd2e6ad4d879ffa5d3ef7a1c", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -384,6 +384,8 @@ pub use self::traits::FusedIterator;\n pub use self::traits::InPlaceIterable;\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n pub use self::traits::TrustedLen;\n+#[unstable(feature = \"trusted_step\", issue = \"85731\")]\n+pub use self::traits::TrustedStep;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::traits::{\n     DoubleEndedIterator, ExactSizeIterator, Extend, FromIterator, IntoIterator, Product, Sum,"}, {"sha": "de5d77e96ee568b98be6e79864600d47ae7147ab", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 360, "deletions": 108, "changes": 468, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -3,21 +3,23 @@ use crate::convert::TryFrom;\n use crate::mem;\n use crate::ops::{self, Try};\n \n-use super::{FusedIterator, TrustedLen, TrustedRandomAccess};\n+use super::{FusedIterator, TrustedLen, TrustedRandomAccess, TrustedStep};\n+\n+// Safety: All invariants are upheld.\n+macro_rules! unsafe_impl_trusted_step {\n+    ($($type:ty)*) => {$(\n+        #[unstable(feature = \"trusted_step\", issue = \"85731\")]\n+        unsafe impl TrustedStep for $type {}\n+    )*};\n+}\n+unsafe_impl_trusted_step![char i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize];\n \n /// Objects that have a notion of *successor* and *predecessor* operations.\n ///\n /// The *successor* operation moves towards values that compare greater.\n /// The *predecessor* operation moves towards values that compare lesser.\n-///\n-/// # Safety\n-///\n-/// This trait is `unsafe` because its implementation must be correct for\n-/// the safety of `unsafe trait TrustedLen` implementations, and the results\n-/// of using this trait can otherwise be trusted by `unsafe` code to be correct\n-/// and fulfill the listed obligations.\n #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-pub unsafe trait Step: Clone + PartialOrd + Sized {\n+pub trait Step: Clone + PartialOrd + Sized {\n     /// Returns the number of *successor* steps required to get from `start` to `end`.\n     ///\n     /// Returns `None` if the number of steps would overflow `usize`\n@@ -55,7 +57,6 @@ pub unsafe trait Step: Clone + PartialOrd + Sized {\n     ///\n     /// * `Step::forward_checked(a, n) == (0..n).try_fold(a, |x, _| Step::forward_checked(&x, 1))`\n     ///   * Corollary: `Step::forward_checked(&a, 0) == Some(a)`\n-    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n     fn forward_checked(start: Self, count: usize) -> Option<Self>;\n \n     /// Returns the value that would be obtained by taking the *successor*\n@@ -81,7 +82,6 @@ pub unsafe trait Step: Clone + PartialOrd + Sized {\n     ///   * Corollary: `Step::forward(a, 0) == a`\n     /// * `Step::forward(a, n) >= a`\n     /// * `Step::backward(Step::forward(a, n), n) == a`\n-    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n     fn forward(start: Self, count: usize) -> Self {\n         Step::forward_checked(start, count).expect(\"overflow in `Step::forward`\")\n     }\n@@ -106,7 +106,6 @@ pub unsafe trait Step: Clone + PartialOrd + Sized {\n     /// For any `a` and `n`, where no overflow occurs:\n     ///\n     /// * `Step::forward_unchecked(a, n)` is equivalent to `Step::forward(a, n)`\n-    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n     unsafe fn forward_unchecked(start: Self, count: usize) -> Self {\n         Step::forward(start, count)\n     }\n@@ -127,7 +126,6 @@ pub unsafe trait Step: Clone + PartialOrd + Sized {\n     ///\n     /// * `Step::backward_checked(a, n) == (0..n).try_fold(a, |x, _| Step::backward_checked(&x, 1))`\n     ///   * Corollary: `Step::backward_checked(&a, 0) == Some(a)`\n-    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n     fn backward_checked(start: Self, count: usize) -> Option<Self>;\n \n     /// Returns the value that would be obtained by taking the *predecessor*\n@@ -153,7 +151,6 @@ pub unsafe trait Step: Clone + PartialOrd + Sized {\n     ///   * Corollary: `Step::backward(a, 0) == a`\n     /// * `Step::backward(a, n) <= a`\n     /// * `Step::forward(Step::backward(a, n), n) == a`\n-    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n     fn backward(start: Self, count: usize) -> Self {\n         Step::backward_checked(start, count).expect(\"overflow in `Step::backward`\")\n     }\n@@ -178,7 +175,6 @@ pub unsafe trait Step: Clone + PartialOrd + Sized {\n     /// For any `a` and `n`, where no overflow occurs:\n     ///\n     /// * `Step::backward_unchecked(a, n)` is equivalent to `Step::backward(a, n)`\n-    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n     unsafe fn backward_unchecked(start: Self, count: usize) -> Self {\n         Step::backward(start, count)\n     }\n@@ -237,7 +233,7 @@ macro_rules! step_integer_impls {\n         $(\n             #[allow(unreachable_patterns)]\n             #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-            unsafe impl Step for $u_narrower {\n+            impl Step for $u_narrower {\n                 step_identical_methods!();\n \n                 #[inline]\n@@ -269,7 +265,7 @@ macro_rules! step_integer_impls {\n \n             #[allow(unreachable_patterns)]\n             #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-            unsafe impl Step for $i_narrower {\n+            impl Step for $i_narrower {\n                 step_identical_methods!();\n \n                 #[inline]\n@@ -333,7 +329,7 @@ macro_rules! step_integer_impls {\n         $(\n             #[allow(unreachable_patterns)]\n             #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-            unsafe impl Step for $u_wider {\n+            impl Step for $u_wider {\n                 step_identical_methods!();\n \n                 #[inline]\n@@ -358,7 +354,7 @@ macro_rules! step_integer_impls {\n \n             #[allow(unreachable_patterns)]\n             #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-            unsafe impl Step for $i_wider {\n+            impl Step for $i_wider {\n                 step_identical_methods!();\n \n                 #[inline]\n@@ -408,7 +404,7 @@ step_integer_impls! {\n }\n \n #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-unsafe impl Step for char {\n+impl Step for char {\n     #[inline]\n     fn steps_between(&start: &char, &end: &char) -> Option<usize> {\n         let start = start as u32;\n@@ -512,33 +508,87 @@ macro_rules! range_incl_exact_iter_impl {\n     )*)\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step> Iterator for ops::Range<A> {\n+/// Specialization implementations for `Range`.\n+trait RangeIteratorImpl {\n+    type Item;\n+\n+    // Iterator\n+    fn spec_next(&mut self) -> Option<Self::Item>;\n+    fn spec_nth(&mut self, n: usize) -> Option<Self::Item>;\n+\n+    // DoubleEndedIterator\n+    fn spec_next_back(&mut self) -> Option<Self::Item>;\n+    fn spec_nth_back(&mut self, n: usize) -> Option<Self::Item>;\n+}\n+\n+impl<A: Step> RangeIteratorImpl for ops::Range<A> {\n     type Item = A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    default fn spec_next(&mut self) -> Option<A> {\n         if self.start < self.end {\n-            // SAFETY: just checked precondition\n-            let n = unsafe { Step::forward_unchecked(self.start.clone(), 1) };\n+            let n =\n+                Step::forward_checked(self.start.clone(), 1).expect(\"`Step` invariants not upheld\");\n             Some(mem::replace(&mut self.start, n))\n         } else {\n             None\n         }\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n+    default fn spec_nth(&mut self, n: usize) -> Option<A> {\n+        if let Some(plus_n) = Step::forward_checked(self.start.clone(), n) {\n+            if plus_n < self.end {\n+                self.start =\n+                    Step::forward_checked(plus_n.clone(), 1).expect(\"`Step` invariants not upheld\");\n+                return Some(plus_n);\n+            }\n+        }\n+\n+        self.start = self.end.clone();\n+        None\n+    }\n+\n+    #[inline]\n+    default fn spec_next_back(&mut self) -> Option<A> {\n         if self.start < self.end {\n-            let hint = Step::steps_between(&self.start, &self.end);\n-            (hint.unwrap_or(usize::MAX), hint)\n+            self.end =\n+                Step::backward_checked(self.end.clone(), 1).expect(\"`Step` invariants not upheld\");\n+            Some(self.end.clone())\n         } else {\n-            (0, Some(0))\n+            None\n         }\n     }\n \n     #[inline]\n-    fn nth(&mut self, n: usize) -> Option<A> {\n+    default fn spec_nth_back(&mut self, n: usize) -> Option<A> {\n+        if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {\n+            if minus_n > self.start {\n+                self.end =\n+                    Step::backward_checked(minus_n, 1).expect(\"`Step` invariants not upheld\");\n+                return Some(self.end.clone());\n+            }\n+        }\n+\n+        self.end = self.start.clone();\n+        None\n+    }\n+}\n+\n+impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {\n+    #[inline]\n+    fn spec_next(&mut self) -> Option<T> {\n+        if self.start < self.end {\n+            // SAFETY: just checked precondition\n+            let n = unsafe { Step::forward_unchecked(self.start.clone(), 1) };\n+            Some(mem::replace(&mut self.start, n))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn spec_nth(&mut self, n: usize) -> Option<T> {\n         if let Some(plus_n) = Step::forward_checked(self.start.clone(), n) {\n             if plus_n < self.end {\n                 // SAFETY: just checked precondition\n@@ -551,6 +601,56 @@ impl<A: Step> Iterator for ops::Range<A> {\n         None\n     }\n \n+    #[inline]\n+    fn spec_next_back(&mut self) -> Option<T> {\n+        if self.start < self.end {\n+            // SAFETY: just checked precondition\n+            self.end = unsafe { Step::backward_unchecked(self.end.clone(), 1) };\n+            Some(self.end.clone())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn spec_nth_back(&mut self, n: usize) -> Option<T> {\n+        if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {\n+            if minus_n > self.start {\n+                // SAFETY: just checked precondition\n+                self.end = unsafe { Step::backward_unchecked(minus_n, 1) };\n+                return Some(self.end.clone());\n+            }\n+        }\n+\n+        self.end = self.start.clone();\n+        None\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Step> Iterator for ops::Range<A> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        self.spec_next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.start < self.end {\n+            let hint = Step::steps_between(&self.start, &self.end);\n+            (hint.unwrap_or(usize::MAX), hint)\n+        } else {\n+            (0, Some(0))\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<A> {\n+        self.spec_nth(n)\n+    }\n+\n     #[inline]\n     fn last(mut self) -> Option<A> {\n         self.next_back()\n@@ -631,32 +731,36 @@ range_incl_exact_iter_impl! {\n impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n-        if self.start < self.end {\n-            // SAFETY: just checked precondition\n-            self.end = unsafe { Step::backward_unchecked(self.end.clone(), 1) };\n-            Some(self.end.clone())\n-        } else {\n-            None\n-        }\n+        self.spec_next_back()\n     }\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<A> {\n-        if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {\n-            if minus_n > self.start {\n-                // SAFETY: just checked precondition\n-                self.end = unsafe { Step::backward_unchecked(minus_n, 1) };\n-                return Some(self.end.clone());\n-            }\n-        }\n-\n-        self.end = self.start.clone();\n-        None\n+        self.spec_nth_back(n)\n     }\n }\n \n+// Safety:\n+// The following invariants for `Step::steps_between` exist:\n+//\n+// > * `steps_between(&a, &b) == Some(n)` only if `a <= b`\n+// >   * Note that `a <= b` does _not_ imply `steps_between(&a, &b) != None`;\n+// >     this is the case when it would require more than `usize::MAX` steps to\n+// >     get to `b`\n+// > * `steps_between(&a, &b) == None` if `a > b`\n+//\n+// The first invariant is what is generally required for `TrustedLen` to be\n+// sound. The note addendum satisfies an additional `TrustedLen` invariant.\n+//\n+// > The upper bound must only be `None` if the actual iterator length is larger\n+// > than `usize::MAX`\n+//\n+// The second invariant logically follows the first so long as the `PartialOrd`\n+// implementation is correct; regardless it is explicitly stated. If `a < b`\n+// then `(0, Some(0))` is returned by `ops::Range<A: Step>::size_hint`. As such\n+// the second invariant is upheld.\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<A: Step> TrustedLen for ops::Range<A> {}\n+unsafe impl<A: TrustedStep> TrustedLen for ops::Range<A> {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::Range<A> {}\n@@ -684,18 +788,130 @@ impl<A: Step> Iterator for ops::RangeFrom<A> {\n     }\n }\n \n+// Safety: See above implementation for `ops::Range<A>`\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A: TrustedStep> TrustedLen for ops::RangeFrom<A> {}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::RangeFrom<A> {}\n \n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<A: Step> TrustedLen for ops::RangeFrom<A> {}\n+trait RangeInclusiveIteratorImpl {\n+    type Item;\n \n-#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<A: Step> Iterator for ops::RangeInclusive<A> {\n+    // Iterator\n+    fn spec_next(&mut self) -> Option<Self::Item>;\n+    fn spec_try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>;\n+\n+    // DoubleEndedIterator\n+    fn spec_next_back(&mut self) -> Option<Self::Item>;\n+    fn spec_try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>;\n+}\n+\n+impl<A: Step> RangeInclusiveIteratorImpl for ops::RangeInclusive<A> {\n     type Item = A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    default fn spec_next(&mut self) -> Option<A> {\n+        if self.is_empty() {\n+            return None;\n+        }\n+        let is_iterating = self.start < self.end;\n+        Some(if is_iterating {\n+            let n =\n+                Step::forward_checked(self.start.clone(), 1).expect(\"`Step` invariants not upheld\");\n+            mem::replace(&mut self.start, n)\n+        } else {\n+            self.exhausted = true;\n+            self.start.clone()\n+        })\n+    }\n+\n+    #[inline]\n+    default fn spec_try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, A) -> R,\n+        R: Try<Output = B>,\n+    {\n+        if self.is_empty() {\n+            return try { init };\n+        }\n+\n+        let mut accum = init;\n+\n+        while self.start < self.end {\n+            let n =\n+                Step::forward_checked(self.start.clone(), 1).expect(\"`Step` invariants not upheld\");\n+            let n = mem::replace(&mut self.start, n);\n+            accum = f(accum, n)?;\n+        }\n+\n+        self.exhausted = true;\n+\n+        if self.start == self.end {\n+            accum = f(accum, self.start.clone())?;\n+        }\n+\n+        try { accum }\n+    }\n+\n+    #[inline]\n+    default fn spec_next_back(&mut self) -> Option<A> {\n+        if self.is_empty() {\n+            return None;\n+        }\n+        let is_iterating = self.start < self.end;\n+        Some(if is_iterating {\n+            let n =\n+                Step::backward_checked(self.end.clone(), 1).expect(\"`Step` invariants not upheld\");\n+            mem::replace(&mut self.end, n)\n+        } else {\n+            self.exhausted = true;\n+            self.end.clone()\n+        })\n+    }\n+\n+    #[inline]\n+    default fn spec_try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, A) -> R,\n+        R: Try<Output = B>,\n+    {\n+        if self.is_empty() {\n+            return try { init };\n+        }\n+\n+        let mut accum = init;\n+\n+        while self.start < self.end {\n+            let n =\n+                Step::backward_checked(self.end.clone(), 1).expect(\"`Step` invariants not upheld\");\n+            let n = mem::replace(&mut self.end, n);\n+            accum = f(accum, n)?;\n+        }\n+\n+        self.exhausted = true;\n+\n+        if self.start == self.end {\n+            accum = f(accum, self.start.clone())?;\n+        }\n+\n+        try { accum }\n+    }\n+}\n+\n+impl<T: TrustedStep> RangeInclusiveIteratorImpl for ops::RangeInclusive<T> {\n+    #[inline]\n+    fn spec_next(&mut self) -> Option<T> {\n         if self.is_empty() {\n             return None;\n         }\n@@ -710,6 +926,90 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         })\n     }\n \n+    #[inline]\n+    fn spec_try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, T) -> R,\n+        R: Try<Output = B>,\n+    {\n+        if self.is_empty() {\n+            return try { init };\n+        }\n+\n+        let mut accum = init;\n+\n+        while self.start < self.end {\n+            // SAFETY: just checked precondition\n+            let n = unsafe { Step::forward_unchecked(self.start.clone(), 1) };\n+            let n = mem::replace(&mut self.start, n);\n+            accum = f(accum, n)?;\n+        }\n+\n+        self.exhausted = true;\n+\n+        if self.start == self.end {\n+            accum = f(accum, self.start.clone())?;\n+        }\n+\n+        try { accum }\n+    }\n+\n+    #[inline]\n+    fn spec_next_back(&mut self) -> Option<T> {\n+        if self.is_empty() {\n+            return None;\n+        }\n+        let is_iterating = self.start < self.end;\n+        Some(if is_iterating {\n+            // SAFETY: just checked precondition\n+            let n = unsafe { Step::backward_unchecked(self.end.clone(), 1) };\n+            mem::replace(&mut self.end, n)\n+        } else {\n+            self.exhausted = true;\n+            self.end.clone()\n+        })\n+    }\n+\n+    #[inline]\n+    fn spec_try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, T) -> R,\n+        R: Try<Output = B>,\n+    {\n+        if self.is_empty() {\n+            return try { init };\n+        }\n+\n+        let mut accum = init;\n+\n+        while self.start < self.end {\n+            // SAFETY: just checked precondition\n+            let n = unsafe { Step::backward_unchecked(self.end.clone(), 1) };\n+            let n = mem::replace(&mut self.end, n);\n+            accum = f(accum, n)?;\n+        }\n+\n+        self.exhausted = true;\n+\n+        if self.start == self.end {\n+            accum = f(accum, self.start.clone())?;\n+        }\n+\n+        try { accum }\n+    }\n+}\n+\n+#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n+impl<A: Step> Iterator for ops::RangeInclusive<A> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        self.spec_next()\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         if self.is_empty() {\n@@ -751,32 +1051,13 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n     }\n \n     #[inline]\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Output = B>,\n     {\n-        if self.is_empty() {\n-            return try { init };\n-        }\n-\n-        let mut accum = init;\n-\n-        while self.start < self.end {\n-            // SAFETY: just checked precondition\n-            let n = unsafe { Step::forward_unchecked(self.start.clone(), 1) };\n-            let n = mem::replace(&mut self.start, n);\n-            accum = f(accum, n)?;\n-        }\n-\n-        self.exhausted = true;\n-\n-        if self.start == self.end {\n-            accum = f(accum, self.start.clone())?;\n-        }\n-\n-        try { accum }\n+        self.spec_try_fold(init, f)\n     }\n \n     #[inline]\n@@ -813,18 +1094,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n-        if self.is_empty() {\n-            return None;\n-        }\n-        let is_iterating = self.start < self.end;\n-        Some(if is_iterating {\n-            // SAFETY: just checked precondition\n-            let n = unsafe { Step::backward_unchecked(self.end.clone(), 1) };\n-            mem::replace(&mut self.end, n)\n-        } else {\n-            self.exhausted = true;\n-            self.end.clone()\n-        })\n+        self.spec_next_back()\n     }\n \n     #[inline]\n@@ -856,32 +1126,13 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     }\n \n     #[inline]\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Output = B>,\n     {\n-        if self.is_empty() {\n-            return try { init };\n-        }\n-\n-        let mut accum = init;\n-\n-        while self.start < self.end {\n-            // SAFETY: just checked precondition\n-            let n = unsafe { Step::backward_unchecked(self.end.clone(), 1) };\n-            let n = mem::replace(&mut self.end, n);\n-            accum = f(accum, n)?;\n-        }\n-\n-        self.exhausted = true;\n-\n-        if self.start == self.end {\n-            accum = f(accum, self.start.clone())?;\n-        }\n-\n-        try { accum }\n+        self.spec_try_rfold(init, f)\n     }\n \n     #[inline]\n@@ -899,8 +1150,9 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     }\n }\n \n+// Safety: See above implementation for `ops::Range<A>`\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<A: Step> TrustedLen for ops::RangeInclusive<A> {}\n+unsafe impl<A: TrustedStep> TrustedLen for ops::RangeInclusive<A> {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::RangeInclusive<A> {}"}, {"sha": "ebf37f97bc6178649deeddee6fae20f9a1539ccc", "filename": "library/core/src/iter/traits/marker.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -1,3 +1,5 @@\n+use crate::iter::Step;\n+\n /// An iterator that always continues to yield `None` when exhausted.\n ///\n /// Calling next on a fused iterator that has returned `None` once is guaranteed\n@@ -55,3 +57,18 @@ unsafe impl<I: TrustedLen + ?Sized> TrustedLen for &mut I {}\n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n #[doc(hidden)]\n pub unsafe trait InPlaceIterable: Iterator {}\n+\n+/// A type that upholds all invariants of [`Step`].\n+///\n+/// The invariants of [`Step::steps_between()`] are a superset of the invariants\n+/// of [`TrustedLen`]. As such, [`TrustedLen`] is implemented for all range\n+/// types with the same generic type argument.\n+///\n+/// # Safety\n+///\n+/// The implementation of [`Step`] for the given type must guarantee all\n+/// invariants of all methods are upheld. See the [`Step`] trait's documentation\n+/// for details. Consumers are free to rely on the invariants in unsafe code.\n+#[unstable(feature = \"trusted_step\", issue = \"85731\")]\n+#[rustc_specialization_trait]\n+pub unsafe trait TrustedStep: Step {}"}, {"sha": "ffd745a46b12c0e1091bb423ae4265f33e66380d", "filename": "library/core/src/iter/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -13,5 +13,7 @@ pub use self::exact_size::ExactSizeIterator;\n pub use self::iterator::Iterator;\n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n pub use self::marker::InPlaceIterable;\n+#[unstable(feature = \"trusted_step\", issue = \"85731\")]\n+pub use self::marker::TrustedStep;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::marker::{FusedIterator, TrustedLen};"}, {"sha": "16051b3bc36c72701cf83546a8f60cac73b5fb21", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -40,7 +40,6 @@\n #![feature(maybe_uninit_write_slice)]\n #![feature(min_specialization)]\n #![feature(step_trait)]\n-#![feature(step_trait_ext)]\n #![feature(str_internals)]\n #![feature(test)]\n #![feature(trusted_len)]"}, {"sha": "80024124dc523d4c535fff3e14945b4b62af2067", "filename": "src/test/mir-opt/remove_storage_markers.main.RemoveStorageMarkers.diff", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/src%2Ftest%2Fmir-opt%2Fremove_storage_markers.main.RemoveStorageMarkers.diff", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/src%2Ftest%2Fmir-opt%2Fremove_storage_markers.main.RemoveStorageMarkers.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_storage_markers.main.RemoveStorageMarkers.diff?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -32,6 +32,10 @@\n                   scope 5 {\n                       debug i => _15;      // in scope 5 at $DIR/remove_storage_markers.rs:8:9: 8:10\n                   }\n+                  scope 7 (inlined iter::range::<impl Iterator for std::ops::Range<i32>>::next) { // at $DIR/remove_storage_markers.rs:8:14: 8:19\n+                      debug self => _9;    // in scope 7 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+                      let mut _18: &mut std::ops::Range<i32>; // in scope 7 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+                  }\n               }\n           }\n           scope 6 (inlined <std::ops::Range<i32> as IntoIterator>::into_iter) { // at $DIR/remove_storage_markers.rs:8:14: 8:19\n@@ -61,19 +65,15 @@\n -         StorageLive(_10);                // scope 3 at $DIR/remove_storage_markers.rs:8:14: 8:19\n           _10 = &mut _4;                   // scope 3 at $DIR/remove_storage_markers.rs:8:14: 8:19\n           _9 = &mut (*_10);                // scope 3 at $DIR/remove_storage_markers.rs:8:14: 8:19\n-          _8 = <std::ops::Range<i32> as Iterator>::next(move _9) -> bb2; // scope 3 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+-         StorageLive(_18);                // scope 7 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+          _18 = &mut (*_9);                // scope 7 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+          _8 = <std::ops::Range<i32> as iter::range::RangeIteratorImpl>::spec_next(move _18) -> bb4; // scope 7 at $DIR/remove_storage_markers.rs:8:14: 8:19\n                                            // mir::Constant\n                                            // + span: $DIR/remove_storage_markers.rs:8:14: 8:19\n-                                           // + literal: Const { ty: for<'r> fn(&'r mut std::ops::Range<i32>) -> std::option::Option<<std::ops::Range<i32> as std::iter::Iterator>::Item> {<std::ops::Range<i32> as std::iter::Iterator>::next}, val: Value(Scalar(<ZST>)) }\n+                                           // + literal: Const { ty: for<'r> fn(&'r mut std::ops::Range<i32>) -> std::option::Option<<std::ops::Range<i32> as std::iter::range::RangeIteratorImpl>::Item> {<std::ops::Range<i32> as std::iter::range::RangeIteratorImpl>::spec_next}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb2: {\n--         StorageDead(_9);                 // scope 3 at $DIR/remove_storage_markers.rs:8:18: 8:19\n-          _11 = discriminant(_8);          // scope 3 at $DIR/remove_storage_markers.rs:8:9: 8:10\n-          switchInt(move _11) -> [0_isize: bb3, otherwise: bb4]; // scope 3 at $DIR/remove_storage_markers.rs:8:9: 8:10\n-      }\n-  \n-      bb3: {\n           _0 = const ();                   // scope 3 at $DIR/remove_storage_markers.rs:8:5: 10:6\n -         StorageDead(_10);                // scope 3 at $DIR/remove_storage_markers.rs:8:18: 8:19\n -         StorageDead(_8);                 // scope 3 at $DIR/remove_storage_markers.rs:8:18: 8:19\n@@ -85,7 +85,7 @@\n           return;                          // scope 0 at $DIR/remove_storage_markers.rs:11:2: 11:2\n       }\n   \n-      bb4: {\n+      bb3: {\n -         StorageLive(_12);                // scope 3 at $DIR/remove_storage_markers.rs:8:9: 8:10\n           _12 = ((_8 as Some).0: i32);     // scope 3 at $DIR/remove_storage_markers.rs:8:9: 8:10\n -         StorageLive(_13);                // scope 4 at $DIR/remove_storage_markers.rs:8:9: 8:10\n@@ -111,5 +111,12 @@\n -         StorageDead(_6);                 // scope 2 at $DIR/remove_storage_markers.rs:10:5: 10:6\n           goto -> bb1;                     // scope 2 at $DIR/remove_storage_markers.rs:8:5: 10:6\n       }\n+  \n+      bb4: {\n+-         StorageDead(_18);                // scope 7 at $DIR/remove_storage_markers.rs:8:14: 8:19\n+-         StorageDead(_9);                 // scope 3 at $DIR/remove_storage_markers.rs:8:18: 8:19\n+          _11 = discriminant(_8);          // scope 3 at $DIR/remove_storage_markers.rs:8:9: 8:10\n+          switchInt(move _11) -> [0_isize: bb2, otherwise: bb3]; // scope 3 at $DIR/remove_storage_markers.rs:8:9: 8:10\n+      }\n   }\n   "}, {"sha": "45dcb74a6e05c41cbbc263b916c9f642aa5d8228", "filename": "src/test/ui/impl-trait/example-calendar.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a72afa7dd5689da1844695086d1f89130956a88/src%2Ftest%2Fui%2Fimpl-trait%2Fexample-calendar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a72afa7dd5689da1844695086d1f89130956a88/src%2Ftest%2Fui%2Fimpl-trait%2Fexample-calendar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fexample-calendar.rs?ref=9a72afa7dd5689da1844695086d1f89130956a88", "patch": "@@ -3,7 +3,6 @@\n \n #![feature(fn_traits,\n            step_trait,\n-           step_trait_ext,\n            unboxed_closures,\n )]\n \n@@ -157,7 +156,7 @@ impl<'a, 'b> std::ops::Add<&'b NaiveDate> for &'a NaiveDate {\n     }\n }\n \n-unsafe impl std::iter::Step for NaiveDate {\n+impl std::iter::Step for NaiveDate {\n     fn steps_between(_: &Self, _: &Self) -> Option<usize> {\n         unimplemented!()\n     }"}]}