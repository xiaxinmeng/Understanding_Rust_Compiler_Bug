{"sha": "92f13d823138ce3a22acef0db7818627ad5dee27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZjEzZDgyMzEzOGNlM2EyMmFjZWYwZGI3ODE4NjI3YWQ1ZGVlMjc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2014-11-19T08:57:34Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2014-11-19T08:57:34Z"}, "message": "boxvec", "tree": {"sha": "f63f0cbd99984aa384dc258d6ec5601f37dc25d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f63f0cbd99984aa384dc258d6ec5601f37dc25d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92f13d823138ce3a22acef0db7818627ad5dee27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92f13d823138ce3a22acef0db7818627ad5dee27", "html_url": "https://github.com/rust-lang/rust/commit/92f13d823138ce3a22acef0db7818627ad5dee27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92f13d823138ce3a22acef0db7818627ad5dee27/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6db0039e90c09e59d8bedef2c0a5e0d811787a69", "url": "https://api.github.com/repos/rust-lang/rust/commits/6db0039e90c09e59d8bedef2c0a5e0d811787a69", "html_url": "https://github.com/rust-lang/rust/commit/6db0039e90c09e59d8bedef2c0a5e0d811787a69"}], "stats": {"total": 95, "additions": 92, "deletions": 3}, "files": [{"sha": "468da46f028a0f283b8eb16ed4dff4c75ad8291a", "filename": "examples/boxvec.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/92f13d823138ce3a22acef0db7818627ad5dee27/examples%2Fboxvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f13d823138ce3a22acef0db7818627ad5dee27/examples%2Fboxvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/examples%2Fboxvec.rs?ref=92f13d823138ce3a22acef0db7818627ad5dee27", "patch": "@@ -0,0 +1,12 @@\n+#![feature(phase)]\n+\n+#[phase(plugin)]\n+extern crate rust_clippy;\n+\n+pub fn test(foo: Box<Vec<uint>>) {\n+    println!(\"{}\", foo)\n+}\n+\n+fn main(){\n+    test(box Vec::new());\n+}\n\\ No newline at end of file"}, {"sha": "934232dceec1197b855527db769e2e52d250081b", "filename": "src/lib.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/92f13d823138ce3a22acef0db7818627ad5dee27/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f13d823138ce3a22acef0db7818627ad5dee27/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=92f13d823138ce3a22acef0db7818627ad5dee27", "patch": "@@ -1,3 +1,21 @@\n-#[test]\n-fn it_works() {\n-}\n+#![feature(globs, phase, plugin_registrar)] \n+\n+\n+#[phase(plugin,link)]\n+extern crate syntax;\n+#[phase(plugin, link)]\n+extern crate rustc;\n+\n+\n+\n+use rustc::plugin::Registry;\n+use rustc::lint::LintPassObject;\n+\n+pub mod types;\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    //reg.register_syntax_extension(intern(\"jstraceable\"), base::ItemDecorator(box expand_jstraceable));\n+    //reg.register_macro(\"factorial\", expand)\n+    reg.register_lint_pass(box types::TypePass as LintPassObject);\n+}\n\\ No newline at end of file"}, {"sha": "ffea017ec00617f11f33b4a5d7ba2c8046254129", "filename": "src/types.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/92f13d823138ce3a22acef0db7818627ad5dee27/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f13d823138ce3a22acef0db7818627ad5dee27/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=92f13d823138ce3a22acef0db7818627ad5dee27", "patch": "@@ -0,0 +1,59 @@\n+\n+\n+use syntax::ptr::P;\n+use syntax::ast;\n+use syntax::ast::*;\n+use rustc::lint::{Context, LintPass, LintArray, Lint, Level};\n+use syntax::codemap::Span;\n+\n+\n+pub struct TypePass;\n+\n+declare_lint!(CLIPPY_BOX_VEC, Warn,\n+              \"Warn on usage of Box<Vec<T>>\")\n+\n+\n+pub fn match_ty_unwrap<'a>(ty: &'a Ty, segments: &[&str]) -> Option<&'a [P<Ty>]> {\n+    match ty.node {\n+        TyPath(Path {segments: ref seg, ..}, _, _) => {\n+            // So ast::Path isn't the full path, just the tokens that were provided.\n+            // I could muck around with the maps and find the full path\n+            // however the more efficient way is to simply reverse the iterators and zip them\n+            // which will compare them in reverse until one of them runs out of segments\n+            if seg.iter().rev().zip(segments.iter().rev()).all(|(a,b)| a.identifier.as_str() == *b) {\n+                match seg.as_slice().last() {\n+                    Some(&PathSegment {parameters: AngleBracketedParameters(ref a), ..}) => {\n+                        Some(a.types.as_slice())\n+                    }\n+                    _ => None\n+                }\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None\n+    }\n+}\n+\n+\n+fn span_note_and_lint(cx: &Context, lint: &'static Lint, span: Span, msg: &str, note: &str) {\n+    cx.span_lint(lint, span, msg);\n+    if cx.current_level(lint) != Level::Allow {\n+        cx.sess().span_note(span, note);\n+    }\n+}\n+impl LintPass for TypePass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(CLIPPY_BOX_VEC)\n+    }\n+\n+    fn check_ty(&mut self, cx: &Context, ty: &ast::Ty) {\n+        match_ty_unwrap(ty, &[\"std\", \"boxed\", \"Box\"]).and_then(|t| t.head())\n+          .map(|t| match_ty_unwrap(&**t, &[\"std\", \"vec\", \"Vec\"]))\n+          .map(|_| {\n+            span_note_and_lint(cx, CLIPPY_BOX_VEC, ty.span,\n+                              \"Detected Box<Vec<T>>. Did you mean to use Vec<T>?\",\n+                              \"Vec<T> is already on the heap, Box<Vec<T>> makes an extra allocation\");\n+          });\n+    }\n+}\n\\ No newline at end of file"}]}