{"sha": "d9277b163c36448c5fbc39fa089a78256b45ffc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5Mjc3YjE2M2MzNjQ0OGM1ZmJjMzlmYTA4OWE3ODI1NmI0NWZmYzE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-09T12:20:22Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:54Z"}, "message": "trans: Make everything used from within at_start Builder-friendly.", "tree": {"sha": "13cb534361a3c54e13228a3fae4b5c0c812dbf5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13cb534361a3c54e13228a3fae4b5c0c812dbf5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9277b163c36448c5fbc39fa089a78256b45ffc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9277b163c36448c5fbc39fa089a78256b45ffc1", "html_url": "https://github.com/rust-lang/rust/commit/d9277b163c36448c5fbc39fa089a78256b45ffc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9277b163c36448c5fbc39fa089a78256b45ffc1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82fad1dfc70c641c28f8a422934b89bf983925b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/82fad1dfc70c641c28f8a422934b89bf983925b8", "html_url": "https://github.com/rust-lang/rust/commit/82fad1dfc70c641c28f8a422934b89bf983925b8"}], "stats": {"total": 311, "additions": 169, "deletions": 142}, "files": [{"sha": "192522214e604115101f3eb20d3964d9f6fa6474", "filename": "src/librustc_trans/trans/abi.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fabi.rs?ref=d9277b163c36448c5fbc39fa089a78256b45ffc1", "patch": "@@ -10,9 +10,8 @@\n \n use llvm::{self, ValueRef};\n use trans::base;\n-use trans::build::B;\n use trans::builder::Builder;\n-use trans::common::{type_is_fat_ptr, Block};\n+use trans::common::{type_is_fat_ptr, BlockAndBuilder};\n use trans::context::CrateContext;\n use trans::cabi_x86;\n use trans::cabi_x86_64;\n@@ -169,18 +168,16 @@ impl ArgType {\n         }\n     }\n \n-    pub fn store_fn_arg(&self, bcx: Block, idx: &mut usize, dst: ValueRef) {\n+    pub fn store_fn_arg(&self, bcx: &BlockAndBuilder, idx: &mut usize, dst: ValueRef) {\n         if self.pad.is_some() {\n             *idx += 1;\n         }\n         if self.is_ignore() {\n             return;\n         }\n-        let val = llvm::get_param(bcx.fcx.llfn, *idx as c_uint);\n+        let val = llvm::get_param(bcx.fcx().llfn, *idx as c_uint);\n         *idx += 1;\n-        if !bcx.unreachable.get() {\n-            self.store(&B(bcx), val, dst);\n-        }\n+        self.store(bcx, val, dst);\n     }\n }\n "}, {"sha": "45a1236647e406ff71a74be26ffd286a30c24aa7", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=d9277b163c36448c5fbc39fa089a78256b45ffc1", "patch": "@@ -1065,6 +1065,15 @@ pub fn num_args(r: &Repr, discr: Disr) -> usize {\n /// Access a field, at a point when the value's case is known.\n pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n                                    val: MaybeSizedValue, discr: Disr, ix: usize) -> ValueRef {\n+    trans_field_ptr_builder(&bcx.build(), r, val, discr, ix)\n+}\n+\n+/// Access a field, at a point when the value's case is known.\n+pub fn trans_field_ptr_builder<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n+                                           r: &Repr<'tcx>,\n+                                           val: MaybeSizedValue,\n+                                           discr: Disr, ix: usize)\n+                                           -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n     // someday), it will need to return a possibly-new bcx as well.\n@@ -1087,13 +1096,15 @@ pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n             assert_eq!(machine::llsize_of_alloc(bcx.ccx(), ty), 0);\n             // The contents of memory at this pointer can't matter, but use\n             // the value that's \"reasonable\" in case of pointer comparison.\n-            PointerCast(bcx, val.value, ty.ptr_to())\n+            if bcx.is_unreachable() { return C_undef(ty.ptr_to()); }\n+            bcx.pointercast(val.value, ty.ptr_to())\n         }\n         RawNullablePointer { nndiscr, nnty, .. } => {\n             assert_eq!(ix, 0);\n             assert_eq!(discr, nndiscr);\n             let ty = type_of::type_of(bcx.ccx(), nnty);\n-            PointerCast(bcx, val.value, ty.ptr_to())\n+            if bcx.is_unreachable() { return C_undef(ty.ptr_to()); }\n+            bcx.pointercast(val.value, ty.ptr_to())\n         }\n         StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n             assert_eq!(discr, nndiscr);\n@@ -1102,33 +1113,39 @@ pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n     }\n }\n \n-pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, val: MaybeSizedValue,\n-                                    ix: usize, needs_cast: bool) -> ValueRef {\n+fn struct_field_ptr<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n+                                st: &Struct<'tcx>, val: MaybeSizedValue,\n+                                ix: usize, needs_cast: bool) -> ValueRef {\n     let ccx = bcx.ccx();\n+    let fty = st.fields[ix];\n+    let ll_fty = type_of::in_memory_type_of(bcx.ccx(), fty);\n+    if bcx.is_unreachable() {\n+        return C_undef(ll_fty.ptr_to());\n+    }\n+\n     let ptr_val = if needs_cast {\n         let fields = st.fields.iter().map(|&ty| {\n             type_of::in_memory_type_of(ccx, ty)\n         }).collect::<Vec<_>>();\n         let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n-        PointerCast(bcx, val.value, real_ty.ptr_to())\n+        bcx.pointercast(val.value, real_ty.ptr_to())\n     } else {\n         val.value\n     };\n \n-    let fty = st.fields[ix];\n     // Simple case - we can just GEP the field\n     //   * First field - Always aligned properly\n     //   * Packed struct - There is no alignment padding\n     //   * Field is sized - pointer is properly aligned already\n     if ix == 0 || st.packed || type_is_sized(bcx.tcx(), fty) {\n-        return StructGEP(bcx, ptr_val, ix);\n+        return bcx.struct_gep(ptr_val, ix);\n     }\n \n     // If the type of the last field is [T] or str, then we don't need to do\n     // any adjusments\n     match fty.sty {\n         ty::TySlice(..) | ty::TyStr => {\n-            return StructGEP(bcx, ptr_val, ix);\n+            return bcx.struct_gep(ptr_val, ix);\n         }\n         _ => ()\n     }\n@@ -1137,7 +1154,7 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n     if !val.has_meta() {\n         debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n                ix, Value(ptr_val));\n-        return StructGEP(bcx, ptr_val, ix);\n+        return bcx.struct_gep(ptr_val, ix);\n     }\n \n     let dbloc = DebugLoc::None;\n@@ -1178,22 +1195,21 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n     //   (unaligned offset + (align - 1)) & -align\n \n     // Calculate offset\n-    let align_sub_1 = Sub(bcx, align, C_uint(bcx.ccx(), 1u64), dbloc);\n-    let offset = And(bcx,\n-                     Add(bcx, unaligned_offset, align_sub_1, dbloc),\n-                     Neg(bcx, align, dbloc),\n-                     dbloc);\n+    dbloc.apply(bcx.fcx());\n+    let align_sub_1 = bcx.sub(align, C_uint(bcx.ccx(), 1u64));\n+    let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n+                         bcx.neg(align));\n \n     debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n \n     // Cast and adjust pointer\n-    let byte_ptr = PointerCast(bcx, ptr_val, Type::i8p(bcx.ccx()));\n-    let byte_ptr = GEP(bcx, byte_ptr, &[offset]);\n+    let byte_ptr = bcx.pointercast(ptr_val, Type::i8p(bcx.ccx()));\n+    let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n \n     // Finally, cast back to the type expected\n     let ll_fty = type_of::in_memory_type_of(bcx.ccx(), fty);\n     debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n-    PointerCast(bcx, byte_ptr, ll_fty.ptr_to())\n+    bcx.pointercast(byte_ptr, ll_fty.ptr_to())\n }\n \n pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n@@ -1284,7 +1300,8 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 }\n             ));\n             bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {\n-                let ptr = struct_field_ptr(variant_cx, st, MaybeSizedValue::sized(value),\n+                let ptr = struct_field_ptr(&variant_cx.build(), st,\n+                                           MaybeSizedValue::sized(value),\n                                            (st.fields.len() - 1), false);\n                 datum::Datum::new(ptr, ptr_ty, datum::Lvalue::new(\"adt::trans_drop_flag_ptr\"))\n                     .store_to(variant_cx, scratch.val)"}, {"sha": "6add4fee56750de96aceacbc11041ee11187e018", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=d9277b163c36448c5fbc39fa089a78256b45ffc1", "patch": "@@ -911,33 +911,43 @@ pub fn load_if_immediate<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, t: Ty<'\n /// differs from the type used for SSA values. Also handles various special cases where the type\n /// gives us better information about what we are loading.\n pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n-    if cx.unreachable.get() || type_is_zero_size(cx.ccx(), t) {\n+    if cx.unreachable.get() {\n         return C_undef(type_of::type_of(cx.ccx(), t));\n     }\n+    load_ty_builder(&B(cx), ptr, t)\n+}\n+\n+pub fn load_ty_builder<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n+    let ccx = b.ccx;\n+    if type_is_zero_size(ccx, t) {\n+        return C_undef(type_of::type_of(ccx, t));\n+    }\n \n     unsafe {\n         let global = llvm::LLVMIsAGlobalVariable(ptr);\n         if !global.is_null() && llvm::LLVMIsGlobalConstant(global) == llvm::True {\n             let val = llvm::LLVMGetInitializer(global);\n             if !val.is_null() {\n-                return to_immediate(cx, val, t);\n+                if t.is_bool() {\n+                    return llvm::LLVMConstTrunc(val, Type::i1(ccx).to_ref());\n+                }\n+                return val;\n             }\n         }\n     }\n \n-    let val = if t.is_bool() {\n-        LoadRangeAssert(cx, ptr, 0, 2, llvm::False)\n+    if t.is_bool() {\n+        b.trunc(b.load_range_assert(ptr, 0, 2, llvm::False), Type::i1(ccx))\n     } else if t.is_char() {\n         // a char is a Unicode codepoint, and so takes values from 0\n         // to 0x10FFFF inclusive only.\n-        LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, llvm::False)\n-    } else if (t.is_region_ptr() || t.is_unique()) && !common::type_is_fat_ptr(cx.tcx(), t) {\n-        LoadNonNull(cx, ptr)\n+        b.load_range_assert(ptr, 0, 0x10FFFF + 1, llvm::False)\n+    } else if (t.is_region_ptr() || t.is_unique()) &&\n+              !common::type_is_fat_ptr(ccx.tcx(), t) {\n+        b.load_nonnull(ptr)\n     } else {\n-        Load(cx, ptr)\n-    };\n-\n-    to_immediate(cx, val, t)\n+        b.load(ptr)\n+    }\n }\n \n /// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n@@ -1644,13 +1654,14 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n                                                                    uninit_reason,\n                                                                    arg_scope_id, |bcx, dst| {\n                         debug!(\"FunctionContext::bind_args: {:?}: {:?}\", hir_arg, arg_ty);\n+                        let b = &bcx.build();\n                         if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n                             let meta = &self.fn_ty.args[idx];\n                             idx += 1;\n-                            arg.store_fn_arg(bcx, &mut llarg_idx, expr::get_dataptr(bcx, dst));\n-                            meta.store_fn_arg(bcx, &mut llarg_idx, expr::get_meta(bcx, dst));\n+                            arg.store_fn_arg(b, &mut llarg_idx, expr::get_dataptr(bcx, dst));\n+                            meta.store_fn_arg(b, &mut llarg_idx, expr::get_meta(bcx, dst));\n                         } else {\n-                            arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n+                            arg.store_fn_arg(b, &mut llarg_idx, dst);\n                         }\n                         bcx\n                     }))\n@@ -1672,13 +1683,14 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n                     for (j, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n                         let dst = StructGEP(bcx, llval, j);\n                         let arg = &self.fn_ty.args[idx];\n+                        let b = &bcx.build();\n                         if common::type_is_fat_ptr(bcx.tcx(), tupled_arg_ty) {\n                             let meta = &self.fn_ty.args[idx];\n                             idx += 1;\n-                            arg.store_fn_arg(bcx, &mut llarg_idx, expr::get_dataptr(bcx, dst));\n-                            meta.store_fn_arg(bcx, &mut llarg_idx, expr::get_meta(bcx, dst));\n+                            arg.store_fn_arg(b, &mut llarg_idx, expr::get_dataptr(bcx, dst));\n+                            meta.store_fn_arg(b, &mut llarg_idx, expr::get_meta(bcx, dst));\n                         } else {\n-                            arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n+                            arg.store_fn_arg(b, &mut llarg_idx, dst);\n                         }\n                     }\n                     bcx\n@@ -2024,13 +2036,14 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let lldestptr = adt::trans_field_ptr(bcx, &repr, dest_val, Disr::from(disr), i);\n             let arg = &fcx.fn_ty.args[arg_idx];\n             arg_idx += 1;\n+            let b = &bcx.build();\n             if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n                 let meta = &fcx.fn_ty.args[arg_idx];\n                 arg_idx += 1;\n-                arg.store_fn_arg(bcx, &mut llarg_idx, expr::get_dataptr(bcx, lldestptr));\n-                meta.store_fn_arg(bcx, &mut llarg_idx, expr::get_meta(bcx, lldestptr));\n+                arg.store_fn_arg(b, &mut llarg_idx, expr::get_dataptr(bcx, lldestptr));\n+                meta.store_fn_arg(b, &mut llarg_idx, expr::get_meta(bcx, lldestptr));\n             } else {\n-                arg.store_fn_arg(bcx, &mut llarg_idx, lldestptr);\n+                arg.store_fn_arg(b, &mut llarg_idx, lldestptr);\n             }\n         }\n         adt::trans_set_discr(bcx, &repr, dest, disr);"}, {"sha": "2036feb31a25bcd84975e46c6a7bb73c6099f46a", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=d9277b163c36448c5fbc39fa089a78256b45ffc1", "patch": "@@ -53,7 +53,7 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let llenv = if kind == ty::ClosureKind::FnOnce && !env_arg.is_indirect() {\n         let closure_ty = node_id_type(bcx, id);\n         let llenv = rvalue_scratch_datum(bcx, closure_ty, \"closure_env\").val;\n-        env_arg.store_fn_arg(bcx, &mut env_idx, llenv);\n+        env_arg.store_fn_arg(&bcx.build(), &mut env_idx, llenv);\n         llenv\n     } else {\n         get_param(bcx.fcx.llfn, env_idx as c_uint)\n@@ -410,7 +410,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n                                                 InitAlloca::Dropped,\n                                                 self_scope_id, |bcx, llval| {\n             let mut llarg_idx = self_idx;\n-            env_arg.store_fn_arg(bcx, &mut llarg_idx, llval);\n+            env_arg.store_fn_arg(&bcx.build(), &mut llarg_idx, llval);\n             bcx.fcx.schedule_lifetime_end(self_scope_id, llval);\n             bcx\n         })).val"}, {"sha": "db06b2352fd359c37fb31773a14519c3d7e40055", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=d9277b163c36448c5fbc39fa089a78256b45ffc1", "patch": "@@ -688,6 +688,10 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n \n     // Methods delegated to bcx\n \n+    pub fn is_unreachable(&self) -> bool {\n+        self.bcx.unreachable.get()\n+    }\n+\n     pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {\n         self.bcx.ccx()\n     }"}, {"sha": "4ca5fb07c98259a68237af43b58b4fda4dbc782d", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=d9277b163c36448c5fbc39fa089a78256b45ffc1", "patch": "@@ -371,7 +371,8 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n }\n \n-pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n+pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n+                                         t: Ty<'tcx>, info: ValueRef)\n                                          -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, Value(info));\n@@ -385,6 +386,10 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n         let align = C_uint(bcx.ccx(), align);\n         return (size, align);\n     }\n+    if bcx.is_unreachable() {\n+        let llty = Type::int(bcx.ccx());\n+        return (C_undef(llty), C_undef(llty));\n+    }\n     match t.sty {\n         ty::TyStruct(def, substs) => {\n             let ccx = bcx.ccx();\n@@ -407,8 +412,6 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             let field_ty = monomorphize::field_ty(bcx.tcx(), substs, last_field);\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n-            let dbloc = DebugLoc::None;\n-\n             // FIXME (#26403, #27023): We should be adding padding\n             // to `sized_size` (to accommodate the `unsized_align`\n             // required of the unsized field that follows) before\n@@ -417,14 +420,14 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             // here. But this is where the add would go.)\n \n             // Return the sum of sizes and max of aligns.\n-            let mut size = Add(bcx, sized_size, unsized_size, dbloc);\n+            let mut size = bcx.add(sized_size, unsized_size);\n \n             // Issue #27023: If there is a drop flag, *now* we add 1\n             // to the size.  (We can do this without adding any\n             // padding because drop flags do not have any alignment\n             // constraints.)\n             if sizing_type.needs_drop_flag() {\n-                size = Add(bcx, size, C_uint(bcx.ccx(), 1_u64), dbloc);\n+                size = bcx.add(size, C_uint(bcx.ccx(), 1_u64));\n             }\n \n             // Choose max of two known alignments (combined value must\n@@ -435,14 +438,9 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n                     // pick the correct alignment statically.\n                     C_uint(ccx, std::cmp::max(sized_align, unsized_align))\n                 }\n-                _ => Select(bcx,\n-                            ICmp(bcx,\n-                                 llvm::IntUGT,\n-                                 sized_align,\n-                                 unsized_align,\n-                                 dbloc),\n-                            sized_align,\n-                            unsized_align)\n+                _ => bcx.select(bcx.icmp(llvm::IntUGT, sized_align, unsized_align),\n+                                sized_align,\n+                                unsized_align)\n             };\n \n             // Issue #27023: must add any necessary padding to `size`\n@@ -456,19 +454,18 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             //\n             //   `(size + (align-1)) & -align`\n \n-            let addend = Sub(bcx, align, C_uint(bcx.ccx(), 1_u64), dbloc);\n-            let size = And(\n-                bcx, Add(bcx, size, addend, dbloc), Neg(bcx, align, dbloc), dbloc);\n+            let addend = bcx.sub(align, C_uint(bcx.ccx(), 1_u64));\n+            let size = bcx.and(bcx.add(size, addend), bcx.neg(align));\n \n             (size, align)\n         }\n         ty::TyTrait(..) => {\n             // info points to the vtable and the second entry in the vtable is the\n             // dynamic size of the object.\n-            let info = PointerCast(bcx, info, Type::int(bcx.ccx()).ptr_to());\n-            let size_ptr = GEPi(bcx, info, &[1]);\n-            let align_ptr = GEPi(bcx, info, &[2]);\n-            (Load(bcx, size_ptr), Load(bcx, align_ptr))\n+            let info = bcx.pointercast(info, Type::int(bcx.ccx()).ptr_to());\n+            let size_ptr = bcx.gepi(info, &[1]);\n+            let align_ptr = bcx.gepi(info, &[2]);\n+            (bcx.load(size_ptr), bcx.load(align_ptr))\n         }\n         ty::TySlice(_) | ty::TyStr => {\n             let unit_ty = t.sequence_element_type(bcx.tcx());\n@@ -477,7 +474,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             let llunit_ty = sizing_type_of(bcx.ccx(), unit_ty);\n             let unit_align = llalign_of_min(bcx.ccx(), llunit_ty);\n             let unit_size = llsize_of_alloc(bcx.ccx(), llunit_ty);\n-            (Mul(bcx, info, C_uint(bcx.ccx(), unit_size), DebugLoc::None),\n+            (bcx.mul(info, C_uint(bcx.ccx(), unit_size)),\n              C_uint(bcx.ccx(), unit_align))\n         }\n         _ => bcx.sess().bug(&format!(\"Unexpected unsized type, found {}\", t))\n@@ -522,7 +519,8 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n                     let bcx = drop_ty(bcx, v0, content_ty, DebugLoc::None);\n                     let info = expr::get_meta(bcx, v0);\n                     let info = Load(bcx, info);\n-                    let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n+                    let (llsize, llalign) =\n+                        size_and_align_of_dst(&bcx.build(), content_ty, info);\n \n                     // `Box<ZeroSizeType>` does not allocate.\n                     let needs_free = ICmp(bcx,"}, {"sha": "736803c573e989a045b08b4c64eecd0a87040a70", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=d9277b163c36448c5fbc39fa089a78256b45ffc1", "patch": "@@ -430,7 +430,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"size_of_val\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             if !type_is_sized(tcx, tp_ty) {\n-                let (llsize, _) = glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n+                let (llsize, _) =\n+                    glue::size_and_align_of_dst(&bcx.build(), tp_ty, llargs[1]);\n                 llsize\n             } else {\n                 let lltp_ty = type_of::type_of(ccx, tp_ty);\n@@ -444,7 +445,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"min_align_of_val\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             if !type_is_sized(tcx, tp_ty) {\n-                let (_, llalign) = glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n+                let (_, llalign) =\n+                    glue::size_and_align_of_dst(&bcx.build(), tp_ty, llargs[1]);\n                 llalign\n             } else {\n                 C_uint(ccx, type_of::align_of(ccx, tp_ty))"}, {"sha": "0128cceab1e6b46c6096c0182f6e0252171ce6c7", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=d9277b163c36448c5fbc39fa089a78256b45ffc1", "patch": "@@ -26,7 +26,7 @@ use trans::glue;\n use trans::type_::Type;\n \n use super::{MirContext, drop};\n-use super::lvalue::LvalueRef;\n+use super::lvalue::{LvalueRef, load_fat_ptr};\n use super::operand::OperandRef;\n use super::operand::OperandValue::{self, FatPtr, Immediate, Ref};\n \n@@ -478,13 +478,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let base_repr = adt::represent_type(bcx.ccx(), lv_ty);\n         let base = adt::MaybeSizedValue::sized(lv.llval);\n         for (n, &ty) in result_types.iter().enumerate() {\n-            let ptr = bcx.with_block(|bcx| {\n-                adt::trans_field_ptr(bcx, &base_repr, base, Disr(0), n)\n-            });\n+            let ptr = adt::trans_field_ptr_builder(bcx, &base_repr, base, Disr(0), n);\n             let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n-                let (lldata, llextra) = bcx.with_block(|bcx| {\n-                    base::load_fat_ptr(bcx, ptr, ty)\n-                });\n+                let (lldata, llextra) = load_fat_ptr(bcx, ptr);\n                 FatPtr(lldata, llextra)\n             } else {\n                 // Don't bother loading the value, trans_argument will."}, {"sha": "b6f942c4637e3a383c41ce0eb8414aef59e34a19", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=d9277b163c36448c5fbc39fa089a78256b45ffc1", "patch": "@@ -12,8 +12,10 @@ use llvm::ValueRef;\n use rustc::middle::ty::{self, Ty, TypeFoldable};\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n+use trans::abi;\n use trans::adt;\n use trans::base;\n+use trans::builder::Builder;\n use trans::common::{self, BlockAndBuilder};\n use trans::consts;\n use trans::machine;\n@@ -54,6 +56,18 @@ impl<'tcx> LvalueRef<'tcx> {\n     }\n }\n \n+pub fn get_meta(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n+    b.struct_gep(fat_ptr, abi::FAT_PTR_EXTRA)\n+}\n+\n+pub fn get_dataptr(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n+    b.struct_gep(fat_ptr, abi::FAT_PTR_ADDR)\n+}\n+\n+pub fn load_fat_ptr(b: &Builder, fat_ptr: ValueRef) -> (ValueRef, ValueRef) {\n+    (b.load(get_dataptr(b, fat_ptr)), b.load(get_meta(b, fat_ptr)))\n+}\n+\n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn lvalue_len(&mut self,\n                       bcx: &BlockAndBuilder<'bcx, 'tcx>,\n@@ -130,14 +144,12 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let (llprojected, llextra) = match projection.elem {\n                     mir::ProjectionElem::Deref => {\n                         let base_ty = tr_base.ty.to_ty(tcx);\n-                        bcx.with_block(|bcx| {\n-                            if common::type_is_sized(tcx, projected_ty.to_ty(tcx)) {\n-                                (base::load_ty(bcx, tr_base.llval, base_ty),\n-                                 ptr::null_mut())\n-                            } else {\n-                                base::load_fat_ptr(bcx, tr_base.llval, base_ty)\n-                            }\n-                        })\n+                        if common::type_is_sized(tcx, projected_ty.to_ty(tcx)) {\n+                            (base::load_ty_builder(bcx, tr_base.llval, base_ty),\n+                             ptr::null_mut())\n+                        } else {\n+                            load_fat_ptr(bcx, tr_base.llval)\n+                        }\n                     }\n                     mir::ProjectionElem::Field(ref field, _) => {\n                         let base_ty = tr_base.ty.to_ty(tcx);\n@@ -153,9 +165,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         } else {\n                             adt::MaybeSizedValue::unsized_(tr_base.llval, tr_base.llextra)\n                         };\n-                        let llprojected = bcx.with_block(|bcx| {\n-                            adt::trans_field_ptr(bcx, &base_repr, base, Disr(discr), field.index())\n-                        });\n+                        let llprojected = adt::trans_field_ptr_builder(bcx, &base_repr, base,\n+                                                                       Disr(discr), field.index());\n                         let llextra = if is_sized {\n                             ptr::null_mut()\n                         } else {"}, {"sha": "9df2cb712b14fb2c4356197c52c47a4741d51487", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=d9277b163c36448c5fbc39fa089a78256b45ffc1", "patch": "@@ -14,14 +14,12 @@ use middle::ty;\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n use trans::base;\n-use trans::build;\n use trans::common::{self, Block, BlockAndBuilder, FunctionContext};\n-use trans::expr;\n \n use std::ops::Deref;\n use std::rc::Rc;\n \n-use self::lvalue::LvalueRef;\n+use self::lvalue::{LvalueRef, get_dataptr, get_meta};\n use self::operand::OperandRef;\n \n #[derive(Clone)]\n@@ -185,26 +183,25 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                 _ => unreachable!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let llval = bcx.with_block(|bcx| {\n-                let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n-                for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n-                    let dst = build::StructGEP(bcx, lltemp, i);\n-                    let arg = &fcx.fn_ty.args[idx];\n+            let lltemp = bcx.with_block(|bcx| {\n+                base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index))\n+            });\n+            for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n+                let dst = bcx.struct_gep(lltemp, i);\n+                let arg = &fcx.fn_ty.args[idx];\n                     idx += 1;\n-                    if common::type_is_fat_ptr(tcx, tupled_arg_ty) {\n+                if common::type_is_fat_ptr(tcx, tupled_arg_ty) {\n                         // We pass fat pointers as two words, but inside the tuple\n                         // they are the two sub-fields of a single aggregate field.\n-                        let meta = &fcx.fn_ty.args[idx];\n-                        idx += 1;\n-                        arg.store_fn_arg(bcx, &mut llarg_idx, expr::get_dataptr(bcx, dst));\n-                        meta.store_fn_arg(bcx, &mut llarg_idx, expr::get_meta(bcx, dst));\n-                    } else {\n-                        arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n-                    }\n+                    let meta = &fcx.fn_ty.args[idx];\n+                    idx += 1;\n+                    arg.store_fn_arg(bcx, &mut llarg_idx, get_dataptr(bcx, dst));\n+                    meta.store_fn_arg(bcx, &mut llarg_idx, get_meta(bcx, dst));\n+                } else {\n+                    arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n                 }\n-                lltemp\n-            });\n-            return LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty));\n+            }\n+            return LvalueRef::new_sized(lltemp, LvalueTy::from_ty(arg_ty));\n         }\n \n         let arg = &fcx.fn_ty.args[idx];\n@@ -218,23 +215,23 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n             llarg_idx += 1;\n             llarg\n         } else {\n-            bcx.with_block(|bcx| {\n-                let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n-                if common::type_is_fat_ptr(tcx, arg_ty) {\n-                    // we pass fat pointers as two words, but we want to\n-                    // represent them internally as a pointer to two words,\n-                    // so make an alloca to store them in.\n-                    let meta = &fcx.fn_ty.args[idx];\n-                    idx += 1;\n-                    arg.store_fn_arg(bcx, &mut llarg_idx, expr::get_dataptr(bcx, lltemp));\n-                    meta.store_fn_arg(bcx, &mut llarg_idx, expr::get_meta(bcx, lltemp));\n-                } else  {\n-                    // otherwise, arg is passed by value, so make a\n-                    // temporary and store it there\n-                    arg.store_fn_arg(bcx, &mut llarg_idx, lltemp);\n-                }\n-                lltemp\n-            })\n+            let lltemp = bcx.with_block(|bcx| {\n+                base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index))\n+            });\n+            if common::type_is_fat_ptr(tcx, arg_ty) {\n+                // we pass fat pointers as two words, but we want to\n+                // represent them internally as a pointer to two words,\n+                // so make an alloca to store them in.\n+                let meta = &fcx.fn_ty.args[idx];\n+                idx += 1;\n+                arg.store_fn_arg(bcx, &mut llarg_idx, get_dataptr(bcx, lltemp));\n+                meta.store_fn_arg(bcx, &mut llarg_idx, get_meta(bcx, lltemp));\n+            } else  {\n+                // otherwise, arg is passed by value, so make a\n+                // temporary and store it there\n+                arg.store_fn_arg(bcx, &mut llarg_idx, lltemp);\n+            }\n+            lltemp\n         };\n         LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty))\n     }).collect()"}, {"sha": "6df4502fbc827503282185651626baf413e1c650", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=d9277b163c36448c5fbc39fa089a78256b45ffc1", "patch": "@@ -19,6 +19,7 @@ use trans::glue;\n \n use std::fmt;\n \n+use super::lvalue::load_fat_ptr;\n use super::{MirContext, TempRef, drop};\n \n /// The representation of a Rust value. The enum variant is in fact\n@@ -94,14 +95,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n         let val = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n             datum::ByValue => {\n-                bcx.with_block(|bcx| {\n-                    OperandValue::Immediate(base::load_ty(bcx, llval, ty))\n-                })\n+                OperandValue::Immediate(base::load_ty_builder(bcx, llval, ty))\n             }\n             datum::ByRef if common::type_is_fat_ptr(bcx.tcx(), ty) => {\n-                let (lldata, llextra) = bcx.with_block(|bcx| {\n-                    base::load_fat_ptr(bcx, llval, ty)\n-                });\n+                let (lldata, llextra) = load_fat_ptr(bcx, llval);\n                 OperandValue::FatPtr(lldata, llextra)\n             }\n             datum::ByRef => OperandValue::Ref(llval)"}, {"sha": "b63af3489b3757218aa627e533a95fae23156049", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9277b163c36448c5fbc39fa089a78256b45ffc1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=d9277b163c36448c5fbc39fa089a78256b45ffc1", "patch": "@@ -21,7 +21,6 @@ use trans::callee::Callee;\n use trans::common::{self, BlockAndBuilder, Result};\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n-use trans::expr;\n use trans::adt;\n use trans::machine;\n use trans::type_::Type;\n@@ -32,7 +31,7 @@ use trans::Disr;\n \n use super::MirContext;\n use super::operand::{OperandRef, OperandValue};\n-use super::lvalue::LvalueRef;\n+use super::lvalue::{LvalueRef, get_dataptr, get_meta};\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n@@ -100,8 +99,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let tr_elem = self.trans_operand(&bcx, elem);\n                 let count = ConstVal::Integral(ConstInt::Usize(count.value));\n                 let size = self.trans_constval(&bcx, &count, bcx.tcx().types.usize).immediate();\n+                let base = get_dataptr(&bcx, dest.llval);\n                 let bcx = bcx.map_block(|block| {\n-                    let base = expr::get_dataptr(block, dest.llval);\n                     tvec::iter_vec_raw(block, base, tr_elem.ty, size, |block, llslot, _| {\n                         self.store_operand_direct(block, llslot, tr_elem);\n                         block\n@@ -124,9 +123,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             // Do not generate stores and GEPis for zero-sized fields.\n                             if !common::type_is_zero_size(bcx.ccx(), op.ty) {\n                                 let val = adt::MaybeSizedValue::sized(dest.llval);\n-                                let lldest_i = bcx.with_block(|bcx| {\n-                                    adt::trans_field_ptr(bcx, &repr, val, disr, i)\n-                                });\n+                                let lldest_i = adt::trans_field_ptr_builder(&bcx, &repr,\n+                                                                            val, disr, i);\n                                 self.store_operand(&bcx, lldest_i, op);\n                             }\n                             self.set_operand_dropped(&bcx, operand);\n@@ -186,11 +184,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let llbase1 = bcx.gepi(llbase, &[from_start]);\n                 let adj = common::C_uint(ccx, from_start + from_end);\n                 let lllen1 = bcx.sub(lllen, adj);\n-                let (lladdrdest, llmetadest) = bcx.with_block(|bcx| {\n-                    (expr::get_dataptr(bcx, dest.llval), expr::get_meta(bcx, dest.llval))\n-                });\n-                bcx.store(llbase1, lladdrdest);\n-                bcx.store(lllen1, llmetadest);\n+                bcx.store(llbase1, get_dataptr(&bcx, dest.llval));\n+                bcx.store(lllen1, get_meta(&bcx, dest.llval));\n                 bcx\n             }\n "}]}