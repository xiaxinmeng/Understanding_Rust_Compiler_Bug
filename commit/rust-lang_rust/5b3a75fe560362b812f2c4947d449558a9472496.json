{"sha": "5b3a75fe560362b812f2c4947d449558a9472496", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViM2E3NWZlNTYwMzYyYjgxMmYyYzQ5NDdkNDQ5NTU4YTk0NzI0OTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-14T06:45:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-14T06:45:26Z"}, "message": "Auto merge of #30883 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #30626, #30662, #30770, #30801, #30818, #30823, #30828, #30835, #30837, #30839, #30845, #30848, #30850, #30851, #30863\n- Failed merges:", "tree": {"sha": "d7a502871e586d7cf4dbd5bc8f0ef32ddbe7ef0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7a502871e586d7cf4dbd5bc8f0ef32ddbe7ef0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b3a75fe560362b812f2c4947d449558a9472496", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b3a75fe560362b812f2c4947d449558a9472496", "html_url": "https://github.com/rust-lang/rust/commit/5b3a75fe560362b812f2c4947d449558a9472496", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b3a75fe560362b812f2c4947d449558a9472496/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1f550ebc299d5eadc073160cd3acb8de6c5d857", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1f550ebc299d5eadc073160cd3acb8de6c5d857", "html_url": "https://github.com/rust-lang/rust/commit/e1f550ebc299d5eadc073160cd3acb8de6c5d857"}, {"sha": "1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40", "url": "https://api.github.com/repos/rust-lang/rust/commits/1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40", "html_url": "https://github.com/rust-lang/rust/commit/1246f43bf9d9c21edc65bb6d26fc3ef883dd9f40"}], "stats": {"total": 1184, "additions": 833, "deletions": 351}, "files": [{"sha": "636c8adfa91e9f0d9236506d49869220e58780a4", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -17,7 +17,7 @@ Read [\"Installing Rust\"] from [The Book].\n 1. Make sure you have installed the dependencies:\n \n    * `g++` 4.7 or `clang++` 3.x\n-   * `python` 2.6 or later (but not 3.x)\n+   * `python` 2.7 or later (but not 3.x)\n    * GNU `make` 3.81 or later\n    * `curl`\n    * `git`"}, {"sha": "be53234cb02e2ca402f07197251ae7b435696f8e", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -103,7 +103,7 @@ DEPS_rustc_lint := rustc log syntax\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n DEPS_rustc_metadata := rustc rustc_front syntax rbml\n DEPS_rustc_mir := rustc rustc_front syntax\n-DEPS_rustc_resolve := rustc rustc_front log syntax\n+DEPS_rustc_resolve := arena rustc rustc_front log syntax\n DEPS_rustc_platform_intrinsics := rustc rustc_llvm\n DEPS_rustc_plugin := rustc rustc_metadata syntax\n DEPS_rustc_privacy := rustc rustc_front log syntax"}, {"sha": "ffa0ec4917cb3ef02fba42e1cc9171a0124ad576", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -92,6 +92,7 @@\n #![feature(unsize)]\n #![feature(drop_in_place)]\n #![feature(fn_traits)]\n+#![feature(const_fn)]\n \n #![feature(needs_allocator)]\n \n@@ -134,15 +135,6 @@ mod boxed_test;\n pub mod arc;\n pub mod rc;\n pub mod raw_vec;\n+pub mod oom;\n \n-/// Common out-of-memory routine\n-#[cold]\n-#[inline(never)]\n-#[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n-           issue = \"27700\")]\n-pub fn oom() -> ! {\n-    // FIXME(#14674): This really needs to do something other than just abort\n-    //                here, but any printing done must be *guaranteed* to not\n-    //                allocate.\n-    unsafe { core::intrinsics::abort() }\n-}\n+pub use oom::oom;"}, {"sha": "d355d59185eb4850311f808835835400978fc756", "filename": "src/liballoc/oom.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Fliballoc%2Foom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Fliballoc%2Foom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Foom.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::sync::atomic::{AtomicPtr, Ordering};\n+use core::mem;\n+use core::intrinsics;\n+\n+static OOM_HANDLER: AtomicPtr<()> = AtomicPtr::new(default_oom_handler as *mut ());\n+\n+fn default_oom_handler() -> ! {\n+    // The default handler can't do much more since we can't assume the presence\n+    // of libc or any way of printing an error message.\n+    unsafe { intrinsics::abort() }\n+}\n+\n+/// Common out-of-memory routine\n+#[cold]\n+#[inline(never)]\n+#[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n+           issue = \"27700\")]\n+pub fn oom() -> ! {\n+    let value = OOM_HANDLER.load(Ordering::SeqCst);\n+    let handler: fn() -> ! = unsafe { mem::transmute(value) };\n+    handler();\n+}\n+\n+/// Set a custom handler for out-of-memory conditions\n+///\n+/// To avoid recursive OOM failures, it is critical that the OOM handler does\n+/// not allocate any memory itself.\n+#[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n+           issue = \"27700\")]\n+pub fn set_oom_handler(handler: fn() -> !) {\n+    OOM_HANDLER.store(handler as *mut (), Ordering::SeqCst);\n+}"}, {"sha": "d9cafd53a851ee248bcf57856bb9a3d830dcc33b", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -16,6 +16,42 @@\n //!\n //! [`String`]: struct.String.html\n //! [`ToString`]: trait.ToString.html\n+//!\n+//! # Examples\n+//!\n+//! There are multiple ways to create a new `String` from a string literal:\n+//!\n+//! ```rust\n+//! let s = \"Hello\".to_string();\n+//!\n+//! let s = String::from(\"world\");\n+//! let s: String = \"also this\".into();\n+//! ```\n+//!\n+//! You can create a new `String` from an existing one by concatenating with\n+//! `+`:\n+//!\n+//! ```rust\n+//! let s = \"Hello\".to_string();\n+//!\n+//! let message = s + \" world!\";\n+//! ```\n+//!\n+//! If you have a vector of valid UTF-8 bytes, you can make a `String` out of\n+//! it. You can do the reverse too.\n+//!\n+//! ```rust\n+//! let sparkle_heart = vec![240, 159, 146, 150];\n+//!\n+//! // We know these bytes are valid, so we'll use `unwrap()`.\n+//! let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n+//!\n+//! assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n+//!\n+//! let bytes = sparkle_heart.into_bytes();\n+//!\n+//! assert_eq!(bytes, [240, 159, 146, 150]);\n+//! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "4033fea1f8e5d892bd189b9cd8a8098c297869bd", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -1569,7 +1569,7 @@ impl Debug for () {\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Debug for PhantomData<T> {\n+impl<T: ?Sized> Debug for PhantomData<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(\"PhantomData\")\n     }"}, {"sha": "80bfbe4edda8810dedb47db0085254a450497c89", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -132,7 +132,6 @@ pub struct Options {\n     pub prints: Vec<PrintRequest>,\n     pub cg: CodegenOptions,\n     pub color: ColorConfig,\n-    pub show_span: Option<String>,\n     pub externs: HashMap<String, Vec<String>>,\n     pub crate_name: Option<String>,\n     /// An optional name to use as the crate for std during std injection,\n@@ -243,7 +242,6 @@ pub fn basic_options() -> Options {\n         prints: Vec::new(),\n         cg: basic_codegen_options(),\n         color: ColorConfig::Auto,\n-        show_span: None,\n         externs: HashMap::new(),\n         crate_name: None,\n         alt_std_name: None,\n@@ -634,6 +632,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"don't clear the resolution tables after analysis\"),\n     keep_ast: bool = (false, parse_bool,\n           \"keep the AST after lowering it to HIR\"),\n+    show_span: Option<String> = (None, parse_opt_string,\n+          \"show spans for compiler debugging (expr|pat|ty)\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -882,7 +882,6 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n                       `hir` (the HIR), `hir,identified`, or\n                       `hir,typed` (HIR with types for each node).\",\n                      \"TYPE\"),\n-        opt::opt_u(\"\", \"show-span\", \"Show spans for compiler debugging\", \"expr|pat|ty\"),\n     ]);\n     opts\n }\n@@ -1123,7 +1122,6 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         prints: prints,\n         cg: cg,\n         color: color,\n-        show_span: None,\n         externs: externs,\n         crate_name: crate_name,\n         alt_std_name: None,"}, {"sha": "840260da33086956d30499da09b76782da9453b2", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -428,7 +428,7 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n         println!(\"Pre-expansion node count:  {}\", count_nodes(&krate));\n     }\n \n-    if let Some(ref s) = sess.opts.show_span {\n+    if let Some(ref s) = sess.opts.debugging_opts.show_span {\n         syntax::show_span::run(sess.diagnostic(), s, &krate);\n     }\n "}, {"sha": "cdac3de3682e57911c104f5df1c15dc5ab813da7", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -138,12 +138,9 @@ pub fn run_compiler<'a>(args: &[String], callbacks: &mut CompilerCalls<'a>) {\n     };\n \n     let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n-    let mut sess = build_session(sopts, input_file_path, descriptions,\n+    let sess = build_session(sopts, input_file_path, descriptions,\n                                  cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-    if sess.unstable_options() {\n-        sess.opts.show_span = matches.opt_str(\"show-span\");\n-    }\n     let mut cfg = config::build_configuration(&sess);\n     target_features::add_configuration(&mut cfg, &sess);\n \n@@ -387,7 +384,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     fn build_controller(&mut self, sess: &Session) -> CompileController<'a> {\n         let mut control = CompileController::basic();\n \n-        if sess.opts.parse_only || sess.opts.show_span.is_some() ||\n+        if sess.opts.parse_only || sess.opts.debugging_opts.show_span.is_some() ||\n            sess.opts.debugging_opts.ast_json_noexpand {\n             control.after_parse.stop = Compilation::Stop;\n         }"}, {"sha": "2e713a2f50e0fcdb0d5dfe08db3c54f2107f20ab", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 54, "deletions": 58, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -21,7 +21,7 @@ use Module;\n use Namespace::{TypeNS, ValueNS};\n use NameBindings;\n use {names_to_string, module_to_string};\n-use ParentLink::{self, ModuleParentLink, BlockParentLink};\n+use ParentLink::{ModuleParentLink, BlockParentLink};\n use Resolver;\n use resolve_imports::Shadowable;\n use {resolve_error, resolve_struct_error, ResolutionError};\n@@ -52,7 +52,6 @@ use rustc_front::intravisit::{self, Visitor};\n \n use std::mem::replace;\n use std::ops::{Deref, DerefMut};\n-use std::rc::Rc;\n \n // Specifies how duplicates should be handled when adding a child item if\n // another item exists with the same name in some namespace.\n@@ -86,7 +85,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// Constructs the reduced graph for the entire crate.\n     fn build_reduced_graph(self, krate: &hir::Crate) {\n         let mut visitor = BuildReducedGraphVisitor {\n-            parent: self.graph_root.clone(),\n+            parent: self.graph_root,\n             builder: self,\n         };\n         intravisit::walk_crate(&mut visitor, krate);\n@@ -97,12 +96,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// Returns the child's corresponding name bindings.\n     fn add_child(&self,\n                  name: Name,\n-                 parent: &Rc<Module>,\n+                 parent: Module<'b>,\n                  duplicate_checking_mode: DuplicateCheckingMode,\n                  // For printing errors\n                  sp: Span)\n-                 -> NameBindings {\n-        self.check_for_conflicts_between_external_crates_and_items(&**parent, name, sp);\n+                 -> NameBindings<'b> {\n+        self.check_for_conflicts_between_external_crates_and_items(parent, name, sp);\n \n         // Add or reuse the child.\n         let child = parent.children.borrow().get(&name).cloned();\n@@ -178,12 +177,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         return false;\n     }\n \n-    fn get_parent_link(&mut self, parent: &Rc<Module>, name: Name) -> ParentLink {\n-        ModuleParentLink(Rc::downgrade(parent), name)\n-    }\n-\n     /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(&mut self, item: &Item, parent: &Rc<Module>) -> Rc<Module> {\n+    fn build_reduced_graph_for_item(&mut self, item: &Item, parent: Module<'b>) -> Module<'b> {\n         let name = item.name;\n         let sp = item.span;\n         let is_public = item.vis == hir::Public;\n@@ -238,7 +233,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         }\n \n                         let subclass = SingleImport(binding, source_name);\n-                        self.build_import_directive(&**parent,\n+                        self.build_import_directive(parent,\n                                                     module_path,\n                                                     subclass,\n                                                     view_path.span,\n@@ -288,7 +283,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                     (module_path.to_vec(), name, rename)\n                                 }\n                             };\n-                            self.build_import_directive(&**parent,\n+                            self.build_import_directive(parent,\n                                                         module_path,\n                                                         SingleImport(rename, name),\n                                                         source_item.span,\n@@ -298,7 +293,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         }\n                     }\n                     ViewPathGlob(_) => {\n-                        self.build_import_directive(&**parent,\n+                        self.build_import_directive(parent,\n                                                     module_path,\n                                                     GlobImport,\n                                                     view_path.span,\n@@ -307,7 +302,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                     shadowable);\n                     }\n                 }\n-                parent.clone()\n+                parent\n             }\n \n             ItemExternCrate(_) => {\n@@ -319,32 +314,32 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         index: CRATE_DEF_INDEX,\n                     };\n                     self.external_exports.insert(def_id);\n-                    let parent_link = ModuleParentLink(Rc::downgrade(parent), name);\n+                    let parent_link = ModuleParentLink(parent, name);\n                     let def = DefMod(def_id);\n-                    let external_module = Module::new(parent_link, Some(def), false, true);\n+                    let external_module = self.new_module(parent_link, Some(def), false, true);\n \n                     debug!(\"(build reduced graph for item) found extern `{}`\",\n                            module_to_string(&*external_module));\n-                    self.check_for_conflicts_for_external_crate(&parent, name, sp);\n+                    self.check_for_conflicts_for_external_crate(parent, name, sp);\n                     parent.external_module_children\n                           .borrow_mut()\n-                          .insert(name, external_module.clone());\n+                          .insert(name, external_module);\n                     self.build_reduced_graph_for_external_crate(&external_module);\n                 }\n-                parent.clone()\n+                parent\n             }\n \n             ItemMod(..) => {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateTypes, sp);\n \n-                let parent_link = self.get_parent_link(parent, name);\n+                let parent_link = ModuleParentLink(parent, name);\n                 let def = DefMod(self.ast_map.local_def_id(item.id));\n-                let module = Module::new(parent_link, Some(def), false, is_public);\n+                let module = self.new_module(parent_link, Some(def), false, is_public);\n                 name_bindings.define_module(module.clone(), sp);\n                 module\n             }\n \n-            ItemForeignMod(..) => parent.clone(),\n+            ItemForeignMod(..) => parent,\n \n             // These items live in the value namespace.\n             ItemStatic(_, m, _) => {\n@@ -354,19 +349,19 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 name_bindings.define_value(DefStatic(self.ast_map.local_def_id(item.id), mutbl),\n                                            sp,\n                                            modifiers);\n-                parent.clone()\n+                parent\n             }\n             ItemConst(_, _) => {\n                 self.add_child(name, parent, ForbidDuplicateValues, sp)\n                     .define_value(DefConst(self.ast_map.local_def_id(item.id)), sp, modifiers);\n-                parent.clone()\n+                parent\n             }\n             ItemFn(_, _, _, _, _, _) => {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n \n                 let def = DefFn(self.ast_map.local_def_id(item.id), false);\n                 name_bindings.define_value(def, sp, modifiers);\n-                parent.clone()\n+                parent\n             }\n \n             // These items live in the type namespace.\n@@ -376,11 +371,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                    ForbidDuplicateTypes,\n                                                    sp);\n \n-                let parent_link = self.get_parent_link(parent, name);\n+                let parent_link = ModuleParentLink(parent, name);\n                 let def = DefTy(self.ast_map.local_def_id(item.id), false);\n-                let module = Module::new(parent_link, Some(def), false, is_public);\n+                let module = self.new_module(parent_link, Some(def), false, is_public);\n                 name_bindings.define_module(module, sp);\n-                parent.clone()\n+                parent\n             }\n \n             ItemEnum(ref enum_definition, _) => {\n@@ -389,9 +384,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                    ForbidDuplicateTypes,\n                                                    sp);\n \n-                let parent_link = self.get_parent_link(parent, name);\n+                let parent_link = ModuleParentLink(parent, name);\n                 let def = DefTy(self.ast_map.local_def_id(item.id), true);\n-                let module = Module::new(parent_link, Some(def), false, is_public);\n+                let module = self.new_module(parent_link, Some(def), false, is_public);\n                 name_bindings.define_module(module.clone(), sp);\n \n                 let variant_modifiers = if is_public {\n@@ -404,7 +399,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.build_reduced_graph_for_variant(variant, item_def_id,\n                                                          &module, variant_modifiers);\n                 }\n-                parent.clone()\n+                parent\n             }\n \n             // These items live in both the type and value namespaces.\n@@ -444,11 +439,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let item_def_id = self.ast_map.local_def_id(item.id);\n                 self.structs.insert(item_def_id, named_fields);\n \n-                parent.clone()\n+                parent\n             }\n \n             ItemDefaultImpl(_, _) |\n-            ItemImpl(..) => parent.clone(),\n+            ItemImpl(..) => parent,\n \n             ItemTrait(_, _, _, ref items) => {\n                 let name_bindings = self.add_child(name,\n@@ -459,9 +454,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let def_id = self.ast_map.local_def_id(item.id);\n \n                 // Add all the items within to a new module.\n-                let parent_link = self.get_parent_link(parent, name);\n+                let parent_link = ModuleParentLink(parent, name);\n                 let def = DefTrait(def_id);\n-                let module_parent = Module::new(parent_link, Some(def), false, is_public);\n+                let module_parent = self.new_module(parent_link, Some(def), false, is_public);\n                 name_bindings.define_module(module_parent.clone(), sp);\n \n                 // Add the names of all the items to the trait info.\n@@ -494,7 +489,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.trait_item_map.insert((trait_item.name, def_id), trait_item_def_id);\n                 }\n \n-                parent.clone()\n+                parent\n             }\n         }\n     }\n@@ -504,7 +499,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n                                        item_id: DefId,\n-                                       parent: &Rc<Module>,\n+                                       parent: Module<'b>,\n                                        variant_modifiers: DefModifiers) {\n         let name = variant.node.name;\n         let is_exported = if variant.node.data.is_struct() {\n@@ -534,7 +529,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self,\n                                             foreign_item: &ForeignItem,\n-                                            parent: &Rc<Module>) {\n+                                            parent: Module<'b>) {\n         let name = foreign_item.name;\n         let is_public = foreign_item.vis == hir::Public;\n         let modifiers = if is_public {\n@@ -555,30 +550,30 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         name_bindings.define_value(def, foreign_item.span, modifiers);\n     }\n \n-    fn build_reduced_graph_for_block(&mut self, block: &Block, parent: &Rc<Module>) -> Rc<Module> {\n+    fn build_reduced_graph_for_block(&mut self, block: &Block, parent: Module<'b>) -> Module<'b> {\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.id;\n \n             debug!(\"(building reduced graph for block) creating a new anonymous module for block \\\n                     {}\",\n                    block_id);\n \n-            let parent_link = BlockParentLink(Rc::downgrade(parent), block_id);\n-            let new_module = Module::new(parent_link, None, false, false);\n-            parent.anonymous_children.borrow_mut().insert(block_id, new_module.clone());\n+            let parent_link = BlockParentLink(parent, block_id);\n+            let new_module = self.new_module(parent_link, None, false, false);\n+            parent.anonymous_children.borrow_mut().insert(block_id, new_module);\n             new_module\n         } else {\n-            parent.clone()\n+            parent\n         }\n     }\n \n     fn handle_external_def(&mut self,\n                            def: Def,\n                            vis: Visibility,\n-                           child_name_bindings: &NameBindings,\n+                           child_name_bindings: &NameBindings<'b>,\n                            final_ident: &str,\n                            name: Name,\n-                           new_parent: &Rc<Module>) {\n+                           new_parent: Module<'b>) {\n         debug!(\"(building reduced graph for external crate) building external def {}, priv {:?}\",\n                final_ident,\n                vis);\n@@ -609,8 +604,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     debug!(\"(building reduced graph for external crate) building module {} {}\",\n                            final_ident,\n                            is_public);\n-                    let parent_link = self.get_parent_link(new_parent, name);\n-                    let module = Module::new(parent_link, Some(def), true, is_public);\n+                    let parent_link = ModuleParentLink(new_parent, name);\n+                    let module = self.new_module(parent_link, Some(def), true, is_public);\n                     child_name_bindings.define_module(module, DUMMY_SP);\n                 }\n             }\n@@ -681,8 +676,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 }\n \n                 // Define a module if necessary.\n-                let parent_link = self.get_parent_link(new_parent, name);\n-                let module = Module::new(parent_link, Some(def), true, is_public);\n+                let parent_link = ModuleParentLink(new_parent, name);\n+                let module = self.new_module(parent_link, Some(def), true, is_public);\n                 child_name_bindings.define_module(module, DUMMY_SP);\n             }\n             DefTy(..) | DefAssociatedTy(..) => {\n@@ -728,7 +723,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n     /// Builds the reduced graph for a single item in an external crate.\n     fn build_reduced_graph_for_external_crate_def(&mut self,\n-                                                  root: &Rc<Module>,\n+                                                  root: Module<'b>,\n                                                   xcdef: ChildItem) {\n         match xcdef.def {\n             DlDef(def) => {\n@@ -766,9 +761,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     }\n \n     /// Builds the reduced graph rooted at the given external module.\n-    fn populate_external_module(&mut self, module: &Rc<Module>) {\n+    fn populate_external_module(&mut self, module: Module<'b>) {\n         debug!(\"(populating external module) attempting to populate {}\",\n-               module_to_string(&**module));\n+               module_to_string(module));\n \n         let def_id = match module.def_id() {\n             None => {\n@@ -788,7 +783,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n     /// Ensures that the reduced graph rooted at the given external module\n     /// is built, building it if it is not.\n-    fn populate_module_if_necessary(&mut self, module: &Rc<Module>) {\n+    fn populate_module_if_necessary(&mut self, module: Module<'b>) {\n         if !module.populated.get() {\n             self.populate_external_module(module)\n         }\n@@ -797,7 +792,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n     /// Builds the reduced graph rooted at the 'use' directive for an external\n     /// crate.\n-    fn build_reduced_graph_for_external_crate(&mut self, root: &Rc<Module>) {\n+    fn build_reduced_graph_for_external_crate(&mut self, root: Module<'b>) {\n         let root_cnum = root.def_id().unwrap().krate;\n         for child in self.session.cstore.crate_top_level_items(root_cnum) {\n             self.build_reduced_graph_for_external_crate_def(root, child);\n@@ -806,7 +801,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n     /// Creates and adds an import directive to the given module.\n     fn build_import_directive(&mut self,\n-                              module_: &Module,\n+                              module_: Module<'b>,\n                               module_path: Vec<Name>,\n                               subclass: ImportDirectiveSubclass,\n                               span: Span,\n@@ -866,7 +861,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n struct BuildReducedGraphVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     builder: GraphBuilder<'a, 'b, 'tcx>,\n-    parent: Rc<Module>,\n+    parent: Module<'b>,\n }\n \n impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n@@ -897,6 +892,7 @@ pub fn build_reduced_graph(resolver: &mut Resolver, krate: &hir::Crate) {\n     GraphBuilder { resolver: resolver }.build_reduced_graph(krate);\n }\n \n-pub fn populate_module_if_necessary(resolver: &mut Resolver, module: &Rc<Module>) {\n+pub fn populate_module_if_necessary<'a, 'tcx>(resolver: &mut Resolver<'a, 'tcx>,\n+                                              module: Module<'a>) {\n     GraphBuilder { resolver: resolver }.populate_module_if_necessary(module);\n }"}, {"sha": "9857e83bd621a7ddc47dcee3c60c5950f6fe0458", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 146, "deletions": 122, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -26,6 +26,7 @@\n extern crate log;\n #[macro_use]\n extern crate syntax;\n+extern crate arena;\n #[macro_use]\n #[no_link]\n extern crate rustc_bitflags;\n@@ -90,7 +91,7 @@ use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::mem::replace;\n-use std::rc::{Rc, Weak};\n+use std::rc::Rc;\n \n use resolve_imports::{Target, ImportDirective, ImportResolutionPerNamespace};\n use resolve_imports::Shadowable;\n@@ -576,7 +577,7 @@ pub enum Namespace {\n /// a particular namespace. The result is either definitely-resolved,\n /// definitely- unresolved, or unknown.\n #[derive(Clone)]\n-enum NamespaceResult {\n+enum NamespaceResult<'a> {\n     /// Means that resolve hasn't gathered enough information yet to determine\n     /// whether the name is bound in this namespace. (That is, it hasn't\n     /// resolved all `use` directives yet.)\n@@ -586,10 +587,10 @@ enum NamespaceResult {\n     UnboundResult,\n     /// Means that resolve has determined that the name is bound in the Module\n     /// argument, and specified by the NameBinding argument.\n-    BoundResult(Rc<Module>, NameBinding),\n+    BoundResult(Module<'a>, NameBinding<'a>),\n }\n \n-impl NamespaceResult {\n+impl<'a> NamespaceResult<'a> {\n     fn is_unknown(&self) -> bool {\n         match *self {\n             UnknownResult => true,\n@@ -766,9 +767,9 @@ enum UseLexicalScopeFlag {\n     UseLexicalScope,\n }\n \n-enum ModulePrefixResult {\n+enum ModulePrefixResult<'a> {\n     NoPrefixFound,\n-    PrefixFound(Rc<Module>, usize),\n+    PrefixFound(Module<'a>, usize),\n }\n \n #[derive(Copy, Clone)]\n@@ -830,24 +831,24 @@ impl LocalDef {\n \n /// The link from a module up to its nearest parent node.\n #[derive(Clone,Debug)]\n-enum ParentLink {\n+enum ParentLink<'a> {\n     NoParentLink,\n-    ModuleParentLink(Weak<Module>, Name),\n-    BlockParentLink(Weak<Module>, NodeId),\n+    ModuleParentLink(Module<'a>, Name),\n+    BlockParentLink(Module<'a>, NodeId),\n }\n \n /// One node in the tree of modules.\n-pub struct Module {\n-    parent_link: ParentLink,\n+pub struct ModuleS<'a> {\n+    parent_link: ParentLink<'a>,\n     def: Cell<Option<Def>>,\n     is_public: bool,\n \n-    children: RefCell<HashMap<Name, NameBindings>>,\n+    children: RefCell<HashMap<Name, NameBindings<'a>>>,\n     imports: RefCell<Vec<ImportDirective>>,\n \n     // The external module children of this node that were declared with\n     // `extern crate`.\n-    external_module_children: RefCell<HashMap<Name, Rc<Module>>>,\n+    external_module_children: RefCell<HashMap<Name, Module<'a>>>,\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n     // modules that are implicitly created around items contained within\n@@ -863,10 +864,10 @@ pub struct Module {\n     //\n     // There will be an anonymous module created around `g` with the ID of the\n     // entry block for `f`.\n-    anonymous_children: RefCell<NodeMap<Rc<Module>>>,\n+    anonymous_children: RefCell<NodeMap<Module<'a>>>,\n \n     // The status of resolving each import in this module.\n-    import_resolutions: RefCell<HashMap<Name, ImportResolutionPerNamespace>>,\n+    import_resolutions: RefCell<HashMap<Name, ImportResolutionPerNamespace<'a>>>,\n \n     // The number of unresolved globs that this module exports.\n     glob_count: Cell<usize>,\n@@ -886,13 +887,11 @@ pub struct Module {\n     populated: Cell<bool>,\n }\n \n-impl Module {\n-    fn new(parent_link: ParentLink,\n-           def: Option<Def>,\n-           external: bool,\n-           is_public: bool)\n-           -> Rc<Module> {\n-        Rc::new(Module {\n+pub type Module<'a> = &'a ModuleS<'a>;\n+\n+impl<'a> ModuleS<'a> {\n+    fn new(parent_link: ParentLink<'a>, def: Option<Def>, external: bool, is_public: bool) -> Self {\n+        ModuleS {\n             parent_link: parent_link,\n             def: Cell::new(def),\n             is_public: is_public,\n@@ -906,7 +905,7 @@ impl Module {\n             pub_glob_count: Cell::new(0),\n             resolved_import_count: Cell::new(0),\n             populated: Cell::new(!external),\n-        })\n+        }\n     }\n \n     fn def_id(&self) -> Option<DefId> {\n@@ -935,9 +934,7 @@ impl Module {\n             self.imports.borrow().len() == self.resolved_import_count.get()\n         }\n     }\n-}\n \n-impl Module {\n     pub fn inc_glob_count(&self) {\n         self.glob_count.set(self.glob_count.get() + 1);\n     }\n@@ -961,7 +958,7 @@ impl Module {\n     }\n }\n \n-impl fmt::Debug for Module {\n+impl<'a> fmt::Debug for ModuleS<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f,\n                \"{:?}, {}\",\n@@ -989,20 +986,20 @@ bitflags! {\n \n // Records a possibly-private value, type, or module definition.\n #[derive(Debug)]\n-struct NsDef {\n+struct NsDef<'a> {\n     modifiers: DefModifiers, // see note in ImportResolutionPerNamespace about how to use this\n-    def_or_module: DefOrModule,\n+    def_or_module: DefOrModule<'a>,\n     span: Option<Span>,\n }\n \n #[derive(Debug)]\n-enum DefOrModule {\n+enum DefOrModule<'a> {\n     Def(Def),\n-    Module(Rc<Module>),\n+    Module(Module<'a>),\n }\n \n-impl NsDef {\n-    fn create_from_module(module: Rc<Module>, span: Option<Span>) -> Self {\n+impl<'a> NsDef<'a> {\n+    fn create_from_module(module: Module<'a>, span: Option<Span>) -> Self {\n         let modifiers = if module.is_public {\n             DefModifiers::PUBLIC\n         } else {\n@@ -1016,9 +1013,9 @@ impl NsDef {\n         NsDef { modifiers: modifiers, def_or_module: DefOrModule::Def(def), span: span }\n     }\n \n-    fn module(&self) -> Option<Rc<Module>> {\n+    fn module(&self) -> Option<Module<'a>> {\n         match self.def_or_module {\n-            DefOrModule::Module(ref module) => Some(module.clone()),\n+            DefOrModule::Module(ref module) => Some(module),\n             DefOrModule::Def(_) => None,\n         }\n     }\n@@ -1033,18 +1030,18 @@ impl NsDef {\n \n // Records at most one definition that a name in a namespace is bound to\n #[derive(Clone,Debug)]\n-pub struct NameBinding(Rc<RefCell<Option<NsDef>>>);\n+pub struct NameBinding<'a>(Rc<RefCell<Option<NsDef<'a>>>>);\n \n-impl NameBinding {\n+impl<'a> NameBinding<'a> {\n     fn new() -> Self {\n         NameBinding(Rc::new(RefCell::new(None)))\n     }\n \n-    fn create_from_module(module: Rc<Module>) -> Self {\n+    fn create_from_module(module: Module<'a>) -> Self {\n         NameBinding(Rc::new(RefCell::new(Some(NsDef::create_from_module(module, None)))))\n     }\n \n-    fn set(&self, ns_def: NsDef) {\n+    fn set(&self, ns_def: NsDef<'a>) {\n         *self.0.borrow_mut() = Some(ns_def);\n     }\n \n@@ -1054,15 +1051,15 @@ impl NameBinding {\n         }\n     }\n \n-    fn borrow(&self) -> ::std::cell::Ref<Option<NsDef>> {\n+    fn borrow(&self) -> ::std::cell::Ref<Option<NsDef<'a>>> {\n         self.0.borrow()\n     }\n \n     // Lifted versions of the NsDef methods and fields\n     fn def(&self) -> Option<Def> {\n         self.borrow().as_ref().and_then(NsDef::def)\n     }\n-    fn module(&self) -> Option<Rc<Module>> {\n+    fn module(&self) -> Option<Module<'a>> {\n         self.borrow().as_ref().and_then(NsDef::module)\n     }\n     fn span(&self) -> Option<Span> {\n@@ -1093,28 +1090,28 @@ impl NameBinding {\n // Records the definitions (at most one for each namespace) that a name is\n // bound to.\n #[derive(Clone,Debug)]\n-pub struct NameBindings {\n-    type_ns: NameBinding, // < Meaning in type namespace.\n-    value_ns: NameBinding, // < Meaning in value namespace.\n+pub struct NameBindings<'a> {\n+    type_ns: NameBinding<'a>, // < Meaning in type namespace.\n+    value_ns: NameBinding<'a>, // < Meaning in value namespace.\n }\n \n-impl ::std::ops::Index<Namespace> for NameBindings {\n-    type Output = NameBinding;\n-    fn index(&self, namespace: Namespace) -> &NameBinding {\n+impl<'a> ::std::ops::Index<Namespace> for NameBindings<'a> {\n+    type Output = NameBinding<'a>;\n+    fn index(&self, namespace: Namespace) -> &NameBinding<'a> {\n         match namespace { TypeNS => &self.type_ns, ValueNS => &self.value_ns }\n     }\n }\n \n-impl NameBindings {\n-    fn new() -> NameBindings {\n+impl<'a> NameBindings<'a> {\n+    fn new() -> Self {\n         NameBindings {\n             type_ns: NameBinding::new(),\n             value_ns: NameBinding::new(),\n         }\n     }\n \n     /// Creates a new module in this set of name bindings.\n-    fn define_module(&self, module: Rc<Module>, sp: Span) {\n+    fn define_module(&self, module: Module<'a>, sp: Span) {\n         self.type_ns.set(NsDef::create_from_module(module, Some(sp)));\n     }\n \n@@ -1170,7 +1167,7 @@ pub struct Resolver<'a, 'tcx: 'a> {\n \n     ast_map: &'a hir_map::Map<'tcx>,\n \n-    graph_root: Rc<Module>,\n+    graph_root: Module<'a>,\n \n     trait_item_map: FnvHashMap<(Name, DefId), DefId>,\n \n@@ -1180,7 +1177,7 @@ pub struct Resolver<'a, 'tcx: 'a> {\n     unresolved_imports: usize,\n \n     // The module that represents the current item scope.\n-    current_module: Rc<Module>,\n+    current_module: Module<'a>,\n \n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n@@ -1226,6 +1223,12 @@ pub struct Resolver<'a, 'tcx: 'a> {\n     // The intention is that the callback modifies this flag.\n     // Once set, the resolver falls out of the walk, preserving the ribs.\n     resolved: bool,\n+\n+    arenas: &'a ResolverArenas<'a>,\n+}\n+\n+pub struct ResolverArenas<'a> {\n+    modules: arena::TypedArena<ModuleS<'a>>,\n }\n \n #[derive(PartialEq)]\n@@ -1237,10 +1240,12 @@ enum FallbackChecks {\n impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn new(session: &'a Session,\n            ast_map: &'a hir_map::Map<'tcx>,\n-           make_glob_map: MakeGlobMap)\n+           make_glob_map: MakeGlobMap,\n+           arenas: &'a ResolverArenas<'a>)\n            -> Resolver<'a, 'tcx> {\n         let root_def_id = ast_map.local_def_id(CRATE_NODE_ID);\n-        let graph_root = Module::new(NoParentLink, Some(DefMod(root_def_id)), false, true);\n+        let graph_root = ModuleS::new(NoParentLink, Some(DefMod(root_def_id)), false, true);\n+        let graph_root = arenas.modules.alloc(graph_root);\n \n         Resolver {\n             session: session,\n@@ -1249,7 +1254,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n-            graph_root: graph_root.clone(),\n+            graph_root: graph_root,\n \n             trait_item_map: FnvHashMap(),\n             structs: FnvHashMap(),\n@@ -1281,9 +1286,25 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             callback: None,\n             resolved: false,\n+\n+            arenas: arenas,\n+        }\n+    }\n+\n+    fn arenas() -> ResolverArenas<'a> {\n+        ResolverArenas {\n+            modules: arena::TypedArena::new(),\n         }\n     }\n \n+    fn new_module(&self,\n+                  parent_link: ParentLink<'a>,\n+                  def: Option<Def>,\n+                  external: bool,\n+                  is_public: bool) -> Module<'a> {\n+        self.arenas.modules.alloc(ModuleS::new(parent_link, def, external, is_public))\n+    }\n+\n     #[inline]\n     fn record_import_use(&mut self, import_id: NodeId, name: Name) {\n         if !self.make_glob_map {\n@@ -1308,7 +1329,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     /// Check that an external crate doesn't collide with items or other external crates.\n-    fn check_for_conflicts_for_external_crate(&self, module: &Module, name: Name, span: Span) {\n+    fn check_for_conflicts_for_external_crate(&self, module: Module<'a>, name: Name, span: Span) {\n         if module.external_module_children.borrow().contains_key(&name) {\n             span_err!(self.session,\n                       span,\n@@ -1328,7 +1349,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Checks that the names of items don't collide with external crates.\n     fn check_for_conflicts_between_external_crates_and_items(&self,\n-                                                             module: &Module,\n+                                                             module: Module<'a>,\n                                                              name: Name,\n                                                              span: Span) {\n         if module.external_module_children.borrow().contains_key(&name) {\n@@ -1338,19 +1359,20 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Resolves the given module path from the given root `module_`.\n     fn resolve_module_path_from_root(&mut self,\n-                                     module_: Rc<Module>,\n+                                     module_: Module<'a>,\n                                      module_path: &[Name],\n                                      index: usize,\n                                      span: Span,\n                                      name_search_type: NameSearchType,\n                                      lp: LastPrivate)\n-                                     -> ResolveResult<(Rc<Module>, LastPrivate)> {\n-        fn search_parent_externals(needle: Name, module: &Rc<Module>) -> Option<Rc<Module>> {\n+                                     -> ResolveResult<(Module<'a>, LastPrivate)> {\n+        fn search_parent_externals<'a>(needle: Name, module: Module<'a>)\n+                                       -> Option<Module<'a>> {\n             match module.external_module_children.borrow().get(&needle) {\n-                Some(_) => Some(module.clone()),\n+                Some(_) => Some(module),\n                 None => match module.parent_link {\n                     ModuleParentLink(ref parent, _) => {\n-                        search_parent_externals(needle, &parent.upgrade().unwrap())\n+                        search_parent_externals(needle, parent)\n                     }\n                     _ => None,\n                 },\n@@ -1367,14 +1389,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // modules as we go.\n         while index < module_path_len {\n             let name = module_path[index];\n-            match self.resolve_name_in_module(search_module.clone(),\n+            match self.resolve_name_in_module(search_module,\n                                               name,\n                                               TypeNS,\n                                               name_search_type,\n                                               false) {\n                 Failed(None) => {\n                     let segment_name = name.as_str();\n-                    let module_name = module_to_string(&*search_module);\n+                    let module_name = module_to_string(search_module);\n                     let mut span = span;\n                     let msg = if \"???\" == &module_name[..] {\n                         span.hi = span.lo + Pos::from_usize(segment_name.len());\n@@ -1445,12 +1467,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// On success, returns the resolved module, and the closest *private*\n     /// module found to the destination when resolving this path.\n     fn resolve_module_path(&mut self,\n-                           module_: Rc<Module>,\n+                           module_: Module<'a>,\n                            module_path: &[Name],\n                            use_lexical_scope: UseLexicalScopeFlag,\n                            span: Span,\n                            name_search_type: NameSearchType)\n-                           -> ResolveResult<(Rc<Module>, LastPrivate)> {\n+                           -> ResolveResult<(Module<'a>, LastPrivate)> {\n         let module_path_len = module_path.len();\n         assert!(module_path_len > 0);\n \n@@ -1459,7 +1481,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                module_to_string(&*module_));\n \n         // Resolve the module prefix, if any.\n-        let module_prefix_result = self.resolve_module_prefix(module_.clone(), module_path);\n+        let module_prefix_result = self.resolve_module_prefix(module_, module_path);\n \n         let search_module;\n         let start_index;\n@@ -1495,7 +1517,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     DontUseLexicalScope => {\n                         // This is a crate-relative path. We will start the\n                         // resolution process at index zero.\n-                        search_module = self.graph_root.clone();\n+                        search_module = self.graph_root;\n                         start_index = 0;\n                         last_private = LastMod(AllPublic);\n                     }\n@@ -1519,7 +1541,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n             Success(PrefixFound(ref containing_module, index)) => {\n-                search_module = containing_module.clone();\n+                search_module = containing_module;\n                 start_index = index;\n                 last_private = LastMod(DependsOn(containing_module.def_id()\n                                                                   .unwrap()));\n@@ -1537,11 +1559,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n     fn resolve_item_in_lexical_scope(&mut self,\n-                                     module_: Rc<Module>,\n+                                     module_: Module<'a>,\n                                      name: Name,\n                                      namespace: Namespace,\n                                      record_used: bool)\n-                                     -> ResolveResult<(Target, bool)> {\n+                                     -> ResolveResult<(Target<'a>, bool)> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in namespace {:?} in `{}`\",\n                name,\n                namespace,\n@@ -1554,7 +1576,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match module_.children.borrow().get(&name) {\n             Some(name_bindings) if name_bindings[namespace].defined() => {\n                 debug!(\"top name bindings succeeded\");\n-                return Success((Target::new(module_.clone(),\n+                return Success((Target::new(module_,\n                                             name_bindings[namespace].clone(),\n                                             Shadowable::Never),\n                                 false));\n@@ -1594,9 +1616,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Search for external modules.\n         if namespace == TypeNS {\n-            // FIXME (21114): In principle unclear `child` *has* to be lifted.\n-            let child = module_.external_module_children.borrow().get(&name).cloned();\n-            if let Some(module) = child {\n+            let children = module_.external_module_children.borrow();\n+            if let Some(module) = children.get(&name) {\n                 let name_binding = NameBinding::create_from_module(module);\n                 debug!(\"lower name bindings succeeded\");\n                 return Success((Target::new(module_, name_binding, Shadowable::Never),\n@@ -1608,7 +1629,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut search_module = module_;\n         loop {\n             // Go to the next parent.\n-            match search_module.parent_link.clone() {\n+            match search_module.parent_link {\n                 NoParentLink => {\n                     // No more parents. This module was unresolved.\n                     debug!(\"(resolving item in lexical scope) unresolved module\");\n@@ -1621,16 +1642,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 searching through module parents\");\n                             return Failed(None);\n                     } else {\n-                        search_module = parent_module_node.upgrade().unwrap();\n+                        search_module = parent_module_node;\n                     }\n                 }\n-                BlockParentLink(ref parent_module_node, _) => {\n-                    search_module = parent_module_node.upgrade().unwrap();\n+                BlockParentLink(parent_module_node, _) => {\n+                    search_module = parent_module_node;\n                 }\n             }\n \n             // Resolve the name in the parent module.\n-            match self.resolve_name_in_module(search_module.clone(),\n+            match self.resolve_name_in_module(search_module,\n                                               name,\n                                               namespace,\n                                               PathSearch,\n@@ -1657,9 +1678,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Resolves a module name in the current lexical scope.\n     fn resolve_module_in_lexical_scope(&mut self,\n-                                       module_: Rc<Module>,\n+                                       module_: Module<'a>,\n                                        name: Name)\n-                                       -> ResolveResult<Rc<Module>> {\n+                                       -> ResolveResult<Module<'a>> {\n         // If this module is an anonymous module, resolve the item in the\n         // lexical scope. Otherwise, resolve the item from the crate root.\n         let resolve_result = self.resolve_item_in_lexical_scope(module_, name, TypeNS, true);\n@@ -1685,14 +1706,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     /// Returns the nearest normal module parent of the given module.\n-    fn get_nearest_normal_module_parent(&mut self, module_: Rc<Module>) -> Option<Rc<Module>> {\n+    fn get_nearest_normal_module_parent(&mut self, module_: Module<'a>) -> Option<Module<'a>> {\n         let mut module_ = module_;\n         loop {\n-            match module_.parent_link.clone() {\n+            match module_.parent_link {\n                 NoParentLink => return None,\n                 ModuleParentLink(new_module, _) |\n                 BlockParentLink(new_module, _) => {\n-                    let new_module = new_module.upgrade().unwrap();\n+                    let new_module = new_module;\n                     if new_module.is_normal() {\n                         return Some(new_module);\n                     }\n@@ -1704,11 +1725,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Returns the nearest normal module parent of the given module, or the\n     /// module itself if it is a normal module.\n-    fn get_nearest_normal_module_parent_or_self(&mut self, module_: Rc<Module>) -> Rc<Module> {\n+    fn get_nearest_normal_module_parent_or_self(&mut self, module_: Module<'a>) -> Module<'a> {\n         if module_.is_normal() {\n             return module_;\n         }\n-        match self.get_nearest_normal_module_parent(module_.clone()) {\n+        match self.get_nearest_normal_module_parent(module_) {\n             None => module_,\n             Some(new_module) => new_module,\n         }\n@@ -1718,9 +1739,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// (b) some chain of `super::`.\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n     fn resolve_module_prefix(&mut self,\n-                             module_: Rc<Module>,\n+                             module_: Module<'a>,\n                              module_path: &[Name])\n-                             -> ResolveResult<ModulePrefixResult> {\n+                             -> ResolveResult<ModulePrefixResult<'a>> {\n         // Start at the current module if we see `self` or `super`, or at the\n         // top of the crate otherwise.\n         let mut i = match &*module_path[0].as_str() {\n@@ -1756,23 +1777,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// The boolean returned on success is an indicator of whether this lookup\n     /// passed through a public re-export proxy.\n     fn resolve_name_in_module(&mut self,\n-                              module_: Rc<Module>,\n+                              module_: Module<'a>,\n                               name: Name,\n                               namespace: Namespace,\n                               name_search_type: NameSearchType,\n                               allow_private_imports: bool)\n-                              -> ResolveResult<(Target, bool)> {\n+                              -> ResolveResult<(Target<'a>, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n                name,\n                module_to_string(&*module_));\n \n         // First, check the direct children of the module.\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n-        match module_.children.borrow().get(&name) {\n+        let children = module_.children.borrow();\n+        match children.get(&name) {\n             Some(name_bindings) if name_bindings[namespace].defined() => {\n                 debug!(\"(resolving name in module) found node as child\");\n-                return Success((Target::new(module_.clone(),\n+                return Success((Target::new(module_,\n                                             name_bindings[namespace].clone(),\n                                             Shadowable::Never),\n                                 false));\n@@ -1791,7 +1813,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Check the list of resolved imports.\n-        match module_.import_resolutions.borrow().get(&name) {\n+        let children = module_.import_resolutions.borrow();\n+        match children.get(&name) {\n             Some(import_resolution) if allow_private_imports ||\n                                        import_resolution[namespace].is_public => {\n \n@@ -1823,9 +1846,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Finally, search through external children.\n         if namespace == TypeNS {\n-            // FIXME (21114): In principle unclear `child` *has* to be lifted.\n-            let child = module_.external_module_children.borrow().get(&name).cloned();\n-            if let Some(module) = child {\n+            let children = module_.external_module_children.borrow();\n+            if let Some(module) = children.get(&name) {\n                 let name_binding = NameBinding::create_from_module(module);\n                 return Success((Target::new(module_, name_binding, Shadowable::Never),\n                                 false));\n@@ -1837,7 +1859,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         return Failed(None);\n     }\n \n-    fn report_unresolved_imports(&mut self, module_: Rc<Module>) {\n+    fn report_unresolved_imports(&mut self, module_: Module<'a>) {\n         let index = module_.resolved_import_count.get();\n         let imports = module_.imports.borrow();\n         let import_count = imports.len();\n@@ -1862,7 +1884,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         for (_, module_) in module_.anonymous_children.borrow().iter() {\n-            self.report_unresolved_imports(module_.clone());\n+            self.report_unresolved_imports(module_);\n         }\n     }\n \n@@ -1887,7 +1909,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn with_scope<F>(&mut self, name: Option<Name>, f: F)\n         where F: FnOnce(&mut Resolver)\n     {\n-        let orig_module = self.current_module.clone();\n+        let orig_module = self.current_module;\n \n         // Move down in the graph.\n         match name {\n@@ -2475,14 +2497,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.value_ribs.push(Rib::new(NormalRibKind));\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n-        let orig_module = self.current_module.clone();\n+        let orig_module = self.current_module;\n         match orig_module.anonymous_children.borrow().get(&block.id) {\n             None => {\n                 // Nothing to do.\n             }\n             Some(anonymous_module) => {\n                 debug!(\"(resolving block) found anonymous module, moving down\");\n-                self.current_module = anonymous_module.clone();\n+                self.current_module = anonymous_module;\n             }\n         }\n \n@@ -2871,7 +2893,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                        name: Name,\n                                        span: Span)\n                                        -> BareIdentifierPatternResolution {\n-        let module = self.current_module.clone();\n+        let module = self.current_module;\n         match self.resolve_item_in_lexical_scope(module, name, ValueNS, true) {\n             Success((target, _)) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in finding {} at {:?}\",\n@@ -3135,7 +3157,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let containing_module;\n         let last_private;\n-        let current_module = self.current_module.clone();\n+        let current_module = self.current_module;\n         match self.resolve_module_path(current_module,\n                                        &module_path[..],\n                                        UseLexicalScope,\n@@ -3162,7 +3184,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n-        let def = match self.resolve_name_in_module(containing_module.clone(),\n+        let def = match self.resolve_name_in_module(containing_module,\n                                                     name,\n                                                     namespace,\n                                                     NameSearchType::PathSearch,\n@@ -3193,7 +3215,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                   .map(|ps| ps.identifier.name)\n                                   .collect::<Vec<_>>();\n \n-        let root_module = self.graph_root.clone();\n+        let root_module = self.graph_root;\n \n         let containing_module;\n         let last_private;\n@@ -3283,7 +3305,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                              record_used: bool)\n                                              -> Option<Def> {\n         // Check the items.\n-        let module = self.current_module.clone();\n+        let module = self.current_module;\n         match self.resolve_item_in_lexical_scope(module, name, namespace, record_used) {\n             Success((target, _)) => {\n                 match target.binding.def() {\n@@ -3345,11 +3367,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        fn get_module(this: &mut Resolver,\n-                      span: Span,\n-                      name_path: &[ast::Name])\n-                      -> Option<Rc<Module>> {\n-            let root = this.current_module.clone();\n+        fn get_module<'a, 'tcx>(this: &mut Resolver<'a, 'tcx>,\n+                                span: Span,\n+                                name_path: &[ast::Name])\n+                                -> Option<Module<'a>> {\n+            let root = this.current_module;\n             let last_name = name_path.last().unwrap();\n \n             if name_path.len() == 1 {\n@@ -3603,7 +3625,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     let name_path = path.segments.iter()\n                                                         .map(|seg| seg.identifier.name)\n                                                         .collect::<Vec<_>>();\n-                                    let current_module = self.current_module.clone();\n+                                    let current_module = self.current_module;\n \n                                     match self.resolve_module_path(current_module,\n                                                    &name_path[..],\n@@ -3725,7 +3747,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let mut found_traits = Vec::new();\n-        let mut search_module = self.current_module.clone();\n+        let mut search_module = self.current_module;\n         loop {\n             // Look for the current trait.\n             match self.current_trait_ref {\n@@ -3778,10 +3800,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n \n-            match search_module.parent_link.clone() {\n+            match search_module.parent_link {\n                 NoParentLink | ModuleParentLink(..) => break,\n                 BlockParentLink(parent_module, _) => {\n-                    search_module = parent_module.upgrade().unwrap();\n+                    search_module = parent_module;\n                 }\n             }\n         }\n@@ -3828,7 +3850,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     //\n \n     #[allow(dead_code)]   // useful for debugging\n-    fn dump_module(&mut self, module_: Rc<Module>) {\n+    fn dump_module(&mut self, module_: Module<'a>) {\n         debug!(\"Dump of module `{}`:\", module_to_string(&*module_));\n \n         debug!(\"Children:\");\n@@ -3891,20 +3913,20 @@ fn path_names_to_string(path: &Path, depth: usize) -> String {\n }\n \n /// A somewhat inefficient routine to obtain the name of a module.\n-fn module_to_string(module: &Module) -> String {\n+fn module_to_string<'a>(module: Module<'a>) -> String {\n     let mut names = Vec::new();\n \n-    fn collect_mod(names: &mut Vec<ast::Name>, module: &Module) {\n+    fn collect_mod<'a>(names: &mut Vec<ast::Name>, module: Module<'a>) {\n         match module.parent_link {\n             NoParentLink => {}\n             ModuleParentLink(ref module, name) => {\n                 names.push(name);\n-                collect_mod(names, &*module.upgrade().unwrap());\n+                collect_mod(names, module);\n             }\n             BlockParentLink(ref module, _) => {\n                 // danger, shouldn't be ident?\n                 names.push(special_idents::opaque.name);\n-                collect_mod(names, &*module.upgrade().unwrap());\n+                collect_mod(names, module);\n             }\n         }\n     }\n@@ -3946,7 +3968,8 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n                                make_glob_map: MakeGlobMap)\n                                -> CrateMap {\n     let krate = ast_map.krate();\n-    let mut resolver = create_resolver(session, ast_map, krate, make_glob_map, None);\n+    let arenas = Resolver::arenas();\n+    let mut resolver = create_resolver(session, ast_map, krate, make_glob_map, &arenas, None);\n \n     resolver.resolve_crate(krate);\n \n@@ -3978,9 +4001,10 @@ pub fn create_resolver<'a, 'tcx>(session: &'a Session,\n                                  ast_map: &'a hir_map::Map<'tcx>,\n                                  krate: &'a Crate,\n                                  make_glob_map: MakeGlobMap,\n+                                 arenas: &'a ResolverArenas<'a>,\n                                  callback: Option<Box<Fn(hir_map::Node, &mut bool) -> bool>>)\n                                  -> Resolver<'a, 'tcx> {\n-    let mut resolver = Resolver::new(session, ast_map, make_glob_map);\n+    let mut resolver = Resolver::new(session, ast_map, make_glob_map, arenas);\n \n     resolver.callback = callback;\n "}, {"sha": "13f4348f79522052aa2b735df00d24be3f055798", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -28,7 +28,6 @@ use rustc::middle::def::Export;\n use syntax::ast;\n \n use std::ops::{Deref, DerefMut};\n-use std::rc::Rc;\n \n struct ExportRecorder<'a, 'b: 'a, 'tcx: 'b> {\n     resolver: &'a mut Resolver<'b, 'tcx>,\n@@ -50,7 +49,7 @@ impl<'a, 'b, 'tcx:'b> DerefMut for ExportRecorder<'a, 'b, 'tcx> {\n }\n \n impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n-    fn record_exports_for_module_subtree(&mut self, module_: Rc<Module>) {\n+    fn record_exports_for_module_subtree(&mut self, module_: Module<'b>) {\n         // If this isn't a local krate, then bail out. We don't need to record\n         // exports for nonlocal crates.\n \n@@ -59,23 +58,23 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n                 // OK. Continue.\n                 debug!(\"(recording exports for module subtree) recording exports for local \\\n                         module `{}`\",\n-                       module_to_string(&*module_));\n+                       module_to_string(module_));\n             }\n             None => {\n                 // Record exports for the root module.\n                 debug!(\"(recording exports for module subtree) recording exports for root module \\\n                         `{}`\",\n-                       module_to_string(&*module_));\n+                       module_to_string(module_));\n             }\n             Some(_) => {\n                 // Bail out.\n                 debug!(\"(recording exports for module subtree) not recording exports for `{}`\",\n-                       module_to_string(&*module_));\n+                       module_to_string(module_));\n                 return;\n             }\n         }\n \n-        self.record_exports_for_module(&*module_);\n+        self.record_exports_for_module(module_);\n         build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n \n         for (_, child_name_bindings) in module_.children.borrow().iter() {\n@@ -90,11 +89,11 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         }\n \n         for (_, child_module) in module_.anonymous_children.borrow().iter() {\n-            self.record_exports_for_module_subtree(child_module.clone());\n+            self.record_exports_for_module_subtree(child_module);\n         }\n     }\n \n-    fn record_exports_for_module(&mut self, module_: &Module) {\n+    fn record_exports_for_module(&mut self, module_: Module<'b>) {\n         let mut exports = Vec::new();\n \n         self.add_exports_for_module(&mut exports, module_);\n@@ -128,7 +127,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn add_exports_for_module(&mut self, exports: &mut Vec<Export>, module_: &Module) {\n+    fn add_exports_for_module(&mut self, exports: &mut Vec<Export>, module_: Module<'b>) {\n         for (name, import_resolution) in module_.import_resolutions.borrow().iter() {\n             let xs = [TypeNS, ValueNS];\n             for &ns in &xs {\n@@ -150,6 +149,6 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n \n pub fn record(resolver: &mut Resolver) {\n     let mut recorder = ExportRecorder { resolver: resolver };\n-    let root_module = recorder.graph_root.clone();\n+    let root_module = recorder.graph_root;\n     recorder.record_exports_for_module_subtree(root_module);\n }"}, {"sha": "53d1b888d8e87a5b0f8c3bfa837efafe01141178", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 50, "deletions": 54, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -36,7 +36,6 @@ use syntax::codemap::Span;\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use std::mem::replace;\n-use std::rc::Rc;\n \n /// Contains data for specific types of import directives.\n #[derive(Copy, Clone,Debug)]\n@@ -84,17 +83,15 @@ impl ImportDirective {\n \n /// The item that an import resolves to.\n #[derive(Clone,Debug)]\n-pub struct Target {\n-    pub target_module: Rc<Module>,\n-    pub binding: NameBinding,\n+pub struct Target<'a> {\n+    pub target_module: Module<'a>,\n+    pub binding: NameBinding<'a>,\n     pub shadowable: Shadowable,\n }\n \n-impl Target {\n-    pub fn new(target_module: Rc<Module>,\n-               binding: NameBinding,\n-               shadowable: Shadowable)\n-               -> Target {\n+impl<'a> Target<'a> {\n+    pub fn new(target_module: Module<'a>, binding: NameBinding<'a>, shadowable: Shadowable)\n+               -> Self {\n         Target {\n             target_module: target_module,\n             binding: binding,\n@@ -109,44 +106,44 @@ impl Target {\n /// and for each namespace, it records the `use` directive importing the name in the namespace\n /// and the `Target` to which the name in the namespace resolves (if applicable).\n /// Different `use` directives may import the same name in different namespaces.\n-pub struct ImportResolutionPerNamespace {\n+pub struct ImportResolutionPerNamespace<'a> {\n     // When outstanding_references reaches zero, outside modules can count on the targets being\n     // correct. Before then, all bets are off; future `use` directives could override the name.\n     // Since shadowing is forbidden, the only way outstanding_references > 1 in a legal program\n     // is if the name is imported by exactly two `use` directives, one of which resolves to a\n     // value and the other of which resolves to a type.\n     pub outstanding_references: usize,\n-    pub type_ns: ImportResolution,\n-    pub value_ns: ImportResolution,\n+    pub type_ns: ImportResolution<'a>,\n+    pub value_ns: ImportResolution<'a>,\n }\n \n /// Records what we know about an imported name in a namespace (see `ImportResolutionPerNamespace`).\n #[derive(Clone,Debug)]\n-pub struct ImportResolution {\n+pub struct ImportResolution<'a> {\n     /// Whether the name in the namespace was imported with a `use` or a `pub use`.\n     pub is_public: bool,\n \n     /// Resolution of the name in the namespace\n-    pub target: Option<Target>,\n+    pub target: Option<Target<'a>>,\n \n     /// The source node of the `use` directive\n     pub id: NodeId,\n }\n \n-impl ::std::ops::Index<Namespace> for ImportResolutionPerNamespace {\n-    type Output = ImportResolution;\n-    fn index(&self, ns: Namespace) -> &ImportResolution {\n+impl<'a> ::std::ops::Index<Namespace> for ImportResolutionPerNamespace<'a> {\n+    type Output = ImportResolution<'a>;\n+    fn index(&self, ns: Namespace) -> &ImportResolution<'a> {\n         match ns { TypeNS => &self.type_ns, ValueNS => &self.value_ns }\n     }\n }\n \n-impl ::std::ops::IndexMut<Namespace> for ImportResolutionPerNamespace {\n-    fn index_mut(&mut self, ns: Namespace) -> &mut ImportResolution {\n+impl<'a> ::std::ops::IndexMut<Namespace> for ImportResolutionPerNamespace<'a> {\n+    fn index_mut(&mut self, ns: Namespace) -> &mut ImportResolution<'a> {\n         match ns { TypeNS => &mut self.type_ns, ValueNS => &mut self.value_ns }\n     }\n }\n \n-impl ImportResolutionPerNamespace {\n+impl<'a> ImportResolutionPerNamespace<'a> {\n     pub fn new(id: NodeId, is_public: bool) -> Self {\n         let resolution = ImportResolution { id: id, is_public: is_public, target: None };\n         ImportResolutionPerNamespace {\n@@ -191,8 +188,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                    i,\n                    self.resolver.unresolved_imports);\n \n-            let module_root = self.resolver.graph_root.clone();\n-            let errors = self.resolve_imports_for_module_subtree(module_root.clone());\n+            let module_root = self.resolver.graph_root;\n+            let errors = self.resolve_imports_for_module_subtree(module_root);\n \n             if self.resolver.unresolved_imports == 0 {\n                 debug!(\"(resolving imports) success\");\n@@ -225,13 +222,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     /// Attempts to resolve imports for the given module and all of its\n     /// submodules.\n     fn resolve_imports_for_module_subtree(&mut self,\n-                                          module_: Rc<Module>)\n+                                          module_: Module<'b>)\n                                           -> Vec<ImportResolvingError> {\n         let mut errors = Vec::new();\n         debug!(\"(resolving imports for module subtree) resolving {}\",\n                module_to_string(&*module_));\n-        let orig_module = replace(&mut self.resolver.current_module, module_.clone());\n-        errors.extend(self.resolve_imports_for_module(module_.clone()));\n+        let orig_module = replace(&mut self.resolver.current_module, module_);\n+        errors.extend(self.resolve_imports_for_module(module_));\n         self.resolver.current_module = orig_module;\n \n         build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n@@ -247,14 +244,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         }\n \n         for (_, child_module) in module_.anonymous_children.borrow().iter() {\n-            errors.extend(self.resolve_imports_for_module_subtree(child_module.clone()));\n+            errors.extend(self.resolve_imports_for_module_subtree(child_module));\n         }\n \n         errors\n     }\n \n     /// Attempts to resolve imports for the given module only.\n-    fn resolve_imports_for_module(&mut self, module: Rc<Module>) -> Vec<ImportResolvingError> {\n+    fn resolve_imports_for_module(&mut self, module: Module<'b>) -> Vec<ImportResolvingError> {\n         let mut errors = Vec::new();\n \n         if module.all_imports_resolved() {\n@@ -268,7 +265,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         let mut indeterminate_imports = Vec::new();\n         while module.resolved_import_count.get() + indeterminate_imports.len() < import_count {\n             let import_index = module.resolved_import_count.get();\n-            match self.resolve_import_for_module(module.clone(), &imports[import_index]) {\n+            match self.resolve_import_for_module(module, &imports[import_index]) {\n                 ResolveResult::Failed(err) => {\n                     let import_directive = &imports[import_index];\n                     let (span, help) = match err {\n@@ -306,7 +303,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     /// currently-unresolved imports, or success if we know the name exists.\n     /// If successful, the resolved bindings are written into the module.\n     fn resolve_import_for_module(&mut self,\n-                                 module_: Rc<Module>,\n+                                 module_: Module<'b>,\n                                  import_directive: &ImportDirective)\n                                  -> ResolveResult<()> {\n         let mut resolution_result = ResolveResult::Failed(None);\n@@ -319,9 +316,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // First, resolve the module path for the directive, if necessary.\n         let container = if module_path.is_empty() {\n             // Use the crate root.\n-            Some((self.resolver.graph_root.clone(), LastMod(AllPublic)))\n+            Some((self.resolver.graph_root, LastMod(AllPublic)))\n         } else {\n-            match self.resolver.resolve_module_path(module_.clone(),\n+            match self.resolver.resolve_module_path(module_,\n                                                     &module_path[..],\n                                                     UseLexicalScopeFlag::DontUseLexicalScope,\n                                                     import_directive.span,\n@@ -399,8 +396,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     }\n \n     fn resolve_single_import(&mut self,\n-                             module_: &Module,\n-                             target_module: Rc<Module>,\n+                             module_: Module<'b>,\n+                             target_module: Module<'b>,\n                              target: Name,\n                              source: Name,\n                              directive: &ImportDirective,\n@@ -447,7 +444,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 let mut pub_err = false;\n                 if child_name_bindings.value_ns.defined() {\n                     debug!(\"(resolving single import) found value binding\");\n-                    value_result = BoundResult(target_module.clone(),\n+                    value_result = BoundResult(target_module,\n                                                child_name_bindings.value_ns.clone());\n                     if directive.is_public && !child_name_bindings.value_ns.is_public() {\n                         let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n@@ -473,7 +470,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 }\n                 if child_name_bindings.type_ns.defined() {\n                     debug!(\"(resolving single import) found type binding\");\n-                    type_result = BoundResult(target_module.clone(),\n+                    type_result = BoundResult(target_module,\n                                               child_name_bindings.type_ns.clone());\n                     if !pub_err && directive.is_public &&\n                        !child_name_bindings.type_ns.is_public() {\n@@ -543,11 +540,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     }\n                     Some(import_resolution) if import_resolution.outstanding_references == 0 => {\n \n-                        fn get_binding(this: &mut Resolver,\n-                                       import_resolution: &ImportResolutionPerNamespace,\n-                                       namespace: Namespace,\n-                                       source: Name)\n-                                       -> NamespaceResult {\n+                        fn get_binding<'a>(this: &mut Resolver,\n+                                           import_resolution: &ImportResolutionPerNamespace<'a>,\n+                                           namespace: Namespace,\n+                                           source: Name)\n+                                           -> NamespaceResult<'a> {\n \n                             // Import resolutions must be declared with \"pub\"\n                             // in order to be exported.\n@@ -640,7 +637,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         match type_result {\n             BoundResult(..) => {}\n             _ => {\n-                match target_module.external_module_children.borrow_mut().get(&source).cloned() {\n+                match target_module.external_module_children.borrow_mut().get(&source) {\n                     None => {} // Continue.\n                     Some(module) => {\n                         debug!(\"(resolving single import) found external module\");\n@@ -652,7 +649,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                             _ => {}\n                         }\n                         let name_binding = NameBinding::create_from_module(module);\n-                        type_result = BoundResult(target_module.clone(), name_binding);\n+                        type_result = BoundResult(target_module, name_binding);\n                         type_used_public = true;\n                     }\n                 }\n@@ -685,7 +682,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                              target);\n \n                         import_resolution[namespace] = ImportResolution {\n-                            target: Some(Target::new(target_module.clone(),\n+                            target: Some(Target::new(target_module,\n                                                      name_binding.clone(),\n                                                      directive.shadowable)),\n                             id: directive.id,\n@@ -777,8 +774,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     // that exports nothing is valid). target_module is the module we are\n     // actually importing, i.e., `foo` in `use foo::*`.\n     fn resolve_glob_import(&mut self,\n-                           module_: &Module,\n-                           target_module: Rc<Module>,\n+                           module_: Module<'b>,\n+                           target_module: Module<'b>,\n                            import_directive: &ImportDirective,\n                            lp: LastPrivate)\n                            -> ResolveResult<()> {\n@@ -841,7 +838,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         for (&name, name_bindings) in target_module.children.borrow().iter() {\n             self.merge_import_resolution(module_,\n-                                         target_module.clone(),\n+                                         target_module,\n                                          import_directive,\n                                          name,\n                                          name_bindings.clone());\n@@ -863,11 +860,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     }\n \n     fn merge_import_resolution(&mut self,\n-                               module_: &Module,\n-                               containing_module: Rc<Module>,\n+                               module_: Module<'b>,\n+                               containing_module: Module<'b>,\n                                import_directive: &ImportDirective,\n                                name: Name,\n-                               name_bindings: NameBindings) {\n+                               name_bindings: NameBindings<'b>) {\n         let id = import_directive.id;\n         let is_public = import_directive.is_public;\n \n@@ -916,7 +913,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                   msg);\n                     } else {\n                         dest_import_resolution[namespace] = ImportResolution {\n-                            target: Some(Target::new(containing_module.clone(),\n+                            target: Some(Target::new(containing_module,\n                                                      name_bindings[namespace].clone(),\n                                                      import_directive.shadowable)),\n                             id: id,\n@@ -993,8 +990,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n     /// Checks that imported names and items don't have the same name.\n     fn check_for_conflicts_between_imports_and_items(&mut self,\n-                                                     module: &Module,\n-                                                     import: &ImportResolutionPerNamespace,\n+                                                     module: Module<'b>,\n+                                                     import: &ImportResolutionPerNamespace<'b>,\n                                                      import_span: Span,\n                                                      name: Name) {\n         // First, check for conflicts between imports and `extern crate`s.\n@@ -1013,8 +1010,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         }\n \n         // Check for item conflicts.\n-        let children = module.children.borrow();\n-        let name_bindings = match children.get(&name) {\n+        let name_bindings = match module.children.borrow().get(&name) {\n             None => {\n                 // There can't be any conflicts.\n                 return;"}, {"sha": "f46a7ea67b5f23aa7aadb72d978806d1163a9ce3", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -1760,6 +1760,9 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     let lvalue = Lvalue::new_with_hint(caller_name, bcx, p_id, HintKind::DontZeroJustUse);\n     let datum = Datum::new(llval, var_ty, lvalue);\n \n+    debug!(\"mk_binding_alloca cleanup_scope={:?} llval={} var_ty={:?}\",\n+           cleanup_scope, bcx.ccx().tn().val_to_string(llval), var_ty);\n+\n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n     call_lifetime_start(bcx, llval);"}, {"sha": "d22d619b9622754002c18d29f3b14a9c8eb92bee", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -55,6 +55,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::attr::IntType;\n use trans::_match;\n+use trans::base::InitAlloca;\n use trans::build::*;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n@@ -1279,7 +1280,12 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n             let scratch = unpack_datum!(bcx, datum::lvalue_scratch_datum(\n                 bcx, tcx.dtor_type(), \"drop_flag\",\n-                cleanup::CustomScope(custom_cleanup_scope), (), |_, bcx, _| bcx\n+                InitAlloca::Uninit(\"drop flag itself has no dtor\"),\n+                cleanup::CustomScope(custom_cleanup_scope), (), |_, bcx, _| {\n+                    debug!(\"no-op populate call for trans_drop_flag_ptr on dtor_type={:?}\",\n+                           tcx.dtor_type());\n+                    bcx\n+                }\n             ));\n             bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {\n                 let ptr = struct_field_ptr(variant_cx, st, MaybeSizedValue::sized(value),"}, {"sha": "f8b5f8e48f49930e92c303d91771ff3940212b4b", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 151, "deletions": 40, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -1147,48 +1147,63 @@ pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>, val: ValueRef, f: F) ->\n     next_cx\n }\n \n-pub fn call_lifetime_start(cx: Block, ptr: ValueRef) {\n-    if cx.sess().opts.optimize == config::No {\n+enum Lifetime { Start, End }\n+\n+// If LLVM lifetime intrinsic support is enabled (i.e. optimizations\n+// on), and `ptr` is nonzero-sized, then extracts the size of `ptr`\n+// and the intrinsic for `lt` and passes them to `emit`, which is in\n+// charge of generating code to call the passed intrinsic on whatever\n+// block of generated code is targetted for the intrinsic.\n+//\n+// If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n+// off) or `ptr` is zero-sized, then no-op (does not call `emit`).\n+fn core_lifetime_emit<'blk, 'tcx, F>(ccx: &'blk CrateContext<'blk, 'tcx>,\n+                                     ptr: ValueRef,\n+                                     lt: Lifetime,\n+                                     emit: F)\n+    where F: FnOnce(&'blk CrateContext<'blk, 'tcx>, machine::llsize, ValueRef)\n+{\n+    if ccx.sess().opts.optimize == config::No {\n         return;\n     }\n \n-    let _icx = push_ctxt(\"lifetime_start\");\n-    let ccx = cx.ccx();\n+    let _icx = push_ctxt(match lt {\n+        Lifetime::Start => \"lifetime_start\",\n+        Lifetime::End => \"lifetime_end\"\n+    });\n \n     let size = machine::llsize_of_alloc(ccx, val_ty(ptr).element_type());\n     if size == 0 {\n         return;\n     }\n \n-    let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n-    let lifetime_start = ccx.get_intrinsic(&\"llvm.lifetime.start\");\n-    Call(cx,\n-         lifetime_start,\n-         &[C_u64(ccx, size), ptr],\n-         None,\n-         DebugLoc::None);\n+    let lifetime_intrinsic = ccx.get_intrinsic(match lt {\n+        Lifetime::Start => \"llvm.lifetime.start\",\n+        Lifetime::End => \"llvm.lifetime.end\"\n+    });\n+    emit(ccx, size, lifetime_intrinsic)\n }\n \n-pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n-    if cx.sess().opts.optimize == config::No {\n-        return;\n-    }\n-\n-    let _icx = push_ctxt(\"lifetime_end\");\n-    let ccx = cx.ccx();\n-\n-    let size = machine::llsize_of_alloc(ccx, val_ty(ptr).element_type());\n-    if size == 0 {\n-        return;\n-    }\n+pub fn call_lifetime_start(cx: Block, ptr: ValueRef) {\n+    core_lifetime_emit(cx.ccx(), ptr, Lifetime::Start, |ccx, size, lifetime_start| {\n+        let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n+        Call(cx,\n+             lifetime_start,\n+             &[C_u64(ccx, size), ptr],\n+             None,\n+             DebugLoc::None);\n+    })\n+}\n \n-    let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n-    let lifetime_end = ccx.get_intrinsic(&\"llvm.lifetime.end\");\n-    Call(cx,\n-         lifetime_end,\n-         &[C_u64(ccx, size), ptr],\n-         None,\n-         DebugLoc::None);\n+pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n+    core_lifetime_emit(cx.ccx(), ptr, Lifetime::End, |ccx, size, lifetime_end| {\n+        let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n+        Call(cx,\n+             lifetime_end,\n+             &[C_u64(ccx, size), ptr],\n+             None,\n+             DebugLoc::None);\n+    })\n }\n \n // Generates code for resumption of unwind at the end of a landing pad.\n@@ -1285,12 +1300,81 @@ fn memfill<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>, byte:\n            None);\n }\n \n-pub fn alloc_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, name: &str) -> ValueRef {\n+/// In general, when we create an scratch value in an alloca, the\n+/// creator may not know if the block (that initializes the scratch\n+/// with the desired value) actually dominates the cleanup associated\n+/// with the scratch value.\n+///\n+/// To deal with this, when we do an alloca (at the *start* of whole\n+/// function body), we optionally can also set the associated\n+/// dropped-flag state of the alloca to \"dropped.\"\n+#[derive(Copy, Clone, Debug)]\n+pub enum InitAlloca {\n+    /// Indicates that the state should have its associated drop flag\n+    /// set to \"dropped\" at the point of allocation.\n+    Dropped,\n+    /// Indicates the value of the associated drop flag is irrelevant.\n+    /// The embedded string literal is a programmer provided argument\n+    /// for why. This is a safeguard forcing compiler devs to\n+    /// document; it might be a good idea to also emit this as a\n+    /// comment with the alloca itself when emitting LLVM output.ll.\n+    Uninit(&'static str),\n+}\n+\n+\n+pub fn alloc_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                            t: Ty<'tcx>,\n+                            name: &str) -> ValueRef {\n+    // pnkfelix: I do not know why alloc_ty meets the assumptions for\n+    // passing Uninit, but it was never needed (even back when we had\n+    // the original boolean `zero` flag on `lvalue_scratch_datum`).\n+    alloc_ty_init(bcx, t, InitAlloca::Uninit(\"all alloc_ty are uninit\"), name)\n+}\n+\n+/// This variant of `fn alloc_ty` does not necessarily assume that the\n+/// alloca should be created with no initial value. Instead the caller\n+/// controls that assumption via the `init` flag.\n+///\n+/// Note that if the alloca *is* initialized via `init`, then we will\n+/// also inject an `llvm.lifetime.start` before that initialization\n+/// occurs, and thus callers should not call_lifetime_start\n+/// themselves.  But if `init` says \"uninitialized\", then callers are\n+/// in charge of choosing where to call_lifetime_start and\n+/// subsequently populate the alloca.\n+///\n+/// (See related discussion on PR #30823.)\n+pub fn alloc_ty_init<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             t: Ty<'tcx>,\n+                             init: InitAlloca,\n+                             name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n     assert!(!t.has_param_types());\n-    alloca(bcx, ty, name)\n+    match init {\n+        InitAlloca::Dropped => alloca_dropped(bcx, t, name),\n+        InitAlloca::Uninit(_) => alloca(bcx, ty, name),\n+    }\n+}\n+\n+pub fn alloca_dropped<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ty: Ty<'tcx>, name: &str) -> ValueRef {\n+    let _icx = push_ctxt(\"alloca_dropped\");\n+    let llty = type_of::type_of(cx.ccx(), ty);\n+    if cx.unreachable.get() {\n+        unsafe { return llvm::LLVMGetUndef(llty.ptr_to().to_ref()); }\n+    }\n+    let p = alloca(cx, llty, name);\n+    let b = cx.fcx.ccx.builder();\n+    b.position_before(cx.fcx.alloca_insert_pt.get().unwrap());\n+\n+    // This is just like `call_lifetime_start` (but latter expects a\n+    // Block, which we do not have for `alloca_insert_pt`).\n+    core_lifetime_emit(cx.ccx(), p, Lifetime::Start, |ccx, size, lifetime_start| {\n+        let ptr = b.pointercast(p, Type::i8p(ccx));\n+        b.call(lifetime_start, &[C_u64(ccx, size), ptr], None);\n+    });\n+    memfill(&b, p, ty, adt::DTOR_DONE);\n+    p\n }\n \n pub fn alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n@@ -1565,6 +1649,7 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n     // Create the drop-flag hints for every unfragmented path in the function.\n     let tcx = fcx.ccx.tcx();\n     let fn_did = tcx.map.local_def_id(fcx.id);\n+    let tables = tcx.tables.borrow();\n     let mut hints = fcx.lldropflag_hints.borrow_mut();\n     let fragment_infos = tcx.fragment_infos.borrow();\n \n@@ -1588,12 +1673,22 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n             let (var, datum) = match info {\n                 ty::FragmentInfo::Moved { var, .. } |\n                 ty::FragmentInfo::Assigned { var, .. } => {\n-                    let datum = seen.get(&var).cloned().unwrap_or_else(|| {\n-                        let datum = make_datum(var);\n-                        seen.insert(var, datum.clone());\n-                        datum\n+                    let opt_datum = seen.get(&var).cloned().unwrap_or_else(|| {\n+                        let ty = tables.node_types[&var];\n+                        if fcx.type_needs_drop(ty) {\n+                            let datum = make_datum(var);\n+                            seen.insert(var, Some(datum.clone()));\n+                            Some(datum)\n+                        } else {\n+                            // No drop call needed, so we don't need a dropflag hint\n+                            None\n+                        }\n                     });\n-                    (var, datum)\n+                    if let Some(datum) = opt_datum {\n+                        (var, datum)\n+                    } else {\n+                        continue\n+                    }\n                 }\n             };\n             match info {\n@@ -1639,6 +1734,8 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n     let fcx = bcx.fcx;\n     let arg_scope_id = cleanup::CustomScope(arg_scope);\n \n+    debug!(\"create_datums_for_fn_args\");\n+\n     // Return an array wrapping the ValueRefs that we get from `get_param` for\n     // each argument into datums.\n     //\n@@ -1650,6 +1747,7 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n     // This alloca should be optimized away by LLVM's mem-to-reg pass in\n     // the event it's not truly needed.\n     let mut idx = fcx.arg_offset() as c_uint;\n+    let uninit_reason = InitAlloca::Uninit(\"fn_arg populate dominates dtor\");\n     for (i, &arg_ty) in arg_tys.iter().enumerate() {\n         let arg_datum = if !has_tupled_arg || i < arg_tys.len() - 1 {\n             if type_of::arg_is_indirect(bcx.ccx(), arg_ty) &&\n@@ -1669,9 +1767,12 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n                 let data = get_param(fcx.llfn, idx);\n                 let extra = get_param(fcx.llfn, idx + 1);\n                 idx += 2;\n-                unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\",\n+                unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\", uninit_reason,\n                                                         arg_scope_id, (data, extra),\n                                                         |(data, extra), bcx, dst| {\n+                    debug!(\"populate call for create_datum_for_fn_args \\\n+                            early fat arg, on arg[{}] ty={:?}\", i, arg_ty);\n+\n                     Store(bcx, data, expr::get_dataptr(bcx, dst));\n                     Store(bcx, extra, expr::get_meta(bcx, dst));\n                     bcx\n@@ -1684,9 +1785,16 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n                               datum::lvalue_scratch_datum(bcx,\n                                                           arg_ty,\n                                                           \"\",\n+                                                          uninit_reason,\n                                                           arg_scope_id,\n                                                           tmp,\n-                                                          |tmp, bcx, dst| tmp.store_to(bcx, dst)))\n+                                                          |tmp, bcx, dst| {\n+\n+                        debug!(\"populate call for create_datum_for_fn_args \\\n+                                early thin arg, on arg[{}] ty={:?}\", i, arg_ty);\n+\n+                                                              tmp.store_to(bcx, dst)\n+                                                          }))\n             }\n         } else {\n             // FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n@@ -1696,11 +1804,14 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n                                   datum::lvalue_scratch_datum(bcx,\n                                                               arg_ty,\n                                                               \"tupled_args\",\n+                                                              uninit_reason,\n                                                               arg_scope_id,\n                                                               (),\n                                                               |(),\n                                                                mut bcx,\n-                                                               llval| {\n+                                                              llval| {\n+                        debug!(\"populate call for create_datum_for_fn_args \\\n+                                tupled_args, on arg[{}] ty={:?}\", i, arg_ty);\n                         for (j, &tupled_arg_ty) in\n                                     tupled_arg_tys.iter().enumerate() {\n                             let lldest = StructGEP(bcx, llval, j);"}, {"sha": "32f263746d31e04158742f0abcf12395ad1d44c4", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -288,20 +288,31 @@ pub fn immediate_rvalue_bcx<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     return DatumBlock::new(bcx, immediate_rvalue(val, ty))\n }\n \n-\n /// Allocates temporary space on the stack using alloca() and returns a by-ref Datum pointing to\n /// it. The memory will be dropped upon exit from `scope`. The callback `populate` should\n /// initialize the memory.\n+///\n+/// The flag `zero` indicates how the temporary space itself should be\n+/// initialized at the outset of the function; the only time that\n+/// `InitAlloca::Uninit` is a valid value for `zero` is when the\n+/// caller can prove that either (1.) the code injected by `populate`\n+/// onto `bcx` always dominates the end of `scope`, or (2.) the data\n+/// being allocated has no associated destructor.\n pub fn lvalue_scratch_datum<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n                                               ty: Ty<'tcx>,\n                                               name: &str,\n+                                              zero: InitAlloca,\n                                               scope: cleanup::ScopeId,\n                                               arg: A,\n                                               populate: F)\n                                               -> DatumBlock<'blk, 'tcx, Lvalue> where\n     F: FnOnce(A, Block<'blk, 'tcx>, ValueRef) -> Block<'blk, 'tcx>,\n {\n-    let scratch = alloc_ty(bcx, ty, name);\n+    // Very subtle: potentially initialize the scratch memory at point where it is alloca'ed.\n+    // (See discussion at Issue 30530.)\n+    let scratch = alloc_ty_init(bcx, ty, zero, name);\n+    debug!(\"lvalue_scratch_datum scope={:?} scratch={} ty={:?}\",\n+           scope, bcx.ccx().tn().val_to_string(scratch), ty);\n \n     // Subtle. Populate the scratch memory *before* scheduling cleanup.\n     let bcx = populate(arg, bcx, scratch);\n@@ -340,6 +351,8 @@ fn add_rvalue_clean<'a, 'tcx>(mode: RvalueMode,\n                               scope: cleanup::ScopeId,\n                               val: ValueRef,\n                               ty: Ty<'tcx>) {\n+    debug!(\"add_rvalue_clean scope={:?} val={} ty={:?}\",\n+           scope, fcx.ccx.tn().val_to_string(val), ty);\n     match mode {\n         ByValue => { fcx.schedule_drop_immediate(scope, val, ty); }\n         ByRef => {\n@@ -496,9 +509,13 @@ impl<'tcx> Datum<'tcx, Rvalue> {\n \n             ByValue => {\n                 lvalue_scratch_datum(\n-                    bcx, self.ty, name, scope, self,\n+                    bcx, self.ty, name, InitAlloca::Dropped, scope, self,\n                     |this, bcx, llval| {\n-                        call_lifetime_start(bcx, llval);\n+                        debug!(\"populate call for Datum::to_lvalue_datum_in_scope \\\n+                                self.ty={:?}\", this.ty);\n+                        // do not call_lifetime_start here; the\n+                        // `InitAlloc::Dropped` will start scratch\n+                        // value's lifetime at open of function body.\n                         let bcx = this.store_to(bcx, llval);\n                         bcx.fcx.schedule_lifetime_end(scope, llval);\n                         bcx"}, {"sha": "57afd0b580f177d40906cf3022e3d2e62b955638", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -1487,6 +1487,8 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     };\n \n+    debug!(\"trans_adt\");\n+\n     // This scope holds intermediates that must be cleaned should\n     // panic occur before the ADT as a whole is ready.\n     let custom_cleanup_scope = fcx.push_custom_cleanup_scope();"}, {"sha": "3a1568a70c9922d8d8804c8daa75b0c6b402a090", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -111,8 +111,15 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Always create an alloca even if zero-sized, to preserve\n     // the non-null invariant of the inner slice ptr\n-    let llfixed = base::alloc_ty(bcx, fixed_ty, \"\");\n-    call_lifetime_start(bcx, llfixed);\n+    let llfixed;\n+    // Issue 30018: ensure state is initialized as dropped if necessary.\n+    if fcx.type_needs_drop(vt.unit_ty) {\n+        llfixed = base::alloc_ty_init(bcx, fixed_ty, InitAlloca::Dropped, \"\");\n+    } else {\n+        let uninit = InitAlloca::Uninit(\"fcx says vt.unit_ty is non-drop\");\n+        llfixed = base::alloc_ty_init(bcx, fixed_ty, uninit, \"\");\n+        call_lifetime_start(bcx, llfixed);\n+    };\n \n     if count > 0 {\n         // Arrange for the backing array to be cleaned up.\n@@ -212,8 +219,8 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         bcx = expr::trans_into(bcx, &**element,\n                                                SaveIn(lleltptr));\n                         let scope = cleanup::CustomScope(temp_scope);\n-                        fcx.schedule_lifetime_end(scope, lleltptr);\n-                        fcx.schedule_drop_mem(scope, lleltptr, vt.unit_ty, None);\n+                        // Issue #30822: mark memory as dropped after running destructor\n+                        fcx.schedule_drop_and_fill_mem(scope, lleltptr, vt.unit_ty, None);\n                     }\n                     fcx.pop_custom_cleanup_scope(temp_scope);\n                 }"}, {"sha": "8bc1c184d20387daa6939e4534a086637a444deb", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -1819,10 +1819,10 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Optio\n         } else if stab.level == stability::Unstable {\n             let unstable_extra = if show_reason {\n                 match (!stab.feature.is_empty(), &cx.issue_tracker_base_url, stab.issue) {\n-                    (true, &Some(ref tracker_url), Some(issue_no)) =>\n+                    (true, &Some(ref tracker_url), Some(issue_no)) if issue_no > 0 =>\n                         format!(\" (<code>{}</code> <a href=\\\"{}{}\\\">#{}</a>)\",\n                                 Escape(&stab.feature), tracker_url, issue_no, issue_no),\n-                    (false, &Some(ref tracker_url), Some(issue_no)) =>\n+                    (false, &Some(ref tracker_url), Some(issue_no)) if issue_no > 0 =>\n                         format!(\" (<a href=\\\"{}{}\\\">#{}</a>)\", Escape(&tracker_url), issue_no,\n                                 issue_no),\n                     (true, _, _) =>"}, {"sha": "a9a79fe2c7733f3afc9332c2f99f8f62b4724791", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -772,21 +772,6 @@ impl<W: Write> fmt::Debug for LineWriter<W> where W: fmt::Debug {\n     }\n }\n \n-struct InternalBufWriter<W: Write>(BufWriter<W>);\n-\n-impl<W: Read + Write> InternalBufWriter<W> {\n-    fn get_mut(&mut self) -> &mut BufWriter<W> {\n-        let InternalBufWriter(ref mut w) = *self;\n-        return w;\n-    }\n-}\n-\n-impl<W: Read + Write> Read for InternalBufWriter<W> {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.get_mut().inner.as_mut().unwrap().read(buf)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;"}, {"sha": "8561ecd9c4cb92d9e21952fe65167c03b9ad9ab5", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -206,7 +206,7 @@ pub fn on_panic(obj: &(Any+Send), file: &'static str, line: u32) {\n     // debugger provides a useable stacktrace.\n     if panics >= 3 {\n         util::dumb_print(format_args!(\"thread panicked while processing \\\n-                                       panic. aborting.\"));\n+                                       panic. aborting.\\n\"));\n         unsafe { intrinsics::abort() }\n     }\n \n@@ -232,7 +232,7 @@ pub fn on_panic(obj: &(Any+Send), file: &'static str, line: u32) {\n         // just abort. In the future we may consider resuming\n         // unwinding or otherwise exiting the thread cleanly.\n         util::dumb_print(format_args!(\"thread panicked while panicking. \\\n-                                       aborting.\"));\n+                                       aborting.\\n\"));\n         unsafe { intrinsics::abort() }\n     }\n }"}, {"sha": "23a368a30a52bc4cfb67f4d8bfd81cbfb8406289", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -222,7 +222,7 @@ mod imp {\n             // getentropy(2) permits a maximum buffer size of 256 bytes\n             for s in v.chunks_mut(256) {\n                 let ret = unsafe {\n-                    libc::syscall(libc::NR_GETENTROPY, s.as_mut_ptr(), s.len())\n+                    libc::getentropy(s.as_mut_ptr() as *mut libc::c_void, s.len())\n                 };\n                 if ret == -1 {\n                     panic!(\"unexpected getentropy error: {}\", errno());"}, {"sha": "b7a6b7650d54079de57495659ba7684dc697264a", "filename": "src/libstd/sys/common/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -35,12 +35,12 @@ pub fn dumb_print(args: fmt::Arguments) {\n }\n \n pub fn abort(args: fmt::Arguments) -> ! {\n-    dumb_print(format_args!(\"fatal runtime error: {}\", args));\n+    dumb_print(format_args!(\"fatal runtime error: {}\\n\", args));\n     unsafe { intrinsics::abort(); }\n }\n \n #[allow(dead_code)] // stack overflow detection not enabled on all platforms\n pub unsafe fn report_overflow() {\n-    dumb_print(format_args!(\"\\nthread '{}' has overflowed its stack\",\n+    dumb_print(format_args!(\"\\nthread '{}' has overflowed its stack\\n\",\n                             thread::current().name().unwrap_or(\"<unknown>\")));\n }"}, {"sha": "10fda3fcd7fa5165ce82e70ea0fab45d8517559e", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -204,7 +204,8 @@ impl DirEntry {\n \n     #[cfg(any(target_os = \"macos\",\n               target_os = \"ios\",\n-              target_os = \"netbsd\"))]\n+              target_os = \"netbsd\",\n+              target_os = \"openbsd\"))]\n     fn name_bytes(&self) -> &[u8] {\n         unsafe {\n             ::slice::from_raw_parts(self.entry.d_name.as_ptr() as *const u8,\n@@ -213,8 +214,7 @@ impl DirEntry {\n     }\n     #[cfg(any(target_os = \"freebsd\",\n               target_os = \"dragonfly\",\n-              target_os = \"bitrig\",\n-              target_os = \"openbsd\"))]\n+              target_os = \"bitrig\"))]\n     fn name_bytes(&self) -> &[u8] {\n         unsafe {\n             ::slice::from_raw_parts(self.entry.d_name.as_ptr() as *const u8,"}, {"sha": "9771b057d8d21f5bfac77a38cbb71b5130e5c899", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -15,6 +15,7 @@ use io::{self, ErrorKind};\n use libc;\n use num::One;\n use ops::Neg;\n+use alloc::oom;\n \n #[cfg(target_os = \"android\")]   pub use os::android as platform;\n #[cfg(target_os = \"bitrig\")]    pub use os::bitrig as platform;\n@@ -45,6 +46,22 @@ pub mod thread_local;\n pub mod time;\n pub mod stdio;\n \n+// A nicer handler for out-of-memory situations than the default one. This one\n+// prints a message to stderr before aborting. It is critical that this code\n+// does not allocate any memory since we are in an OOM situation. Any errors are\n+// ignored while printing since there's nothing we can do about them and we are\n+// about to exit anyways.\n+fn oom_handler() -> ! {\n+    use intrinsics;\n+    let msg = \"fatal runtime error: out of memory\\n\";\n+    unsafe {\n+        libc::write(libc::STDERR_FILENO,\n+                    msg.as_ptr() as *const libc::c_void,\n+                    msg.len() as libc::size_t);\n+        intrinsics::abort();\n+    }\n+}\n+\n #[cfg(not(any(target_os = \"nacl\", test)))]\n pub fn init() {\n     use libc::signal;\n@@ -58,10 +75,14 @@ pub fn init() {\n     unsafe {\n         assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != !0);\n     }\n+\n+    oom::set_oom_handler(oom_handler);\n }\n \n #[cfg(all(target_os = \"nacl\", not(test)))]\n-pub fn init() { }\n+pub fn init() {\n+    oom::set_oom_handler(oom_handler);\n+}\n \n pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     match errno as libc::c_int {"}, {"sha": "fc49f4257be2ace4908917a38edd0278ce04b774", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -59,19 +59,19 @@ mod imp {\n     static mut PAGE_SIZE: usize = 0;\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> *mut libc::c_void {\n+    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize {\n         #[repr(C)]\n         struct siginfo_t {\n             a: [libc::c_int; 3], // si_signo, si_code, si_errno,\n             si_addr: *mut libc::c_void,\n         }\n \n-        (*(info as *const siginfo_t)).si_addr\n+        (*(info as *const siginfo_t)).si_addr as usize\n     }\n \n     #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n-    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> *mut libc::c_void {\n-        (*info).si_addr\n+    unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize {\n+        (*info).si_addr as usize\n     }\n \n     // Signal handler for the SIGSEGV and SIGBUS handlers. We've got guard pages\n@@ -98,7 +98,7 @@ mod imp {\n         use sys_common::util::report_overflow;\n \n         let guard = thread_info::stack_guard().unwrap_or(0);\n-        let addr = siginfo_si_addr(info) as usize;\n+        let addr = siginfo_si_addr(info);\n \n         // If the faulting address is within the guard page, then we print a\n         // message saying so."}, {"sha": "16c4ae8257c132d7018e018fcab09c682f8f8db6", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -20,6 +20,7 @@ use num::Zero;\n use os::windows::ffi::{OsStrExt, OsStringExt};\n use path::PathBuf;\n use time::Duration;\n+use alloc::oom;\n \n #[macro_use] pub mod compat;\n \n@@ -42,7 +43,26 @@ pub mod thread_local;\n pub mod time;\n pub mod stdio;\n \n-pub fn init() {}\n+// See comment in sys/unix/mod.rs\n+fn oom_handler() -> ! {\n+    use intrinsics;\n+    use ptr;\n+    let msg = \"fatal runtime error: out of memory\\n\";\n+    unsafe {\n+        // WriteFile silently fails if it is passed an invalid handle, so there\n+        // is no need to check the result of GetStdHandle.\n+        c::WriteFile(c::GetStdHandle(c::STD_ERROR_HANDLE),\n+                     msg.as_ptr() as c::LPVOID,\n+                     msg.len() as c::DWORD,\n+                     ptr::null_mut(),\n+                     ptr::null_mut());\n+        intrinsics::abort();\n+    }\n+}\n+\n+pub fn init() {\n+    oom::set_oom_handler(oom_handler);\n+}\n \n pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     match errno as c::DWORD {"}, {"sha": "7ecb3920cc86c9ede483e4a79cf264de587ec15a", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -40,7 +40,7 @@ const MILLIS_PER_SEC: u64 = 1_000;\n /// let ten_millis = Duration::from_millis(10);\n /// ```\n #[stable(feature = \"duration\", since = \"1.3.0\")]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n pub struct Duration {\n     secs: u64,\n     nanos: u32, // Always 0 <= nanos < NANOS_PER_SEC"}, {"sha": "dcc344c4ffd2140f6d6b9965aba5c936bbd12924", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -919,7 +919,6 @@ fn get_concurrency() -> usize {\n     #[cfg(any(target_os = \"freebsd\",\n               target_os = \"dragonfly\",\n               target_os = \"bitrig\",\n-              target_os = \"openbsd\",\n               target_os = \"netbsd\"))]\n     fn num_cpus() -> usize {\n         let mut cpus: libc::c_uint = 0;\n@@ -946,6 +945,24 @@ fn get_concurrency() -> usize {\n         }\n         cpus as usize\n     }\n+\n+    #[cfg(target_os = \"openbsd\")]\n+    fn num_cpus() -> usize {\n+        let mut cpus: libc::c_uint = 0;\n+        let mut cpus_size = std::mem::size_of_val(&cpus);\n+        let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n+\n+        unsafe {\n+            libc::sysctl(mib.as_mut_ptr(), 2,\n+                         &mut cpus as *mut _ as *mut _,\n+                         &mut cpus_size as *mut _ as *mut _,\n+                         0 as *mut _, 0);\n+        }\n+        if cpus < 1 {\n+            cpus = 1;\n+        }\n+        cpus as usize\n+    }\n }\n \n pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {"}, {"sha": "c55cc91cc928fa66e96dfa4e79b60f48e1d505d9", "filename": "src/test/run-pass/issue-29092.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Ftest%2Frun-pass%2Fissue-29092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Ftest%2Frun-pass%2Fissue-29092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29092.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for Issue #29092.\n+//\n+// (Possibly redundant with regression test run-pass/issue-30530.rs)\n+\n+use self::Term::*;\n+\n+#[derive(Clone)]\n+pub enum Term {\n+    Dummy,\n+    A(Box<Term>),\n+    B(Box<Term>),\n+}\n+\n+// a small-step evaluator\n+pub fn small_eval(v: Term) -> Term {\n+    match v {\n+        A(t) => *t.clone(),\n+        B(t) => *t.clone(),\n+        _ => Dummy,\n+    }\n+}\n+\n+fn main() {\n+    small_eval(Dummy);\n+}"}, {"sha": "25eff9def9dfc83e3c0d396262779c0599058907", "filename": "src/test/run-pass/issue-30018-nopanic.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Ftest%2Frun-pass%2Fissue-30018-nopanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Ftest%2Frun-pass%2Fissue-30018-nopanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-30018-nopanic.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// More thorough regression test for Issues #30018 and #30822. This\n+// attempts to explore different ways that array element construction\n+// (for both scratch arrays and non-scratch ones) interacts with\n+// breaks in the control-flow, in terms of the order of evaluation of\n+// the destructors (which may change; see RFC Issue 744) and the\n+// number of times that the destructor evaluates for each value (which\n+// should never exceed 1; this latter case is what #30822 is about).\n+\n+use std::cell::RefCell;\n+\n+struct D<'a>(&'a RefCell<Vec<i32>>, i32);\n+\n+impl<'a> Drop for D<'a> {\n+    fn drop(&mut self) {\n+        println!(\"Dropping D({})\", self.1);\n+        (self.0).borrow_mut().push(self.1);\n+    }\n+}\n+\n+fn main() {\n+    println!(\"Start\");\n+    break_during_elem();\n+    break_after_whole();\n+    println!(\"Finis\");\n+}\n+\n+fn break_during_elem() {\n+    let log = &RefCell::new(Vec::new());\n+\n+    // CASE 1: Fixed-size array itself is stored in _r slot.\n+    loop {\n+        let _r = [D(log, 10),\n+                  D(log, 11),\n+                  { D(log, 12); break; },\n+                  D(log, 13)];\n+    }\n+    assert_eq!(&log.borrow()[..], &[12, 11, 10]);\n+    log.borrow_mut().clear();\n+\n+    // CASE 2: Slice (borrow of array) is stored in _r slot.\n+    // This is the case that is actually being reported in #30018.\n+    loop {\n+        let _r = &[D(log, 20),\n+                   D(log, 21),\n+                   { D(log, 22); break; },\n+                   D(log, 23)];\n+    }\n+    assert_eq!(&log.borrow()[..], &[22, 21, 20]);\n+    log.borrow_mut().clear();\n+\n+    // CASE 3: (Borrow of) slice-index of array is stored in _r slot.\n+    loop {\n+        let _r = &[D(log, 30),\n+                  D(log, 31),\n+                  { D(log, 32); break; },\n+                  D(log, 33)][..];\n+    }\n+    assert_eq!(&log.borrow()[..], &[32, 31, 30]);\n+    log.borrow_mut().clear();\n+}\n+\n+// The purpose of these functions is to test what happens when we\n+// panic after an array has been constructed in its entirety.\n+//\n+// It is meant to act as proof that we still need to continue\n+// scheduling the destruction of an array even after we've scheduling\n+// drop for its elements during construction; the latter is tested by\n+// `fn break_during_elem()`.\n+fn break_after_whole() {\n+    let log = &RefCell::new(Vec::new());\n+\n+    // CASE 1: Fixed-size array itself is stored in _r slot.\n+    loop {\n+        let _r = [D(log, 10),\n+                  D(log, 11),\n+                  D(log, 12)];\n+        break;\n+    }\n+    assert_eq!(&log.borrow()[..], &[10, 11, 12]);\n+    log.borrow_mut().clear();\n+\n+    // CASE 2: Slice (borrow of array) is stored in _r slot.\n+    loop {\n+        let _r = &[D(log, 20),\n+                   D(log, 21),\n+                   D(log, 22)];\n+        break;\n+    }\n+    assert_eq!(&log.borrow()[..], &[20, 21, 22]);\n+    log.borrow_mut().clear();\n+\n+    // CASE 3: (Borrow of) slice-index of array is stored in _r slot.\n+    loop {\n+        let _r = &[D(log, 30),\n+                   D(log, 31),\n+                   D(log, 32)][..];\n+        break;\n+    }\n+    assert_eq!(&log.borrow()[..], &[30, 31, 32]);\n+    log.borrow_mut().clear();\n+}"}, {"sha": "da4d5f19d4a2e9b585f825c93d539602e531fd6f", "filename": "src/test/run-pass/issue-30018-panic.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Ftest%2Frun-pass%2Fissue-30018-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Ftest%2Frun-pass%2Fissue-30018-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-30018-panic.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for Issue #30018. This is very similar to the\n+// original reported test, except that the panic is wrapped in a\n+// spawned thread to isolate the expected error result from the\n+// SIGTRAP injected by the drop-flag consistency checking.\n+\n+struct Foo;\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {}\n+}\n+\n+fn foo() -> Foo {\n+    panic!();\n+}\n+\n+fn main() {\n+    use std::thread;\n+    let handle = thread::spawn(|| {\n+        let _ = &[foo()];\n+    });\n+    let _ = handle.join();\n+}"}, {"sha": "d5139c908bdac2ea2b743c7e354c398a5c7ec399", "filename": "src/test/run-pass/issue-30530.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5b3a75fe560362b812f2c4947d449558a9472496/src%2Ftest%2Frun-pass%2Fissue-30530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3a75fe560362b812f2c4947d449558a9472496/src%2Ftest%2Frun-pass%2Fissue-30530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-30530.rs?ref=5b3a75fe560362b812f2c4947d449558a9472496", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for Issue #30530: alloca's created for storing\n+// intermediate scratch values during brace-less match arms need to be\n+// initialized with their drop-flag set to \"dropped\" (or else we end\n+// up running the destructors on garbage data at the end of the\n+// function).\n+\n+pub enum Handler {\n+    Default,\n+    #[allow(dead_code)]\n+    Custom(*mut Box<Fn()>),\n+}\n+\n+fn main() {\n+    take(Handler::Default, Box::new(main));\n+}\n+\n+#[inline(never)]\n+pub fn take(h: Handler, f: Box<Fn()>) -> Box<Fn()> {\n+    unsafe {\n+        match h {\n+            Handler::Custom(ptr) => *Box::from_raw(ptr),\n+            Handler::Default => f,\n+        }\n+    }\n+}"}]}