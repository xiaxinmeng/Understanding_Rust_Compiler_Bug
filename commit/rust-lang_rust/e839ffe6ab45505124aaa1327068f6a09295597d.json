{"sha": "e839ffe6ab45505124aaa1327068f6a09295597d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MzlmZmU2YWI0NTUwNTEyNGFhYTEzMjcwNjhmNmEwOTI5NTU5N2Q=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-31T23:34:41Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-01T22:59:01Z"}, "message": "libterm: Unconfigure tests during normal build", "tree": {"sha": "dc8c2926b2a6593e6e7820c06de8cacac5109872", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc8c2926b2a6593e6e7820c06de8cacac5109872"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e839ffe6ab45505124aaa1327068f6a09295597d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e839ffe6ab45505124aaa1327068f6a09295597d", "html_url": "https://github.com/rust-lang/rust/commit/e839ffe6ab45505124aaa1327068f6a09295597d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e839ffe6ab45505124aaa1327068f6a09295597d/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "751af273209a0466d41ea8af5ff0c318a7f221ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/751af273209a0466d41ea8af5ff0c318a7f221ec", "html_url": "https://github.com/rust-lang/rust/commit/751af273209a0466d41ea8af5ff0c318a7f221ec"}], "stats": {"total": 346, "additions": 173, "deletions": 173}, "files": [{"sha": "c7466daa2baa6f671b1d3caa7b9e93fd70ff2b46", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 3, "deletions": 141, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/e839ffe6ab45505124aaa1327068f6a09295597d/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e839ffe6ab45505124aaa1327068f6a09295597d/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=e839ffe6ab45505124aaa1327068f6a09295597d", "patch": "@@ -5,6 +5,9 @@ use self::States::*;\n \n use std::iter::repeat;\n \n+#[cfg(test)]\n+mod tests;\n+\n #[derive(Clone, Copy, PartialEq)]\n enum States {\n     Nothing,\n@@ -526,144 +529,3 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8>, String> {\n     }\n     Ok(s)\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::{expand, Variables};\n-    use super::Param::{self, Words, Number};\n-    use std::result::Result::Ok;\n-\n-    #[test]\n-    fn test_basic_setabf() {\n-        let s = b\"\\\\E[48;5;%p1%dm\";\n-        assert_eq!(expand(s, &[Number(1)], &mut Variables::new()).unwrap(),\n-                   \"\\\\E[48;5;1m\".bytes().collect::<Vec<_>>());\n-    }\n-\n-    #[test]\n-    fn test_multiple_int_constants() {\n-        assert_eq!(expand(b\"%{1}%{2}%d%d\", &[], &mut Variables::new()).unwrap(),\n-                   \"21\".bytes().collect::<Vec<_>>());\n-    }\n-\n-    #[test]\n-    fn test_op_i() {\n-        let mut vars = Variables::new();\n-        assert_eq!(expand(b\"%p1%d%p2%d%p3%d%i%p1%d%p2%d%p3%d\",\n-                          &[Number(1), Number(2), Number(3)],\n-                          &mut vars),\n-                   Ok(\"123233\".bytes().collect::<Vec<_>>()));\n-        assert_eq!(expand(b\"%p1%d%p2%d%i%p1%d%p2%d\", &[], &mut vars),\n-                   Ok(\"0011\".bytes().collect::<Vec<_>>()));\n-    }\n-\n-    #[test]\n-    fn test_param_stack_failure_conditions() {\n-        let mut varstruct = Variables::new();\n-        let vars = &mut varstruct;\n-        fn get_res(fmt: &str,\n-                   cap: &str,\n-                   params: &[Param],\n-                   vars: &mut Variables)\n-                   -> Result<Vec<u8>, String> {\n-            let mut u8v: Vec<_> = fmt.bytes().collect();\n-            u8v.extend(cap.as_bytes().iter().map(|&b| b));\n-            expand(&u8v, params, vars)\n-        }\n-\n-        let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];\n-        for &cap in caps.iter() {\n-            let res = get_res(\"\", cap, &[], vars);\n-            assert!(res.is_err(),\n-                    \"Op {} succeeded incorrectly with 0 stack entries\",\n-                    cap);\n-            let p = if cap == \"%s\" || cap == \"%l\" {\n-                Words(\"foo\".to_string())\n-            } else {\n-                Number(97)\n-            };\n-            let res = get_res(\"%p1\", cap, &[p], vars);\n-            assert!(res.is_ok(),\n-                    \"Op {} failed with 1 stack entry: {}\",\n-                    cap,\n-                    res.unwrap_err());\n-        }\n-        let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n-        for &cap in caps.iter() {\n-            let res = expand(cap.as_bytes(), &[], vars);\n-            assert!(res.is_err(),\n-                    \"Binop {} succeeded incorrectly with 0 stack entries\",\n-                    cap);\n-            let res = get_res(\"%{1}\", cap, &[], vars);\n-            assert!(res.is_err(),\n-                    \"Binop {} succeeded incorrectly with 1 stack entry\",\n-                    cap);\n-            let res = get_res(\"%{1}%{2}\", cap, &[], vars);\n-            assert!(res.is_ok(),\n-                    \"Binop {} failed with 2 stack entries: {}\",\n-                    cap,\n-                    res.unwrap_err());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_push_bad_param() {\n-        assert!(expand(b\"%pa\", &[], &mut Variables::new()).is_err());\n-    }\n-\n-    #[test]\n-    fn test_comparison_ops() {\n-        let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n-        for &(op, bs) in v.iter() {\n-            let s = format!(\"%{{1}}%{{2}}%{}%d\", op);\n-            let res = expand(s.as_bytes(), &[], &mut Variables::new());\n-            assert!(res.is_ok(), res.unwrap_err());\n-            assert_eq!(res.unwrap(), vec![b'0' + bs[0]]);\n-            let s = format!(\"%{{1}}%{{1}}%{}%d\", op);\n-            let res = expand(s.as_bytes(), &[], &mut Variables::new());\n-            assert!(res.is_ok(), res.unwrap_err());\n-            assert_eq!(res.unwrap(), vec![b'0' + bs[1]]);\n-            let s = format!(\"%{{2}}%{{1}}%{}%d\", op);\n-            let res = expand(s.as_bytes(), &[], &mut Variables::new());\n-            assert!(res.is_ok(), res.unwrap_err());\n-            assert_eq!(res.unwrap(), vec![b'0' + bs[2]]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_conditionals() {\n-        let mut vars = Variables::new();\n-        let s = b\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\";\n-        let res = expand(s, &[Number(1)], &mut vars);\n-        assert!(res.is_ok(), res.unwrap_err());\n-        assert_eq!(res.unwrap(), \"\\\\E[31m\".bytes().collect::<Vec<_>>());\n-        let res = expand(s, &[Number(8)], &mut vars);\n-        assert!(res.is_ok(), res.unwrap_err());\n-        assert_eq!(res.unwrap(), \"\\\\E[90m\".bytes().collect::<Vec<_>>());\n-        let res = expand(s, &[Number(42)], &mut vars);\n-        assert!(res.is_ok(), res.unwrap_err());\n-        assert_eq!(res.unwrap(), \"\\\\E[38;5;42m\".bytes().collect::<Vec<_>>());\n-    }\n-\n-    #[test]\n-    fn test_format() {\n-        let mut varstruct = Variables::new();\n-        let vars = &mut varstruct;\n-        assert_eq!(expand(b\"%p1%s%p2%2s%p3%2s%p4%.2s\",\n-                          &[Words(\"foo\".to_string()),\n-                            Words(\"foo\".to_string()),\n-                            Words(\"f\".to_string()),\n-                            Words(\"foo\".to_string())],\n-                          vars),\n-                   Ok(\"foofoo ffo\".bytes().collect::<Vec<_>>()));\n-        assert_eq!(expand(b\"%p1%:-4.2s\", &[Words(\"foo\".to_string())], vars),\n-                   Ok(\"fo  \".bytes().collect::<Vec<_>>()));\n-\n-        assert_eq!(expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", &[Number(1)], vars),\n-                   Ok(\"1001    1+1\".bytes().collect::<Vec<_>>()));\n-        assert_eq!(expand(b\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\",\n-                          &[Number(15), Number(27)],\n-                          vars),\n-                   Ok(\"17017  001b0X001B\".bytes().collect::<Vec<_>>()));\n-    }\n-}"}, {"sha": "4d38715424e8a202bb9c76e52ad60ef74c7761c5", "filename": "src/libterm/terminfo/parm/tests.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/e839ffe6ab45505124aaa1327068f6a09295597d/src%2Flibterm%2Fterminfo%2Fparm%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e839ffe6ab45505124aaa1327068f6a09295597d/src%2Flibterm%2Fterminfo%2Fparm%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm%2Ftests.rs?ref=e839ffe6ab45505124aaa1327068f6a09295597d", "patch": "@@ -0,0 +1,137 @@\n+use super::*;\n+\n+use std::result::Result::Ok;\n+\n+#[test]\n+fn test_basic_setabf() {\n+    let s = b\"\\\\E[48;5;%p1%dm\";\n+    assert_eq!(expand(s, &[Number(1)], &mut Variables::new()).unwrap(),\n+                \"\\\\E[48;5;1m\".bytes().collect::<Vec<_>>());\n+}\n+\n+#[test]\n+fn test_multiple_int_constants() {\n+    assert_eq!(expand(b\"%{1}%{2}%d%d\", &[], &mut Variables::new()).unwrap(),\n+                \"21\".bytes().collect::<Vec<_>>());\n+}\n+\n+#[test]\n+fn test_op_i() {\n+    let mut vars = Variables::new();\n+    assert_eq!(expand(b\"%p1%d%p2%d%p3%d%i%p1%d%p2%d%p3%d\",\n+                        &[Number(1), Number(2), Number(3)],\n+                        &mut vars),\n+                Ok(\"123233\".bytes().collect::<Vec<_>>()));\n+    assert_eq!(expand(b\"%p1%d%p2%d%i%p1%d%p2%d\", &[], &mut vars),\n+                Ok(\"0011\".bytes().collect::<Vec<_>>()));\n+}\n+\n+#[test]\n+fn test_param_stack_failure_conditions() {\n+    let mut varstruct = Variables::new();\n+    let vars = &mut varstruct;\n+    fn get_res(fmt: &str,\n+                cap: &str,\n+                params: &[Param],\n+                vars: &mut Variables)\n+                -> Result<Vec<u8>, String> {\n+        let mut u8v: Vec<_> = fmt.bytes().collect();\n+        u8v.extend(cap.as_bytes().iter().map(|&b| b));\n+        expand(&u8v, params, vars)\n+    }\n+\n+    let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];\n+    for &cap in caps.iter() {\n+        let res = get_res(\"\", cap, &[], vars);\n+        assert!(res.is_err(),\n+                \"Op {} succeeded incorrectly with 0 stack entries\",\n+                cap);\n+        let p = if cap == \"%s\" || cap == \"%l\" {\n+            Words(\"foo\".to_string())\n+        } else {\n+            Number(97)\n+        };\n+        let res = get_res(\"%p1\", cap, &[p], vars);\n+        assert!(res.is_ok(),\n+                \"Op {} failed with 1 stack entry: {}\",\n+                cap,\n+                res.unwrap_err());\n+    }\n+    let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n+    for &cap in caps.iter() {\n+        let res = expand(cap.as_bytes(), &[], vars);\n+        assert!(res.is_err(),\n+                \"Binop {} succeeded incorrectly with 0 stack entries\",\n+                cap);\n+        let res = get_res(\"%{1}\", cap, &[], vars);\n+        assert!(res.is_err(),\n+                \"Binop {} succeeded incorrectly with 1 stack entry\",\n+                cap);\n+        let res = get_res(\"%{1}%{2}\", cap, &[], vars);\n+        assert!(res.is_ok(),\n+                \"Binop {} failed with 2 stack entries: {}\",\n+                cap,\n+                res.unwrap_err());\n+    }\n+}\n+\n+#[test]\n+fn test_push_bad_param() {\n+    assert!(expand(b\"%pa\", &[], &mut Variables::new()).is_err());\n+}\n+\n+#[test]\n+fn test_comparison_ops() {\n+    let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n+    for &(op, bs) in v.iter() {\n+        let s = format!(\"%{{1}}%{{2}}%{}%d\", op);\n+        let res = expand(s.as_bytes(), &[], &mut Variables::new());\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), vec![b'0' + bs[0]]);\n+        let s = format!(\"%{{1}}%{{1}}%{}%d\", op);\n+        let res = expand(s.as_bytes(), &[], &mut Variables::new());\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), vec![b'0' + bs[1]]);\n+        let s = format!(\"%{{2}}%{{1}}%{}%d\", op);\n+        let res = expand(s.as_bytes(), &[], &mut Variables::new());\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), vec![b'0' + bs[2]]);\n+    }\n+}\n+\n+#[test]\n+fn test_conditionals() {\n+    let mut vars = Variables::new();\n+    let s = b\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\";\n+    let res = expand(s, &[Number(1)], &mut vars);\n+    assert!(res.is_ok(), res.unwrap_err());\n+    assert_eq!(res.unwrap(), \"\\\\E[31m\".bytes().collect::<Vec<_>>());\n+    let res = expand(s, &[Number(8)], &mut vars);\n+    assert!(res.is_ok(), res.unwrap_err());\n+    assert_eq!(res.unwrap(), \"\\\\E[90m\".bytes().collect::<Vec<_>>());\n+    let res = expand(s, &[Number(42)], &mut vars);\n+    assert!(res.is_ok(), res.unwrap_err());\n+    assert_eq!(res.unwrap(), \"\\\\E[38;5;42m\".bytes().collect::<Vec<_>>());\n+}\n+\n+#[test]\n+fn test_format() {\n+    let mut varstruct = Variables::new();\n+    let vars = &mut varstruct;\n+    assert_eq!(expand(b\"%p1%s%p2%2s%p3%2s%p4%.2s\",\n+                        &[Words(\"foo\".to_string()),\n+                        Words(\"foo\".to_string()),\n+                        Words(\"f\".to_string()),\n+                        Words(\"foo\".to_string())],\n+                        vars),\n+                Ok(\"foofoo ffo\".bytes().collect::<Vec<_>>()));\n+    assert_eq!(expand(b\"%p1%:-4.2s\", &[Words(\"foo\".to_string())], vars),\n+                Ok(\"fo  \".bytes().collect::<Vec<_>>()));\n+\n+    assert_eq!(expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", &[Number(1)], vars),\n+                Ok(\"1001    1+1\".bytes().collect::<Vec<_>>()));\n+    assert_eq!(expand(b\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\",\n+                        &[Number(15), Number(27)],\n+                        vars),\n+                Ok(\"17017  001b0X001B\".bytes().collect::<Vec<_>>()));\n+}"}, {"sha": "a8653a22f2538c2ecc8f0e6798a2535c5325a713", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e839ffe6ab45505124aaa1327068f6a09295597d/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e839ffe6ab45505124aaa1327068f6a09295597d/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=e839ffe6ab45505124aaa1327068f6a09295597d", "patch": "@@ -7,6 +7,9 @@ use std::io;\n use std::io::prelude::*;\n use super::super::TermInfo;\n \n+#[cfg(test)]\n+mod tests;\n+\n // These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n \n #[rustfmt::skip]\n@@ -331,16 +334,3 @@ pub fn msys_terminfo() -> TermInfo {\n         strings,\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use super::{boolnames, boolfnames, numnames, numfnames, stringnames, stringfnames};\n-\n-    #[test]\n-    fn test_veclens() {\n-        assert_eq!(boolfnames.len(), boolnames.len());\n-        assert_eq!(numfnames.len(), numnames.len());\n-        assert_eq!(stringfnames.len(), stringnames.len());\n-    }\n-}"}, {"sha": "8a9187b0495cc9a6e314cc01fd3b3cee21b9aed6", "filename": "src/libterm/terminfo/parser/compiled/tests.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e839ffe6ab45505124aaa1327068f6a09295597d/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e839ffe6ab45505124aaa1327068f6a09295597d/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled%2Ftests.rs?ref=e839ffe6ab45505124aaa1327068f6a09295597d", "patch": "@@ -0,0 +1,8 @@\n+use super::*;\n+\n+#[test]\n+fn test_veclens() {\n+    assert_eq!(boolfnames.len(), boolnames.len());\n+    assert_eq!(numfnames.len(), numnames.len());\n+    assert_eq!(stringfnames.len(), stringnames.len());\n+}"}, {"sha": "5499e240e66e54268b5acbe00a3ceae2ad1a500c", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e839ffe6ab45505124aaa1327068f6a09295597d/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e839ffe6ab45505124aaa1327068f6a09295597d/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=e839ffe6ab45505124aaa1327068f6a09295597d", "patch": "@@ -6,6 +6,9 @@ use std::env;\n use std::fs;\n use std::path::PathBuf;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// Return path to database entry for `term`\n #[allow(deprecated)]\n pub fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n@@ -64,21 +67,3 @@ pub fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n     }\n     None\n }\n-\n-#[test]\n-#[ignore = \"buildbots don't have ncurses installed and I can't mock everything I need\"]\n-fn test_get_dbpath_for_term() {\n-    // woefully inadequate test coverage\n-    // note: current tests won't work with non-standard terminfo hierarchies (e.g., macOS's)\n-    use std::env;\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    fn x(t: &str) -> String {\n-        let p = get_dbpath_for_term(t).expect(\"no terminfo entry found\");\n-        p.to_str().unwrap().to_string()\n-    }\n-    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n-    assert!(get_dbpath_for_term(\"\") == None);\n-    env::set_var(\"TERMINFO_DIRS\", \":\");\n-    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n-    env::remove_var(\"TERMINFO_DIRS\");\n-}"}, {"sha": "4227a585e2f59e22e7f1dd129110f3115539f90d", "filename": "src/libterm/terminfo/searcher/tests.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e839ffe6ab45505124aaa1327068f6a09295597d/src%2Flibterm%2Fterminfo%2Fsearcher%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e839ffe6ab45505124aaa1327068f6a09295597d/src%2Flibterm%2Fterminfo%2Fsearcher%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher%2Ftests.rs?ref=e839ffe6ab45505124aaa1327068f6a09295597d", "patch": "@@ -0,0 +1,19 @@\n+use super::*;\n+\n+#[test]\n+#[ignore = \"buildbots don't have ncurses installed and I can't mock everything I need\"]\n+fn test_get_dbpath_for_term() {\n+    // woefully inadequate test coverage\n+    // note: current tests won't work with non-standard terminfo hierarchies (e.g., macOS's)\n+    use std::env;\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    fn x(t: &str) -> String {\n+        let p = get_dbpath_for_term(t).expect(\"no terminfo entry found\");\n+        p.to_str().unwrap().to_string()\n+    }\n+    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n+    assert!(get_dbpath_for_term(\"\") == None);\n+    env::set_var(\"TERMINFO_DIRS\", \":\");\n+    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n+    env::remove_var(\"TERMINFO_DIRS\");\n+}"}, {"sha": "23fe06080892c019b9738817c116d67b6091ba7e", "filename": "src/tools/tidy/src/unit_tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e839ffe6ab45505124aaa1327068f6a09295597d/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e839ffe6ab45505124aaa1327068f6a09295597d/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs?ref=e839ffe6ab45505124aaa1327068f6a09295597d", "patch": "@@ -38,7 +38,6 @@ pub fn check(root_path: &Path, bad: &mut bool) {\n         \"libstd\",\n         \"libsyntax\",\n         \"libsyntax_pos\",\n-        \"libterm/terminfo\",\n     ];\n \n     let mut skip = |path: &Path| {"}]}