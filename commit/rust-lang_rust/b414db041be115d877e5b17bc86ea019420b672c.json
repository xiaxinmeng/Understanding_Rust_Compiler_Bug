{"sha": "b414db041be115d877e5b17bc86ea019420b672c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0MTRkYjA0MWJlMTE1ZDg3N2U1YjE3YmM4NmVhMDE5NDIwYjY3MmM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-01T02:25:24Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-01T02:26:25Z"}, "message": "rustc: Parse by-reference pattern bindings with the \"ref\" keyword", "tree": {"sha": "d7e15ba792c8376aaabe9727726de34b03e89baf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7e15ba792c8376aaabe9727726de34b03e89baf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b414db041be115d877e5b17bc86ea019420b672c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b414db041be115d877e5b17bc86ea019420b672c", "html_url": "https://github.com/rust-lang/rust/commit/b414db041be115d877e5b17bc86ea019420b672c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b414db041be115d877e5b17bc86ea019420b672c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a841789a41941ad73a57cd9972dfbd5fdff02685", "url": "https://api.github.com/repos/rust-lang/rust/commits/a841789a41941ad73a57cd9972dfbd5fdff02685", "html_url": "https://github.com/rust-lang/rust/commit/a841789a41941ad73a57cd9972dfbd5fdff02685"}], "stats": {"total": 347, "additions": 202, "deletions": 145}, "files": [{"sha": "e7c661734f4f4fb547cf7df54f941690dc24ec45", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -20,7 +20,7 @@ type package = {\n     url: ~str,\n     method: ~str,\n     description: ~str,\n-    ref: option<~str>,\n+    reference: option<~str>,\n     tags: ~[~str],\n     versions: ~[(~str, ~str)]\n };\n@@ -497,7 +497,7 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n         }\n     };\n \n-    let ref = alt p.find(~\"ref\") {\n+    let reference = alt p.find(~\"ref\") {\n         some(json::string(n)) { some(*n) }\n         _ { none }\n     };\n@@ -530,7 +530,7 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n         url: url,\n         method: method,\n         description: description,\n-        ref: ref,\n+        reference: reference,\n         tags: tags,\n         versions: ~[]\n     };\n@@ -815,10 +815,10 @@ fn install_source(c: cargo, path: ~str) {\n     }\n }\n \n-fn install_git(c: cargo, wd: ~str, url: ~str, ref: option<~str>) {\n+fn install_git(c: cargo, wd: ~str, url: ~str, reference: option<~str>) {\n     run::program_output(~\"git\", ~[~\"clone\", url, wd]);\n-    if option::is_some(ref) {\n-        let r = option::get(ref);\n+    if option::is_some(reference) {\n+        let r = option::get(reference);\n         os::change_dir(wd);\n         run::run_program(~\"git\", ~[~\"checkout\", r]);\n     }\n@@ -855,7 +855,7 @@ fn install_package(c: cargo, src: ~str, wd: ~str, pkg: package) {\n     info(fmt!{\"installing %s/%s via %s...\", src, pkg.name, method});\n \n     alt method {\n-        ~\"git\" { install_git(c, wd, url, copy pkg.ref); }\n+        ~\"git\" { install_git(c, wd, url, copy pkg.reference); }\n         ~\"file\" { install_file(c, wd, url); }\n         ~\"curl\" { install_curl(c, wd, copy url); }\n         _ {}\n@@ -1034,12 +1034,12 @@ fn install_query(c: cargo, wd: ~str, target: ~str) {\n         install_file(c, wd, target);\n         ret;\n     } else if is_git_url(target) {\n-        let ref = if c.opts.free.len() >= 4u {\n+        let reference = if c.opts.free.len() >= 4u {\n             some(c.opts.free[3u])\n         } else {\n             none\n         };\n-        install_git(c, wd, target, ref);\n+        install_git(c, wd, target, reference);\n     } else if !valid_pkg_name(target) && has_archive_extension(target) {\n         install_curl(c, wd, target);\n         ret;"}, {"sha": "04f10a7f23c24a89c7ea4b9bbb0b4fdb64bb5143", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -536,7 +536,7 @@ fn push_slow<T>(&v: ~[const T], +initval: T) {\n \n // Unchecked vector indexing\n #[inline(always)]\n-unsafe fn ref<T: copy>(v: &[const T], i: uint) -> T {\n+unsafe fn get_ref<T: copy>(v: &[const T], i: uint) -> T {\n     as_buf(v, |p, _len| *ptr::offset(p, i))\n }\n \n@@ -555,7 +555,7 @@ fn push_all<T: copy>(&v: ~[const T], rhs: &[const T]) {\n     reserve(v, v.len() + rhs.len());\n \n     for uint::range(0u, rhs.len()) |i| {\n-        push(v, unsafe { ref(rhs, i) })\n+        push(v, unsafe { get_ref(rhs, i) })\n     }\n }\n "}, {"sha": "0dede78ffd0b0e39af175a3f4da41ed82a118922", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -145,6 +145,12 @@ type pat = {id: node_id, node: pat_, span: span};\n #[auto_serialize]\n type field_pat = {ident: ident, pat: @pat};\n \n+#[auto_serialize]\n+enum binding_mode {\n+    bind_by_value,\n+    bind_by_ref\n+}\n+\n #[auto_serialize]\n enum pat_ {\n     pat_wild,\n@@ -155,7 +161,7 @@ enum pat_ {\n     // which it is. The resolver determines this, and\n     // records this pattern's node_id in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n-    pat_ident(@path, option<@pat>),\n+    pat_ident(binding_mode, @path, option<@pat>),\n     pat_enum(@path, option<~[@pat]>), // \"none\" means a * pattern where\n                                   // we don't bind the fields to names\n     pat_rec(~[field_pat], bool),"}, {"sha": "4ef4288376c6621a171f923ed267a7debe26c72a", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -158,7 +158,7 @@ fn map_block(b: blk, cx: ctx, v: vt) {\n fn number_pat(cx: ctx, pat: @pat) {\n     do ast_util::walk_pat(pat) |p| {\n         alt p.node {\n-          pat_ident(_, _) {\n+          pat_ident(*) {\n             cx.map.insert(p.id, node_local(cx.local_id));\n             cx.local_id += 1u;\n           }"}, {"sha": "5f46a693f18204ef3456998edb3c823ac082b251", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -568,15 +568,15 @@ pure fn is_item_impl(item: @ast::item) -> bool {\n fn walk_pat(pat: @pat, it: fn(@pat)) {\n     it(pat);\n     alt pat.node {\n-      pat_ident(pth, some(p)) { walk_pat(p, it); }\n+      pat_ident(_, pth, some(p)) { walk_pat(p, it); }\n       pat_rec(fields, _) {\n         for fields.each |f| { walk_pat(f.pat, it); }\n       }\n       pat_enum(_, some(s)) | pat_tup(s) {\n         for s.each |p| { walk_pat(p, it); }\n       }\n       pat_box(s) | pat_uniq(s) { walk_pat(s, it); }\n-      pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _)\n+      pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _, _)\n         | pat_enum(_, _) {}\n     }\n }"}, {"sha": "90319feb4d291422b586c4ac96f24bf4831fa852", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -228,7 +228,7 @@ impl helpers of ext_ctxt_helpers for ext_ctxt {\n         let path = @{span: span, global: false, idents: ~[nm],\n                      rp: none, types: ~[]};\n         @{id: self.next_id(),\n-          node: ast::pat_ident(path, none),\n+          node: ast::pat_ident(ast::bind_by_ref, path, none),\n           span: span}\n     }\n \n@@ -834,7 +834,9 @@ fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n             // Generate pattern var(v1, v2, v3)\n             |pats| {\n                 if vec::is_empty(pats) {\n-                    ast::pat_ident(cx.path(v_span, ~[v_name]), none)\n+                    ast::pat_ident(ast::bind_by_ref,\n+                                   cx.path(v_span, ~[v_name]),\n+                                   none)\n                 } else {\n                     ast::pat_enum(cx.path(v_span, ~[v_name]), some(pats))\n                 }"}, {"sha": "89c53d16ac541e99a9b20c1544941fc74d9ded77", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -116,8 +116,10 @@ impl ast_builder of ext_ctxt_ast_builder for ext_ctxt {\n             @{node: {is_mutbl: false,\n                      ty: self.ty_infer(),\n                      pat: @{id: self.next_id(),\n-                            node: ast::pat_ident(\n-                                path(ident, self.empty_span()), none),\n+                            node: ast::pat_ident(ast::bind_by_ref,\n+                                                 path(ident,\n+                                                      self.empty_span()),\n+                                                 none),\n                             span: self.empty_span()},\n                      init: some({op: ast::init_move,\n                                  expr: e}),"}, {"sha": "94753ea88e038aa34d355961921dcc6fbd4c0223", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -170,7 +170,7 @@ fn parse_crate(p: parser) -> @ast::crate { p.parse_crate_mod(~[]) }\n fn parse_ty(p: parser) -> @ast::ty { p.parse_ty(false) }\n fn parse_stmt(p: parser) -> @ast::stmt { p.parse_stmt(~[]) }\n fn parse_expr(p: parser) -> @ast::expr { p.parse_expr() }\n-fn parse_pat(p: parser) -> @ast::pat { p.parse_pat() }\n+fn parse_pat(p: parser) -> @ast::pat { p.parse_pat(true) }\n \n fn parse_item(p: parser) -> @ast::item {\n     alt p.parse_item(~[], ast::public) {"}, {"sha": "bd8fcf552dac95af28e141d78b3dee19029a3d6c", "filename": "src/libsyntax/ext/tt/earley_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -326,7 +326,7 @@ fn parse_nt(p: parser, name: ~str) -> nonterminal {\n       }}\n       ~\"block\" { token::nt_block(p.parse_block()) }\n       ~\"stmt\" { token::nt_stmt(p.parse_stmt(~[])) }\n-      ~\"pat\" { token::nt_pat(p.parse_pat()) }\n+      ~\"pat\" { token::nt_pat(p.parse_pat(true)) }\n       ~\"expr\" { token::nt_expr(p.parse_expr()) }\n       ~\"ty\" { token::nt_ty(p.parse_ty(false /* no need to disambiguate*/)) }\n       // this could be handled like a token, since it is one"}, {"sha": "7900b5eea1528955a810c3b7ce44b653df25f737", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -332,8 +332,9 @@ fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n     ret alt p {\n           pat_wild { pat_wild }\n-          pat_ident(pth, sub) {\n-            pat_ident(fld.fold_path(pth),\n+          pat_ident(binding_mode, pth, sub) {\n+            pat_ident(binding_mode,\n+                      fld.fold_path(pth),\n                       option::map(sub, |x| fld.fold_pat(x)))\n           }\n           pat_lit(e) { pat_lit(fld.fold_expr(e)) }"}, {"sha": "89053c4eb1d653f15bff91eeccb1fcd265c9197b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 89, "deletions": 59, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -15,14 +15,12 @@ import common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed,\n import dvec::{dvec, extensions};\n import vec::{push};\n import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n-             bitand, bitor, bitxor, blk, blk_check_mode, bound_const,\n-             bound_copy, bound_send, bound_trait, bound_owned,\n-             box, by_copy, by_move,\n-             by_mutbl_ref, by_ref, by_val, capture_clause, capture_item,\n-             cdir_dir_mod, cdir_src_mod,\n-             cdir_view_item, class_immutable,\n-             class_member, class_method, class_mutable,\n-             crate, crate_cfg, crate_directive, decl,\n+             bind_by_ref, bind_by_value, bitand, bitor, bitxor, blk,\n+             blk_check_mode, bound_const, bound_copy, bound_send, bound_trait,\n+             bound_owned, box, by_copy, by_move, by_mutbl_ref, by_ref, by_val,\n+             capture_clause, capture_item, cdir_dir_mod, cdir_src_mod,\n+             cdir_view_item, class_immutable, class_member, class_method,\n+             class_mutable, crate, crate_cfg, crate_directive, decl,\n              decl_item, decl_local, default_blk, deref, div, expl, expr,\n              expr_, expr_addr_of, expr_alt, expr_again, expr_assert,\n              expr_assign, expr_assign_op, expr_binary, expr_block, expr_break,\n@@ -1585,21 +1583,21 @@ class parser {\n     fn parse_pats() -> ~[@pat] {\n         let mut pats = ~[];\n         loop {\n-            vec::push(pats, self.parse_pat());\n+            vec::push(pats, self.parse_pat(true));\n             if self.token == token::BINOP(token::OR) { self.bump(); }\n             else { ret pats; }\n         };\n     }\n \n-    fn parse_pat() -> @pat {\n+    fn parse_pat(refutable: bool) -> @pat {\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n         let mut pat;\n         alt self.token {\n           token::UNDERSCORE { self.bump(); pat = pat_wild; }\n           token::AT {\n             self.bump();\n-            let sub = self.parse_pat();\n+            let sub = self.parse_pat(refutable);\n             hi = sub.span.hi;\n             // HACK: parse @\"...\" as a literal of a vstore @str\n             pat = alt sub.node {\n@@ -1614,7 +1612,7 @@ class parser {\n           }\n           token::TILDE {\n             self.bump();\n-            let sub = self.parse_pat();\n+            let sub = self.parse_pat(refutable);\n             hi = sub.span.hi;\n             // HACK: parse ~\"...\" as a literal of a vstore ~str\n             pat = alt sub.node {\n@@ -1660,11 +1658,13 @@ class parser {\n                 let mut subpat;\n                 if self.token == token::COLON {\n                     self.bump();\n-                    subpat = self.parse_pat();\n+                    subpat = self.parse_pat(refutable);\n                 } else {\n-                    subpat = @{id: self.get_id(),\n-                               node: pat_ident(fieldpath, none),\n-                               span: mk_sp(lo, hi)};\n+                    subpat = @{\n+                        id: self.get_id(),\n+                        node: pat_ident(bind_by_ref, fieldpath, none),\n+                        span: mk_sp(lo, hi)\n+                    };\n                 }\n                 vec::push(fields, {ident: fieldname, pat: subpat});\n             }\n@@ -1681,10 +1681,10 @@ class parser {\n                 let expr = self.mk_expr(lo, hi, expr_lit(lit));\n                 pat = pat_lit(expr);\n             } else {\n-                let mut fields = ~[self.parse_pat()];\n+                let mut fields = ~[self.parse_pat(refutable)];\n                 while self.token == token::COMMA {\n                     self.bump();\n-                    vec::push(fields, self.parse_pat());\n+                    vec::push(fields, self.parse_pat(refutable));\n                 }\n                 if vec::len(fields) == 1u { self.expect(token::COMMA); }\n                 hi = self.span.hi;\n@@ -1704,50 +1704,80 @@ class parser {\n                     hi = val.span.hi;\n                     pat = pat_lit(val);\n                 }\n-            } else if is_plain_ident(self.token) &&\n-                alt self.look_ahead(1u) {\n-                  token::LPAREN | token::LBRACKET | token::LT { false }\n-                  _ { true }\n-                } {\n-                let name = self.parse_value_path();\n-                let sub = if self.eat(token::AT) { some(self.parse_pat()) }\n-                else { none };\n-                pat = pat_ident(name, sub);\n             } else {\n-                let enum_path = self.parse_path_with_tps(true);\n-                hi = enum_path.span.hi;\n-                let mut args: ~[@pat] = ~[];\n-                let mut star_pat = false;\n-                alt self.token {\n-                  token::LPAREN {\n-                    alt self.look_ahead(1u) {\n-                      token::BINOP(token::STAR) {\n-                        // This is a \"top constructor only\" pat\n-                        self.bump(); self.bump();\n-                        star_pat = true;\n-                        self.expect(token::RPAREN);\n+                let binding_mode;\n+                if self.eat_keyword(~\"ref\") {\n+                    binding_mode = bind_by_ref;\n+                } else {\n+                    alt self.token {\n+                        token::BINOP(token::PLUS) => {\n+                            // XXX: Temporary thing pending a snapshot.\n+                            self.bump();\n+                            binding_mode = bind_by_value;\n+                        }\n+                        _ if refutable => {\n+                            // XXX: Should be bind_by_value, but that's not\n+                            // backward compatible.\n+                            binding_mode = bind_by_ref;\n+                        }\n+                        _ => {\n+                            binding_mode = bind_by_value;\n+                        }\n+                    }\n+                }\n+\n+                if is_plain_ident(self.token) &&\n+                    alt self.look_ahead(1) {\n+                      token::LPAREN | token::LBRACKET | token::LT => {\n+                        false\n                       }\n-                      _ {\n-                        args = self.parse_unspanned_seq(\n-                            token::LPAREN, token::RPAREN,\n-                            seq_sep_trailing_disallowed(token::COMMA),\n-                            |p| p.parse_pat());\n-                        hi = self.span.hi;\n+                      _ => {\n+                        true\n                       }\n+                    } {\n+                    let name = self.parse_value_path();\n+                    let sub = if self.eat(token::AT) {\n+                        some(self.parse_pat(refutable))\n+                    }\n+                    else { none };\n+                    pat = pat_ident(binding_mode, name, sub);\n+                } else {\n+                    let enum_path = self.parse_path_with_tps(true);\n+                    hi = enum_path.span.hi;\n+                    let mut args: ~[@pat] = ~[];\n+                    let mut star_pat = false;\n+                    alt self.token {\n+                      token::LPAREN {\n+                        alt self.look_ahead(1u) {\n+                          token::BINOP(token::STAR) {\n+                            // This is a \"top constructor only\" pat\n+                            self.bump(); self.bump();\n+                            star_pat = true;\n+                            self.expect(token::RPAREN);\n+                          }\n+                          _ {\n+                            args = self.parse_unspanned_seq(\n+                                token::LPAREN, token::RPAREN,\n+                                seq_sep_trailing_disallowed(token::COMMA),\n+                                |p| p.parse_pat(refutable));\n+                            hi = self.span.hi;\n+                          }\n+                        }\n+                      }\n+                      _ { }\n+                    }\n+                    // at this point, we're not sure whether it's a enum or a\n+                    // bind\n+                    if star_pat {\n+                        pat = pat_enum(enum_path, none);\n+                    }\n+                    else if vec::is_empty(args) &&\n+                        vec::len(enum_path.idents) == 1u {\n+                        pat = pat_ident(binding_mode, enum_path, none);\n+                    }\n+                    else {\n+                        pat = pat_enum(enum_path, some(args));\n                     }\n-                  }\n-                  _ { }\n-                }\n-                // at this point, we're not sure whether it's a enum or a bind\n-                if star_pat {\n-                    pat = pat_enum(enum_path, none);\n-                }\n-                else if vec::is_empty(args) &&\n-                    vec::len(enum_path.idents) == 1u {\n-                    pat = pat_ident(enum_path, none);\n-                }\n-                else {\n-                    pat = pat_enum(enum_path, some(args));\n                 }\n             }\n           }\n@@ -1758,7 +1788,7 @@ class parser {\n     fn parse_local(is_mutbl: bool,\n                    allow_init: bool) -> @local {\n         let lo = self.span.lo;\n-        let pat = self.parse_pat();\n+        let pat = self.parse_pat(false);\n         let mut ty = @{id: self.get_id(),\n                        node: ty_infer,\n                        span: mk_sp(lo, lo)};"}, {"sha": "cbea14f31850da6e58f45474b7af0977d7393069", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -331,7 +331,7 @@ fn restricted_keyword_table() -> hashmap<~str, ()> {\n         ~\"new\",\n         ~\"owned\",\n         ~\"pure\",\n-        ~\"ret\", ~\"return\",\n+        ~\"ref\", ~\"ret\", ~\"return\",\n         ~\"struct\",\n         ~\"true\", ~\"trait\", ~\"type\",\n         ~\"unchecked\", ~\"unsafe\","}, {"sha": "b0ef87a8cca38d870eeadd16a06fc4cb9e331b1f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -1302,11 +1302,15 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n      is that it doesn't matter */\n     alt pat.node {\n       ast::pat_wild { word(s.s, ~\"_\"); }\n-      ast::pat_ident(path, sub) {\n+      ast::pat_ident(binding_mode, path, sub) {\n+        alt binding_mode {\n+          ast::bind_by_ref => { word_space(s, ~\"ref\"); }\n+          ast::bind_by_value => {}\n+        }\n         print_path(s, path, true);\n         alt sub {\n-          some(p) { word(s.s, ~\"@\"); print_pat(s, p); }\n-          none {}\n+          some(p) => { word(s.s, ~\"@\"); print_pat(s, p); }\n+          none => {}\n         }\n       }\n       ast::pat_enum(path, args_) {"}, {"sha": "5cf73da1944fb6fbfb53e81a7107fb4e95a0c3ef", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -229,7 +229,7 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n       pat_box(inner) | pat_uniq(inner) {\n         v.visit_pat(inner, e, v);\n       }\n-      pat_ident(path, inner) {\n+      pat_ident(_, path, inner) {\n           visit_path(path, e, v);\n           do option::iter(inner) |subpat| { v.visit_pat(subpat, e, v)};\n       }"}, {"sha": "f08a06f341978cca9684d12442f1e14ab51e41a0", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -473,11 +473,13 @@ impl methods for gather_loan_ctxt {\n             }\n           }\n \n-          ast::pat_ident(_, none) if self.pat_is_variant(pat) {\n+          ast::pat_ident(_, _, none) if self.pat_is_variant(pat) {\n             // nullary variant\n             debug!{\"nullary variant\"};\n           }\n-          ast::pat_ident(id, o_pat) {\n+          ast::pat_ident(_, id, o_pat) {\n+            // XXX: Needs to take by-ref/by-val into account.\n+\n             // x or x @ p --- `x` must remain valid for the scope of the alt\n             debug!{\"defines identifier %s\", pprust::path_to_str(id)};\n "}, {"sha": "4093c0fcc6e49914bbf1aaee37ee2d2819de0149", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -71,8 +71,8 @@ fn check_arms(tcx: ty::ctxt, arms: ~[arm]) {\n \n fn raw_pat(p: @pat) -> @pat {\n     alt p.node {\n-      pat_ident(_, some(s)) { raw_pat(s) }\n-      _ { p }\n+      pat_ident(_, _, some(s)) => { raw_pat(s) }\n+      _ => { p }\n     }\n }\n \n@@ -199,32 +199,34 @@ fn is_useful_specialized(tcx: ty::ctxt, m: matrix, v: ~[@pat], ctor: ctor,\n fn pat_ctor_id(tcx: ty::ctxt, p: @pat) -> option<ctor> {\n     let pat = raw_pat(p);\n     alt pat.node {\n-      pat_wild { none }\n-      pat_ident(_, _) | pat_enum(_, _) {\n+      pat_wild => { none }\n+      pat_ident(_, _, _) | pat_enum(_, _) => {\n         alt tcx.def_map.find(pat.id) {\n           some(def_variant(_, id)) { some(variant(id)) }\n           _ { none }\n         }\n       }\n-      pat_lit(expr) { some(val(eval_const_expr(tcx, expr))) }\n-      pat_range(lo, hi) {\n+      pat_lit(expr) => { some(val(eval_const_expr(tcx, expr))) }\n+      pat_range(lo, hi) => {\n         some(range(eval_const_expr(tcx, lo), eval_const_expr(tcx, hi)))\n       }\n-      pat_box(_) | pat_uniq(_) | pat_rec(_, _) | pat_tup(_) { some(single) }\n+      pat_box(_) | pat_uniq(_) | pat_rec(_, _) | pat_tup(_) => {\n+        some(single)\n+      }\n     }\n }\n \n fn is_wild(tcx: ty::ctxt, p: @pat) -> bool {\n     let pat = raw_pat(p);\n     alt pat.node {\n-      pat_wild { true }\n-      pat_ident(_, _) {\n+      pat_wild => { true }\n+      pat_ident(_, _, _) => {\n         alt tcx.def_map.find(pat.id) {\n-          some(def_variant(_, _)) { false }\n-          _ { true }\n+          some(def_variant(_, _)) => { false }\n+          _ => { true }\n         }\n       }\n-      _ { false }\n+      _ => { false }\n     }\n }\n \n@@ -296,7 +298,7 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n     alt r0.node {\n       pat_wild { some(vec::append(vec::from_elem(arity, wild()),\n                                   vec::tail(r))) }\n-      pat_ident(_, _) {\n+      pat_ident(_, _, _) {\n         alt tcx.def_map.find(r0.id) {\n           some(def_variant(_, id)) {\n             if variant(id) == ctor_id { some(vec::tail(r)) }\n@@ -377,26 +379,26 @@ fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n     }\n \n     alt pat.node {\n-      pat_box(sub) | pat_uniq(sub) | pat_ident(_, some(sub)) {\n+      pat_box(sub) | pat_uniq(sub) | pat_ident(_, _, some(sub)) => {\n         is_refutable(tcx, sub)\n       }\n-      pat_wild | pat_ident(_, none) { false }\n-      pat_lit(_) | pat_range(_, _) { true }\n-      pat_rec(fields, _) {\n+      pat_wild | pat_ident(_, _, none) => { false }\n+      pat_lit(_) | pat_range(_, _) => { true }\n+      pat_rec(fields, _) => {\n         for fields.each |it| {\n             if is_refutable(tcx, it.pat) { ret true; }\n         }\n         false\n       }\n-      pat_tup(elts) {\n+      pat_tup(elts) => {\n         for elts.each |elt| { if is_refutable(tcx, elt) { ret true; } }\n         false\n       }\n-      pat_enum(_, some(args)) {\n+      pat_enum(_, some(args)) => {\n         for args.each |p| { if is_refutable(tcx, p) { ret true; } };\n         false\n       }\n-      pat_enum(_,_) { false }\n+      pat_enum(_,_) => { false }\n     }\n }\n "}, {"sha": "8415b5e1a3286797af774ce9cc795dbd9cd95f85", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -24,7 +24,7 @@ fn pat_id_map(dm: resolve3::DefMap, pat: @pat) -> pat_id_map {\n fn pat_is_variant(dm: resolve3::DefMap, pat: @pat) -> bool {\n     alt pat.node {\n       pat_enum(_, _) { true }\n-      pat_ident(_, none) {\n+      pat_ident(_, _, none) {\n         alt dm.find(pat.id) {\n           some(def_variant(_, _)) { true }\n           _ { false }\n@@ -38,7 +38,7 @@ fn pat_bindings(dm: resolve3::DefMap, pat: @pat,\n                 it: fn(node_id, span, @path)) {\n     do walk_pat(pat) |p| {\n         alt p.node {\n-          pat_ident(pth, _) if !pat_is_variant(dm, p) {\n+          pat_ident(_, pth, _) if !pat_is_variant(dm, p) {\n             it(p.id, p.span, pth);\n           }\n           _ {}"}, {"sha": "809fd1c6fd69d3034b029ca844bbc711c38bfab3", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -208,7 +208,7 @@ fn resolve_arm(arm: ast::arm, cx: ctxt, visitor: visit::vt<ctxt>) {\n \n fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n     alt pat.node {\n-      ast::pat_ident(path, _) {\n+      ast::pat_ident(_, path, _) {\n         let defn_opt = cx.def_map.find(pat.id);\n         alt defn_opt {\n           some(ast::def_variant(_,_)) {"}, {"sha": "f66e3925fb092b040514dc8f4941ea2dbe76314f", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -5,11 +5,11 @@ import metadata::cstore::find_use_stmt_cnum;\n import metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n import middle::lang_items::LanguageItems;\n import middle::lint::{deny, allow, forbid, level, unused_imports, warn};\n-import syntax::ast::{_mod, add, arm, bitand, bitor, bitxor, blk, bound_const};\n-import syntax::ast::{bound_copy, bound_owned, bound_send, bound_trait};\n-import syntax::ast::{capture_clause, class_ctor, class_dtor, class_member};\n-import syntax::ast::{class_method, crate, crate_num, decl_item, def, def_arg};\n-import syntax::ast::{def_binding, def_class, def_const, def_fn};\n+import syntax::ast::{_mod, add, arm, bind_by_value, bitand, bitor, bitxor};\n+import syntax::ast::{blk, bound_const, bound_copy, bound_owned, bound_send};\n+import syntax::ast::{bound_trait, capture_clause, class_ctor, class_dtor};\n+import syntax::ast::{class_member, class_method, crate, crate_num, decl_item};\n+import syntax::ast::{def, def_arg, def_binding, def_class, def_const, def_fn};\n import syntax::ast::{def_foreign_mod, def_id, def_local, def_mod};\n import syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param,\n                      def_typaram_binder};\n@@ -3734,8 +3734,8 @@ class Resolver {\n         let pat_id = pattern.id;\n         do walk_pat(pattern) |pattern| {\n             alt pattern.node {\n-                pat_ident(path, _)\n-                        if !path.global && path.idents.len() == 1u {\n+                pat_ident(_, path, _)\n+                        if !path.global && path.idents.len() == 1u => {\n \n                     // The meaning of pat_ident with no type parameters\n                     // depends on whether an enum variant with that name is in\n@@ -3748,14 +3748,14 @@ class Resolver {\n                     let atom = (*self.atom_table).intern(path.idents[0]);\n \n                     alt self.resolve_enum_variant_or_const(atom) {\n-                        FoundEnumVariant(def) if mode == RefutableMode {\n+                        FoundEnumVariant(def) if mode == RefutableMode => {\n                             debug!{\"(resolving pattern) resolving `%s` to \\\n                                     enum variant\",\n                                    *path.idents[0]};\n \n                             self.record_def(pattern.id, def);\n                         }\n-                        FoundEnumVariant(_) {\n+                        FoundEnumVariant(_) => {\n                             self.session.span_err(pattern.span,\n                                                   fmt!{\"declaration of `%s` \\\n                                                         shadows an enum \\\n@@ -3764,13 +3764,13 @@ class Resolver {\n                                                             atom_to_str\n                                                             (atom)});\n                         }\n-                        FoundConst {\n+                        FoundConst => {\n                             self.session.span_err(pattern.span,\n                                                   ~\"pattern variable \\\n                                                    conflicts with a constant \\\n                                                    in scope\");\n                         }\n-                        EnumVariantOrConstNotFound {\n+                        EnumVariantOrConstNotFound => {\n                             debug!{\"(resolving pattern) binding `%s`\",\n                                    *path.idents[0]};\n \n@@ -3836,7 +3836,7 @@ class Resolver {\n                     }\n                 }\n \n-                pat_ident(path, _) | pat_enum(path, _) {\n+                pat_ident(_, path, _) | pat_enum(path, _) => {\n                     // These two must be enum variants.\n                     alt self.resolve_path(path, ValueNS, false, visitor) {\n                         some(def @ def_variant(*)) {\n@@ -3860,16 +3860,16 @@ class Resolver {\n                     }\n                 }\n \n-                pat_lit(expr) {\n+                pat_lit(expr) => {\n                     self.resolve_expr(expr, visitor);\n                 }\n \n-                pat_range(first_expr, last_expr) {\n+                pat_range(first_expr, last_expr) => {\n                     self.resolve_expr(first_expr, visitor);\n                     self.resolve_expr(last_expr, visitor);\n                 }\n \n-                _ {\n+                _ => {\n                     // Nothing to do.\n                 }\n             }"}, {"sha": "b25aa26066fff6c2ea0e688fe0f10296343f58ba", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -79,7 +79,12 @@ fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> opt {\n     core::unreachable();\n }\n \n-type bind_map = ~[{ident: ast::ident, val: ValueRef}];\n+type bind_map = ~[{\n+    ident: ast::ident,\n+    val: ValueRef,\n+    mode: ast::binding_mode\n+}];\n+\n fn assoc(key: ast::ident, list: bind_map) -> option<ValueRef> {\n     for vec::each(list) |elt| {\n         if str::eq(*elt.ident, *key) { ret some(elt.val); }\n@@ -98,7 +103,7 @@ type match_ = ~[match_branch];\n fn has_nested_bindings(m: match_, col: uint) -> bool {\n     for vec::each(m) |br| {\n         alt br.pats[col].node {\n-          ast::pat_ident(_, some(_)) { ret true; }\n+          ast::pat_ident(_, _, some(_)) { ret true; }\n           _ {}\n         }\n     }\n@@ -109,7 +114,7 @@ fn expand_nested_bindings(m: match_, col: uint, val: ValueRef) -> match_ {\n     let mut result = ~[];\n     for vec::each(m) |br| {\n       alt br.pats[col].node {\n-          ast::pat_ident(name, some(inner)) {\n+          ast::pat_ident(mode, name, some(inner)) {\n             let pats = vec::append(\n                 vec::slice(br.pats, 0u, col),\n                 vec::append(~[inner],\n@@ -118,7 +123,8 @@ fn expand_nested_bindings(m: match_, col: uint, val: ValueRef) -> match_ {\n                       @{pats: pats,\n                         bound: vec::append(\n                             br.bound, ~[{ident: path_to_ident(name),\n-                                        val: val}])\n+                                        val: val,\n+                                        mode: mode}])\n                                 with *br});\n           }\n           _ { vec::push(result, br); }\n@@ -140,9 +146,11 @@ fn enter_match(dm: DefMap, m: match_, col: uint, val: ValueRef,\n                 vec::view(br.pats, col + 1u, br.pats.len()));\n             let self = br.pats[col];\n             let bound = alt self.node {\n-              ast::pat_ident(name, none) if !pat_is_variant(dm, self) {\n+              ast::pat_ident(mode, name, none) if !pat_is_variant(dm, self) {\n                 vec::append(br.bound,\n-                            ~[{ident: path_to_ident(name), val: val}])\n+                            ~[{ident: path_to_ident(name),\n+                               val: val,\n+                               mode: mode}])\n               }\n               _ { br.bound }\n             };\n@@ -158,7 +166,7 @@ fn enter_default(dm: DefMap, m: match_, col: uint, val: ValueRef) -> match_ {\n     do enter_match(dm, m, col, val) |p| {\n         alt p.node {\n           ast::pat_wild | ast::pat_rec(_, _) | ast::pat_tup(_) { some(~[]) }\n-          ast::pat_ident(_, none) if !pat_is_variant(dm, p) {\n+          ast::pat_ident(_, _, none) if !pat_is_variant(dm, p) {\n             some(~[])\n           }\n           _ { none }\n@@ -177,7 +185,7 @@ fn enter_opt(tcx: ty::ctxt, m: match_, opt: opt, col: uint,\n                      vec::from_elem(variant_size, dummy))) }\n             else { none }\n           }\n-          ast::pat_ident(_, none) if pat_is_variant(tcx.def_map, p) {\n+          ast::pat_ident(_, _, none) if pat_is_variant(tcx.def_map, p) {\n             if opt_eq(tcx, variant_opt(tcx, p.id), opt) { some(~[]) }\n             else { none }\n           }\n@@ -359,7 +367,7 @@ fn pick_col(m: match_) -> uint {\n     fn score(p: @ast::pat) -> uint {\n         alt p.node {\n           ast::pat_lit(_) | ast::pat_enum(_, _) | ast::pat_range(_, _) { 1u }\n-          ast::pat_ident(_, some(p)) { score(p) }\n+          ast::pat_ident(_, _, some(p)) { score(p) }\n           _ { 0u }\n         }\n     }\n@@ -725,7 +733,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n \n     // Necessary since bind_irrefutable_pat is called outside trans_alt\n     alt pat.node {\n-      ast::pat_ident(_,inner) {\n+      ast::pat_ident(_, _,inner) {\n         if pat_is_variant(bcx.tcx().def_map, pat) { ret bcx; }\n         if make_copy {\n             let ty = node_id_type(bcx, pat.id);"}, {"sha": "ef92891418a620886d6235e58bf241bec3a1e975", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -4380,7 +4380,7 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n     let _icx = cx.insn_ctxt(~\"alloc_local\");\n     let t = node_id_type(cx, local.node.id);\n     let simple_name = alt local.node.pat.node {\n-      ast::pat_ident(pth, none) { some(path_to_ident(pth)) }\n+      ast::pat_ident(_, pth, none) { some(path_to_ident(pth)) }\n       _ { none }\n     };\n     let val = alloc_ty(cx, t);"}, {"sha": "98e7129abba130aac61582c69a66bd9996b08400", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -646,7 +646,7 @@ fn create_local_var(bcx: block, local: @ast::local)\n     }\n \n     let name = alt local.node.pat.node {\n-      ast::pat_ident(pth, _) { ast_util::path_to_ident(pth) }\n+      ast::pat_ident(_, pth, _) { ast_util::path_to_ident(pth) }\n       // FIXME this should be handled (#2533)\n       _ { fail ~\"no single variable name for local\"; }\n     };"}, {"sha": "d8dd6bf0542f532b247698cf786180a3cbbb9750", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -320,14 +320,14 @@ fn check_fn(ccx: @crate_ctxt,\n         // Add pattern bindings.\n         let visit_pat = fn@(p: @ast::pat, &&e: (), v: visit::vt<()>) {\n             alt p.node {\n-              ast::pat_ident(path, _)\n-              if !pat_util::pat_is_variant(fcx.ccx.tcx.def_map, p) {\n+              ast::pat_ident(_, path, _)\n+                  if !pat_util::pat_is_variant(fcx.ccx.tcx.def_map, p) => {\n                 assign(p.id, none);\n                 debug!{\"Pattern binding %s is assigned to %s\",\n                        *path.idents[0],\n                        fcx.locals.get(p.id).to_str()};\n               }\n-              _ {}\n+              _ => {}\n             }\n             visit::visit_pat(p, e, v);\n         };"}, {"sha": "5cc8a95372286e6ac19d371b526dd9a9b1619cb6", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -155,7 +155,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         }\n         fcx.write_ty(pat.id, b_ty);\n       }\n-      ast::pat_ident(name, sub) if !pat_is_variant(tcx.def_map, pat) {\n+      ast::pat_ident(_, name, sub) if !pat_is_variant(tcx.def_map, pat) {\n         let vid = lookup_local(fcx, pat.span, pat.id);\n         let mut typ = ty::mk_var(tcx, vid);\n         demand::suptype(fcx, pat.span, expected, typ);\n@@ -171,7 +171,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           _ {}\n         }\n       }\n-      ast::pat_ident(path, c) {\n+      ast::pat_ident(_, path, c) {\n         check_pat_variant(pcx, pat, path, some(~[]), expected);\n       }\n       ast::pat_enum(path, subpats) {"}, {"sha": "50e2d5db973c407ea1f7090ec98f8e7c561a4111", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b414db041be115d877e5b17bc86ea019420b672c/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=b414db041be115d877e5b17bc86ea019420b672c", "patch": "@@ -105,7 +105,7 @@ fn visit_local(l: @ast::local, &&rcx: @rcx, v: rvt) {\n fn visit_pat(p: @ast::pat, &&rcx: @rcx, v: rvt) {\n     let fcx = rcx.fcx;\n     alt p.node {\n-      ast::pat_ident(path, _)\n+      ast::pat_ident(_, path, _)\n       if !pat_util::pat_is_variant(fcx.ccx.tcx.def_map, p) {\n         debug!{\"visit_pat binding=%s\", *path.idents[0]};\n         visit_node(p.id, p.span, rcx);"}]}