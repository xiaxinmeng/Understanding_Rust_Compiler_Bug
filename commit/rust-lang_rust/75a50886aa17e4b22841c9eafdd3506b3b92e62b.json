{"sha": "75a50886aa17e4b22841c9eafdd3506b3b92e62b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1YTUwODg2YWExN2U0YjIyODQxYzllYWZkZDM1MDZiM2I5MmU2MmI=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-09T10:03:18Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-15T16:14:34Z"}, "message": "Avoid converting through Constructor when subtracting ranges", "tree": {"sha": "b3825e78f53eca1a218482d31714565cf8bc3bba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3825e78f53eca1a218482d31714565cf8bc3bba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75a50886aa17e4b22841c9eafdd3506b3b92e62b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75a50886aa17e4b22841c9eafdd3506b3b92e62b", "html_url": "https://github.com/rust-lang/rust/commit/75a50886aa17e4b22841c9eafdd3506b3b92e62b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75a50886aa17e4b22841c9eafdd3506b3b92e62b/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6c862574de4245698452f46025163434a9fbbe1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6c862574de4245698452f46025163434a9fbbe1", "html_url": "https://github.com/rust-lang/rust/commit/c6c862574de4245698452f46025163434a9fbbe1"}], "stats": {"total": 67, "additions": 29, "deletions": 38}, "files": [{"sha": "37bd50579448e21f7af107f3c6723082f87ee5f9", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 29, "deletions": 38, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/75a50886aa17e4b22841c9eafdd3506b3b92e62b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75a50886aa17e4b22841c9eafdd3506b3b92e62b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=75a50886aa17e4b22841c9eafdd3506b3b92e62b", "patch": "@@ -763,35 +763,30 @@ impl<'tcx> Constructor<'tcx> {\n                 remaining_ctors\n             }\n             ConstantRange(..) | ConstantValue(..) => {\n-                if let Some(_self_range) = IntRange::from_ctor(tcx, param_env, self) {\n-                    let mut remaining_ctors = vec![self.clone()];\n-                    for other_ctor in other_ctors {\n-                        if other_ctor == self {\n-                            // If a constructor appears in a `match` arm, we can\n+                if let Some(self_range) = IntRange::from_ctor(tcx, param_env, self) {\n+                    let mut remaining_ranges = vec![self_range.clone()];\n+                    let other_ranges = other_ctors\n+                        .into_iter()\n+                        .filter_map(|c| IntRange::from_ctor(tcx, param_env, c));\n+                    for other_range in other_ranges {\n+                        if other_range == self_range {\n+                            // If the `self` range appears directly in a `match` arm, we can\n                             // eliminate it straight away.\n-                            remaining_ctors = vec![]\n-                        } else if let Some(interval) =\n-                            IntRange::from_ctor(tcx, param_env, other_ctor)\n-                        {\n-                            // Refine the required constructors for the type by subtracting\n-                            // the range defined by the current constructor pattern.\n-                            remaining_ctors =\n-                                interval.subtract_from(tcx, param_env, remaining_ctors);\n+                            remaining_ranges = vec![];\n+                        } else {\n+                            // Otherwise explicitely compute the remaining ranges.\n+                            remaining_ranges = other_range.subtract_from(remaining_ranges);\n                         }\n \n-                        // If the constructor patterns that have been considered so far\n-                        // already cover the entire range of values, then we know the\n-                        // constructor is not missing, and we can move on to the next one.\n-                        if remaining_ctors.is_empty() {\n+                        // If the ranges that have been considered so far already cover the entire\n+                        // range of values, we can return early.\n+                        if remaining_ranges.is_empty() {\n                             break;\n                         }\n                     }\n \n-                    // If a constructor has not been matched, then it is missing.\n-                    // We add `remaining_ctors` instead of `self`, because then we can\n-                    // provide more detailed error information about precisely which\n-                    // ranges have been omitted.\n-                    remaining_ctors\n+                    // Convert the ranges back into constructors\n+                    remaining_ranges.into_iter().map(|range| range.into_ctor(tcx)).collect()\n                 } else {\n                     if other_ctors.iter().any(|c| {\n                         c == self\n@@ -1418,38 +1413,27 @@ impl<'tcx> IntRange<'tcx> {\n \n     /// Returns a collection of ranges that spans the values covered by `ranges`, subtracted\n     /// by the values covered by `self`: i.e., `ranges \\ self` (in set notation).\n-    fn subtract_from(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ranges: Vec<Constructor<'tcx>>,\n-    ) -> Vec<Constructor<'tcx>> {\n-        let ranges = ranges\n-            .into_iter()\n-            .filter_map(|r| IntRange::from_ctor(tcx, param_env, &r).map(|i| i.range));\n+    fn subtract_from(self, ranges: Vec<IntRange<'tcx>>) -> Vec<IntRange<'tcx>> {\n         let mut remaining_ranges = vec![];\n         let ty = self.ty;\n         let span = self.span;\n         let (lo, hi) = self.range.into_inner();\n         for subrange in ranges {\n-            let (subrange_lo, subrange_hi) = subrange.into_inner();\n+            let (subrange_lo, subrange_hi) = subrange.range.into_inner();\n             if lo > subrange_hi || subrange_lo > hi {\n                 // The pattern doesn't intersect with the subrange at all,\n                 // so the subrange remains untouched.\n-                remaining_ranges\n-                    .push(IntRange { range: subrange_lo..=subrange_hi, ty, span }.into_ctor(tcx));\n+                remaining_ranges.push(IntRange { range: subrange_lo..=subrange_hi, ty, span });\n             } else {\n                 if lo > subrange_lo {\n                     // The pattern intersects an upper section of the\n                     // subrange, so a lower section will remain.\n-                    remaining_ranges\n-                        .push(IntRange { range: subrange_lo..=(lo - 1), ty, span }.into_ctor(tcx));\n+                    remaining_ranges.push(IntRange { range: subrange_lo..=(lo - 1), ty, span });\n                 }\n                 if hi < subrange_hi {\n                     // The pattern intersects a lower section of the\n                     // subrange, so an upper section will remain.\n-                    remaining_ranges\n-                        .push(IntRange { range: (hi + 1)..=subrange_hi, ty, span }.into_ctor(tcx));\n+                    remaining_ranges.push(IntRange { range: (hi + 1)..=subrange_hi, ty, span });\n                 }\n             }\n         }\n@@ -1491,6 +1475,13 @@ impl<'tcx> IntRange<'tcx> {\n     }\n }\n \n+// Ignore spans when comparing, they don't carry semantic information as they are only for lints.\n+impl<'tcx> std::cmp::PartialEq for IntRange<'tcx> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.range == other.range && self.ty == other.ty\n+    }\n+}\n+\n // A struct to compute a set of constructors equivalent to `all_ctors \\ used_ctors`.\n struct MissingConstructors<'tcx> {\n     tcx: TyCtxt<'tcx>,"}]}