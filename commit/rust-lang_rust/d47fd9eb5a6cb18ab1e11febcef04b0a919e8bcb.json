{"sha": "d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0N2ZkOWViNWE2Y2IxOGFiMWUxMWZlYmNlZjA0YjBhOTE5ZThiY2I=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-19T20:46:31Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T16:21:33Z"}, "message": "rustc_metadata: use specialization for {en,de}coding Ty and Substs.", "tree": {"sha": "357fc24b4f1877ea8e3d9610529cf5eb454eaa70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/357fc24b4f1877ea8e3d9610529cf5eb454eaa70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb", "html_url": "https://github.com/rust-lang/rust/commit/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82197287a204376ac6c1aa102f8af79bd20246cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/82197287a204376ac6c1aa102f8af79bd20246cf", "html_url": "https://github.com/rust-lang/rust/commit/82197287a204376ac6c1aa102f8af79bd20246cf"}], "stats": {"total": 239, "additions": 71, "deletions": 168}, "files": [{"sha": "9dacb9062c1c3776153d60dd93c8e7d9e35f1a8e", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 15, "deletions": 105, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb", "patch": "@@ -509,85 +509,20 @@ pub trait MacroLoader {\n /// Note, however, that this only works for RBML-based encoding and decoding at\n /// the moment.\n pub mod tls {\n-    use rbml::opaque::Encoder as OpaqueEncoder;\n     use rbml::opaque::Decoder as OpaqueDecoder;\n-    use serialize;\n     use std::cell::Cell;\n-    use std::mem;\n-    use ty::{self, Ty, TyCtxt};\n+    use ty::{Ty, TyCtxt};\n     use ty::subst::Substs;\n     use hir::def_id::DefId;\n \n-    pub trait EncodingContext<'tcx> {\n-        fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n-        fn encode_ty(&self, encoder: &mut OpaqueEncoder, t: Ty<'tcx>);\n-        fn encode_substs(&self, encoder: &mut OpaqueEncoder, substs: &Substs<'tcx>);\n-    }\n-\n     /// Marker type used for the TLS slot.\n     /// The type context cannot be used directly because the TLS\n     /// in libstd doesn't allow types generic over lifetimes.\n     struct TlsPayload;\n \n-    thread_local! {\n-        static TLS_ENCODING: Cell<Option<*const TlsPayload>> = Cell::new(None)\n-    }\n-\n-    /// Execute f after pushing the given EncodingContext onto the TLS stack.\n-    pub fn enter_encoding_context<'tcx, F, R>(ecx: &EncodingContext<'tcx>,\n-                                              encoder: &mut OpaqueEncoder,\n-                                              f: F) -> R\n-        where F: FnOnce(&EncodingContext<'tcx>, &mut OpaqueEncoder) -> R\n-    {\n-        let tls_payload = (ecx as *const _, encoder as *mut _);\n-        let tls_ptr = &tls_payload as *const _ as *const TlsPayload;\n-        TLS_ENCODING.with(|tls| {\n-            let prev = tls.get();\n-            tls.set(Some(tls_ptr));\n-            let ret = f(ecx, encoder);\n-            tls.set(prev);\n-            return ret\n-        })\n-    }\n-\n-    /// Execute f with access to the thread-local encoding context and\n-    /// rbml encoder. This function will panic if the encoder passed in and the\n-    /// context encoder are not the same.\n-    ///\n-    /// Note that this method is 'practically' safe due to its checking that the\n-    /// encoder passed in is the same as the one in TLS, but it would still be\n-    /// possible to construct cases where the EncodingContext is exchanged\n-    /// while the same encoder is used, thus working with a wrong context.\n-    pub fn with_encoding_context<'tcx, E, F, R>(encoder: &mut E, f: F) -> R\n-        where F: FnOnce(&EncodingContext<'tcx>, &mut OpaqueEncoder) -> R,\n-              E: serialize::Encoder\n-    {\n-        unsafe {\n-            unsafe_with_encoding_context(|ecx, tls_encoder| {\n-                assert!(encoder as *mut _ as usize == tls_encoder as *mut _ as usize);\n-\n-                let ecx: &EncodingContext<'tcx> = mem::transmute(ecx);\n-\n-                f(ecx, tls_encoder)\n-            })\n-        }\n-    }\n-\n-    /// Execute f with access to the thread-local encoding context and\n-    /// rbml encoder.\n-    pub unsafe fn unsafe_with_encoding_context<F, R>(f: F) -> R\n-        where F: FnOnce(&EncodingContext, &mut OpaqueEncoder) -> R\n-    {\n-        TLS_ENCODING.with(|tls| {\n-            let tls = tls.get().unwrap();\n-            let tls_payload = tls as *mut (&EncodingContext, &mut OpaqueEncoder);\n-            f((*tls_payload).0, (*tls_payload).1)\n-        })\n-    }\n-\n     pub trait DecodingContext<'tcx> {\n         fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n-        fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> ty::Ty<'tcx>;\n+        fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> Ty<'tcx>;\n         fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> &'tcx Substs<'tcx>;\n         fn translate_def_id(&self, def_id: DefId) -> DefId;\n     }\n@@ -597,56 +532,31 @@ pub mod tls {\n     }\n \n     /// Execute f after pushing the given DecodingContext onto the TLS stack.\n-    pub fn enter_decoding_context<'tcx, F, R>(dcx: &DecodingContext<'tcx>,\n-                                              decoder: &mut OpaqueDecoder,\n-                                              f: F) -> R\n-        where F: FnOnce(&DecodingContext<'tcx>, &mut OpaqueDecoder) -> R\n+    pub fn enter_decoding_context<'tcx, F, R>(dcx: &DecodingContext<'tcx>, f: F) -> R\n+        where F: FnOnce(&DecodingContext<'tcx>) -> R\n     {\n-        let tls_payload = (dcx as *const _, decoder as *mut _);\n+        let tls_payload = dcx as *const _;\n         let tls_ptr = &tls_payload as *const _ as *const TlsPayload;\n         TLS_DECODING.with(|tls| {\n             let prev = tls.get();\n             tls.set(Some(tls_ptr));\n-            let ret = f(dcx, decoder);\n+            let ret = f(dcx);\n             tls.set(prev);\n-            return ret\n+            ret\n         })\n     }\n \n-    /// Execute f with access to the thread-local decoding context and\n-    /// rbml decoder. This function will panic if the decoder passed in and the\n-    /// context decoder are not the same.\n-    ///\n-    /// Note that this method is 'practically' safe due to its checking that the\n-    /// decoder passed in is the same as the one in TLS, but it would still be\n-    /// possible to construct cases where the DecodingContext is exchanged\n-    /// while the same decoder is used, thus working with a wrong context.\n-    pub fn with_decoding_context<'decoder, 'tcx, D, F, R>(d: &'decoder mut D, f: F) -> R\n-        where D: serialize::Decoder,\n-              F: FnOnce(&DecodingContext<'tcx>,\n-                        &mut OpaqueDecoder) -> R,\n-              'tcx: 'decoder\n+    /// Execute f with access to the thread-local decoding context.\n+    /// FIXME(eddyb) This is horribly unsound as it allows the\n+    /// caler to pick any lifetime for 'tcx, including 'static.\n+    pub fn with_decoding_context<'tcx, F, R>(f: F) -> R\n+        where F: FnOnce(&DecodingContext<'tcx>) -> R,\n     {\n         unsafe {\n-            unsafe_with_decoding_context(|dcx, decoder| {\n-                assert!((d as *mut _ as usize) == (decoder as *mut _ as usize));\n-\n-                let dcx: &DecodingContext<'tcx> = mem::transmute(dcx);\n-\n-                f(dcx, decoder)\n+            TLS_DECODING.with(|tls| {\n+                let tls = tls.get().unwrap();\n+                f(*(tls as *mut &DecodingContext))\n             })\n         }\n     }\n-\n-    /// Execute f with access to the thread-local decoding context and\n-    /// rbml decoder.\n-    pub unsafe fn unsafe_with_decoding_context<F, R>(f: F) -> R\n-        where F: FnOnce(&DecodingContext, &mut OpaqueDecoder) -> R\n-    {\n-        TLS_DECODING.with(|tls| {\n-            let tls = tls.get().unwrap();\n-            let tls_payload = tls as *mut (&DecodingContext, &mut OpaqueDecoder);\n-            f((*tls_payload).0, (*tls_payload).1)\n-        })\n-    }\n }"}, {"sha": "716b4672ec72e0878af1582ef2644858be5d061b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb", "patch": "@@ -34,7 +34,7 @@ use util::common::MemoizationMap;\n use util::nodemap::NodeSet;\n use util::nodemap::FnvHashMap;\n \n-use serialize::{Encodable, Encoder, Decodable, Decoder};\n+use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::hash::{Hash, Hasher};\n@@ -567,23 +567,8 @@ impl<'tcx> Hash for TyS<'tcx> {\n \n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n-impl<'tcx> Encodable for Ty<'tcx> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        cstore::tls::with_encoding_context(s, |ecx, rbml_w| {\n-            ecx.encode_ty(rbml_w, *self);\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<'tcx> Decodable for Ty<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Ty<'tcx>, D::Error> {\n-        cstore::tls::with_decoding_context(d, |dcx, rbml_r| {\n-            Ok(dcx.decode_ty(rbml_r))\n-        })\n-    }\n-}\n-\n+impl<'tcx> serialize::UseSpecializedEncodable for Ty<'tcx> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for Ty<'tcx> {}\n \n /// Upvars do not get their own node-id. Instead, we use the pair of\n /// the original var id (that is, the root variable that is referenced\n@@ -1506,7 +1491,7 @@ impl<'tcx> Decodable for AdtDef<'tcx> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<AdtDef<'tcx>, D::Error> {\n         let def_id: DefId = Decodable::decode(d)?;\n \n-        cstore::tls::with_decoding_context(d, |dcx, _| {\n+        cstore::tls::with_decoding_context(|dcx| {\n             let def_id = dcx.translate_def_id(def_id);\n             Ok(dcx.tcx().lookup_adt_def(def_id))\n         })"}, {"sha": "5f02b1be44a821795748015808cbd34572e88f14", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb", "patch": "@@ -275,7 +275,7 @@ impl<'tcx> Encodable for ClosureSubsts<'tcx> {\n impl<'tcx> Decodable for ClosureSubsts<'tcx> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<ClosureSubsts<'tcx>, D::Error> {\n         let (func_substs, upvar_tys) = Decodable::decode(d)?;\n-        cstore::tls::with_decoding_context(d, |dcx, _| {\n+        cstore::tls::with_decoding_context(|dcx| {\n             Ok(ClosureSubsts {\n                 func_substs: func_substs,\n                 upvar_tys: dcx.tcx().mk_type_list(upvar_tys)\n@@ -666,7 +666,7 @@ pub enum Region {\n impl<'tcx> Decodable for &'tcx Region {\n     fn decode<D: Decoder>(d: &mut D) -> Result<&'tcx Region, D::Error> {\n         let r = Decodable::decode(d)?;\n-        cstore::tls::with_decoding_context(d, |dcx, _| {\n+        cstore::tls::with_decoding_context(|dcx| {\n             Ok(dcx.tcx().mk_region(r))\n         })\n     }"}, {"sha": "6b493118bcfd0d8c817c31d3131f1ab816e909ff", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb", "patch": "@@ -10,12 +10,11 @@\n \n // Type substitutions.\n \n-use middle::cstore;\n use hir::def_id::DefId;\n use ty::{self, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n-use serialize::{Encodable, Encoder, Decodable, Decoder};\n+use serialize;\n use syntax_pos::{Span, DUMMY_SP};\n \n use core::nonzero::NonZero;\n@@ -298,25 +297,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n     }\n }\n \n-impl<'tcx> Encodable for &'tcx Substs<'tcx> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        cstore::tls::with_encoding_context(s, |ecx, rbml_w| {\n-            ecx.encode_substs(rbml_w, self);\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<'tcx> Decodable for &'tcx Substs<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<&'tcx Substs<'tcx>, D::Error> {\n-        let substs = cstore::tls::with_decoding_context(d, |dcx, rbml_r| {\n-            dcx.decode_substs(rbml_r)\n-        });\n-\n-        Ok(substs)\n-    }\n-}\n-\n+impl<'tcx> serialize::UseSpecializedEncodable for &'tcx Substs<'tcx> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Substs<'tcx> {}\n \n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`"}, {"sha": "3b6984a8c4622fbc49e4dfe1e8daa085fb8decf0", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb", "patch": "@@ -28,13 +28,14 @@ use middle::dependency_format::Linkage;\n use rustc::dep_graph::DepNode;\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::Substs;\n \n use rustc::hir::svh::Svh;\n use rustc::mir::mir_map::MirMap;\n use rustc::session::config::{self, PanicStrategy, CrateTypeRustcMacro};\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n \n-use rustc_serialize::Encodable;\n+use rustc_serialize::{Encodable, SpecializedEncoder, SpecializedDecoder};\n use std::cell::RefCell;\n use std::io::prelude::*;\n use std::io::{Cursor, SeekFrom};\n@@ -78,6 +79,48 @@ impl<'a, 'tcx> DerefMut for EncodeContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n+    fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n+        let cx = self.ty_str_ctxt();\n+        self.emit_opaque(|opaque_encoder| {\n+            Ok(tyencode::enc_ty(opaque_encoder.cursor, &cx, ty))\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> SpecializedEncoder<&'tcx Substs<'tcx>> for EncodeContext<'a, 'tcx> {\n+    fn specialized_encode(&mut self, substs: &&'tcx Substs<'tcx>) -> Result<(), Self::Error> {\n+        let cx = self.ty_str_ctxt();\n+        self.emit_opaque(|opaque_encoder| {\n+            Ok(tyencode::enc_substs(opaque_encoder.cursor, &cx, substs))\n+        })\n+    }\n+}\n+\n+/// FIXME(#31844) This is horribly unsound as it allows the\n+/// caller to pick any lifetime for 'tcx, including 'static.\n+impl<'a, 'tcx> SpecializedDecoder<Ty<'tcx>> for ::rbml::reader::Decoder<'a> {\n+    fn specialized_decode(&mut self) -> Result<Ty<'tcx>, Self::Error> {\n+        self.read_opaque(|opaque_decoder, _| {\n+            ::middle::cstore::tls::with_decoding_context(|dcx| {\n+                Ok(dcx.decode_ty(opaque_decoder))\n+            })\n+        })\n+    }\n+}\n+\n+/// FIXME(#31844) This is horribly unsound as it allows the\n+/// caller to pick any lifetime for 'tcx, including 'static.\n+impl<'a, 'tcx> SpecializedDecoder<&'tcx Substs<'tcx>> for ::rbml::reader::Decoder<'a> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx Substs<'tcx>, Self::Error> {\n+        self.read_opaque(|opaque_decoder, _| {\n+            ::middle::cstore::tls::with_decoding_context(|dcx| {\n+                Ok(dcx.decode_substs(opaque_decoder))\n+            })\n+        })\n+    }\n+}\n+\n fn encode_name(ecx: &mut EncodeContext, name: Name) {\n     ecx.wr_tagged_str(tag_paths_data_name, &name.as_str());\n }"}, {"sha": "d9d103beaf0f85f9fbcf4d8b92ac423dc2692ea0", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb", "patch": "@@ -26,6 +26,7 @@\n #![feature(rustc_macro_lib)]\n #![feature(rustc_macro_internals)]\n #![feature(rustc_private)]\n+#![feature(specialization)]\n #![feature(staged_api)]\n #![cfg_attr(test, feature(test))]\n "}, {"sha": "da6d04fc0ef37e9036b7187b938964952dff32c5", "filename": "src/librustc_metadata/tls_context.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb/src%2Flibrustc_metadata%2Ftls_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb/src%2Flibrustc_metadata%2Ftls_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftls_context.rs?ref=d47fd9eb5a6cb18ab1e11febcef04b0a919e8bcb", "patch": "@@ -11,32 +11,14 @@\n // This module provides implementations for the thread-local encoding and\n // decoding context traits in rustc::middle::cstore::tls.\n \n-use rbml::opaque::Encoder as OpaqueEncoder;\n use rbml::opaque::Decoder as OpaqueDecoder;\n use rustc::middle::cstore::tls;\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{Ty, TyCtxt};\n \n use decoder::{self, Cmd};\n-use encoder;\n use tydecode::TyDecoder;\n-use tyencode;\n-\n-impl<'a, 'tcx: 'a> tls::EncodingContext<'tcx> for encoder::EncodeContext<'a, 'tcx> {\n-\n-    fn tcx<'s>(&'s self) -> TyCtxt<'s, 'tcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn encode_ty(&self, encoder: &mut OpaqueEncoder, t: ty::Ty<'tcx>) {\n-        tyencode::enc_ty(encoder.cursor, &self.ty_str_ctxt(), t);\n-    }\n-\n-    fn encode_substs(&self, encoder: &mut OpaqueEncoder, substs: &Substs<'tcx>) {\n-        tyencode::enc_substs(encoder.cursor, &self.ty_str_ctxt(), substs);\n-    }\n-}\n \n pub struct DecodingContext<'a, 'tcx: 'a> {\n     pub crate_metadata: Cmd<'a>,\n@@ -49,7 +31,7 @@ impl<'a, 'tcx: 'a> tls::DecodingContext<'tcx> for DecodingContext<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> ty::Ty<'tcx> {\n+    fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> Ty<'tcx> {\n         let def_id_convert = &mut |did| {\n             decoder::translate_def_id(self.crate_metadata, did)\n         };"}]}