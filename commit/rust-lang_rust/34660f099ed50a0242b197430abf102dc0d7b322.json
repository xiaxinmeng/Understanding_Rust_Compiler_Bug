{"sha": "34660f099ed50a0242b197430abf102dc0d7b322", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0NjYwZjA5OWVkNTBhMDI0MmIxOTc0MzBhYmYxMDJkYzBkN2IzMjI=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-07-04T21:36:03Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-07-04T21:36:03Z"}, "message": "Merge pull request #2798 from erickt/incoming\n\nadding base64 and to_bytes to stdlib", "tree": {"sha": "b7fd457a80b7460fd32680a2fa4a72c1bf426ffb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7fd457a80b7460fd32680a2fa4a72c1bf426ffb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34660f099ed50a0242b197430abf102dc0d7b322", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34660f099ed50a0242b197430abf102dc0d7b322", "html_url": "https://github.com/rust-lang/rust/commit/34660f099ed50a0242b197430abf102dc0d7b322", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34660f099ed50a0242b197430abf102dc0d7b322/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10fd19580ed1f2caed28e90893f2f4889760265d", "url": "https://api.github.com/repos/rust-lang/rust/commits/10fd19580ed1f2caed28e90893f2f4889760265d", "html_url": "https://github.com/rust-lang/rust/commit/10fd19580ed1f2caed28e90893f2f4889760265d"}, {"sha": "2f9c0114fa0b0d3b018b37dcfd0eafaf01d6c48a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f9c0114fa0b0d3b018b37dcfd0eafaf01d6c48a", "html_url": "https://github.com/rust-lang/rust/commit/2f9c0114fa0b0d3b018b37dcfd0eafaf01d6c48a"}], "stats": {"total": 177, "additions": 177, "deletions": 0}, "files": [{"sha": "4bfd16344cbd57e80df29e083d8deb2f4743f29c", "filename": "src/libcore/to_bytes.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/34660f099ed50a0242b197430abf102dc0d7b322/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34660f099ed50a0242b197430abf102dc0d7b322/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=34660f099ed50a0242b197430abf102dc0d7b322", "patch": "@@ -0,0 +1,19 @@\n+iface to_bytes {\n+    fn to_bytes() -> ~[u8];\n+}\n+\n+impl of to_bytes for ~[u8] {\n+    fn to_bytes() -> ~[u8] { copy self }\n+}\n+\n+impl of to_bytes for @~[u8] {\n+    fn to_bytes() -> ~[u8] { copy *self }\n+}\n+\n+impl of to_bytes for str {\n+    fn to_bytes() -> ~[u8] { str::bytes(self) }\n+}\n+\n+impl of to_bytes for @str {\n+    fn to_bytes() -> ~[u8] { str::bytes(*self) }\n+}"}, {"sha": "3ca34c4b756975f69682ddfec422920f450698d2", "filename": "src/libstd/base64.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/34660f099ed50a0242b197430abf102dc0d7b322/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34660f099ed50a0242b197430abf102dc0d7b322/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=34660f099ed50a0242b197430abf102dc0d7b322", "patch": "@@ -0,0 +1,158 @@\n+import io::{reader, reader_util};\n+\n+iface to_base64 {\n+    fn to_base64() -> str;\n+}\n+\n+impl of to_base64 for ~[u8] {\n+    fn to_base64() -> str {\n+        let chars = str::chars(\n+            \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n+        );\n+\n+        let len = self.len();\n+        let mut s = \"\";\n+        str::reserve(s, ((len + 3u) / 4u) * 3u);\n+\n+        let mut i = 0u;\n+\n+        while i < len - (len % 3u) {\n+            let n = (self[i] as uint) << 16u |\n+                    (self[i + 1u] as uint) << 8u |\n+                    (self[i + 2u] as uint);\n+\n+            // This 24-bit number gets separated into four 6-bit numbers.\n+            str::push_char(s, chars[(n >> 18u) & 63u]);\n+            str::push_char(s, chars[(n >> 12u) & 63u]);\n+            str::push_char(s, chars[(n >> 6u) & 63u]);\n+            str::push_char(s, chars[n & 63u]);\n+\n+            i += 3u;\n+        }\n+\n+        alt check len % 3u {\n+          0u { }\n+          1u {\n+            let n = (self[i] as uint) << 16u;\n+            str::push_char(s, chars[(n >> 18u) & 63u]);\n+            str::push_char(s, chars[(n >> 12u) & 63u]);\n+            str::push_char(s, '=');\n+            str::push_char(s, '=');\n+          }\n+          2u {\n+            let n = (self[i] as uint) << 16u | (self[i + 1u] as uint) << 8u;\n+            str::push_char(s, chars[(n >> 18u) & 63u]);\n+            str::push_char(s, chars[(n >> 12u) & 63u]);\n+            str::push_char(s, chars[(n >> 6u) & 63u]);\n+            str::push_char(s, '=');\n+          }\n+        }\n+\n+        s\n+    }\n+}\n+\n+impl of to_base64 for str {\n+    fn to_base64() -> str {\n+        str::bytes(self).to_base64()\n+    }\n+}\n+\n+iface from_base64 {\n+    fn from_base64() -> ~[u8];\n+}\n+\n+impl of from_base64 for ~[u8] {\n+    fn from_base64() -> ~[u8] {\n+        if self.len() % 4u != 0u { fail \"invalid base64 length\"; }\n+\n+        let len = self.len();\n+        let mut padding = 0u;\n+\n+        if len != 0u {\n+            if self[len - 1u] == '=' as u8 { padding += 1u; }\n+            if self[len - 2u] == '=' as u8 { padding += 1u; }\n+        }\n+\n+        let mut r = ~[];\n+        vec::reserve(r, (len / 4u) * 3u - padding);\n+\n+        let mut i = 0u;\n+        while i < len {\n+            let mut n = 0u;\n+\n+            for iter::repeat(4u) {\n+                let ch = self[i] as char;\n+                n <<= 6u;\n+\n+                if ch >= 'A' && ch <= 'Z' {\n+                    n |= (ch as uint) - 0x41u;\n+                } else if ch >= 'a' && ch <= 'z' {\n+                    n |= (ch as uint) - 0x47u;\n+                } else if ch >= '0' && ch <= '9' {\n+                    n |= (ch as uint) + 0x04u;\n+                } else if ch == '+' {\n+                    n |= 0x3Eu;\n+                } else if ch == '/' {\n+                    n |= 0x3Fu;\n+                } else if ch == '=' {\n+                    alt len - i {\n+                      1u {\n+                        vec::push(r, ((n >> 16u) & 0xFFu) as u8);\n+                        vec::push(r, ((n >> 8u ) & 0xFFu) as u8);\n+                        ret copy r;\n+                      }\n+                      2u {\n+                        vec::push(r, ((n >> 10u) & 0xFFu) as u8);\n+                        ret copy r;\n+                      }\n+                      _ {\n+                        fail \"invalid base64 padding\";\n+                      }\n+                    }\n+                } else {\n+                    fail \"invalid base64 character\";\n+                }\n+\n+                i += 1u;\n+            };\n+\n+            vec::push(r, ((n >> 16u) & 0xFFu) as u8);\n+            vec::push(r, ((n >> 8u ) & 0xFFu) as u8);\n+            vec::push(r, ((n       ) & 0xFFu) as u8);\n+        }\n+\n+        r\n+    }\n+}\n+\n+impl of from_base64 for str {\n+    fn from_base64() -> ~[u8] {\n+        str::bytes(self).from_base64()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_to_base64() {\n+        assert \"\".to_base64()       == \"\";\n+        assert \"f\".to_base64()      == \"Zg==\";\n+        assert \"fo\".to_base64()     == \"Zm8=\";\n+        assert \"foo\".to_base64()    == \"Zm9v\";\n+        assert \"foob\".to_base64()   == \"Zm9vYg==\";\n+        assert \"fooba\".to_base64()  == \"Zm9vYmE=\";\n+        assert \"foobar\".to_base64() == \"Zm9vYmFy\";\n+    }\n+\n+    #[test]\n+    fn test_from_base64() {\n+        assert \"\".from_base64() == str::bytes(\"\");\n+        assert \"Zg==\".from_base64() == str::bytes(\"f\");\n+        assert \"Zm8=\".from_base64() == str::bytes(\"fo\");\n+        assert \"Zm9v\".from_base64() == str::bytes(\"foo\");\n+        assert \"Zm9vYg==\".from_base64() == str::bytes(\"foob\");\n+        assert \"Zm9vYmE=\".from_base64() == str::bytes(\"fooba\");\n+        assert \"Zm9vYmFy\".from_base64() == str::bytes(\"foobar\");\n+    }\n+}"}]}