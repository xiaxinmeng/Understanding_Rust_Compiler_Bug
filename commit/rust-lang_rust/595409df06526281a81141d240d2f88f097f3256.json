{"sha": "595409df06526281a81141d240d2f88f097f3256", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NTQwOWRmMDY1MjYyODFhODExNDFkMjQwZDJmODhmMDk3ZjMyNTY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-06-05T00:50:49Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-06-05T00:50:49Z"}, "message": "Introduce a fast-path for type_is_sized/type_moves_by_default\n\nThis seems to improve performance by the same 2-3% of my selection\nfast-path.", "tree": {"sha": "203de3c38163f720ce1bdafeba908b0cf129a548", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/203de3c38163f720ce1bdafeba908b0cf129a548"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/595409df06526281a81141d240d2f88f097f3256", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/595409df06526281a81141d240d2f88f097f3256", "html_url": "https://github.com/rust-lang/rust/commit/595409df06526281a81141d240d2f88f097f3256", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/595409df06526281a81141d240d2f88f097f3256/comments", "author": null, "committer": null, "parents": [{"sha": "52e530af4cfe4a873cd27278ee3ddff66b6754e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/52e530af4cfe4a873cd27278ee3ddff66b6754e1", "html_url": "https://github.com/rust-lang/rust/commit/52e530af4cfe4a873cd27278ee3ddff66b6754e1"}], "stats": {"total": 187, "additions": 119, "deletions": 68}, "files": [{"sha": "6985ca27861eb585c36c1a64287c5b48460785a5", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/595409df06526281a81141d240d2f88f097f3256/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595409df06526281a81141d240d2f88f097f3256/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=595409df06526281a81141d240d2f88f097f3256", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n                cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n         debug!(\"consume; cmt: {:?}; type: {}\", *cmt, ty_to_string(self.tcx, cmt.ty));\n-        if !ty::type_is_sized(self.param_env, span, cmt.ty) {\n+        if !ty::type_is_sized(Some(self.param_env), self.tcx, span, cmt.ty) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\",\n                 ty_to_string(self.tcx, cmt.ty));"}, {"sha": "b67f0434918143402aca7e41be0a676b99e1f617", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/595409df06526281a81141d240d2f88f097f3256/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595409df06526281a81141d240d2f88f097f3256/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=595409df06526281a81141d240d2f88f097f3256", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n                 debug!(\"with_each_combination: space={:?}, index={}, param_ty={}\",\n                        space, index, param_ty.repr(self.tcx));\n \n-                if !ty::type_is_sized(param_env, span, param_ty) {\n+                if !ty::type_is_sized(Some(param_env), self.tcx, span, param_ty) {\n                     debug!(\"with_each_combination: param_ty is not known to be sized\");\n \n                     substs.types.get_mut_slice(space)[index] = self.dummy_unsized_ty;"}, {"sha": "87216b1add0fa8648f61c55c02c243dcdde4bb2a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 115, "deletions": 54, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/595409df06526281a81141d240d2f88f097f3256/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595409df06526281a81141d240d2f88f097f3256/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=595409df06526281a81141d240d2f88f097f3256", "patch": "@@ -756,16 +756,6 @@ pub struct ctxt<'tcx> {\n     /// Caches the representation hints for struct definitions.\n     pub repr_hint_cache: RefCell<DefIdMap<Rc<Vec<attr::ReprAttr>>>>,\n \n-    /// Caches whether types are known to impl Copy. Note that type\n-    /// parameters are never placed into this cache, because their\n-    /// results are dependent on the parameter environment.\n-    pub type_impls_copy_cache: RefCell<HashMap<Ty<'tcx>,bool>>,\n-\n-    /// Caches whether types are known to impl Sized. Note that type\n-    /// parameters are never placed into this cache, because their\n-    /// results are dependent on the parameter environment.\n-    pub type_impls_sized_cache: RefCell<HashMap<Ty<'tcx>,bool>>,\n-\n     /// Maps Expr NodeId's to their constant qualification.\n     pub const_qualif_map: RefCell<NodeMap<check_const::ConstQualif>>,\n \n@@ -827,6 +817,23 @@ bitflags! {\n         const NEEDS_SUBST       = TypeFlags::HAS_PARAMS.bits |\n                                   TypeFlags::HAS_SELF.bits |\n                                   TypeFlags::HAS_REGIONS.bits,\n+\n+        // Flags representing the nominal content of a type,\n+        // computed by FlagsComputetion\n+        const NOMINAL_FLAGS     = TypeFlags::HAS_PARAMS.bits |\n+                                  TypeFlags::HAS_SELF.bits |\n+                                  TypeFlags::HAS_TY_INFER.bits |\n+                                  TypeFlags::HAS_RE_INFER.bits |\n+                                  TypeFlags::HAS_RE_LATE_BOUND.bits |\n+                                  TypeFlags::HAS_REGIONS.bits |\n+                                  TypeFlags::HAS_TY_ERR.bits |\n+                                  TypeFlags::HAS_PROJECTION.bits,\n+\n+        // Caches for type_is_sized, type_moves_by_default\n+        const SIZEDNESS_CACHED  = 1 << 16,\n+        const IS_SIZED          = 1 << 17,\n+        const MOVENESS_CACHED   = 1 << 18,\n+        const MOVES_BY_DEFAULT  = 1 << 19,\n     }\n }\n \n@@ -859,8 +866,8 @@ macro_rules! sty_debug_print {\n                         ty::ty_err => /* unimportant */ continue,\n                         $(ty::$variant(..) => &mut $variant,)*\n                     };\n-                    let region = t.flags.intersects(ty::TypeFlags::HAS_RE_INFER);\n-                    let ty = t.flags.intersects(ty::TypeFlags::HAS_TY_INFER);\n+                    let region = t.flags.get().intersects(ty::TypeFlags::HAS_RE_INFER);\n+                    let ty = t.flags.get().intersects(ty::TypeFlags::HAS_TY_INFER);\n \n                     variant.total += 1;\n                     total.total += 1;\n@@ -908,7 +915,7 @@ impl<'tcx> ctxt<'tcx> {\n #[derive(Debug)]\n pub struct TyS<'tcx> {\n     pub sty: sty<'tcx>,\n-    pub flags: TypeFlags,\n+    pub flags: Cell<TypeFlags>,\n \n     // the maximal depth of any bound regions appearing in this type.\n     region_depth: u32,\n@@ -964,23 +971,23 @@ impl<'tcx> Borrow<sty<'tcx>> for InternedTy<'tcx> {\n }\n \n pub fn type_has_params(ty: Ty) -> bool {\n-    ty.flags.intersects(TypeFlags::HAS_PARAMS)\n+    ty.flags.get().intersects(TypeFlags::HAS_PARAMS)\n }\n pub fn type_has_self(ty: Ty) -> bool {\n-    ty.flags.intersects(TypeFlags::HAS_SELF)\n+    ty.flags.get().intersects(TypeFlags::HAS_SELF)\n }\n pub fn type_has_ty_infer(ty: Ty) -> bool {\n-    ty.flags.intersects(TypeFlags::HAS_TY_INFER)\n+    ty.flags.get().intersects(TypeFlags::HAS_TY_INFER)\n }\n pub fn type_needs_infer(ty: Ty) -> bool {\n-    ty.flags.intersects(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER)\n+    ty.flags.get().intersects(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER)\n }\n pub fn type_has_projection(ty: Ty) -> bool {\n-    ty.flags.intersects(TypeFlags::HAS_PROJECTION)\n+    ty.flags.get().intersects(TypeFlags::HAS_PROJECTION)\n }\n \n pub fn type_has_late_bound_regions(ty: Ty) -> bool {\n-    ty.flags.intersects(TypeFlags::HAS_RE_LATE_BOUND)\n+    ty.flags.get().intersects(TypeFlags::HAS_RE_LATE_BOUND)\n }\n \n /// An \"escaping region\" is a bound region whose binder is not part of `t`.\n@@ -2770,8 +2777,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         stability: RefCell::new(stability),\n         selection_cache: traits::SelectionCache::new(),\n         repr_hint_cache: RefCell::new(DefIdMap()),\n-        type_impls_copy_cache: RefCell::new(HashMap::new()),\n-        type_impls_sized_cache: RefCell::new(HashMap::new()),\n         const_qualif_map: RefCell::new(NodeMap()),\n         custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n         cast_kinds: RefCell::new(NodeMap()),\n@@ -2871,7 +2876,7 @@ fn intern_ty<'tcx>(type_arena: &'tcx TypedArena<TyS<'tcx>>,\n \n     let ty = match () {\n         () => type_arena.alloc(TyS { sty: st,\n-                                     flags: flags.flags,\n+                                     flags: Cell::new(flags.flags),\n                                      region_depth: flags.depth, }),\n     };\n \n@@ -2902,7 +2907,7 @@ impl FlagComputation {\n     }\n \n     fn add_flags(&mut self, flags: TypeFlags) {\n-        self.flags = self.flags | flags;\n+        self.flags = self.flags | (flags & TypeFlags::NOMINAL_FLAGS);\n     }\n \n     fn add_depth(&mut self, depth: u32) {\n@@ -3008,7 +3013,7 @@ impl FlagComputation {\n     }\n \n     fn add_ty(&mut self, ty: Ty) {\n-        self.add_flags(ty.flags);\n+        self.add_flags(ty.flags.get());\n         self.add_depth(ty.region_depth);\n     }\n \n@@ -3389,11 +3394,11 @@ pub fn type_is_nil(ty: Ty) -> bool {\n }\n \n pub fn type_is_error(ty: Ty) -> bool {\n-    ty.flags.intersects(TypeFlags::HAS_TY_ERR)\n+    ty.flags.get().intersects(TypeFlags::HAS_TY_ERR)\n }\n \n pub fn type_needs_subst(ty: Ty) -> bool {\n-    ty.flags.intersects(TypeFlags::NEEDS_SUBST)\n+    ty.flags.get().intersects(TypeFlags::NEEDS_SUBST)\n }\n \n pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {\n@@ -3911,42 +3916,30 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n     }\n }\n \n-fn type_impls_bound<'a,'tcx>(param_env: &ParameterEnvironment<'a,'tcx>,\n-                             cache: &RefCell<HashMap<Ty<'tcx>,bool>>,\n+fn type_impls_bound<'a,'tcx>(param_env: Option<&ParameterEnvironment<'a,'tcx>>,\n+                             tcx: &ty::ctxt<'tcx>,\n                              ty: Ty<'tcx>,\n                              bound: ty::BuiltinBound,\n                              span: Span)\n                              -> bool\n {\n-    assert!(!ty::type_needs_infer(ty));\n-\n-    if !type_has_params(ty) && !type_has_self(ty) {\n-        match cache.borrow().get(&ty) {\n-            None => {}\n-            Some(&result) => {\n-                debug!(\"type_impls_bound({}, {:?}) = {:?} (cached)\",\n-                       ty.repr(param_env.tcx),\n-                       bound,\n-                       result);\n-                return result\n-            }\n+    let pe;\n+    let param_env = match param_env {\n+        Some(e) => e,\n+        None => {\n+            pe = empty_parameter_environment(tcx);\n+            &pe\n         }\n-    }\n-\n-    let infcx = infer::new_infer_ctxt(param_env.tcx);\n+    };\n+    let infcx = infer::new_infer_ctxt(tcx);\n \n     let is_impld = traits::type_known_to_meet_builtin_bound(&infcx, param_env, ty, bound, span);\n \n     debug!(\"type_impls_bound({}, {:?}) = {:?}\",\n-           ty.repr(param_env.tcx),\n+           ty.repr(tcx),\n            bound,\n            is_impld);\n \n-    if !type_has_params(ty) && !type_has_self(ty) {\n-        let old_value = cache.borrow_mut().insert(ty, is_impld);\n-        assert!(old_value.is_none());\n-    }\n-\n     is_impld\n }\n \n@@ -3955,17 +3948,85 @@ pub fn type_moves_by_default<'a,'tcx>(param_env: &ParameterEnvironment<'a,'tcx>,\n                                       ty: Ty<'tcx>)\n                                       -> bool\n {\n-    let tcx = param_env.tcx;\n-    !type_impls_bound(param_env, &tcx.type_impls_copy_cache, ty, ty::BoundCopy, span)\n+    if ty.flags.get().intersects(TypeFlags::MOVENESS_CACHED) {\n+        return ty.flags.get().intersects(TypeFlags::MOVES_BY_DEFAULT);\n+    }\n+\n+    assert!(!ty::type_needs_infer(ty));\n+\n+    // Fast-path for primitive types\n+    let result = match ty.sty {\n+        ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n+        ty_ptr(..) | ty_bare_fn(..) | ty_rptr(_, mt {\n+            mutbl: ast::MutImmutable, ..\n+        }) => Some(false),\n+\n+        ty_str | ty_uniq(..) | ty_rptr(_, mt {\n+            mutbl: ast::MutMutable, ..\n+        }) => Some(true),\n+\n+        ty_vec(..) | ty_trait(..) | ty_tup(..) |\n+        ty_closure(..) | ty_enum(..) | ty_struct(..) |\n+        ty_projection(..) | ty_param(..) | ty_infer(..) | ty_err => None\n+    }.unwrap_or_else(|| !type_impls_bound(Some(param_env),\n+                                          param_env.tcx,\n+                                          ty,\n+                                          ty::BoundCopy,\n+                                          span));\n+\n+    if !type_has_params(ty) && !type_has_self(ty) {\n+        ty.flags.set(ty.flags.get() | if result {\n+            TypeFlags::MOVENESS_CACHED | TypeFlags::MOVES_BY_DEFAULT\n+        } else {\n+            TypeFlags::MOVENESS_CACHED\n+        });\n+    }\n+\n+    result\n }\n \n-pub fn type_is_sized<'a,'tcx>(param_env: &ParameterEnvironment<'a,'tcx>,\n+#[inline]\n+pub fn type_is_sized<'a,'tcx>(param_env: Option<&ParameterEnvironment<'a,'tcx>>,\n+                              tcx: &ty::ctxt<'tcx>,\n                               span: Span,\n                               ty: Ty<'tcx>)\n                               -> bool\n {\n-    let tcx = param_env.tcx;\n-    type_impls_bound(param_env, &tcx.type_impls_sized_cache, ty, ty::BoundSized, span)\n+    if ty.flags.get().intersects(TypeFlags::SIZEDNESS_CACHED) {\n+        let result = ty.flags.get().intersects(TypeFlags::IS_SIZED);\n+        return result;\n+    }\n+\n+    type_is_sized_uncached(param_env, tcx, span, ty)\n+}\n+\n+fn type_is_sized_uncached<'a,'tcx>(param_env: Option<&ParameterEnvironment<'a,'tcx>>,\n+                                   tcx: &ty::ctxt<'tcx>,\n+                                   span: Span,\n+                                   ty: Ty<'tcx>) -> bool {\n+    assert!(!ty::type_needs_infer(ty));\n+\n+    // Fast-path for primitive types\n+    let result = match ty.sty {\n+        ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n+        ty_uniq(..) | ty_ptr(..) | ty_rptr(..) | ty_bare_fn(..) |\n+        ty_vec(_, Some(..)) | ty_tup(..) | ty_closure(..) => Some(true),\n+\n+        ty_str | ty_trait(..) | ty_vec(_, None) => Some(false),\n+\n+        ty_enum(..) | ty_struct(..) | ty_projection(..) | ty_param(..) |\n+        ty_infer(..) | ty_err => None\n+    }.unwrap_or_else(|| type_impls_bound(param_env, tcx, ty, ty::BoundSized, span));\n+\n+    if !type_has_params(ty) && !type_has_self(ty) {\n+        ty.flags.set(ty.flags.get() | if result {\n+            TypeFlags::SIZEDNESS_CACHED | TypeFlags::IS_SIZED\n+        } else {\n+            TypeFlags::SIZEDNESS_CACHED\n+        });\n+    }\n+\n+    result\n }\n \n pub fn is_ffi_safe<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {"}, {"sha": "bd073e4f81ed76bb2b6d75ac16f2b80c4775f427", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/595409df06526281a81141d240d2f88f097f3256/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/595409df06526281a81141d240d2f88f097f3256/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=595409df06526281a81141d240d2f88f097f3256", "patch": "@@ -118,19 +118,9 @@ pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n     }\n }\n \n-// Is the type's representation size known at compile time?\n+/// Is the type's representation size known at compile time?\n pub fn type_is_sized<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    let param_env = ty::empty_parameter_environment(tcx);\n-    // FIXME(#4287) This can cause errors due to polymorphic recursion,\n-    // a better span should be provided, if available.\n-    let err_count = tcx.sess.err_count();\n-    let is_sized = ty::type_is_sized(&param_env, DUMMY_SP, ty);\n-    // Those errors aren't fatal, but an incorrect result can later\n-    // trip over asserts in both rustc's trans and LLVM.\n-    if err_count < tcx.sess.err_count() {\n-        tcx.sess.abort_if_errors();\n-    }\n-    is_sized\n+    ty::type_is_sized(None, tcx, DUMMY_SP, ty)\n }\n \n pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {"}]}