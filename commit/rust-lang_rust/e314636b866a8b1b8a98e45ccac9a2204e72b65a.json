{"sha": "e314636b866a8b1b8a98e45ccac9a2204e72b65a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMTQ2MzZiODY2YThiMWI4YTk4ZTQ1Y2NhYzlhMjIwNGU3MmI2NWE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-06-13T17:10:32Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-17T02:50:57Z"}, "message": "rustc: use Vec instead of VecPerParamSpace for ty::GenericPredicates.", "tree": {"sha": "1f5e6e79372814a0b4a3b9e66ce74c165e82f3dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f5e6e79372814a0b4a3b9e66ce74c165e82f3dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e314636b866a8b1b8a98e45ccac9a2204e72b65a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e314636b866a8b1b8a98e45ccac9a2204e72b65a", "html_url": "https://github.com/rust-lang/rust/commit/e314636b866a8b1b8a98e45ccac9a2204e72b65a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e314636b866a8b1b8a98e45ccac9a2204e72b65a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bf5fa3269ba32ae21e349ac675bdedcc7e99a66", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bf5fa3269ba32ae21e349ac675bdedcc7e99a66", "html_url": "https://github.com/rust-lang/rust/commit/1bf5fa3269ba32ae21e349ac675bdedcc7e99a66"}], "stats": {"total": 257, "additions": 109, "deletions": 148}, "files": [{"sha": "8ddb14e08e31ee9e7653205da3945e718c4515b7", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -184,7 +184,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Search for a predicate like `Self : Sized` amongst the trait bounds.\n         let free_substs = self.construct_free_substs(generics,\n             self.region_maps.node_extent(ast::DUMMY_NODE_ID));\n-        let predicates = predicates.instantiate(self, &free_substs).predicates.into_vec();\n+        let predicates = predicates.instantiate(self, &free_substs).predicates;\n         elaborate_predicates(self, predicates)\n             .any(|predicate| {\n                 match predicate {"}, {"sha": "d580deed0756ab0ccd7acf5e0ad760fffb388978", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -811,7 +811,7 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n     // If so, extract what we know from the trait and try to come up with a good answer.\n     let trait_predicates = selcx.tcx().lookup_predicates(def_id);\n     let bounds = trait_predicates.instantiate(selcx.tcx(), substs);\n-    let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates.into_vec());\n+    let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates);\n     assemble_candidates_from_predicates(selcx,\n                                         obligation,\n                                         obligation_trait_ref,"}, {"sha": "6b9de746f66c39b8e840fff5a98a9f40db68737a", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -1214,7 +1214,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                bounds);\n \n         let matching_bound =\n-            util::elaborate_predicates(self.tcx(), bounds.predicates.into_vec())\n+            util::elaborate_predicates(self.tcx(), bounds.predicates)\n             .filter_to_traits()\n             .find(\n                 |bound| self.probe("}, {"sha": "4f39a711010b7a82105e1334a55051ba85e4c7eb", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -178,7 +178,7 @@ impl<'a, 'gcx, 'tcx> ImplHeader<'tcx> {\n             impl_def_id: impl_def_id,\n             self_ty: tcx.lookup_item_type(impl_def_id).ty,\n             trait_ref: tcx.impl_trait_ref(impl_def_id),\n-            predicates: tcx.lookup_predicates(impl_def_id).predicates.into_vec(),\n+            predicates: tcx.lookup_predicates(impl_def_id).predicates\n         }.subst(tcx, &impl_substs);\n \n         let traits::Normalized { value: mut header, obligations } =\n@@ -775,13 +775,13 @@ impl<'tcx> Generics<'tcx> {\n /// Bounds on generics.\n #[derive(Clone)]\n pub struct GenericPredicates<'tcx> {\n-    pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n+    pub predicates: Vec<Predicate<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n     pub fn empty() -> GenericPredicates<'tcx> {\n         GenericPredicates {\n-            predicates: VecPerParamSpace::empty(),\n+            predicates: vec![]\n         }\n     }\n \n@@ -797,9 +797,9 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n                                   -> InstantiatedPredicates<'tcx>\n     {\n         InstantiatedPredicates {\n-            predicates: self.predicates.map(|pred| {\n+            predicates: self.predicates.iter().map(|pred| {\n                 pred.subst_supertrait(tcx, poly_trait_ref)\n-            })\n+            }).collect()\n         }\n     }\n }\n@@ -1193,12 +1193,12 @@ impl<'tcx> Predicate<'tcx> {\n /// [usize:Bar<isize>]]`.\n #[derive(Clone)]\n pub struct InstantiatedPredicates<'tcx> {\n-    pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n+    pub predicates: Vec<Predicate<'tcx>>,\n }\n \n impl<'tcx> InstantiatedPredicates<'tcx> {\n     pub fn empty() -> InstantiatedPredicates<'tcx> {\n-        InstantiatedPredicates { predicates: VecPerParamSpace::empty() }\n+        InstantiatedPredicates { predicates: vec![] }\n     }\n \n     pub fn is_empty(&self) -> bool {\n@@ -2909,7 +2909,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.global_tcx();\n         let bounds = generic_predicates.instantiate(tcx, &free_substs);\n         let bounds = tcx.liberate_late_bound_regions(free_id_outlive, &ty::Binder(bounds));\n-        let predicates = bounds.predicates.into_vec();\n+        let predicates = bounds.predicates;\n \n         // Finally, we have to normalize the bounds in the environment, in\n         // case they contain any associated type projections. This process"}, {"sha": "25b108cee27550163a797bdb438365937f4c0dde", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -217,14 +217,6 @@ pub struct VecPerParamSpace<T> {\n     content: Vec<T>,\n }\n \n-/// The `split` function converts one `VecPerParamSpace` into this\n-/// `SeparateVecsPerParamSpace` structure.\n-pub struct SeparateVecsPerParamSpace<T> {\n-    pub types: Vec<T>,\n-    pub selfs: Vec<T>,\n-    pub fns: Vec<T>,\n-}\n-\n impl<T: fmt::Debug> fmt::Debug for VecPerParamSpace<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"[{:?};{:?};{:?}]\",\n@@ -428,18 +420,6 @@ impl<T> VecPerParamSpace<T> {\n                                        self.self_limit)\n     }\n \n-    pub fn split(self) -> SeparateVecsPerParamSpace<T> {\n-        let VecPerParamSpace { type_limit, self_limit, content } = self;\n-\n-        let mut content_iter = content.into_iter();\n-\n-        SeparateVecsPerParamSpace {\n-            types: content_iter.by_ref().take(type_limit).collect(),\n-            selfs: content_iter.by_ref().take(self_limit - type_limit).collect(),\n-            fns: content_iter.collect()\n-        }\n-    }\n-\n     pub fn with_slice(mut self, space: ParamSpace, slice: &[T])\n                     -> VecPerParamSpace<T>\n         where T: Clone"}, {"sha": "37750b568bba2823c70e5ac24f28ba7455cc5604", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -917,7 +917,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     let mut first = true;\n                     let mut is_sized = false;\n                     write!(f, \"impl\")?;\n-                    for predicate in bounds.predicates.into_vec() {\n+                    for predicate in bounds.predicates {\n                         if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n                             // Don't print +Sized, but rather +?Sized if absent.\n                             if Some(trait_ref.def_id()) == tcx.lang_items.sized_trait() {"}, {"sha": "0011b59c70ed3d5f19ab908e8d5fdc84306c3fba", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -207,9 +207,8 @@ pub const tag_type_param_def: usize = 0x94;\n pub const tag_item_generics: usize = 0x95;\n pub const tag_method_ty_generics: usize = 0x96;\n \n-pub const tag_type_predicate: usize = 0x97;\n-pub const tag_self_predicate: usize = 0x98;\n-pub const tag_fn_predicate: usize = 0x99;\n+pub const tag_predicate: usize = 0x97;\n+// GAP 0x98, 0x99\n \n pub const tag_unsafety: usize = 0x9a;\n "}, {"sha": "b91fb993f08ee9d931152147fe87458b91690f5b", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -1622,21 +1622,11 @@ fn doc_predicates<'a, 'tcx>(base_doc: rbml::Doc,\n {\n     let doc = reader::get_doc(base_doc, tag);\n \n-    let mut predicates = subst::VecPerParamSpace::empty();\n-    for predicate_doc in reader::tagged_docs(doc, tag_type_predicate) {\n-        predicates.push(subst::TypeSpace,\n-                        doc_predicate(cdata, predicate_doc, tcx));\n-    }\n-    for predicate_doc in reader::tagged_docs(doc, tag_self_predicate) {\n-        predicates.push(subst::SelfSpace,\n-                        doc_predicate(cdata, predicate_doc, tcx));\n-    }\n-    for predicate_doc in reader::tagged_docs(doc, tag_fn_predicate) {\n-        predicates.push(subst::FnSpace,\n-                        doc_predicate(cdata, predicate_doc, tcx));\n+    ty::GenericPredicates {\n+        predicates: reader::tagged_docs(doc, tag_predicate).map(|predicate_doc| {\n+            doc_predicate(cdata, predicate_doc, tcx)\n+        }).collect()\n     }\n-\n-    ty::GenericPredicates { predicates: predicates }\n }\n \n pub fn is_defaulted_trait(cdata: Cmd, trait_id: DefIndex) -> bool {"}, {"sha": "288fb74cc18a13c71c242df7258bbd6f76db6dca", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -26,7 +26,6 @@ use rustc::hir::def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n use rustc::dep_graph::{DepGraph, DepNode, DepTask};\n-use rustc::ty::subst;\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n@@ -541,14 +540,8 @@ fn encode_predicates_in_current_doc<'a,'tcx>(rbml_w: &mut Encoder,\n                                              index: &mut CrateIndex<'a, 'tcx>,\n                                              predicates: &ty::GenericPredicates<'tcx>)\n {\n-    for (space, _, predicate) in predicates.predicates.iter_enumerated() {\n-        let tag = match space {\n-            subst::TypeSpace => tag_type_predicate,\n-            subst::SelfSpace => tag_self_predicate,\n-            subst::FnSpace => tag_fn_predicate\n-        };\n-\n-        rbml_w.wr_tagged_u32(tag,\n+    for predicate in &predicates.predicates {\n+        rbml_w.wr_tagged_u32(tag_predicate,\n             index.add_xref(XRef::Predicate(predicate.clone())));\n     }\n }"}, {"sha": "ffacbae1afd6f1dd158744df1d9ef222eb6c8645", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -1257,7 +1257,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     assert!(mth.is_provided);\n \n                     let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n-                    if !normalize_and_test_predicates(tcx, predicates.into_vec()) {\n+                    if !normalize_and_test_predicates(tcx, predicates) {\n                         continue;\n                     }\n "}, {"sha": "169242fbf7270091f6670a79d89bc020d004e67c", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -289,7 +289,7 @@ pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // try and trans it, in that case. Issue #23435.\n             if mth.is_provided {\n                 let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n-                if !normalize_and_test_predicates(tcx, predicates.into_vec()) {\n+                if !normalize_and_test_predicates(tcx, predicates) {\n                     debug!(\"get_vtable_methods: predicates do not hold\");\n                     return None;\n                 }"}, {"sha": "a0af98dec7298f0153a05a94a51f3d36637ee87e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -56,7 +56,6 @@ use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n use rustc::lint;\n use rustc::ty::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs, ParamSpace};\n-use rustc::ty::subst::VecPerParamSpace;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n@@ -1778,7 +1777,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     let predicates = bounds.predicates(tcx, ty);\n                     let predicates = tcx.lift_to_global(&predicates).unwrap();\n                     tcx.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n-                        predicates: VecPerParamSpace::new(vec![], vec![], predicates)\n+                        predicates: predicates\n                     });\n \n                     ty"}, {"sha": "d501a8a184cee57f3c815a0a7e955b32290579ce", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -13,7 +13,7 @@ use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty;\n use rustc::traits::{self, Reveal};\n use rustc::ty::error::ExpectedFound;\n-use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace};\n+use rustc::ty::subst::{self, Subst, Substs};\n use rustc::hir::map::Node;\n use rustc::hir::{ImplItemKind, TraitItem_};\n \n@@ -213,6 +213,15 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         return;\n     }\n \n+    // Depend on trait/impl predicates always being before method's own predicates,\n+    // to be able to split method predicates into \"inherited\" and method-specific.\n+    let trait_predicates = tcx.lookup_predicates(trait_m.container_id()).predicates;\n+    let impl_predicates = tcx.lookup_predicates(impl_m.container_id()).predicates;\n+    let trait_method_start = trait_predicates.len();\n+    let impl_method_start = impl_predicates.len();\n+    assert_eq!(&trait_predicates[..], &trait_m.predicates.predicates[..trait_method_start]);\n+    assert_eq!(&impl_predicates[..], &impl_m.predicates.predicates[..impl_method_start]);\n+\n     tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|mut infcx| {\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n@@ -224,40 +233,32 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // environment. We can't just use `impl_env.caller_bounds`,\n         // however, because we want to replace all late-bound regions with\n         // region variables.\n-        let impl_bounds =\n-            impl_m.predicates.instantiate(tcx, impl_to_skol_substs);\n+        let impl_bounds = impl_m.predicates.instantiate(tcx, impl_to_skol_substs);\n \n         debug!(\"compare_impl_method: impl_bounds={:?}\", impl_bounds);\n \n-        // Obtain the predicate split predicate sets for each.\n-        let trait_pred = trait_bounds.predicates.split();\n-        let impl_pred = impl_bounds.predicates.split();\n-\n         // This is the only tricky bit of the new way we check implementation methods\n         // We need to build a set of predicates where only the FnSpace bounds\n         // are from the trait and we assume all other bounds from the implementation\n         // to be previously satisfied.\n         //\n         // We then register the obligations from the impl_m and check to see\n         // if all constraints hold.\n-        let hybrid_preds = VecPerParamSpace::new(\n-            impl_pred.types,\n-            impl_pred.selfs,\n-            trait_pred.fns\n-        );\n+        let hybrid_preds = impl_bounds.predicates[..impl_method_start].iter()\n+                    .chain(trait_bounds.predicates[trait_method_start..].iter());\n \n         // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n         // The key step here is to update the caller_bounds's predicates to be\n         // the new hybrid bounds we computed.\n         let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n-        let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.into_vec());\n+        let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.cloned().collect());\n         let trait_param_env = traits::normalize_param_env_or_error(tcx,\n                                                                    trait_param_env,\n                                                                    normalize_cause.clone());\n         // FIXME(@jroesch) this seems ugly, but is a temporary change\n         infcx.parameter_environment = trait_param_env;\n \n-        debug!(\"compare_impl_method: trait_bounds={:?}\",\n+        debug!(\"compare_impl_method: caller_bounds={:?}\",\n             infcx.parameter_environment.caller_bounds);\n \n         let mut selcx = traits::SelectionContext::new(&infcx);\n@@ -266,7 +267,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             infcx.replace_late_bound_regions_with_fresh_var(\n                 impl_m_span,\n                 infer::HigherRankedType,\n-                &ty::Binder(impl_pred.fns));\n+                &ty::Binder(impl_bounds.predicates[impl_method_start..].to_vec()));\n         for predicate in impl_pred_fns {\n             let traits::Normalized { value: predicate, .. } =\n                 traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);"}, {"sha": "1e2446788adc9383c165974017cac8c4245f6626", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -179,21 +179,15 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n     let generic_assumptions = tcx.lookup_predicates(self_type_did);\n \n     let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n-    assert!(assumptions_in_impl_context.predicates.is_empty_in(subst::SelfSpace));\n-    assert!(assumptions_in_impl_context.predicates.is_empty_in(subst::FnSpace));\n-    let assumptions_in_impl_context =\n-        assumptions_in_impl_context.predicates.get_slice(subst::TypeSpace);\n+    let assumptions_in_impl_context = assumptions_in_impl_context.predicates;\n \n     // An earlier version of this code attempted to do this checking\n     // via the traits::fulfill machinery. However, it ran into trouble\n     // since the fulfill machinery merely turns outlives-predicates\n     // 'a:'b and T:'b into region inference constraints. It is simpler\n     // just to look for all the predicates directly.\n \n-    assert!(dtor_predicates.predicates.is_empty_in(subst::SelfSpace));\n-    assert!(dtor_predicates.predicates.is_empty_in(subst::FnSpace));\n-    let predicates = dtor_predicates.predicates.get_slice(subst::TypeSpace);\n-    for predicate in predicates {\n+    for predicate in &dtor_predicates.predicates {\n         // (We do not need to worry about deep analysis of type\n         // expressions etc because the Drop impls are already forced\n         // to take on a structure that is roughly an alpha-renaming of"}, {"sha": "e4701bb119559968e3891c5b1c4f7c6e09d3ee6d", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -799,7 +799,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n             let trait_predicates = self.tcx.lookup_predicates(def_id);\n             let bounds = trait_predicates.instantiate(self.tcx, substs);\n-            let predicates = bounds.predicates.into_vec();\n+            let predicates = bounds.predicates;\n             debug!(\"assemble_projection_candidates: predicates={:?}\",\n                    predicates);\n             for poly_bound in"}, {"sha": "22da4ab9c43faed0b34eba3a638d365726c47bcd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -65,7 +65,7 @@ use middle::lang_items::SizedTraitLangItem;\n use middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{eval_const_expr_partial, report_const_eval_err};\n-use rustc::ty::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace, VecPerParamSpace};\n+use rustc::ty::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace};\n use rustc::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n use rustc::ty::{VariantKind};\n@@ -1185,9 +1185,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n         // generic types:\n         let trait_def = trait_def_of_item(ccx, item);\n         let self_predicate = ty::GenericPredicates {\n-            predicates: VecPerParamSpace::new(vec![],\n-                                              vec![trait_def.trait_ref.to_predicate()],\n-                                              vec![])\n+            predicates: vec![trait_def.trait_ref.to_predicate()]\n         };\n         let scope = &(generics, &self_predicate);\n \n@@ -1209,7 +1207,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n         // Combine the two lists to form the complete set of superbounds:\n         let superbounds = superbounds1.into_iter().chain(superbounds2).collect();\n         let superpredicates = ty::GenericPredicates {\n-            predicates: VecPerParamSpace::new(superbounds, vec![], vec![])\n+            predicates: superbounds\n         };\n         debug!(\"superpredicates for trait {:?} = {:?}\",\n                tcx.map.local_def_id(item.id),\n@@ -1368,7 +1366,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n     // Add in a predicate that `Self:Trait` (where `Trait` is the\n     // current trait).  This is needed for builtin bounds.\n     let self_predicate = trait_def.trait_ref.to_poly_trait_ref().to_predicate();\n-    base_predicates.predicates.push(SelfSpace, self_predicate);\n+    base_predicates.predicates.push(self_predicate);\n \n     // add in the explicit where-clauses\n     let mut trait_predicates =\n@@ -1379,7 +1377,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n                                                            &trait_predicates,\n                                                            trait_def.trait_ref,\n                                                            items);\n-    trait_predicates.predicates.extend(TypeSpace, assoc_predicates.into_iter());\n+    trait_predicates.predicates.extend(assoc_predicates);\n \n     let prev_predicates = tcx.predicates.borrow_mut().insert(def_id, trait_predicates);\n     assert!(prev_predicates.is_none());\n@@ -1784,8 +1782,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                     SizedByDefault::Yes,\n                                     None,\n                                     param.span);\n-        let predicates = bounds.predicates(ccx.tcx, param_ty);\n-        result.predicates.extend(space, predicates.into_iter());\n+        result.predicates.extend(bounds.predicates(ccx.tcx, param_ty));\n     }\n \n     // Collect the region predicates that were declared inline as\n@@ -1803,7 +1800,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         for bound in &param.bounds {\n             let bound_region = ast_region_to_region(ccx.tcx, bound);\n             let outlives = ty::Binder(ty::OutlivesPredicate(region, bound_region));\n-            result.predicates.push(space, outlives.to_predicate());\n+            result.predicates.push(outlives.to_predicate());\n         }\n     }\n \n@@ -1827,17 +1824,17 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                                     poly_trait_ref,\n                                                     &mut projections);\n \n-                            result.predicates.push(space, trait_ref.to_predicate());\n+                            result.predicates.push(trait_ref.to_predicate());\n \n                             for projection in &projections {\n-                                result.predicates.push(space, projection.to_predicate());\n+                                result.predicates.push(projection.to_predicate());\n                             }\n                         }\n \n                         &hir::TyParamBound::RegionTyParamBound(ref lifetime) => {\n                             let region = ast_region_to_region(tcx, lifetime);\n                             let pred = ty::Binder(ty::OutlivesPredicate(ty, region));\n-                            result.predicates.push(space, ty::Predicate::TypeOutlives(pred))\n+                            result.predicates.push(ty::Predicate::TypeOutlives(pred))\n                         }\n                     }\n                 }\n@@ -1848,7 +1845,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 for bound in &region_pred.bounds {\n                     let r2 = ast_region_to_region(tcx, bound);\n                     let pred = ty::Binder(ty::OutlivesPredicate(r1, r2));\n-                    result.predicates.push(space, ty::Predicate::RegionOutlives(pred))\n+                    result.predicates.push(ty::Predicate::RegionOutlives(pred))\n                 }\n             }\n \n@@ -1861,7 +1858,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         }\n     }\n \n-    return result;\n+    result\n }\n \n fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n@@ -2221,9 +2218,6 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let impl_scheme = ccx.tcx.lookup_item_type(impl_def_id);\n     let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n \n-    assert!(impl_predicates.predicates.is_empty_in(FnSpace));\n-    assert!(impl_predicates.predicates.is_empty_in(SelfSpace));\n-\n     // The trait reference is an input, so find all type parameters\n     // reachable from there, to start (if this is an inherent impl,\n     // then just examine the self type).\n@@ -2233,7 +2227,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         input_parameters.extend(ctp::parameters_for(trait_ref, false));\n     }\n \n-    ctp::setup_constraining_predicates(impl_predicates.predicates.get_mut_slice(TypeSpace),\n+    ctp::setup_constraining_predicates(&mut impl_predicates.predicates,\n                                        impl_trait_ref,\n                                        &mut input_parameters);\n "}, {"sha": "cea12404298fc90b212e924ac112bef2421cfcda", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -395,8 +395,12 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                 };\n                 // Not sure the choice of ParamSpace actually matters here,\n                 // because an associated type won't have generics on the LHS\n-                let typedef = (type_scheme, ty::GenericPredicates::empty(),\n-                               subst::ParamSpace::TypeSpace).clean(cx);\n+                let typedef = clean::Typedef {\n+                    type_: type_scheme.ty.clean(cx),\n+                    generics: (&type_scheme.generics,\n+                               &ty::GenericPredicates::empty(),\n+                               subst::TypeSpace).clean(cx)\n+                };\n                 Some(clean::Item {\n                     name: Some(assoc_ty.name.clean(cx)),\n                     inner: clean::TypedefItem(typedef, true),\n@@ -512,20 +516,41 @@ fn build_static<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// its associated types as well. We specifically move these clauses to the\n /// associated types instead when displaying, so when we're genering the\n /// generics for the trait itself we need to be sure to remove them.\n+/// We also need to remove the implied \"recursive\" Self: Trait bound.\n ///\n /// The inverse of this filtering logic can be found in the `Clean`\n /// implementation for `AssociatedType`\n fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics)\n                              -> clean::Generics {\n+    for pred in &mut g.where_predicates {\n+        match *pred {\n+            clean::WherePredicate::BoundPredicate {\n+                ty: clean::Generic(ref s),\n+                ref mut bounds\n+            } if *s == \"Self\" => {\n+                bounds.retain(|bound| {\n+                    match *bound {\n+                        clean::TyParamBound::TraitBound(clean::PolyTrait {\n+                            trait_: clean::ResolvedPath { did, .. },\n+                            ..\n+                        }, _) => did != trait_did,\n+                        _ => true\n+                    }\n+                });\n+            }\n+            _ => {}\n+        }\n+    }\n+\n     g.where_predicates.retain(|pred| {\n         match *pred {\n             clean::WherePredicate::BoundPredicate {\n                 ty: clean::QPath {\n                     self_type: box clean::Generic(ref s),\n                     trait_: box clean::ResolvedPath { did, .. },\n                     name: ref _name,\n-                }, ..\n-            } => *s != \"Self\" || did != trait_did,\n+                }, ref bounds\n+            } => !(*s == \"Self\" && did == trait_did) && !bounds.is_empty(),\n             _ => true,\n         }\n     });"}, {"sha": "0da833d147ee56d9bf331fbca8e3d0b7589c21ec", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -1010,8 +1010,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n             srp.clean(cx)\n         }).collect::<Vec<_>>();\n \n-        let mut where_predicates = preds.predicates.get_slice(space)\n-                                                   .to_vec().clean(cx);\n+        let mut where_predicates = preds.predicates.to_vec().clean(cx);\n \n         // Type parameters and have a Sized bound by default unless removed with\n         // ?Sized.  Scan through the predicates and mark any type parameter with\n@@ -1363,7 +1362,17 @@ impl Clean<Item> for hir::ImplItem {\n \n impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        let generics = (&self.generics, &self.predicates,\n+        // Depend on trait/impl predicates always being before method's own predicates,\n+        // to be able to split method predicates into \"inherited\" and method-specific.\n+        let outer_predicates = cx.tcx().lookup_predicates(self.container_id()).predicates;\n+        let method_start = outer_predicates.len();\n+        assert_eq!(&outer_predicates[..], &self.predicates.predicates[..method_start]);\n+\n+        let method_predicates = ty::GenericPredicates {\n+            predicates: self.predicates.predicates[method_start..].to_vec()\n+        };\n+\n+        let generics = (&self.generics, &method_predicates,\n                         subst::FnSpace).clean(cx);\n         let mut decl = (self.def_id, &self.fty.sig).clean(cx);\n         match self.explicit_self {\n@@ -1863,8 +1872,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 let item_predicates = cx.tcx().lookup_predicates(def_id);\n                 let substs = cx.tcx().lift(&substs).unwrap();\n                 let bounds = item_predicates.instantiate(cx.tcx(), substs);\n-                let predicates = bounds.predicates.into_vec();\n-                ImplTrait(predicates.into_iter().filter_map(|predicate| {\n+                ImplTrait(bounds.predicates.into_iter().filter_map(|predicate| {\n                     predicate.to_opt_poly_trait_ref().clean(cx)\n                 }).collect())\n             }\n@@ -2967,17 +2975,6 @@ impl<'tcx> Clean<Item> for ty::AssociatedType<'tcx> {\n     }\n }\n \n-impl<'a> Clean<Typedef> for (ty::TypeScheme<'a>, ty::GenericPredicates<'a>,\n-                             ParamSpace) {\n-    fn clean(&self, cx: &DocContext) -> Typedef {\n-        let (ref ty_scheme, ref predicates, ps) = *self;\n-        Typedef {\n-            type_: ty_scheme.ty.clean(cx),\n-            generics: (&ty_scheme.generics, predicates, ps).clean(cx)\n-        }\n-    }\n-}\n-\n fn lang_struct(cx: &DocContext, did: Option<DefId>,\n                t: ty::Ty, name: &str,\n                fallback: fn(Box<Type>) -> Type) -> Type {"}, {"sha": "7ae177439064f9c19d642c82009068b0ded9391c", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e314636b866a8b1b8a98e45ccac9a2204e72b65a/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=e314636b866a8b1b8a98e45ccac9a2204e72b65a", "patch": "@@ -30,11 +30,11 @@ use std::mem;\n use std::collections::BTreeMap;\n \n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst;\n+use rustc::ty;\n \n use clean::PathParameters as PP;\n use clean::WherePredicate as WP;\n-use clean::{self, Clean};\n+use clean;\n use core::DocContext;\n \n pub fn where_clauses(cx: &DocContext, clauses: Vec<WP>) -> Vec<WP> {\n@@ -153,27 +153,16 @@ fn trait_is_same_or_supertrait(cx: &DocContext, child: DefId,\n     if child == trait_ {\n         return true\n     }\n-    let def = cx.tcx().lookup_trait_def(child);\n-    let predicates = cx.tcx().lookup_predicates(child);\n-    let generics = (&def.generics, &predicates, subst::TypeSpace).clean(cx);\n-    generics.where_predicates.iter().filter_map(|pred| {\n-        match *pred {\n-            clean::WherePredicate::BoundPredicate {\n-                ty: clean::Generic(ref s),\n-                ref bounds\n-            } if *s == \"Self\" => Some(bounds),\n-            _ => None,\n-        }\n-    }).flat_map(|bounds| bounds).any(|bound| {\n-        let poly_trait = match *bound {\n-            clean::TraitBound(ref t, _) => t,\n-            _ => return false,\n-        };\n-        match poly_trait.trait_ {\n-            clean::ResolvedPath { did, .. } => {\n-                trait_is_same_or_supertrait(cx, did, trait_)\n+    let predicates = cx.tcx().lookup_super_predicates(child).predicates;\n+    predicates.iter().filter_map(|pred| {\n+        if let ty::Predicate::Trait(ref pred) = *pred {\n+            if pred.0.trait_ref.self_ty().is_self() {\n+                Some(pred.def_id())\n+            } else {\n+                None\n             }\n-            _ => false,\n+        } else {\n+            None\n         }\n-    })\n+    }).any(|did| trait_is_same_or_supertrait(cx, did, trait_))\n }"}]}