{"sha": "21187206c3521f10d91627771d682c513a4356dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMTg3MjA2YzM1MjFmMTBkOTE2Mjc3NzFkNjgyYzUxM2E0MzU2ZGM=", "commit": {"author": {"name": "Daniel Patterson", "email": "dbp@riseup.net", "date": "2012-08-01T03:14:50Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-03T18:28:19Z"}, "message": "std::net::url cleanups for lint check", "tree": {"sha": "e72ed52e19cad69b8f1cf4f540c7fb1f64770c4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e72ed52e19cad69b8f1cf4f540c7fb1f64770c4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21187206c3521f10d91627771d682c513a4356dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21187206c3521f10d91627771d682c513a4356dc", "html_url": "https://github.com/rust-lang/rust/commit/21187206c3521f10d91627771d682c513a4356dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21187206c3521f10d91627771d682c513a4356dc/comments", "author": null, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b57f6b73badafede3f9242ce177bb7aa3c695150", "url": "https://api.github.com/repos/rust-lang/rust/commits/b57f6b73badafede3f9242ce177bb7aa3c695150", "html_url": "https://github.com/rust-lang/rust/commit/b57f6b73badafede3f9242ce177bb7aa3c695150"}], "stats": {"total": 111, "additions": 61, "deletions": 50}, "files": [{"sha": "90c5e037e4d6c035efc989b4ccff0ec3aba73d1e", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 61, "deletions": 50, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/21187206c3521f10d91627771d682c513a4356dc/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21187206c3521f10d91627771d682c513a4356dc/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=21187206c3521f10d91627771d682c513a4356dc", "patch": "@@ -30,8 +30,9 @@ type userinfo = {\n \n type query = ~[(~str, ~str)];\n \n-fn url(-scheme: ~str, -user: option<userinfo>, -host: ~str, -port: option<~str>,\n-       -path: ~str, -query: query, -fragment: option<~str>) -> url {\n+fn url(-scheme: ~str, -user: option<userinfo>, -host: ~str,\n+       -port: option<~str>, -path: ~str, -query: query,\n+       -fragment: option<~str>) -> url {\n     { scheme: scheme, user: user, host: host, port: port,\n      path: path, query: query, fragment: fragment }\n }\n@@ -79,19 +80,19 @@ fn encode_inner(s: ~str, full_url: bool) -> ~str {\n     }\n }\n \n-/** \n- * Encodes a URI by replacing reserved characters with percent encoded character\n- * sequences.\n+/**\n+ * Encodes a URI by replacing reserved characters with percent encoded\n+ * character sequences.\n  *\n  * This function is compliant with RFC 3986.\n  */\n fn encode(s: ~str) -> ~str {\n     encode_inner(s, true)\n }\n \n-/** \n- * Encodes a URI component by replacing reserved characters with percent encoded\n- * character sequences.\n+/**\n+ * Encodes a URI component by replacing reserved characters with percent\n+ * encoded character sequences.\n  *\n  * This function is compliant with RFC 3986.\n  */\n@@ -139,14 +140,14 @@ fn decode_inner(s: ~str, full_url: bool) -> ~str {\n \n /**\n  * Decode a string encoded with percent encoding.\n- * \n+ *\n  * This will only decode escape sequences generated by encode_uri.\n  */\n fn decode(s: ~str) -> ~str {\n     decode_inner(s, true)\n }\n \n-/** \n+/**\n  * Decode a string encoded with percent encoding.\n  */\n fn decode_component(s: ~str) -> ~str {\n@@ -172,7 +173,7 @@ fn encode_plus(s: ~str) -> ~str {\n     }\n }\n \n-/** \n+/**\n  * Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n  */\n fn encode_form_urlencoded(m: hashmap<~str, @dvec<@~str>>) -> ~str {\n@@ -190,18 +191,19 @@ fn encode_form_urlencoded(m: hashmap<~str, @dvec<@~str>>) -> ~str {\n                 first = false;\n             }\n \n-            out += #fmt(\"%s=%s\", key, encode_plus(*value)); \n+            out += #fmt(\"%s=%s\", key, encode_plus(*value));\n         }\n     }\n \n     out\n }\n \n-/** \n+/**\n  * Decode a string encoded with the 'application/x-www-form-urlencoded' media\n  * type into a hashmap.\n  */\n-fn decode_form_urlencoded(s: ~[u8]) -> hashmap<~str, @dvec<@~str>> {\n+fn decode_form_urlencoded(s: ~[u8]) ->\n+    map::hashmap<~str, @dvec::dvec<@~str>> {\n     do io::with_bytes_reader(s) |rdr| {\n         let m = str_hash();\n         let mut key = ~\"\";\n@@ -282,7 +284,8 @@ fn split_char_first(s: ~str, c: char) -> (~str, ~str) {\n     if index+match_ == len {\n         return (str::slice(s, 0, index), ~\"\");\n     } else {\n-        return (str::slice(s, 0, index), str::slice(s, index + match_, str::len(s)));\n+        return (str::slice(s, 0, index),\n+             str::slice(s, index + match_, str::len(s)));\n     }\n }\n \n@@ -355,7 +358,7 @@ fn get_scheme(rawurl: ~str) -> result::result<(~str, ~str), @~str> {\n \n // returns userinfo, host, port, and unparsed part, or an error\n // currently doesn't handle IPv6 addresses.\n-fn get_authority(rawurl: ~str) -> \n+fn get_authority(rawurl: ~str) ->\n     result::result<(option<userinfo>, ~str, option<~str>, ~str), @~str> {\n     if !str::starts_with(rawurl, ~\"//\") {\n         // there is no authority.\n@@ -373,7 +376,7 @@ fn get_authority(rawurl: ~str) ->\n     enum input {\n         digit, // all digits\n         hex, // digits and letters a-f\n-        unreserved // all other legal characters in usernames, passwords, hosts\n+        unreserved // all other legal characters\n     }\n     let len = str::len(rawurl);\n     let mut st : state = start;\n@@ -399,8 +402,8 @@ fn get_authority(rawurl: ~str) ->\n         alt c {\n           '0' to '9' { }\n           'A' to 'F' | 'a' to 'f' {\n-            if in == digit { \n-                in = hex; \n+            if in == digit {\n+                in = hex;\n             }\n           }\n           'G' to 'Z' | 'g' to 'z' | '-' | '.' | '_' | '~' | '%' |\n@@ -415,7 +418,7 @@ fn get_authority(rawurl: ~str) ->\n           }\n         }\n \n-        // now state machine        \n+        // now process states\n         alt c {\n           ':' {\n             colon_count += 1;\n@@ -465,14 +468,14 @@ fn get_authority(rawurl: ~str) ->\n             alt st {\n               start {\n                 let user = str::slice(rawurl, begin, i);\n-                userinfo = option::some({user : user, \n+                userinfo = option::some({user : user,\n                                          pass: option::none});\n                 st = in_host;\n               }\n               pass_host_port {\n                 let user = str::slice(rawurl, begin, pos);\n                 let pass = str::slice(rawurl, pos+1, i);\n-                userinfo = option::some({user: user, \n+                userinfo = option::some({user: user,\n                                          pass: option::some(pass)});\n                 st = in_host;\n               }\n@@ -482,7 +485,7 @@ fn get_authority(rawurl: ~str) ->\n             }\n             begin = i+1;\n           }\n-          \n+\n           '?' | '#' | '/' {\n             break;\n           }\n@@ -517,14 +520,14 @@ fn get_authority(rawurl: ~str) ->\n       }\n     }\n \n-    let rest = if i+1 == len { ~\"\" } \n+    let rest = if i+1 == len { ~\"\" }\n     else { str::slice(rawurl, i, len) };\n     return result::ok((userinfo, host, port, rest));\n }\n \n \n // returns the path and unparsed part of url, or an error\n-fn get_path(rawurl: ~str, authority : bool) -> \n+fn get_path(rawurl: ~str, authority : bool) ->\n     result::result<(~str, ~str), @~str> {\n     let len = str::len(rawurl);\n     let mut end = len;\n@@ -548,27 +551,27 @@ fn get_path(rawurl: ~str, authority : bool) ->\n                                '/' in presence of authority.\");\n         }\n     }\n-    \n-    return result::ok((decode_component(str::slice(rawurl, 0, end)), \n+\n+    return result::ok((decode_component(str::slice(rawurl, 0, end)),\n                     str::slice(rawurl, end, len)));\n }\n \n // returns the parsed query and the fragment, if present\n-fn get_query_fragment(rawurl: ~str) -> \n+fn get_query_fragment(rawurl: ~str) ->\n     result::result<(query, option<~str>), @~str> {\n     if !str::starts_with(rawurl, ~\"?\") {\n         if str::starts_with(rawurl, ~\"#\") {\n-            let f = decode_component(str::slice(rawurl, \n-                                                1, \n+            let f = decode_component(str::slice(rawurl,\n+                                                1,\n                                                 str::len(rawurl)));\n             return result::ok((~[], option::some(f)));\n         } else {\n             return result::ok((~[], option::none));\n         }\n     }\n-    let (q, r) = split_char_first(str::slice(rawurl, 1, \n+    let (q, r) = split_char_first(str::slice(rawurl, 1,\n                                              str::len(rawurl)), '#');\n-    let f = if str::len(r) != 0 { \n+    let f = if str::len(r) != 0 {\n         option::some(decode_component(r)) } else { option::none };\n     return result::ok((query_from_str(q), f));\n }\n@@ -606,7 +609,7 @@ fn from_str(rawurl: ~str) -> result::result<url, ~str> {\n     let mut pth = get_path(rest, has_authority);\n     if result::is_err(pth) {\n         return result::err(copy *result::get_err(pth));\n-    } \n+    }\n     let (path, rest) = result::unwrap(pth);\n \n     // query and fragment\n@@ -616,7 +619,7 @@ fn from_str(rawurl: ~str) -> result::result<url, ~str> {\n     }\n     let (query, fragment) = result::unwrap(qry);\n \n-    return result::ok(url(scheme, userinfo, host, \n+    return result::ok(url(scheme, userinfo, host,\n                        port, path, query, fragment));\n }\n \n@@ -647,7 +650,8 @@ fn to_str(url: url) -> ~str {\n         str::concat(~[~\"?\", query_to_str(url.query)])\n     };\n     let fragment = if option::is_some(url.fragment) {\n-        str::concat(~[~\"#\", encode_component(option::unwrap(copy url.fragment))])\n+        str::concat(~[~\"#\", encode_component(\n+            option::unwrap(copy url.fragment))])\n     } else {\n         ~\"\"\n     };\n@@ -674,7 +678,7 @@ mod tests {\n         let (u,v) = split_char_first(~\"hello, sweet world\", ',');\n         assert u == ~\"hello\";\n         assert v == ~\" sweet world\";\n-        \n+\n         let (u,v) = split_char_first(~\"hello sweet world\", ',');\n         assert u == ~\"hello sweet world\";\n         assert v == ~\"\";\n@@ -684,7 +688,7 @@ mod tests {\n     fn test_get_authority() {\n         let (u, h, p, r) = result::unwrap(get_authority(\n             ~\"//user:pass@rust-lang.org/something\"));\n-        assert u == option::some({user: ~\"user\", \n+        assert u == option::some({user: ~\"user\",\n                                   pass: option::some(~\"pass\")});\n         assert h == ~\"rust-lang.org\";\n         assert option::is_none(p);\n@@ -696,7 +700,7 @@ mod tests {\n         assert h == ~\"rust-lang.org\";\n         assert p == option::some(~\"8000\");\n         assert r == ~\"?something\";\n-        \n+\n         let (u, h, p, r) = result::unwrap(get_authority(\n             ~\"//rust-lang.org#blah\"));\n         assert option::is_none(u);\n@@ -718,50 +722,57 @@ mod tests {\n             ~\"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"));\n         assert u == option::some({user: ~\"us\", pass : option::some(~\"p\")});\n         assert h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\";\n-        assert p == option::some(~\"8000\");        \n+        assert p == option::some(~\"8000\");\n \n-        // invalid authorities; \n-        assert result::is_err(get_authority(~\"//user:pass@rust-lang:something\"));        \n-        assert result::is_err(get_authority(~\"//user@rust-lang:something:/path\"));\n+        // invalid authorities;\n+        assert result::is_err(get_authority(\n+            ~\"//user:pass@rust-lang:something\"));\n+        assert result::is_err(get_authority(\n+            ~\"//user@rust-lang:something:/path\"));\n         assert result::is_err(get_authority(\n             ~\"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:800a\"));\n         assert result::is_err(get_authority(\n             ~\"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000:00\"));\n \n         // these parse as empty, because they don't start with '//'\n-        let (_, h, _, _) = result::unwrap(get_authority(~\"user:pass@rust-lang\"));\n+        let (_, h, _, _) = result::unwrap(\n+            get_authority(~\"user:pass@rust-lang\"));\n         assert h == ~\"\";\n-        let (_, h, _, _) = result::unwrap(get_authority(~\"rust-lang.org\"));\n+        let (_, h, _, _) = result::unwrap(\n+            get_authority(~\"rust-lang.org\"));\n         assert h == ~\"\";\n \n     }\n \n     #[test]\n     fn test_get_path() {\n-        let (p, r) = result::unwrap(get_path(~\"/something+%20orother\", true));\n+        let (p, r) = result::unwrap(get_path(\n+            ~\"/something+%20orother\", true));\n         assert p == ~\"/something+ orother\";\n         assert r == ~\"\";\n-        let (p, r) = result::unwrap(get_path(~\"test@email.com#fragment\", false));\n+        let (p, r) = result::unwrap(get_path(\n+            ~\"test@email.com#fragment\", false));\n         assert p == ~\"test@email.com\";\n         assert r == ~\"#fragment\";\n         let (p, r) = result::unwrap(get_path(~\"/gen/:addr=?q=v\", false));\n         assert p == ~\"/gen/:addr=\";\n         assert r == ~\"?q=v\";\n-        \n+\n         //failure cases\n         assert result::is_err(get_path(~\"something?q\", true));\n-        \n+\n     }\n \n     #[test]\n     fn test_url_parse() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n-        \n+\n         let up = from_str(url);\n         let u = result::unwrap(up);\n         assert u.scheme == ~\"http\";\n         assert option::unwrap(copy u.user).user == ~\"user\";\n-        assert option::unwrap(copy option::unwrap(copy u.user).pass) == ~\"pass\";\n+        assert option::unwrap(copy option::unwrap(copy u.user).pass)\n+            == ~\"pass\";\n         assert u.host == ~\"rust-lang.org\";\n         assert u.path == ~\"/doc\";\n         assert u.query.find(|kv| kv.first() == ~\"s\").get().second() == ~\"v\";"}]}