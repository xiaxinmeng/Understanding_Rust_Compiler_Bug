{"sha": "7206fec9c3fdfdd736d6d8986c5f7c43354488e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMDZmZWM5YzNmZGZkZDczNmQ2ZDg5ODZjNWY3YzQzMzU0NDg4ZTI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-10T09:29:13Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-10T09:29:13Z"}, "message": "Rollup merge of #23105 - alexcrichton:rand-wrapping, r=brson\n\n There was a buildbot failure recently of an arithmetic overflow in the isaac\nmodule of the rand crate, so I've imported the isaac implementation from\nout-of-tree which makes somewhat more liberal usage of the wrapping primitives.\nHopefull this quelches any future overflow!", "tree": {"sha": "87726ae2ae50b347e3a96db8cf817ef8b243f056", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87726ae2ae50b347e3a96db8cf817ef8b243f056"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7206fec9c3fdfdd736d6d8986c5f7c43354488e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7206fec9c3fdfdd736d6d8986c5f7c43354488e2", "html_url": "https://github.com/rust-lang/rust/commit/7206fec9c3fdfdd736d6d8986c5f7c43354488e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7206fec9c3fdfdd736d6d8986c5f7c43354488e2/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a49b6f8bd30848fe07f6e006d43f674aa7d64c01", "url": "https://api.github.com/repos/rust-lang/rust/commits/a49b6f8bd30848fe07f6e006d43f674aa7d64c01", "html_url": "https://github.com/rust-lang/rust/commit/a49b6f8bd30848fe07f6e006d43f674aa7d64c01"}, {"sha": "ee7a72c608dcae1b66d75f43378dfa1bee36f2d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee7a72c608dcae1b66d75f43378dfa1bee36f2d2", "html_url": "https://github.com/rust-lang/rust/commit/ee7a72c608dcae1b66d75f43378dfa1bee36f2d2"}], "stats": {"total": 246, "additions": 125, "deletions": 121}, "files": [{"sha": "7ea62b7fd3f413b62d35b1d365872e645d3cc4ee", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 125, "deletions": 121, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/7206fec9c3fdfdd736d6d8986c5f7c43354488e2/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7206fec9c3fdfdd736d6d8986c5f7c43354488e2/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=7206fec9c3fdfdd736d6d8986c5f7c43354488e2", "patch": "@@ -10,16 +10,21 @@\n \n //! The ISAAC random number generator.\n \n+#![allow(non_camel_case_types)]\n+\n use core::prelude::*;\n use core::slice;\n use core::iter::{range_step, repeat};\n-use core::num::wrapping::Wrapping;\n+use core::num::wrapping::Wrapping as w;\n \n use {Rng, SeedableRng, Rand};\n \n-const RAND_SIZE_LEN: u32 = 8;\n-const RAND_SIZE: u32 = 1 << (RAND_SIZE_LEN as uint);\n-const RAND_SIZE_UINT: uint = 1 << (RAND_SIZE_LEN as uint);\n+type w32 = w<u32>;\n+type w64 = w<u64>;\n+\n+const RAND_SIZE_LEN: usize = 8;\n+const RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n+const RAND_SIZE_USIZE: usize = 1 << RAND_SIZE_LEN;\n \n /// A random number generator that uses the ISAAC algorithm[1].\n ///\n@@ -33,18 +38,18 @@ const RAND_SIZE_UINT: uint = 1 << (RAND_SIZE_LEN as uint);\n #[derive(Copy)]\n pub struct IsaacRng {\n     cnt: u32,\n-    rsl: [u32; RAND_SIZE_UINT],\n-    mem: [u32; RAND_SIZE_UINT],\n-    a: u32,\n-    b: u32,\n-    c: u32\n+    rsl: [w32; RAND_SIZE_USIZE],\n+    mem: [w32; RAND_SIZE_USIZE],\n+    a: w32,\n+    b: w32,\n+    c: w32,\n }\n \n static EMPTY: IsaacRng = IsaacRng {\n     cnt: 0,\n-    rsl: [0; RAND_SIZE_UINT],\n-    mem: [0; RAND_SIZE_UINT],\n-    a: 0, b: 0, c: 0\n+    rsl: [w(0); RAND_SIZE_USIZE],\n+    mem: [w(0); RAND_SIZE_USIZE],\n+    a: w(0), b: w(0), c: w(0),\n };\n \n impl IsaacRng {\n@@ -61,7 +66,7 @@ impl IsaacRng {\n     /// of `rsl` as a seed, otherwise construct one algorithmically (not\n     /// randomly).\n     fn init(&mut self, use_rsl: bool) {\n-        let mut a = Wrapping(0x9e3779b9);\n+        let mut a = w(0x9e3779b9);\n         let mut b = a;\n         let mut c = a;\n         let mut d = a;\n@@ -90,29 +95,29 @@ impl IsaacRng {\n         if use_rsl {\n             macro_rules! memloop {\n                 ($arr:expr) => {{\n-                    for i in range_step(0, RAND_SIZE as uint, 8) {\n-                        a=a+Wrapping($arr[i  ]); b=b+Wrapping($arr[i+1]);\n-                        c=c+Wrapping($arr[i+2]); d=d+Wrapping($arr[i+3]);\n-                        e=e+Wrapping($arr[i+4]); f=f+Wrapping($arr[i+5]);\n-                        g=g+Wrapping($arr[i+6]); h=h+Wrapping($arr[i+7]);\n+                    for i in range_step(0, RAND_SIZE_USIZE, 8) {\n+                        a=a+$arr[i  ]; b=b+$arr[i+1];\n+                        c=c+$arr[i+2]; d=d+$arr[i+3];\n+                        e=e+$arr[i+4]; f=f+$arr[i+5];\n+                        g=g+$arr[i+6]; h=h+$arr[i+7];\n                         mix!();\n-                        self.mem[i  ]=a.0; self.mem[i+1]=b.0;\n-                        self.mem[i+2]=c.0; self.mem[i+3]=d.0;\n-                        self.mem[i+4]=e.0; self.mem[i+5]=f.0;\n-                        self.mem[i+6]=g.0; self.mem[i+7]=h.0;\n+                        self.mem[i  ]=a; self.mem[i+1]=b;\n+                        self.mem[i+2]=c; self.mem[i+3]=d;\n+                        self.mem[i+4]=e; self.mem[i+5]=f;\n+                        self.mem[i+6]=g; self.mem[i+7]=h;\n                     }\n                 }}\n             }\n \n             memloop!(self.rsl);\n             memloop!(self.mem);\n         } else {\n-            for i in range_step(0, RAND_SIZE as uint, 8) {\n+            for i in range_step(0, RAND_SIZE_USIZE, 8) {\n                 mix!();\n-                self.mem[i  ]=a.0; self.mem[i+1]=b.0;\n-                self.mem[i+2]=c.0; self.mem[i+3]=d.0;\n-                self.mem[i+4]=e.0; self.mem[i+5]=f.0;\n-                self.mem[i+6]=g.0; self.mem[i+7]=h.0;\n+                self.mem[i  ]=a; self.mem[i+1]=b;\n+                self.mem[i+2]=c; self.mem[i+3]=d;\n+                self.mem[i+4]=e; self.mem[i+5]=f;\n+                self.mem[i+6]=g; self.mem[i+7]=h;\n             }\n         }\n \n@@ -123,47 +128,46 @@ impl IsaacRng {\n     #[inline]\n     #[allow(unsigned_negation)]\n     fn isaac(&mut self) {\n-        self.c += 1;\n+        self.c = self.c + w(1);\n         // abbreviations\n         let mut a = self.a;\n         let mut b = self.b + self.c;\n \n-        const MIDPOINT: uint = (RAND_SIZE / 2) as uint;\n+        const MIDPOINT: usize = RAND_SIZE_USIZE / 2;\n \n         macro_rules! ind {\n-            ($x:expr) => (Wrapping( self.mem[(($x >> 2) as uint &\n-                                              ((RAND_SIZE - 1) as uint))] ))\n+            ($x:expr) => ( self.mem[($x >> 2).0 as usize & (RAND_SIZE_USIZE - 1)] )\n         }\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n-        for &(mr_offset, m2_offset) in &r {\n+        for &(mr_offset, m2_offset) in r.iter() {\n \n             macro_rules! rngstepp {\n                 ($j:expr, $shift:expr) => {{\n                     let base = $j;\n-                    let mix = a << $shift as uint;\n+                    let mix = a << $shift;\n \n                     let x = self.mem[base  + mr_offset];\n-                    a = (Wrapping(a ^ mix) + Wrapping(self.mem[base + m2_offset])).0;\n-                    let y = ind!(x) + Wrapping(a) + Wrapping(b);\n-                    self.mem[base + mr_offset] = y.0;\n+                    a = (a ^ mix) + self.mem[base + m2_offset];\n+                    let y = ind!(x) + a + b;\n+                    self.mem[base + mr_offset] = y;\n \n-                    b = (ind!(y.0 >> RAND_SIZE_LEN as uint) + Wrapping(x)).0;\n+                    b = ind!(y >> RAND_SIZE_LEN) + x;\n                     self.rsl[base + mr_offset] = b;\n                 }}\n             }\n \n             macro_rules! rngstepn {\n                 ($j:expr, $shift:expr) => {{\n                     let base = $j;\n-                    let mix = a >> $shift as uint;\n+                    let mix = a >> $shift;\n \n                     let x = self.mem[base  + mr_offset];\n-                    a = (Wrapping(a ^ mix) + Wrapping(self.mem[base + m2_offset])).0;\n-                    let y = ind!(x) + Wrapping(a) + Wrapping(b);\n-                    self.mem[base + mr_offset] = y.0;\n+                    a = (a ^ mix) + self.mem[base + m2_offset];\n+                    let y = ind!(x) + a + b;\n+                    self.mem[base + mr_offset] = y;\n \n-                    b = (ind!(y.0 >> RAND_SIZE_LEN as uint) + Wrapping(x)).0;\n+                    b = ind!(y >> RAND_SIZE_LEN) + x;\n                     self.rsl[base + mr_offset] = b;\n                 }}\n             }\n@@ -209,7 +213,7 @@ impl Rng for IsaacRng {\n         // (the % is cheaply telling the optimiser that we're always\n         // in bounds, without unsafe. NB. this is a power of two, so\n         // it optimises to a bitwise mask).\n-        self.rsl[(self.cnt % RAND_SIZE) as uint]\n+        self.rsl[(self.cnt % RAND_SIZE) as usize].0\n     }\n }\n \n@@ -220,12 +224,12 @@ impl<'a> SeedableRng<&'a [u32]> for IsaacRng {\n         let seed_iter = seed.iter().cloned().chain(repeat(0));\n \n         for (rsl_elem, seed_elem) in self.rsl.iter_mut().zip(seed_iter) {\n-            *rsl_elem = seed_elem;\n+            *rsl_elem = w(seed_elem);\n         }\n         self.cnt = 0;\n-        self.a = 0;\n-        self.b = 0;\n-        self.c = 0;\n+        self.a = w(0);\n+        self.b = w(0);\n+        self.c = w(0);\n \n         self.init(true);\n     }\n@@ -248,21 +252,21 @@ impl Rand for IsaacRng {\n         unsafe {\n             let ptr = ret.rsl.as_mut_ptr() as *mut u8;\n \n-            let slice = slice::from_raw_parts_mut(ptr, (RAND_SIZE * 4) as uint);\n+            let slice = slice::from_raw_parts_mut(ptr, RAND_SIZE_USIZE * 4);\n             other.fill_bytes(slice);\n         }\n         ret.cnt = 0;\n-        ret.a = 0;\n-        ret.b = 0;\n-        ret.c = 0;\n+        ret.a = w(0);\n+        ret.b = w(0);\n+        ret.c = w(0);\n \n         ret.init(true);\n         return ret;\n     }\n }\n \n-const RAND_SIZE_64_LEN: uint = 8;\n-const RAND_SIZE_64: uint = 1 << RAND_SIZE_64_LEN;\n+const RAND_SIZE_64_LEN: usize = 8;\n+const RAND_SIZE_64: usize = 1 << RAND_SIZE_64_LEN;\n \n /// A random number generator that uses ISAAC-64[1], the 64-bit\n /// variant of the ISAAC algorithm.\n@@ -276,19 +280,19 @@ const RAND_SIZE_64: uint = 1 << RAND_SIZE_64_LEN;\n /// generator*](http://www.burtleburtle.net/bob/rand/isaacafa.html)\n #[derive(Copy)]\n pub struct Isaac64Rng {\n-    cnt: uint,\n-    rsl: [u64; RAND_SIZE_64],\n-    mem: [u64; RAND_SIZE_64],\n-    a: u64,\n-    b: u64,\n-    c: u64,\n+    cnt: usize,\n+    rsl: [w64; RAND_SIZE_64],\n+    mem: [w64; RAND_SIZE_64],\n+    a: w64,\n+    b: w64,\n+    c: w64,\n }\n \n static EMPTY_64: Isaac64Rng = Isaac64Rng {\n     cnt: 0,\n-    rsl: [0; RAND_SIZE_64],\n-    mem: [0; RAND_SIZE_64],\n-    a: 0, b: 0, c: 0,\n+    rsl: [w(0); RAND_SIZE_64],\n+    mem: [w(0); RAND_SIZE_64],\n+    a: w(0), b: w(0), c: w(0),\n };\n \n impl Isaac64Rng {\n@@ -306,22 +310,22 @@ impl Isaac64Rng {\n     fn init(&mut self, use_rsl: bool) {\n         macro_rules! init {\n             ($var:ident) => (\n-                let mut $var = Wrapping(0x9e3779b97f4a7c13);\n+                let mut $var = w(0x9e3779b97f4a7c13);\n             )\n         }\n         init!(a); init!(b); init!(c); init!(d);\n         init!(e); init!(f); init!(g); init!(h);\n \n         macro_rules! mix {\n             () => {{\n-                a=a-e; f=f^h>>9;  h=h+a;\n-                b=b-f; g=g^a<<9;  a=a+b;\n-                c=c-g; h=h^b>>23; b=b+c;\n-                d=d-h; a=a^c<<15; c=c+d;\n-                e=e-a; b=b^d>>14; d=d+e;\n-                f=f-b; c=c^e<<20; e=e+f;\n-                g=g-c; d=d^f>>17; f=f+g;\n-                h=h-d; e=e^g<<14; g=g+h;\n+                a=a-e; f=f^(h>>9);  h=h+a;\n+                b=b-f; g=g^(a<<9);  a=a+b;\n+                c=c-g; h=h^(b>>23); b=b+c;\n+                d=d-h; a=a^(c<<15); c=c+d;\n+                e=e-a; b=b^(d>>14); d=d+e;\n+                f=f-b; c=c^(e<<20); e=e+f;\n+                g=g-c; d=d^(f>>17); f=f+g;\n+                h=h-d; e=e^(g<<14); g=g+h;\n             }}\n         }\n \n@@ -333,15 +337,15 @@ impl Isaac64Rng {\n             macro_rules! memloop {\n                 ($arr:expr) => {{\n                     for i in (0..RAND_SIZE_64 / 8).map(|i| i * 8) {\n-                        a=a+Wrapping($arr[i  ]); b=b+Wrapping($arr[i+1]);\n-                        c=c+Wrapping($arr[i+2]); d=d+Wrapping($arr[i+3]);\n-                        e=e+Wrapping($arr[i+4]); f=f+Wrapping($arr[i+5]);\n-                        g=g+Wrapping($arr[i+6]); h=h+Wrapping($arr[i+7]);\n+                        a=a+$arr[i  ]; b=b+$arr[i+1];\n+                        c=c+$arr[i+2]; d=d+$arr[i+3];\n+                        e=e+$arr[i+4]; f=f+$arr[i+5];\n+                        g=g+$arr[i+6]; h=h+$arr[i+7];\n                         mix!();\n-                        self.mem[i  ]=a.0; self.mem[i+1]=b.0;\n-                        self.mem[i+2]=c.0; self.mem[i+3]=d.0;\n-                        self.mem[i+4]=e.0; self.mem[i+5]=f.0;\n-                        self.mem[i+6]=g.0; self.mem[i+7]=h.0;\n+                        self.mem[i  ]=a; self.mem[i+1]=b;\n+                        self.mem[i+2]=c; self.mem[i+3]=d;\n+                        self.mem[i+4]=e; self.mem[i+5]=f;\n+                        self.mem[i+6]=g; self.mem[i+7]=h;\n                     }\n                 }}\n             }\n@@ -351,10 +355,10 @@ impl Isaac64Rng {\n         } else {\n             for i in (0..RAND_SIZE_64 / 8).map(|i| i * 8) {\n                 mix!();\n-                self.mem[i  ]=a.0; self.mem[i+1]=b.0;\n-                self.mem[i+2]=c.0; self.mem[i+3]=d.0;\n-                self.mem[i+4]=e.0; self.mem[i+5]=f.0;\n-                self.mem[i+6]=g.0; self.mem[i+7]=h.0;\n+                self.mem[i  ]=a; self.mem[i+1]=b;\n+                self.mem[i+2]=c; self.mem[i+3]=d;\n+                self.mem[i+4]=e; self.mem[i+5]=f;\n+                self.mem[i+6]=g; self.mem[i+7]=h;\n             }\n         }\n \n@@ -363,53 +367,53 @@ impl Isaac64Rng {\n \n     /// Refills the output buffer (`self.rsl`)\n     fn isaac64(&mut self) {\n-        self.c += 1;\n+        self.c = self.c + w(1);\n         // abbreviations\n-        let mut a = Wrapping(self.a);\n-        let mut b = Wrapping(self.b) + Wrapping(self.c);\n-        const MIDPOINT: uint =  RAND_SIZE_64 / 2;\n-        const MP_VEC: [(uint, uint); 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n+        let mut a = self.a;\n+        let mut b = self.b + self.c;\n+        const MIDPOINT: usize =  RAND_SIZE_64 / 2;\n+        const MP_VEC: [(usize, usize); 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n         macro_rules! ind {\n             ($x:expr) => {\n-                *self.mem.get_unchecked(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n+                *self.mem.get_unchecked((($x >> 3).0 as usize) & (RAND_SIZE_64 - 1))\n             }\n         }\n \n-        for &(mr_offset, m2_offset) in &MP_VEC {\n+        for &(mr_offset, m2_offset) in MP_VEC.iter() {\n             for base in (0..MIDPOINT / 4).map(|i| i * 4) {\n \n                 macro_rules! rngstepp {\n                     ($j:expr, $shift:expr) => {{\n                         let base = base + $j;\n-                        let mix = a ^ (a << $shift as uint);\n+                        let mix = a ^ (a << $shift);\n                         let mix = if $j == 0 {!mix} else {mix};\n \n                         unsafe {\n-                            let x = Wrapping(*self.mem.get_unchecked(base + mr_offset));\n-                            a = mix + Wrapping(*self.mem.get_unchecked(base + m2_offset));\n-                            let y = Wrapping(ind!(x.0)) + a + b;\n-                            *self.mem.get_unchecked_mut(base + mr_offset) = y.0;\n+                            let x = *self.mem.get_unchecked(base + mr_offset);\n+                            a = mix + *self.mem.get_unchecked(base + m2_offset);\n+                            let y = ind!(x) + a + b;\n+                            *self.mem.get_unchecked_mut(base + mr_offset) = y;\n \n-                            b = Wrapping(ind!(y.0 >> RAND_SIZE_64_LEN)) + x;\n-                            *self.rsl.get_unchecked_mut(base + mr_offset) = b.0;\n+                            b = ind!(y >> RAND_SIZE_64_LEN) + x;\n+                            *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n                         }\n                     }}\n                 }\n \n                 macro_rules! rngstepn {\n                     ($j:expr, $shift:expr) => {{\n                         let base = base + $j;\n-                        let mix = a ^ (a >> $shift as uint);\n+                        let mix = a ^ (a >> $shift);\n                         let mix = if $j == 0 {!mix} else {mix};\n \n                         unsafe {\n-                            let x = Wrapping(*self.mem.get_unchecked(base + mr_offset));\n-                            a = mix + Wrapping(*self.mem.get_unchecked(base + m2_offset));\n-                            let y = Wrapping(ind!(x.0)) + a + b;\n-                            *self.mem.get_unchecked_mut(base + mr_offset) = y.0;\n+                            let x = *self.mem.get_unchecked(base + mr_offset);\n+                            a = mix + *self.mem.get_unchecked(base + m2_offset);\n+                            let y = ind!(x) + a + b;\n+                            *self.mem.get_unchecked_mut(base + mr_offset) = y;\n \n-                            b = Wrapping(ind!(y.0 >> RAND_SIZE_64_LEN)) + x;\n-                            *self.rsl.get_unchecked_mut(base + mr_offset) = b.0;\n+                            b = ind!(y >> RAND_SIZE_64_LEN) + x;\n+                            *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n                         }\n                     }}\n                 }\n@@ -421,8 +425,8 @@ impl Isaac64Rng {\n             }\n         }\n \n-        self.a = a.0;\n-        self.b = b.0;\n+        self.a = a;\n+        self.b = b;\n         self.cnt = RAND_SIZE_64;\n     }\n }\n@@ -452,7 +456,7 @@ impl Rng for Isaac64Rng {\n         // See corresponding location in IsaacRng.next_u32 for\n         // explanation.\n         debug_assert!(self.cnt < RAND_SIZE_64);\n-        self.rsl[(self.cnt % RAND_SIZE_64) as uint]\n+        self.rsl[(self.cnt % RAND_SIZE_64) as usize].0\n     }\n }\n \n@@ -463,12 +467,12 @@ impl<'a> SeedableRng<&'a [u64]> for Isaac64Rng {\n         let seed_iter = seed.iter().cloned().chain(repeat(0));\n \n         for (rsl_elem, seed_elem) in self.rsl.iter_mut().zip(seed_iter) {\n-            *rsl_elem = seed_elem;\n+            *rsl_elem = w(seed_elem);\n         }\n         self.cnt = 0;\n-        self.a = 0;\n-        self.b = 0;\n-        self.c = 0;\n+        self.a = w(0);\n+        self.b = w(0);\n+        self.c = w(0);\n \n         self.init(true);\n     }\n@@ -491,13 +495,13 @@ impl Rand for Isaac64Rng {\n         unsafe {\n             let ptr = ret.rsl.as_mut_ptr() as *mut u8;\n \n-            let slice = slice::from_raw_parts_mut(ptr, (RAND_SIZE_64 * 8) as uint);\n+            let slice = slice::from_raw_parts_mut(ptr, RAND_SIZE_64 * 8);\n             other.fill_bytes(slice);\n         }\n         ret.cnt = 0;\n-        ret.a = 0;\n-        ret.b = 0;\n-        ret.c = 0;\n+        ret.a = w(0);\n+        ret.b = w(0);\n+        ret.c = w(0);\n \n         ret.init(true);\n         return ret;\n@@ -516,16 +520,16 @@ mod test {\n     #[test]\n     fn test_rng_32_rand_seeded() {\n         let s = ::test::rng().gen_iter::<u32>().take(256).collect::<Vec<u32>>();\n-        let mut ra: IsaacRng = SeedableRng::from_seed(&*s);\n-        let mut rb: IsaacRng = SeedableRng::from_seed(&*s);\n+        let mut ra: IsaacRng = SeedableRng::from_seed(&s[..]);\n+        let mut rb: IsaacRng = SeedableRng::from_seed(&s[..]);\n         assert!(order::equals(ra.gen_ascii_chars().take(100),\n                               rb.gen_ascii_chars().take(100)));\n     }\n     #[test]\n     fn test_rng_64_rand_seeded() {\n         let s = ::test::rng().gen_iter::<u64>().take(256).collect::<Vec<u64>>();\n-        let mut ra: Isaac64Rng = SeedableRng::from_seed(&*s);\n-        let mut rb: Isaac64Rng = SeedableRng::from_seed(&*s);\n+        let mut ra: Isaac64Rng = SeedableRng::from_seed(&s[..]);\n+        let mut rb: Isaac64Rng = SeedableRng::from_seed(&s[..]);\n         assert!(order::equals(ra.gen_ascii_chars().take(100),\n                               rb.gen_ascii_chars().take(100)));\n     }\n@@ -550,7 +554,7 @@ mod test {\n     #[test]\n     fn test_rng_32_reseed() {\n         let s = ::test::rng().gen_iter::<u32>().take(256).collect::<Vec<u32>>();\n-        let mut r: IsaacRng = SeedableRng::from_seed(&*s);\n+        let mut r: IsaacRng = SeedableRng::from_seed(&s[..]);\n         let string1: String = r.gen_ascii_chars().take(100).collect();\n \n         r.reseed(&s);\n@@ -561,7 +565,7 @@ mod test {\n     #[test]\n     fn test_rng_64_reseed() {\n         let s = ::test::rng().gen_iter::<u64>().take(256).collect::<Vec<u64>>();\n-        let mut r: Isaac64Rng = SeedableRng::from_seed(&*s);\n+        let mut r: Isaac64Rng = SeedableRng::from_seed(&s[..]);\n         let string1: String = r.gen_ascii_chars().take(100).collect();\n \n         r.reseed(&s);"}]}