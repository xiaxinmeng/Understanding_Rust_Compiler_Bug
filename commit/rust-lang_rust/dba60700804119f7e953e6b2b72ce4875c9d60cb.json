{"sha": "dba60700804119f7e953e6b2b72ce4875c9d60cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYTYwNzAwODA0MTE5ZjdlOTUzZTZiMmI3MmNlNDg3NWM5ZDYwY2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-29T03:51:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-29T03:51:30Z"}, "message": "auto merge of #10117 : huonw/rust/dead-visits, r=sanxiyn\n\nUsed nowhere, and these are likely incorrect anyway: self needs to be\r\ndereferenced once more otherwise the method calls will be reusing the\r\ncurrent impl... bam! Infinite recursion.", "tree": {"sha": "305cf23c4db7df9f366cef8766134ed36fb18518", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/305cf23c4db7df9f366cef8766134ed36fb18518"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dba60700804119f7e953e6b2b72ce4875c9d60cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dba60700804119f7e953e6b2b72ce4875c9d60cb", "html_url": "https://github.com/rust-lang/rust/commit/dba60700804119f7e953e6b2b72ce4875c9d60cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dba60700804119f7e953e6b2b72ce4875c9d60cb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0222cda27d0a1a06e7f227dfb1f0f6f87d2e742", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0222cda27d0a1a06e7f227dfb1f0f6f87d2e742", "html_url": "https://github.com/rust-lang/rust/commit/c0222cda27d0a1a06e7f227dfb1f0f6f87d2e742"}, {"sha": "17b87d20304db1e8727754b7ef900dc3c986d878", "url": "https://api.github.com/repos/rust-lang/rust/commits/17b87d20304db1e8727754b7ef900dc3c986d878", "html_url": "https://github.com/rust-lang/rust/commit/17b87d20304db1e8727754b7ef900dc3c986d878"}], "stats": {"total": 196, "additions": 70, "deletions": 126}, "files": [{"sha": "575f8bc6278c7065fc48877dffe97808d763fb6a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 70, "deletions": 63, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/dba60700804119f7e953e6b2b72ce4875c9d60cb/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba60700804119f7e953e6b2b72ce4875c9d60cb/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=dba60700804119f7e953e6b2b72ce4875c9d60cb", "patch": "@@ -566,12 +566,11 @@ fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n             // oh dear heaven... this is going to include the enum names, as well....\n             // ... but that should be okay, as long as the new names are gensyms\n             // for the old ones.\n-            let idents = @mut ~[];\n-            let name_finder = new_name_finder(idents);\n+            let mut name_finder = new_name_finder(~[]);\n             name_finder.visit_pat(expanded_pat,());\n             // generate fresh names, push them to a new pending list\n             let new_pending_renames = @mut ~[];\n-            for ident in idents.iter() {\n+            for ident in name_finder.ident_accumulator.iter() {\n                 let new_name = fresh_name(ident);\n                 new_pending_renames.push((*ident,new_name));\n             }\n@@ -609,7 +608,7 @@ fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n // array (passed in to the traversal)\n #[deriving(Clone)]\n struct NewNameFinderContext {\n-    ident_accumulator: @mut ~[ast::Ident],\n+    ident_accumulator: ~[ast::Ident],\n }\n \n impl Visitor<()> for NewNameFinderContext {\n@@ -653,50 +652,13 @@ impl Visitor<()> for NewNameFinderContext {\n \n }\n \n-// a visitor that extracts the paths\n-// from a given thingy and puts them in a mutable\n-// array (passed in to the traversal)\n-#[deriving(Clone)]\n-struct NewPathExprFinderContext {\n-    path_accumulator: @mut ~[ast::Path],\n-}\n-\n-impl Visitor<()> for NewPathExprFinderContext {\n-\n-    fn visit_expr(&mut self, expr: @ast::Expr, _: ()) {\n-        match *expr {\n-            ast::Expr{id:_,span:_,node:ast::ExprPath(ref p)} => {\n-                self.path_accumulator.push(p.clone());\n-                // not calling visit_path, should be fine.\n-            }\n-            _ => visit::walk_expr(self,expr,())\n-        }\n-    }\n-\n-    fn visit_ty(&mut self, typ: &ast::Ty, _: ()) {\n-        visit::walk_ty(self, typ, ())\n-    }\n-\n-}\n-\n // return a visitor that extracts the pat_ident paths\n // from a given thingy and puts them in a mutable\n // array (passed in to the traversal)\n-pub fn new_name_finder(idents: @mut ~[ast::Ident]) -> @mut Visitor<()> {\n-    let context = @mut NewNameFinderContext {\n+pub fn new_name_finder(idents: ~[ast::Ident]) -> NewNameFinderContext {\n+    NewNameFinderContext {\n         ident_accumulator: idents,\n-    };\n-    context as @mut Visitor<()>\n-}\n-\n-// return a visitor that extracts the paths\n-// from a given pattern and puts them in a mutable\n-// array (passed in to the traversal)\n-pub fn new_path_finder(paths: @mut ~[ast::Path]) -> @mut Visitor<()> {\n-    let context = @mut NewPathExprFinderContext {\n-        path_accumulator: paths,\n-    };\n-    context as @mut Visitor<()>\n+    }\n }\n \n // expand a block. pushes a new exts_frame, then calls expand_block_elts\n@@ -1371,6 +1333,42 @@ mod test {\n     use util::parser_testing::{string_to_crate, string_to_crate_and_sess};\n     use util::parser_testing::{string_to_pat, string_to_tts, strs_to_idents};\n     use visit;\n+    use visit::Visitor;\n+\n+    // a visitor that extracts the paths\n+    // from a given thingy and puts them in a mutable\n+    // array (passed in to the traversal)\n+    #[deriving(Clone)]\n+    struct NewPathExprFinderContext {\n+        path_accumulator: ~[ast::Path],\n+    }\n+\n+    impl Visitor<()> for NewPathExprFinderContext {\n+\n+        fn visit_expr(&mut self, expr: @ast::Expr, _: ()) {\n+            match *expr {\n+                ast::Expr{id:_,span:_,node:ast::ExprPath(ref p)} => {\n+                    self.path_accumulator.push(p.clone());\n+                    // not calling visit_path, should be fine.\n+                }\n+                _ => visit::walk_expr(self,expr,())\n+            }\n+        }\n+\n+        fn visit_ty(&mut self, typ: &ast::Ty, _: ()) {\n+            visit::walk_ty(self, typ, ())\n+        }\n+\n+    }\n+\n+    // return a visitor that extracts the paths\n+    // from a given pattern and puts them in a mutable\n+    // array (passed in to the traversal)\n+    pub fn new_path_finder(paths: ~[ast::Path]) -> NewPathExprFinderContext {\n+        NewPathExprFinderContext {\n+            path_accumulator: paths\n+        }\n+    }\n \n     // make sure that fail! is present\n     #[test] fn fail_exists_test () {\n@@ -1498,10 +1496,11 @@ mod test {\n         let renamer = new_rename_folder(ast::Ident{name:a_name,ctxt:EMPTY_CTXT},\n                                         a2_name);\n         let renamed_ast = renamer.fold_crate(item_ast.clone());\n-        let varrefs = @mut ~[];\n-        visit::walk_crate(&mut new_path_finder(varrefs), &renamed_ast, ());\n-        match varrefs {\n-            @[ast::Path{segments:[ref seg],_}] =>\n+        let mut path_finder = new_path_finder(~[]);\n+        visit::walk_crate(&mut path_finder, &renamed_ast, ());\n+\n+        match path_finder.path_accumulator {\n+            [ast::Path{segments:[ref seg],_}] =>\n                 assert_eq!(mtwt_resolve(seg.identifier),a2_name),\n             _ => assert_eq!(0,1)\n         }\n@@ -1513,10 +1512,10 @@ mod test {\n         let pending_renames = @mut ~[(ast::Ident::new(a_name),a2_name),\n                                      (ast::Ident{name:a_name,ctxt:ctxt2},a3_name)];\n         let double_renamed = renames_to_fold(pending_renames).fold_crate(item_ast);\n-        let varrefs = @mut ~[];\n-        visit::walk_crate(&mut new_path_finder(varrefs), &double_renamed, ());\n-        match varrefs {\n-            @[ast::Path{segments:[ref seg],_}] =>\n+        let mut path_finder = new_path_finder(~[]);\n+        visit::walk_crate(&mut path_finder, &double_renamed, ());\n+        match path_finder.path_accumulator {\n+            [ast::Path{segments:[ref seg],_}] =>\n                 assert_eq!(mtwt_resolve(seg.identifier),a3_name),\n             _ => assert_eq!(0,1)\n         }\n@@ -1623,11 +1622,15 @@ mod test {\n         };\n         let cr = expand_crate_str(teststr.to_managed());\n         // find the bindings:\n-        let bindings = @mut ~[];\n-        visit::walk_crate(&mut new_name_finder(bindings),&cr,());\n+        let mut name_finder = new_name_finder(~[]);\n+        visit::walk_crate(&mut name_finder,&cr,());\n+        let bindings = name_finder.ident_accumulator;\n+\n         // find the varrefs:\n-        let varrefs = @mut ~[];\n-        visit::walk_crate(&mut new_path_finder(varrefs),&cr,());\n+        let mut path_finder = new_path_finder(~[]);\n+        visit::walk_crate(&mut path_finder,&cr,());\n+        let varrefs = path_finder.path_accumulator;\n+\n         // must be one check clause for each binding:\n         assert_eq!(bindings.len(),bound_connections.len());\n         for (binding_idx,shouldmatch) in bound_connections.iter().enumerate() {\n@@ -1686,8 +1689,10 @@ foo_module!()\n \";\n         let cr = expand_crate_str(crate_str);\n         // find the xx binding\n-        let bindings = @mut ~[];\n-        visit::walk_crate(&mut new_name_finder(bindings), &cr, ());\n+        let mut name_finder = new_name_finder(~[]);\n+        visit::walk_crate(&mut name_finder, &cr, ());\n+        let bindings = name_finder.ident_accumulator;\n+\n         let cxbinds : ~[&ast::Ident] =\n             bindings.iter().filter(|b|{@\"xx\" == (ident_to_str(*b))}).collect();\n         let cxbind = match cxbinds {\n@@ -1696,8 +1701,10 @@ foo_module!()\n         };\n         let resolved_binding = mtwt_resolve(*cxbind);\n         // find all the xx varrefs:\n-        let varrefs = @mut ~[];\n-        visit::walk_crate(&mut new_path_finder(varrefs), &cr, ());\n+        let mut path_finder = new_path_finder(~[]);\n+        visit::walk_crate(&mut path_finder, &cr, ());\n+        let varrefs = path_finder.path_accumulator;\n+\n         // the xx binding should bind all of the xx varrefs:\n         for (idx,v) in varrefs.iter().filter(|p|{ p.segments.len() == 1\n                                           && (@\"xx\" == (ident_to_str(&p.segments[0].identifier)))\n@@ -1723,10 +1730,10 @@ foo_module!()\n     #[test]\n     fn pat_idents(){\n         let pat = string_to_pat(@\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\");\n-        let idents = @mut ~[];\n-        let pat_idents = new_name_finder(idents);\n+        let mut pat_idents = new_name_finder(~[]);\n         pat_idents.visit_pat(pat, ());\n-        assert_eq!(idents, @mut strs_to_idents(~[\"a\",\"c\",\"b\",\"d\"]));\n+        assert_eq!(pat_idents.ident_accumulator,\n+                   strs_to_idents(~[\"a\",\"c\",\"b\",\"d\"]));\n     }\n \n }"}, {"sha": "e879d67fbf2f5c47e50cb1800c47e1befe758209", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/dba60700804119f7e953e6b2b72ce4875c9d60cb/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba60700804119f7e953e6b2b72ce4875c9d60cb/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=dba60700804119f7e953e6b2b72ce4875c9d60cb", "patch": "@@ -93,69 +93,6 @@ pub trait Visitor<E:Clone> {\n     fn visit_mac(&mut self, m:&mac, e:E) { walk_mac(self, m, e); }\n }\n \n-impl<E:Clone> Visitor<E> for @mut Visitor<E> {\n-    fn visit_mod(&mut self, a:&_mod, b:Span, c:NodeId, e:E) {\n-        (*self).visit_mod(a, b, c, e)\n-    }\n-    fn visit_view_item(&mut self, a:&view_item, e:E) {\n-        (*self).visit_view_item(a, e)\n-    }\n-    fn visit_foreign_item(&mut self, a:@foreign_item, e:E) {\n-        (*self).visit_foreign_item(a, e)\n-    }\n-    fn visit_item(&mut self, a:@item, e:E) {\n-        (*self).visit_item(a, e)\n-    }\n-    fn visit_local(&mut self, a:@Local, e:E) {\n-        (*self).visit_local(a, e)\n-    }\n-    fn visit_block(&mut self, a:&Block, e:E) {\n-        (*self).visit_block(a, e)\n-    }\n-    fn visit_stmt(&mut self, a:@Stmt, e:E) {\n-        (*self).visit_stmt(a, e)\n-    }\n-    fn visit_arm(&mut self, a:&Arm, e:E) {\n-        (*self).visit_arm(a, e)\n-    }\n-    fn visit_pat(&mut self, a:@Pat, e:E) {\n-        (*self).visit_pat(a, e)\n-    }\n-    fn visit_decl(&mut self, a:@Decl, e:E) {\n-        (*self).visit_decl(a, e)\n-    }\n-    fn visit_expr(&mut self, a:@Expr, e:E) {\n-        (*self).visit_expr(a, e)\n-    }\n-    fn visit_expr_post(&mut self, a:@Expr, e:E) {\n-        (*self).visit_expr_post(a, e)\n-    }\n-    fn visit_ty(&mut self, a:&Ty, e:E) {\n-        (*self).visit_ty(a, e)\n-    }\n-    fn visit_generics(&mut self, a:&Generics, e:E) {\n-        (*self).visit_generics(a, e)\n-    }\n-    fn visit_fn(&mut self, a:&fn_kind, b:&fn_decl, c:&Block, d:Span, f:NodeId, e:E) {\n-        (*self).visit_fn(a, b, c, d, f, e)\n-    }\n-    fn visit_ty_method(&mut self, a:&TypeMethod, e:E) {\n-        (*self).visit_ty_method(a, e)\n-    }\n-    fn visit_trait_method(&mut self, a:&trait_method, e:E) {\n-        (*self).visit_trait_method(a, e)\n-    }\n-    fn visit_struct_def(&mut self, a:@struct_def, b:Ident, c:&Generics, d:NodeId, e:E) {\n-        (*self).visit_struct_def(a, b, c, d, e)\n-    }\n-    fn visit_struct_field(&mut self, a:@struct_field, e:E) {\n-        (*self).visit_struct_field(a, e)\n-    }\n-    fn visit_mac(&mut self, macro:&mac, e:E) {\n-        (*self).visit_mac(macro, e);\n-    }\n-}\n-\n pub fn walk_crate<E:Clone, V:Visitor<E>>(visitor: &mut V, crate: &Crate, env: E) {\n     visitor.visit_mod(&crate.module, crate.span, CRATE_NODE_ID, env)\n }"}]}