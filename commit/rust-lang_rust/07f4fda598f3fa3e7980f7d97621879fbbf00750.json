{"sha": "07f4fda598f3fa3e7980f7d97621879fbbf00750", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ZjRmZGE1OThmM2ZhM2U3OTgwZjdkOTc2MjE4NzlmYmJmMDA3NTA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-17T16:01:33Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-18T11:36:18Z"}, "message": "syntax: use an index in CodeMap instead of Gc for ExpnInfo.", "tree": {"sha": "ed0c76fbf0a9428a73c73260b9035aed0323c313", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed0c76fbf0a9428a73c73260b9035aed0323c313"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07f4fda598f3fa3e7980f7d97621879fbbf00750", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07f4fda598f3fa3e7980f7d97621879fbbf00750", "html_url": "https://github.com/rust-lang/rust/commit/07f4fda598f3fa3e7980f7d97621879fbbf00750", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07f4fda598f3fa3e7980f7d97621879fbbf00750/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49dd8e8c366f492d3ba3d0d2fd9d943f92073a18", "url": "https://api.github.com/repos/rust-lang/rust/commits/49dd8e8c366f492d3ba3d0d2fd9d943f92073a18", "html_url": "https://github.com/rust-lang/rust/commit/49dd8e8c366f492d3ba3d0d2fd9d943f92073a18"}], "stats": {"total": 236, "additions": 123, "deletions": 113}, "files": [{"sha": "7fe044b0fc811d28c304814c11d080437df51c32", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=07f4fda598f3fa3e7980f7d97621879fbbf00750", "patch": "@@ -25,7 +25,6 @@ source code snippets, etc.\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::cell::RefCell;\n-use std::gc::Gc;\n use std::rc::Rc;\n \n pub trait Pos {\n@@ -93,10 +92,10 @@ pub struct Span {\n     pub hi: BytePos,\n     /// Information about where the macro came from, if this piece of\n     /// code was created by a macro expansion.\n-    pub expn_info: Option<Gc<ExpnInfo>>\n+    pub expn_id: ExpnId\n }\n \n-pub static DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_info: None };\n+pub static DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_id: NO_EXPANSION };\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Spanned<T> {\n@@ -140,17 +139,19 @@ pub fn dummy_spanned<T>(t: T) -> Spanned<T> {\n \n /* assuming that we're not in macro expansion */\n pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n-    Span {lo: lo, hi: hi, expn_info: None}\n+    Span {lo: lo, hi: hi, expn_id: NO_EXPANSION}\n }\n \n /// Return the span itself if it doesn't come from a macro expansion,\n /// otherwise return the call site span up to the `enclosing_sp` by\n /// following the `expn_info` chain.\n-pub fn original_sp(sp: Span, enclosing_sp: Span) -> Span {\n-    match (sp.expn_info, enclosing_sp.expn_info) {\n+pub fn original_sp(cm: &CodeMap, sp: Span, enclosing_sp: Span) -> Span {\n+    let call_site1 = cm.with_expn_info(sp.expn_id, |ei| ei.map(|ei| ei.call_site));\n+    let call_site2 = cm.with_expn_info(enclosing_sp.expn_id, |ei| ei.map(|ei| ei.call_site));\n+    match (call_site1, call_site2) {\n         (None, _) => sp,\n-        (Some(expn1), Some(expn2)) if expn1.call_site == expn2.call_site => sp,\n-        (Some(expn1), _) => original_sp(expn1.call_site, enclosing_sp),\n+        (Some(call_site1), Some(call_site2)) if call_site1 == call_site2 => sp,\n+        (Some(call_site1), _) => original_sp(cm, call_site1, enclosing_sp),\n     }\n }\n \n@@ -222,6 +223,11 @@ pub struct ExpnInfo {\n     pub callee: NameAndSpan\n }\n \n+#[deriving(PartialEq, Eq, Clone, Show, Hash)]\n+pub struct ExpnId(u32);\n+\n+pub static NO_EXPANSION: ExpnId = ExpnId(-1);\n+\n pub type FileName = String;\n \n pub struct FileLines {\n@@ -299,13 +305,15 @@ impl FileMap {\n }\n \n pub struct CodeMap {\n-    pub files: RefCell<Vec<Rc<FileMap>>>\n+    pub files: RefCell<Vec<Rc<FileMap>>>,\n+    expansions: RefCell<Vec<ExpnInfo>>\n }\n \n impl CodeMap {\n     pub fn new() -> CodeMap {\n         CodeMap {\n             files: RefCell::new(Vec::new()),\n+            expansions: RefCell::new(Vec::new()),\n         }\n     }\n \n@@ -527,6 +535,19 @@ impl CodeMap {\n             col: chpos - linechpos\n         }\n     }\n+\n+    pub fn record_expansion(&self, expn_info: ExpnInfo) -> ExpnId {\n+        let mut expansions = self.expansions.borrow_mut();\n+        expansions.push(expn_info);\n+        ExpnId(expansions.len().to_u32().expect(\"too many ExpnInfo's!\") - 1)\n+    }\n+\n+    pub fn with_expn_info<T>(&self, id: ExpnId, f: |Option<&ExpnInfo>| -> T) -> T {\n+        match id {\n+            NO_EXPANSION => f(None),\n+            ExpnId(i) => f(Some(&(*self.expansions.borrow())[i as uint]))\n+        }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "f33c768d647575607a821aad4a6dc364604558bc", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=07f4fda598f3fa3e7980f7d97621879fbbf00750", "patch": "@@ -389,7 +389,7 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n         // we want to tell compiletest/runtest to look at the last line of the\n         // span (since `custom_highlight_lines` displays an arrow to the end of\n         // the span)\n-        let span_end = Span { lo: sp.hi, hi: sp.hi, expn_info: sp.expn_info};\n+        let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n         let ses = cm.span_to_string(span_end);\n         try!(print_diagnostic(dst, ses.as_slice(), lvl, msg, code));\n         if rsp.is_full_span() {\n@@ -523,24 +523,24 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n                          cm: &codemap::CodeMap,\n                          sp: Span)\n                          -> io::IoResult<()> {\n-    for ei in sp.expn_info.iter() {\n-        let ss = ei.callee\n-                   .span\n-                   .as_ref()\n-                   .map_or(\"\".to_string(), |span| cm.span_to_string(*span));\n-        let (pre, post) = match ei.callee.format {\n-            codemap::MacroAttribute => (\"#[\", \"]\"),\n-            codemap::MacroBang => (\"\", \"!\")\n-        };\n-        try!(print_diagnostic(w, ss.as_slice(), Note,\n-                              format!(\"in expansion of {}{}{}\", pre,\n-                                      ei.callee.name,\n-                                      post).as_slice(), None));\n-        let ss = cm.span_to_string(ei.call_site);\n-        try!(print_diagnostic(w, ss.as_slice(), Note, \"expansion site\", None));\n-        try!(print_macro_backtrace(w, cm, ei.call_site));\n-    }\n-    Ok(())\n+    let cs = try!(cm.with_expn_info(sp.expn_id, |expn_info| match expn_info {\n+        Some(ei) => {\n+            let ss = ei.callee.span.map_or(String::new(), |span| cm.span_to_string(span));\n+            let (pre, post) = match ei.callee.format {\n+                codemap::MacroAttribute => (\"#[\", \"]\"),\n+                codemap::MacroBang => (\"\", \"!\")\n+            };\n+            try!(print_diagnostic(w, ss.as_slice(), Note,\n+                                  format!(\"in expansion of {}{}{}\", pre,\n+                                          ei.callee.name,\n+                                          post).as_slice(), None));\n+            let ss = cm.span_to_string(ei.call_site);\n+            try!(print_diagnostic(w, ss.as_slice(), Note, \"expansion site\", None));\n+            Ok(Some(ei.call_site))\n+        }\n+        None => Ok(None)\n+    }));\n+    cs.map_or(Ok(()), |call_site| print_macro_backtrace(w, cm, call_site))\n }\n \n pub fn expect<T>(diag: &SpanHandler, opt: Option<T>, msg: || -> String) -> T {"}, {"sha": "be0ab63e50dc736984ea52af771ebf23d9b31e9d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=07f4fda598f3fa3e7980f7d97621879fbbf00750", "patch": "@@ -11,7 +11,7 @@\n use ast;\n use ast::Name;\n use codemap;\n-use codemap::{CodeMap, Span, ExpnInfo};\n+use codemap::{CodeMap, Span, ExpnId, ExpnInfo, NO_EXPANSION};\n use ext;\n use ext::expand;\n use parse;\n@@ -24,7 +24,6 @@ use ext::mtwt;\n use fold::Folder;\n \n use std::collections::HashMap;\n-use std::gc::{Gc, GC};\n use std::rc::Rc;\n \n // new-style macro! tt code:\n@@ -457,7 +456,7 @@ fn initial_syntax_expander_table() -> SyntaxEnv {\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub cfg: ast::CrateConfig,\n-    pub backtrace: Option<Gc<ExpnInfo>>,\n+    pub backtrace: ExpnId,\n     pub ecfg: expand::ExpansionConfig,\n \n     pub mod_path: Vec<ast::Ident> ,\n@@ -473,7 +472,7 @@ impl<'a> ExtCtxt<'a> {\n         ExtCtxt {\n             parse_sess: parse_sess,\n             cfg: cfg,\n-            backtrace: None,\n+            backtrace: NO_EXPANSION,\n             mod_path: Vec::new(),\n             ecfg: ecfg,\n             trace_mac: false,\n@@ -501,13 +500,49 @@ impl<'a> ExtCtxt<'a> {\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n     pub fn call_site(&self) -> Span {\n-        match self.backtrace {\n+        self.codemap().with_expn_info(self.backtrace, |ei| match ei {\n             Some(expn_info) => expn_info.call_site,\n             None => self.bug(\"missing top span\")\n-        }\n+        })\n     }\n     pub fn print_backtrace(&self) { }\n-    pub fn backtrace(&self) -> Option<Gc<ExpnInfo>> { self.backtrace }\n+    pub fn backtrace(&self) -> ExpnId { self.backtrace }\n+    pub fn original_span(&self) -> Span {\n+        let mut expn_id = self.backtrace;\n+        let mut call_site = None;\n+        loop {\n+            match self.codemap().with_expn_info(expn_id, |ei| ei.map(|ei| ei.call_site)) {\n+                None => break,\n+                Some(cs) => {\n+                    call_site = Some(cs);\n+                    expn_id = cs.expn_id;\n+                }\n+            }\n+        }\n+        call_site.expect(\"missing expansion backtrace\")\n+    }\n+    pub fn original_span_in_file(&self) -> Span {\n+        let mut expn_id = self.backtrace;\n+        let mut call_site = None;\n+        loop {\n+            let expn_info = self.codemap().with_expn_info(expn_id, |ei| {\n+                ei.map(|ei| (ei.call_site, ei.callee.name.as_slice() == \"include\"))\n+            });\n+            match expn_info {\n+                None => break,\n+                Some((cs, is_include)) => {\n+                    if is_include {\n+                        // Don't recurse into file using \"include!\".\n+                        break;\n+                    }\n+                    call_site = Some(cs);\n+                    expn_id = cs.expn_id;\n+                }\n+            }\n+        }\n+        call_site.expect(\"missing expansion backtrace\")\n+    }\n+\n     pub fn mod_push(&mut self, i: ast::Ident) { self.mod_path.push(i); }\n     pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n     pub fn mod_path(&self) -> Vec<ast::Ident> {\n@@ -516,22 +551,22 @@ impl<'a> ExtCtxt<'a> {\n         v.extend(self.mod_path.iter().map(|a| *a));\n         return v;\n     }\n-    pub fn bt_push(&mut self, ei: codemap::ExpnInfo) {\n-        match ei {\n-            ExpnInfo {call_site: cs, callee: ref callee} => {\n-                self.backtrace =\n-                    Some(box(GC) ExpnInfo {\n-                        call_site: Span {lo: cs.lo, hi: cs.hi,\n-                                         expn_info: self.backtrace.clone()},\n-                        callee: (*callee).clone()\n-                    });\n-            }\n-        }\n+    pub fn bt_push(&mut self, ei: ExpnInfo) {\n+        let mut call_site = ei.call_site;\n+        call_site.expn_id = self.backtrace;\n+        self.backtrace = self.codemap().record_expansion(ExpnInfo {\n+            call_site: call_site,\n+            callee: ei.callee\n+        });\n     }\n     pub fn bt_pop(&mut self) {\n         match self.backtrace {\n-            Some(expn_info) => self.backtrace = expn_info.call_site.expn_info,\n-            _ => self.bug(\"tried to pop without a push\")\n+            NO_EXPANSION => self.bug(\"tried to pop without a push\"),\n+            expn_id => {\n+                self.backtrace = self.codemap().with_expn_info(expn_id, |expn_info| {\n+                    expn_info.map_or(NO_EXPANSION, |ei| ei.call_site.expn_id)\n+                });\n+            }\n         }\n     }\n     /// Emit `msg` attached to `sp`, and stop compilation immediately."}, {"sha": "16ecd83180ed15826026c66ae41ac79ed0675ac7", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=07f4fda598f3fa3e7980f7d97621879fbbf00750", "patch": "@@ -573,7 +573,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let field_span = Span {\n             lo: sp.lo - Pos::from_uint(field_name.get().len()),\n             hi: sp.hi,\n-            expn_info: sp.expn_info,\n+            expn_id: sp.expn_id,\n         };\n \n         let id = Spanned { node: ident, span: field_span };\n@@ -583,7 +583,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let field_span = Span {\n             lo: sp.lo - Pos::from_uint(idx.to_string().len()),\n             hi: sp.hi,\n-            expn_info: sp.expn_info,\n+            expn_id: sp.expn_id,\n         };\n \n         let id = Spanned { node: idx, span: field_span };"}, {"sha": "142adc9b721e00d462c8d7e36bb97554b1c76c5c", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=07f4fda598f3fa3e7980f7d97621879fbbf00750", "patch": "@@ -181,7 +181,6 @@\n //! ~~~\n \n use std::cell::RefCell;\n-use std::gc::GC;\n use std::vec;\n \n use abi::Abi;\n@@ -1169,7 +1168,7 @@ impl<'a> TraitDef<'a> {\n             None => cx.span_bug(self.span, \"trait with empty path in generic `deriving`\"),\n             Some(name) => *name\n         };\n-        to_set.expn_info = Some(box(GC) codemap::ExpnInfo {\n+        to_set.expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n             call_site: to_set,\n             callee: codemap::NameAndSpan {\n                 name: format!(\"deriving({})\", trait_name),"}, {"sha": "f81fc909a745bbbe705e7c2cb55fcf76e1ea6841", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=07f4fda598f3fa3e7980f7d97621879fbbf00750", "patch": "@@ -30,8 +30,6 @@ use util::small_vector::SmallVector;\n use visit;\n use visit::Visitor;\n \n-use std::gc::Gc;\n-\n enum Either<L,R> {\n     Left(L),\n     Right(R)\n@@ -161,11 +159,11 @@ fn expand_mac_invoc<T>(mac: ast::Mac, span: codemap::Span,\n                         // be the root of the call stack. That's the most\n                         // relevant span and it's the actual invocation of\n                         // the macro.\n-                        let mac_span = original_span(fld.cx);\n+                        let mac_span = fld.cx.original_span();\n \n                         let opt_parsed = {\n                             let expanded = expandfun.expand(fld.cx,\n-                                                            mac_span.call_site,\n+                                                            mac_span,\n                                                             marked_before.as_slice());\n                             parse_thunk(expanded)\n                         };\n@@ -759,9 +757,9 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n \n                     let fm = fresh_mark();\n                     let marked_before = mark_tts(tts.as_slice(), fm);\n-                    let mac_span = original_span(fld.cx);\n+                    let mac_span = fld.cx.original_span();\n                     let expanded = match expander.expand(fld.cx,\n-                                        mac_span.call_site,\n+                                        mac_span,\n                                         marked_before.as_slice()).make_pat() {\n                         Some(e) => e,\n                         None => {\n@@ -969,7 +967,7 @@ fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n     Span {\n         lo: sp.lo,\n         hi: sp.hi,\n-        expn_info: cx.backtrace(),\n+        expn_id: cx.backtrace(),\n     }\n }\n \n@@ -1083,21 +1081,6 @@ fn mark_method(expr: P<ast::Method>, m: Mrk) -> P<ast::Method> {\n         .expect_one(\"marking an item didn't return exactly one method\")\n }\n \n-fn original_span(cx: &ExtCtxt) -> Gc<codemap::ExpnInfo> {\n-    let mut relevant_info = cx.backtrace();\n-    let mut einfo = relevant_info.unwrap();\n-    loop {\n-        match relevant_info {\n-            None => { break }\n-            Some(e) => {\n-                einfo = e;\n-                relevant_info = einfo.call_site.expn_info;\n-            }\n-        }\n-    }\n-    return einfo;\n-}\n-\n /// Check that there are no macro invocations left in the AST:\n pub fn check_for_macros(sess: &parse::ParseSess, krate: &ast::Crate) {\n     visit::walk_crate(&mut MacroExterminator{sess:sess}, krate);"}, {"sha": "41967b0680cffa9684c5c0765e025940a472cb13", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 9, "deletions": 37, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=07f4fda598f3fa3e7980f7d97621879fbbf00750", "patch": "@@ -11,15 +11,13 @@\n use ast;\n use codemap;\n use codemap::{Pos, Span};\n-use codemap::{ExpnInfo, NameAndSpan};\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n use parse;\n use parse::token;\n use print::pprust;\n \n-use std::gc::Gc;\n use std::io::File;\n use std::rc::Rc;\n \n@@ -32,20 +30,20 @@ pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                    -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n-    let topmost = topmost_expn_info(cx.backtrace().unwrap());\n-    let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n+    let topmost = cx.original_span_in_file();\n+    let loc = cx.codemap().lookup_char_pos(topmost.lo);\n \n-    base::MacExpr::new(cx.expr_uint(topmost.call_site, loc.line))\n+    base::MacExpr::new(cx.expr_uint(topmost, loc.line))\n }\n \n /* col!(): expands to the current column number */\n pub fn expand_col(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                   -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n \n-    let topmost = topmost_expn_info(cx.backtrace().unwrap());\n-    let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n-    base::MacExpr::new(cx.expr_uint(topmost.call_site, loc.col.to_uint()))\n+    let topmost = cx.original_span_in_file();\n+    let loc = cx.codemap().lookup_char_pos(topmost.lo);\n+    base::MacExpr::new(cx.expr_uint(topmost, loc.col.to_uint()))\n }\n \n /// file!(): expands to the current filename */\n@@ -55,10 +53,10 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                    -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n-    let topmost = topmost_expn_info(cx.backtrace().unwrap());\n-    let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n+    let topmost = cx.original_span_in_file();\n+    let loc = cx.codemap().lookup_char_pos(topmost.lo);\n     let filename = token::intern_and_get_ident(loc.file.name.as_slice());\n-    base::MacExpr::new(cx.expr_str(topmost.call_site, filename))\n+    base::MacExpr::new(cx.expr_str(topmost, filename))\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n@@ -162,32 +160,6 @@ pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     }\n }\n \n-// recur along an ExpnInfo chain to find the original expression\n-fn topmost_expn_info(expn_info: Gc<codemap::ExpnInfo>) -> Gc<codemap::ExpnInfo> {\n-    match *expn_info {\n-        ExpnInfo { call_site: ref call_site, .. } => {\n-            match call_site.expn_info {\n-                Some(next_expn_info) => {\n-                    match *next_expn_info {\n-                        ExpnInfo {\n-                            callee: NameAndSpan { name: ref name, .. },\n-                            ..\n-                        } => {\n-                            // Don't recurse into file using \"include!\"\n-                            if \"include\" == name.as_slice() {\n-                                expn_info\n-                            } else {\n-                                topmost_expn_info(next_expn_info)\n-                            }\n-                        }\n-                    }\n-                },\n-                None => expn_info\n-            }\n-        }\n-    }\n-}\n-\n // resolve a file-system path to an absolute file-system path (if it\n // isn't already)\n fn res_rel_file(cx: &mut ExtCtxt, sp: codemap::Span, arg: &Path) -> Path {"}, {"sha": "153b3cc90d60101f8f9f66d32b5e4c25789cefc0", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=07f4fda598f3fa3e7980f7d97621879fbbf00750", "patch": "@@ -23,7 +23,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/master/\")]\n \n-#![feature(macro_rules, globs, managed_boxes, default_type_params, phase)]\n+#![feature(macro_rules, globs, default_type_params, phase)]\n #![feature(quote, struct_variant, unsafe_destructor, import_shadowing)]\n #![allow(deprecated)]\n "}, {"sha": "7c0564c28d18f0e669e144903b360115abf1a99a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f4fda598f3fa3e7980f7d97621879fbbf00750/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=07f4fda598f3fa3e7980f7d97621879fbbf00750", "patch": "@@ -3590,7 +3590,7 @@ impl<'a> Parser<'a> {\n                                     let span_with_semi = Span {\n                                         lo: span.lo,\n                                         hi: self.last_span.hi,\n-                                        expn_info: span.expn_info,\n+                                        expn_id: span.expn_id,\n                                     };\n                                     stmts.push(P(Spanned {\n                                         node: StmtSemi(e, stmt_id),"}]}