{"sha": "db01b6789db9b4f89209ea6e28781dfd66eebbcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMDFiNjc4OWRiOWI0Zjg5MjA5ZWE2ZTI4NzgxZGZkNjZlZWJiY2I=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-08-25T03:11:44Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-09-06T23:58:22Z"}, "message": "[nll] Refactor the `Edges` iterator to return `OutlivesConstraints`\n\nPart of #53178", "tree": {"sha": "1a726a48df4bd9b1bcf0c8433d37157291d48313", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a726a48df4bd9b1bcf0c8433d37157291d48313"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db01b6789db9b4f89209ea6e28781dfd66eebbcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db01b6789db9b4f89209ea6e28781dfd66eebbcb", "html_url": "https://github.com/rust-lang/rust/commit/db01b6789db9b4f89209ea6e28781dfd66eebbcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db01b6789db9b4f89209ea6e28781dfd66eebbcb/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8c11d216b04abe21a03220b344f1415e1d6ebd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8c11d216b04abe21a03220b344f1415e1d6ebd1", "html_url": "https://github.com/rust-lang/rust/commit/a8c11d216b04abe21a03220b344f1415e1d6ebd1"}], "stats": {"total": 60, "additions": 31, "deletions": 29}, "files": [{"sha": "7cf94ec84dc935eac95218de674fd446df762467", "filename": "src/librustc_mir/borrow_check/nll/constraints/graph.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/db01b6789db9b4f89209ea6e28781dfd66eebbcb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db01b6789db9b4f89209ea6e28781dfd66eebbcb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs?ref=db01b6789db9b4f89209ea6e28781dfd66eebbcb", "patch": "@@ -103,27 +103,33 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     }\n \n     /// Given a region `R`, iterate over all constraints `R: R1`.\n-    crate fn outgoing_edges(&self, region_sup: RegionVid) -> Edges<'_, D> {\n+    crate fn outgoing_edges<'a>(\n+        &'a self,\n+        region_sup: RegionVid,\n+        constraints: &'a ConstraintSet,\n+    ) -> Edges<'a, D> {\n         let first = self.first_constraints[region_sup];\n         Edges {\n             graph: self,\n+            constraints,\n             pointer: first,\n         }\n     }\n }\n \n crate struct Edges<'s, D: ConstraintGraphDirecton> {\n     graph: &'s ConstraintGraph<D>,\n+    constraints: &'s ConstraintSet,\n     pointer: Option<ConstraintIndex>,\n }\n \n impl<'s, D: ConstraintGraphDirecton> Iterator for Edges<'s, D> {\n-    type Item = ConstraintIndex;\n+    type Item = OutlivesConstraint;\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if let Some(p) = self.pointer {\n             self.pointer = self.graph.next_constraints[p];\n-            Some(p)\n+            Some(self.constraints[p])\n         } else {\n             None\n         }\n@@ -154,22 +160,20 @@ impl<'s, D: ConstraintGraphDirecton> RegionGraph<'s, D> {\n     /// there exists a constraint `R: R1`.\n     crate fn outgoing_regions(&self, region_sup: RegionVid) -> Successors<'_, D> {\n         Successors {\n-            set: self.set,\n-            edges: self.constraint_graph.outgoing_edges(region_sup),\n+            edges: self.constraint_graph.outgoing_edges(region_sup, self.set),\n         }\n     }\n }\n \n crate struct Successors<'s, D: ConstraintGraphDirecton> {\n-    set: &'s ConstraintSet,\n     edges: Edges<'s, D>,\n }\n \n impl<'s, D: ConstraintGraphDirecton> Iterator for Successors<'s, D> {\n     type Item = RegionVid;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        self.edges.next().map(|c| D::end_region(&self.set[c]))\n+        self.edges.next().map(|c| D::end_region(&c))\n     }\n }\n "}, {"sha": "2a541b6474f583fc71648189587de2bd55a69358", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/db01b6789db9b4f89209ea6e28781dfd66eebbcb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db01b6789db9b4f89209ea6e28781dfd66eebbcb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=db01b6789db9b4f89209ea6e28781dfd66eebbcb", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::region_infer::{ConstraintIndex, RegionInferenceContext};\n+use borrow_check::nll::constraints::OutlivesConstraint;\n+use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n@@ -53,7 +54,7 @@ impl fmt::Display for ConstraintCategory {\n #[derive(Copy, Clone, PartialEq, Eq)]\n enum Trace {\n     StartRegion,\n-    FromConstraint(ConstraintIndex),\n+    FromOutlivesConstraint(OutlivesConstraint),\n     NotVisited,\n }\n \n@@ -80,12 +81,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\n             \"best_blame_constraint: path={:#?}\",\n             path.iter()\n-                .map(|&ci| format!(\n-                    \"{:?}: {:?} ({:?}: {:?})\",\n-                    ci,\n-                    &self.constraints[ci],\n-                    self.constraint_sccs.scc(self.constraints[ci].sup),\n-                    self.constraint_sccs.scc(self.constraints[ci].sub),\n+                .map(|&c| format!(\n+                    \"{:?} ({:?}: {:?})\",\n+                    c,\n+                    self.constraint_sccs.scc(c.sup),\n+                    self.constraint_sccs.scc(c.sub),\n                 ))\n                 .collect::<Vec<_>>()\n         );\n@@ -121,7 +121,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // highlight (e.g., a call site or something).\n         let target_scc = self.constraint_sccs.scc(target_region);\n         let best_choice = (0..path.len()).rev().find(|&i| {\n-            let constraint = &self.constraints[path[i]];\n+            let constraint = path[i];\n \n             let constraint_sup_scc = self.constraint_sccs.scc(constraint.sup);\n \n@@ -164,7 +164,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         from_region: RegionVid,\n         target_test: impl Fn(RegionVid) -> bool,\n-    ) -> Option<(Vec<ConstraintIndex>, RegionVid)> {\n+    ) -> Option<(Vec<OutlivesConstraint>, RegionVid)> {\n         let mut context = IndexVec::from_elem(Trace::NotVisited, &self.definitions);\n         context[from_region] = Trace::StartRegion;\n \n@@ -185,9 +185,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         Trace::NotVisited => {\n                             bug!(\"found unvisited region {:?} on path to {:?}\", p, r)\n                         }\n-                        Trace::FromConstraint(c) => {\n+                        Trace::FromOutlivesConstraint(c) => {\n                             result.push(c);\n-                            p = self.constraints[c].sup;\n+                            p = c.sup;\n                         }\n \n                         Trace::StartRegion => {\n@@ -201,11 +201,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Otherwise, walk over the outgoing constraints and\n             // enqueue any regions we find, keeping track of how we\n             // reached them.\n-            for constraint in self.constraint_graph.outgoing_edges(r) {\n-                assert_eq!(self.constraints[constraint].sup, r);\n-                let sub_region = self.constraints[constraint].sub;\n+            for constraint in self.constraint_graph.outgoing_edges(r, &self.constraints) {\n+                assert_eq!(constraint.sup, r);\n+                let sub_region = constraint.sub;\n                 if let Trace::NotVisited = context[sub_region] {\n-                    context[sub_region] = Trace::FromConstraint(constraint);\n+                    context[sub_region] = Trace::FromOutlivesConstraint(constraint);\n                     deque.push_back(sub_region);\n                 }\n             }\n@@ -216,8 +216,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// This function will return true if a constraint is interesting and false if a constraint\n     /// is not. It is useful in filtering constraint paths to only interesting points.\n-    fn constraint_is_interesting(&self, index: ConstraintIndex) -> bool {\n-        let constraint = self.constraints[index];\n+    fn constraint_is_interesting(&self, constraint: OutlivesConstraint) -> bool {\n         debug!(\n             \"constraint_is_interesting: locations={:?} constraint={:?}\",\n             constraint.locations, constraint\n@@ -232,19 +231,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// This function classifies a constraint from a location.\n     fn classify_constraint(\n         &self,\n-        index: ConstraintIndex,\n+        constraint: OutlivesConstraint,\n         mir: &Mir<'tcx>,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n     ) -> (ConstraintCategory, Span) {\n-        let constraint = self.constraints[index];\n         debug!(\"classify_constraint: constraint={:?}\", constraint);\n         let span = constraint.locations.span(mir);\n         let location = constraint\n             .locations\n             .from_location()\n             .unwrap_or(Location::START);\n \n-        if !self.constraint_is_interesting(index) {\n+        if !self.constraint_is_interesting(constraint) {\n             return (ConstraintCategory::Boring, span);\n         }\n "}, {"sha": "4fe39ba3c9520bea74aed78160f7fa822c31e835", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db01b6789db9b4f89209ea6e28781dfd66eebbcb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db01b6789db9b4f89209ea6e28781dfd66eebbcb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=db01b6789db9b4f89209ea6e28781dfd66eebbcb", "patch": "@@ -11,7 +11,7 @@\n use super::universal_regions::UniversalRegions;\n use borrow_check::nll::constraints::graph::NormalConstraintGraph;\n use borrow_check::nll::constraints::{\n-    ConstraintIndex, ConstraintSccIndex, ConstraintSet, OutlivesConstraint,\n+    ConstraintSccIndex, ConstraintSet, OutlivesConstraint,\n };\n use borrow_check::nll::region_infer::values::{RegionElement, ToElementIndex};\n use borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;"}]}