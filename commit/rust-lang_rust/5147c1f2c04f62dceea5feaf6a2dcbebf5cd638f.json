{"sha": "5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNDdjMWYyYzA0ZjYyZGNlZWE1ZmVhZjZhMmRjYmViZjVjZDYzOGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-06T01:24:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-06T01:24:22Z"}, "message": "Auto merge of #31307 - nagisa:mir-drop-terminator, r=nikomatsakis\n\nThe scope of these refactorings is a little bit bigger than the title implies. See each commit for details.\n\nI\u2019m submitting this for nitpicking now (the first 4 commits), because I feel the basic idea/implementation is sound and should work. I will eventually expand this PR to cover the translator changes necessary for all this to work (+ tests), ~~and perhaps implement a dynamic dropping scheme while I\u2019m at it as well.~~\n\nr? @nikomatsakis", "tree": {"sha": "4d8cd52215cb214be361a4fe29e750597fdd6a61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d8cd52215cb214be361a4fe29e750597fdd6a61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "html_url": "https://github.com/rust-lang/rust/commit/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "url": "https://api.github.com/repos/rust-lang/rust/commits/34af2de4096b3b1c5d3a5b70171c6e27822aaefb", "html_url": "https://github.com/rust-lang/rust/commit/34af2de4096b3b1c5d3a5b70171c6e27822aaefb"}, {"sha": "caf62ef9846edfd41177b883181c5c045ca69859", "url": "https://api.github.com/repos/rust-lang/rust/commits/caf62ef9846edfd41177b883181c5c045ca69859", "html_url": "https://github.com/rust-lang/rust/commit/caf62ef9846edfd41177b883181c5c045ca69859"}], "stats": {"total": 879, "additions": 547, "deletions": 332}, "files": [{"sha": "b948567ac5b74a565a55d6136081e763aec8d997", "filename": "src/doc/book/lang-items.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Fdoc%2Fbook%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Fdoc%2Fbook%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flang-items.md?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -39,11 +39,17 @@ unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n \n     p\n }\n+\n #[lang = \"exchange_free\"]\n unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {\n     libc::free(ptr as *mut libc::c_void)\n }\n \n+#[lang = \"box_free\"]\n+unsafe fn box_free<T>(ptr: *mut T) {\n+    deallocate(ptr as *mut u8, ::core::mem::size_of::<T>(), ::core::mem::align_of::<T>());\n+}\n+\n #[start]\n fn main(argc: isize, argv: *const *const u8) -> isize {\n     let x = box 1;"}, {"sha": "08b403a60f3819d7ee07e9186141d237ac0fadab", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -16,6 +16,8 @@\n             issue = \"27700\")]\n \n use core::{isize, usize};\n+#[cfg(not(test))]\n+use core::intrinsics::{size_of, min_align_of};\n \n #[allow(improper_ctypes)]\n extern \"C\" {\n@@ -147,6 +149,17 @@ unsafe fn exchange_free(ptr: *mut u8, old_size: usize, align: usize) {\n     deallocate(ptr, old_size, align);\n }\n \n+#[cfg(not(test))]\n+#[lang = \"box_free\"]\n+#[inline]\n+unsafe fn box_free<T>(ptr: *mut T) {\n+    let size = size_of::<T>();\n+    // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n+    if size != 0 {\n+        deallocate(ptr as *mut u8, size, min_align_of::<T>());\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     extern crate test;"}, {"sha": "7ed931265f22cea910118d353b2a56250087934c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -435,7 +435,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         let is_named = node.name().is_some();\n         let field_type = self.tcx.node_id_to_type(node.id);\n         let is_marker_field = match field_type.ty_to_def_id() {\n-            Some(def_id) => self.tcx.lang_items.items().any(|(_, item)| *item == Some(def_id)),\n+            Some(def_id) => self.tcx.lang_items.items().iter().any(|item| *item == Some(def_id)),\n             _ => false\n         };\n         is_named"}, {"sha": "a22ad7a0707c2aef4958e6deec8447ae587fdb46", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -37,9 +37,6 @@ use syntax::parse::token::InternedString;\n use rustc_front::intravisit::Visitor;\n use rustc_front::hir;\n \n-use std::iter::Enumerate;\n-use std::slice;\n-\n // The actual lang items defined come at the end of this file in one handy table.\n // So you probably just want to nip down to the end.\n macro_rules! lets_do_this {\n@@ -70,8 +67,8 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn items<'a>(&'a self) -> Enumerate<slice::Iter<'a, Option<DefId>>> {\n-        self.items.iter().enumerate()\n+    pub fn items(&self) -> &[Option<DefId>] {\n+        &*self.items\n     }\n \n     pub fn item_name(index: usize) -> &'static str {\n@@ -336,6 +333,7 @@ lets_do_this! {\n \n     ExchangeMallocFnLangItem,        \"exchange_malloc\",         exchange_malloc_fn;\n     ExchangeFreeFnLangItem,          \"exchange_free\",           exchange_free_fn;\n+    BoxFreeFnLangItem,               \"box_free\",                box_free_fn;\n     StrDupUniqFnLangItem,            \"strdup_uniq\",             strdup_uniq_fn;\n \n     StartFnLangItem,                 \"start\",                   start_fn;"}, {"sha": "6dd447e3b6860c68ec4e567b68406c80c423ab56", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -362,7 +362,7 @@ pub fn find_reachable(tcx: &ty::ctxt,\n     for (id, _) in &access_levels.map {\n         reachable_context.worklist.push(*id);\n     }\n-    for (_, item) in tcx.lang_items.items() {\n+    for item in tcx.lang_items.items().iter() {\n         if let Some(did) = *item {\n             if let Some(node_id) = tcx.map.as_local_node_id(did) {\n                 reachable_context.worklist.push(node_id);"}, {"sha": "783c58469a1b3c79011456b72e1c57dff5a9a72e", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 60, "deletions": 111, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -8,21 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use graphviz::IntoCow;\n use middle::const_eval::ConstVal;\n use middle::def_id::DefId;\n use middle::subst::Substs;\n use middle::ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n use rustc_back::slice;\n-use rustc_data_structures::tuple_slice::TupleSlice;\n use rustc_front::hir::InlineAsm;\n-use syntax::ast::{self, Name};\n-use syntax::codemap::Span;\n-use graphviz::IntoCow;\n use std::ascii;\n-use std::borrow::Cow;\n+use std::borrow::{Cow};\n use std::fmt::{self, Debug, Formatter, Write};\n use std::{iter, u32};\n use std::ops::{Index, IndexMut};\n+use syntax::ast::{self, Name};\n+use syntax::codemap::Span;\n \n /// Lowered representation of a single function.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n@@ -263,101 +262,63 @@ pub enum Terminator<'tcx> {\n     /// `END_BLOCK`.\n     Return,\n \n+    /// Drop the Lvalue\n+    Drop {\n+        value: Lvalue<'tcx>,\n+        target: BasicBlock,\n+        unwind: Option<BasicBlock>\n+    },\n+\n     /// Block ends with a call of a converging function\n     Call {\n         /// The function that\u2019s being called\n         func: Operand<'tcx>,\n         /// Arguments the function is called with\n         args: Vec<Operand<'tcx>>,\n-        /// The kind of call with associated information\n-        kind: CallKind<'tcx>,\n+        /// Destination for the return value. If some, the call is converging.\n+        destination: Option<(Lvalue<'tcx>, BasicBlock)>,\n+        /// Cleanups to be done if the call unwinds.\n+        cleanup: Option<BasicBlock>\n     },\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub enum CallKind<'tcx> {\n-    /// Diverging function without associated cleanup\n-    Diverging,\n-    /// Diverging function with associated cleanup\n-    DivergingCleanup(BasicBlock),\n-    /// Converging function without associated cleanup\n-    Converging {\n-        /// Destination where the call result is written\n-        destination: Lvalue<'tcx>,\n-        /// Block to branch into on successful return\n-        target: BasicBlock,\n-    },\n-    ConvergingCleanup {\n-        /// Destination where the call result is written\n-        destination: Lvalue<'tcx>,\n-        /// First target is branched to on successful return.\n-        /// Second block contains the cleanups to do on unwind.\n-        targets: (BasicBlock, BasicBlock)\n-    }\n-}\n-\n-impl<'tcx> CallKind<'tcx> {\n-    pub fn successors(&self) -> &[BasicBlock] {\n-        match *self {\n-            CallKind::Diverging => &[],\n-            CallKind::DivergingCleanup(ref b) |\n-            CallKind::Converging { target: ref b, .. } => slice::ref_slice(b),\n-            CallKind::ConvergingCleanup { ref targets, .. } => targets.as_slice(),\n-        }\n-    }\n-\n-    pub fn successors_mut(&mut self) -> &mut [BasicBlock] {\n-        match *self {\n-            CallKind::Diverging => &mut [],\n-            CallKind::DivergingCleanup(ref mut b) |\n-            CallKind::Converging { target: ref mut b, .. } => slice::mut_ref_slice(b),\n-            CallKind::ConvergingCleanup { ref mut targets, .. } => targets.as_mut_slice(),\n-        }\n-    }\n-\n-    pub fn destination(&self) -> Option<&Lvalue<'tcx>> {\n-        match *self {\n-            CallKind::Converging { ref destination, .. } |\n-            CallKind::ConvergingCleanup { ref destination, .. } => Some(destination),\n-            CallKind::Diverging |\n-            CallKind::DivergingCleanup(_) => None\n-        }\n-    }\n-\n-    pub fn destination_mut(&mut self) -> Option<&mut Lvalue<'tcx>> {\n-        match *self {\n-            CallKind::Converging { ref mut destination, .. } |\n-            CallKind::ConvergingCleanup { ref mut destination, .. } => Some(destination),\n-            CallKind::Diverging |\n-            CallKind::DivergingCleanup(_) => None\n-        }\n-    }\n-}\n-\n impl<'tcx> Terminator<'tcx> {\n-    pub fn successors(&self) -> &[BasicBlock] {\n+    pub fn successors(&self) -> Cow<[BasicBlock]> {\n         use self::Terminator::*;\n         match *self {\n-            Goto { target: ref b } => slice::ref_slice(b),\n-            If { targets: ref b, .. } => b.as_slice(),\n-            Switch { targets: ref b, .. } => b,\n-            SwitchInt { targets: ref b, .. } => b,\n-            Resume => &[],\n-            Return => &[],\n-            Call { ref kind, .. } => kind.successors(),\n+            Goto { target: ref b } => slice::ref_slice(b).into_cow(),\n+            If { targets: (b1, b2), .. } => vec![b1, b2].into_cow(),\n+            Switch { targets: ref b, .. } => b[..].into_cow(),\n+            SwitchInt { targets: ref b, .. } => b[..].into_cow(),\n+            Resume => (&[]).into_cow(),\n+            Return => (&[]).into_cow(),\n+            Call { destination: Some((_, t)), cleanup: Some(c), .. } => vec![t, c].into_cow(),\n+            Call { destination: Some((_, ref t)), cleanup: None, .. } =>\n+                slice::ref_slice(t).into_cow(),\n+            Call { destination: None, cleanup: Some(ref c), .. } => slice::ref_slice(c).into_cow(),\n+            Call { destination: None, cleanup: None, .. } => (&[]).into_cow(),\n+            Drop { target, unwind: Some(unwind), .. } => vec![target, unwind].into_cow(),\n+            Drop { ref target, .. } => slice::ref_slice(target).into_cow(),\n         }\n     }\n \n-    pub fn successors_mut(&mut self) -> &mut [BasicBlock] {\n+    // FIXME: no mootable cow. I\u2019m honestly not sure what a \u201ccow\u201d between `&mut [BasicBlock]` and\n+    // `Vec<&mut BasicBlock>` would look like in the first place.\n+    pub fn successors_mut(&mut self) -> Vec<&mut BasicBlock> {\n         use self::Terminator::*;\n         match *self {\n-            Goto { target: ref mut b } => slice::mut_ref_slice(b),\n-            If { targets: ref mut b, .. } => b.as_mut_slice(),\n-            Switch { targets: ref mut b, .. } => b,\n-            SwitchInt { targets: ref mut b, .. } => b,\n-            Resume => &mut [],\n-            Return => &mut [],\n-            Call { ref mut kind, .. } => kind.successors_mut(),\n+            Goto { target: ref mut b } => vec![b],\n+            If { targets: (ref mut b1, ref mut b2), .. } => vec![b1, b2],\n+            Switch { targets: ref mut b, .. } => b.iter_mut().collect(),\n+            SwitchInt { targets: ref mut b, .. } => b.iter_mut().collect(),\n+            Resume => Vec::new(),\n+            Return => Vec::new(),\n+            Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut c), .. } => vec![t, c],\n+            Call { destination: Some((_, ref mut t)), cleanup: None, .. } => vec![t],\n+            Call { destination: None, cleanup: Some(ref mut c), .. } => vec![c],\n+            Call { destination: None, cleanup: None, .. } => vec![],\n+            Drop { ref mut target, unwind: Some(ref mut unwind), .. } => vec![target, unwind],\n+            Drop { ref mut target, .. } => vec![target]\n         }\n     }\n }\n@@ -424,8 +385,9 @@ impl<'tcx> Terminator<'tcx> {\n             SwitchInt { discr: ref lv, .. } => write!(fmt, \"switchInt({:?})\", lv),\n             Return => write!(fmt, \"return\"),\n             Resume => write!(fmt, \"resume\"),\n-            Call { ref kind, ref func, ref args } => {\n-                if let Some(destination) = kind.destination() {\n+            Drop { ref value, .. } => write!(fmt, \"drop({:?})\", value),\n+            Call { ref func, ref args, ref destination, .. } => {\n+                if let Some((ref destination, _)) = *destination {\n                     try!(write!(fmt, \"{:?} = \", destination));\n                 }\n                 try!(write!(fmt, \"{:?}(\", func));\n@@ -445,34 +407,31 @@ impl<'tcx> Terminator<'tcx> {\n         use self::Terminator::*;\n         match *self {\n             Return | Resume => vec![],\n-            Goto { .. } => vec![\"\".into_cow()],\n-            If { .. } => vec![\"true\".into_cow(), \"false\".into_cow()],\n+            Goto { .. } => vec![\"\".into()],\n+            If { .. } => vec![\"true\".into(), \"false\".into()],\n             Switch { ref adt_def, .. } => {\n                 adt_def.variants\n                        .iter()\n-                       .map(|variant| variant.name.to_string().into_cow())\n+                       .map(|variant| variant.name.to_string().into())\n                        .collect()\n             }\n             SwitchInt { ref values, .. } => {\n                 values.iter()\n                       .map(|const_val| {\n                           let mut buf = String::new();\n                           fmt_const_val(&mut buf, const_val).unwrap();\n-                          buf.into_cow()\n+                          buf.into()\n                       })\n-                      .chain(iter::once(String::from(\"otherwise\").into_cow()))\n+                      .chain(iter::once(String::from(\"otherwise\").into()))\n                       .collect()\n             }\n-            Call { ref kind, .. } => match *kind {\n-                CallKind::Diverging =>\n-                    vec![],\n-                CallKind::DivergingCleanup(..) =>\n-                    vec![\"unwind\".into_cow()],\n-                CallKind::Converging { .. } =>\n-                    vec![\"return\".into_cow()],\n-                CallKind::ConvergingCleanup { .. } =>\n-                    vec![\"return\".into_cow(), \"unwind\".into_cow()],\n-            },\n+            Call { destination: Some(_), cleanup: Some(_), .. } =>\n+                vec![\"return\".into_cow(), \"unwind\".into_cow()],\n+            Call { destination: Some(_), cleanup: None, .. } => vec![\"return\".into_cow()],\n+            Call { destination: None, cleanup: Some(_), .. } => vec![\"unwind\".into_cow()],\n+            Call { destination: None, cleanup: None, .. } => vec![],\n+            Drop { unwind: None, .. } => vec![\"return\".into_cow()],\n+            Drop { .. } => vec![\"return\".into_cow(), \"unwind\".into_cow()],\n         }\n     }\n }\n@@ -490,23 +449,13 @@ pub struct Statement<'tcx> {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum StatementKind<'tcx> {\n     Assign(Lvalue<'tcx>, Rvalue<'tcx>),\n-    Drop(DropKind, Lvalue<'tcx>),\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n-pub enum DropKind {\n-    /// free a partially constructed box, should go away eventually\n-    Free,\n-    Deep\n }\n \n impl<'tcx> Debug for Statement<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::StatementKind::*;\n         match self.kind {\n-            Assign(ref lv, ref rv) => write!(fmt, \"{:?} = {:?}\", lv, rv),\n-            Drop(DropKind::Free, ref lv) => write!(fmt, \"free {:?}\", lv),\n-            Drop(DropKind::Deep, ref lv) => write!(fmt, \"drop {:?}\", lv),\n+            Assign(ref lv, ref rv) => write!(fmt, \"{:?} = {:?}\", lv, rv)\n         }\n     }\n }"}, {"sha": "fb4e0e97054b9fc41d7a3cbc05446dc3cac9c655", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -124,9 +124,6 @@ macro_rules! make_mir_visitor {\n                                           ref $($mutability)* rvalue) => {\n                         self.visit_assign(block, lvalue, rvalue);\n                     }\n-                    StatementKind::Drop(_, ref $($mutability)* lvalue) => {\n-                        self.visit_lvalue(lvalue, LvalueContext::Drop);\n-                    }\n                 }\n             }\n \n@@ -177,30 +174,25 @@ macro_rules! make_mir_visitor {\n                     Terminator::Return => {\n                     }\n \n+                    Terminator::Drop { ref $($mutability)* value, target, unwind } => {\n+                        self.visit_lvalue(value, LvalueContext::Drop);\n+                        self.visit_branch(block, target);\n+                        unwind.map(|t| self.visit_branch(block, t));\n+                    }\n+\n                     Terminator::Call { ref $($mutability)* func,\n                                        ref $($mutability)* args,\n-                                       ref $($mutability)* kind } => {\n+                                       ref $($mutability)* destination,\n+                                       cleanup } => {\n                         self.visit_operand(func);\n                         for arg in args {\n                             self.visit_operand(arg);\n                         }\n-                        match *kind {\n-                            CallKind::Converging {\n-                                ref $($mutability)* destination,\n-                                ..\n-                            }        |\n-                            CallKind::ConvergingCleanup {\n-                                ref $($mutability)* destination,\n-                                ..\n-                            } => {\n-                                self.visit_lvalue(destination, LvalueContext::Store);\n-                            }\n-                            CallKind::Diverging           |\n-                            CallKind::DivergingCleanup(_) => {}\n-                        }\n-                        for &target in kind.successors() {\n+                        if let Some((ref $($mutability)* destination, target)) = *destination {\n+                            self.visit_lvalue(destination, LvalueContext::Store);\n                             self.visit_branch(block, target);\n                         }\n+                        cleanup.map(|t| self.visit_branch(block, t));\n                     }\n                 }\n             }"}, {"sha": "8df72016078e6330de3050afb4276e62fd400a9f", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -1649,7 +1649,7 @@ fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_lang_items);\n \n-    for (i, &opt_def_id) in ecx.tcx.lang_items.items() {\n+    for (i, &opt_def_id) in ecx.tcx.lang_items.items().iter().enumerate() {\n         if let Some(def_id) = opt_def_id {\n             if def_id.is_local() {\n                 rbml_w.start_tag(tag_lang_items_item);"}, {"sha": "c7147d111aace02a0dddeb90e6e8107a629f700c", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -32,19 +32,17 @@ impl<'tcx> CFG<'tcx> {\n         BasicBlock::new(node_index)\n     }\n \n+    pub fn start_new_cleanup_block(&mut self) -> BasicBlock {\n+        let bb = self.start_new_block();\n+        self.block_data_mut(bb).is_cleanup = true;\n+        bb\n+    }\n+\n     pub fn push(&mut self, block: BasicBlock, statement: Statement<'tcx>) {\n         debug!(\"push({:?}, {:?})\", block, statement);\n         self.block_data_mut(block).statements.push(statement);\n     }\n \n-    pub fn push_drop(&mut self, block: BasicBlock, span: Span,\n-                     kind: DropKind, lvalue: &Lvalue<'tcx>) {\n-        self.push(block, Statement {\n-            span: span,\n-            kind: StatementKind::Drop(kind, lvalue.clone())\n-        });\n-    }\n-\n     pub fn push_assign(&mut self,\n                        block: BasicBlock,\n                        span: Span,\n@@ -81,4 +79,3 @@ impl<'tcx> CFG<'tcx> {\n         self.block_data_mut(block).terminator = Some(terminator);\n     }\n }\n-"}, {"sha": "dea2d750b981bed47801d3cdfd3ece92713a5316", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -59,25 +59,18 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let arg = unpack!(block = this.as_operand(block, arg));\n                 block.and(Rvalue::UnaryOp(op, arg))\n             }\n-            ExprKind::Box { value } => {\n+            ExprKind::Box { value, value_extents } => {\n                 let value = this.hir.mirror(value);\n                 let result = this.temp(expr.ty);\n-\n                 // to start, malloc some memory of suitable type (thus far, uninitialized):\n-                let rvalue = Rvalue::Box(value.ty);\n-                this.cfg.push_assign(block, expr_span, &result, rvalue);\n-\n-                // schedule a shallow free of that memory, lest we unwind:\n-                let extent = this.extent_of_innermost_scope();\n-                this.schedule_drop(expr_span, extent, DropKind::Free, &result, value.ty);\n-\n-                // initialize the box contents:\n-                let contents = result.clone().deref();\n-                unpack!(block = this.into(&contents, block, value));\n-\n-                // now that the result is fully initialized, cancel the drop\n-                // by \"using\" the result (which is linear):\n-                block.and(Rvalue::Use(Operand::Consume(result)))\n+                this.cfg.push_assign(block, expr_span, &result, Rvalue::Box(value.ty));\n+                this.in_scope(value_extents, block, |this| {\n+                    // schedule a shallow free of that memory, lest we unwind:\n+                    this.schedule_box_free(expr_span, value_extents, &result, value.ty);\n+                    // initialize the box contents:\n+                    unpack!(block = this.into(&result.clone().deref(), block, value));\n+                    block.and(Rvalue::Use(Operand::Consume(result)))\n+                })\n             }\n             ExprKind::Cast { source } => {\n                 let source = unpack!(block = this.as_operand(block, source));"}, {"sha": "27c374e1ac2c468591118dcb40e0654fd73115cf", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -41,7 +41,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 this.hir.span_bug(expr.span, \"no temp_lifetime for expr\");\n             }\n         };\n-        this.schedule_drop(expr.span, temp_lifetime, DropKind::Deep, &temp, expr_ty);\n+        this.schedule_drop(expr.span, temp_lifetime, &temp, expr_ty);\n \n         // Careful here not to cause an infinite cycle. If we always\n         // called `into`, then for lvalues like `x.f`, it would"}, {"sha": "f50e5689df017cdbb7bcdc0c924070f964c91cb7", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -188,7 +188,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 // operators like x[j] = x[i].\n                 let rhs = unpack!(block = this.as_operand(block, rhs));\n                 let lhs = unpack!(block = this.as_lvalue(block, lhs));\n-                this.cfg.push_drop(block, expr_span, DropKind::Deep, &lhs);\n+                unpack!(block = this.build_drop(block, lhs.clone()));\n                 this.cfg.push_assign(block, expr_span, &lhs, Rvalue::Use(rhs));\n                 block.unit()\n             }\n@@ -253,17 +253,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 this.cfg.terminate(block, Terminator::Call {\n                     func: fun,\n                     args: args,\n-                    kind: match (cleanup, diverges) {\n-                        (None, true) => CallKind::Diverging,\n-                        (Some(c), true) => CallKind::DivergingCleanup(c),\n-                        (None, false) => CallKind::Converging {\n-                            destination: destination.clone(),\n-                            target: success\n-                        },\n-                        (Some(c), false) => CallKind::ConvergingCleanup {\n-                            destination: destination.clone(),\n-                            targets: (success, c)\n-                        }\n+                    cleanup: cleanup,\n+                    destination: if diverges {\n+                        None\n+                    } else {\n+                        Some ((destination.clone(), success))\n                     }\n                 });\n                 success.unit()"}, {"sha": "e6430b7d63404cbff54f12d8543b37f7bc0cedc6", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -601,7 +601,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             ty: var_ty.clone(),\n         });\n         let index = index as u32;\n-        self.schedule_drop(span, var_extent, DropKind::Deep, &Lvalue::Var(index), var_ty);\n+        self.schedule_drop(span, var_extent, &Lvalue::Var(index), var_ty);\n         self.var_indices.insert(var_id, index);\n \n         debug!(\"declare_binding: index={:?}\", index);"}, {"sha": "27654127a6c24c6ac89abdf732bfed2a8ce31f26", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 324, "deletions": 94, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -86,19 +86,48 @@ should go to.\n \n */\n \n-use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::{BlockAnd, BlockAndExtension, Builder, CFG};\n use rustc::middle::region::CodeExtent;\n use rustc::middle::lang_items;\n-use rustc::middle::subst::Substs;\n+use rustc::middle::subst::{Substs, Subst, VecPerParamSpace};\n use rustc::middle::ty::{self, Ty};\n use rustc::mir::repr::*;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::parse::token::intern_and_get_ident;\n \n pub struct Scope<'tcx> {\n     extent: CodeExtent,\n-    drops: Vec<(DropKind, Span, Lvalue<'tcx>)>,\n-    cached_block: Option<BasicBlock>,\n+    drops: Vec<DropData<'tcx>>,\n+    // A scope may only have one associated free, because:\n+    // 1. We require a `free` to only be scheduled in the scope of `EXPR` in `box EXPR`;\n+    // 2. It only makes sense to have it translated into the diverge-path.\n+    //\n+    // This kind of drop will be run *after* all the regular drops scheduled onto this scope,\n+    // because drops may have dependencies on the allocated memory.\n+    //\n+    // This is expected to go away once `box EXPR` becomes a sugar for placement protocol and gets\n+    // desugared in some earlier stage.\n+    free: Option<FreeData<'tcx>>,\n+}\n+\n+struct DropData<'tcx> {\n+    value: Lvalue<'tcx>,\n+    // NB: per-drop \u201ccache\u201d is necessary for the build_scope_drops function below.\n+    /// The cached block for the cleanups-on-diverge path. This block contains code to run the\n+    /// current drop and all the preceding drops (i.e. those having lower index in Drop\u2019s\n+    /// Scope drop array)\n+    cached_block: Option<BasicBlock>\n+}\n+\n+struct FreeData<'tcx> {\n+    span: Span,\n+    /// Lvalue containing the allocated box.\n+    value: Lvalue<'tcx>,\n+    /// type of item for which the box was allocated for (i.e. the T in Box<T>).\n+    item_ty: Ty<'tcx>,\n+    /// The cached block containing code to run the free. The block will also execute all the drops\n+    /// in the scope.\n+    cached_block: Option<BasicBlock>\n }\n \n #[derive(Clone, Debug)]\n@@ -114,7 +143,38 @@ pub struct LoopScope {\n     pub might_break: bool\n }\n \n+impl<'tcx> Scope<'tcx> {\n+    /// Invalidate all the cached blocks in the scope.\n+    ///\n+    /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n+    /// larger extent of code.\n+    fn invalidate_cache(&mut self) {\n+        for dropdata in &mut self.drops {\n+            dropdata.cached_block = None;\n+        }\n+        if let Some(ref mut freedata) = self.free {\n+            freedata.cached_block = None;\n+        }\n+    }\n+\n+    /// Returns the cached block for this scope.\n+    ///\n+    /// Precondition: the caches must be fully filled (i.e. diverge_cleanup is called) in order for\n+    /// this method to work correctly.\n+    fn cached_block(&self) -> Option<BasicBlock> {\n+        if let Some(data) = self.drops.last() {\n+            Some(data.cached_block.expect(\"drop cache is not filled\"))\n+        } else if let Some(ref data) = self.free {\n+            Some(data.cached_block.expect(\"free cache is not filled\"))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<'a,'tcx> Builder<'a,'tcx> {\n+    // Adding and removing scopes\n+    // ==========================\n     /// Start a loop scope, which tracks where `continue` and `break`\n     /// should branch to. See module comment for more details.\n     ///\n@@ -146,9 +206,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         where F: FnOnce(&mut Builder<'a, 'tcx>) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n-        self.push_scope(extent, block);\n+        self.push_scope(extent);\n         let rv = unpack!(block = f(self));\n-        self.pop_scope(extent, block);\n+        unpack!(block = self.pop_scope(extent, block));\n         debug!(\"in_scope: exiting extent={:?} block={:?}\", extent, block);\n         block.and(rv)\n     }\n@@ -157,35 +217,51 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    pub fn push_scope(&mut self, extent: CodeExtent, block: BasicBlock) {\n-        debug!(\"push_scope({:?}, {:?})\", extent, block);\n-\n-        // push scope, execute `f`, then pop scope again\n+    pub fn push_scope(&mut self, extent: CodeExtent) {\n+        debug!(\"push_scope({:?})\", extent);\n         self.scopes.push(Scope {\n             extent: extent.clone(),\n             drops: vec![],\n-            cached_block: None,\n+            free: None\n         });\n     }\n \n     /// Pops a scope, which should have extent `extent`, adding any\n     /// drops onto the end of `block` that are needed.  This must\n     /// match 1-to-1 with `push_scope`.\n-    pub fn pop_scope(&mut self, extent: CodeExtent, block: BasicBlock) {\n+    pub fn pop_scope(&mut self, extent: CodeExtent, block: BasicBlock) -> BlockAnd<()> {\n         debug!(\"pop_scope({:?}, {:?})\", extent, block);\n+        // We need to have `cached_block`s available for all the drops, so we call diverge_cleanup\n+        // to make sure all the `cached_block`s are filled in.\n+        self.diverge_cleanup();\n         let scope = self.scopes.pop().unwrap();\n-\n         assert_eq!(scope.extent, extent);\n+        build_scope_drops(block, &scope, &self.scopes[..], &mut self.cfg)\n+    }\n+\n+\n+    /// Branch out of `block` to `target`, exiting all scopes up to\n+    /// and including `extent`.  This will insert whatever drops are\n+    /// needed, as well as tracking this exit for the SEME region. See\n+    /// module comment for details.\n+    pub fn exit_scope(&mut self,\n+                      span: Span,\n+                      extent: CodeExtent,\n+                      mut block: BasicBlock,\n+                      target: BasicBlock) {\n+        let scope_count = 1 + self.scopes.iter().rev().position(|scope| scope.extent == extent)\n+                                                      .unwrap_or_else(||{\n+            self.hir.span_bug(span, &format!(\"extent {:?} does not enclose\", extent))\n+        });\n \n-        // add in any drops needed on the fallthrough path (any other\n-        // exiting paths, such as those that arise from `break`, will\n-        // have drops already)\n-        for (kind, span, lvalue) in scope.drops {\n-            self.cfg.push_drop(block, span, kind, &lvalue);\n+        for (idx, ref scope) in self.scopes.iter().enumerate().rev().take(scope_count) {\n+            unpack!(block = build_scope_drops(block, scope, &self.scopes[..idx], &mut self.cfg));\n         }\n+        self.cfg.terminate(block, Terminator::Goto { target: target });\n     }\n \n-\n+    // Finding scopes\n+    // ==============\n     /// Finds the loop scope for a given label. This is used for\n     /// resolving `break` and `continue`.\n     pub fn find_loop_scope(&mut self,\n@@ -208,30 +284,81 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }.unwrap_or_else(|| hir.span_bug(span, \"no enclosing loop scope found?\"))\n     }\n \n-    /// Branch out of `block` to `target`, exiting all scopes up to\n-    /// and including `extent`.  This will insert whatever drops are\n-    /// needed, as well as tracking this exit for the SEME region. See\n-    /// module comment for details.\n-    pub fn exit_scope(&mut self,\n-                      span: Span,\n-                      extent: CodeExtent,\n-                      block: BasicBlock,\n-                      target: BasicBlock) {\n-        let Builder { ref mut scopes, ref mut cfg, ref mut hir, .. } = *self;\n+    pub fn extent_of_innermost_scope(&self) -> CodeExtent {\n+        self.scopes.last().map(|scope| scope.extent).unwrap()\n+    }\n \n-        let scope_count = 1 + scopes.iter().rev().position(|scope| scope.extent == extent)\n-                                                 .unwrap_or_else(||{\n-            hir.span_bug(span, &format!(\"extent {:?} does not enclose\", extent))\n-        });\n+    pub fn extent_of_outermost_scope(&self) -> CodeExtent {\n+        self.scopes.first().map(|scope| scope.extent).unwrap()\n+    }\n+\n+    // Scheduling drops\n+    // ================\n+    /// Indicates that `lvalue` should be dropped on exit from\n+    /// `extent`.\n+    pub fn schedule_drop(&mut self,\n+                         span: Span,\n+                         extent: CodeExtent,\n+                         lvalue: &Lvalue<'tcx>,\n+                         lvalue_ty: Ty<'tcx>) {\n+        if !self.hir.needs_drop(lvalue_ty) {\n+            return\n+        }\n+        for scope in self.scopes.iter_mut().rev() {\n+            if scope.extent == extent {\n+                // No need to invalidate any caches here. The just-scheduled drop will branch into\n+                // the drop that comes before it in the vector.\n+                scope.drops.push(DropData {\n+                    value: lvalue.clone(),\n+                    cached_block: None\n+                });\n+                return;\n+            } else {\n+                // We must invalidate all the cached_blocks leading up to the scope we\u2019re\n+                // looking for, because all of the blocks in the chain will become incorrect.\n+                scope.invalidate_cache()\n+            }\n+        }\n+        self.hir.span_bug(span,\n+                          &format!(\"extent {:?} not in scope to drop {:?}\", extent, lvalue));\n+    }\n \n-        for scope in scopes.iter_mut().rev().take(scope_count) {\n-            for &(kind, drop_span, ref lvalue) in &scope.drops {\n-                cfg.push_drop(block, drop_span, kind, lvalue);\n+    /// Schedule dropping of a not-yet-fully-initialised box.\n+    ///\n+    /// This cleanup will only be translated into unwind branch.\n+    /// The extent should be for the `EXPR` inside `box EXPR`.\n+    /// There may only be one \u201cfree\u201d scheduled in any given scope.\n+    pub fn schedule_box_free(&mut self,\n+                             span: Span,\n+                             extent: CodeExtent,\n+                             value: &Lvalue<'tcx>,\n+                             item_ty: Ty<'tcx>) {\n+        for scope in self.scopes.iter_mut().rev() {\n+            if scope.extent == extent {\n+                assert!(scope.free.is_none(), \"scope already has a scheduled free!\");\n+                // We also must invalidate the caches in the scope for which the free is scheduled\n+                // because the drops must branch into the free we schedule here.\n+                scope.invalidate_cache();\n+                scope.free = Some(FreeData {\n+                    span: span,\n+                    value: value.clone(),\n+                    item_ty: item_ty,\n+                    cached_block: None\n+                });\n+                return;\n+            } else {\n+                // We must invalidate all the cached_blocks leading up to the scope we\u2019re looking\n+                // for, because otherwise some/most of the blocks in the chain will become\n+                // incorrect.\n+                scope.invalidate_cache();\n             }\n         }\n-        cfg.terminate(block, Terminator::Goto { target: target });\n+        self.hir.span_bug(span,\n+                          &format!(\"extent {:?} not in scope to free {:?}\", extent, value));\n     }\n \n+    // Other\n+    // =====\n     /// Creates a path that performs all required cleanup for unwinding.\n     ///\n     /// This path terminates in Resume. Returns the start of the path.\n@@ -241,64 +368,40 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         if self.scopes.is_empty() {\n             return None;\n         }\n+        let unit_temp = self.get_unit_temp();\n+        let Builder { ref mut hir, ref mut cfg, ref mut scopes, .. } = *self;\n+        let mut next_block = None;\n \n-        let mut terminator = Terminator::Resume;\n         // Given an array of scopes, we generate these from the outermost scope to the innermost\n         // one. Thus for array [S0, S1, S2] with corresponding cleanup blocks [B0, B1, B2], we will\n-        // generate B0 <- B1 <- B2 in left-to-right order. The outermost scope (B0) will always\n-        // terminate with a Resume terminator.\n-        for scope in self.scopes.iter_mut().filter(|s| !s.drops.is_empty()) {\n-            if let Some(b) = scope.cached_block {\n-                terminator = Terminator::Goto { target: b };\n-                continue;\n-            } else {\n-                let new_block = self.cfg.start_new_block();\n-                self.cfg.block_data_mut(new_block).is_cleanup = true;\n-                self.cfg.terminate(new_block, terminator);\n-                terminator = Terminator::Goto { target: new_block };\n-                for &(kind, span, ref lvalue) in scope.drops.iter().rev() {\n-                    self.cfg.push_drop(new_block, span, kind, lvalue);\n-                }\n-                scope.cached_block = Some(new_block);\n-            }\n+        // generate B0 <- B1 <- B2 in left-to-right order. Control flow of the generated blocks\n+        // always ends up at a block with the Resume terminator.\n+        for scope in scopes.iter_mut().filter(|s| !s.drops.is_empty() || s.free.is_some()) {\n+            next_block = Some(build_diverge_scope(hir.tcx(),\n+                                                  cfg,\n+                                                  unit_temp.clone(),\n+                                                  scope,\n+                                                  next_block));\n         }\n-        // Return the innermost cached block, most likely the one we just generated.\n-        // Note that if there are no cleanups in scope we return None.\n-        self.scopes.iter().rev().flat_map(|b| b.cached_block).next()\n+        scopes.iter().rev().flat_map(|x| x.cached_block()).next()\n     }\n \n-    /// Indicates that `lvalue` should be dropped on exit from\n-    /// `extent`.\n-    pub fn schedule_drop(&mut self,\n-                         span: Span,\n-                         extent: CodeExtent,\n-                         kind: DropKind,\n-                         lvalue: &Lvalue<'tcx>,\n-                         lvalue_ty: Ty<'tcx>) {\n-        if self.hir.needs_drop(lvalue_ty) {\n-            for scope in self.scopes.iter_mut().rev() {\n-                // We must invalidate all the cached_blocks leading up to the scope we\u2019re looking\n-                // for, because otherwise some/most of the blocks in the chain might become\n-                // incorrect (i.e. they still are pointing at old cached_block).\n-                scope.cached_block = None;\n-                if scope.extent == extent {\n-                    scope.drops.push((kind, span, lvalue.clone()));\n-                    return;\n-                }\n-            }\n-            self.hir.span_bug(span,\n-                              &format!(\"extent {:?} not in scope to drop {:?}\", extent, lvalue));\n-        }\n-    }\n-\n-    pub fn extent_of_innermost_scope(&self) -> CodeExtent {\n-        self.scopes.last().map(|scope| scope.extent).unwrap()\n+    /// Utility function for *non*-scope code to build their own drops\n+    pub fn build_drop(&mut self, block: BasicBlock, value: Lvalue<'tcx>) -> BlockAnd<()> {\n+        let next_target = self.cfg.start_new_block();\n+        let diverge_target = self.diverge_cleanup();\n+        self.cfg.terminate(block, Terminator::Drop {\n+            value: value,\n+            target: next_target,\n+            unwind: diverge_target,\n+        });\n+        next_target.unit()\n     }\n \n-    pub fn extent_of_outermost_scope(&self) -> CodeExtent {\n-        self.scopes.first().map(|scope| scope.extent).unwrap()\n-    }\n \n+    // Panicking\n+    // =========\n+    // FIXME: should be moved into their own module\n     pub fn panic_bounds_check(&mut self,\n                              block: BasicBlock,\n                              index: Operand<'tcx>,\n@@ -328,10 +431,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         self.cfg.terminate(block, Terminator::Call {\n             func: Operand::Constant(func),\n             args: vec![Operand::Consume(tuple_ref), index, len],\n-            kind: match cleanup {\n-                None => CallKind::Diverging,\n-                Some(c) => CallKind::DivergingCleanup(c)\n-            }\n+            destination: None,\n+            cleanup: cleanup,\n         });\n     }\n \n@@ -368,10 +469,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         self.cfg.terminate(block, Terminator::Call {\n             func: Operand::Constant(func),\n             args: vec![Operand::Consume(tuple_ref)],\n-            kind: match cleanup {\n-                None => CallKind::Diverging,\n-                Some(c) => CallKind::DivergingCleanup(c)\n-            }\n+            cleanup: cleanup,\n+            destination: None,\n         });\n     }\n \n@@ -405,4 +504,135 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             literal: self.hir.usize_literal(span_lines.line)\n         })\n     }\n+\n+}\n+\n+/// Builds drops for pop_scope and exit_scope.\n+fn build_scope_drops<'tcx>(mut block: BasicBlock,\n+                           scope: &Scope<'tcx>,\n+                           earlier_scopes: &[Scope<'tcx>],\n+                           cfg: &mut CFG<'tcx>)\n+                           -> BlockAnd<()> {\n+    let mut iter = scope.drops.iter().rev().peekable();\n+    while let Some(drop_data) = iter.next() {\n+        // Try to find the next block with its cached block for us to diverge into in case the\n+        // drop panics.\n+        let on_diverge = iter.peek().iter().flat_map(|dd| dd.cached_block.into_iter()).next();\n+        // If there\u2019s no `cached_block`s within current scope, we must look for one in the\n+        // enclosing scope.\n+        let on_diverge = on_diverge.or_else(||{\n+            earlier_scopes.iter().rev().flat_map(|s| s.cached_block()).next()\n+        });\n+        let next = cfg.start_new_block();\n+        cfg.terminate(block, Terminator::Drop {\n+            value: drop_data.value.clone(),\n+            target: next,\n+            unwind: on_diverge\n+        });\n+        block = next;\n+    }\n+    block.unit()\n+}\n+\n+fn build_diverge_scope<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                             cfg: &mut CFG<'tcx>,\n+                             unit_temp: Lvalue<'tcx>,\n+                             scope: &mut Scope<'tcx>,\n+                             target: Option<BasicBlock>)\n+                             -> BasicBlock {\n+    debug_assert!(!scope.drops.is_empty() || scope.free.is_some());\n+\n+    // First, we build the drops, iterating the drops array in reverse. We do that so that as soon\n+    // as we find a `cached_block`, we know that we\u2019re finished and don\u2019t need to do anything else.\n+    let mut previous = None;\n+    let mut last_drop_block = None;\n+    for drop_data in scope.drops.iter_mut().rev() {\n+        if let Some(cached_block) = drop_data.cached_block {\n+            if let Some((previous_block, previous_value)) = previous {\n+                cfg.terminate(previous_block, Terminator::Drop {\n+                    value: previous_value,\n+                    target: cached_block,\n+                    unwind: None\n+                });\n+                return last_drop_block.unwrap();\n+            } else {\n+                return cached_block;\n+            }\n+        } else {\n+            let block = cfg.start_new_cleanup_block();\n+            drop_data.cached_block = Some(block);\n+            if let Some((previous_block, previous_value)) = previous {\n+                cfg.terminate(previous_block, Terminator::Drop {\n+                    value: previous_value,\n+                    target: block,\n+                    unwind: None\n+                });\n+            } else {\n+                last_drop_block = Some(block);\n+            }\n+            previous = Some((block, drop_data.value.clone()));\n+        }\n+    }\n+\n+    // Prepare the end target for this chain.\n+    let mut target = target.unwrap_or_else(||{\n+        let b = cfg.start_new_cleanup_block();\n+        cfg.terminate(b, Terminator::Resume);\n+        b\n+    });\n+\n+    // Then, build the free branching into the prepared target.\n+    if let Some(ref mut free_data) = scope.free {\n+        target = if let Some(cached_block) = free_data.cached_block {\n+            cached_block\n+        } else {\n+            let t = build_free(tcx, cfg, unit_temp, free_data, target);\n+            free_data.cached_block = Some(t);\n+            t\n+        }\n+    };\n+\n+    if let Some((previous_block, previous_value)) = previous {\n+        // Finally, branch into that just-built `target` from the `previous_block`.\n+        cfg.terminate(previous_block, Terminator::Drop {\n+            value: previous_value,\n+            target: target,\n+            unwind: None\n+        });\n+        last_drop_block.unwrap()\n+    } else {\n+        // If `previous.is_none()`, there were no drops in this scope \u2013 we return the\n+        // target.\n+        target\n+    }\n+}\n+\n+fn build_free<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                    cfg: &mut CFG<'tcx>,\n+                    unit_temp: Lvalue<'tcx>,\n+                    data: &FreeData<'tcx>,\n+                    target: BasicBlock)\n+                    -> BasicBlock {\n+    let free_func = tcx.lang_items.box_free_fn()\n+                       .expect(\"box_free language item is missing\");\n+    let substs = tcx.mk_substs(Substs::new(\n+        VecPerParamSpace::new(vec![], vec![], vec![data.item_ty]),\n+        VecPerParamSpace::new(vec![], vec![], vec![])\n+    ));\n+    let block = cfg.start_new_cleanup_block();\n+    cfg.terminate(block, Terminator::Call {\n+        func: Operand::Constant(Constant {\n+            span: data.span,\n+            ty: tcx.lookup_item_type(free_func).ty.subst(tcx, substs),\n+            literal: Literal::Item {\n+                def_id: free_func,\n+                kind: ItemKind::Function,\n+                substs: substs\n+            }\n+        }),\n+        args: vec![Operand::Consume(data.value.clone())],\n+        destination: Some((unit_temp, target)),\n+        cleanup: None\n+    });\n+    block\n }"}, {"sha": "6c0f1c7081be8f44c47a7cd3da41483bb11df4d6", "filename": "src/librustc_mir/build/stmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -42,16 +42,16 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 None => {\n                     let (extent, _) = stmt_lists.pop().unwrap();\n                     if let Some(extent) = extent {\n-                        this.pop_scope(extent, block);\n+                        unpack!(block = this.pop_scope(extent, block));\n                     }\n                     continue\n                 }\n             };\n \n-            let Stmt { span, kind } = this.hir.mirror(stmt);\n+            let Stmt { span: _, kind } = this.hir.mirror(stmt);\n             match kind {\n                 StmtKind::Let { remainder_scope, init_scope, pattern, initializer, stmts } => {\n-                    this.push_scope(remainder_scope, block);\n+                    this.push_scope(remainder_scope);\n                     stmt_lists.push((Some(remainder_scope), stmts.into_iter()));\n                     unpack!(block = this.in_scope(init_scope, block, move |this| {\n                         // FIXME #30046                              ^~~~\n@@ -72,7 +72,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         let expr = this.hir.mirror(expr);\n                         let temp = this.temp(expr.ty.clone());\n                         unpack!(block = this.into(&temp, block, expr));\n-                        this.cfg.push_drop(block, span, DropKind::Deep, &temp);\n+                        unpack!(block = this.build_drop(block, temp));\n                         block.unit()\n                     }));\n                 }"}, {"sha": "f9a9c99f63d5e23fad2b3033c6e1343632b0277d", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -375,7 +375,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             hir::ExprType(ref source, _) =>\n                 return source.make_mirror(cx),\n             hir::ExprBox(ref value) =>\n-                ExprKind::Box { value: value.to_ref() },\n+                ExprKind::Box {\n+                    value: value.to_ref(),\n+                    value_extents: cx.tcx.region_maps.node_extent(value.id)\n+                },\n             hir::ExprVec(ref fields) =>\n                 ExprKind::Vec { fields: fields.to_ref() },\n             hir::ExprTup(ref fields) =>"}, {"sha": "0891c2845b0ba66537a2ca868b6a153a673f8036", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -123,6 +123,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Box {\n         value: ExprRef<'tcx>,\n+        value_extents: CodeExtent,\n     },\n     Call {\n         ty: ty::Ty<'tcx>,"}, {"sha": "d0dbdeb033db216db97c9d3b7b5ad4cd1349b0c3", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -69,9 +69,6 @@ impl<'a, 'tcx> EraseRegions<'a, 'tcx> {\n                 self.erase_regions_lvalue(lvalue);\n                 self.erase_regions_rvalue(rvalue);\n             }\n-            StatementKind::Drop(_, ref mut lvalue) => {\n-                self.erase_regions_lvalue(lvalue);\n-            }\n         }\n     }\n \n@@ -93,8 +90,11 @@ impl<'a, 'tcx> EraseRegions<'a, 'tcx> {\n                 self.erase_regions_lvalue(discr);\n                 *switch_ty = self.tcx.erase_regions(switch_ty);\n             },\n-            Terminator::Call { ref mut func, ref mut args, ref mut kind } => {\n-                if let Some(destination) = kind.destination_mut() {\n+            Terminator::Drop { ref mut value, .. } => {\n+                self.erase_regions_lvalue(value);\n+            }\n+            Terminator::Call { ref mut func, ref mut args, ref mut destination, .. } => {\n+                if let Some((ref mut destination, _)) = *destination {\n                     self.erase_regions_lvalue(destination);\n                 }\n                 self.erase_regions_operand(func);"}, {"sha": "9d4c73b90f81a6fef0c5caf06003c34298fcd59f", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -29,7 +29,7 @@ impl SimplifyCfg {\n \n         let mut worklist = vec![START_BLOCK];\n         while let Some(bb) = worklist.pop() {\n-            for succ in mir.basic_block_data(bb).terminator().successors() {\n+            for succ in mir.basic_block_data(bb).terminator().successors().iter() {\n                 if !seen[succ.index()] {\n                     seen[succ.index()] = true;\n                     worklist.push(*succ);"}, {"sha": "5be585c4189e162e2494e07e7ac113c774a6d6b2", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 48, "deletions": 28, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -18,10 +18,11 @@ use trans::base;\n use trans::build;\n use trans::common::{self, Block, LandingPad};\n use trans::debuginfo::DebugLoc;\n+use trans::Disr;\n use trans::foreign;\n+use trans::glue;\n use trans::type_of;\n use trans::type_::Type;\n-use trans::Disr;\n \n use super::MirContext;\n use super::operand::OperandValue::{FatPtr, Immediate, Ref};\n@@ -94,7 +95,39 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 base::build_return_block(bcx.fcx, bcx, return_ty, DebugLoc::None);\n             }\n \n-            mir::Terminator::Call { ref func, ref args, ref kind } => {\n+            mir::Terminator::Drop { ref value, target, unwind } => {\n+                let lvalue = self.trans_lvalue(bcx, value);\n+                let ty = lvalue.ty.to_ty(bcx.tcx());\n+                // Double check for necessity to drop\n+                if !glue::type_needs_drop(bcx.tcx(), ty) {\n+                    build::Br(bcx, self.llblock(target), DebugLoc::None);\n+                    return;\n+                }\n+                let drop_fn = glue::get_drop_glue(bcx.ccx(), ty);\n+                let drop_ty = glue::get_drop_glue_type(bcx.ccx(), ty);\n+                let llvalue = if drop_ty != ty {\n+                    build::PointerCast(bcx, lvalue.llval,\n+                                       type_of::type_of(bcx.ccx(), drop_ty).ptr_to())\n+                } else {\n+                    lvalue.llval\n+                };\n+                if let Some(unwind) = unwind {\n+                    let uwbcx = self.bcx(unwind);\n+                    let unwind = self.make_landing_pad(uwbcx);\n+                    build::Invoke(bcx,\n+                                  drop_fn,\n+                                  &[llvalue],\n+                                  self.llblock(target),\n+                                  unwind.llbb,\n+                                  None,\n+                                  DebugLoc::None);\n+                } else {\n+                    build::Call(bcx, drop_fn, &[llvalue], None, DebugLoc::None);\n+                    build::Br(bcx, self.llblock(target), DebugLoc::None);\n+                }\n+            }\n+\n+            mir::Terminator::Call { ref func, ref args, ref destination, ref cleanup } => {\n                 // Create the callee. This will always be a fn ptr and hence a kind of scalar.\n                 let callee = self.trans_operand(bcx, func);\n                 let attrs = attributes::from_fn_type(bcx.ccx(), callee.ty);\n@@ -115,7 +148,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 };\n \n                 // Prepare the return value destination\n-                let (ret_dest_ty, must_copy_dest) = if let Some(d) = kind.destination() {\n+                let (ret_dest_ty, must_copy_dest) = if let Some((ref d, _)) = *destination {\n                     let dest = self.trans_lvalue(bcx, d);\n                     let ret_ty = dest.ty.to_ty(bcx.tcx());\n                     if !is_foreign && type_of::return_uses_outptr(bcx.ccx(), ret_ty) {\n@@ -144,9 +177,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 }\n \n                 // Many different ways to call a function handled here\n-                match (is_foreign, base::avoid_invoke(bcx), kind) {\n+                match (is_foreign, base::avoid_invoke(bcx), cleanup, destination) {\n                     // The two cases below are the only ones to use LLVM\u2019s `invoke`.\n-                    (false, false, &mir::CallKind::DivergingCleanup(cleanup)) => {\n+                    (false, false, &Some(cleanup), &None) => {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n                         let unreachable_blk = self.unreachable_block();\n@@ -158,14 +191,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                       Some(attrs),\n                                       debugloc);\n                     },\n-                    (false, false, &mir::CallKind::ConvergingCleanup { ref targets, .. }) => {\n-                        let cleanup = self.bcx(targets.1);\n+                    (false, false, &Some(cleanup), &Some((_, success))) => {\n+                        let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n                         let (target, postinvoke) = if must_copy_dest {\n-                            (bcx.fcx.new_block(\"\", None),\n-                             Some(self.bcx(targets.0)))\n+                            (bcx.fcx.new_block(\"\", None), Some(self.bcx(success)))\n                         } else {\n-                            (self.bcx(targets.0), None)\n+                            (self.bcx(success), None)\n                         };\n                         let invokeret = build::Invoke(bcx,\n                                                       callee.immediate(),\n@@ -205,19 +237,11 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             build::Br(target, postinvoketarget.llbb, debugloc);\n                         }\n                     },\n-                    (false, _, &mir::CallKind::DivergingCleanup(_)) |\n-                    (false, _, &mir::CallKind::Diverging) => {\n+                    (false, _, _, &None) => {\n                         build::Call(bcx, callee.immediate(), &llargs[..], Some(attrs), debugloc);\n                         build::Unreachable(bcx);\n                     }\n-                    (false, _, k@&mir::CallKind::ConvergingCleanup { .. }) |\n-                    (false, _, k@&mir::CallKind::Converging { .. }) => {\n-                        // FIXME: Bug #20046\n-                        let target = match *k {\n-                            mir::CallKind::ConvergingCleanup { targets, .. } => targets.0,\n-                            mir::CallKind::Converging { target, .. } => target,\n-                            _ => unreachable!()\n-                        };\n+                    (false, _, _, &Some((_, target))) => {\n                         let llret = build::Call(bcx,\n                                                 callee.immediate(),\n                                                 &llargs[..],\n@@ -231,7 +255,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         build::Br(bcx, self.llblock(target), debugloc);\n                     }\n                     // Foreign functions\n-                    (true, _, k) => {\n+                    (true, _, _, destination) => {\n                         let (dest, _) = ret_dest_ty\n                             .expect(\"return destination is not set\");\n                         bcx = foreign::trans_native_call(bcx,\n@@ -241,13 +265,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                    &llargs[..],\n                                                    arg_tys,\n                                                    debugloc);\n-                        match *k {\n-                            mir::CallKind::ConvergingCleanup { targets, .. } =>\n-                                build::Br(bcx, self.llblock(targets.0), debugloc),\n-                            mir::CallKind::Converging { target, .. } =>\n-                                build::Br(bcx, self.llblock(target), debugloc),\n-                            _ => ()\n-                        };\n+                        if let Some((_, target)) = *destination {\n+                            build::Br(bcx, self.llblock(target), debugloc);\n+                        }\n                     },\n                 }\n             }"}, {"sha": "3b763599f777290e4ab90b8f21dbea56383439bb", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -82,13 +82,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           constant: &mir::Constant<'tcx>)\n                           -> OperandRef<'tcx>\n     {\n-        let ty = bcx.monomorphize(&constant.ty);\n         match constant.literal {\n             mir::Literal::Item { def_id, kind, substs } => {\n                 let substs = bcx.tcx().mk_substs(bcx.monomorphize(&substs));\n-                self.trans_item_ref(bcx, ty, kind, substs, def_id)\n+                self.trans_item_ref(bcx, constant.ty, kind, substs, def_id)\n             }\n             mir::Literal::Value { ref value } => {\n+                let ty = bcx.monomorphize(&constant.ty);\n                 self.trans_constval(bcx, value, ty)\n             }\n         }"}, {"sha": "d994f1ea7b0b761d56b86606cfc80bea7937ec7b", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -65,7 +65,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 assert!(lvalue.llextra != ptr::null_mut());\n                 lvalue.llextra\n             }\n-            _ => bcx.sess().bug(\"unexpected type in get_base_and_len\"),\n+            _ => bcx.sess().bug(\"unexpected type in lvalue_len\"),\n         }\n     }\n "}, {"sha": "b19ecc45a4e5e98a2d501f68c08d4cc425f79a2a", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -195,8 +195,8 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>,\n mod analyze;\n mod block;\n mod constant;\n+mod did;\n mod lvalue;\n-mod rvalue;\n mod operand;\n+mod rvalue;\n mod statement;\n-mod did;"}, {"sha": "fc8885647377c685c169bd5e88556e1d171ce280", "filename": "src/librustc_trans/trans/mir/statement.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::middle::ty::LvaluePreference;\n use rustc::mir::repr as mir;\n use trans::common::Block;\n-use trans::debuginfo::DebugLoc;\n-use trans::glue;\n \n use super::MirContext;\n use super::TempRef;\n@@ -51,20 +48,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     }\n                 }\n             }\n-\n-            mir::StatementKind::Drop(mir::DropKind::Deep, ref lvalue) => {\n-                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n-                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n-                glue::drop_ty(bcx, tr_lvalue.llval, ty, DebugLoc::None)\n-            }\n-\n-            mir::StatementKind::Drop(mir::DropKind::Free, ref lvalue) => {\n-                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n-                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n-                let content_ty = ty.builtin_deref(true, LvaluePreference::NoPreference);\n-                let content_ty = content_ty.unwrap().ty;\n-                glue::trans_exchange_free_ty(bcx, tr_lvalue.llval, content_ty, DebugLoc::None)\n-            }\n         }\n     }\n }"}, {"sha": "df20700e01628b3f90adb8c3245f6832fd833b46", "filename": "src/test/run-fail/mir_drop_panics.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Ftest%2Frun-fail%2Fmir_drop_panics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f/src%2Ftest%2Frun-fail%2Fmir_drop_panics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_drop_panics.rs?ref=5147c1f2c04f62dceea5feaf6a2dcbebf5cd638f", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(rustc_attrs)]\n+\n+// ignore-msvc: FIXME(#30941)\n+// error-pattern:panic 1\n+// error-pattern:drop 2\n+use std::io::{self, Write};\n+\n+struct Droppable(u32);\n+impl Drop for Droppable {\n+    fn drop(&mut self) {\n+        if self.0 == 1 {\n+            panic!(\"panic 1\");\n+        } else {\n+            write!(io::stderr(), \"drop {}\", self.0);\n+        }\n+    }\n+}\n+\n+#[rustc_mir]\n+fn mir() {\n+    let x = Droppable(2);\n+    let y = Droppable(1);\n+}\n+\n+fn main() {\n+    mir();\n+}"}]}