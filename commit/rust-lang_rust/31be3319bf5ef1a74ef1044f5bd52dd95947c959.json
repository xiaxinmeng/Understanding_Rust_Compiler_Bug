{"sha": "31be3319bf5ef1a74ef1044f5bd52dd95947c959", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxYmUzMzE5YmY1ZWYxYTc0ZWYxMDQ0ZjViZDUyZGQ5NTk0N2M5NTk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-22T15:24:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-22T15:24:14Z"}, "message": "collections: Deprecate shift_char for insert/remove\n\nThis commit deprecates the String::shift_char() function in favor of the\naddition of an insert()/remove() pair of functions. This aligns the API with Vec\nin that characters can be inserted at arbitrary positions.  Additionaly, there\nis no `_char` suffix due to the rationaled laid out in the previous commit.\n\nThese functions are both introduced as unstable as their failure semantics,\nwhile in line with slices/vectors, are uncertain about whether they should\nremain the same.", "tree": {"sha": "48b8f9f68a9db9d61cdb7ed71d916e07c0e13fc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48b8f9f68a9db9d61cdb7ed71d916e07c0e13fc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31be3319bf5ef1a74ef1044f5bd52dd95947c959", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31be3319bf5ef1a74ef1044f5bd52dd95947c959", "html_url": "https://github.com/rust-lang/rust/commit/31be3319bf5ef1a74ef1044f5bd52dd95947c959", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31be3319bf5ef1a74ef1044f5bd52dd95947c959/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79b4ce06ae8be58fcf09aa96afea4bed6d487db5", "url": "https://api.github.com/repos/rust-lang/rust/commits/79b4ce06ae8be58fcf09aa96afea4bed6d487db5", "html_url": "https://github.com/rust-lang/rust/commit/79b4ce06ae8be58fcf09aa96afea4bed6d487db5"}], "stats": {"total": 102, "additions": 87, "deletions": 15}, "files": [{"sha": "cdb6ba1bcd705d716ccf7a09c2604f9e7d09ace5", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 87, "deletions": 15, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/31be3319bf5ef1a74ef1044f5bd52dd95947c959/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31be3319bf5ef1a74ef1044f5bd52dd95947c959/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=31be3319bf5ef1a74ef1044f5bd52dd95947c959", "patch": "@@ -727,37 +727,80 @@ impl String {\n         self.vec.remove(0)\n     }\n \n-    /// Removes the first character from the string buffer and returns it.\n-    /// Returns `None` if this string buffer is empty.\n+    /// Deprecated, call `remove(0)` instead\n+    #[deprecated = \"call .remove(0) instead\"]\n+    pub fn shift_char(&mut self) -> Option<char> {\n+        self.remove(0)\n+    }\n+\n+    /// Removes the character from the string buffer at byte position `idx` and\n+    /// returns it. Returns `None` if `idx` is out of bounds.\n     ///\n     /// # Warning\n     ///\n-    /// This is a O(n) operation as it requires copying every element in the buffer.\n+    /// This is a O(n) operation as it requires copying every element in the\n+    /// buffer.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If `idx` does not lie on a character boundary, then this function will\n+    /// fail.\n     ///\n     /// # Example\n     ///\n     /// ```\n     /// let mut s = String::from_str(\"foo\");\n-    /// assert_eq!(s.shift_char(), Some('f'));\n-    /// assert_eq!(s.shift_char(), Some('o'));\n-    /// assert_eq!(s.shift_char(), Some('o'));\n-    /// assert_eq!(s.shift_char(), None);\n+    /// assert_eq!(s.remove(0), Some('f'));\n+    /// assert_eq!(s.remove(1), Some('o'));\n+    /// assert_eq!(s.remove(0), Some('o'));\n+    /// assert_eq!(s.remove(0), None);\n     /// ```\n-    pub fn shift_char(&mut self) -> Option<char> {\n+    #[unstable = \"the failure semantics of this function and return type \\\n+                  may change\"]\n+    pub fn remove(&mut self, idx: uint) -> Option<char> {\n         let len = self.len();\n-        if len == 0 {\n-            return None\n-        }\n+        if idx >= len { return None }\n \n-        let CharRange {ch, next} = self.as_slice().char_range_at(0);\n-        let new_len = len - next;\n+        let CharRange { ch, next } = self.as_slice().char_range_at(idx);\n         unsafe {\n-            ptr::copy_memory(self.vec.as_mut_ptr(), self.vec.as_ptr().offset(next as int), new_len);\n-            self.vec.set_len(new_len);\n+            ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as int),\n+                             self.vec.as_ptr().offset(next as int),\n+                             len - next);\n+            self.vec.set_len(len - (next - idx));\n         }\n         Some(ch)\n     }\n \n+    /// Insert a character into the string buffer at byte position `idx`.\n+    ///\n+    /// # Warning\n+    ///\n+    /// This is a O(n) operation as it requires copying every element in the\n+    /// buffer.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If `idx` does not lie on a character boundary or is out of bounds, then\n+    /// this function will fail.\n+    pub fn insert(&mut self, idx: uint, ch: char) {\n+        let len = self.len();\n+        assert!(idx <= len);\n+        assert!(self.as_slice().is_char_boundary(idx));\n+        self.vec.reserve_additional(4);\n+        let mut bits = [0, ..4];\n+        let amt = ch.encode_utf8(bits).unwrap();\n+\n+        unsafe {\n+            ptr::copy_memory(self.vec.as_mut_ptr().offset((idx + amt) as int),\n+                             self.vec.as_ptr().offset(idx as int),\n+                             len - idx);\n+            ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as int),\n+                             bits.as_ptr(),\n+                             amt);\n+            self.vec.set_len(len + amt);\n+        }\n+    }\n+\n     /// Views the string buffer as a mutable sequence of bytes.\n     ///\n     /// This is unsafe because it does not check\n@@ -1209,6 +1252,35 @@ mod tests {\n         assert_eq!(b.as_slice(), \"1234522\");\n     }\n \n+    #[test]\n+    fn remove() {\n+        let mut s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\".to_string();;\n+        assert_eq!(s.remove(0), Some('\u0e28'));\n+        assert_eq!(s.len(), 33);\n+        assert_eq!(s.as_slice(), \"\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\");\n+        assert_eq!(s.remove(33), None);\n+        assert_eq!(s.remove(300), None);\n+        assert_eq!(s.remove(17), Some('\u1ec7'));\n+        assert_eq!(s.as_slice(), \"\u0e44\u0e17\u0e22\u4e2d\u534eVit Nam; foobar\");\n+    }\n+\n+    #[test] #[should_fail]\n+    fn remove_bad() {\n+        \"\u0e28\".to_string().remove(1);\n+    }\n+\n+    #[test]\n+    fn insert() {\n+        let mut s = \"foobar\".to_string();\n+        s.insert(0, '\u1ec7');\n+        assert_eq!(s.as_slice(), \"\u1ec7foobar\");\n+        s.insert(6, '\u0e22');\n+        assert_eq!(s.as_slice(), \"\u1ec7foo\u0e22bar\");\n+    }\n+\n+    #[test] #[should_fail] fn insert_bad1() { \"\".to_string().insert(1, 't'); }\n+    #[test] #[should_fail] fn insert_bad2() { \"\u1ec7\".to_string().insert(1, 't'); }\n+\n     #[bench]\n     fn bench_with_capacity(b: &mut Bencher) {\n         b.iter(|| {"}]}