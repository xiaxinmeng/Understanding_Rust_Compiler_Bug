{"sha": "4d17fbaf37a0641894317f016244943af66ce87b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMTdmYmFmMzdhMDY0MTg5NDMxN2YwMTYyNDQ5NDNhZjY2Y2U4N2I=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-01-10T18:21:27Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-01-11T04:19:02Z"}, "message": "Add ability to attach custom #[on_unimplemented] error messages for unimplemented traits (fixes #20783)", "tree": {"sha": "c50c34e10a3cb3816f454a69a6c9119f3a98fee2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c50c34e10a3cb3816f454a69a6c9119f3a98fee2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d17fbaf37a0641894317f016244943af66ce87b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d17fbaf37a0641894317f016244943af66ce87b", "html_url": "https://github.com/rust-lang/rust/commit/4d17fbaf37a0641894317f016244943af66ce87b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d17fbaf37a0641894317f016244943af66ce87b/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14f9d1f256e643e65f42737c7d3174bcc7a75abb", "url": "https://api.github.com/repos/rust-lang/rust/commits/14f9d1f256e643e65f42737c7d3174bcc7a75abb", "html_url": "https://github.com/rust-lang/rust/commit/14f9d1f256e643e65f42737c7d3174bcc7a75abb"}], "stats": {"total": 131, "additions": 130, "deletions": 1}, "files": [{"sha": "e22de10a974f02a7df795881b62c5c48418099d9", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d17fbaf37a0641894317f016244943af66ce87b/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d17fbaf37a0641894317f016244943af66ce87b/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=4d17fbaf37a0641894317f016244943af66ce87b", "patch": "@@ -101,6 +101,8 @@ pub trait Iterator {\n \n /// Conversion from an `Iterator`\n #[stable]\n+#[on_unimplemented=\"a collection of type `{Self}` cannot be \\\n+                    built from an iterator over elements of type `{A}`\"]\n pub trait FromIterator<A> {\n     /// Build a container with elements from an external iterator.\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;"}, {"sha": "e720a5df5980741b9b0d8046dce765017a6bbb1d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d17fbaf37a0641894317f016244943af66ce87b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d17fbaf37a0641894317f016244943af66ce87b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=4d17fbaf37a0641894317f016244943af66ce87b", "patch": "@@ -32,6 +32,7 @@\n \n extern crate arena;\n extern crate flate;\n+extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n extern crate libc;"}, {"sha": "300b9aaf10060cf02b68f92c3786cda435dd2ba1", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d17fbaf37a0641894317f016244943af66ce87b/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d17fbaf37a0641894317f016244943af66ce87b/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=4d17fbaf37a0641894317f016244943af66ce87b", "patch": "@@ -666,6 +666,7 @@ impl LintPass for UnusedAttributes {\n             \"must_use\",\n             \"stable\",\n             \"unstable\",\n+            \"on_unimplemented\",\n \n             // FIXME: #19470 this shouldn't be needed forever\n             \"old_orphan_check\","}, {"sha": "8903667505b328f77cb9122289b541a54f873a57", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4d17fbaf37a0641894317f016244943af66ce87b/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d17fbaf37a0641894317f016244943af66ce87b/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=4d17fbaf37a0641894317f016244943af66ce87b", "patch": "@@ -18,9 +18,12 @@ use super::{\n     SelectionError,\n };\n \n+use fmt_macros::{Parser, Piece, Position};\n use middle::infer::InferCtxt;\n-use middle::ty::{self, AsPredicate, ReferencesError, ToPolyTraitRef};\n+use middle::ty::{self, AsPredicate, ReferencesError, ToPolyTraitRef, TraitRef};\n+use std::collections::HashMap;\n use syntax::codemap::Span;\n+use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use util::ppaux::{Repr, UserString};\n \n pub fn report_fulfillment_errors<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n@@ -62,6 +65,69 @@ pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n+fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                     trait_ref: &TraitRef<'tcx>) -> Option<String> {\n+    let def_id = trait_ref.def_id;\n+    let mut report = None;\n+    ty::each_attr(infcx.tcx, def_id, |item| {\n+        if item.check_name(\"on_unimplemented\") {\n+            if let Some(ref istring) = item.value_str() {\n+                let def = ty::lookup_trait_def(infcx.tcx, def_id);\n+                let mut generic_map = def.generics.types.iter_enumerated()\n+                                         .map(|(param, i, gen)| {\n+                                               (gen.name.as_str().to_string(),\n+                                                trait_ref.substs.types.get(param, i)\n+                                                         .user_string(infcx.tcx))\n+                                              }).collect::<HashMap<String, String>>();\n+                generic_map.insert(\"Self\".to_string(),\n+                                   trait_ref.self_ty().user_string(infcx.tcx));\n+                let parser = Parser::new(istring.get());\n+                let mut errored = false;\n+                let err: String = parser.filter_map(|p| {\n+                    match p {\n+                        Piece::String(s) => Some(s),\n+                        Piece::NextArgument(a) => match a.position {\n+                            Position::ArgumentNamed(s) => match generic_map.get(s) {\n+                                Some(val) => Some(val.as_slice()),\n+                                None => {\n+                                    infcx.tcx.sess\n+                                         .span_err(item.meta().span,\n+                                                   format!(\"there is no type parameter \\\n+                                                            {} on trait {}\",\n+                                                           s, def.trait_ref\n+                                                                 .user_string(infcx.tcx))\n+                                                   .as_slice());\n+                                    errored = true;\n+                                    None\n+                                }\n+                            },\n+                            _ => {\n+                                infcx.tcx.sess.span_err(item.meta().span,\n+                                                        \"only named substitution \\\n+                                                        parameters are allowed\");\n+                                errored = true;\n+                                None\n+                            }\n+                        }\n+                    }\n+                }).collect();\n+                // Report only if the format string checks out\n+                if !errored {\n+                    report = Some(err);\n+                }\n+            } else {\n+                infcx.tcx.sess.span_err(item.meta().span,\n+                                        \"this attribute must have a value, \\\n+                                        eg `#[on_unimplemented = \\\"foo\\\"]`\")\n+            }\n+            false\n+        } else {\n+            true\n+        }\n+    });\n+    report\n+}\n+\n pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                         obligation: &PredicateObligation<'tcx>,\n                                         error: &SelectionError<'tcx>)\n@@ -88,12 +154,20 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         infcx.resolve_type_vars_if_possible(trait_predicate);\n                     if !trait_predicate.references_error() {\n                         let trait_ref = trait_predicate.to_poly_trait_ref();\n+                        // Check if it has a custom \"#[on_unimplemented]\" error message,\n+                        // report with that message if it does\n+                        let custom_note = report_on_unimplemented(infcx, &*trait_ref.0);\n                         infcx.tcx.sess.span_err(\n                             obligation.cause.span,\n                             format!(\n                                 \"the trait `{}` is not implemented for the type `{}`\",\n                                 trait_ref.user_string(infcx.tcx),\n                                 trait_ref.self_ty().user_string(infcx.tcx)).as_slice());\n+                        if let Some(s) = custom_note {\n+                           infcx.tcx.sess.span_note(\n+                                obligation.cause.span,\n+                                s.as_slice());\n+                        }\n                     }\n                 }\n "}, {"sha": "5a56e91cdda80b2cc0dc0bf44f7c1821aa219460", "filename": "src/test/compile-fail/on-unimplemented.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4d17fbaf37a0641894317f016244943af66ce87b/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d17fbaf37a0641894317f016244943af66ce87b/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs?ref=4d17fbaf37a0641894317f016244943af66ce87b", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+// ignore-tidy-linelength\n+\n+#[on_unimplemented = \"test error `{Self}` with `{Bar}` `{Baz}` `{Quux}`\"]\n+trait Foo<Bar, Baz, Quux>{}\n+\n+fn foobar<U: Clone, T: Foo<u8, U, u32>>() -> T {\n+\n+}\n+\n+#[on_unimplemented=\"a collection of type `{Self}` cannot be built from an iterator over elements of type `{A}`\"]\n+trait MyFromIterator<A> {\n+    /// Build a container with elements from an external iterator.\n+    fn my_from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n+}\n+\n+fn collect<A, I: Iterator<Item=A>, B: MyFromIterator<A>>(it: I) -> B {\n+    MyFromIterator::my_from_iter(it)\n+}\n+\n+#[on_unimplemented] //~ ERROR this attribute must have a value\n+trait BadAnnotation1 {}\n+\n+#[on_unimplemented = \"Unimplemented trait error on `{Self}` with params `<{A},{B},{C}>`\"]\n+//~^ ERROR there is no type parameter C on trait BadAnnotation2<A, B>\n+trait BadAnnotation2<A,B> {}\n+\n+fn trigger1<T: BadAnnotation1>(t: T)  {}\n+fn trigger2<A, B, T: BadAnnotation2<A,B>>(t: T) {}\n+\n+pub fn main() {\n+    let x = vec!(1u8, 2, 3, 4);\n+    let y: Option<Vec<u8>> = collect(x.iter()); // this should give approximately the same error for x.iter().collect()\n+    //~^ ERROR\n+    //~^^ NOTE a collection of type `core::option::Option<collections::vec::Vec<u8>>` cannot be built from an iterator over elements of type `&u8`\n+    let x: String = foobar(); //~ ERROR\n+    //~^ NOTE test error `collections::string::String` with `u8` `_` `u32`\n+\n+    // The following two have errors in their annotations, so the regular error should be thrown\n+    trigger1(1u8); //~ ERROR the trait `BadAnnotation1` is not implemented for the type `u8`\n+    trigger2::<u8, u8, u8>(1u8); //~ ERROR the trait `BadAnnotation2<u8, u8>` is not implemented\n+\n+}"}]}