{"sha": "9738c2a45c03034f937a0b2ce7a690f64e7662eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MzhjMmE0NWMwMzAzNGY5MzdhMGIyY2U3YTY5MGY2NGU3NjYyZWI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-16T23:11:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-19T18:56:52Z"}, "message": "test: Rewrite nbody and spectralnorm shootout benchmarks", "tree": {"sha": "b8c0a235db5a91a0d476c76cab6e018ff76aafab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8c0a235db5a91a0d476c76cab6e018ff76aafab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9738c2a45c03034f937a0b2ce7a690f64e7662eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9738c2a45c03034f937a0b2ce7a690f64e7662eb", "html_url": "https://github.com/rust-lang/rust/commit/9738c2a45c03034f937a0b2ce7a690f64e7662eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9738c2a45c03034f937a0b2ce7a690f64e7662eb/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90b65c88397b72deacb07d2b3963e959effe83ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/90b65c88397b72deacb07d2b3963e959effe83ac", "html_url": "https://github.com/rust-lang/rust/commit/90b65c88397b72deacb07d2b3963e959effe83ac"}], "stats": {"total": 512, "additions": 206, "deletions": 306}, "files": [{"sha": "4080c70c8ae482070af1232e5907a79cbbc60aef", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9738c2a45c03034f937a0b2ce7a690f64e7662eb/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/9738c2a45c03034f937a0b2ce7a690f64e7662eb/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=9738c2a45c03034f937a0b2ce7a690f64e7662eb", "patch": "@@ -98,6 +98,7 @@ pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n pub use vec::{OwnedVector, OwnedCopyableVector};\n pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n+pub use iter::{ExtendedMutableIter};\n \n pub use num::{Num, NumCast};\n pub use ptr::Ptr;"}, {"sha": "3dcca0e06c228c4e9f45c4b3f113ab177d2a5d5e", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9738c2a45c03034f937a0b2ce7a690f64e7662eb/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9738c2a45c03034f937a0b2ce7a690f64e7662eb/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=9738c2a45c03034f937a0b2ce7a690f64e7662eb", "patch": "@@ -45,6 +45,10 @@ pub trait ExtendedIter<A> {\n     fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B];\n }\n \n+pub trait ExtendedMutableIter<A> {\n+    fn eachi_mut(&mut self, blk: &fn(uint, &mut A) -> bool);\n+}\n+\n pub trait EqIter<A:Eq> {\n     fn contains(&self, x: &A) -> bool;\n     fn count(&self, x: &A) -> uint;"}, {"sha": "95481d032a446ef1fdfcc566063efbfebaf017f1", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9738c2a45c03034f937a0b2ce7a690f64e7662eb/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9738c2a45c03034f937a0b2ce7a690f64e7662eb/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=9738c2a45c03034f937a0b2ce7a690f64e7662eb", "patch": "@@ -33,7 +33,7 @@ pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n pub use iter::{BaseIter, ReverseIter, MutableIter, ExtendedIter, EqIter};\n pub use iter::{CopyableIter, CopyableOrderedIter, CopyableNonstrictIter};\n-pub use iter::Times;\n+pub use iter::{Times, ExtendedMutableIter};\n pub use num::{Num, NumCast};\n pub use path::GenericPath;\n pub use path::Path;"}, {"sha": "3e0ba38a6e816e554146b5a6843c0e2cce9a9a47", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9738c2a45c03034f937a0b2ce7a690f64e7662eb/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9738c2a45c03034f937a0b2ce7a690f64e7662eb/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=9738c2a45c03034f937a0b2ce7a690f64e7662eb", "patch": "@@ -1388,13 +1388,19 @@ pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) {\n /// to mutate the contents as you iterate.\n #[inline(always)]\n pub fn each_mut<'r,T>(v: &'r mut [T], f: &fn(elem: &'r mut T) -> bool) {\n-    let mut i = 0;\n-    let n = v.len();\n-    while i < n {\n-        if !f(&mut v[i]) {\n-            return;\n+    do vec::as_mut_buf(v) |p, n| {\n+        let mut n = n;\n+        let mut p = p;\n+        while n > 0 {\n+            unsafe {\n+                let q: &'r mut T = cast::transmute_mut_region(&mut *p);\n+                if !f(q) {\n+                    break;\n+                }\n+                p = p.offset(1);\n+            }\n+            n -= 1;\n         }\n-        i += 1;\n     }\n }\n \n@@ -1426,6 +1432,22 @@ pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) {\n     }\n }\n \n+/**\n+ * Iterates over a mutable vector's elements and indices\n+ *\n+ * Return true to continue, false to break.\n+ */\n+#[inline(always)]\n+pub fn eachi_mut<'r,T>(v: &'r mut [T], f: &fn(uint, v: &'r mut T) -> bool) {\n+    let mut i = 0;\n+    for each_mut(v) |p| {\n+        if !f(i, p) {\n+            return;\n+        }\n+        i += 1;\n+    }\n+}\n+\n /**\n  * Iterates over a vector's elements in reverse\n  *\n@@ -2654,6 +2676,13 @@ impl<'self,A> iter::ExtendedIter<A> for &'self [A] {\n     }\n }\n \n+impl<'self,A> iter::ExtendedMutableIter<A> for &'self mut [A] {\n+    #[inline(always)]\n+    pub fn eachi_mut(&mut self, blk: &fn(uint, v: &mut A) -> bool) {\n+        eachi_mut(*self, blk)\n+    }\n+}\n+\n // FIXME(#4148): This should be redundant\n impl<A> iter::ExtendedIter<A> for ~[A] {\n     pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {"}, {"sha": "e633f307bc227295df41cd51bd69c0965335bc1e", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 129, "deletions": 233, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/9738c2a45c03034f937a0b2ce7a690f64e7662eb/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9738c2a45c03034f937a0b2ce7a690f64e7662eb/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=9738c2a45c03034f937a0b2ce7a690f64e7662eb", "patch": "@@ -1,254 +1,150 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// based on:\n-// http://shootout.alioth.debian.org/u32/benchmark.php?test=nbody&lang=java\n-\n-extern mod std;\n-\n-use core::os;\n-\n-// Using sqrt from the standard library is way slower than using libc\n-// directly even though std just calls libc, I guess it must be\n-// because the the indirection through another dynamic linker\n-// stub. Kind of shocking. Might be able to make it faster still with\n-// an llvm intrinsic.\n-mod libc {\n-    #[nolink]\n-    pub extern {\n-        pub fn sqrt(n: float) -> float;\n-    }\n-}\n-\n-fn main() {\n-    let args = os::args();\n-    let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n-        ~[~\"\", ~\"4000000\"]\n-    } else if args.len() <= 1u {\n-        ~[~\"\", ~\"100000\"]\n-    } else {\n-        args\n-    };\n-    let n = int::from_str(args[1]).get();\n-    let mut bodies: ~[Body::Props] = NBodySystem::make();\n-    io::println(fmt!(\"%f\", NBodySystem::energy(bodies)));\n-    let mut i = 0;\n-    while i < n {\n-        NBodySystem::advance(bodies, 0.01);\n-        i += 1;\n-    }\n-    io::println(fmt!(\"%f\", NBodySystem::energy(bodies)));\n+use core::from_str::FromStr;\n+use core::uint::range;\n+use core::unstable::intrinsics::sqrtf64;\n+\n+static PI: f64 = 3.141592653589793;\n+static SOLAR_MASS: f64 = 4.0 * PI * PI;\n+static YEAR: f64 = 365.24;\n+static N_BODIES: uint = 5;\n+\n+static BODIES: [Planet, ..N_BODIES] = [\n+    // Sun\n+    Planet {\n+        x: [ 0.0, 0.0, 0.0 ],\n+        v: [ 0.0, 0.0, 0.0 ],\n+        mass: SOLAR_MASS,\n+    },\n+    // Jupiter\n+    Planet {\n+        x: [\n+            4.84143144246472090e+00,\n+            -1.16032004402742839e+00,\n+            -1.03622044471123109e-01,\n+        ],\n+        v: [\n+            1.66007664274403694e-03 * YEAR,\n+            7.69901118419740425e-03 * YEAR,\n+            -6.90460016972063023e-05 * YEAR,\n+        ],\n+        mass: 9.54791938424326609e-04 * SOLAR_MASS,\n+    },\n+    // Saturn\n+    Planet {\n+        x: [\n+            8.34336671824457987e+00,\n+            4.12479856412430479e+00,\n+            -4.03523417114321381e-01,\n+        ],\n+        v: [\n+            -2.76742510726862411e-03 * YEAR,\n+            4.99852801234917238e-03 * YEAR,\n+            2.30417297573763929e-05 * YEAR,\n+        ],\n+        mass: 2.85885980666130812e-04 * SOLAR_MASS,\n+    },\n+    // Uranus\n+    Planet {\n+        x: [\n+            1.28943695621391310e+01,\n+            -1.51111514016986312e+01,\n+            -2.23307578892655734e-01,\n+        ],\n+        v: [\n+            2.96460137564761618e-03 * YEAR,\n+            2.37847173959480950e-03 * YEAR,\n+            -2.96589568540237556e-05 * YEAR,\n+        ],\n+        mass: 4.36624404335156298e-05 * SOLAR_MASS,\n+    },\n+    // Neptune\n+    Planet {\n+        x: [\n+            1.53796971148509165e+01,\n+            -2.59193146099879641e+01,\n+            1.79258772950371181e-01,\n+        ],\n+        v: [\n+            2.68067772490389322e-03 * YEAR,\n+            1.62824170038242295e-03 * YEAR,\n+            -9.51592254519715870e-05 * YEAR,\n+        ],\n+        mass: 5.15138902046611451e-05 * SOLAR_MASS,\n+    },\n+];\n+\n+struct Planet {\n+    x: [f64, ..3],\n+    v: [f64, ..3],\n+    mass: f64,\n }\n \n-pub mod NBodySystem {\n-    use Body;\n-\n-    pub fn make() -> ~[Body::Props] {\n-        let mut bodies: ~[Body::Props] =\n-            ~[Body::sun(),\n-              Body::jupiter(),\n-              Body::saturn(),\n-              Body::uranus(),\n-              Body::neptune()];\n-\n-        let mut px = 0.0;\n-        let mut py = 0.0;\n-        let mut pz = 0.0;\n-\n-        let mut i = 0;\n-        while i < 5 {\n-            px += bodies[i].vx * bodies[i].mass;\n-            py += bodies[i].vy * bodies[i].mass;\n-            pz += bodies[i].vz * bodies[i].mass;\n-\n-            i += 1;\n-        }\n-\n-        // side-effecting\n-        Body::offset_momentum(&mut bodies[0], px, py, pz);\n-\n-        return bodies;\n-    }\n-\n-    pub fn advance(bodies: &mut [Body::Props], dt: float) {\n-        let mut i = 0;\n-        while i < 5 {\n-            let mut j = i + 1;\n-            while j < 5 {\n-                advance_one(&mut bodies[i],\n-                            &mut bodies[j], dt);\n-                j += 1;\n+fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: i32) {\n+    let mut d = [ 0.0, ..3 ];\n+    for (steps as uint).times {\n+        for range(0, N_BODIES) |i| {\n+            for range(i + 1, N_BODIES) |j| {\n+                d[0] = bodies[i].x[0] - bodies[j].x[0];\n+                d[1] = bodies[i].x[1] - bodies[j].x[1];\n+                d[2] = bodies[i].x[2] - bodies[j].x[2];\n+\n+                let d2 = d[0]*d[0] + d[1]*d[1] + d[2]*d[2];\n+                let mag = dt / (d2 * sqrtf64(d2));\n+\n+                let a_mass = bodies[i].mass, b_mass = bodies[j].mass;\n+                bodies[i].v[0] -= d[0] * b_mass * mag;\n+                bodies[i].v[1] -= d[1] * b_mass * mag;\n+                bodies[i].v[2] -= d[2] * b_mass * mag;\n+\n+                bodies[j].v[0] += d[0] * a_mass * mag;\n+                bodies[j].v[1] += d[1] * a_mass * mag;\n+                bodies[j].v[2] += d[2] * a_mass * mag;\n             }\n-\n-            i += 1;\n         }\n \n-        i = 0;\n-        while i < 5 {\n-            move_(&mut bodies[i], dt);\n-            i += 1;\n+        for vec::each_mut(*bodies) |a| {\n+            a.x[0] += dt * a.v[0];\n+            a.x[1] += dt * a.v[1];\n+            a.x[2] += dt * a.v[2];\n         }\n     }\n+}\n \n-    pub fn advance_one(bi: &mut Body::Props,\n-                       bj: &mut Body::Props,\n-                       dt: float) {\n-        unsafe {\n-            let dx = bi.x - bj.x;\n-            let dy = bi.y - bj.y;\n-            let dz = bi.z - bj.z;\n-\n-            let dSquared = dx * dx + dy * dy + dz * dz;\n-\n-            let distance = ::libc::sqrt(dSquared);\n-            let mag = dt / (dSquared * distance);\n-\n-            bi.vx -= dx * bj.mass * mag;\n-            bi.vy -= dy * bj.mass * mag;\n-            bi.vz -= dz * bj.mass * mag;\n-\n-            bj.vx += dx * bi.mass * mag;\n-            bj.vy += dy * bi.mass * mag;\n-            bj.vz += dz * bi.mass * mag;\n+fn energy(bodies: &[Planet, ..N_BODIES]) -> f64 {\n+    let mut e = 0.0;\n+    let mut d = [ 0.0, ..3 ];\n+    for range(0, N_BODIES) |i| {\n+        for range(0, 3) |k| {\n+            e += bodies[i].mass * bodies[i].v[k] * bodies[i].v[k] / 2.0;\n         }\n-    }\n-\n-    pub fn move_(b: &mut Body::Props, dt: float) {\n-        b.x += dt * b.vx;\n-        b.y += dt * b.vy;\n-        b.z += dt * b.vz;\n-    }\n \n-    pub fn energy(bodies: &[Body::Props]) -> float {\n-        unsafe {\n-            let mut dx;\n-            let mut dy;\n-            let mut dz;\n-            let mut distance;\n-            let mut e = 0.0;\n-\n-            let mut i = 0;\n-            while i < 5 {\n-                e +=\n-                    0.5 * bodies[i].mass *\n-                    (bodies[i].vx * bodies[i].vx\n-                     + bodies[i].vy * bodies[i].vy\n-                     + bodies[i].vz * bodies[i].vz);\n-\n-                let mut j = i + 1;\n-                while j < 5 {\n-                    dx = bodies[i].x - bodies[j].x;\n-                    dy = bodies[i].y - bodies[j].y;\n-                    dz = bodies[i].z - bodies[j].z;\n-\n-                    distance = ::libc::sqrt(dx * dx\n-                                            + dy * dy\n-                                            + dz * dz);\n-                    e -= bodies[i].mass\n-                        * bodies[j].mass / distance;\n-\n-                    j += 1;\n-                }\n-\n-                i += 1;\n+        for range(i + 1, N_BODIES) |j| {\n+            for range(0, 3) |k| {\n+                d[k] = bodies[i].x[k] - bodies[j].x[k];\n             }\n-            return e;\n+            let dist = sqrtf64(d[0]*d[0] + d[1]*d[1] + d[2]*d[2]);\n+            e -= bodies[i].mass * bodies[j].mass / dist;\n         }\n     }\n+    e\n }\n \n-pub mod Body {\n-    use Body;\n-\n-    pub static PI: float = 3.141592653589793;\n-    pub static SOLAR_MASS: float = 39.478417604357432;\n-    // was 4 * PI * PI originally\n-    pub static DAYS_PER_YEAR: float = 365.24;\n-\n-    pub struct Props {\n-        x: float,\n-        y: float,\n-        z: float,\n-        vx: float,\n-        vy: float,\n-        vz: float,\n-        mass: float\n-    }\n-\n-    pub fn jupiter() -> Body::Props {\n-        return Props {\n-            x: 4.84143144246472090e+00,\n-            y: -1.16032004402742839e+00,\n-            z: -1.03622044471123109e-01,\n-            vx: 1.66007664274403694e-03 * DAYS_PER_YEAR,\n-            vy: 7.69901118419740425e-03 * DAYS_PER_YEAR,\n-            vz: -6.90460016972063023e-05 * DAYS_PER_YEAR,\n-            mass: 9.54791938424326609e-04 * SOLAR_MASS\n-        };\n-    }\n-\n-    pub fn saturn() -> Body::Props {\n-        return Props {\n-            x: 8.34336671824457987e+00,\n-            y: 4.12479856412430479e+00,\n-            z: -4.03523417114321381e-01,\n-            vx: -2.76742510726862411e-03 * DAYS_PER_YEAR,\n-            vy: 4.99852801234917238e-03 * DAYS_PER_YEAR,\n-            vz: 2.30417297573763929e-05 * DAYS_PER_YEAR,\n-            mass: 2.85885980666130812e-04 * SOLAR_MASS\n-        };\n-    }\n-\n-    pub fn uranus() -> Body::Props {\n-        return Props {\n-            x: 1.28943695621391310e+01,\n-            y: -1.51111514016986312e+01,\n-            z: -2.23307578892655734e-01,\n-            vx: 2.96460137564761618e-03 * DAYS_PER_YEAR,\n-            vy: 2.37847173959480950e-03 * DAYS_PER_YEAR,\n-            vz: -2.96589568540237556e-05 * DAYS_PER_YEAR,\n-            mass: 4.36624404335156298e-05 * SOLAR_MASS\n-        };\n+fn offset_momentum(bodies: &mut [Planet, ..N_BODIES]) {\n+    for range(0, N_BODIES) |i| {\n+        for range(0, 3) |k| {\n+            bodies[0].v[k] -= bodies[i].v[k] * bodies[i].mass / SOLAR_MASS;\n+        }\n     }\n+}\n \n-    pub fn neptune() -> Body::Props {\n-        return Props {\n-            x: 1.53796971148509165e+01,\n-            y: -2.59193146099879641e+01,\n-            z: 1.79258772950371181e-01,\n-            vx: 2.68067772490389322e-03 * DAYS_PER_YEAR,\n-            vy: 1.62824170038242295e-03 * DAYS_PER_YEAR,\n-            vz: -9.51592254519715870e-05 * DAYS_PER_YEAR,\n-            mass: 5.15138902046611451e-05 * SOLAR_MASS\n-        };\n-    }\n+fn main() {\n+    let n: i32 = FromStr::from_str(os::args()[1]).get();\n+    let mut bodies = BODIES;\n \n-    pub fn sun() -> Body::Props {\n-        return Props {\n-            x: 0.0,\n-            y: 0.0,\n-            z: 0.0,\n-            vx: 0.0,\n-            vy: 0.0,\n-            vz: 0.0,\n-            mass: SOLAR_MASS\n-        };\n-    }\n+    offset_momentum(&mut bodies);\n+    println(fmt!(\"%.9f\", energy(&bodies) as float));\n \n-    pub fn offset_momentum(props: &mut Body::Props,\n-                           px: float,\n-                           py: float,\n-                           pz: float) {\n-        props.vx = -px / SOLAR_MASS;\n-        props.vy = -py / SOLAR_MASS;\n-        props.vz = -pz / SOLAR_MASS;\n-    }\n+    advance(&mut bodies, 0.01, n);\n \n+    println(fmt!(\"%.9f\", energy(&bodies) as float));\n }\n+"}, {"sha": "00e255d890b9d1def58cab256733599e358329be", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 36, "deletions": 66, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/9738c2a45c03034f937a0b2ce7a690f64e7662eb/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9738c2a45c03034f937a0b2ce7a690f64e7662eb/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=9738c2a45c03034f937a0b2ce7a690f64e7662eb", "patch": "@@ -1,84 +1,54 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+use core::from_str::FromStr;\n+use core::iter::ExtendedMutableIter;\n+use core::unstable::intrinsics::sqrtf64;\n \n-// Based on spectalnorm.gcc by Sebastien Loisel\n-\n-extern mod std;\n+#[inline]\n+fn A(i: i32, j: i32) -> i32 {\n+    (i+j) * (i+j+1) / 2 + i + 1\n+}\n \n-fn eval_A(i: uint, j: uint) -> float {\n-    1.0/(((i+j)*(i+j+1u)/2u+i+1u) as float)\n+fn dot(v: &[f64], u: &[f64]) -> f64 {\n+    let mut sum = 0.0;\n+    for v.eachi |i, &v_i| {\n+        sum += v_i * u[i];\n+    }\n+    sum\n }\n \n-fn eval_A_times_u(u: &const [float], Au: &mut [float]) {\n-    let N = vec::len(u);\n-    let mut i = 0u;\n-    while i < N {\n-        Au[i] = 0.0;\n-        let mut j = 0u;\n-        while j < N {\n-            Au[i] += eval_A(i, j) * u[j];\n-            j += 1u;\n+fn mult_Av(v: &mut [f64], out: &mut [f64]) {\n+    for vec::eachi_mut(out) |i, out_i| {\n+        let mut sum = 0.0;\n+        for vec::eachi_mut(v) |j, &v_j| {\n+            sum += v_j / (A(i as i32, j as i32) as f64);\n         }\n-        i += 1u;\n+        *out_i = sum;\n     }\n }\n \n-fn eval_At_times_u(u: &const [float], Au: &mut [float]) {\n-    let N = vec::len(u);\n-    let mut i = 0u;\n-    while i < N {\n-        Au[i] = 0.0;\n-        let mut j = 0u;\n-        while j < N {\n-            Au[i] += eval_A(j, i) * u[j];\n-            j += 1u;\n+fn mult_Atv(v: &mut [f64], out: &mut [f64]) {\n+    for vec::eachi_mut(out) |i, out_i| {\n+        let mut sum = 0.0;\n+        for vec::eachi_mut(v) |j, &v_j| {\n+            sum += v_j / (A(j as i32, i as i32) as f64);\n         }\n-        i += 1u;\n+        *out_i = sum;\n     }\n }\n \n-fn eval_AtA_times_u(u: &const [float], AtAu: &mut [float]) {\n-    let mut v = vec::from_elem(vec::len(u), 0.0);\n-    eval_A_times_u(u, v);\n-    eval_At_times_u(v, AtAu);\n+fn mult_AtAv(v: &mut [f64], out: &mut [f64], tmp: &mut [f64]) {\n+    mult_Av(v, tmp);\n+    mult_Atv(tmp, out);\n }\n \n+#[fixed_stack_segment]\n fn main() {\n-    let args = os::args();\n-    let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n-        ~[~\"\", ~\"2000\"]\n-    } else if args.len() <= 1u {\n-        ~[~\"\", ~\"1000\"]\n-    } else {\n-        args\n-    };\n-\n-    let N = uint::from_str(args[1]).get();\n-\n-    let mut u = vec::from_elem(N, 1.0);\n-    let mut v = vec::from_elem(N, 0.0);\n-    let mut i = 0u;\n-    while i < 10u {\n-        eval_AtA_times_u(u, v);\n-        eval_AtA_times_u(v, u);\n-        i += 1u;\n-    }\n-\n-    let mut vBv = 0.0;\n-    let mut vv = 0.0;\n-    let mut i = 0u;\n-    while i < N {\n-        vBv += u[i] * v[i];\n-        vv += v[i] * v[i];\n-        i += 1u;\n+    let n: uint = FromStr::from_str(os::args()[1]).get();\n+    let mut u = vec::from_elem(n, 1f64), v = u.clone(), tmp = u.clone();\n+    for 8.times {\n+        mult_AtAv(u, v, tmp);\n+        mult_AtAv(v, u, tmp);\n     }\n \n-    io::println(fmt!(\"%0.9f\\n\", float::sqrt(vBv / vv)));\n+    println(fmt!(\"%.9f\", sqrtf64(dot(u,v) / dot(v,v)) as float));\n }\n+"}]}