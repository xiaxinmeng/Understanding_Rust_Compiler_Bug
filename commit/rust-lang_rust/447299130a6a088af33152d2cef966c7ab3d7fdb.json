{"sha": "447299130a6a088af33152d2cef966c7ab3d7fdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NzI5OTEzMGE2YTA4OGFmMzMxNTJkMmNlZjk2NmM3YWIzZDdmZGI=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-10T22:04:32Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-14T10:31:22Z"}, "message": "Add to_bytes and from_bytes to primitive integers", "tree": {"sha": "f33b56bc7bf505ff2ac037f5bfc1ecfa662139af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f33b56bc7bf505ff2ac037f5bfc1ecfa662139af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/447299130a6a088af33152d2cef966c7ab3d7fdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/447299130a6a088af33152d2cef966c7ab3d7fdb", "html_url": "https://github.com/rust-lang/rust/commit/447299130a6a088af33152d2cef966c7ab3d7fdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/447299130a6a088af33152d2cef966c7ab3d7fdb/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b72d48f8e5f3c7cabcf6fcd31474209bff0ab59", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b72d48f8e5f3c7cabcf6fcd31474209bff0ab59", "html_url": "https://github.com/rust-lang/rust/commit/0b72d48f8e5f3c7cabcf6fcd31474209bff0ab59"}], "stats": {"total": 89, "additions": 89, "deletions": 0}, "files": [{"sha": "b89fb81c6f7d3d62dabb082176e95857cb46560c", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/447299130a6a088af33152d2cef966c7ab3d7fdb/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/447299130a6a088af33152d2cef966c7ab3d7fdb/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=447299130a6a088af33152d2cef966c7ab3d7fdb", "patch": "@@ -15,6 +15,7 @@\n use convert::TryFrom;\n use fmt;\n use intrinsics;\n+use mem;\n #[allow(deprecated)] use nonzero::NonZero;\n use ops;\n use str::FromStr;\n@@ -1619,6 +1620,50 @@ $EndFeature, \"\n             #[inline]\n             pub fn is_negative(self) -> bool { self < 0 }\n         }\n+\n+        /// Return the memory representation of this integer as a byte array.\n+        ///\n+        /// The target platform\u2019s native endianness is used.\n+        /// Portable code likely wants to use this after [`to_be`] or [`to_le`].\n+        ///\n+        /// [`to_be`]: #method.to_be\n+        /// [`to_le`]: #method.to_le\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let bytes = i32::min_value().to_be().to_bytes();\n+        /// assert_eq!(bytes, [0x80, 0, 0, 0]);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n+        #[inline]\n+        pub fn to_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            unsafe { mem::transmute(self) }\n+        }\n+\n+        /// Create an integer value from its memory representation as a byte array.\n+        ///\n+        /// The target platform\u2019s native endianness is used.\n+        /// Portable code likely wants to use [`from_be`] or [`from_le`] after this.\n+        ///\n+        /// [`from_be`]: #method.from_be\n+        /// [`from_le`]: #method.from_le\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let int = i32::from_be(i32::from_bytes([0x80, 0, 0, 0]));\n+        /// assert_eq!(int, i32::min_value());\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n+        #[inline]\n+        pub fn from_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            unsafe { mem::transmute(bytes) }\n+        }\n     }\n }\n \n@@ -2933,6 +2978,50 @@ $EndFeature, \"\n                 self.one_less_than_next_power_of_two().checked_add(1)\n             }\n         }\n+\n+        /// Return the memory representation of this integer as a byte array.\n+        ///\n+        /// The target platform\u2019s native endianness is used.\n+        /// Portable code likely wants to use this after [`to_be`] or [`to_le`].\n+        ///\n+        /// [`to_be`]: #method.to_be\n+        /// [`to_le`]: #method.to_le\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let bytes = 0x1234_5678_u32.to_be().to_bytes();\n+        /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n+        #[inline]\n+        pub fn to_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            unsafe { mem::transmute(self) }\n+        }\n+\n+        /// Create an integer value from its memory representation as a byte array.\n+        ///\n+        /// The target platform\u2019s native endianness is used.\n+        /// Portable code likely wants to use [`to_be`] or [`to_le`] after this.\n+        ///\n+        /// [`to_be`]: #method.to_be\n+        /// [`to_le`]: #method.to_le\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_to_from_bytes)]\n+        ///\n+        /// let int = u32::from_be(u32::from_bytes([0x12, 0x34, 0x56, 0x78]));\n+        /// assert_eq!(int, 0x1234_5678_u32);\n+        /// ```\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"49792\")]\n+        #[inline]\n+        pub fn from_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            unsafe { mem::transmute(bytes) }\n+        }\n     }\n }\n "}]}