{"sha": "e70cbef0c5db81079f4b5643380d6047ccd34a10", "node_id": "C_kwDOAAsO6NoAKGU3MGNiZWYwYzVkYjgxMDc5ZjRiNTY0MzM4MGQ2MDQ3Y2NkMzRhMTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-01T12:15:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-01T12:15:10Z"}, "message": "Auto merge of #103590 - compiler-errors:ocx-more, r=lcnr\n\n(almost) Always use `ObligationCtxt` when dealing with canonical queries\n\nHope this is a step in the right direction. cc rust-lang/types-team#50.\n\nr? `@lcnr`", "tree": {"sha": "6123ac4c7d8880a04e10a9e75f291b19001caa3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6123ac4c7d8880a04e10a9e75f291b19001caa3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e70cbef0c5db81079f4b5643380d6047ccd34a10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e70cbef0c5db81079f4b5643380d6047ccd34a10", "html_url": "https://github.com/rust-lang/rust/commit/e70cbef0c5db81079f4b5643380d6047ccd34a10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e70cbef0c5db81079f4b5643380d6047ccd34a10/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c493bae0d8efd75723460ce5c371f726efa93f15", "url": "https://api.github.com/repos/rust-lang/rust/commits/c493bae0d8efd75723460ce5c371f726efa93f15", "html_url": "https://github.com/rust-lang/rust/commit/c493bae0d8efd75723460ce5c371f726efa93f15"}, {"sha": "2f9794b84a4ae882edd428c1c3764eec99cdebff", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f9794b84a4ae882edd428c1c3764eec99cdebff", "html_url": "https://github.com/rust-lang/rust/commit/2f9794b84a4ae882edd428c1c3764eec99cdebff"}], "stats": {"total": 255, "additions": 121, "deletions": 134}, "files": [{"sha": "dac6abe37f5891d3e3667be00defec2bf8184374", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=e70cbef0c5db81079f4b5643380d6047ccd34a10", "patch": "@@ -5,14 +5,14 @@ use rustc_infer::infer::region_constraints::Constraint;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n use rustc_infer::infer::RegionVariableOrigin;\n use rustc_infer::infer::{InferCtxt, RegionResolutionError, SubregionOrigin, TyCtxtInferExt as _};\n-use rustc_infer::traits::{Normalized, ObligationCause, TraitEngine, TraitEngineExt};\n+use rustc_infer::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::RegionVid;\n use rustc_middle::ty::UniverseIndex;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op;\n-use rustc_trait_selection::traits::{SelectionContext, TraitEngineExt as _};\n+use rustc_trait_selection::traits::ObligationCtxt;\n use rustc_traits::{type_op_ascribe_user_type_with_span, type_op_prove_predicate_with_cause};\n \n use std::fmt;\n@@ -240,9 +240,9 @@ impl<'tcx> TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n         let (ref infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-        type_op_prove_predicate_with_cause(infcx, &mut *fulfill_cx, key, cause);\n-        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n+        let ocx = ObligationCtxt::new(infcx);\n+        type_op_prove_predicate_with_cause(&ocx, key, cause);\n+        try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }\n }\n \n@@ -281,9 +281,7 @@ where\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n         let (ref infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n-        let mut selcx = SelectionContext::new(infcx);\n+        let ocx = ObligationCtxt::new(infcx);\n \n         // FIXME(lqd): Unify and de-duplicate the following with the actual\n         // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n@@ -292,11 +290,9 @@ where\n         // to normalize the `nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs` test. Check\n         // after #85499 lands to see if its fixes have erased this difference.\n         let (param_env, value) = key.into_parts();\n-        let Normalized { value: _, obligations } =\n-            rustc_trait_selection::traits::normalize(&mut selcx, param_env, cause, value.value);\n-        fulfill_cx.register_predicate_obligations(infcx, obligations);\n+        let _ = ocx.normalize(cause, param_env, value.value);\n \n-        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n+        try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }\n }\n \n@@ -329,9 +325,9 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n         let (ref infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-        type_op_ascribe_user_type_with_span(infcx, &mut *fulfill_cx, key, Some(cause.span)).ok()?;\n-        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n+        let ocx = ObligationCtxt::new(infcx);\n+        type_op_ascribe_user_type_with_span(&ocx, key, Some(cause.span)).ok()?;\n+        try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }\n }\n \n@@ -372,25 +368,24 @@ impl<'tcx> TypeOpInfo<'tcx> for crate::type_check::InstantiateOpaqueType<'tcx> {\n     }\n }\n \n-#[instrument(skip(fulfill_cx, infcx), level = \"debug\")]\n+#[instrument(skip(ocx), level = \"debug\")]\n fn try_extract_error_from_fulfill_cx<'tcx>(\n-    mut fulfill_cx: Box<dyn TraitEngine<'tcx> + 'tcx>,\n-    infcx: &InferCtxt<'tcx>,\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n     placeholder_region: ty::Region<'tcx>,\n     error_region: Option<ty::Region<'tcx>>,\n ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n     // We generally shouldn't have errors here because the query was\n     // already run, but there's no point using `delay_span_bug`\n     // when we're going to emit an error here anyway.\n-    let _errors = fulfill_cx.select_all_or_error(infcx);\n-    let region_constraints = infcx.with_region_constraints(|r| r.clone());\n+    let _errors = ocx.select_all_or_error();\n+    let region_constraints = ocx.infcx.with_region_constraints(|r| r.clone());\n     try_extract_error_from_region_constraints(\n-        infcx,\n+        ocx.infcx,\n         placeholder_region,\n         error_region,\n         &region_constraints,\n-        |vid| infcx.region_var_origin(vid),\n-        |vid| infcx.universe_of_region(infcx.tcx.mk_region(ty::ReVar(vid))),\n+        |vid| ocx.infcx.region_var_origin(vid),\n+        |vid| ocx.infcx.universe_of_region(ocx.infcx.tcx.mk_region(ty::ReVar(vid))),\n     )\n }\n "}, {"sha": "aeaf7a6cfe1f12fb73f26cc68ec1cb5bd8a94b1f", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=e70cbef0c5db81079f4b5643380d6047ccd34a10", "patch": "@@ -290,23 +290,16 @@ fn compare_predicate_entailment<'tcx>(\n     // type would be more appropriate. In other places we have a `Vec<Span>`\n     // corresponding to their `Vec<Predicate>`, but we don't have that here.\n     // Fixing this would improve the output of test `issue-83765.rs`.\n-    let mut result = infcx\n-        .at(&cause, param_env)\n-        .sup(trait_fty, impl_fty)\n-        .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok));\n+    let mut result = ocx.sup(&cause, param_env, trait_fty, impl_fty);\n \n     // HACK(RPITIT): #101614. When we are trying to infer the hidden types for\n     // RPITITs, we need to equate the output tys instead of just subtyping. If\n     // we just use `sup` above, we'll end up `&'static str <: _#1t`, which causes\n     // us to infer `_#1t = #'_#2r str`, where `'_#2r` is unconstrained, which gets\n     // fixed up to `ReEmpty`, and which is certainly not what we want.\n     if trait_fty.has_infer_types() {\n-        result = result.and_then(|()| {\n-            infcx\n-                .at(&cause, param_env)\n-                .eq(trait_sig.output(), impl_sig.output())\n-                .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok))\n-        });\n+        result =\n+            result.and_then(|()| ocx.eq(&cause, param_env, trait_sig.output(), impl_sig.output()));\n     }\n \n     if let Err(terr) = result {\n@@ -1389,10 +1382,7 @@ pub(crate) fn raw_compare_const_impl<'tcx>(\n \n     debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n-    let err = infcx\n-        .at(&cause, param_env)\n-        .sup(trait_ty, impl_ty)\n-        .map(|ok| ocx.register_infer_ok_obligations(ok));\n+    let err = ocx.sup(&cause, param_env, trait_ty, impl_ty);\n \n     if let Err(terr) = err {\n         debug!("}, {"sha": "0117bdd0ba81cb7966043768f14a54de7a1dbc38", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=e70cbef0c5db81079f4b5643380d6047ccd34a10", "patch": "@@ -1674,7 +1674,7 @@ fn receiver_is_valid<'tcx>(\n \n     // `self: Self` is always valid.\n     if can_eq_self(receiver_ty) {\n-        if let Err(err) = wfcx.equate_types(&cause, wfcx.param_env, self_ty, receiver_ty) {\n+        if let Err(err) = wfcx.eq(&cause, wfcx.param_env, self_ty, receiver_ty) {\n             infcx.err_ctxt().report_mismatched_types(&cause, self_ty, receiver_ty, err).emit();\n         }\n         return true;\n@@ -1704,9 +1704,7 @@ fn receiver_is_valid<'tcx>(\n             if can_eq_self(potential_self_ty) {\n                 wfcx.register_obligations(autoderef.into_obligations());\n \n-                if let Err(err) =\n-                    wfcx.equate_types(&cause, wfcx.param_env, self_ty, potential_self_ty)\n-                {\n+                if let Err(err) = wfcx.eq(&cause, wfcx.param_env, self_ty, potential_self_ty) {\n                     infcx\n                         .err_ctxt()\n                         .report_mismatched_types(&cause, self_ty, potential_self_ty, err)"}, {"sha": "cbd6481f9cb81087566500347072104d4defee5a", "filename": "compiler/rustc_infer/src/infer/canonical/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs?ref=e70cbef0c5db81079f4b5643380d6047ccd34a10", "patch": "@@ -43,7 +43,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     ///\n     /// This is only meant to be invoked as part of constructing an\n     /// inference context at the start of a query (see\n-    /// `InferCtxtBuilder::enter_with_canonical`). It basically\n+    /// `InferCtxtBuilder::build_with_canonical`). It basically\n     /// brings the canonical value \"into scope\" within your new infcx.\n     ///\n     /// At the end of processing, the substitution S (once"}, {"sha": "96ac4e9c1292a9cba25ade5404ed5bac49e22467", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=e70cbef0c5db81079f4b5643380d6047ccd34a10", "patch": "@@ -1,5 +1,5 @@\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n-use crate::traits::{self, TraitEngine, TraitEngineExt};\n+use crate::traits::{self, ObligationCtxt};\n \n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n@@ -142,7 +142,7 @@ pub trait InferCtxtBuilderExt<'tcx> {\n     fn enter_canonical_trait_query<K, R>(\n         &mut self,\n         canonical_key: &Canonical<'tcx, K>,\n-        operation: impl FnOnce(&InferCtxt<'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n+        operation: impl FnOnce(&ObligationCtxt<'_, 'tcx>, K) -> Fallible<R>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n     where\n         K: TypeFoldable<'tcx>,\n@@ -170,17 +170,17 @@ impl<'tcx> InferCtxtBuilderExt<'tcx> for InferCtxtBuilder<'tcx> {\n     fn enter_canonical_trait_query<K, R>(\n         &mut self,\n         canonical_key: &Canonical<'tcx, K>,\n-        operation: impl FnOnce(&InferCtxt<'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n+        operation: impl FnOnce(&ObligationCtxt<'_, 'tcx>, K) -> Fallible<R>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n     where\n         K: TypeFoldable<'tcx>,\n         R: Debug + TypeFoldable<'tcx>,\n         Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable<'tcx>,\n     {\n-        let (ref infcx, key, canonical_inference_vars) =\n+        let (infcx, key, canonical_inference_vars) =\n             self.build_with_canonical(DUMMY_SP, canonical_key);\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-        let value = operation(infcx, &mut *fulfill_cx, key)?;\n-        infcx.make_canonicalized_query_response(canonical_inference_vars, value, &mut *fulfill_cx)\n+        let ocx = ObligationCtxt::new(&infcx);\n+        let value = operation(&ocx, key)?;\n+        ocx.make_canonicalized_query_response(canonical_inference_vars, value)\n     }\n }"}, {"sha": "21516c93efb53aa8b33e681938a61c1701f54d35", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=e70cbef0c5db81079f4b5643380d6047ccd34a10", "patch": "@@ -1,14 +1,21 @@\n use std::cell::RefCell;\n+use std::fmt::Debug;\n \n use super::TraitEngine;\n use super::{ChalkFulfillmentContext, FulfillmentContext};\n use crate::infer::InferCtxtExt;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_infer::infer::at::ToTrace;\n+use rustc_infer::infer::canonical::{\n+    Canonical, CanonicalVarValues, CanonicalizedQueryResponse, QueryResponse,\n+};\n use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::traits::query::Fallible;\n use rustc_infer::traits::{\n     FulfillmentError, Obligation, ObligationCause, PredicateObligation, TraitEngineExt as _,\n };\n+use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::ToPredicate;\n use rustc_middle::ty::TypeFoldable;\n@@ -105,12 +112,12 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         self.register_infer_ok_obligations(infer_ok)\n     }\n \n-    pub fn equate_types(\n+    pub fn eq<T: ToTrace<'tcx>>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        expected: Ty<'tcx>,\n-        actual: Ty<'tcx>,\n+        expected: T,\n+        actual: T,\n     ) -> Result<(), TypeError<'tcx>> {\n         match self.infcx.at(cause, param_env).eq(expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n@@ -121,6 +128,22 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         }\n     }\n \n+    pub fn sup<T: ToTrace<'tcx>>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        expected: T,\n+        actual: T,\n+    ) -> Result<(), TypeError<'tcx>> {\n+        match self.infcx.at(cause, param_env).sup(expected, actual) {\n+            Ok(InferOk { obligations, value: () }) => {\n+                self.register_obligations(obligations);\n+                Ok(())\n+            }\n+            Err(e) => Err(e),\n+        }\n+    }\n+\n     pub fn select_all_or_error(&self) -> Vec<FulfillmentError<'tcx>> {\n         self.engine.borrow_mut().select_all_or_error(self.infcx)\n     }\n@@ -154,4 +177,20 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         }\n         implied_bounds\n     }\n+\n+    pub fn make_canonicalized_query_response<T>(\n+        &self,\n+        inference_vars: CanonicalVarValues<'tcx>,\n+        answer: T,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, T>>\n+    where\n+        T: Debug + TypeFoldable<'tcx>,\n+        Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable<'tcx>,\n+    {\n+        self.infcx.make_canonicalized_query_response(\n+            inference_vars,\n+            answer,\n+            &mut **self.engine.borrow_mut(),\n+        )\n+    }\n }"}, {"sha": "82f6111f6f92e440e66dd4a5bb31b68d34ac6c8b", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=e70cbef0c5db81079f4b5643380d6047ccd34a10", "patch": "@@ -28,9 +28,9 @@ fn implied_outlives_bounds<'tcx>(\n     &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>,\n     NoSolution,\n > {\n-    tcx.infer_ctxt().enter_canonical_trait_query(&goal, |infcx, _fulfill_cx, key| {\n+    tcx.infer_ctxt().enter_canonical_trait_query(&goal, |ocx, key| {\n         let (param_env, ty) = key.into_parts();\n-        compute_implied_outlives_bounds(&infcx, param_env, ty)\n+        compute_implied_outlives_bounds(&ocx.infcx, param_env, ty)\n     })\n }\n "}, {"sha": "0ffa92f1ad55d960310e1625e13f53c362ea0e09", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=e70cbef0c5db81079f4b5643380d6047ccd34a10", "patch": "@@ -3,6 +3,7 @@\n \n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n+#![feature(let_chains)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "e805eb4282119b5db40be90ebe6a6324ffa9f382", "filename": "compiler/rustc_traits/src/normalize_projection_ty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs?ref=e70cbef0c5db81079f4b5643380d6047ccd34a10", "patch": "@@ -1,6 +1,5 @@\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n@@ -23,8 +22,8 @@ fn normalize_projection_ty<'tcx>(\n     tcx.sess.perf_stats.normalize_projection_ty.fetch_add(1, Ordering::Relaxed);\n     tcx.infer_ctxt().enter_canonical_trait_query(\n         &goal,\n-        |infcx, fulfill_cx, ParamEnvAnd { param_env, value: goal }| {\n-            let selcx = &mut SelectionContext::new(infcx);\n+        |ocx, ParamEnvAnd { param_env, value: goal }| {\n+            let selcx = &mut SelectionContext::new(ocx.infcx);\n             let cause = ObligationCause::dummy();\n             let mut obligations = vec![];\n             let answer = traits::normalize_projection_type(\n@@ -35,7 +34,7 @@ fn normalize_projection_ty<'tcx>(\n                 0,\n                 &mut obligations,\n             );\n-            fulfill_cx.register_predicate_obligations(infcx, obligations);\n+            ocx.register_obligations(obligations);\n             // FIXME(associated_const_equality): All users of normalize_projection_ty expected\n             // a type, but there is the possibility it could've been a const now. Maybe change\n             // it to a Term later?"}, {"sha": "98cb3f21555ac238e1add134dff545fc097d20d2", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 41, "deletions": 76, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70cbef0c5db81079f4b5643380d6047ccd34a10/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=e70cbef0c5db81079f4b5643380d6047ccd34a10", "patch": "@@ -2,25 +2,22 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n-use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n-use rustc_infer::traits::{ObligationCauseCode, TraitEngineExt as _};\n+use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n+use rustc_infer::traits::ObligationCauseCode;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{\n-    self, EarlyBinder, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable, Variance,\n-};\n-use rustc_middle::ty::{GenericArg, UserSelfTy, UserSubsts};\n-use rustc_middle::ty::{ParamEnv, ParamEnvAnd, Predicate, ToPredicate};\n+use rustc_middle::ty::{self, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{ParamEnvAnd, Predicate, ToPredicate};\n+use rustc_middle::ty::{UserSelfTy, UserSubsts};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n-use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use rustc_trait_selection::traits::query::type_op::ascribe_user_type::AscribeUserType;\n use rustc_trait_selection::traits::query::type_op::eq::Eq;\n use rustc_trait_selection::traits::query::type_op::normalize::Normalize;\n use rustc_trait_selection::traits::query::type_op::prove_predicate::ProvePredicate;\n use rustc_trait_selection::traits::query::type_op::subtype::Subtype;\n use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n-use rustc_trait_selection::traits::{Normalized, Obligation, ObligationCause, TraitEngine};\n+use rustc_trait_selection::traits::{Normalized, Obligation, ObligationCause, ObligationCtxt};\n use std::fmt;\n use std::iter::zip;\n \n@@ -42,17 +39,16 @@ fn type_op_ascribe_user_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, AscribeUserType<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n-    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n-        type_op_ascribe_user_type_with_span(infcx, fulfill_cx, key, None)\n+    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |ocx, key| {\n+        type_op_ascribe_user_type_with_span(ocx, key, None)\n     })\n }\n \n /// The core of the `type_op_ascribe_user_type` query: for diagnostics purposes in NLL HRTB errors,\n /// this query can be re-run to better track the span of the obligation cause, and improve the error\n /// message. Do not call directly unless you're in that very specific context.\n-pub fn type_op_ascribe_user_type_with_span<'a, 'tcx: 'a>(\n-    infcx: &'a InferCtxt<'tcx>,\n-    fulfill_cx: &'a mut dyn TraitEngine<'tcx>,\n+pub fn type_op_ascribe_user_type_with_span<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n     key: ParamEnvAnd<'tcx, AscribeUserType<'tcx>>,\n     span: Option<Span>,\n ) -> Result<(), NoSolution> {\n@@ -61,89 +57,69 @@ pub fn type_op_ascribe_user_type_with_span<'a, 'tcx: 'a>(\n         \"type_op_ascribe_user_type: mir_ty={:?} def_id={:?} user_substs={:?}\",\n         mir_ty, def_id, user_substs\n     );\n-\n-    let mut cx = AscribeUserTypeCx { infcx, param_env, span: span.unwrap_or(DUMMY_SP), fulfill_cx };\n+    let cx = AscribeUserTypeCx { ocx, param_env, span: span.unwrap_or(DUMMY_SP) };\n     cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs)?;\n     Ok(())\n }\n \n struct AscribeUserTypeCx<'me, 'tcx> {\n-    infcx: &'me InferCtxt<'tcx>,\n-    param_env: ParamEnv<'tcx>,\n+    ocx: &'me ObligationCtxt<'me, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     span: Span,\n-    fulfill_cx: &'me mut dyn TraitEngine<'tcx>,\n }\n \n impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n-    fn normalize<T>(&mut self, value: T) -> T\n+    fn normalize<T>(&self, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         self.normalize_with_cause(value, ObligationCause::misc(self.span, hir::CRATE_HIR_ID))\n     }\n \n-    fn normalize_with_cause<T>(&mut self, value: T, cause: ObligationCause<'tcx>) -> T\n+    fn normalize_with_cause<T>(&self, value: T, cause: ObligationCause<'tcx>) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        self.infcx\n-            .partially_normalize_associated_types_in(cause, self.param_env, value)\n-            .into_value_registering_obligations(self.infcx, self.fulfill_cx)\n+        self.ocx.normalize(cause, self.param_env, value)\n     }\n \n-    fn relate<T>(&mut self, a: T, variance: Variance, b: T) -> Result<(), NoSolution>\n+    fn eq<T>(&self, a: T, b: T) -> Result<(), NoSolution>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.infcx\n-            .at(&ObligationCause::dummy_with_span(self.span), self.param_env)\n-            .relate(a, variance, b)?\n-            .into_value_registering_obligations(self.infcx, self.fulfill_cx);\n-        Ok(())\n+        Ok(self.ocx.eq(&ObligationCause::dummy_with_span(self.span), self.param_env, a, b)?)\n     }\n \n-    fn prove_predicate(&mut self, predicate: Predicate<'tcx>, cause: ObligationCause<'tcx>) {\n-        self.fulfill_cx.register_predicate_obligation(\n-            self.infcx,\n-            Obligation::new(cause, self.param_env, predicate),\n-        );\n+    fn prove_predicate(&self, predicate: Predicate<'tcx>, cause: ObligationCause<'tcx>) {\n+        self.ocx.register_obligation(Obligation::new(cause, self.param_env, predicate));\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn subst<T>(&self, value: T, substs: &[GenericArg<'tcx>]) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        EarlyBinder(value).subst(self.tcx(), substs)\n+        self.ocx.infcx.tcx\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn relate_mir_and_user_ty(\n-        &mut self,\n+        &self,\n         mir_ty: Ty<'tcx>,\n         def_id: DefId,\n         user_substs: UserSubsts<'tcx>,\n     ) -> Result<(), NoSolution> {\n         let UserSubsts { user_self_ty, substs } = user_substs;\n         let tcx = self.tcx();\n \n-        let ty = tcx.type_of(def_id);\n-        let ty = self.subst(ty, substs);\n+        let ty = tcx.bound_type_of(def_id).subst(tcx, substs);\n         let ty = self.normalize(ty);\n         debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n \n-        self.relate(mir_ty, Variance::Invariant, ty)?;\n+        self.eq(mir_ty, ty)?;\n \n         // Prove the predicates coming along with `def_id`.\n         //\n         // Also, normalize the `instantiated_predicates`\n         // because otherwise we wind up with duplicate \"type\n         // outlives\" error messages.\n-        let instantiated_predicates =\n-            self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n+        let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n \n         let cause = ObligationCause::dummy_with_span(self.span);\n \n@@ -163,15 +139,14 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         }\n \n         if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n-            let impl_self_ty = self.tcx().type_of(impl_def_id);\n-            let impl_self_ty = self.subst(impl_self_ty, &substs);\n+            let impl_self_ty = tcx.bound_type_of(impl_def_id).subst(tcx, substs);\n             let impl_self_ty = self.normalize(impl_self_ty);\n \n-            self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n+            self.eq(self_ty, impl_self_ty)?;\n \n             self.prove_predicate(\n                 ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()))\n-                    .to_predicate(self.tcx()),\n+                    .to_predicate(tcx),\n                 cause.clone(),\n             );\n         }\n@@ -188,7 +163,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         // type were ill-formed but did not appear in `ty`,\n         // which...could happen with normalization...\n         self.prove_predicate(\n-            ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(self.tcx()),\n+            ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(tcx),\n             cause,\n         );\n         Ok(())\n@@ -199,28 +174,23 @@ fn type_op_eq<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Eq<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n-    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n+    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |ocx, key| {\n         let (param_env, Eq { a, b }) = key.into_parts();\n-        infcx\n-            .at(&ObligationCause::dummy(), param_env)\n-            .eq(a, b)?\n-            .into_value_registering_obligations(infcx, fulfill_cx);\n-        Ok(())\n+        Ok(ocx.eq(&ObligationCause::dummy(), param_env, a, b)?)\n     })\n }\n \n fn type_op_normalize<'tcx, T>(\n-    infcx: &InferCtxt<'tcx>,\n-    fulfill_cx: &mut dyn TraitEngine<'tcx>,\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n     key: ParamEnvAnd<'tcx, Normalize<T>>,\n ) -> Fallible<T>\n where\n     T: fmt::Debug + TypeFoldable<'tcx> + Lift<'tcx>,\n {\n     let (param_env, Normalize { value }) = key.into_parts();\n     let Normalized { value, obligations } =\n-        infcx.at(&ObligationCause::dummy(), param_env).normalize(value)?;\n-    fulfill_cx.register_predicate_obligations(infcx, obligations);\n+        ocx.infcx.at(&ObligationCause::dummy(), param_env).normalize(value)?;\n+    ocx.register_obligations(obligations);\n     Ok(value)\n }\n \n@@ -256,13 +226,9 @@ fn type_op_subtype<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Subtype<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n-    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n+    tcx.infer_ctxt().enter_canonical_trait_query(&canonicalized, |ocx, key| {\n         let (param_env, Subtype { sub, sup }) = key.into_parts();\n-        infcx\n-            .at(&ObligationCause::dummy(), param_env)\n-            .sup(sup, sub)?\n-            .into_value_registering_obligations(infcx, fulfill_cx);\n-        Ok(())\n+        Ok(ocx.sup(&ObligationCause::dummy(), param_env, sup, sub)?)\n     })\n }\n \n@@ -274,8 +240,8 @@ fn type_op_prove_predicate<'tcx>(\n     // impl-trait/issue-99642.rs\n     tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).enter_canonical_trait_query(\n         &canonicalized,\n-        |infcx, fulfill_cx, key| {\n-            type_op_prove_predicate_with_cause(infcx, fulfill_cx, key, ObligationCause::dummy());\n+        |ocx, key| {\n+            type_op_prove_predicate_with_cause(ocx, key, ObligationCause::dummy());\n             Ok(())\n         },\n     )\n@@ -284,12 +250,11 @@ fn type_op_prove_predicate<'tcx>(\n /// The core of the `type_op_prove_predicate` query: for diagnostics purposes in NLL HRTB errors,\n /// this query can be re-run to better track the span of the obligation cause, and improve the error\n /// message. Do not call directly unless you're in that very specific context.\n-pub fn type_op_prove_predicate_with_cause<'a, 'tcx: 'a>(\n-    infcx: &'a InferCtxt<'tcx>,\n-    fulfill_cx: &'a mut dyn TraitEngine<'tcx>,\n+pub fn type_op_prove_predicate_with_cause<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n     key: ParamEnvAnd<'tcx, ProvePredicate<'tcx>>,\n     cause: ObligationCause<'tcx>,\n ) {\n     let (param_env, ProvePredicate { predicate }) = key.into_parts();\n-    fulfill_cx.register_predicate_obligation(infcx, Obligation::new(cause, param_env, predicate));\n+    ocx.register_obligation(Obligation::new(cause, param_env, predicate));\n }"}]}