{"sha": "751131b4acce37d0d4d62edd1eb831143c8fa46f", "node_id": "C_kwDOAAsO6NoAKDc1MTEzMWI0YWNjZTM3ZDBkNGQ2MmVkZDFlYjgzMTE0M2M4ZmE0NmY", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-01T01:57:32Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-28T16:51:03Z"}, "message": "Move `AssignOps` into `Operators` lint pass", "tree": {"sha": "4d948cb62fdc64951d6b2868c64f47046815c43c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d948cb62fdc64951d6b2868c64f47046815c43c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/751131b4acce37d0d4d62edd1eb831143c8fa46f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/751131b4acce37d0d4d62edd1eb831143c8fa46f", "html_url": "https://github.com/rust-lang/rust/commit/751131b4acce37d0d4d62edd1eb831143c8fa46f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/751131b4acce37d0d4d62edd1eb831143c8fa46f/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6", "html_url": "https://github.com/rust-lang/rust/commit/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6"}], "stats": {"total": 504, "additions": 261, "deletions": 243}, "files": [{"sha": "f81da2d42233380e9bd5a633b8b13237dfcac68a", "filename": "clippy_lints/src/assign_ops.rs", "status": "removed", "additions": 0, "deletions": 235, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=448b6f45bd1175e3ea7f696e1ff7b9702d8a7cc6", "patch": "@@ -1,235 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::implements_trait;\n-use clippy_utils::{binop_traits, sugg};\n-use clippy_utils::{eq_expr_value, trait_ref_of_method};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `a = a op b` or `a = b commutative_op a`\n-    /// patterns.\n-    ///\n-    /// ### Why is this bad?\n-    /// These can be written as the shorter `a op= b`.\n-    ///\n-    /// ### Known problems\n-    /// While forbidden by the spec, `OpAssign` traits may have\n-    /// implementations that differ from the regular `Op` impl.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let mut a = 5;\n-    /// let b = 0;\n-    /// // ...\n-    ///\n-    /// a = a + b;\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// let mut a = 5;\n-    /// let b = 0;\n-    /// // ...\n-    ///\n-    /// a += b;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub ASSIGN_OP_PATTERN,\n-    style,\n-    \"assigning the result of an operation on a variable to that same variable\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `a op= a op b` or `a op= b op a` patterns.\n-    ///\n-    /// ### Why is this bad?\n-    /// Most likely these are bugs where one meant to write `a\n-    /// op= b`.\n-    ///\n-    /// ### Known problems\n-    /// Clippy cannot know for sure if `a op= a op b` should have\n-    /// been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore, it suggests both.\n-    /// If `a op= a op b` is really the correct behavior it should be\n-    /// written as `a = a op a op b` as it's less confusing.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let mut a = 5;\n-    /// let b = 2;\n-    /// // ...\n-    /// a += a + b;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MISREFACTORED_ASSIGN_OP,\n-    suspicious,\n-    \"having a variable on both sides of an assign op\"\n-}\n-\n-declare_lint_pass!(AssignOps => [ASSIGN_OP_PATTERN, MISREFACTORED_ASSIGN_OP]);\n-\n-impl<'tcx> LateLintPass<'tcx> for AssignOps {\n-    #[allow(clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        match &expr.kind {\n-            hir::ExprKind::AssignOp(op, lhs, rhs) => {\n-                if let hir::ExprKind::Binary(binop, l, r) = &rhs.kind {\n-                    if op.node != binop.node {\n-                        return;\n-                    }\n-                    // lhs op= l op r\n-                    if eq_expr_value(cx, lhs, l) {\n-                        lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, r);\n-                    }\n-                    // lhs op= l commutative_op r\n-                    if is_commutative(op.node) && eq_expr_value(cx, lhs, r) {\n-                        lint_misrefactored_assign_op(cx, expr, *op, rhs, lhs, l);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::Assign(assignee, e, _) => {\n-                if let hir::ExprKind::Binary(op, l, r) = &e.kind {\n-                    let lint = |assignee: &hir::Expr<'_>, rhs: &hir::Expr<'_>| {\n-                        let ty = cx.typeck_results().expr_ty(assignee);\n-                        let rty = cx.typeck_results().expr_ty(rhs);\n-                        if_chain! {\n-                            if let Some((_, lang_item)) = binop_traits(op.node);\n-                            if let Ok(trait_id) = cx.tcx.lang_items().require(lang_item);\n-                            let parent_fn = cx.tcx.hir().get_parent_item(e.hir_id);\n-                            if trait_ref_of_method(cx, parent_fn)\n-                                .map_or(true, |t| t.path.res.def_id() != trait_id);\n-                            if implements_trait(cx, ty, trait_id, &[rty.into()]);\n-                            then {\n-                                span_lint_and_then(\n-                                    cx,\n-                                    ASSIGN_OP_PATTERN,\n-                                    expr.span,\n-                                    \"manual implementation of an assign operation\",\n-                                    |diag| {\n-                                        if let (Some(snip_a), Some(snip_r)) =\n-                                            (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span))\n-                                        {\n-                                            diag.span_suggestion(\n-                                                expr.span,\n-                                                \"replace it with\",\n-                                                format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n-                                                Applicability::MachineApplicable,\n-                                            );\n-                                        }\n-                                    },\n-                                );\n-                            }\n-                        }\n-                    };\n-\n-                    let mut visitor = ExprVisitor {\n-                        assignee,\n-                        counter: 0,\n-                        cx,\n-                    };\n-\n-                    walk_expr(&mut visitor, e);\n-\n-                    if visitor.counter == 1 {\n-                        // a = a op b\n-                        if eq_expr_value(cx, assignee, l) {\n-                            lint(assignee, r);\n-                        }\n-                        // a = b commutative_op a\n-                        // Limited to primitive type as these ops are know to be commutative\n-                        if eq_expr_value(cx, assignee, r) && cx.typeck_results().expr_ty(assignee).is_primitive_ty() {\n-                            match op.node {\n-                                hir::BinOpKind::Add\n-                                | hir::BinOpKind::Mul\n-                                | hir::BinOpKind::And\n-                                | hir::BinOpKind::Or\n-                                | hir::BinOpKind::BitXor\n-                                | hir::BinOpKind::BitAnd\n-                                | hir::BinOpKind::BitOr => {\n-                                    lint(assignee, l);\n-                                },\n-                                _ => {},\n-                            }\n-                        }\n-                    }\n-                }\n-            },\n-            _ => {},\n-        }\n-    }\n-}\n-\n-fn lint_misrefactored_assign_op(\n-    cx: &LateContext<'_>,\n-    expr: &hir::Expr<'_>,\n-    op: hir::BinOp,\n-    rhs: &hir::Expr<'_>,\n-    assignee: &hir::Expr<'_>,\n-    rhs_other: &hir::Expr<'_>,\n-) {\n-    span_lint_and_then(\n-        cx,\n-        MISREFACTORED_ASSIGN_OP,\n-        expr.span,\n-        \"variable appears on both sides of an assignment operation\",\n-        |diag| {\n-            if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs_other.span)) {\n-                let a = &sugg::Sugg::hir(cx, assignee, \"..\");\n-                let r = &sugg::Sugg::hir(cx, rhs, \"..\");\n-                let long = format!(\"{} = {}\", snip_a, sugg::make_binop(op.node.into(), a, r));\n-                diag.span_suggestion(\n-                    expr.span,\n-                    &format!(\n-                        \"did you mean `{} = {} {} {}` or `{}`? Consider replacing it with\",\n-                        snip_a,\n-                        snip_a,\n-                        op.node.as_str(),\n-                        snip_r,\n-                        long\n-                    ),\n-                    format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                diag.span_suggestion(\n-                    expr.span,\n-                    \"or\",\n-                    long,\n-                    Applicability::MaybeIncorrect, // snippet\n-                );\n-            }\n-        },\n-    );\n-}\n-\n-#[must_use]\n-fn is_commutative(op: hir::BinOpKind) -> bool {\n-    use rustc_hir::BinOpKind::{\n-        Add, And, BitAnd, BitOr, BitXor, Div, Eq, Ge, Gt, Le, Lt, Mul, Ne, Or, Rem, Shl, Shr, Sub,\n-    };\n-    match op {\n-        Add | Mul | And | Or | BitXor | BitAnd | BitOr | Eq | Ne => true,\n-        Sub | Div | Rem | Shl | Shr | Lt | Le | Ge | Gt => false,\n-    }\n-}\n-\n-struct ExprVisitor<'a, 'tcx> {\n-    assignee: &'a hir::Expr<'a>,\n-    counter: u8,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        if eq_expr_value(self.cx, self.assignee, expr) {\n-            self.counter += 1;\n-        }\n-\n-        walk_expr(self, expr);\n-    }\n-}"}, {"sha": "b43c11330f0d81a38ad7044784ee89b6fbd95359", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/751131b4acce37d0d4d62edd1eb831143c8fa46f/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751131b4acce37d0d4d62edd1eb831143c8fa46f/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=751131b4acce37d0d4d62edd1eb831143c8fa46f", "patch": "@@ -6,8 +6,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE),\n     LintId::of(approx_const::APPROX_CONSTANT),\n     LintId::of(assertions_on_constants::ASSERTIONS_ON_CONSTANTS),\n-    LintId::of(assign_ops::ASSIGN_OP_PATTERN),\n-    LintId::of(assign_ops::MISREFACTORED_ASSIGN_OP),\n     LintId::of(async_yields_async::ASYNC_YIELDS_ASYNC),\n     LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n     LintId::of(attrs::DEPRECATED_CFG_ATTR),\n@@ -260,6 +258,8 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n     LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(operators::ABSURD_EXTREME_COMPARISONS),\n+    LintId::of(operators::ASSIGN_OP_PATTERN),\n+    LintId::of(operators::MISREFACTORED_ASSIGN_OP),\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n     LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),"}, {"sha": "231511d46b729136ed7ac4640af9b3e7b7ec0592", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/751131b4acce37d0d4d62edd1eb831143c8fa46f/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751131b4acce37d0d4d62edd1eb831143c8fa46f/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=751131b4acce37d0d4d62edd1eb831143c8fa46f", "patch": "@@ -42,8 +42,6 @@ store.register_lints(&[\n     asm_syntax::INLINE_ASM_X86_ATT_SYNTAX,\n     asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX,\n     assertions_on_constants::ASSERTIONS_ON_CONSTANTS,\n-    assign_ops::ASSIGN_OP_PATTERN,\n-    assign_ops::MISREFACTORED_ASSIGN_OP,\n     async_yields_async::ASYNC_YIELDS_ASYNC,\n     attrs::ALLOW_ATTRIBUTES_WITHOUT_REASON,\n     attrs::BLANKET_CLIPPY_RESTRICTION_LINTS,\n@@ -435,8 +433,10 @@ store.register_lints(&[\n     only_used_in_recursion::ONLY_USED_IN_RECURSION,\n     open_options::NONSENSICAL_OPEN_OPTIONS,\n     operators::ABSURD_EXTREME_COMPARISONS,\n+    operators::ASSIGN_OP_PATTERN,\n     operators::FLOAT_ARITHMETIC,\n     operators::INTEGER_ARITHMETIC,\n+    operators::MISREFACTORED_ASSIGN_OP,\n     option_env_unwrap::OPTION_ENV_UNWRAP,\n     option_if_let_else::OPTION_IF_LET_ELSE,\n     overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL,"}, {"sha": "78df54a4fff6fdfb4baa62238d99a824db1fa6f1", "filename": "clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/751131b4acce37d0d4d62edd1eb831143c8fa46f/clippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751131b4acce37d0d4d62edd1eb831143c8fa46f/clippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_style.rs?ref=751131b4acce37d0d4d62edd1eb831143c8fa46f", "patch": "@@ -4,7 +4,6 @@\n \n store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(assertions_on_constants::ASSERTIONS_ON_CONSTANTS),\n-    LintId::of(assign_ops::ASSIGN_OP_PATTERN),\n     LintId::of(blacklisted_name::BLACKLISTED_NAME),\n     LintId::of(blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n     LintId::of(bool_assert_comparison::BOOL_ASSERT_COMPARISON),\n@@ -98,6 +97,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(non_copy_const::BORROW_INTERIOR_MUTABLE_CONST),\n     LintId::of(non_copy_const::DECLARE_INTERIOR_MUTABLE_CONST),\n     LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n+    LintId::of(operators::ASSIGN_OP_PATTERN),\n     LintId::of(ptr::CMP_NULL),\n     LintId::of(ptr::PTR_ARG),\n     LintId::of(ptr_eq::PTR_EQ),"}, {"sha": "4ee89b7bec5d4f30418773ed8f4304aa5355a430", "filename": "clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/751131b4acce37d0d4d62edd1eb831143c8fa46f/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751131b4acce37d0d4d62edd1eb831143c8fa46f/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=751131b4acce37d0d4d62edd1eb831143c8fa46f", "patch": "@@ -4,7 +4,6 @@\n \n store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec![\n     LintId::of(almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE),\n-    LintId::of(assign_ops::MISREFACTORED_ASSIGN_OP),\n     LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n@@ -29,6 +28,7 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(methods::SUSPICIOUS_MAP),\n     LintId::of(mut_key::MUTABLE_KEY_TYPE),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n+    LintId::of(operators::MISREFACTORED_ASSIGN_OP),\n     LintId::of(rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),"}, {"sha": "0f9e3b06233136aa998f8a5c158171c4c71e64b4", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/751131b4acce37d0d4d62edd1eb831143c8fa46f/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751131b4acce37d0d4d62edd1eb831143c8fa46f/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=751131b4acce37d0d4d62edd1eb831143c8fa46f", "patch": "@@ -174,7 +174,6 @@ mod as_conversions;\n mod as_underscore;\n mod asm_syntax;\n mod assertions_on_constants;\n-mod assign_ops;\n mod async_yields_async;\n mod attrs;\n mod await_holding_invalid;\n@@ -704,7 +703,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(doc::DocMarkdown::new(doc_valid_idents.clone())));\n     store.register_late_pass(|| Box::new(neg_multiply::NegMultiply));\n     store.register_late_pass(|| Box::new(mem_forget::MemForget));\n-    store.register_late_pass(|| Box::new(assign_ops::AssignOps));\n     store.register_late_pass(|| Box::new(let_if_seq::LetIfSeq));\n     store.register_late_pass(|| Box::new(mixed_read_write_in_expression::EvalOrderDependence));\n     store.register_late_pass(|| Box::new(missing_doc::MissingDoc::new()));"}, {"sha": "979e0a66707dda33463259430cefe05e6c01df62", "filename": "clippy_lints/src/operators/assign_op_pattern.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/751131b4acce37d0d4d62edd1eb831143c8fa46f/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751131b4acce37d0d4d62edd1eb831143c8fa46f/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs?ref=751131b4acce37d0d4d62edd1eb831143c8fa46f", "patch": "@@ -0,0 +1,101 @@\n+use clippy_utils::binop_traits;\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::implements_trait;\n+use clippy_utils::{eq_expr_value, trait_ref_of_method};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{walk_expr, Visitor};\n+use rustc_lint::LateContext;\n+\n+use super::ASSIGN_OP_PATTERN;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    assignee: &'tcx hir::Expr<'_>,\n+    e: &'tcx hir::Expr<'_>,\n+) {\n+    if let hir::ExprKind::Binary(op, l, r) = &e.kind {\n+        let lint = |assignee: &hir::Expr<'_>, rhs: &hir::Expr<'_>| {\n+            let ty = cx.typeck_results().expr_ty(assignee);\n+            let rty = cx.typeck_results().expr_ty(rhs);\n+            if_chain! {\n+                if let Some((_, lang_item)) = binop_traits(op.node);\n+                if let Ok(trait_id) = cx.tcx.lang_items().require(lang_item);\n+                let parent_fn = cx.tcx.hir().get_parent_item(e.hir_id);\n+                if trait_ref_of_method(cx, parent_fn)\n+                    .map_or(true, |t| t.path.res.def_id() != trait_id);\n+                if implements_trait(cx, ty, trait_id, &[rty.into()]);\n+                then {\n+                    span_lint_and_then(\n+                        cx,\n+                        ASSIGN_OP_PATTERN,\n+                        expr.span,\n+                        \"manual implementation of an assign operation\",\n+                        |diag| {\n+                            if let (Some(snip_a), Some(snip_r)) =\n+                                (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span))\n+                            {\n+                                diag.span_suggestion(\n+                                    expr.span,\n+                                    \"replace it with\",\n+                                    format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            }\n+                        },\n+                    );\n+                }\n+            }\n+        };\n+\n+        let mut visitor = ExprVisitor {\n+            assignee,\n+            counter: 0,\n+            cx,\n+        };\n+\n+        walk_expr(&mut visitor, e);\n+\n+        if visitor.counter == 1 {\n+            // a = a op b\n+            if eq_expr_value(cx, assignee, l) {\n+                lint(assignee, r);\n+            }\n+            // a = b commutative_op a\n+            // Limited to primitive type as these ops are know to be commutative\n+            if eq_expr_value(cx, assignee, r) && cx.typeck_results().expr_ty(assignee).is_primitive_ty() {\n+                match op.node {\n+                    hir::BinOpKind::Add\n+                    | hir::BinOpKind::Mul\n+                    | hir::BinOpKind::And\n+                    | hir::BinOpKind::Or\n+                    | hir::BinOpKind::BitXor\n+                    | hir::BinOpKind::BitAnd\n+                    | hir::BinOpKind::BitOr => {\n+                        lint(assignee, l);\n+                    },\n+                    _ => {},\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct ExprVisitor<'a, 'tcx> {\n+    assignee: &'a hir::Expr<'a>,\n+    counter: u8,\n+    cx: &'a LateContext<'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+        if eq_expr_value(self.cx, self.assignee, expr) {\n+            self.counter += 1;\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+}"}, {"sha": "0024384d9278daaaae0aba70a72c27013bad40de", "filename": "clippy_lints/src/operators/misrefactored_assign_op.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/751131b4acce37d0d4d62edd1eb831143c8fa46f/clippy_lints%2Fsrc%2Foperators%2Fmisrefactored_assign_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751131b4acce37d0d4d62edd1eb831143c8fa46f/clippy_lints%2Fsrc%2Foperators%2Fmisrefactored_assign_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fmisrefactored_assign_op.rs?ref=751131b4acce37d0d4d62edd1eb831143c8fa46f", "patch": "@@ -0,0 +1,84 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::eq_expr_value;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::sugg;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::MISREFACTORED_ASSIGN_OP;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    op: hir::BinOpKind,\n+    lhs: &'tcx hir::Expr<'_>,\n+    rhs: &'tcx hir::Expr<'_>,\n+) {\n+    if let hir::ExprKind::Binary(binop, l, r) = &rhs.kind {\n+        if op != binop.node {\n+            return;\n+        }\n+        // lhs op= l op r\n+        if eq_expr_value(cx, lhs, l) {\n+            lint_misrefactored_assign_op(cx, expr, op, rhs, lhs, r);\n+        }\n+        // lhs op= l commutative_op r\n+        if is_commutative(op) && eq_expr_value(cx, lhs, r) {\n+            lint_misrefactored_assign_op(cx, expr, op, rhs, lhs, l);\n+        }\n+    }\n+}\n+\n+fn lint_misrefactored_assign_op(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    op: hir::BinOpKind,\n+    rhs: &hir::Expr<'_>,\n+    assignee: &hir::Expr<'_>,\n+    rhs_other: &hir::Expr<'_>,\n+) {\n+    span_lint_and_then(\n+        cx,\n+        MISREFACTORED_ASSIGN_OP,\n+        expr.span,\n+        \"variable appears on both sides of an assignment operation\",\n+        |diag| {\n+            if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs_other.span)) {\n+                let a = &sugg::Sugg::hir(cx, assignee, \"..\");\n+                let r = &sugg::Sugg::hir(cx, rhs, \"..\");\n+                let long = format!(\"{} = {}\", snip_a, sugg::make_binop(op.into(), a, r));\n+                diag.span_suggestion(\n+                    expr.span,\n+                    &format!(\n+                        \"did you mean `{} = {} {} {}` or `{}`? Consider replacing it with\",\n+                        snip_a,\n+                        snip_a,\n+                        op.as_str(),\n+                        snip_r,\n+                        long\n+                    ),\n+                    format!(\"{} {}= {}\", snip_a, op.as_str(), snip_r),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                diag.span_suggestion(\n+                    expr.span,\n+                    \"or\",\n+                    long,\n+                    Applicability::MaybeIncorrect, // snippet\n+                );\n+            }\n+        },\n+    );\n+}\n+\n+#[must_use]\n+fn is_commutative(op: hir::BinOpKind) -> bool {\n+    use rustc_hir::BinOpKind::{\n+        Add, And, BitAnd, BitOr, BitXor, Div, Eq, Ge, Gt, Le, Lt, Mul, Ne, Or, Rem, Shl, Shr, Sub,\n+    };\n+    match op {\n+        Add | Mul | And | Or | BitXor | BitAnd | BitOr | Eq | Ne => true,\n+        Sub | Div | Rem | Shl | Shr | Lt | Le | Ge | Gt => false,\n+    }\n+}"}, {"sha": "c1d038aa2b1a83e8e51d07f37acc3411e3cad043", "filename": "clippy_lints/src/operators/mod.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/751131b4acce37d0d4d62edd1eb831143c8fa46f/clippy_lints%2Fsrc%2Foperators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/751131b4acce37d0d4d62edd1eb831143c8fa46f/clippy_lints%2Fsrc%2Foperators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fmod.rs?ref=751131b4acce37d0d4d62edd1eb831143c8fa46f", "patch": "@@ -3,6 +3,8 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n mod absurd_extreme_comparisons;\n+mod assign_op_pattern;\n+mod misrefactored_assign_op;\n mod numeric_arithmetic;\n \n declare_clippy_lint! {\n@@ -82,6 +84,68 @@ declare_clippy_lint! {\n     \"any floating-point arithmetic statement\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `a = a op b` or `a = b commutative_op a`\n+    /// patterns.\n+    ///\n+    /// ### Why is this bad?\n+    /// These can be written as the shorter `a op= b`.\n+    ///\n+    /// ### Known problems\n+    /// While forbidden by the spec, `OpAssign` traits may have\n+    /// implementations that differ from the regular `Op` impl.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let mut a = 5;\n+    /// let b = 0;\n+    /// // ...\n+    ///\n+    /// a = a + b;\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut a = 5;\n+    /// let b = 0;\n+    /// // ...\n+    ///\n+    /// a += b;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub ASSIGN_OP_PATTERN,\n+    style,\n+    \"assigning the result of an operation on a variable to that same variable\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `a op= a op b` or `a op= b op a` patterns.\n+    ///\n+    /// ### Why is this bad?\n+    /// Most likely these are bugs where one meant to write `a\n+    /// op= b`.\n+    ///\n+    /// ### Known problems\n+    /// Clippy cannot know for sure if `a op= a op b` should have\n+    /// been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore, it suggests both.\n+    /// If `a op= a op b` is really the correct behavior it should be\n+    /// written as `a = a op a op b` as it's less confusing.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let mut a = 5;\n+    /// let b = 2;\n+    /// // ...\n+    /// a += a + b;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MISREFACTORED_ASSIGN_OP,\n+    suspicious,\n+    \"having a variable on both sides of an assign op\"\n+}\n+\n #[derive(Default)]\n pub struct Operators {\n     arithmetic_context: numeric_arithmetic::Context,\n@@ -90,6 +154,8 @@ impl_lint_pass!(Operators => [\n     ABSURD_EXTREME_COMPARISONS,\n     INTEGER_ARITHMETIC,\n     FLOAT_ARITHMETIC,\n+    ASSIGN_OP_PATTERN,\n+    MISREFACTORED_ASSIGN_OP,\n ]);\n impl<'tcx> LateLintPass<'tcx> for Operators {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n@@ -102,6 +168,10 @@ impl<'tcx> LateLintPass<'tcx> for Operators {\n             },\n             ExprKind::AssignOp(op, lhs, rhs) => {\n                 self.arithmetic_context.check_binary(cx, e, op.node, lhs, rhs);\n+                misrefactored_assign_op::check(cx, e, op.node, lhs, rhs);\n+            },\n+            ExprKind::Assign(lhs, rhs, _) => {\n+                assign_op_pattern::check(cx, e, lhs, rhs);\n             },\n             ExprKind::Unary(op, arg) => {\n                 if op == UnOp::Neg {"}]}