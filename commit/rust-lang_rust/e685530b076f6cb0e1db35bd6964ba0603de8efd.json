{"sha": "e685530b076f6cb0e1db35bd6964ba0603de8efd", "node_id": "C_kwDOAAsO6NoAKGU2ODU1MzBiMDc2ZjZjYjBlMWRiMzViZDY5NjRiYTA2MDNkZThlZmQ", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-03T00:40:41Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-06T18:11:41Z"}, "message": "deduplicate some copy_op code", "tree": {"sha": "3694c21e8e24462016073c850b719348c1c6f964", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3694c21e8e24462016073c850b719348c1c6f964"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e685530b076f6cb0e1db35bd6964ba0603de8efd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e685530b076f6cb0e1db35bd6964ba0603de8efd", "html_url": "https://github.com/rust-lang/rust/commit/e685530b076f6cb0e1db35bd6964ba0603de8efd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e685530b076f6cb0e1db35bd6964ba0603de8efd/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "924a4cd008eb6e627c7828e241d25ce8457d84d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/924a4cd008eb6e627c7828e241d25ce8457d84d3", "html_url": "https://github.com/rust-lang/rust/commit/924a4cd008eb6e627c7828e241d25ce8457d84d3"}], "stats": {"total": 161, "additions": 74, "deletions": 87}, "files": [{"sha": "5d598b65c72247c6f4339dfec964a6067bb22a67", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e685530b076f6cb0e1db35bd6964ba0603de8efd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e685530b076f6cb0e1db35bd6964ba0603de8efd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=e685530b076f6cb0e1db35bd6964ba0603de8efd", "patch": "@@ -359,7 +359,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let src_field = self.operand_field(src, i)?;\n                     let dst_field = self.place_field(dest, i)?;\n                     if src_field.layout.ty == cast_ty_field.ty {\n-                        self.copy_op(&src_field, &dst_field)?;\n+                        self.copy_op(&src_field, &dst_field, /*allow_transmute*/ false)?;\n                     } else {\n                         self.unsize_into(&src_field, cast_ty_field, &dst_field)?;\n                     }"}, {"sha": "3892d1920cef7453b37875038704f03a80c0c353", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e685530b076f6cb0e1db35bd6964ba0603de8efd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e685530b076f6cb0e1db35bd6964ba0603de8efd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=e685530b076f6cb0e1db35bd6964ba0603de8efd", "patch": "@@ -800,7 +800,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 .local_to_op(self.frame(), mir::RETURN_PLACE, None)\n                 .expect(\"return place should always be live\");\n             let dest = self.frame().return_place;\n-            let err = self.copy_op_transmute(&op, &dest);\n+            let err = self.copy_op(&op, &dest, /*allow_transmute*/ true);\n             trace!(\"return value: {:?}\", self.dump_place(*dest));\n             // We delay actually short-circuiting on this error until *after* the stack frame is\n             // popped, since we want this error to be attributed to the caller, whose type defines"}, {"sha": "93b64d9d37a49e30e1290de7b776c49905a6a1e4", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e685530b076f6cb0e1db35bd6964ba0603de8efd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e685530b076f6cb0e1db35bd6964ba0603de8efd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=e685530b076f6cb0e1db35bd6964ba0603de8efd", "patch": "@@ -174,7 +174,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let val =\n                     self.tcx.const_eval_global_id(self.param_env, gid, Some(self.tcx.span))?;\n                 let val = self.const_val_to_op(val, ty, Some(dest.layout))?;\n-                self.copy_op(&val, dest)?;\n+                self.copy_op(&val, dest, /*allow_transmute*/ false)?;\n             }\n \n             sym::ctpop\n@@ -394,7 +394,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             sym::transmute => {\n-                self.copy_op_transmute(&args[0], dest)?;\n+                self.copy_op(&args[0], dest, /*allow_transmute*/ true)?;\n             }\n             sym::assert_inhabited | sym::assert_zero_valid | sym::assert_uninit_valid => {\n                 let ty = instance.substs.type_at(0);\n@@ -461,7 +461,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let place = self.mplace_index(&dest, i)?;\n                     let value =\n                         if i == index { *elem } else { self.mplace_index(&input, i)?.into() };\n-                    self.copy_op(&value, &place.into())?;\n+                    self.copy_op(&value, &place.into(), /*allow_transmute*/ false)?;\n                 }\n             }\n             sym::simd_extract => {\n@@ -473,11 +473,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     index,\n                     input_len\n                 );\n-                self.copy_op(&self.mplace_index(&input, index)?.into(), dest)?;\n+                self.copy_op(\n+                    &self.mplace_index(&input, index)?.into(),\n+                    dest,\n+                    /*allow_transmute*/ false,\n+                )?;\n             }\n             sym::likely | sym::unlikely | sym::black_box => {\n                 // These just return their argument\n-                self.copy_op(&args[0], dest)?;\n+                self.copy_op(&args[0], dest, /*allow_transmute*/ false)?;\n             }\n             sym::assume => {\n                 let cond = self.read_scalar(&args[0])?.check_init()?.to_bool()?;"}, {"sha": "57ecad07b42b4312686e57353362ff480e215c25", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 59, "deletions": 76, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/e685530b076f6cb0e1db35bd6964ba0603de8efd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e685530b076f6cb0e1db35bd6964ba0603de8efd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=e685530b076f6cb0e1db35bd6964ba0603de8efd", "patch": "@@ -10,8 +10,9 @@ use rustc_macros::HashStable;\n use rustc_middle::mir;\n use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::{self, Ty};\n-use rustc_target::abi::{Abi, Align, FieldsShape, TagEncoding};\n-use rustc_target::abi::{HasDataLayout, Size, VariantIdx, Variants};\n+use rustc_target::abi::{\n+    Abi, Align, FieldsShape, HasDataLayout, Size, TagEncoding, VariantIdx, Variants,\n+};\n \n use super::{\n     alloc_range, mir_assign_valid_types, AllocId, AllocRef, AllocRefMut, CheckInAllocMsg,\n@@ -772,51 +773,51 @@ where\n             }\n             Place::Ptr(mplace) => mplace, // already referring to memory\n         };\n-        let dest = MPlaceTy { mplace, layout: dest.layout, align: dest.align };\n \n         // This is already in memory, write there.\n-        self.write_immediate_to_mplace_no_validate(src, &dest)\n+        self.write_immediate_to_mplace_no_validate(src, dest.layout, dest.align, mplace)\n     }\n \n     /// Write an immediate to memory.\n     /// If you use this you are responsible for validating that things got copied at the\n-    /// right type.\n+    /// right layout.\n     fn write_immediate_to_mplace_no_validate(\n         &mut self,\n         value: Immediate<M::PointerTag>,\n-        dest: &MPlaceTy<'tcx, M::PointerTag>,\n+        layout: TyAndLayout<'tcx>,\n+        align: Align,\n+        dest: MemPlace<M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         // Note that it is really important that the type here is the right one, and matches the\n         // type things are read at. In case `value` is a `ScalarPair`, we don't do any magic here\n         // to handle padding properly, which is only correct if we never look at this data with the\n         // wrong type.\n \n         let tcx = *self.tcx;\n-        let Some(mut alloc) = self.get_place_alloc_mut(dest)? else {\n+        let Some(mut alloc) = self.get_place_alloc_mut(&MPlaceTy { mplace: dest, layout, align })? else {\n             // zero-sized access\n             return Ok(());\n         };\n \n         match value {\n             Immediate::Scalar(scalar) => {\n-                let Abi::Scalar(s) = dest.layout.abi else { span_bug!(\n+                let Abi::Scalar(s) = layout.abi else { span_bug!(\n                         self.cur_span(),\n-                        \"write_immediate_to_mplace: invalid Scalar layout: {:#?}\",\n-                        dest.layout\n+                        \"write_immediate_to_mplace: invalid Scalar layout: {layout:#?}\",\n                     )\n                 };\n                 let size = s.size(&tcx);\n-                assert_eq!(size, dest.layout.size, \"abi::Scalar size does not match layout size\");\n+                assert_eq!(size, layout.size, \"abi::Scalar size does not match layout size\");\n                 alloc.write_scalar(alloc_range(Size::ZERO, size), scalar)\n             }\n             Immediate::ScalarPair(a_val, b_val) => {\n                 // We checked `ptr_align` above, so all fields will have the alignment they need.\n                 // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n                 // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n-                let Abi::ScalarPair(a, b) = dest.layout.abi else { span_bug!(\n+                let Abi::ScalarPair(a, b) = layout.abi else { span_bug!(\n                         self.cur_span(),\n                         \"write_immediate_to_mplace: invalid ScalarPair layout: {:#?}\",\n-                        dest.layout\n+                        layout\n                     )\n                 };\n                 let (a_size, b_size) = (a.size(&tcx), b.size(&tcx));\n@@ -858,16 +859,17 @@ where\n         Ok(())\n     }\n \n-    /// Copies the data from an operand to a place. This does not support transmuting!\n-    /// Use `copy_op_transmute` if the layouts could disagree.\n+    /// Copies the data from an operand to a place.\n+    /// `allow_transmute` indicates whether the layouts may disagree.\n     #[inline(always)]\n     #[instrument(skip(self), level = \"debug\")]\n     pub fn copy_op(\n         &mut self,\n         src: &OpTy<'tcx, M::PointerTag>,\n         dest: &PlaceTy<'tcx, M::PointerTag>,\n+        allow_transmute: bool,\n     ) -> InterpResult<'tcx> {\n-        self.copy_op_no_validate(src, dest)?;\n+        self.copy_op_no_validate(src, dest, allow_transmute)?;\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n@@ -877,19 +879,22 @@ where\n         Ok(())\n     }\n \n-    /// Copies the data from an operand to a place. This does not support transmuting!\n-    /// Use `copy_op_transmute` if the layouts could disagree.\n+    /// Copies the data from an operand to a place.\n+    /// `allow_transmute` indicates whether the layouts may disagree.\n     /// Also, if you use this you are responsible for validating that things get copied at the\n     /// right type.\n     #[instrument(skip(self), level = \"debug\")]\n     fn copy_op_no_validate(\n         &mut self,\n         src: &OpTy<'tcx, M::PointerTag>,\n         dest: &PlaceTy<'tcx, M::PointerTag>,\n+        allow_transmute: bool,\n     ) -> InterpResult<'tcx> {\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n-        if !mir_assign_valid_types(*self.tcx, self.param_env, src.layout, dest.layout) {\n+        let layout_compat =\n+            mir_assign_valid_types(*self.tcx, self.param_env, src.layout, dest.layout);\n+        if !allow_transmute && !layout_compat {\n             span_bug!(\n                 self.cur_span(),\n                 \"type mismatch when copying!\\nsrc: {:?},\\ndest: {:?}\",\n@@ -898,82 +903,55 @@ where\n             );\n         }\n \n-        // Let us see if the layout is simple so we take a shortcut, avoid force_allocation.\n+        // Let us see if the layout is simple so we take a shortcut,\n+        // avoid force_allocation.\n         let src = match self.read_immediate_raw(src, /*force*/ false)? {\n             Ok(src_val) => {\n                 assert!(!src.layout.is_unsized(), \"cannot have unsized immediates\");\n+                assert!(\n+                    !dest.layout.is_unsized(),\n+                    \"the src is sized, so the dest must also be sized\"\n+                );\n+                assert_eq!(src.layout.size, dest.layout.size);\n                 // Yay, we got a value that we can write directly.\n-                return self.write_immediate_no_validate(*src_val, dest);\n+                return if layout_compat {\n+                    self.write_immediate_no_validate(*src_val, dest)\n+                } else {\n+                    // This is tricky. The problematic case is `ScalarPair`: the `src_val` was\n+                    // loaded using the offsets defined by `src.layout`. When we put this back into\n+                    // the destination, we have to use the same offsets! So (a) we make sure we\n+                    // write back to memory, and (b) we use `dest` *with the source layout*.\n+                    let dest_mem = self.force_allocation(dest)?;\n+                    self.write_immediate_to_mplace_no_validate(\n+                        *src_val,\n+                        src.layout,\n+                        dest_mem.align,\n+                        *dest_mem,\n+                    )\n+                };\n             }\n             Err(mplace) => mplace,\n         };\n         // Slow path, this does not fit into an immediate. Just memcpy.\n         trace!(\"copy_op: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);\n \n-        let dest = self.force_allocation(dest)?;\n+        let dest = self.force_allocation(&dest)?;\n         let Some((dest_size, _)) = self.size_and_align_of_mplace(&dest)? else {\n             span_bug!(self.cur_span(), \"copy_op needs (dynamically) sized values\")\n         };\n         if cfg!(debug_assertions) {\n             let src_size = self.size_and_align_of_mplace(&src)?.unwrap().0;\n             assert_eq!(src_size, dest_size, \"Cannot copy differently-sized data\");\n+        } else {\n+            // As a cheap approximation, we compare the fixed parts of the size.\n+            assert_eq!(src.layout.size, dest.layout.size);\n         }\n \n         self.mem_copy(\n             src.ptr, src.align, dest.ptr, dest.align, dest_size, /*nonoverlapping*/ false,\n         )\n     }\n \n-    /// Copies the data from an operand to a place. The layouts may disagree, but they must\n-    /// have the same size.\n-    pub fn copy_op_transmute(\n-        &mut self,\n-        src: &OpTy<'tcx, M::PointerTag>,\n-        dest: &PlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx> {\n-        if mir_assign_valid_types(*self.tcx, self.param_env, src.layout, dest.layout) {\n-            // Fast path: Just use normal `copy_op`. This is faster because it tries\n-            // `read_immediate_raw` first before doing `force_allocation`.\n-            return self.copy_op(src, dest);\n-        }\n-        // Unsized copies rely on interpreting `src.meta` with `dest.layout`, we want\n-        // to avoid that here.\n-        assert!(\n-            !src.layout.is_unsized() && !dest.layout.is_unsized(),\n-            \"Cannot transmute unsized data\"\n-        );\n-        // We still require the sizes to match.\n-        if src.layout.size != dest.layout.size {\n-            span_bug!(\n-                self.cur_span(),\n-                \"size-changing transmute, should have been caught by transmute checking: {:#?}\\ndest: {:#?}\",\n-                src,\n-                dest\n-            );\n-        }\n-\n-        // The hard case is `ScalarPair`.  `src` is already read from memory in this case,\n-        // using `src.layout` to figure out which bytes to use for the 1st and 2nd field.\n-        // We have to write them to `dest` at the offsets they were *read at*, which is\n-        // not necessarily the same as the offsets in `dest.layout`!\n-        // Hence we do the copy with the source layout on both sides.  We also make sure to write\n-        // into memory, because if `dest` is a local we would not even have a way to write\n-        // at the `src` offsets; the fact that we came from a different layout would\n-        // just be lost.\n-        let dest = self.force_allocation(dest)?;\n-        self.copy_op_no_validate(\n-            src,\n-            &PlaceTy::from(MPlaceTy { mplace: *dest, layout: src.layout, align: dest.align }),\n-        )?;\n-\n-        if M::enforce_validity(self) {\n-            // Data got changed, better make sure it matches the type!\n-            self.validate_operand(&dest.into())?;\n-        }\n-\n-        Ok(())\n-    }\n-\n     /// Ensures that a place is in memory, and returns where it is.\n     /// If the place currently refers to a local that doesn't yet have a matching allocation,\n     /// create such an allocation.\n@@ -997,18 +975,23 @@ where\n                         if local_layout.is_unsized() {\n                             throw_unsup_format!(\"unsized locals are not supported\");\n                         }\n-                        let mplace = self.allocate(local_layout, MemoryKind::Stack)?;\n+                        let mplace = *self.allocate(local_layout, MemoryKind::Stack)?;\n                         if !matches!(local_val, Immediate::Uninit) {\n                             // Preserve old value. (As an optimization, we can skip this if it was uninit.)\n                             // We don't have to validate as we can assume the local\n                             // was already valid for its type.\n-                            self.write_immediate_to_mplace_no_validate(local_val, &mplace)?;\n+                            self.write_immediate_to_mplace_no_validate(\n+                                local_val,\n+                                local_layout,\n+                                local_layout.align.abi,\n+                                mplace,\n+                            )?;\n                         }\n                         // Now we can call `access_mut` again, asserting it goes well,\n                         // and actually overwrite things.\n                         *M::access_local_mut(self, frame, local).unwrap() =\n-                            Operand::Indirect(*mplace);\n-                        *mplace\n+                            Operand::Indirect(mplace);\n+                        mplace\n                     }\n                     &mut Operand::Indirect(mplace) => mplace, // this already was an indirect local\n                 }"}, {"sha": "240910c08b2ed2ddf1cfa10623c693ed8e6a1377", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e685530b076f6cb0e1db35bd6964ba0603de8efd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e685530b076f6cb0e1db35bd6964ba0603de8efd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=e685530b076f6cb0e1db35bd6964ba0603de8efd", "patch": "@@ -169,7 +169,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Use(ref operand) => {\n                 // Avoid recomputing the layout\n                 let op = self.eval_operand(operand, Some(dest.layout))?;\n-                self.copy_op(&op, &dest)?;\n+                self.copy_op(&op, &dest, /*allow_transmute*/ false)?;\n             }\n \n             BinaryOp(bin_op, box (ref left, ref right)) => {\n@@ -204,7 +204,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 for (field_index, operand) in operands.iter().enumerate() {\n                     let op = self.eval_operand(operand, None)?;\n                     let field_dest = self.place_field(&dest, field_index)?;\n-                    self.copy_op(&op, &field_dest)?;\n+                    self.copy_op(&op, &field_dest, /*allow_transmute*/ false)?;\n                 }\n             }\n \n@@ -220,7 +220,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 } else {\n                     // Write the src to the first element.\n                     let first = self.mplace_field(&dest, 0)?;\n-                    self.copy_op(&src, &first.into())?;\n+                    self.copy_op(&src, &first.into(), /*allow_transmute*/ false)?;\n \n                     // This is performance-sensitive code for big static/const arrays! So we\n                     // avoid writing each operand individually and instead just make many copies"}, {"sha": "515cc222dc69a21b75218e5495da73cf6d108a1b", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e685530b076f6cb0e1db35bd6964ba0603de8efd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e685530b076f6cb0e1db35bd6964ba0603de8efd/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=e685530b076f6cb0e1db35bd6964ba0603de8efd", "patch": "@@ -321,7 +321,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // FIXME: Depending on the PassMode, this should reset some padding to uninitialized. (This\n         // is true for all `copy_op`, but there are a lot of special cases for argument passing\n         // specifically.)\n-        self.copy_op_transmute(&caller_arg, callee_arg)\n+        self.copy_op(&caller_arg, callee_arg, /*allow_transmute*/ true)\n     }\n \n     /// Call this function -- pushing the stack frame and initializing the arguments."}]}