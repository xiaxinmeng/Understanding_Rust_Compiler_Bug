{"sha": "30dc32b10eb53e4a92c61a42062983db58838217", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZGMzMmIxMGViNTNlNGE5MmM2MWE0MjA2Mjk4M2RiNTg4MzgyMTc=", "commit": {"author": {"name": "Sebastian Dr\u00f6ge", "email": "sebastian@centricular.com", "date": "2020-08-28T05:55:41Z"}, "committer": {"name": "Sebastian Dr\u00f6ge", "email": "sebastian@centricular.com", "date": "2020-08-30T20:13:46Z"}, "message": "Add (non-public) slice::split_at_unchecked() and split_at_mut_unchecked()\n\nThese are unsafe variants of the non-unchecked functions and don't do\nany bounds checking.\n\nFor the time being these are not public and only a preparation for the\nfollowing commit. Making it public and stabilization can follow later\nand be discussed in https://github.com/rust-lang/rust/issues/76014 .", "tree": {"sha": "3d61a0c57703961d5c77b23120c064378c0ee64e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d61a0c57703961d5c77b23120c064378c0ee64e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30dc32b10eb53e4a92c61a42062983db58838217", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30dc32b10eb53e4a92c61a42062983db58838217", "html_url": "https://github.com/rust-lang/rust/commit/30dc32b10eb53e4a92c61a42062983db58838217", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30dc32b10eb53e4a92c61a42062983db58838217/comments", "author": {"login": "sdroege", "id": 301846, "node_id": "MDQ6VXNlcjMwMTg0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/301846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sdroege", "html_url": "https://github.com/sdroege", "followers_url": "https://api.github.com/users/sdroege/followers", "following_url": "https://api.github.com/users/sdroege/following{/other_user}", "gists_url": "https://api.github.com/users/sdroege/gists{/gist_id}", "starred_url": "https://api.github.com/users/sdroege/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sdroege/subscriptions", "organizations_url": "https://api.github.com/users/sdroege/orgs", "repos_url": "https://api.github.com/users/sdroege/repos", "events_url": "https://api.github.com/users/sdroege/events{/privacy}", "received_events_url": "https://api.github.com/users/sdroege/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sdroege", "id": 301846, "node_id": "MDQ6VXNlcjMwMTg0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/301846?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sdroege", "html_url": "https://github.com/sdroege", "followers_url": "https://api.github.com/users/sdroege/followers", "following_url": "https://api.github.com/users/sdroege/following{/other_user}", "gists_url": "https://api.github.com/users/sdroege/gists{/gist_id}", "starred_url": "https://api.github.com/users/sdroege/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sdroege/subscriptions", "organizations_url": "https://api.github.com/users/sdroege/orgs", "repos_url": "https://api.github.com/users/sdroege/repos", "events_url": "https://api.github.com/users/sdroege/events{/privacy}", "received_events_url": "https://api.github.com/users/sdroege/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fe9a33659641d062c1fe3577327147b4d9943a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fe9a33659641d062c1fe3577327147b4d9943a2", "html_url": "https://github.com/rust-lang/rust/commit/2fe9a33659641d062c1fe3577327147b4d9943a2"}], "stats": {"total": 102, "additions": 94, "deletions": 8}, "files": [{"sha": "d5f32ccc49bd636764a465df02308b8350686ae7", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 94, "deletions": 8, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/30dc32b10eb53e4a92c61a42062983db58838217/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30dc32b10eb53e4a92c61a42062983db58838217/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=30dc32b10eb53e4a92c61a42062983db58838217", "patch": "@@ -1148,7 +1148,10 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n-        (&self[..mid], &self[mid..])\n+        assert!(mid <= self.len());\n+        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n+        // fulfills the requirements of `from_raw_parts_mut`.\n+        unsafe { self.split_at_unchecked(mid) }\n     }\n \n     /// Divides one mutable slice into two at an index.\n@@ -1178,16 +1181,99 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n-        let len = self.len();\n-        let ptr = self.as_mut_ptr();\n-\n+        assert!(mid <= self.len());\n         // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n         // fulfills the requirements of `from_raw_parts_mut`.\n-        unsafe {\n-            assert!(mid <= len);\n+        unsafe { self.split_at_mut_unchecked(mid) }\n+    }\n \n-            (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid))\n-        }\n+    /// Divides one slice into two at an index, without doing bounds checking.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// This is generally not recommended, use with caution!\n+    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n+    /// even if the resulting reference is not used.\n+    /// For a safe alternative see [`split_at`].\n+    ///\n+    /// [`split_at`]: #method.split_at\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```compile_fail\n+    /// #![feature(slice_split_at_unchecked)]\n+    ///\n+    /// let v = [1, 2, 3, 4, 5, 6];\n+    ///\n+    /// unsafe {\n+    ///    let (left, right) = v.split_at_unchecked(0);\n+    ///    assert!(left == []);\n+    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// unsafe {\n+    ///     let (left, right) = v.split_at_unchecked(2);\n+    ///     assert!(left == [1, 2]);\n+    ///     assert!(right == [3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// unsafe {\n+    ///     let (left, right) = v.split_at_unchecked(6);\n+    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == []);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"slice_split_at_unchecked\", reason = \"new API\", issue = \"76014\")]\n+    #[inline]\n+    unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n+        // SAFETY: Caller has to check that 0 <= mid < self.len()\n+        unsafe { (self.get_unchecked(..mid), self.get_unchecked(mid..)) }\n+    }\n+\n+    /// Divides one mutable slice into two at an index, without doing bounds checking.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// This is generally not recommended, use with caution!\n+    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n+    /// even if the resulting reference is not used.\n+    /// For a safe alternative see [`split_at_mut`].\n+    ///\n+    /// [`split_at_mut`]: #method.split_at_mut\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```compile_fail\n+    /// #![feature(slice_split_at_unchecked)]\n+    ///\n+    /// let mut v = [1, 0, 3, 0, 5, 6];\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// unsafe {\n+    ///     let (left, right) = v.split_at_mut_unchecked(2);\n+    ///     assert!(left == [1, 0]);\n+    ///     assert!(right == [3, 0, 5, 6]);\n+    ///     left[1] = 2;\n+    ///     right[1] = 4;\n+    /// }\n+    /// assert!(v == [1, 2, 3, 4, 5, 6]);\n+    /// ```\n+    #[unstable(feature = \"slice_split_at_unchecked\", reason = \"new API\", issue = \"76014\")]\n+    #[inline]\n+    unsafe fn split_at_mut_unchecked(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n+        let len = self.len();\n+        let ptr = self.as_mut_ptr();\n+\n+        // SAFETY: Caller has to check that 0 <= mid < self.len().\n+        //\n+        // [ptr; mid] and [mid; len] are not overlapping, so returning a mutable reference\n+        // is fine.\n+        unsafe { (from_raw_parts_mut(ptr, mid), from_raw_parts_mut(ptr.add(mid), len - mid)) }\n     }\n \n     /// Returns an iterator over subslices separated by elements that match"}]}