{"sha": "a02014280586b53997622c501db00398376967a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMjAxNDI4MDU4NmI1Mzk5NzYyMmM1MDFkYjAwMzk4Mzc2OTY3YTg=", "commit": {"author": {"name": "Nathan West", "email": "Lucretiel@gmail.com", "date": "2020-09-11T03:39:55Z"}, "committer": {"name": "Nathan West", "email": "Lucretiel@gmail.com", "date": "2020-09-11T03:39:55Z"}, "message": "Refactor io/buffered.rs into submodules", "tree": {"sha": "65eb6e53da55ef22d567ca63d1e7c0d4c1864c0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65eb6e53da55ef22d567ca63d1e7c0d4c1864c0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a02014280586b53997622c501db00398376967a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a02014280586b53997622c501db00398376967a8", "html_url": "https://github.com/rust-lang/rust/commit/a02014280586b53997622c501db00398376967a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a02014280586b53997622c501db00398376967a8/comments", "author": {"login": "Lucretiel", "id": 1823405, "node_id": "MDQ6VXNlcjE4MjM0MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1823405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lucretiel", "html_url": "https://github.com/Lucretiel", "followers_url": "https://api.github.com/users/Lucretiel/followers", "following_url": "https://api.github.com/users/Lucretiel/following{/other_user}", "gists_url": "https://api.github.com/users/Lucretiel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lucretiel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lucretiel/subscriptions", "organizations_url": "https://api.github.com/users/Lucretiel/orgs", "repos_url": "https://api.github.com/users/Lucretiel/repos", "events_url": "https://api.github.com/users/Lucretiel/events{/privacy}", "received_events_url": "https://api.github.com/users/Lucretiel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Lucretiel", "id": 1823405, "node_id": "MDQ6VXNlcjE4MjM0MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1823405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lucretiel", "html_url": "https://github.com/Lucretiel", "followers_url": "https://api.github.com/users/Lucretiel/followers", "following_url": "https://api.github.com/users/Lucretiel/following{/other_user}", "gists_url": "https://api.github.com/users/Lucretiel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lucretiel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lucretiel/subscriptions", "organizations_url": "https://api.github.com/users/Lucretiel/orgs", "repos_url": "https://api.github.com/users/Lucretiel/repos", "events_url": "https://api.github.com/users/Lucretiel/events{/privacy}", "received_events_url": "https://api.github.com/users/Lucretiel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee04f9a4dac3e72914862e9f2046eee70aedcbfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee04f9a4dac3e72914862e9f2046eee70aedcbfd", "html_url": "https://github.com/rust-lang/rust/commit/ee04f9a4dac3e72914862e9f2046eee70aedcbfd"}], "stats": {"total": 2637, "additions": 1331, "deletions": 1306}, "files": [{"sha": "7329ea53736ec5852118f6f4cb37a549df69dfab", "filename": "library/std/src/io/buffered.rs", "status": "modified", "additions": 19, "deletions": 1306, "changes": 1325, "blob_url": "https://github.com/rust-lang/rust/blob/a02014280586b53997622c501db00398376967a8/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02014280586b53997622c501db00398376967a8/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs?ref=a02014280586b53997622c501db00398376967a8", "patch": "@@ -1,506 +1,21 @@\n //! Buffering wrappers for I/O traits\n \n+mod bufreader;\n+mod bufwriter;\n+mod linewriter;\n+mod linewritershim;\n+\n #[cfg(test)]\n mod tests;\n \n-use crate::io::prelude::*;\n-\n-use crate::cmp;\n use crate::error;\n use crate::fmt;\n-use crate::io::{\n-    self, Error, ErrorKind, Initializer, IoSlice, IoSliceMut, SeekFrom, DEFAULT_BUF_SIZE,\n-};\n-use crate::memchr;\n-\n-/// The `BufReader<R>` struct adds buffering to any reader.\n-///\n-/// It can be excessively inefficient to work directly with a [`Read`] instance.\n-/// For example, every call to [`read`][`TcpStream::read`] on [`TcpStream`]\n-/// results in a system call. A `BufReader<R>` performs large, infrequent reads on\n-/// the underlying [`Read`] and maintains an in-memory buffer of the results.\n-///\n-/// `BufReader<R>` can improve the speed of programs that make *small* and\n-/// *repeated* read calls to the same file or network socket. It does not\n-/// help when reading very large amounts at once, or reading just one or a few\n-/// times. It also provides no advantage when reading from a source that is\n-/// already in memory, like a [`Vec`]`<u8>`.\n-///\n-/// When the `BufReader<R>` is dropped, the contents of its buffer will be\n-/// discarded. Creating multiple instances of a `BufReader<R>` on the same\n-/// stream can cause data loss. Reading from the underlying reader after\n-/// unwrapping the `BufReader<R>` with [`BufReader::into_inner`] can also cause\n-/// data loss.\n-///\n-/// [`TcpStream::read`]: Read::read\n-/// [`TcpStream`]: crate::net::TcpStream\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::io::prelude::*;\n-/// use std::io::BufReader;\n-/// use std::fs::File;\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     let f = File::open(\"log.txt\")?;\n-///     let mut reader = BufReader::new(f);\n-///\n-///     let mut line = String::new();\n-///     let len = reader.read_line(&mut line)?;\n-///     println!(\"First line is {} bytes long\", len);\n-///     Ok(())\n-/// }\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct BufReader<R> {\n-    inner: R,\n-    buf: Box<[u8]>,\n-    pos: usize,\n-    cap: usize,\n-}\n-\n-impl<R: Read> BufReader<R> {\n-    /// Creates a new `BufReader<R>` with a default buffer capacity. The default is currently 8 KB,\n-    /// but may change in the future.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufReader;\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f = File::open(\"log.txt\")?;\n-    ///     let reader = BufReader::new(f);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(inner: R) -> BufReader<R> {\n-        BufReader::with_capacity(DEFAULT_BUF_SIZE, inner)\n-    }\n-\n-    /// Creates a new `BufReader<R>` with the specified buffer capacity.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Creating a buffer with ten bytes of capacity:\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufReader;\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f = File::open(\"log.txt\")?;\n-    ///     let reader = BufReader::with_capacity(10, f);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: usize, inner: R) -> BufReader<R> {\n-        unsafe {\n-            let mut buffer = Vec::with_capacity(capacity);\n-            buffer.set_len(capacity);\n-            inner.initializer().initialize(&mut buffer);\n-            BufReader { inner, buf: buffer.into_boxed_slice(), pos: 0, cap: 0 }\n-        }\n-    }\n-}\n-\n-impl<R> BufReader<R> {\n-    /// Gets a reference to the underlying reader.\n-    ///\n-    /// It is inadvisable to directly read from the underlying reader.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufReader;\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f1 = File::open(\"log.txt\")?;\n-    ///     let reader = BufReader::new(f1);\n-    ///\n-    ///     let f2 = reader.get_ref();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_ref(&self) -> &R {\n-        &self.inner\n-    }\n-\n-    /// Gets a mutable reference to the underlying reader.\n-    ///\n-    /// It is inadvisable to directly read from the underlying reader.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufReader;\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f1 = File::open(\"log.txt\")?;\n-    ///     let mut reader = BufReader::new(f1);\n-    ///\n-    ///     let f2 = reader.get_mut();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut R {\n-        &mut self.inner\n-    }\n-\n-    /// Returns a reference to the internally buffered data.\n-    ///\n-    /// Unlike [`fill_buf`], this will not attempt to fill the buffer if it is empty.\n-    ///\n-    /// [`fill_buf`]: BufRead::fill_buf\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::{BufReader, BufRead};\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f = File::open(\"log.txt\")?;\n-    ///     let mut reader = BufReader::new(f);\n-    ///     assert!(reader.buffer().is_empty());\n-    ///\n-    ///     if reader.fill_buf()?.len() > 0 {\n-    ///         assert!(!reader.buffer().is_empty());\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n-    pub fn buffer(&self) -> &[u8] {\n-        &self.buf[self.pos..self.cap]\n-    }\n-\n-    /// Returns the number of bytes the internal buffer can hold at once.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::{BufReader, BufRead};\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f = File::open(\"log.txt\")?;\n-    ///     let mut reader = BufReader::new(f);\n-    ///\n-    ///     let capacity = reader.capacity();\n-    ///     let buffer = reader.fill_buf()?;\n-    ///     assert!(buffer.len() <= capacity);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"buffered_io_capacity\", since = \"1.46.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.buf.len()\n-    }\n-\n-    /// Unwraps this `BufReader<R>`, returning the underlying reader.\n-    ///\n-    /// Note that any leftover data in the internal buffer is lost. Therefore,\n-    /// a following read from the underlying reader may lead to data loss.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufReader;\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f1 = File::open(\"log.txt\")?;\n-    ///     let reader = BufReader::new(f1);\n-    ///\n-    ///     let f2 = reader.into_inner();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_inner(self) -> R {\n-        self.inner\n-    }\n-\n-    /// Invalidates all data in the internal buffer.\n-    #[inline]\n-    fn discard_buffer(&mut self) {\n-        self.pos = 0;\n-        self.cap = 0;\n-    }\n-}\n-\n-impl<R: Seek> BufReader<R> {\n-    /// Seeks relative to the current position. If the new position lies within the buffer,\n-    /// the buffer will not be flushed, allowing for more efficient seeks.\n-    /// This method does not return the location of the underlying reader, so the caller\n-    /// must track this information themselves if it is required.\n-    #[unstable(feature = \"bufreader_seek_relative\", issue = \"31100\")]\n-    pub fn seek_relative(&mut self, offset: i64) -> io::Result<()> {\n-        let pos = self.pos as u64;\n-        if offset < 0 {\n-            if let Some(new_pos) = pos.checked_sub((-offset) as u64) {\n-                self.pos = new_pos as usize;\n-                return Ok(());\n-            }\n-        } else {\n-            if let Some(new_pos) = pos.checked_add(offset as u64) {\n-                if new_pos <= self.cap as u64 {\n-                    self.pos = new_pos as usize;\n-                    return Ok(());\n-                }\n-            }\n-        }\n-        self.seek(SeekFrom::Current(offset)).map(drop)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R: Read> Read for BufReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        // If we don't have any buffered data and we're doing a massive read\n-        // (larger than our internal buffer), bypass our internal buffer\n-        // entirely.\n-        if self.pos == self.cap && buf.len() >= self.buf.len() {\n-            self.discard_buffer();\n-            return self.inner.read(buf);\n-        }\n-        let nread = {\n-            let mut rem = self.fill_buf()?;\n-            rem.read(buf)?\n-        };\n-        self.consume(nread);\n-        Ok(nread)\n-    }\n-\n-    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n-        if self.pos == self.cap && total_len >= self.buf.len() {\n-            self.discard_buffer();\n-            return self.inner.read_vectored(bufs);\n-        }\n-        let nread = {\n-            let mut rem = self.fill_buf()?;\n-            rem.read_vectored(bufs)?\n-        };\n-        self.consume(nread);\n-        Ok(nread)\n-    }\n-\n-    fn is_read_vectored(&self) -> bool {\n-        self.inner.is_read_vectored()\n-    }\n-\n-    // we can't skip unconditionally because of the large buffer case in read.\n-    unsafe fn initializer(&self) -> Initializer {\n-        self.inner.initializer()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R: Read> BufRead for BufReader<R> {\n-    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n-        // If we've reached the end of our internal buffer then we need to fetch\n-        // some more data from the underlying reader.\n-        // Branch using `>=` instead of the more correct `==`\n-        // to tell the compiler that the pos..cap slice is always valid.\n-        if self.pos >= self.cap {\n-            debug_assert!(self.pos == self.cap);\n-            self.cap = self.inner.read(&mut self.buf)?;\n-            self.pos = 0;\n-        }\n-        Ok(&self.buf[self.pos..self.cap])\n-    }\n-\n-    fn consume(&mut self, amt: usize) {\n-        self.pos = cmp::min(self.pos + amt, self.cap);\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R> fmt::Debug for BufReader<R>\n-where\n-    R: fmt::Debug,\n-{\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt.debug_struct(\"BufReader\")\n-            .field(\"reader\", &self.inner)\n-            .field(\"buffer\", &format_args!(\"{}/{}\", self.cap - self.pos, self.buf.len()))\n-            .finish()\n-    }\n-}\n+use crate::io::Error;\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R: Seek> Seek for BufReader<R> {\n-    /// Seek to an offset, in bytes, in the underlying reader.\n-    ///\n-    /// The position used for seeking with [`SeekFrom::Current`]`(_)` is the\n-    /// position the underlying reader would be at if the `BufReader<R>` had no\n-    /// internal buffer.\n-    ///\n-    /// Seeking always discards the internal buffer, even if the seek position\n-    /// would otherwise fall within it. This guarantees that calling\n-    /// [`BufReader::into_inner()`] immediately after a seek yields the underlying reader\n-    /// at the same position.\n-    ///\n-    /// To seek without discarding the internal buffer, use [`BufReader::seek_relative`].\n-    ///\n-    /// See [`std::io::Seek`] for more details.\n-    ///\n-    /// Note: In the edge case where you're seeking with [`SeekFrom::Current`]`(n)`\n-    /// where `n` minus the internal buffer length overflows an `i64`, two\n-    /// seeks will be performed instead of one. If the second seek returns\n-    /// [`Err`], the underlying reader will be left at the same position it would\n-    /// have if you called `seek` with [`SeekFrom::Current`]`(0)`.\n-    ///\n-    /// [`std::io::Seek`]: Seek\n-    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n-        let result: u64;\n-        if let SeekFrom::Current(n) = pos {\n-            let remainder = (self.cap - self.pos) as i64;\n-            // it should be safe to assume that remainder fits within an i64 as the alternative\n-            // means we managed to allocate 8 exbibytes and that's absurd.\n-            // But it's not out of the realm of possibility for some weird underlying reader to\n-            // support seeking by i64::MIN so we need to handle underflow when subtracting\n-            // remainder.\n-            if let Some(offset) = n.checked_sub(remainder) {\n-                result = self.inner.seek(SeekFrom::Current(offset))?;\n-            } else {\n-                // seek backwards by our remainder, and then by the offset\n-                self.inner.seek(SeekFrom::Current(-remainder))?;\n-                self.discard_buffer();\n-                result = self.inner.seek(SeekFrom::Current(n))?;\n-            }\n-        } else {\n-            // Seeking with Start/End doesn't care about our buffer length.\n-            result = self.inner.seek(pos)?;\n-        }\n-        self.discard_buffer();\n-        Ok(result)\n-    }\n-\n-    /// Returns the current seek position from the start of the stream.\n-    ///\n-    /// The value returned is equivalent to `self.seek(SeekFrom::Current(0))`\n-    /// but does not flush the internal buffer. Due to this optimization the\n-    /// function does not guarantee that calling `.into_inner()` immediately\n-    /// afterwards will yield the underlying reader at the same position. Use\n-    /// [`BufReader::seek`] instead if you require that guarantee.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if the position of the inner reader is smaller\n-    /// than the amount of buffered data. That can happen if the inner reader\n-    /// has an incorrect implementation of [`Seek::stream_position`], or if the\n-    /// position has gone out of sync due to calling [`Seek::seek`] directly on\n-    /// the underlying reader.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```no_run\n-    /// #![feature(seek_convenience)]\n-    /// use std::{\n-    ///     io::{self, BufRead, BufReader, Seek},\n-    ///     fs::File,\n-    /// };\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let mut f = BufReader::new(File::open(\"foo.txt\")?);\n-    ///\n-    ///     let before = f.stream_position()?;\n-    ///     f.read_line(&mut String::new())?;\n-    ///     let after = f.stream_position()?;\n-    ///\n-    ///     println!(\"The first line was {} bytes long\", after - before);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    fn stream_position(&mut self) -> io::Result<u64> {\n-        let remainder = (self.cap - self.pos) as u64;\n-        self.inner.stream_position().map(|pos| {\n-            pos.checked_sub(remainder).expect(\n-                \"overflow when subtracting remaining buffer size from inner stream position\",\n-            )\n-        })\n-    }\n-}\n-\n-/// Wraps a writer and buffers its output.\n-///\n-/// It can be excessively inefficient to work directly with something that\n-/// implements [`Write`]. For example, every call to\n-/// [`write`][`TcpStream::write`] on [`TcpStream`] results in a system call. A\n-/// `BufWriter<W>` keeps an in-memory buffer of data and writes it to an underlying\n-/// writer in large, infrequent batches.\n-///\n-/// `BufWriter<W>` can improve the speed of programs that make *small* and\n-/// *repeated* write calls to the same file or network socket. It does not\n-/// help when writing very large amounts at once, or writing just one or a few\n-/// times. It also provides no advantage when writing to a destination that is\n-/// in memory, like a [`Vec`]<u8>`.\n-///\n-/// It is critical to call [`flush`] before `BufWriter<W>` is dropped. Though\n-/// dropping will attempt to flush the contents of the buffer, any errors\n-/// that happen in the process of dropping will be ignored. Calling [`flush`]\n-/// ensures that the buffer is empty and thus dropping will not even attempt\n-/// file operations.\n-///\n-/// # Examples\n-///\n-/// Let's write the numbers one through ten to a [`TcpStream`]:\n-///\n-/// ```no_run\n-/// use std::io::prelude::*;\n-/// use std::net::TcpStream;\n-///\n-/// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n-///\n-/// for i in 0..10 {\n-///     stream.write(&[i+1]).unwrap();\n-/// }\n-/// ```\n-///\n-/// Because we're not buffering, we write each one in turn, incurring the\n-/// overhead of a system call per byte written. We can fix this with a\n-/// `BufWriter<W>`:\n-///\n-/// ```no_run\n-/// use std::io::prelude::*;\n-/// use std::io::BufWriter;\n-/// use std::net::TcpStream;\n-///\n-/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-///\n-/// for i in 0..10 {\n-///     stream.write(&[i+1]).unwrap();\n-/// }\n-/// stream.flush().unwrap();\n-/// ```\n-///\n-/// By wrapping the stream with a `BufWriter<W>`, these ten writes are all grouped\n-/// together by the buffer and will all be written out in one system call when\n-/// the `stream` is flushed.\n-///\n-/// [`TcpStream::write`]: Write::write\n-/// [`TcpStream`]: crate::net::TcpStream\n-/// [`flush`]: Write::flush\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct BufWriter<W: Write> {\n-    inner: Option<W>,\n-    buf: Vec<u8>,\n-    // #30888: If the inner writer panics in a call to write, we don't want to\n-    // write the buffered data a second time in BufWriter's destructor. This\n-    // flag tells the Drop impl if it should skip the flush.\n-    panicked: bool,\n-}\n+pub use bufreader::BufReader;\n+pub use bufwriter::BufWriter;\n+pub use linewriter::LineWriter;\n+pub(super) use linewritershim::LineWriterShim;\n \n /// An error returned by [`BufWriter::into_inner`] which combines an error that\n /// happened while writing out the buffer, and the buffered writer object\n@@ -530,321 +45,19 @@ pub struct BufWriter<W: Write> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoInnerError<W>(W, Error);\n \n-impl<W: Write> BufWriter<W> {\n-    /// Creates a new `BufWriter<W>` with a default buffer capacity. The default is currently 8 KB,\n-    /// but may change in the future.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(inner: W) -> BufWriter<W> {\n-        BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n-    }\n-\n-    /// Creates a new `BufWriter<W>` with the specified buffer capacity.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Creating a buffer with a buffer of a hundred bytes.\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n-    /// let mut buffer = BufWriter::with_capacity(100, stream);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: usize, inner: W) -> BufWriter<W> {\n-        BufWriter { inner: Some(inner), buf: Vec::with_capacity(capacity), panicked: false }\n-    }\n-\n-    /// Send data in our local buffer into the inner writer, looping as\n-    /// necessary until either it's all been sent or an error occurs.\n-    ///\n-    /// Because all the data in the buffer has been reported to our owner as\n-    /// \"successfully written\" (by returning nonzero success values from\n-    /// `write`), any 0-length writes from `inner` must be reported as i/o\n-    /// errors from this method.\n-    fn flush_buf(&mut self) -> io::Result<()> {\n-        /// Helper struct to ensure the buffer is updated after all the writes\n-        /// are complete. It tracks the number of written bytes and drains them\n-        /// all from the front of the buffer when dropped.\n-        struct BufGuard<'a> {\n-            buffer: &'a mut Vec<u8>,\n-            written: usize,\n-        }\n-\n-        impl<'a> BufGuard<'a> {\n-            fn new(buffer: &'a mut Vec<u8>) -> Self {\n-                Self { buffer, written: 0 }\n-            }\n-\n-            /// The unwritten part of the buffer\n-            fn remaining(&self) -> &[u8] {\n-                &self.buffer[self.written..]\n-            }\n-\n-            /// Flag some bytes as removed from the front of the buffer\n-            fn consume(&mut self, amt: usize) {\n-                self.written += amt;\n-            }\n-\n-            /// true if all of the bytes have been written\n-            fn done(&self) -> bool {\n-                self.written >= self.buffer.len()\n-            }\n-        }\n-\n-        impl Drop for BufGuard<'_> {\n-            fn drop(&mut self) {\n-                if self.written > 0 {\n-                    self.buffer.drain(..self.written);\n-                }\n-            }\n-        }\n-\n-        let mut guard = BufGuard::new(&mut self.buf);\n-        let inner = self.inner.as_mut().unwrap();\n-        while !guard.done() {\n-            self.panicked = true;\n-            let r = inner.write(guard.remaining());\n-            self.panicked = false;\n-\n-            match r {\n-                Ok(0) => {\n-                    return Err(Error::new(\n-                        ErrorKind::WriteZero,\n-                        \"failed to write the buffered data\",\n-                    ));\n-                }\n-                Ok(n) => guard.consume(n),\n-                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n-                Err(e) => return Err(e),\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    /// Buffer some data without flushing it, regardless of the size of the\n-    /// data. Writes as much as possible without exceeding capacity. Returns\n-    /// the number of bytes written.\n-    fn write_to_buf(&mut self, buf: &[u8]) -> usize {\n-        let available = self.buf.capacity() - self.buf.len();\n-        let amt_to_buffer = available.min(buf.len());\n-        self.buf.extend_from_slice(&buf[..amt_to_buffer]);\n-        amt_to_buffer\n-    }\n-\n-    /// Gets a reference to the underlying writer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    ///\n-    /// // we can use reference just like buffer\n-    /// let reference = buffer.get_ref();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_ref(&self) -> &W {\n-        self.inner.as_ref().unwrap()\n-    }\n-\n-    /// Gets a mutable reference to the underlying writer.\n-    ///\n-    /// It is inadvisable to directly write to the underlying writer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    ///\n-    /// // we can use reference just like buffer\n-    /// let reference = buffer.get_mut();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut W {\n-        self.inner.as_mut().unwrap()\n-    }\n-\n-    /// Returns a reference to the internally buffered data.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let buf_writer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    ///\n-    /// // See how many bytes are currently buffered\n-    /// let bytes_buffered = buf_writer.buffer().len();\n-    /// ```\n-    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n-    pub fn buffer(&self) -> &[u8] {\n-        &self.buf\n-    }\n-\n-    /// Returns the number of bytes the internal buffer can hold without flushing.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let buf_writer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    ///\n-    /// // Check the capacity of the inner buffer\n-    /// let capacity = buf_writer.capacity();\n-    /// // Calculate how many bytes can be written without flushing\n-    /// let without_flush = capacity - buf_writer.buffer().len();\n-    /// ```\n-    #[stable(feature = \"buffered_io_capacity\", since = \"1.46.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.buf.capacity()\n-    }\n-\n-    /// Unwraps this `BufWriter<W>`, returning the underlying writer.\n-    ///\n-    /// The buffer is written out before returning the writer.\n-    ///\n-    /// # Errors\n-    ///\n-    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io::BufWriter;\n-    /// use std::net::TcpStream;\n-    ///\n-    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n-    ///\n-    /// // unwrap the TcpStream and flush the buffer\n-    /// let stream = buffer.into_inner().unwrap();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n-        match self.flush_buf() {\n-            Err(e) => Err(IntoInnerError(self, e)),\n-            Ok(()) => Ok(self.inner.take().unwrap()),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> Write for BufWriter<W> {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        if self.buf.len() + buf.len() > self.buf.capacity() {\n-            self.flush_buf()?;\n-        }\n-        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n-        if buf.len() >= self.buf.capacity() {\n-            self.panicked = true;\n-            let r = self.get_mut().write(buf);\n-            self.panicked = false;\n-            r\n-        } else {\n-            self.buf.extend_from_slice(buf);\n-            Ok(buf.len())\n-        }\n-    }\n-\n-    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n-        // Normally, `write_all` just calls `write` in a loop. We can do better\n-        // by calling `self.get_mut().write_all()` directly, which avoids\n-        // round trips through the buffer in the event of a series of partial\n-        // writes in some circumstances.\n-        if self.buf.len() + buf.len() > self.buf.capacity() {\n-            self.flush_buf()?;\n-        }\n-        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n-        if buf.len() >= self.buf.capacity() {\n-            self.panicked = true;\n-            let r = self.get_mut().write_all(buf);\n-            self.panicked = false;\n-            r\n-        } else {\n-            self.buf.extend_from_slice(buf);\n-            Ok(())\n-        }\n-    }\n-\n-    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n-        if self.buf.len() + total_len > self.buf.capacity() {\n-            self.flush_buf()?;\n-        }\n-        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n-        if total_len >= self.buf.capacity() {\n-            self.panicked = true;\n-            let r = self.get_mut().write_vectored(bufs);\n-            self.panicked = false;\n-            r\n-        } else {\n-            bufs.iter().for_each(|b| self.buf.extend_from_slice(b));\n-            Ok(total_len)\n-        }\n-    }\n-\n-    fn is_write_vectored(&self) -> bool {\n-        self.get_ref().is_write_vectored()\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        self.flush_buf().and_then(|()| self.get_mut().flush())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> fmt::Debug for BufWriter<W>\n-where\n-    W: fmt::Debug,\n-{\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt.debug_struct(\"BufWriter\")\n-            .field(\"writer\", &self.inner.as_ref().unwrap())\n-            .field(\"buffer\", &format_args!(\"{}/{}\", self.buf.len(), self.buf.capacity()))\n-            .finish()\n+impl<W> IntoInnerError<W> {\n+    /// Construct a new IntoInnerError\n+    fn new(writer: W, error: Error) -> Self {\n+        Self(writer, error)\n     }\n-}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write + Seek> Seek for BufWriter<W> {\n-    /// Seek to the offset, in bytes, in the underlying writer.\n-    ///\n-    /// Seeking always writes out the internal buffer before seeking.\n-    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n-        self.flush_buf()?;\n-        self.get_mut().seek(pos)\n+    /// Helper to construct a new IntoInnerError; intended to help with\n+    /// adapters that wrap other adapters\n+    fn new_wrapped<W2>(self, f: impl FnOnce(W) -> W2) -> IntoInnerError<W2> {\n+        let Self(writer, error) = self;\n+        IntoInnerError::new(f(writer), error)\n     }\n-}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> Drop for BufWriter<W> {\n-    fn drop(&mut self) {\n-        if self.inner.is_some() && !self.panicked {\n-            // dtors should not panic, so we ignore a failed flush\n-            let _r = self.flush_buf();\n-        }\n-    }\n-}\n-\n-impl<W> IntoInnerError<W> {\n     /// Returns the error which caused the call to [`BufWriter::into_inner()`]\n     /// to fail.\n     ///\n@@ -936,503 +149,3 @@ impl<W> fmt::Display for IntoInnerError<W> {\n         self.error().fmt(f)\n     }\n }\n-\n-/// Private helper struct for implementing the line-buffered writing logic.\n-/// This shim temporarily wraps a BufWriter, and uses its internals to\n-/// implement a line-buffered writer (specifically by using the internal\n-/// methods like write_to_buf and flush_buf). In this way, a more\n-/// efficient abstraction can be created than one that only had access to\n-/// `write` and `flush`, without needlessly duplicating a lot of the\n-/// implementation details of BufWriter. This also allows existing\n-/// `BufWriters` to be temporarily given line-buffering logic; this is what\n-/// enables Stdout to be alternately in line-buffered or block-buffered mode.\n-#[derive(Debug)]\n-pub(super) struct LineWriterShim<'a, W: Write> {\n-    buffer: &'a mut BufWriter<W>,\n-}\n-\n-impl<'a, W: Write> LineWriterShim<'a, W> {\n-    pub fn new(buffer: &'a mut BufWriter<W>) -> Self {\n-        Self { buffer }\n-    }\n-\n-    /// Get a mutable reference to the inner writer (that is, the writer\n-    /// wrapped by the BufWriter). Be careful with this writer, as writes to\n-    /// it will bypass the buffer.\n-    fn inner_mut(&mut self) -> &mut W {\n-        self.buffer.get_mut()\n-    }\n-\n-    /// Get the content currently buffered in self.buffer\n-    fn buffered(&self) -> &[u8] {\n-        self.buffer.buffer()\n-    }\n-\n-    /// Flush the buffer iff the last byte is a newline (indicating that an\n-    /// earlier write only succeeded partially, and we want to retry flushing\n-    /// the buffered line before continuing with a subsequent write)\n-    fn flush_if_completed_line(&mut self) -> io::Result<()> {\n-        match self.buffered().last().copied() {\n-            Some(b'\\n') => self.buffer.flush_buf(),\n-            _ => Ok(()),\n-        }\n-    }\n-}\n-\n-impl<'a, W: Write> Write for LineWriterShim<'a, W> {\n-    /// Write some data into this BufReader with line buffering. This means\n-    /// that, if any newlines are present in the data, the data up to the last\n-    /// newline is sent directly to the underlying writer, and data after it\n-    /// is buffered. Returns the number of bytes written.\n-    ///\n-    /// This function operates on a \"best effort basis\"; in keeping with the\n-    /// convention of `Write::write`, it makes at most one attempt to write\n-    /// new data to the underlying writer. If that write only reports a partial\n-    /// success, the remaining data will be buffered.\n-    ///\n-    /// Because this function attempts to send completed lines to the underlying\n-    /// writer, it will also flush the existing buffer if it ends with a\n-    /// newline, even if the incoming data does not contain any newlines.\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        let newline_idx = match memchr::memrchr(b'\\n', buf) {\n-            // If there are no new newlines (that is, if this write is less than\n-            // one line), just do a regular buffered write (which may flush if\n-            // we exceed the inner buffer's size)\n-            None => {\n-                self.flush_if_completed_line()?;\n-                return self.buffer.write(buf);\n-            }\n-            // Otherwise, arrange for the lines to be written directly to the\n-            // inner writer.\n-            Some(newline_idx) => newline_idx + 1,\n-        };\n-\n-        // Flush existing content to prepare for our write. We have to do this\n-        // before attempting to write `buf` in order to maintain consistency;\n-        // if we add `buf` to the buffer then try to flush it all at once,\n-        // we're obligated to return Ok(), which would mean suppressing any\n-        // errors that occur during flush.\n-        self.buffer.flush_buf()?;\n-\n-        // This is what we're going to try to write directly to the inner\n-        // writer. The rest will be buffered, if nothing goes wrong.\n-        let lines = &buf[..newline_idx];\n-\n-        // Write `lines` directly to the inner writer. In keeping with the\n-        // `write` convention, make at most one attempt to add new (unbuffered)\n-        // data. Because this write doesn't touch the BufWriter state directly,\n-        // and the buffer is known to be empty, we don't need to worry about\n-        // self.buffer.panicked here.\n-        let flushed = self.inner_mut().write(lines)?;\n-\n-        // If buffer returns Ok(0), propagate that to the caller without\n-        // doing additional buffering; otherwise we're just guaranteeing\n-        // an \"ErrorKind::WriteZero\" later.\n-        if flushed == 0 {\n-            return Ok(0);\n-        }\n-\n-        // Now that the write has succeeded, buffer the rest (or as much of\n-        // the rest as possible). If there were any unwritten newlines, we\n-        // only buffer out to the last unwritten newline that fits in the\n-        // buffer; this helps prevent flushing partial lines on subsequent\n-        // calls to LineWriterShim::write.\n-\n-        // Handle the cases in order of most-common to least-common, under\n-        // the presumption that most writes succeed in totality, and that most\n-        // writes are smaller than the buffer.\n-        // - Is this a partial line (ie, no newlines left in the unwritten tail)\n-        // - If not, does the data out to the last unwritten newline fit in\n-        //   the buffer?\n-        // - If not, scan for the last newline that *does* fit in the buffer\n-        let tail = if flushed >= newline_idx {\n-            &buf[flushed..]\n-        } else if newline_idx - flushed <= self.buffer.capacity() {\n-            &buf[flushed..newline_idx]\n-        } else {\n-            let scan_area = &buf[flushed..];\n-            let scan_area = &scan_area[..self.buffer.capacity()];\n-            match memchr::memrchr(b'\\n', scan_area) {\n-                Some(newline_idx) => &scan_area[..newline_idx + 1],\n-                None => scan_area,\n-            }\n-        };\n-\n-        let buffered = self.buffer.write_to_buf(tail);\n-        Ok(flushed + buffered)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        self.buffer.flush()\n-    }\n-\n-    /// Write some vectored data into this BufReader with line buffering. This\n-    /// means that, if any newlines are present in the data, the data up to\n-    /// and including the buffer containing the last newline is sent directly\n-    /// to the inner writer, and the data after it is buffered. Returns the\n-    /// number of bytes written.\n-    ///\n-    /// This function operates on a \"best effort basis\"; in keeping with the\n-    /// convention of `Write::write`, it makes at most one attempt to write\n-    /// new data to the underlying writer.\n-    ///\n-    /// Because this function attempts to send completed lines to the underlying\n-    /// writer, it will also flush the existing buffer if it contains any\n-    /// newlines.\n-    ///\n-    /// Because sorting through an array of `IoSlice` can be a bit convoluted,\n-    /// This method differs from write in the following ways:\n-    ///\n-    /// - It attempts to write the full content of all the buffers up to and\n-    ///   including the one containing the last newline. This means that it\n-    ///   may attempt to write a partial line, that buffer has data past the\n-    ///   newline.\n-    /// - If the write only reports partial success, it does not attempt to\n-    ///   find the precise location of the written bytes and buffer the rest.\n-    ///\n-    /// If the underlying vector doesn't support vectored writing, we instead\n-    /// simply write the first non-empty buffer with `write`. This way, we\n-    /// get the benefits of more granular partial-line handling without losing\n-    /// anything in efficiency\n-    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        // If there's no specialized behavior for write_vectored, just use\n-        // write. This has the benefit of more granular partial-line handling.\n-        if !self.is_write_vectored() {\n-            return match bufs.iter().find(|buf| !buf.is_empty()) {\n-                Some(buf) => self.write(buf),\n-                None => Ok(0),\n-            };\n-        }\n-\n-        // Find the buffer containing the last newline\n-        let last_newline_buf_idx = bufs\n-            .iter()\n-            .enumerate()\n-            .rev()\n-            .find_map(|(i, buf)| memchr::memchr(b'\\n', buf).map(|_| i));\n-\n-        // If there are no new newlines (that is, if this write is less than\n-        // one line), just do a regular buffered write\n-        let last_newline_buf_idx = match last_newline_buf_idx {\n-            // No newlines; just do a normal buffered write\n-            None => {\n-                self.flush_if_completed_line()?;\n-                return self.buffer.write_vectored(bufs);\n-            }\n-            Some(i) => i,\n-        };\n-\n-        // Flush existing content to prepare for our write\n-        self.buffer.flush_buf()?;\n-\n-        // This is what we're going to try to write directly to the inner\n-        // writer. The rest will be buffered, if nothing goes wrong.\n-        let (lines, tail) = bufs.split_at(last_newline_buf_idx + 1);\n-\n-        // Write `lines` directly to the inner writer. In keeping with the\n-        // `write` convention, make at most one attempt to add new (unbuffered)\n-        // data. Because this write doesn't touch the BufWriter state directly,\n-        // and the buffer is known to be empty, we don't need to worry about\n-        // self.panicked here.\n-        let flushed = self.inner_mut().write_vectored(lines)?;\n-\n-        // If inner returns Ok(0), propagate that to the caller without\n-        // doing additional buffering; otherwise we're just guaranteeing\n-        // an \"ErrorKind::WriteZero\" later.\n-        if flushed == 0 {\n-            return Ok(0);\n-        }\n-\n-        // Don't try to reconstruct the exact amount written; just bail\n-        // in the event of a partial write\n-        let lines_len = lines.iter().map(|buf| buf.len()).sum();\n-        if flushed < lines_len {\n-            return Ok(flushed);\n-        }\n-\n-        // Now that the write has succeeded, buffer the rest (or as much of the\n-        // rest as possible)\n-        let buffered: usize = tail\n-            .iter()\n-            .filter(|buf| !buf.is_empty())\n-            .map(|buf| self.buffer.write_to_buf(buf))\n-            .take_while(|&n| n > 0)\n-            .sum();\n-\n-        Ok(flushed + buffered)\n-    }\n-\n-    fn is_write_vectored(&self) -> bool {\n-        self.buffer.is_write_vectored()\n-    }\n-\n-    /// Write some data into this BufReader with line buffering. This means\n-    /// that, if any newlines are present in the data, the data up to the last\n-    /// newline is sent directly to the underlying writer, and data after it\n-    /// is buffered.\n-    ///\n-    /// Because this function attempts to send completed lines to the underlying\n-    /// writer, it will also flush the existing buffer if it contains any\n-    /// newlines, even if the incoming data does not contain any newlines.\n-    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n-        match memchr::memrchr(b'\\n', buf) {\n-            // If there are no new newlines (that is, if this write is less than\n-            // one line), just do a regular buffered write (which may flush if\n-            // we exceed the inner buffer's size)\n-            None => {\n-                self.flush_if_completed_line()?;\n-                self.buffer.write_all(buf)\n-            }\n-            Some(newline_idx) => {\n-                let (lines, tail) = buf.split_at(newline_idx + 1);\n-\n-                if self.buffered().is_empty() {\n-                    self.inner_mut().write_all(lines)?;\n-                } else {\n-                    // If there is any buffered data, we add the incoming lines\n-                    // to that buffer before flushing, which saves us at least\n-                    // one write call. We can't really do this with `write`,\n-                    // since we can't do this *and* not suppress errors *and*\n-                    // report a consistent state to the caller in a return\n-                    // value, but here in write_all it's fine.\n-                    self.buffer.write_all(lines)?;\n-                    self.buffer.flush_buf()?;\n-                }\n-\n-                self.buffer.write_all(tail)\n-            }\n-        }\n-    }\n-}\n-\n-/// Wraps a writer and buffers output to it, flushing whenever a newline\n-/// (`0x0a`, `'\\n'`) is detected.\n-///\n-/// The [`BufWriter`] struct wraps a writer and buffers its output.\n-/// But it only does this batched write when it goes out of scope, or when the\n-/// internal buffer is full. Sometimes, you'd prefer to write each line as it's\n-/// completed, rather than the entire buffer at once. Enter `LineWriter`. It\n-/// does exactly that.\n-///\n-/// Like [`BufWriter`], a `LineWriter`\u2019s buffer will also be flushed when the\n-/// `LineWriter` goes out of scope or when its internal buffer is full.\n-///\n-/// If there's still a partial line in the buffer when the `LineWriter` is\n-/// dropped, it will flush those contents.\n-///\n-/// # Examples\n-///\n-/// We can use `LineWriter` to write one line at a time, significantly\n-/// reducing the number of actual writes to the file.\n-///\n-/// ```no_run\n-/// use std::fs::{self, File};\n-/// use std::io::prelude::*;\n-/// use std::io::LineWriter;\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     let road_not_taken = b\"I shall be telling this with a sigh\n-/// Somewhere ages and ages hence:\n-/// Two roads diverged in a wood, and I -\n-/// I took the one less traveled by,\n-/// And that has made all the difference.\";\n-///\n-///     let file = File::create(\"poem.txt\")?;\n-///     let mut file = LineWriter::new(file);\n-///\n-///     file.write_all(b\"I shall be telling this with a sigh\")?;\n-///\n-///     // No bytes are written until a newline is encountered (or\n-///     // the internal buffer is filled).\n-///     assert_eq!(fs::read_to_string(\"poem.txt\")?, \"\");\n-///     file.write_all(b\"\\n\")?;\n-///     assert_eq!(\n-///         fs::read_to_string(\"poem.txt\")?,\n-///         \"I shall be telling this with a sigh\\n\",\n-///     );\n-///\n-///     // Write the rest of the poem.\n-///     file.write_all(b\"Somewhere ages and ages hence:\n-/// Two roads diverged in a wood, and I -\n-/// I took the one less traveled by,\n-/// And that has made all the difference.\")?;\n-///\n-///     // The last line of the poem doesn't end in a newline, so\n-///     // we have to flush or drop the `LineWriter` to finish\n-///     // writing.\n-///     file.flush()?;\n-///\n-///     // Confirm the whole poem was written.\n-///     assert_eq!(fs::read(\"poem.txt\")?, &road_not_taken[..]);\n-///     Ok(())\n-/// }\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct LineWriter<W: Write> {\n-    inner: BufWriter<W>,\n-}\n-\n-impl<W: Write> LineWriter<W> {\n-    /// Creates a new `LineWriter`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::io::LineWriter;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let file = File::create(\"poem.txt\")?;\n-    ///     let file = LineWriter::new(file);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(inner: W) -> LineWriter<W> {\n-        // Lines typically aren't that long, don't use a giant buffer\n-        LineWriter::with_capacity(1024, inner)\n-    }\n-\n-    /// Creates a new `LineWriter` with a specified capacity for the internal\n-    /// buffer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::io::LineWriter;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let file = File::create(\"poem.txt\")?;\n-    ///     let file = LineWriter::with_capacity(100, file);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(capacity: usize, inner: W) -> LineWriter<W> {\n-        LineWriter { inner: BufWriter::with_capacity(capacity, inner) }\n-    }\n-\n-    /// Gets a reference to the underlying writer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::io::LineWriter;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let file = File::create(\"poem.txt\")?;\n-    ///     let file = LineWriter::new(file);\n-    ///\n-    ///     let reference = file.get_ref();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_ref(&self) -> &W {\n-        self.inner.get_ref()\n-    }\n-\n-    /// Gets a mutable reference to the underlying writer.\n-    ///\n-    /// Caution must be taken when calling methods on the mutable reference\n-    /// returned as extra writes could corrupt the output stream.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::io::LineWriter;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let file = File::create(\"poem.txt\")?;\n-    ///     let mut file = LineWriter::new(file);\n-    ///\n-    ///     // we can use reference just like file\n-    ///     let reference = file.get_mut();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut W {\n-        self.inner.get_mut()\n-    }\n-\n-    /// Unwraps this `LineWriter`, returning the underlying writer.\n-    ///\n-    /// The internal buffer is written out before returning the writer.\n-    ///\n-    /// # Errors\n-    ///\n-    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::io::LineWriter;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let file = File::create(\"poem.txt\")?;\n-    ///\n-    ///     let writer: LineWriter<File> = LineWriter::new(file);\n-    ///\n-    ///     let file: File = writer.into_inner()?;\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n-        self.inner\n-            .into_inner()\n-            .map_err(|IntoInnerError(buf, e)| IntoInnerError(LineWriter { inner: buf }, e))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> Write for LineWriter<W> {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        LineWriterShim::new(&mut self.inner).write(buf)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        self.inner.flush()\n-    }\n-\n-    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        LineWriterShim::new(&mut self.inner).write_vectored(bufs)\n-    }\n-\n-    fn is_write_vectored(&self) -> bool {\n-        self.inner.is_write_vectored()\n-    }\n-\n-    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n-        LineWriterShim::new(&mut self.inner).write_all(buf)\n-    }\n-\n-    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n-        LineWriterShim::new(&mut self.inner).write_all_vectored(bufs)\n-    }\n-\n-    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n-        LineWriterShim::new(&mut self.inner).write_fmt(fmt)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Write> fmt::Debug for LineWriter<W>\n-where\n-    W: fmt::Debug,\n-{\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt.debug_struct(\"LineWriter\")\n-            .field(\"writer\", &self.inner.inner)\n-            .field(\n-                \"buffer\",\n-                &format_args!(\"{}/{}\", self.inner.buf.len(), self.inner.buf.capacity()),\n-            )\n-            .finish()\n-    }\n-}"}, {"sha": "8fe29f08a7bd72b52311d33997a3273fac7ac87f", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "added", "additions": 423, "deletions": 0, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/a02014280586b53997622c501db00398376967a8/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02014280586b53997622c501db00398376967a8/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=a02014280586b53997622c501db00398376967a8", "patch": "@@ -0,0 +1,423 @@\n+use crate::cmp;\n+use crate::fmt;\n+use crate::io::{self, BufRead, Initializer, IoSliceMut, Read, Seek, SeekFrom, DEFAULT_BUF_SIZE};\n+\n+/// The `BufReader<R>` struct adds buffering to any reader.\n+///\n+/// It can be excessively inefficient to work directly with a [`Read`] instance.\n+/// For example, every call to [`read`][`TcpStream::read`] on [`TcpStream`]\n+/// results in a system call. A `BufReader<R>` performs large, infrequent reads on\n+/// the underlying [`Read`] and maintains an in-memory buffer of the results.\n+///\n+/// `BufReader<R>` can improve the speed of programs that make *small* and\n+/// *repeated* read calls to the same file or network socket. It does not\n+/// help when reading very large amounts at once, or reading just one or a few\n+/// times. It also provides no advantage when reading from a source that is\n+/// already in memory, like a [`Vec`]`<u8>`.\n+///\n+/// When the `BufReader<R>` is dropped, the contents of its buffer will be\n+/// discarded. Creating multiple instances of a `BufReader<R>` on the same\n+/// stream can cause data loss. Reading from the underlying reader after\n+/// unwrapping the `BufReader<R>` with [`BufReader::into_inner`] can also cause\n+/// data loss.\n+///\n+/// [`TcpStream::read`]: Read::read\n+/// [`TcpStream`]: crate::net::TcpStream\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::io::prelude::*;\n+/// use std::io::BufReader;\n+/// use std::fs::File;\n+///\n+/// fn main() -> std::io::Result<()> {\n+///     let f = File::open(\"log.txt\")?;\n+///     let mut reader = BufReader::new(f);\n+///\n+///     let mut line = String::new();\n+///     let len = reader.read_line(&mut line)?;\n+///     println!(\"First line is {} bytes long\", len);\n+///     Ok(())\n+/// }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct BufReader<R> {\n+    inner: R,\n+    buf: Box<[u8]>,\n+    pos: usize,\n+    cap: usize,\n+}\n+\n+impl<R: Read> BufReader<R> {\n+    /// Creates a new `BufReader<R>` with a default buffer capacity. The default is currently 8 KB,\n+    /// but may change in the future.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufReader;\n+    /// use std::fs::File;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let f = File::open(\"log.txt\")?;\n+    ///     let reader = BufReader::new(f);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new(inner: R) -> BufReader<R> {\n+        BufReader::with_capacity(DEFAULT_BUF_SIZE, inner)\n+    }\n+\n+    /// Creates a new `BufReader<R>` with the specified buffer capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Creating a buffer with ten bytes of capacity:\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufReader;\n+    /// use std::fs::File;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let f = File::open(\"log.txt\")?;\n+    ///     let reader = BufReader::with_capacity(10, f);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn with_capacity(capacity: usize, inner: R) -> BufReader<R> {\n+        unsafe {\n+            let mut buffer = Vec::with_capacity(capacity);\n+            buffer.set_len(capacity);\n+            inner.initializer().initialize(&mut buffer);\n+            BufReader { inner, buf: buffer.into_boxed_slice(), pos: 0, cap: 0 }\n+        }\n+    }\n+}\n+\n+impl<R> BufReader<R> {\n+    /// Gets a reference to the underlying reader.\n+    ///\n+    /// It is inadvisable to directly read from the underlying reader.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufReader;\n+    /// use std::fs::File;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let f1 = File::open(\"log.txt\")?;\n+    ///     let reader = BufReader::new(f1);\n+    ///\n+    ///     let f2 = reader.get_ref();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_ref(&self) -> &R {\n+        &self.inner\n+    }\n+\n+    /// Gets a mutable reference to the underlying reader.\n+    ///\n+    /// It is inadvisable to directly read from the underlying reader.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufReader;\n+    /// use std::fs::File;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let f1 = File::open(\"log.txt\")?;\n+    ///     let mut reader = BufReader::new(f1);\n+    ///\n+    ///     let f2 = reader.get_mut();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_mut(&mut self) -> &mut R {\n+        &mut self.inner\n+    }\n+\n+    /// Returns a reference to the internally buffered data.\n+    ///\n+    /// Unlike [`fill_buf`], this will not attempt to fill the buffer if it is empty.\n+    ///\n+    /// [`fill_buf`]: BufRead::fill_buf\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::{BufReader, BufRead};\n+    /// use std::fs::File;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let f = File::open(\"log.txt\")?;\n+    ///     let mut reader = BufReader::new(f);\n+    ///     assert!(reader.buffer().is_empty());\n+    ///\n+    ///     if reader.fill_buf()?.len() > 0 {\n+    ///         assert!(!reader.buffer().is_empty());\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n+    pub fn buffer(&self) -> &[u8] {\n+        &self.buf[self.pos..self.cap]\n+    }\n+\n+    /// Returns the number of bytes the internal buffer can hold at once.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::{BufReader, BufRead};\n+    /// use std::fs::File;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let f = File::open(\"log.txt\")?;\n+    ///     let mut reader = BufReader::new(f);\n+    ///\n+    ///     let capacity = reader.capacity();\n+    ///     let buffer = reader.fill_buf()?;\n+    ///     assert!(buffer.len() <= capacity);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"buffered_io_capacity\", since = \"1.46.0\")]\n+    pub fn capacity(&self) -> usize {\n+        self.buf.len()\n+    }\n+\n+    /// Unwraps this `BufReader<R>`, returning the underlying reader.\n+    ///\n+    /// Note that any leftover data in the internal buffer is lost. Therefore,\n+    /// a following read from the underlying reader may lead to data loss.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufReader;\n+    /// use std::fs::File;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let f1 = File::open(\"log.txt\")?;\n+    ///     let reader = BufReader::new(f1);\n+    ///\n+    ///     let f2 = reader.into_inner();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_inner(self) -> R {\n+        self.inner\n+    }\n+\n+    /// Invalidates all data in the internal buffer.\n+    #[inline]\n+    fn discard_buffer(&mut self) {\n+        self.pos = 0;\n+        self.cap = 0;\n+    }\n+}\n+\n+impl<R: Seek> BufReader<R> {\n+    /// Seeks relative to the current position. If the new position lies within the buffer,\n+    /// the buffer will not be flushed, allowing for more efficient seeks.\n+    /// This method does not return the location of the underlying reader, so the caller\n+    /// must track this information themselves if it is required.\n+    #[unstable(feature = \"bufreader_seek_relative\", issue = \"31100\")]\n+    pub fn seek_relative(&mut self, offset: i64) -> io::Result<()> {\n+        let pos = self.pos as u64;\n+        if offset < 0 {\n+            if let Some(new_pos) = pos.checked_sub((-offset) as u64) {\n+                self.pos = new_pos as usize;\n+                return Ok(());\n+            }\n+        } else {\n+            if let Some(new_pos) = pos.checked_add(offset as u64) {\n+                if new_pos <= self.cap as u64 {\n+                    self.pos = new_pos as usize;\n+                    return Ok(());\n+                }\n+            }\n+        }\n+        self.seek(SeekFrom::Current(offset)).map(drop)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<R: Read> Read for BufReader<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        // If we don't have any buffered data and we're doing a massive read\n+        // (larger than our internal buffer), bypass our internal buffer\n+        // entirely.\n+        if self.pos == self.cap && buf.len() >= self.buf.len() {\n+            self.discard_buffer();\n+            return self.inner.read(buf);\n+        }\n+        let nread = {\n+            let mut rem = self.fill_buf()?;\n+            rem.read(buf)?\n+        };\n+        self.consume(nread);\n+        Ok(nread)\n+    }\n+\n+    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n+        if self.pos == self.cap && total_len >= self.buf.len() {\n+            self.discard_buffer();\n+            return self.inner.read_vectored(bufs);\n+        }\n+        let nread = {\n+            let mut rem = self.fill_buf()?;\n+            rem.read_vectored(bufs)?\n+        };\n+        self.consume(nread);\n+        Ok(nread)\n+    }\n+\n+    fn is_read_vectored(&self) -> bool {\n+        self.inner.is_read_vectored()\n+    }\n+\n+    // we can't skip unconditionally because of the large buffer case in read.\n+    unsafe fn initializer(&self) -> Initializer {\n+        self.inner.initializer()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<R: Read> BufRead for BufReader<R> {\n+    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n+        // If we've reached the end of our internal buffer then we need to fetch\n+        // some more data from the underlying reader.\n+        // Branch using `>=` instead of the more correct `==`\n+        // to tell the compiler that the pos..cap slice is always valid.\n+        if self.pos >= self.cap {\n+            debug_assert!(self.pos == self.cap);\n+            self.cap = self.inner.read(&mut self.buf)?;\n+            self.pos = 0;\n+        }\n+        Ok(&self.buf[self.pos..self.cap])\n+    }\n+\n+    fn consume(&mut self, amt: usize) {\n+        self.pos = cmp::min(self.pos + amt, self.cap);\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<R> fmt::Debug for BufReader<R>\n+where\n+    R: fmt::Debug,\n+{\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"BufReader\")\n+            .field(\"reader\", &self.inner)\n+            .field(\"buffer\", &format_args!(\"{}/{}\", self.cap - self.pos, self.buf.len()))\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<R: Seek> Seek for BufReader<R> {\n+    /// Seek to an offset, in bytes, in the underlying reader.\n+    ///\n+    /// The position used for seeking with [`SeekFrom::Current`]`(_)` is the\n+    /// position the underlying reader would be at if the `BufReader<R>` had no\n+    /// internal buffer.\n+    ///\n+    /// Seeking always discards the internal buffer, even if the seek position\n+    /// would otherwise fall within it. This guarantees that calling\n+    /// [`BufReader::into_inner()`] immediately after a seek yields the underlying reader\n+    /// at the same position.\n+    ///\n+    /// To seek without discarding the internal buffer, use [`BufReader::seek_relative`].\n+    ///\n+    /// See [`std::io::Seek`] for more details.\n+    ///\n+    /// Note: In the edge case where you're seeking with [`SeekFrom::Current`]`(n)`\n+    /// where `n` minus the internal buffer length overflows an `i64`, two\n+    /// seeks will be performed instead of one. If the second seek returns\n+    /// [`Err`], the underlying reader will be left at the same position it would\n+    /// have if you called `seek` with [`SeekFrom::Current`]`(0)`.\n+    ///\n+    /// [`std::io::Seek`]: Seek\n+    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n+        let result: u64;\n+        if let SeekFrom::Current(n) = pos {\n+            let remainder = (self.cap - self.pos) as i64;\n+            // it should be safe to assume that remainder fits within an i64 as the alternative\n+            // means we managed to allocate 8 exbibytes and that's absurd.\n+            // But it's not out of the realm of possibility for some weird underlying reader to\n+            // support seeking by i64::MIN so we need to handle underflow when subtracting\n+            // remainder.\n+            if let Some(offset) = n.checked_sub(remainder) {\n+                result = self.inner.seek(SeekFrom::Current(offset))?;\n+            } else {\n+                // seek backwards by our remainder, and then by the offset\n+                self.inner.seek(SeekFrom::Current(-remainder))?;\n+                self.discard_buffer();\n+                result = self.inner.seek(SeekFrom::Current(n))?;\n+            }\n+        } else {\n+            // Seeking with Start/End doesn't care about our buffer length.\n+            result = self.inner.seek(pos)?;\n+        }\n+        self.discard_buffer();\n+        Ok(result)\n+    }\n+\n+    /// Returns the current seek position from the start of the stream.\n+    ///\n+    /// The value returned is equivalent to `self.seek(SeekFrom::Current(0))`\n+    /// but does not flush the internal buffer. Due to this optimization the\n+    /// function does not guarantee that calling `.into_inner()` immediately\n+    /// afterwards will yield the underlying reader at the same position. Use\n+    /// [`BufReader::seek`] instead if you require that guarantee.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the position of the inner reader is smaller\n+    /// than the amount of buffered data. That can happen if the inner reader\n+    /// has an incorrect implementation of [`Seek::stream_position`], or if the\n+    /// position has gone out of sync due to calling [`Seek::seek`] directly on\n+    /// the underlying reader.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// #![feature(seek_convenience)]\n+    /// use std::{\n+    ///     io::{self, BufRead, BufReader, Seek},\n+    ///     fs::File,\n+    /// };\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let mut f = BufReader::new(File::open(\"foo.txt\")?);\n+    ///\n+    ///     let before = f.stream_position()?;\n+    ///     f.read_line(&mut String::new())?;\n+    ///     let after = f.stream_position()?;\n+    ///\n+    ///     println!(\"The first line was {} bytes long\", after - before);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    fn stream_position(&mut self) -> io::Result<u64> {\n+        let remainder = (self.cap - self.pos) as u64;\n+        self.inner.stream_position().map(|pos| {\n+            pos.checked_sub(remainder).expect(\n+                \"overflow when subtracting remaining buffer size from inner stream position\",\n+            )\n+        })\n+    }\n+}"}, {"sha": "8ce795a05ed3643466871daf95653b51645c055c", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/a02014280586b53997622c501db00398376967a8/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02014280586b53997622c501db00398376967a8/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=a02014280586b53997622c501db00398376967a8", "patch": "@@ -0,0 +1,387 @@\n+use crate::fmt;\n+use crate::io::{\n+    self, Error, ErrorKind, IntoInnerError, IoSlice, Seek, SeekFrom, Write, DEFAULT_BUF_SIZE,\n+};\n+\n+/// Wraps a writer and buffers its output.\n+///\n+/// It can be excessively inefficient to work directly with something that\n+/// implements [`Write`]. For example, every call to\n+/// [`write`][`TcpStream::write`] on [`TcpStream`] results in a system call. A\n+/// `BufWriter<W>` keeps an in-memory buffer of data and writes it to an underlying\n+/// writer in large, infrequent batches.\n+///\n+/// `BufWriter<W>` can improve the speed of programs that make *small* and\n+/// *repeated* write calls to the same file or network socket. It does not\n+/// help when writing very large amounts at once, or writing just one or a few\n+/// times. It also provides no advantage when writing to a destination that is\n+/// in memory, like a [`Vec`]<u8>`.\n+///\n+/// It is critical to call [`flush`] before `BufWriter<W>` is dropped. Though\n+/// dropping will attempt to flush the contents of the buffer, any errors\n+/// that happen in the process of dropping will be ignored. Calling [`flush`]\n+/// ensures that the buffer is empty and thus dropping will not even attempt\n+/// file operations.\n+///\n+/// # Examples\n+///\n+/// Let's write the numbers one through ten to a [`TcpStream`]:\n+///\n+/// ```no_run\n+/// use std::io::prelude::*;\n+/// use std::net::TcpStream;\n+///\n+/// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n+///\n+/// for i in 0..10 {\n+///     stream.write(&[i+1]).unwrap();\n+/// }\n+/// ```\n+///\n+/// Because we're not buffering, we write each one in turn, incurring the\n+/// overhead of a system call per byte written. We can fix this with a\n+/// `BufWriter<W>`:\n+///\n+/// ```no_run\n+/// use std::io::prelude::*;\n+/// use std::io::BufWriter;\n+/// use std::net::TcpStream;\n+///\n+/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+///\n+/// for i in 0..10 {\n+///     stream.write(&[i+1]).unwrap();\n+/// }\n+/// stream.flush().unwrap();\n+/// ```\n+///\n+/// By wrapping the stream with a `BufWriter<W>`, these ten writes are all grouped\n+/// together by the buffer and will all be written out in one system call when\n+/// the `stream` is flushed.\n+///\n+/// [`TcpStream::write`]: Write::write\n+/// [`TcpStream`]: crate::net::TcpStream\n+/// [`flush`]: Write::flush\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct BufWriter<W: Write> {\n+    inner: Option<W>,\n+    buf: Vec<u8>,\n+    // #30888: If the inner writer panics in a call to write, we don't want to\n+    // write the buffered data a second time in BufWriter's destructor. This\n+    // flag tells the Drop impl if it should skip the flush.\n+    panicked: bool,\n+}\n+\n+impl<W: Write> BufWriter<W> {\n+    /// Creates a new `BufWriter<W>` with a default buffer capacity. The default is currently 8 KB,\n+    /// but may change in the future.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new(inner: W) -> BufWriter<W> {\n+        BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n+    }\n+\n+    /// Creates a new `BufWriter<W>` with the specified buffer capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Creating a buffer with a buffer of a hundred bytes.\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n+    /// let mut buffer = BufWriter::with_capacity(100, stream);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn with_capacity(capacity: usize, inner: W) -> BufWriter<W> {\n+        BufWriter { inner: Some(inner), buf: Vec::with_capacity(capacity), panicked: false }\n+    }\n+\n+    /// Send data in our local buffer into the inner writer, looping as\n+    /// necessary until either it's all been sent or an error occurs.\n+    ///\n+    /// Because all the data in the buffer has been reported to our owner as\n+    /// \"successfully written\" (by returning nonzero success values from\n+    /// `write`), any 0-length writes from `inner` must be reported as i/o\n+    /// errors from this method.\n+    pub(super) fn flush_buf(&mut self) -> io::Result<()> {\n+        /// Helper struct to ensure the buffer is updated after all the writes\n+        /// are complete. It tracks the number of written bytes and drains them\n+        /// all from the front of the buffer when dropped.\n+        struct BufGuard<'a> {\n+            buffer: &'a mut Vec<u8>,\n+            written: usize,\n+        }\n+\n+        impl<'a> BufGuard<'a> {\n+            fn new(buffer: &'a mut Vec<u8>) -> Self {\n+                Self { buffer, written: 0 }\n+            }\n+\n+            /// The unwritten part of the buffer\n+            fn remaining(&self) -> &[u8] {\n+                &self.buffer[self.written..]\n+            }\n+\n+            /// Flag some bytes as removed from the front of the buffer\n+            fn consume(&mut self, amt: usize) {\n+                self.written += amt;\n+            }\n+\n+            /// true if all of the bytes have been written\n+            fn done(&self) -> bool {\n+                self.written >= self.buffer.len()\n+            }\n+        }\n+\n+        impl Drop for BufGuard<'_> {\n+            fn drop(&mut self) {\n+                if self.written > 0 {\n+                    self.buffer.drain(..self.written);\n+                }\n+            }\n+        }\n+\n+        let mut guard = BufGuard::new(&mut self.buf);\n+        let inner = self.inner.as_mut().unwrap();\n+        while !guard.done() {\n+            self.panicked = true;\n+            let r = inner.write(guard.remaining());\n+            self.panicked = false;\n+\n+            match r {\n+                Ok(0) => {\n+                    return Err(Error::new(\n+                        ErrorKind::WriteZero,\n+                        \"failed to write the buffered data\",\n+                    ));\n+                }\n+                Ok(n) => guard.consume(n),\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Buffer some data without flushing it, regardless of the size of the\n+    /// data. Writes as much as possible without exceeding capacity. Returns\n+    /// the number of bytes written.\n+    pub(super) fn write_to_buf(&mut self, buf: &[u8]) -> usize {\n+        let available = self.buf.capacity() - self.buf.len();\n+        let amt_to_buffer = available.min(buf.len());\n+        self.buf.extend_from_slice(&buf[..amt_to_buffer]);\n+        amt_to_buffer\n+    }\n+\n+    /// Gets a reference to the underlying writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // we can use reference just like buffer\n+    /// let reference = buffer.get_ref();\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_ref(&self) -> &W {\n+        self.inner.as_ref().unwrap()\n+    }\n+\n+    /// Gets a mutable reference to the underlying writer.\n+    ///\n+    /// It is inadvisable to directly write to the underlying writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // we can use reference just like buffer\n+    /// let reference = buffer.get_mut();\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_mut(&mut self) -> &mut W {\n+        self.inner.as_mut().unwrap()\n+    }\n+\n+    /// Returns a reference to the internally buffered data.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let buf_writer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // See how many bytes are currently buffered\n+    /// let bytes_buffered = buf_writer.buffer().len();\n+    /// ```\n+    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n+    pub fn buffer(&self) -> &[u8] {\n+        &self.buf\n+    }\n+\n+    /// Returns the number of bytes the internal buffer can hold without flushing.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let buf_writer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // Check the capacity of the inner buffer\n+    /// let capacity = buf_writer.capacity();\n+    /// // Calculate how many bytes can be written without flushing\n+    /// let without_flush = capacity - buf_writer.buffer().len();\n+    /// ```\n+    #[stable(feature = \"buffered_io_capacity\", since = \"1.46.0\")]\n+    pub fn capacity(&self) -> usize {\n+        self.buf.capacity()\n+    }\n+\n+    /// Unwraps this `BufWriter<W>`, returning the underlying writer.\n+    ///\n+    /// The buffer is written out before returning the writer.\n+    ///\n+    /// # Errors\n+    ///\n+    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io::BufWriter;\n+    /// use std::net::TcpStream;\n+    ///\n+    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n+    ///\n+    /// // unwrap the TcpStream and flush the buffer\n+    /// let stream = buffer.into_inner().unwrap();\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n+        match self.flush_buf() {\n+            Err(e) => Err(IntoInnerError::new(self, e)),\n+            Ok(()) => Ok(self.inner.take().unwrap()),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W: Write> Write for BufWriter<W> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        if self.buf.len() + buf.len() > self.buf.capacity() {\n+            self.flush_buf()?;\n+        }\n+        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n+        if buf.len() >= self.buf.capacity() {\n+            self.panicked = true;\n+            let r = self.get_mut().write(buf);\n+            self.panicked = false;\n+            r\n+        } else {\n+            self.buf.extend_from_slice(buf);\n+            Ok(buf.len())\n+        }\n+    }\n+\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        // Normally, `write_all` just calls `write` in a loop. We can do better\n+        // by calling `self.get_mut().write_all()` directly, which avoids\n+        // round trips through the buffer in the event of a series of partial\n+        // writes in some circumstances.\n+        if self.buf.len() + buf.len() > self.buf.capacity() {\n+            self.flush_buf()?;\n+        }\n+        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n+        if buf.len() >= self.buf.capacity() {\n+            self.panicked = true;\n+            let r = self.get_mut().write_all(buf);\n+            self.panicked = false;\n+            r\n+        } else {\n+            self.buf.extend_from_slice(buf);\n+            Ok(())\n+        }\n+    }\n+\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n+        if self.buf.len() + total_len > self.buf.capacity() {\n+            self.flush_buf()?;\n+        }\n+        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n+        if total_len >= self.buf.capacity() {\n+            self.panicked = true;\n+            let r = self.get_mut().write_vectored(bufs);\n+            self.panicked = false;\n+            r\n+        } else {\n+            bufs.iter().for_each(|b| self.buf.extend_from_slice(b));\n+            Ok(total_len)\n+        }\n+    }\n+\n+    fn is_write_vectored(&self) -> bool {\n+        self.get_ref().is_write_vectored()\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.flush_buf().and_then(|()| self.get_mut().flush())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W: Write> fmt::Debug for BufWriter<W>\n+where\n+    W: fmt::Debug,\n+{\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"BufWriter\")\n+            .field(\"writer\", &self.inner.as_ref().unwrap())\n+            .field(\"buffer\", &format_args!(\"{}/{}\", self.buf.len(), self.buf.capacity()))\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W: Write + Seek> Seek for BufWriter<W> {\n+    /// Seek to the offset, in bytes, in the underlying writer.\n+    ///\n+    /// Seeking always writes out the internal buffer before seeking.\n+    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n+        self.flush_buf()?;\n+        self.get_mut().seek(pos)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W: Write> Drop for BufWriter<W> {\n+    fn drop(&mut self) {\n+        if self.inner.is_some() && !self.panicked {\n+            // dtors should not panic, so we ignore a failed flush\n+            let _r = self.flush_buf();\n+        }\n+    }\n+}"}, {"sha": "502c6e3c6c0b95295ad8be675ffb948e5e552fbf", "filename": "library/std/src/io/buffered/linewriter.rs", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/a02014280586b53997622c501db00398376967a8/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02014280586b53997622c501db00398376967a8/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewriter.rs?ref=a02014280586b53997622c501db00398376967a8", "patch": "@@ -0,0 +1,232 @@\n+use crate::fmt;\n+use crate::io::{self, buffered::LineWriterShim, BufWriter, IntoInnerError, IoSlice, Write};\n+\n+/// Wraps a writer and buffers output to it, flushing whenever a newline\n+/// (`0x0a`, `'\\n'`) is detected.\n+///\n+/// The [`BufWriter`] struct wraps a writer and buffers its output.\n+/// But it only does this batched write when it goes out of scope, or when the\n+/// internal buffer is full. Sometimes, you'd prefer to write each line as it's\n+/// completed, rather than the entire buffer at once. Enter `LineWriter`. It\n+/// does exactly that.\n+///\n+/// Like [`BufWriter`], a `LineWriter`\u2019s buffer will also be flushed when the\n+/// `LineWriter` goes out of scope or when its internal buffer is full.\n+///\n+/// If there's still a partial line in the buffer when the `LineWriter` is\n+/// dropped, it will flush those contents.\n+///\n+/// # Examples\n+///\n+/// We can use `LineWriter` to write one line at a time, significantly\n+/// reducing the number of actual writes to the file.\n+///\n+/// ```no_run\n+/// use std::fs::{self, File};\n+/// use std::io::prelude::*;\n+/// use std::io::LineWriter;\n+///\n+/// fn main() -> std::io::Result<()> {\n+///     let road_not_taken = b\"I shall be telling this with a sigh\n+/// Somewhere ages and ages hence:\n+/// Two roads diverged in a wood, and I -\n+/// I took the one less traveled by,\n+/// And that has made all the difference.\";\n+///\n+///     let file = File::create(\"poem.txt\")?;\n+///     let mut file = LineWriter::new(file);\n+///\n+///     file.write_all(b\"I shall be telling this with a sigh\")?;\n+///\n+///     // No bytes are written until a newline is encountered (or\n+///     // the internal buffer is filled).\n+///     assert_eq!(fs::read_to_string(\"poem.txt\")?, \"\");\n+///     file.write_all(b\"\\n\")?;\n+///     assert_eq!(\n+///         fs::read_to_string(\"poem.txt\")?,\n+///         \"I shall be telling this with a sigh\\n\",\n+///     );\n+///\n+///     // Write the rest of the poem.\n+///     file.write_all(b\"Somewhere ages and ages hence:\n+/// Two roads diverged in a wood, and I -\n+/// I took the one less traveled by,\n+/// And that has made all the difference.\")?;\n+///\n+///     // The last line of the poem doesn't end in a newline, so\n+///     // we have to flush or drop the `LineWriter` to finish\n+///     // writing.\n+///     file.flush()?;\n+///\n+///     // Confirm the whole poem was written.\n+///     assert_eq!(fs::read(\"poem.txt\")?, &road_not_taken[..]);\n+///     Ok(())\n+/// }\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct LineWriter<W: Write> {\n+    inner: BufWriter<W>,\n+}\n+\n+impl<W: Write> LineWriter<W> {\n+    /// Creates a new `LineWriter`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let file = File::create(\"poem.txt\")?;\n+    ///     let file = LineWriter::new(file);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new(inner: W) -> LineWriter<W> {\n+        // Lines typically aren't that long, don't use a giant buffer\n+        LineWriter::with_capacity(1024, inner)\n+    }\n+\n+    /// Creates a new `LineWriter` with a specified capacity for the internal\n+    /// buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let file = File::create(\"poem.txt\")?;\n+    ///     let file = LineWriter::with_capacity(100, file);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn with_capacity(capacity: usize, inner: W) -> LineWriter<W> {\n+        LineWriter { inner: BufWriter::with_capacity(capacity, inner) }\n+    }\n+\n+    /// Gets a reference to the underlying writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let file = File::create(\"poem.txt\")?;\n+    ///     let file = LineWriter::new(file);\n+    ///\n+    ///     let reference = file.get_ref();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_ref(&self) -> &W {\n+        self.inner.get_ref()\n+    }\n+\n+    /// Gets a mutable reference to the underlying writer.\n+    ///\n+    /// Caution must be taken when calling methods on the mutable reference\n+    /// returned as extra writes could corrupt the output stream.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let file = File::create(\"poem.txt\")?;\n+    ///     let mut file = LineWriter::new(file);\n+    ///\n+    ///     // we can use reference just like file\n+    ///     let reference = file.get_mut();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_mut(&mut self) -> &mut W {\n+        self.inner.get_mut()\n+    }\n+\n+    /// Unwraps this `LineWriter`, returning the underlying writer.\n+    ///\n+    /// The internal buffer is written out before returning the writer.\n+    ///\n+    /// # Errors\n+    ///\n+    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::io::LineWriter;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let file = File::create(\"poem.txt\")?;\n+    ///\n+    ///     let writer: LineWriter<File> = LineWriter::new(file);\n+    ///\n+    ///     let file: File = writer.into_inner()?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n+        self.inner.into_inner().map_err(|err| err.new_wrapped(|inner| LineWriter { inner }))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W: Write> Write for LineWriter<W> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        LineWriterShim::new(&mut self.inner).write(buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.inner.flush()\n+    }\n+\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        LineWriterShim::new(&mut self.inner).write_vectored(bufs)\n+    }\n+\n+    fn is_write_vectored(&self) -> bool {\n+        self.inner.is_write_vectored()\n+    }\n+\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        LineWriterShim::new(&mut self.inner).write_all(buf)\n+    }\n+\n+    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n+        LineWriterShim::new(&mut self.inner).write_all_vectored(bufs)\n+    }\n+\n+    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n+        LineWriterShim::new(&mut self.inner).write_fmt(fmt)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W: Write> fmt::Debug for LineWriter<W>\n+where\n+    W: fmt::Debug,\n+{\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_struct(\"LineWriter\")\n+            .field(\"writer\", &self.get_ref())\n+            .field(\n+                \"buffer\",\n+                &format_args!(\"{}/{}\", self.inner.buffer().len(), self.inner.capacity()),\n+            )\n+            .finish()\n+    }\n+}"}, {"sha": "a80d08db8692e32591a07342faf5442269d8cada", "filename": "library/std/src/io/buffered/linewritershim.rs", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/a02014280586b53997622c501db00398376967a8/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewritershim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a02014280586b53997622c501db00398376967a8/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewritershim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Flinewritershim.rs?ref=a02014280586b53997622c501db00398376967a8", "patch": "@@ -0,0 +1,270 @@\n+use crate::io::{self, BufWriter, IoSlice, Write};\n+use crate::memchr;\n+\n+/// Private helper struct for implementing the line-buffered writing logic.\n+/// This shim temporarily wraps a BufWriter, and uses its internals to\n+/// implement a line-buffered writer (specifically by using the internal\n+/// methods like write_to_buf and flush_buf). In this way, a more\n+/// efficient abstraction can be created than one that only had access to\n+/// `write` and `flush`, without needlessly duplicating a lot of the\n+/// implementation details of BufWriter. This also allows existing\n+/// `BufWriters` to be temporarily given line-buffering logic; this is what\n+/// enables Stdout to be alternately in line-buffered or block-buffered mode.\n+#[derive(Debug)]\n+pub struct LineWriterShim<'a, W: Write> {\n+    buffer: &'a mut BufWriter<W>,\n+}\n+\n+impl<'a, W: Write> LineWriterShim<'a, W> {\n+    pub fn new(buffer: &'a mut BufWriter<W>) -> Self {\n+        Self { buffer }\n+    }\n+\n+    /// Get a mutable reference to the inner writer (that is, the writer\n+    /// wrapped by the BufWriter). Be careful with this writer, as writes to\n+    /// it will bypass the buffer.\n+    fn inner_mut(&mut self) -> &mut W {\n+        self.buffer.get_mut()\n+    }\n+\n+    /// Get the content currently buffered in self.buffer\n+    fn buffered(&self) -> &[u8] {\n+        self.buffer.buffer()\n+    }\n+\n+    /// Flush the buffer iff the last byte is a newline (indicating that an\n+    /// earlier write only succeeded partially, and we want to retry flushing\n+    /// the buffered line before continuing with a subsequent write)\n+    fn flush_if_completed_line(&mut self) -> io::Result<()> {\n+        match self.buffered().last().copied() {\n+            Some(b'\\n') => self.buffer.flush_buf(),\n+            _ => Ok(()),\n+        }\n+    }\n+}\n+\n+impl<'a, W: Write> Write for LineWriterShim<'a, W> {\n+    /// Write some data into this BufReader with line buffering. This means\n+    /// that, if any newlines are present in the data, the data up to the last\n+    /// newline is sent directly to the underlying writer, and data after it\n+    /// is buffered. Returns the number of bytes written.\n+    ///\n+    /// This function operates on a \"best effort basis\"; in keeping with the\n+    /// convention of `Write::write`, it makes at most one attempt to write\n+    /// new data to the underlying writer. If that write only reports a partial\n+    /// success, the remaining data will be buffered.\n+    ///\n+    /// Because this function attempts to send completed lines to the underlying\n+    /// writer, it will also flush the existing buffer if it ends with a\n+    /// newline, even if the incoming data does not contain any newlines.\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        let newline_idx = match memchr::memrchr(b'\\n', buf) {\n+            // If there are no new newlines (that is, if this write is less than\n+            // one line), just do a regular buffered write (which may flush if\n+            // we exceed the inner buffer's size)\n+            None => {\n+                self.flush_if_completed_line()?;\n+                return self.buffer.write(buf);\n+            }\n+            // Otherwise, arrange for the lines to be written directly to the\n+            // inner writer.\n+            Some(newline_idx) => newline_idx + 1,\n+        };\n+\n+        // Flush existing content to prepare for our write. We have to do this\n+        // before attempting to write `buf` in order to maintain consistency;\n+        // if we add `buf` to the buffer then try to flush it all at once,\n+        // we're obligated to return Ok(), which would mean suppressing any\n+        // errors that occur during flush.\n+        self.buffer.flush_buf()?;\n+\n+        // This is what we're going to try to write directly to the inner\n+        // writer. The rest will be buffered, if nothing goes wrong.\n+        let lines = &buf[..newline_idx];\n+\n+        // Write `lines` directly to the inner writer. In keeping with the\n+        // `write` convention, make at most one attempt to add new (unbuffered)\n+        // data. Because this write doesn't touch the BufWriter state directly,\n+        // and the buffer is known to be empty, we don't need to worry about\n+        // self.buffer.panicked here.\n+        let flushed = self.inner_mut().write(lines)?;\n+\n+        // If buffer returns Ok(0), propagate that to the caller without\n+        // doing additional buffering; otherwise we're just guaranteeing\n+        // an \"ErrorKind::WriteZero\" later.\n+        if flushed == 0 {\n+            return Ok(0);\n+        }\n+\n+        // Now that the write has succeeded, buffer the rest (or as much of\n+        // the rest as possible). If there were any unwritten newlines, we\n+        // only buffer out to the last unwritten newline that fits in the\n+        // buffer; this helps prevent flushing partial lines on subsequent\n+        // calls to LineWriterShim::write.\n+\n+        // Handle the cases in order of most-common to least-common, under\n+        // the presumption that most writes succeed in totality, and that most\n+        // writes are smaller than the buffer.\n+        // - Is this a partial line (ie, no newlines left in the unwritten tail)\n+        // - If not, does the data out to the last unwritten newline fit in\n+        //   the buffer?\n+        // - If not, scan for the last newline that *does* fit in the buffer\n+        let tail = if flushed >= newline_idx {\n+            &buf[flushed..]\n+        } else if newline_idx - flushed <= self.buffer.capacity() {\n+            &buf[flushed..newline_idx]\n+        } else {\n+            let scan_area = &buf[flushed..];\n+            let scan_area = &scan_area[..self.buffer.capacity()];\n+            match memchr::memrchr(b'\\n', scan_area) {\n+                Some(newline_idx) => &scan_area[..newline_idx + 1],\n+                None => scan_area,\n+            }\n+        };\n+\n+        let buffered = self.buffer.write_to_buf(tail);\n+        Ok(flushed + buffered)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.buffer.flush()\n+    }\n+\n+    /// Write some vectored data into this BufReader with line buffering. This\n+    /// means that, if any newlines are present in the data, the data up to\n+    /// and including the buffer containing the last newline is sent directly\n+    /// to the inner writer, and the data after it is buffered. Returns the\n+    /// number of bytes written.\n+    ///\n+    /// This function operates on a \"best effort basis\"; in keeping with the\n+    /// convention of `Write::write`, it makes at most one attempt to write\n+    /// new data to the underlying writer.\n+    ///\n+    /// Because this function attempts to send completed lines to the underlying\n+    /// writer, it will also flush the existing buffer if it contains any\n+    /// newlines.\n+    ///\n+    /// Because sorting through an array of `IoSlice` can be a bit convoluted,\n+    /// This method differs from write in the following ways:\n+    ///\n+    /// - It attempts to write the full content of all the buffers up to and\n+    ///   including the one containing the last newline. This means that it\n+    ///   may attempt to write a partial line, that buffer has data past the\n+    ///   newline.\n+    /// - If the write only reports partial success, it does not attempt to\n+    ///   find the precise location of the written bytes and buffer the rest.\n+    ///\n+    /// If the underlying vector doesn't support vectored writing, we instead\n+    /// simply write the first non-empty buffer with `write`. This way, we\n+    /// get the benefits of more granular partial-line handling without losing\n+    /// anything in efficiency\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        // If there's no specialized behavior for write_vectored, just use\n+        // write. This has the benefit of more granular partial-line handling.\n+        if !self.is_write_vectored() {\n+            return match bufs.iter().find(|buf| !buf.is_empty()) {\n+                Some(buf) => self.write(buf),\n+                None => Ok(0),\n+            };\n+        }\n+\n+        // Find the buffer containing the last newline\n+        let last_newline_buf_idx = bufs\n+            .iter()\n+            .enumerate()\n+            .rev()\n+            .find_map(|(i, buf)| memchr::memchr(b'\\n', buf).map(|_| i));\n+\n+        // If there are no new newlines (that is, if this write is less than\n+        // one line), just do a regular buffered write\n+        let last_newline_buf_idx = match last_newline_buf_idx {\n+            // No newlines; just do a normal buffered write\n+            None => {\n+                self.flush_if_completed_line()?;\n+                return self.buffer.write_vectored(bufs);\n+            }\n+            Some(i) => i,\n+        };\n+\n+        // Flush existing content to prepare for our write\n+        self.buffer.flush_buf()?;\n+\n+        // This is what we're going to try to write directly to the inner\n+        // writer. The rest will be buffered, if nothing goes wrong.\n+        let (lines, tail) = bufs.split_at(last_newline_buf_idx + 1);\n+\n+        // Write `lines` directly to the inner writer. In keeping with the\n+        // `write` convention, make at most one attempt to add new (unbuffered)\n+        // data. Because this write doesn't touch the BufWriter state directly,\n+        // and the buffer is known to be empty, we don't need to worry about\n+        // self.panicked here.\n+        let flushed = self.inner_mut().write_vectored(lines)?;\n+\n+        // If inner returns Ok(0), propagate that to the caller without\n+        // doing additional buffering; otherwise we're just guaranteeing\n+        // an \"ErrorKind::WriteZero\" later.\n+        if flushed == 0 {\n+            return Ok(0);\n+        }\n+\n+        // Don't try to reconstruct the exact amount written; just bail\n+        // in the event of a partial write\n+        let lines_len = lines.iter().map(|buf| buf.len()).sum();\n+        if flushed < lines_len {\n+            return Ok(flushed);\n+        }\n+\n+        // Now that the write has succeeded, buffer the rest (or as much of the\n+        // rest as possible)\n+        let buffered: usize = tail\n+            .iter()\n+            .filter(|buf| !buf.is_empty())\n+            .map(|buf| self.buffer.write_to_buf(buf))\n+            .take_while(|&n| n > 0)\n+            .sum();\n+\n+        Ok(flushed + buffered)\n+    }\n+\n+    fn is_write_vectored(&self) -> bool {\n+        self.buffer.is_write_vectored()\n+    }\n+\n+    /// Write some data into this BufReader with line buffering. This means\n+    /// that, if any newlines are present in the data, the data up to the last\n+    /// newline is sent directly to the underlying writer, and data after it\n+    /// is buffered.\n+    ///\n+    /// Because this function attempts to send completed lines to the underlying\n+    /// writer, it will also flush the existing buffer if it contains any\n+    /// newlines, even if the incoming data does not contain any newlines.\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        match memchr::memrchr(b'\\n', buf) {\n+            // If there are no new newlines (that is, if this write is less than\n+            // one line), just do a regular buffered write (which may flush if\n+            // we exceed the inner buffer's size)\n+            None => {\n+                self.flush_if_completed_line()?;\n+                self.buffer.write_all(buf)\n+            }\n+            Some(newline_idx) => {\n+                let (lines, tail) = buf.split_at(newline_idx + 1);\n+\n+                if self.buffered().is_empty() {\n+                    self.inner_mut().write_all(lines)?;\n+                } else {\n+                    // If there is any buffered data, we add the incoming lines\n+                    // to that buffer before flushing, which saves us at least\n+                    // one write call. We can't really do this with `write`,\n+                    // since we can't do this *and* not suppress errors *and*\n+                    // report a consistent state to the caller in a return\n+                    // value, but here in write_all it's fine.\n+                    self.buffer.write_all(lines)?;\n+                    self.buffer.flush_buf()?;\n+                }\n+\n+                self.buffer.write_all(tail)\n+            }\n+        }\n+    }\n+}"}]}