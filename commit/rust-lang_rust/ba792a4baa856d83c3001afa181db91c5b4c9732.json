{"sha": "ba792a4baa856d83c3001afa181db91c5b4c9732", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhNzkyYTRiYWE4NTZkODNjMzAwMWFmYTE4MWRiOTFjNWI0Yzk3MzI=", "commit": {"author": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2015-07-26T15:50:29Z"}, "committer": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2015-08-08T15:15:31Z"}, "message": "Accurate decimal-to-float parsing routines.\n\nThis commit primarily adds implementations of the algorithms from William\nClinger's paper \"How to Read Floating Point Numbers Accurately\". It also\nincludes a lot of infrastructure necessary for those algorithms, and some\nunit tests.\n\nSince these algorithms reject a few (extreme) inputs that were previously\naccepted, this could be seen as a [breaking-change]", "tree": {"sha": "7d2096c3a3aed1829069b5e21d90e74e03da578c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d2096c3a3aed1829069b5e21d90e74e03da578c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba792a4baa856d83c3001afa181db91c5b4c9732", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba792a4baa856d83c3001afa181db91c5b4c9732", "html_url": "https://github.com/rust-lang/rust/commit/ba792a4baa856d83c3001afa181db91c5b4c9732", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba792a4baa856d83c3001afa181db91c5b4c9732/comments", "author": null, "committer": null, "parents": [{"sha": "b7e39a1c2dd24fd4110c22c70cad254365b0ffd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7e39a1c2dd24fd4110c22c70cad254365b0ffd3", "html_url": "https://github.com/rust-lang/rust/commit/b7e39a1c2dd24fd4110c22c70cad254365b0ffd3"}], "stats": {"total": 2802, "additions": 2787, "deletions": 15}, "files": [{"sha": "97019090b56c70ada28f91312e91c0c11b2d0104", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "added", "additions": 353, "deletions": 0, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=ba792a4baa856d83c3001afa181db91c5b4c9732", "patch": "@@ -0,0 +1,353 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The various algorithms from the paper.\n+\n+use num::flt2dec::strategy::grisu::Fp;\n+use prelude::v1::*;\n+use cmp::min;\n+use cmp::Ordering::{Less, Equal, Greater};\n+use super::table;\n+use super::rawfp::{self, Unpacked, RawFloat, fp_to_float, next_float, prev_float};\n+use super::num::{self, Big};\n+\n+/// Number of significand bits in Fp\n+const P: u32 = 64;\n+\n+// We simply store the best approximation for *all* exponents, so\n+// the variable \"h\" and the associated conditions can be omitted.\n+// This trades performance for space (11 KiB versus... 5 KiB or so?)\n+\n+fn power_of_ten(e: i16) -> Fp {\n+    assert!(e >= table::MIN_E);\n+    let i = e - table::MIN_E;\n+    let sig = table::POWERS.0[i as usize];\n+    let exp = table::POWERS.1[i as usize];\n+    Fp { f: sig, e: exp }\n+}\n+\n+/// The fast path of Bellerophon using machine-sized integers and floats.\n+///\n+/// This is extracted into a separate function so that it can be attempted before constructing\n+/// a bignum.\n+pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Option<T> {\n+    let num_digits = integral.len() + fractional.len();\n+    // log_10(f64::max_sig) ~ 15.95. We compare the exact value to max_sig near the end,\n+    // this is just a quick, cheap rejection (and also frees the rest of the code from\n+    // worrying about underflow).\n+    if num_digits > 16 {\n+        return None;\n+    }\n+    if e.abs() >= T::ceil_log5_of_max_sig() as i64 {\n+        return None;\n+    }\n+    let f = num::from_str_unchecked(integral.iter().chain(fractional.iter()));\n+    if f > T::max_sig() {\n+        return None;\n+    }\n+    let e = e as i16; // Can't overflow because e.abs() <= LOG5_OF_EXP_N\n+    // The case e < 0 cannot be folded into the other branch. Negative powers result in\n+    // a repeating fractional part in binary, which are rounded, which causes real\n+    // (and occasioally quite significant!) errors in the final result.\n+    // The case `e == 0`, however, is unnecessary for correctness. It's just measurably faster.\n+    if e == 0 {\n+        Some(T::from_int(f))\n+    } else if e > 0 {\n+        Some(T::from_int(f) * fp_to_float(power_of_ten(e)))\n+    } else {\n+        Some(T::from_int(f) / fp_to_float(power_of_ten(-e)))\n+    }\n+}\n+\n+/// Algorithm Bellerophon is trivial code justified by non-trivial numeric analysis.\n+///\n+/// It rounds ``f`` to a float with 64 bit significand and multiplies it by the best approximation\n+/// of `10^e` (in the same floating point format). This is often enough to get the correct result.\n+/// However, when the result is close to halfway between two adjecent (ordinary) floats, the\n+/// compound rounding error from multiplying two approximation means the result may be off by a\n+/// few bits. When this happens, the iterative Algorithm R fixes things up.\n+///\n+/// The hand-wavy \"close to halfway\" is made precise by the numeric analysis in the paper.\n+/// In the words of Clinger:\n+///\n+/// > Slop, expressed in units of the least significant bit, is an inclusive bound for the error\n+/// > accumulated during the floating point calculation of the approximation to f * 10^e. (Slop is\n+/// > not a bound for the true error, but bounds the difference between the approximation z and\n+/// > the best possible approximation that uses p bits of significand.)\n+pub fn bellerophon<T: RawFloat>(f: &Big, e: i16) -> T {\n+    let slop;\n+    if f <= &Big::from_u64(T::max_sig()) {\n+        // The cases abs(e) < log5(2^N) are in fast_path()\n+        slop = if e >= 0 { 0 } else { 3 };\n+    } else {\n+        slop = if e >= 0 { 1 } else { 4 };\n+    }\n+    let z = rawfp::big_to_fp(f).mul(&power_of_ten(e)).normalize();\n+    let exp_p_n = 1 << (P - T::sig_bits() as u32);\n+    let lowbits: i64 = (z.f % exp_p_n) as i64;\n+    // Is the slop large enough to make a difference when\n+    // rounding to n bits?\n+    if (lowbits - exp_p_n as i64 / 2).abs() <= slop {\n+        algorithm_r(f, e, fp_to_float(z))\n+    } else {\n+        fp_to_float(z)\n+    }\n+}\n+\n+/// An iterative algorithm that improves a floating point approximation of `f * 10^e`.\n+///\n+/// Each iteration gets one unit in the last place closer, which of course takes terribly long to\n+/// converge if `z0` is even mildly off. Luckily, when used as fallback for Bellerophon, the\n+/// starting approximation is off by at most one ULP.\n+fn algorithm_r<T: RawFloat>(f: &Big, e: i16, z0: T) -> T {\n+    let mut z = z0;\n+    loop {\n+        let raw = z.unpack();\n+        let (m, k) = (raw.sig, raw.k);\n+        let mut x = f.clone();\n+        let mut y = Big::from_u64(m);\n+\n+        // Find positive integers `x`, `y` such that `x / y` is exactly `(f * 10^e) / (m * 2^k)`.\n+        // This not only avoids dealing with the signs of `e` and `k`, we also eliminate the\n+        // power of two common to `10^e` and `2^k` to make the numbers smaller.\n+        make_ratio(&mut x, &mut y, e, k);\n+\n+        let m_digits = [(m & 0xFF_FF_FF_FF) as u32, (m >> 32) as u32];\n+        // This is written a bit awkwardly because our bignums don't support\n+        // negative numbers, so we use the absolute value + sign information.\n+        // The multiplication with m_digits can't overflow. If `x` or `y` are large enough that\n+        // we need to worry about overflow, then they are also large enough that`make_ratio` has\n+        // reduced the fraction by a factor of 2^64 or more.\n+        let (d2, d_negative) = if x >= y {\n+            // Don't need x any more, save a clone().\n+            x.sub(&y).mul_pow2(1).mul_digits(&m_digits);\n+            (x, false)\n+        } else {\n+            // Still need y - make a copy.\n+            let mut y = y.clone();\n+            y.sub(&x).mul_pow2(1).mul_digits(&m_digits);\n+            (y, true)\n+        };\n+\n+        if d2 < y {\n+            let mut d2_double = d2;\n+            d2_double.mul_pow2(1);\n+            if m == T::min_sig() && d_negative && d2_double > y {\n+                z = prev_float(z);\n+            } else {\n+                return z;\n+            }\n+        } else if d2 == y {\n+            if m % 2 == 0 {\n+                if m == T::min_sig() && d_negative {\n+                    z = prev_float(z);\n+                } else {\n+                    return z;\n+                }\n+            } else if d_negative {\n+                z = prev_float(z);\n+            } else {\n+                z = next_float(z);\n+            }\n+        } else if d_negative {\n+            z = prev_float(z);\n+        } else {\n+            z = next_float(z);\n+        }\n+    }\n+}\n+\n+/// Given `x = f` and `y = m` where `f` represent input decimal digits as usual and `m` is the\n+/// significand of a floating point approximation, make the ratio `x / y` equal to\n+/// `(f * 10^e) / (m * 2^k)`, possibly reduced by a power of two both have in common.\n+fn make_ratio(x: &mut Big, y: &mut Big, e: i16, k: i16) {\n+    let (e_abs, k_abs) = (e.abs() as usize, k.abs() as usize);\n+    if e >= 0 {\n+        if k >= 0 {\n+            // x = f * 10^e, y = m * 2^k, except that we reduce the fraction by some power of two.\n+            let common = min(e_abs, k_abs);\n+            x.mul_pow5(e_abs).mul_pow2(e_abs - common);\n+            y.mul_pow2(k_abs - common);\n+        } else {\n+            // x = f * 10^e * 2^abs(k), y = m\n+            // This can't overflow because it requires positive `e` and negative `k`, which can\n+            // only happen for values extremely close to 1, which means that `e` and `k` will be\n+            // comparatively tiny.\n+            x.mul_pow5(e_abs).mul_pow2(e_abs + k_abs);\n+        }\n+    } else {\n+        if k >= 0 {\n+            // x = f, y = m * 10^abs(e) * 2^k\n+            // This can't overflow either, see above.\n+            y.mul_pow5(e_abs).mul_pow2(k_abs + e_abs);\n+        } else {\n+            // x = f * 2^abs(k), y = m * 10^abs(e), again reducing by a common power of two.\n+            let common = min(e_abs, k_abs);\n+            x.mul_pow2(k_abs - common);\n+            y.mul_pow5(e_abs).mul_pow2(e_abs - common);\n+        }\n+    }\n+}\n+\n+/// Conceptually, Algorithm M is the simplest way to convert a decimal to a float.\n+///\n+/// We form a ratio that is equal to `f * 10^e`, then throwing in powers of two until it gives\n+/// a valid float significand. The binary exponent `k` is the number of times we multiplied\n+/// numerator or denominator by two, i.e., at all times `f * 10^e` equals `(u / v) * 2^k`.\n+/// When we have found out significand, we only need to round by inspecting the remainder of the\n+/// division, which is done in helper functions further below.\n+///\n+/// This algorithm is super slow, even with the optimization described in `quick_start()`.\n+/// However, it's the simplest of the algorithms to adapt for overflow, underflow, and subnormal\n+/// results. This implementation takes over when Bellerophon and Algorithm R are overwhelmed.\n+/// Detecting underflow and overflow is easy: The ratio still isn't an in-range significand,\n+/// yet the minimum/maximum exponent has been reached. In the case of overflow, we simply return\n+/// infinity.\n+///\n+/// Handling underflow and subnormals is trickier. One big problem is that, with the minimum\n+/// exponent, the ratio might still be too large for a significand. See underflow() for details.\n+pub fn algorithm_m<T: RawFloat>(f: &Big, e: i16) -> T {\n+    let mut u;\n+    let mut v;\n+    let e_abs = e.abs() as usize;\n+    let mut k = 0;\n+    if e < 0 {\n+        u = f.clone();\n+        v = Big::from_small(1);\n+        v.mul_pow5(e_abs).mul_pow2(e_abs);\n+    } else {\n+        // FIXME possible optimization: generalize big_to_fp so that we can do the equivalent of\n+        // fp_to_float(big_to_fp(u)) here, only without the double rounding.\n+        u = f.clone();\n+        u.mul_pow5(e_abs).mul_pow2(e_abs);\n+        v = Big::from_small(1);\n+    }\n+    quick_start::<T>(&mut u, &mut v, &mut k);\n+    let mut rem = Big::from_small(0);\n+    let mut x = Big::from_small(0);\n+    let min_sig = Big::from_u64(T::min_sig());\n+    let max_sig = Big::from_u64(T::max_sig());\n+    loop {\n+        u.div_rem(&v, &mut x, &mut rem);\n+        if k == T::min_exp_int() {\n+            // We have to stop at the minimum exponent, if we wait until `k < T::min_exp_int()`,\n+            // then we'd be off by a factor of two. Unfortunately this means we have to special-\n+            // case normal numbers with the minimum exponent.\n+            // FIXME find a more elegant formulation, but run the `tiny-pow10` test to make sure\n+            // that it's actually correct!\n+            if x >= min_sig && x <= max_sig {\n+                break;\n+            }\n+            return underflow(x, v, rem);\n+        }\n+        if k > T::max_exp_int() {\n+            return T::infinity();\n+        }\n+        if x < min_sig {\n+            u.mul_pow2(1);\n+            k -= 1;\n+        } else if x > max_sig {\n+            v.mul_pow2(1);\n+            k += 1;\n+        } else {\n+            break;\n+        }\n+    }\n+    let q = num::to_u64(&x);\n+    let z = rawfp::encode_normal(Unpacked::new(q, k));\n+    round_by_remainder(v, rem, q, z)\n+}\n+\n+/// Skip over most AlgorithmM iterations by checking the bit length.\n+fn quick_start<T: RawFloat>(u: &mut Big, v: &mut Big, k: &mut i16) {\n+    // The bit length is an estimate of the base two logarithm, and log(u / v) = log(u) - log(v).\n+    // The estimate is off by at most 1, but always an under-estimate, so the error on log(u)\n+    // and log(v) are of the same sign and cancel out (if both are large). Therefore the error\n+    // for log(u / v) is at most one as well.\n+    // The target ratio is one where u/v is in an in-range significand. Thus our termination\n+    // condition is log2(u / v) being the significand bits, plus/minus one.\n+    // FIXME Looking at the second bit could improve the estimate and avoid some more divisions.\n+    let target_ratio = f64::sig_bits() as i16;\n+    let log2_u = u.bit_length() as i16;\n+    let log2_v = v.bit_length() as i16;\n+    let mut u_shift: i16 = 0;\n+    let mut v_shift: i16 = 0;\n+    assert!(*k == 0);\n+    loop {\n+        if *k == T::min_exp_int() {\n+            // Underflow or subnormal. Leave it to the main function.\n+            break;\n+        }\n+        if *k == T::max_exp_int() {\n+            // Overflow. Leave it to the main function.\n+            break;\n+        }\n+        let log2_ratio = (log2_u + u_shift) - (log2_v + v_shift);\n+        if log2_ratio < target_ratio - 1 {\n+            u_shift += 1;\n+            *k -= 1;\n+        } else if log2_ratio > target_ratio + 1 {\n+            v_shift += 1;\n+            *k += 1;\n+        } else {\n+            break;\n+        }\n+    }\n+    u.mul_pow2(u_shift as usize);\n+    v.mul_pow2(v_shift as usize);\n+}\n+\n+fn underflow<T: RawFloat>(x: Big, v: Big, rem: Big) -> T {\n+    if x < Big::from_u64(T::min_sig()) {\n+        let q = num::to_u64(&x);\n+        let z = rawfp::encode_subnormal(q);\n+        return round_by_remainder(v, rem, q, z);\n+    }\n+    // Ratio isn't an in-range significand with the minimum exponent, so we need to round off\n+    // excess bits and adjust the exponent accordingly. The real value now looks like this:\n+    //\n+    //        x        lsb\n+    // /--------------\\/\n+    // 1010101010101010.10101010101010 * 2^k\n+    // \\-----/\\-------/ \\------------/\n+    //    q     trunc.    (represented by rem)\n+    //\n+    // Therefore, when the rounded-off bits are != 0.5 ULP, they decide the rounding\n+    // on their own. When they are equal and the remainder is non-zero, the value still\n+    // needs to be rounded up. Only when the rounded off bits are 1/2 and the remainer\n+    // is zero, we have a half-to-even situation.\n+    let bits = x.bit_length();\n+    let lsb = bits - T::sig_bits() as usize;\n+    let q = num::get_bits(&x, lsb, bits);\n+    let k = T::min_exp_int() + lsb as i16;\n+    let z = rawfp::encode_normal(Unpacked::new(q, k));\n+    let q_even = q % 2 == 0;\n+    match num::compare_with_half_ulp(&x, lsb) {\n+        Greater => next_float(z),\n+        Less => z,\n+        Equal if rem.is_zero() && q_even => z,\n+        Equal => next_float(z),\n+    }\n+}\n+\n+/// Ordinary round-to-even, obfuscated by having to round based on the remainder of a division.\n+fn round_by_remainder<T: RawFloat>(v: Big, r: Big, q: u64, z: T) -> T {\n+    let mut v_minus_r = v;\n+    v_minus_r.sub(&r);\n+    if r < v_minus_r {\n+        z\n+    } else if r > v_minus_r {\n+        next_float(z)\n+    } else if q % 2 == 0 {\n+        z\n+    } else {\n+        next_float(z)\n+    }\n+}"}, {"sha": "413a67b25632176608ec48e22428b14ebd20d63b", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=ba792a4baa856d83c3001afa181db91c5b4c9732", "patch": "@@ -0,0 +1,234 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Converting decimal strings into IEEE 754 binary floating point numbers.\n+//!\n+//! # Problem statement\n+//!\n+//! We are given a decimal string such as `12.34e56`. This string consists of integral (`12`),\n+//! fractional (`45`), and exponent (`56`) parts. All parts are optional and interpreted as zero\n+//! when missing.\n+//!\n+//! We seek the IEEE 754 floating point number that is closest to the exact value of the decimal\n+//! string. It is well-known that many decimal strings do not have terminating representations in\n+//! base two, so we round to 0.5 units in the last place (in other words, as well as possible).\n+//! Ties, decimal values exactly half-way between two consecutive floats, are resolved with the\n+//! half-to-even strategy, also known as banker's rounding.\n+//!\n+//! Needless to say, this is quite hard, both in terms of implementation complexity and in terms\n+//! of CPU cycles taken.\n+//!\n+//! # Implementation\n+//!\n+//! First, we ignore signs. Or rather, we remove it at the very beginning of the conversion\n+//! process and re-apply it at the very end. This is correct in all edge cases since IEEE\n+//! floats are symmetric around zero, negating one simply flips the first bit.\n+//!\n+//! Then we remove the decimal point by adjusting the exponent: Conceptually, `12.34e56` turns\n+//! into `1234e54`, which we describe with a positive integer `f = 1234` and an integer `e = 54`.\n+//! The `(f, e)` representation is used by almost all code past the parsing stage.\n+//!\n+//! We then try a long chain of progressively more general and expensive special cases using\n+//! machine-sized integers and small, fixed-sized floating point numbers (first `f32`/`f64`, then\n+//! a type with 64 bit significand, `Fp`). When all these fail, we bite the bullet and resort to a\n+//! simple but very slow algorithm that involved computing `f * 10^e` fully and doing an iterative\n+//! search for the best approximation.\n+//!\n+//! Primarily, this module and its children implement the algorithms described in:\n+//! \"How to Read Floating Point Numbers Accurately\" by William D. Clinger,\n+//! available online: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.4152\n+//!\n+//! In addition, there are numerous helper functions that are used in the paper but not available\n+//! in Rust (or at least in core). Our version is additionally complicated by the need to handle\n+//! overflow and underflow and the desire to handle subnormal numbers.  Bellerophon and\n+//! Algorithm R have trouble with overflow, subnormals, and underflow. We conservatively switch to\n+//! Algorithm M (with the modifications described in section 8 of the paper) well before the\n+//! inputs get into the critical region.\n+//!\n+//! Another aspect that needs attention is the ``RawFloat`` trait by which almost all functions\n+//! are parametrized. One might think that it's enough to parse to `f64` and cast the result to\n+//! `f32`. Unfortunately this is not the world we live in, and this has nothing to do with using\n+//! base two or half-to-even rounding.\n+//!\n+//! Consider for example two types `d2` and `d4` representing a decimal type with two decimal\n+//! digits and four decimal digits each and take \"0.01499\" as input. Let's use half-up rounding.\n+//! Going directly to two decimal digits gives `0.01`, but if we round to four digits first,\n+//! we get `0.0150`, which is then rounded up to `0.02`. The same principle applies to other\n+//! operations as well, if you want 0.5 ULP accuracy you need to do *everything* in full precision\n+//! and round *exactly once, at the end*, by considering all truncated bits at once.\n+//!\n+//! FIXME Although some code duplication is necessary, perhaps parts of the code could be shuffled\n+//! around such that less code is duplicated. Large parts of the algorithms are independent of the\n+//! float type to output, or only needs access to a few constants, which could be passed in as\n+//! parameters.\n+//!\n+//! # Other\n+//!\n+//! The conversion should *never* panic. There are assertions and explicit panics in the code,\n+//! but they should never be triggered and only serve as internal sanity checks. Any panics should\n+//! be considered a bug.\n+//!\n+//! There are unit tests but they are woefully inadequate at ensuring correctness, they only cover\n+//! a small percentage of possible errors. Far more extensive tests are located in the directory\n+//! `src/etc/test-float-parse` as a Python script.\n+//!\n+//! A note on integer overflow: Many parts of this file perform arithmetic with the decimal\n+//! exponent `e`. Primarily, we shift the decimal point around: Before the first decimal digit,\n+//! after the last decimal digit, and so on. This could overflow if done carelessly. We rely on\n+//! the parsing submodule to only hand out sufficiently small exponents, where \"sufficient\" means\n+//! \"such that the exponent +/- the number of decimal digits fits into a 64 bit integer\".\n+//! Larger exponents are accepted, but we don't do arithmetic with them, they are immediately\n+//! turned into {positive,negative} {zero,infinity}.\n+//!\n+//! FIXME: this uses several things from core::num::flt2dec, which is nonsense. Those things\n+//! should be moved into core::num::<something else>.\n+\n+#![doc(hidden)]\n+#![unstable(feature = \"dec2flt\",\n+            reason = \"internal routines only exposed for testing\")]\n+\n+use prelude::v1::*;\n+use num::ParseFloatError as PFE;\n+use num::FloatErrorKind;\n+use self::parse::{parse_decimal, Decimal, Sign};\n+use self::parse::ParseResult::{self, Valid, ShortcutToInf, ShortcutToZero};\n+use self::num::digits_to_big;\n+use self::rawfp::RawFloat;\n+\n+mod algorithm;\n+mod table;\n+mod num;\n+// These two have their own tests.\n+pub mod rawfp;\n+pub mod parse;\n+\n+/// Entry point for decimal-to-f32 conversion.\n+pub fn to_f32(s: &str) -> Result<f32, PFE> {\n+    dec2flt(s)\n+}\n+\n+/// Entry point for decimal-to-f64 conversion.\n+pub fn to_f64(s: &str) -> Result<f64, PFE> {\n+    dec2flt(s)\n+}\n+\n+/// Split decimal string into sign and the rest, without inspecting or validating the rest.\n+fn extract_sign(s: &str) -> (Sign, &str) {\n+    match s.as_bytes()[0] {\n+        b'+' => (Sign::Positive, &s[1..]),\n+        b'-' => (Sign::Negative, &s[1..]),\n+        // If the string is invalid, we never use the sign, so we don't need to validate here.\n+        _ => (Sign::Positive, s),\n+    }\n+}\n+\n+/// Convert a decimal string into a floating point number.\n+fn dec2flt<T: RawFloat>(s: &str) -> Result<T, PFE> {\n+    if s.is_empty() {\n+        return Err(PFE { __kind: FloatErrorKind::Empty });\n+    }\n+    let (sign, s) = extract_sign(s);\n+    let flt = match parse_decimal(s) {\n+        Valid(decimal) => try!(convert(decimal)),\n+        ShortcutToInf => T::infinity(),\n+        ShortcutToZero => T::zero(),\n+        ParseResult::Invalid => match s {\n+            \"inf\" => T::infinity(),\n+            \"NaN\" => T::nan(),\n+            _ => { return Err(PFE { __kind: FloatErrorKind::Invalid }); }\n+        }\n+    };\n+\n+    match sign {\n+        Sign::Positive => Ok(flt),\n+        Sign::Negative => Ok(-flt),\n+    }\n+}\n+\n+/// The main workhorse for the decimal-to-float conversion: Orchestrate all the preprocessing\n+/// and figure out which algorithm should do the actual conversion.\n+fn convert<T: RawFloat>(mut decimal: Decimal) -> Result<T, PFE> {\n+    simplify(&mut decimal);\n+    if let Some(x) = trivial_cases(&decimal) {\n+        return Ok(x);\n+    }\n+    // AlgorithmM and AlgorithmR both compute approximately `f * 10^e`.\n+    let max_digits = decimal.integral.len() + decimal.fractional.len() +\n+                     decimal.exp.abs() as usize;\n+    // Remove/shift out the decimal point.\n+    let e = decimal.exp - decimal.fractional.len() as i64;\n+    if let Some(x) = algorithm::fast_path(decimal.integral, decimal.fractional, e) {\n+        return Ok(x);\n+    }\n+    // Big32x40 is limited to 1280 bits, which translates to about 385 decimal digits.\n+    // If we exceed this, perhaps while calculating `f * 10^e` in Algorithm R or Algorithm M,\n+    // we'll crash. So we error out before getting too close, with a generous safety margin.\n+    if max_digits > 375 {\n+        return Err(PFE { __kind: FloatErrorKind::Invalid });\n+    }\n+    let f = digits_to_big(decimal.integral, decimal.fractional);\n+\n+    // Now the exponent certainly fits in 16 bit, which is used throughout the main algorithms.\n+    let e = e as i16;\n+    // FIXME These bounds are rather conservative. A more careful analysis of the failure modes\n+    // of Bellerophon could allow using it in more cases for a massive speed up.\n+    let exponent_in_range = table::MIN_E <= e && e <= table::MAX_E;\n+    let value_in_range = max_digits <= T::max_normal_digits();\n+    if exponent_in_range && value_in_range {\n+        Ok(algorithm::bellerophon(&f, e))\n+    } else {\n+        Ok(algorithm::algorithm_m(&f, e))\n+    }\n+}\n+\n+// As written, this optimizes badly (see #27130, though it refers to an old version of the code).\n+// `inline(always)` is a workaround for that. There are only two call sites overall and it doesn't\n+// make code size worse.\n+\n+/// Strip zeros where possible, even when this requires changing the exponent\n+#[inline(always)]\n+fn simplify(decimal: &mut Decimal) {\n+    let is_zero = &|&&d: &&u8| -> bool { d == b'0' };\n+    // Trimming these zeros does not change anything but may enable the fast path (< 15 digits).\n+    let leading_zeros = decimal.integral.iter().take_while(is_zero).count();\n+    decimal.integral = &decimal.integral[leading_zeros..];\n+    let trailing_zeros = decimal.fractional.iter().rev().take_while(is_zero).count();\n+    let end = decimal.fractional.len() - trailing_zeros;\n+    decimal.fractional = &decimal.fractional[..end];\n+    // Simplify numbers of the form 0.0...x and x...0.0, adjusting the exponent accordingly.\n+    // This may not always be a win (possibly pushes some numbers out of the fast path), but it\n+    // simplifies other parts significantly (notably, approximating the magnitude of the value).\n+    if decimal.integral.is_empty() {\n+        let leading_zeros = decimal.fractional.iter().take_while(is_zero).count();\n+        decimal.fractional = &decimal.fractional[leading_zeros..];\n+        decimal.exp -= leading_zeros as i64;\n+    } else if decimal.fractional.is_empty() {\n+        let trailing_zeros = decimal.integral.iter().rev().take_while(is_zero).count();\n+        let end = decimal.integral.len() - trailing_zeros;\n+        decimal.integral = &decimal.integral[..end];\n+        decimal.exp += trailing_zeros as i64;\n+    }\n+}\n+\n+/// Detect obvious overflows and underflows without even looking at the decimal digits.\n+fn trivial_cases<T: RawFloat>(decimal: &Decimal) -> Option<T> {\n+    // There were zeros but they were stripped by simplify()\n+    if decimal.integral.is_empty() && decimal.fractional.is_empty() {\n+        return Some(T::zero());\n+    }\n+    // This is a crude approximation of ceil(log10(the real value)).\n+    let max_place = decimal.exp + decimal.integral.len() as i64;\n+    if max_place > T::inf_cutoff() {\n+        return Some(T::infinity());\n+    } else if max_place < T::zero_cutoff() {\n+        return Some(T::zero());\n+    }\n+    None\n+}"}, {"sha": "dcba73d7c93221a687e91c8f50b513dcadd743e9", "filename": "src/libcore/num/dec2flt/num.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs?ref=ba792a4baa856d83c3001afa181db91c5b4c9732", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Utility functions for bignums that don't make too much sense to turn into methods.\n+\n+// FIXME This module's name is a bit unfortunate, since other modules also import `core::num`.\n+\n+use prelude::v1::*;\n+use cmp::Ordering::{self, Less, Equal, Greater};\n+use num::flt2dec::bignum::Big32x40;\n+\n+pub type Big = Big32x40;\n+\n+/// Test whether truncating all bits less significant than `ones_place` introduces\n+/// a relative error less, equal, or greater than 0.5 ULP.\n+pub fn compare_with_half_ulp(f: &Big, ones_place: usize) -> Ordering {\n+    if ones_place == 0 {\n+        return Less;\n+    }\n+    let half_bit = ones_place - 1;\n+    if f.get_bit(half_bit) == 0 {\n+        // < 0.5 ULP\n+        return Less;\n+    }\n+    // If all remaining bits are zero, it's = 0.5 ULP, otherwise > 0.5\n+    // If there are no more bits (half_bit == 0), the below also correctly returns Equal.\n+    for i in 0..half_bit {\n+        if f.get_bit(i) == 1 {\n+            return Greater;\n+        }\n+    }\n+    Equal\n+}\n+\n+/// Convert an ASCII string containing only decimal digits to a `u64`.\n+///\n+/// Does not perform checks for overflow or invalid characters, so if the caller is not careful,\n+/// the result is bogus and can panic (though it won't be `unsafe`). Additionally, empty strings\n+/// are treated as zero. This function exists because\n+///\n+/// 1. using `FromStr` on `&[u8]` requires `from_utf8_unchecked`, which is bad, and\n+/// 2. piecing together the results of `integral.parse()` and `fractional.parse()` is\n+///    more complicated than this entire function.\n+pub fn from_str_unchecked<'a, T>(bytes: T) -> u64 where T : IntoIterator<Item=&'a u8> {\n+    let mut result = 0;\n+    for &c in bytes {\n+        result = result * 10 + (c - b'0') as u64;\n+    }\n+    result\n+}\n+\n+/// Convert a string of ASCII digits into a bignum.\n+///\n+/// Like `from_str_unchecked`, this function relies on the parser to weed out non-digits.\n+pub fn digits_to_big(integral: &[u8], fractional: &[u8]) -> Big {\n+    let mut f = Big::from_small(0);\n+    for &c in integral.iter().chain(fractional) {\n+        let n = (c - b'0') as u32;\n+        f.mul_small(10);\n+        f.add_small(n);\n+    }\n+    f\n+}\n+\n+/// Unwraps a bignum into a 64 bit integer. Panics if the number is too large.\n+pub fn to_u64(x: &Big) -> u64 {\n+    assert!(x.bit_length() < 64);\n+    let d = x.digits();\n+    if d.len() < 2 {\n+        d[0] as u64\n+    } else {\n+        (d[1] as u64) << 32 | d[0] as u64\n+    }\n+}\n+\n+\n+/// Extract a range of bits.\n+\n+/// Index 0 is the least significant bit and the range is half-open as usual.\n+/// Panics if asked to extract more bits than fit into the return type.\n+pub fn get_bits(x: &Big, start: usize, end: usize) -> u64 {\n+    assert!(end - start <= 64);\n+    let mut result: u64 = 0;\n+    for i in (start..end).rev() {\n+        result = result << 1 | x.get_bit(i) as u64;\n+    }\n+    result\n+}"}, {"sha": "58e2a6e9bba4694859f234eb67edd72fa8ddbe87", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=ba792a4baa856d83c3001afa181db91c5b4c9732", "patch": "@@ -0,0 +1,128 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Validating and decomposing a decimal string of the form:\n+//!\n+//! `(digits | digits? '.'? digits?) (('e' | 'E') ('+' | '-')? digits)?`\n+//!\n+//! In other words, standard floating-point syntax, with two exceptions: No sign, and no\n+//! handling of \"inf\" and \"NaN\". These are handled by the driver function (super::dec2flt).\n+//!\n+//! Although recognizing valid inputs is relatively easy, this module also has to reject the\n+//! countless invalid variations, never panic, and perform numerous checks that the other\n+//! modules rely on to not panic (or overflow) in turn.\n+//! To make matters worse, all that happens in a single pass over the input.\n+//! So, be careful when modifying anything, and double-check with the other modules.\n+use prelude::v1::*;\n+use super::num;\n+use self::ParseResult::{Valid, ShortcutToInf, ShortcutToZero, Invalid};\n+\n+#[derive(Debug)]\n+pub enum Sign {\n+    Positive,\n+    Negative,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+/// The interesting parts of a decimal string.\n+pub struct Decimal<'a> {\n+    pub integral: &'a [u8],\n+    pub fractional: &'a [u8],\n+    /// The decimal exponent, guaranteed to have fewer than 18 decimal digits.\n+    pub exp: i64,\n+}\n+\n+impl<'a> Decimal<'a> {\n+    pub fn new(integral: &'a [u8], fractional: &'a [u8], exp: i64) -> Decimal<'a> {\n+        Decimal { integral: integral, fractional: fractional, exp: exp }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum ParseResult<'a> {\n+    Valid(Decimal<'a>),\n+    ShortcutToInf,\n+    ShortcutToZero,\n+    Invalid,\n+}\n+\n+/// Check if the input string is a valid floating point number and if so, locate the integral\n+/// part, the fractional part, and the exponent in it. Does not handle signs.\n+pub fn parse_decimal(s: &str) -> ParseResult {\n+    let s = s.as_bytes();\n+    let (integral, s) = eat_digits(s);\n+    match s.first() {\n+        None => Valid(Decimal::new(integral, b\"\", 0)),\n+        Some(&b'e') | Some(&b'E') => {\n+            if integral.is_empty() {\n+                return Invalid; // No digits before 'e'\n+            }\n+            parse_exp(integral, b\"\", &s[1..])\n+        }\n+        Some(&b'.') => {\n+            let (fractional, s) = eat_digits(&s[1..]);\n+            if integral.is_empty() && fractional.is_empty() && s.is_empty() {\n+                // For historic reasons \".\" is a valid input.\n+                return Valid(Decimal::new(b\"\", b\"\", 0));\n+            }\n+            match s.first() {\n+                None => Valid(Decimal::new(integral, fractional, 0)),\n+                Some(&b'e') | Some(&b'E') => parse_exp(integral, fractional, &s[1..]),\n+                _ => Invalid, // Trailing junk after fractional part\n+            }\n+        }\n+        _ => Invalid, // Trailing junk after first digit string\n+    }\n+}\n+\n+/// Carve off decimal digits up to the first non-digit character.\n+fn eat_digits(s: &[u8]) -> (&[u8], &[u8]) {\n+    let mut i = 0;\n+    while i < s.len() && b'0' <= s[i] && s[i] <= b'9' {\n+        i += 1;\n+    }\n+    (&s[..i], &s[i..])\n+}\n+\n+/// Exponent extraction and error checking.\n+fn parse_exp<'a>(integral: &'a [u8], fractional: &'a [u8], rest: &'a [u8]) -> ParseResult<'a> {\n+    let (sign, rest) = match rest.first() {\n+        Some(&b'-') => (Sign::Negative, &rest[1..]),\n+        Some(&b'+') => (Sign::Positive, &rest[1..]),\n+        _ => (Sign::Positive, rest),\n+    };\n+    let (mut number, trailing) = eat_digits(rest);\n+    if !trailing.is_empty() {\n+        return Invalid; // Trailing junk after exponent\n+    }\n+    if number.is_empty() {\n+        return Invalid; // Empty exponent\n+    }\n+    // At this point, we certainly have a valid string of digits. It may be too long to put into\n+    // an `i64`, but if it's that huge, the input is certainly zero or infinity. Since each zero\n+    // in the decimal digits only adjusts the exponent by +/- 1, at exp = 10^18 the input would\n+    // have to be 17 exabyte (!) of zeros to get even remotely close to being finite.\n+    // This is not exactly a use case we need to cater to.\n+    while number.first() == Some(&b'0') {\n+        number = &number[1..];\n+    }\n+    if number.len() >= 18 {\n+        return match sign {\n+            Sign::Positive => ShortcutToInf,\n+            Sign::Negative => ShortcutToZero,\n+        };\n+    }\n+    let abs_exp = num::from_str_unchecked(number);\n+    let e = match sign {\n+        Sign::Positive => abs_exp as i64,\n+        Sign::Negative => -(abs_exp as i64),\n+    };\n+    Valid(Decimal::new(integral, fractional, e))\n+}"}, {"sha": "830d2dad42fe50de464bfbb010be0d7c68d16b80", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=ba792a4baa856d83c3001afa181db91c5b4c9732", "patch": "@@ -0,0 +1,356 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Bit fiddling on positive IEEE 754 floats. Negative numbers aren't and needn't be handled.\n+//! Normal floating point numbers have a canonical representation as (frac, exp) such that the\n+//! value is 2^exp * (1 + sum(frac[N-i] / 2^i)) where N is the number of bits. Subnormals are\n+//! slightly different and weird, but the same principle applies.\n+//!\n+//! Here, however, we represent them as (sig, k) with f positive, such that the value is f * 2^e.\n+//! Besides making the \"hidden bit\" explicit, this changes the exponent by the so-called\n+//! mantissa shift.\n+//!\n+//! Put another way, normally floats are written as (1) but here they are written as (2):\n+//!\n+//! 1. `1.101100...11 * 2^m`\n+//! 2. `1101100...11 * 2^n`\n+//!\n+//! We call (1) the **fractional representation** and (2) the **integral representation**.\n+//!\n+//! Many functions in this module only handle normal numbers. The dec2flt routines conservatively\n+//! take the universally-correct slow path (Algorithm M) for very small and very large numbers.\n+//! That algorithm needs only next_float() which does handle subnormals and zeros.\n+use prelude::v1::*;\n+use u32;\n+use cmp::Ordering::{Less, Equal, Greater};\n+use ops::{Mul, Div, Neg};\n+use fmt::{Debug, LowerExp};\n+use mem::transmute;\n+use num::flt2dec::strategy::grisu::Fp;\n+use num::FpCategory::{Infinite, Zero, Subnormal, Normal, Nan};\n+use num::Float;\n+use super::num::{self, Big};\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct Unpacked {\n+    pub sig: u64,\n+    pub k: i16,\n+}\n+\n+impl Unpacked {\n+    pub fn new(sig: u64, k: i16) -> Self {\n+        Unpacked { sig: sig, k: k }\n+    }\n+}\n+\n+/// A helper trait to avoid duplicating basically all the conversion code for `f32` and `f64`.\n+///\n+/// See the parent module's doc comment for why this is necessary.\n+///\n+/// Should **never ever** be implemented for other types or be used outside the dec2flt module.\n+/// Inherits from `Float` because there is some overlap, but all the reused methods are trivial.\n+/// The \"methods\" (pseudo-constants) with default implementation should not be overriden.\n+pub trait RawFloat : Float + Copy + Debug + LowerExp\n+                    + Mul<Output=Self> + Div<Output=Self> + Neg<Output=Self>\n+{\n+    /// Get the raw binary representation of the float.\n+    fn transmute(self) -> u64;\n+\n+    /// Transmute the raw binary representation into a float.\n+    fn from_bits(bits: u64) -> Self;\n+\n+    /// Decode the float.\n+    fn unpack(self) -> Unpacked;\n+\n+    /// Cast from a small integer that can be represented exactly.  Panic if the integer can't be\n+    /// represented, the other code in this module makes sure to never let that happen.\n+    fn from_int(x: u64) -> Self;\n+\n+    // FIXME Everything that follows should be associated constants, but taking the value of an\n+    // associated constant from a type parameter does not work (yet?)\n+    // A possible workaround is having a `FloatInfo` struct for all the constants, but so far\n+    // the methods aren't painful enough to rewrite.\n+\n+    /// What the name says. It's easier to hard code than juggling intrinsics and\n+    /// hoping LLVM constant folds it.\n+    fn ceil_log5_of_max_sig() -> i16;\n+\n+    // A conservative bound on the decimal digits of inputs that can't produce overflow or zero or\n+    /// subnormals. Probably the decimal exponent of the maximum normal value, hence the name.\n+    fn max_normal_digits() -> usize;\n+\n+    /// When the most significant decimal digit has a place value greater than this, the number\n+    /// is certainly rounded to infinity.\n+    fn inf_cutoff() -> i64;\n+\n+    /// When the most significant decimal digit has a place value less than this, the number\n+    /// is certainly rounded to zero.\n+    fn zero_cutoff() -> i64;\n+\n+    /// The number of bits in the exponent.\n+    fn exp_bits() -> u8;\n+\n+    /// The number of bits in the singificand, *including* the hidden bit.\n+    fn sig_bits() -> u8;\n+\n+    /// The number of bits in the singificand, *excluding* the hidden bit.\n+    fn explicit_sig_bits() -> u8 {\n+        Self::sig_bits() - 1\n+    }\n+\n+    /// The maximum legal exponent in fractional representation.\n+    fn max_exp() -> i16 {\n+        (1 << (Self::exp_bits() - 1)) - 1\n+    }\n+\n+    /// The minimum legal exponent in fractional representation, excluding subnormals.\n+    fn min_exp() -> i16 {\n+        -Self::max_exp() + 1\n+    }\n+\n+    /// `MAX_EXP` for integral representation, i.e., with the shift applied.\n+    fn max_exp_int() -> i16 {\n+        Self::max_exp() - (Self::sig_bits() as i16 - 1)\n+    }\n+\n+    /// `MAX_EXP` encoded (i.e., with offset bias)\n+    fn max_encoded_exp() -> i16 {\n+        (1 << Self::exp_bits()) - 1\n+    }\n+\n+    /// `MIN_EXP` for integral representation, i.e., with the shift applied.\n+    fn min_exp_int() -> i16 {\n+        Self::min_exp() - (Self::sig_bits() as i16 - 1)\n+    }\n+\n+    /// The maximum normalized singificand in integral representation.\n+    fn max_sig() -> u64 {\n+        (1 << Self::sig_bits()) - 1\n+    }\n+\n+    /// The minimal normalized significand in integral representation.\n+    fn min_sig() -> u64 {\n+        1 << (Self::sig_bits() - 1)\n+    }\n+}\n+\n+impl RawFloat for f32 {\n+    fn sig_bits() -> u8 {\n+        24\n+    }\n+\n+    fn exp_bits() -> u8 {\n+        8\n+    }\n+\n+    fn ceil_log5_of_max_sig() -> i16 {\n+        11\n+    }\n+\n+    fn transmute(self) -> u64 {\n+        let bits: u32 = unsafe { transmute(self) };\n+        bits as u64\n+    }\n+\n+    fn from_bits(bits: u64) -> f32 {\n+        assert!(bits < u32::MAX as u64, \"f32::from_bits: too many bits\");\n+        unsafe { transmute(bits as u32) }\n+    }\n+\n+    fn unpack(self) -> Unpacked {\n+        let (sig, exp, _sig) = self.integer_decode();\n+        Unpacked::new(sig, exp)\n+    }\n+\n+    fn from_int(x: u64) -> f32 {\n+        // rkruppe is uncertain whether `as` rounds correctly on all platforms.\n+        debug_assert!(x as f32 == fp_to_float(Fp { f: x, e: 0 }));\n+        x as f32\n+    }\n+\n+    fn max_normal_digits() -> usize {\n+        35\n+    }\n+\n+    fn inf_cutoff() -> i64 {\n+        40\n+    }\n+\n+    fn zero_cutoff() -> i64 {\n+        -48\n+    }\n+}\n+\n+\n+impl RawFloat for f64 {\n+    fn sig_bits() -> u8 {\n+        53\n+    }\n+\n+    fn exp_bits() -> u8 {\n+        11\n+    }\n+\n+    fn ceil_log5_of_max_sig() -> i16 {\n+        23\n+    }\n+\n+    fn transmute(self) -> u64 {\n+        let bits: u64 = unsafe { transmute(self) };\n+        bits\n+    }\n+\n+    fn from_bits(bits: u64) -> f64 {\n+        unsafe { transmute(bits) }\n+    }\n+\n+    fn unpack(self) -> Unpacked {\n+        let (sig, exp, _sig) = self.integer_decode();\n+        Unpacked::new(sig, exp)\n+    }\n+\n+    fn from_int(x: u64) -> f64 {\n+        // rkruppe is uncertain whether `as` rounds correctly on all platforms.\n+        debug_assert!(x as f64 == fp_to_float(Fp { f: x, e: 0 }));\n+        x as f64\n+    }\n+\n+    fn max_normal_digits() -> usize {\n+        305\n+    }\n+\n+    fn inf_cutoff() -> i64 {\n+        310\n+    }\n+\n+    fn zero_cutoff() -> i64 {\n+        -326\n+    }\n+\n+}\n+\n+/// Convert an Fp to the closest f64. Only handles number that fit into a normalized f64.\n+pub fn fp_to_float<T: RawFloat>(x: Fp) -> T {\n+    let x = x.normalize();\n+    // x.f is 64 bit, so x.e has a mantissa shift of 63\n+    let e = x.e + 63;\n+    if e > T::max_exp() {\n+        panic!(\"fp_to_float: exponent {} too large\", e)\n+    }  else if e > T::min_exp() {\n+        encode_normal(round_normal::<T>(x))\n+    } else {\n+        panic!(\"fp_to_float: exponent {} too small\", e)\n+    }\n+}\n+\n+/// Round the 64-bit significand to 53 bit with half-to-even. Does not handle exponent overflow.\n+pub fn round_normal<T: RawFloat>(x: Fp) -> Unpacked {\n+    let excess = 64 - T::sig_bits() as i16;\n+    let half: u64 = 1 << (excess - 1);\n+    let (q, rem) = (x.f >> excess, x.f & ((1 << excess) - 1));\n+    assert_eq!(q << excess | rem, x.f);\n+    // Adjust mantissa shift\n+    let k = x.e + excess;\n+    if rem < half {\n+        Unpacked::new(q, k)\n+    } else if rem == half && (q % 2) == 0 {\n+        Unpacked::new(q, k)\n+    } else if q == T::max_sig() {\n+        Unpacked::new(T::min_sig(), k + 1)\n+    } else {\n+        Unpacked::new(q + 1, k)\n+    }\n+}\n+\n+/// Inverse of `RawFloat::unpack()` for normalized numbers.\n+/// Panics if the significand or exponent are not valid for normalized numbers.\n+pub fn encode_normal<T: RawFloat>(x: Unpacked) -> T {\n+    debug_assert!(T::min_sig() <= x.sig && x.sig <= T::max_sig(),\n+        \"encode_normal: significand not normalized\");\n+    // Remove the hidden bit\n+    let sig_enc = x.sig & !(1 << T::explicit_sig_bits());\n+    // Adjust the exponent for exponent bias and mantissa shift\n+    let k_enc = x.k + T::max_exp() + T::explicit_sig_bits() as i16;\n+    debug_assert!(k_enc != 0 && k_enc < T::max_encoded_exp(),\n+        \"encode_normal: exponent out of range\");\n+    // Leave sign bit at 0 (\"+\"), our numbers are all positive\n+    let bits = (k_enc as u64) << T::explicit_sig_bits() | sig_enc;\n+    T::from_bits(bits)\n+}\n+\n+/// Construct the subnormal. A mantissa of 0 is allowed and constructs zero.\n+pub fn encode_subnormal<T: RawFloat>(significand: u64) -> T {\n+    assert!(significand < T::min_sig(), \"encode_subnormal: not actually subnormal\");\n+    // \u00cancoded exponent is 0, the sign bit is 0, so we just have to reinterpret the bits.\n+    T::from_bits(significand)\n+}\n+\n+/// Approximate a bignum with an Fp. Rounds within 0.5 ULP with half-to-even.\n+pub fn big_to_fp(f: &Big) -> Fp {\n+    let end = f.bit_length();\n+    assert!(end != 0, \"big_to_fp: unexpectedly, input is zero\");\n+    let start = end.saturating_sub(64);\n+    let leading = num::get_bits(f, start, end);\n+    // We cut off all bits prior to the index `start`, i.e., we effectively right-shift by\n+    // an amount of `start`, so this is also the exponent we need.\n+    let e = start as i16;\n+    let rounded_down = Fp { f: leading, e: e }.normalize();\n+    // Round (half-to-even) depending on the truncated bits.\n+    match num::compare_with_half_ulp(f, start) {\n+        Less => rounded_down,\n+        Equal if leading % 2 == 0 => rounded_down,\n+        Equal | Greater => match leading.checked_add(1) {\n+            Some(f) => Fp { f: f, e: e }.normalize(),\n+            None => Fp { f: 1 << 63, e: e + 1 },\n+        }\n+    }\n+}\n+\n+/// Find the largest floating point number strictly smaller than the argument.\n+/// Does not handle subnormals, zero, or exponent underflow.\n+pub fn prev_float<T: RawFloat>(x: T) -> T {\n+    match x.classify() {\n+        Infinite => panic!(\"prev_float: argument is infinite\"),\n+        Nan => panic!(\"prev_float: argument is NaN\"),\n+        Subnormal => panic!(\"prev_float: argument is subnormal\"),\n+        Zero => panic!(\"prev_float: argument is zero\"),\n+        Normal => {\n+            let Unpacked { sig, k } = x.unpack();\n+            if sig == T::min_sig() {\n+                encode_normal(Unpacked::new(T::max_sig(), k - 1))\n+            } else {\n+                encode_normal(Unpacked::new(sig - 1, k))\n+            }\n+        }\n+    }\n+}\n+\n+// Find the smallest floating point number strictly larger than the argument.\n+// This operation is saturating, i.e. next_float(inf) == inf.\n+// Unlike most code in this module, this function does handle zero, subnormals, and infinities.\n+// However, like all other code here, it does not deal with NaN and negative numbers.\n+pub fn next_float<T: RawFloat>(x: T) -> T {\n+    match x.classify() {\n+        Nan => panic!(\"next_float: argument is NaN\"),\n+        Infinite => T::infinity(),\n+        // This seems too good to be true, but it works.\n+        // 0.0 is encoded as the all-zero word. Subnormals are 0x000m...m where m is the mantissa.\n+        // In particular, the smallest subnormal is 0x0...01 and the largest is 0x000F...F.\n+        // The smallest normal number is 0x0010...0, so this corner case works as well.\n+        // If the increment overflows the mantissa, the carry bit increments the exponent as we\n+        // want, and the mantissa bits become zero. Because of the hidden bit convention, this\n+        // too is exactly what we want!\n+        // Finally, f64::MAX + 1 = 7eff...f + 1 = 7ff0...0 = f64::INFINITY.\n+        Zero | Subnormal | Normal => {\n+            let bits: u64 = x.transmute();\n+            T::from_bits(bits + 1)\n+        }\n+    }\n+}"}, {"sha": "dd985fd155b850417cd3326d7ffcadac407f4b4f", "filename": "src/libcore/num/dec2flt/table.rs", "status": "added", "additions": 1239, "deletions": 0, "changes": 1239, "blob_url": "https://github.com/rust-lang/rust/blob/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcore%2Fnum%2Fdec2flt%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcore%2Fnum%2Fdec2flt%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Ftable.rs?ref=ba792a4baa856d83c3001afa181db91c5b4c9732", "patch": "@@ -0,0 +1,1239 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+// Table of approximations of powers of ten.\n+// DO NOT MODIFY: Generated by a src/etc/dec2flt_table.py\n+pub const MIN_E: i16 = -305;\n+pub const MAX_E: i16 = 305;\n+\n+pub const POWERS: ([u64; 611], [i16; 611]) = ([\n+    0xe0b62e2929aba83c,\n+    0x8c71dcd9ba0b4926,\n+    0xaf8e5410288e1b6f,\n+    0xdb71e91432b1a24b,\n+    0x892731ac9faf056f,\n+    0xab70fe17c79ac6ca,\n+    0xd64d3d9db981787d,\n+    0x85f0468293f0eb4e,\n+    0xa76c582338ed2622,\n+    0xd1476e2c07286faa,\n+    0x82cca4db847945ca,\n+    0xa37fce126597973d,\n+    0xcc5fc196fefd7d0c,\n+    0xff77b1fcbebcdc4f,\n+    0x9faacf3df73609b1,\n+    0xc795830d75038c1e,\n+    0xf97ae3d0d2446f25,\n+    0x9becce62836ac577,\n+    0xc2e801fb244576d5,\n+    0xf3a20279ed56d48a,\n+    0x9845418c345644d7,\n+    0xbe5691ef416bd60c,\n+    0xedec366b11c6cb8f,\n+    0x94b3a202eb1c3f39,\n+    0xb9e08a83a5e34f08,\n+    0xe858ad248f5c22ca,\n+    0x91376c36d99995be,\n+    0xb58547448ffffb2e,\n+    0xe2e69915b3fff9f9,\n+    0x8dd01fad907ffc3c,\n+    0xb1442798f49ffb4b,\n+    0xdd95317f31c7fa1d,\n+    0x8a7d3eef7f1cfc52,\n+    0xad1c8eab5ee43b67,\n+    0xd863b256369d4a41,\n+    0x873e4f75e2224e68,\n+    0xa90de3535aaae202,\n+    0xd3515c2831559a83,\n+    0x8412d9991ed58092,\n+    0xa5178fff668ae0b6,\n+    0xce5d73ff402d98e4,\n+    0x80fa687f881c7f8e,\n+    0xa139029f6a239f72,\n+    0xc987434744ac874f,\n+    0xfbe9141915d7a922,\n+    0x9d71ac8fada6c9b5,\n+    0xc4ce17b399107c23,\n+    0xf6019da07f549b2b,\n+    0x99c102844f94e0fb,\n+    0xc0314325637a193a,\n+    0xf03d93eebc589f88,\n+    0x96267c7535b763b5,\n+    0xbbb01b9283253ca3,\n+    0xea9c227723ee8bcb,\n+    0x92a1958a7675175f,\n+    0xb749faed14125d37,\n+    0xe51c79a85916f485,\n+    0x8f31cc0937ae58d3,\n+    0xb2fe3f0b8599ef08,\n+    0xdfbdcece67006ac9,\n+    0x8bd6a141006042be,\n+    0xaecc49914078536d,\n+    0xda7f5bf590966849,\n+    0x888f99797a5e012d,\n+    0xaab37fd7d8f58179,\n+    0xd5605fcdcf32e1d7,\n+    0x855c3be0a17fcd26,\n+    0xa6b34ad8c9dfc070,\n+    0xd0601d8efc57b08c,\n+    0x823c12795db6ce57,\n+    0xa2cb1717b52481ed,\n+    0xcb7ddcdda26da269,\n+    0xfe5d54150b090b03,\n+    0x9efa548d26e5a6e2,\n+    0xc6b8e9b0709f109a,\n+    0xf867241c8cc6d4c1,\n+    0x9b407691d7fc44f8,\n+    0xc21094364dfb5637,\n+    0xf294b943e17a2bc4,\n+    0x979cf3ca6cec5b5b,\n+    0xbd8430bd08277231,\n+    0xece53cec4a314ebe,\n+    0x940f4613ae5ed137,\n+    0xb913179899f68584,\n+    0xe757dd7ec07426e5,\n+    0x9096ea6f3848984f,\n+    0xb4bca50b065abe63,\n+    0xe1ebce4dc7f16dfc,\n+    0x8d3360f09cf6e4bd,\n+    0xb080392cc4349ded,\n+    0xdca04777f541c568,\n+    0x89e42caaf9491b61,\n+    0xac5d37d5b79b6239,\n+    0xd77485cb25823ac7,\n+    0x86a8d39ef77164bd,\n+    0xa8530886b54dbdec,\n+    0xd267caa862a12d67,\n+    0x8380dea93da4bc60,\n+    0xa46116538d0deb78,\n+    0xcd795be870516656,\n+    0x806bd9714632dff6,\n+    0xa086cfcd97bf97f4,\n+    0xc8a883c0fdaf7df0,\n+    0xfad2a4b13d1b5d6c,\n+    0x9cc3a6eec6311a64,\n+    0xc3f490aa77bd60fd,\n+    0xf4f1b4d515acb93c,\n+    0x991711052d8bf3c5,\n+    0xbf5cd54678eef0b7,\n+    0xef340a98172aace5,\n+    0x9580869f0e7aac0f,\n+    0xbae0a846d2195713,\n+    0xe998d258869facd7,\n+    0x91ff83775423cc06,\n+    0xb67f6455292cbf08,\n+    0xe41f3d6a7377eeca,\n+    0x8e938662882af53e,\n+    0xb23867fb2a35b28e,\n+    0xdec681f9f4c31f31,\n+    0x8b3c113c38f9f37f,\n+    0xae0b158b4738705f,\n+    0xd98ddaee19068c76,\n+    0x87f8a8d4cfa417ca,\n+    0xa9f6d30a038d1dbc,\n+    0xd47487cc8470652b,\n+    0x84c8d4dfd2c63f3b,\n+    0xa5fb0a17c777cf0a,\n+    0xcf79cc9db955c2cc,\n+    0x81ac1fe293d599c0,\n+    0xa21727db38cb0030,\n+    0xca9cf1d206fdc03c,\n+    0xfd442e4688bd304b,\n+    0x9e4a9cec15763e2f,\n+    0xc5dd44271ad3cdba,\n+    0xf7549530e188c129,\n+    0x9a94dd3e8cf578ba,\n+    0xc13a148e3032d6e8,\n+    0xf18899b1bc3f8ca2,\n+    0x96f5600f15a7b7e5,\n+    0xbcb2b812db11a5de,\n+    0xebdf661791d60f56,\n+    0x936b9fcebb25c996,\n+    0xb84687c269ef3bfb,\n+    0xe65829b3046b0afa,\n+    0x8ff71a0fe2c2e6dc,\n+    0xb3f4e093db73a093,\n+    0xe0f218b8d25088b8,\n+    0x8c974f7383725573,\n+    0xafbd2350644eead0,\n+    0xdbac6c247d62a584,\n+    0x894bc396ce5da772,\n+    0xab9eb47c81f5114f,\n+    0xd686619ba27255a3,\n+    0x8613fd0145877586,\n+    0xa798fc4196e952e7,\n+    0xd17f3b51fca3a7a1,\n+    0x82ef85133de648c5,\n+    0xa3ab66580d5fdaf6,\n+    0xcc963fee10b7d1b3,\n+    0xffbbcfe994e5c620,\n+    0x9fd561f1fd0f9bd4,\n+    0xc7caba6e7c5382c9,\n+    0xf9bd690a1b68637b,\n+    0x9c1661a651213e2d,\n+    0xc31bfa0fe5698db8,\n+    0xf3e2f893dec3f126,\n+    0x986ddb5c6b3a76b8,\n+    0xbe89523386091466,\n+    0xee2ba6c0678b597f,\n+    0x94db483840b717f0,\n+    0xba121a4650e4ddec,\n+    0xe896a0d7e51e1566,\n+    0x915e2486ef32cd60,\n+    0xb5b5ada8aaff80b8,\n+    0xe3231912d5bf60e6,\n+    0x8df5efabc5979c90,\n+    0xb1736b96b6fd83b4,\n+    0xddd0467c64bce4a1,\n+    0x8aa22c0dbef60ee4,\n+    0xad4ab7112eb3929e,\n+    0xd89d64d57a607745,\n+    0x87625f056c7c4a8b,\n+    0xa93af6c6c79b5d2e,\n+    0xd389b47879823479,\n+    0x843610cb4bf160cc,\n+    0xa54394fe1eedb8ff,\n+    0xce947a3da6a9273e,\n+    0x811ccc668829b887,\n+    0xa163ff802a3426a9,\n+    0xc9bcff6034c13053,\n+    0xfc2c3f3841f17c68,\n+    0x9d9ba7832936edc1,\n+    0xc5029163f384a931,\n+    0xf64335bcf065d37d,\n+    0x99ea0196163fa42e,\n+    0xc06481fb9bcf8d3a,\n+    0xf07da27a82c37088,\n+    0x964e858c91ba2655,\n+    0xbbe226efb628afeb,\n+    0xeadab0aba3b2dbe5,\n+    0x92c8ae6b464fc96f,\n+    0xb77ada0617e3bbcb,\n+    0xe55990879ddcaabe,\n+    0x8f57fa54c2a9eab7,\n+    0xb32df8e9f3546564,\n+    0xdff9772470297ebd,\n+    0x8bfbea76c619ef36,\n+    0xaefae51477a06b04,\n+    0xdab99e59958885c5,\n+    0x88b402f7fd75539b,\n+    0xaae103b5fcd2a882,\n+    0xd59944a37c0752a2,\n+    0x857fcae62d8493a5,\n+    0xa6dfbd9fb8e5b88f,\n+    0xd097ad07a71f26b2,\n+    0x825ecc24c8737830,\n+    0xa2f67f2dfa90563b,\n+    0xcbb41ef979346bca,\n+    0xfea126b7d78186bd,\n+    0x9f24b832e6b0f436,\n+    0xc6ede63fa05d3144,\n+    0xf8a95fcf88747d94,\n+    0x9b69dbe1b548ce7d,\n+    0xc24452da229b021c,\n+    0xf2d56790ab41c2a3,\n+    0x97c560ba6b0919a6,\n+    0xbdb6b8e905cb600f,\n+    0xed246723473e3813,\n+    0x9436c0760c86e30c,\n+    0xb94470938fa89bcf,\n+    0xe7958cb87392c2c3,\n+    0x90bd77f3483bb9ba,\n+    0xb4ecd5f01a4aa828,\n+    0xe2280b6c20dd5232,\n+    0x8d590723948a535f,\n+    0xb0af48ec79ace837,\n+    0xdcdb1b2798182245,\n+    0x8a08f0f8bf0f156b,\n+    0xac8b2d36eed2dac6,\n+    0xd7adf884aa879177,\n+    0x86ccbb52ea94baeb,\n+    0xa87fea27a539e9a5,\n+    0xd29fe4b18e88640f,\n+    0x83a3eeeef9153e89,\n+    0xa48ceaaab75a8e2b,\n+    0xcdb02555653131b6,\n+    0x808e17555f3ebf12,\n+    0xa0b19d2ab70e6ed6,\n+    0xc8de047564d20a8c,\n+    0xfb158592be068d2f,\n+    0x9ced737bb6c4183d,\n+    0xc428d05aa4751e4d,\n+    0xf53304714d9265e0,\n+    0x993fe2c6d07b7fac,\n+    0xbf8fdb78849a5f97,\n+    0xef73d256a5c0f77d,\n+    0x95a8637627989aae,\n+    0xbb127c53b17ec159,\n+    0xe9d71b689dde71b0,\n+    0x9226712162ab070e,\n+    0xb6b00d69bb55c8d1,\n+    0xe45c10c42a2b3b06,\n+    0x8eb98a7a9a5b04e3,\n+    0xb267ed1940f1c61c,\n+    0xdf01e85f912e37a3,\n+    0x8b61313bbabce2c6,\n+    0xae397d8aa96c1b78,\n+    0xd9c7dced53c72256,\n+    0x881cea14545c7575,\n+    0xaa242499697392d3,\n+    0xd4ad2dbfc3d07788,\n+    0x84ec3c97da624ab5,\n+    0xa6274bbdd0fadd62,\n+    0xcfb11ead453994ba,\n+    0x81ceb32c4b43fcf5,\n+    0xa2425ff75e14fc32,\n+    0xcad2f7f5359a3b3e,\n+    0xfd87b5f28300ca0e,\n+    0x9e74d1b791e07e48,\n+    0xc612062576589ddb,\n+    0xf79687aed3eec551,\n+    0x9abe14cd44753b53,\n+    0xc16d9a0095928a27,\n+    0xf1c90080baf72cb1,\n+    0x971da05074da7bef,\n+    0xbce5086492111aeb,\n+    0xec1e4a7db69561a5,\n+    0x9392ee8e921d5d07,\n+    0xb877aa3236a4b449,\n+    0xe69594bec44de15b,\n+    0x901d7cf73ab0acd9,\n+    0xb424dc35095cd80f,\n+    0xe12e13424bb40e13,\n+    0x8cbccc096f5088cc,\n+    0xafebff0bcb24aaff,\n+    0xdbe6fecebdedd5bf,\n+    0x89705f4136b4a597,\n+    0xabcc77118461cefd,\n+    0xd6bf94d5e57a42bc,\n+    0x8637bd05af6c69b6,\n+    0xa7c5ac471b478423,\n+    0xd1b71758e219652c,\n+    0x83126e978d4fdf3b,\n+    0xa3d70a3d70a3d70a,\n+    0xcccccccccccccccd,\n+    0x8000000000000000,\n+    0xa000000000000000,\n+    0xc800000000000000,\n+    0xfa00000000000000,\n+    0x9c40000000000000,\n+    0xc350000000000000,\n+    0xf424000000000000,\n+    0x9896800000000000,\n+    0xbebc200000000000,\n+    0xee6b280000000000,\n+    0x9502f90000000000,\n+    0xba43b74000000000,\n+    0xe8d4a51000000000,\n+    0x9184e72a00000000,\n+    0xb5e620f480000000,\n+    0xe35fa931a0000000,\n+    0x8e1bc9bf04000000,\n+    0xb1a2bc2ec5000000,\n+    0xde0b6b3a76400000,\n+    0x8ac7230489e80000,\n+    0xad78ebc5ac620000,\n+    0xd8d726b7177a8000,\n+    0x878678326eac9000,\n+    0xa968163f0a57b400,\n+    0xd3c21bcecceda100,\n+    0x84595161401484a0,\n+    0xa56fa5b99019a5c8,\n+    0xcecb8f27f4200f3a,\n+    0x813f3978f8940984,\n+    0xa18f07d736b90be5,\n+    0xc9f2c9cd04674edf,\n+    0xfc6f7c4045812296,\n+    0x9dc5ada82b70b59e,\n+    0xc5371912364ce305,\n+    0xf684df56c3e01bc7,\n+    0x9a130b963a6c115c,\n+    0xc097ce7bc90715b3,\n+    0xf0bdc21abb48db20,\n+    0x96769950b50d88f4,\n+    0xbc143fa4e250eb31,\n+    0xeb194f8e1ae525fd,\n+    0x92efd1b8d0cf37be,\n+    0xb7abc627050305ae,\n+    0xe596b7b0c643c719,\n+    0x8f7e32ce7bea5c70,\n+    0xb35dbf821ae4f38c,\n+    0xe0352f62a19e306f,\n+    0x8c213d9da502de45,\n+    0xaf298d050e4395d7,\n+    0xdaf3f04651d47b4c,\n+    0x88d8762bf324cd10,\n+    0xab0e93b6efee0054,\n+    0xd5d238a4abe98068,\n+    0x85a36366eb71f041,\n+    0xa70c3c40a64e6c52,\n+    0xd0cf4b50cfe20766,\n+    0x82818f1281ed44a0,\n+    0xa321f2d7226895c8,\n+    0xcbea6f8ceb02bb3a,\n+    0xfee50b7025c36a08,\n+    0x9f4f2726179a2245,\n+    0xc722f0ef9d80aad6,\n+    0xf8ebad2b84e0d58c,\n+    0x9b934c3b330c8577,\n+    0xc2781f49ffcfa6d5,\n+    0xf316271c7fc3908b,\n+    0x97edd871cfda3a57,\n+    0xbde94e8e43d0c8ec,\n+    0xed63a231d4c4fb27,\n+    0x945e455f24fb1cf9,\n+    0xb975d6b6ee39e437,\n+    0xe7d34c64a9c85d44,\n+    0x90e40fbeea1d3a4b,\n+    0xb51d13aea4a488dd,\n+    0xe264589a4dcdab15,\n+    0x8d7eb76070a08aed,\n+    0xb0de65388cc8ada8,\n+    0xdd15fe86affad912,\n+    0x8a2dbf142dfcc7ab,\n+    0xacb92ed9397bf996,\n+    0xd7e77a8f87daf7fc,\n+    0x86f0ac99b4e8dafd,\n+    0xa8acd7c0222311bd,\n+    0xd2d80db02aabd62c,\n+    0x83c7088e1aab65db,\n+    0xa4b8cab1a1563f52,\n+    0xcde6fd5e09abcf27,\n+    0x80b05e5ac60b6178,\n+    0xa0dc75f1778e39d6,\n+    0xc913936dd571c84c,\n+    0xfb5878494ace3a5f,\n+    0x9d174b2dcec0e47b,\n+    0xc45d1df942711d9a,\n+    0xf5746577930d6501,\n+    0x9968bf6abbe85f20,\n+    0xbfc2ef456ae276e9,\n+    0xefb3ab16c59b14a3,\n+    0x95d04aee3b80ece6,\n+    0xbb445da9ca61281f,\n+    0xea1575143cf97227,\n+    0x924d692ca61be758,\n+    0xb6e0c377cfa2e12e,\n+    0xe498f455c38b997a,\n+    0x8edf98b59a373fec,\n+    0xb2977ee300c50fe7,\n+    0xdf3d5e9bc0f653e1,\n+    0x8b865b215899f46d,\n+    0xae67f1e9aec07188,\n+    0xda01ee641a708dea,\n+    0x884134fe908658b2,\n+    0xaa51823e34a7eedf,\n+    0xd4e5e2cdc1d1ea96,\n+    0x850fadc09923329e,\n+    0xa6539930bf6bff46,\n+    0xcfe87f7cef46ff17,\n+    0x81f14fae158c5f6e,\n+    0xa26da3999aef774a,\n+    0xcb090c8001ab551c,\n+    0xfdcb4fa002162a63,\n+    0x9e9f11c4014dda7e,\n+    0xc646d63501a1511e,\n+    0xf7d88bc24209a565,\n+    0x9ae757596946075f,\n+    0xc1a12d2fc3978937,\n+    0xf209787bb47d6b85,\n+    0x9745eb4d50ce6333,\n+    0xbd176620a501fc00,\n+    0xec5d3fa8ce427b00,\n+    0x93ba47c980e98ce0,\n+    0xb8a8d9bbe123f018,\n+    0xe6d3102ad96cec1e,\n+    0x9043ea1ac7e41393,\n+    0xb454e4a179dd1877,\n+    0xe16a1dc9d8545e95,\n+    0x8ce2529e2734bb1d,\n+    0xb01ae745b101e9e4,\n+    0xdc21a1171d42645d,\n+    0x899504ae72497eba,\n+    0xabfa45da0edbde69,\n+    0xd6f8d7509292d603,\n+    0x865b86925b9bc5c2,\n+    0xa7f26836f282b733,\n+    0xd1ef0244af2364ff,\n+    0x8335616aed761f1f,\n+    0xa402b9c5a8d3a6e7,\n+    0xcd036837130890a1,\n+    0x802221226be55a65,\n+    0xa02aa96b06deb0fe,\n+    0xc83553c5c8965d3d,\n+    0xfa42a8b73abbf48d,\n+    0x9c69a97284b578d8,\n+    0xc38413cf25e2d70e,\n+    0xf46518c2ef5b8cd1,\n+    0x98bf2f79d5993803,\n+    0xbeeefb584aff8604,\n+    0xeeaaba2e5dbf6785,\n+    0x952ab45cfa97a0b3,\n+    0xba756174393d88e0,\n+    0xe912b9d1478ceb17,\n+    0x91abb422ccb812ef,\n+    0xb616a12b7fe617aa,\n+    0xe39c49765fdf9d95,\n+    0x8e41ade9fbebc27d,\n+    0xb1d219647ae6b31c,\n+    0xde469fbd99a05fe3,\n+    0x8aec23d680043bee,\n+    0xada72ccc20054aea,\n+    0xd910f7ff28069da4,\n+    0x87aa9aff79042287,\n+    0xa99541bf57452b28,\n+    0xd3fa922f2d1675f2,\n+    0x847c9b5d7c2e09b7,\n+    0xa59bc234db398c25,\n+    0xcf02b2c21207ef2f,\n+    0x8161afb94b44f57d,\n+    0xa1ba1ba79e1632dc,\n+    0xca28a291859bbf93,\n+    0xfcb2cb35e702af78,\n+    0x9defbf01b061adab,\n+    0xc56baec21c7a1916,\n+    0xf6c69a72a3989f5c,\n+    0x9a3c2087a63f6399,\n+    0xc0cb28a98fcf3c80,\n+    0xf0fdf2d3f3c30b9f,\n+    0x969eb7c47859e744,\n+    0xbc4665b596706115,\n+    0xeb57ff22fc0c795a,\n+    0x9316ff75dd87cbd8,\n+    0xb7dcbf5354e9bece,\n+    0xe5d3ef282a242e82,\n+    0x8fa475791a569d11,\n+    0xb38d92d760ec4455,\n+    0xe070f78d3927556b,\n+    0x8c469ab843b89563,\n+    0xaf58416654a6babb,\n+    0xdb2e51bfe9d0696a,\n+    0x88fcf317f22241e2,\n+    0xab3c2fddeeaad25b,\n+    0xd60b3bd56a5586f2,\n+    0x85c7056562757457,\n+    0xa738c6bebb12d16d,\n+    0xd106f86e69d785c8,\n+    0x82a45b450226b39d,\n+    0xa34d721642b06084,\n+    0xcc20ce9bd35c78a5,\n+    0xff290242c83396ce,\n+    0x9f79a169bd203e41,\n+    0xc75809c42c684dd1,\n+    0xf92e0c3537826146,\n+    0x9bbcc7a142b17ccc,\n+    0xc2abf989935ddbfe,\n+    0xf356f7ebf83552fe,\n+    0x98165af37b2153df,\n+    0xbe1bf1b059e9a8d6,\n+    0xeda2ee1c7064130c,\n+    0x9485d4d1c63e8be8,\n+    0xb9a74a0637ce2ee1,\n+    0xe8111c87c5c1ba9a,\n+    0x910ab1d4db9914a0,\n+    0xb54d5e4a127f59c8,\n+    0xe2a0b5dc971f303a,\n+    0x8da471a9de737e24,\n+    0xb10d8e1456105dad,\n+    0xdd50f1996b947519,\n+    0x8a5296ffe33cc930,\n+    0xace73cbfdc0bfb7b,\n+    0xd8210befd30efa5a,\n+    0x8714a775e3e95c78,\n+    0xa8d9d1535ce3b396,\n+    0xd31045a8341ca07c,\n+    0x83ea2b892091e44e,\n+    0xa4e4b66b68b65d61,\n+    0xce1de40642e3f4b9,\n+    0x80d2ae83e9ce78f4,\n+    0xa1075a24e4421731,\n+    0xc94930ae1d529cfd,\n+    0xfb9b7cd9a4a7443c,\n+    0x9d412e0806e88aa6,\n+    0xc491798a08a2ad4f,\n+    0xf5b5d7ec8acb58a3,\n+    0x9991a6f3d6bf1766,\n+    0xbff610b0cc6edd3f,\n+    0xeff394dcff8a948f,\n+    0x95f83d0a1fb69cd9,\n+    0xbb764c4ca7a44410,\n+    0xea53df5fd18d5514,\n+    0x92746b9be2f8552c,\n+    0xb7118682dbb66a77,\n+    0xe4d5e82392a40515,\n+    0x8f05b1163ba6832d,\n+    0xb2c71d5bca9023f8,\n+    0xdf78e4b2bd342cf7,\n+    0x8bab8eefb6409c1a,\n+    0xae9672aba3d0c321,\n+    0xda3c0f568cc4f3e9,\n+    0x8865899617fb1871,\n+    0xaa7eebfb9df9de8e,\n+    0xd51ea6fa85785631,\n+    0x8533285c936b35df,\n+    0xa67ff273b8460357,\n+    0xd01fef10a657842c,\n+    0x8213f56a67f6b29c,\n+    0xa298f2c501f45f43,\n+    0xcb3f2f7642717713,\n+    0xfe0efb53d30dd4d8,\n+    0x9ec95d1463e8a507,\n+    0xc67bb4597ce2ce49,\n+    0xf81aa16fdc1b81db,\n+    0x9b10a4e5e9913129,\n+    0xc1d4ce1f63f57d73,\n+    0xf24a01a73cf2dcd0,\n+    0x976e41088617ca02,\n+    0xbd49d14aa79dbc82,\n+    0xec9c459d51852ba3,\n+    0x93e1ab8252f33b46,\n+    0xb8da1662e7b00a17,\n+    0xe7109bfba19c0c9d,\n+    0x906a617d450187e2,\n+    0xb484f9dc9641e9db,\n+    0xe1a63853bbd26451,\n+    0x8d07e33455637eb3,\n+    0xb049dc016abc5e60,\n+    0xdc5c5301c56b75f7,\n+    0x89b9b3e11b6329bb,\n+    0xac2820d9623bf429,\n+    0xd732290fbacaf134,\n+    0x867f59a9d4bed6c0,\n+    0xa81f301449ee8c70,\n+    0xd226fc195c6a2f8c,\n+    0x83585d8fd9c25db8,\n+    0xa42e74f3d032f526,\n+    0xcd3a1230c43fb26f,\n+    0x80444b5e7aa7cf85,\n+    0xa0555e361951c367,\n+    0xc86ab5c39fa63441,\n+    0xfa856334878fc151,\n+    0x9c935e00d4b9d8d2,\n+    0xc3b8358109e84f07,\n+    0xf4a642e14c6262c9,\n+    0x98e7e9cccfbd7dbe,\n+    0xbf21e44003acdd2d,\n+    0xeeea5d5004981478,\n+    0x95527a5202df0ccb,\n+    0xbaa718e68396cffe,\n+    0xe950df20247c83fd,\n+    0x91d28b7416cdd27e,\n+], [\n+    -1077,\n+    -1073,\n+    -1070,\n+    -1067,\n+    -1063,\n+    -1060,\n+    -1057,\n+    -1053,\n+    -1050,\n+    -1047,\n+    -1043,\n+    -1040,\n+    -1037,\n+    -1034,\n+    -1030,\n+    -1027,\n+    -1024,\n+    -1020,\n+    -1017,\n+    -1014,\n+    -1010,\n+    -1007,\n+    -1004,\n+    -1000,\n+    -997,\n+    -994,\n+    -990,\n+    -987,\n+    -984,\n+    -980,\n+    -977,\n+    -974,\n+    -970,\n+    -967,\n+    -964,\n+    -960,\n+    -957,\n+    -954,\n+    -950,\n+    -947,\n+    -944,\n+    -940,\n+    -937,\n+    -934,\n+    -931,\n+    -927,\n+    -924,\n+    -921,\n+    -917,\n+    -914,\n+    -911,\n+    -907,\n+    -904,\n+    -901,\n+    -897,\n+    -894,\n+    -891,\n+    -887,\n+    -884,\n+    -881,\n+    -877,\n+    -874,\n+    -871,\n+    -867,\n+    -864,\n+    -861,\n+    -857,\n+    -854,\n+    -851,\n+    -847,\n+    -844,\n+    -841,\n+    -838,\n+    -834,\n+    -831,\n+    -828,\n+    -824,\n+    -821,\n+    -818,\n+    -814,\n+    -811,\n+    -808,\n+    -804,\n+    -801,\n+    -798,\n+    -794,\n+    -791,\n+    -788,\n+    -784,\n+    -781,\n+    -778,\n+    -774,\n+    -771,\n+    -768,\n+    -764,\n+    -761,\n+    -758,\n+    -754,\n+    -751,\n+    -748,\n+    -744,\n+    -741,\n+    -738,\n+    -735,\n+    -731,\n+    -728,\n+    -725,\n+    -721,\n+    -718,\n+    -715,\n+    -711,\n+    -708,\n+    -705,\n+    -701,\n+    -698,\n+    -695,\n+    -691,\n+    -688,\n+    -685,\n+    -681,\n+    -678,\n+    -675,\n+    -671,\n+    -668,\n+    -665,\n+    -661,\n+    -658,\n+    -655,\n+    -651,\n+    -648,\n+    -645,\n+    -642,\n+    -638,\n+    -635,\n+    -632,\n+    -628,\n+    -625,\n+    -622,\n+    -618,\n+    -615,\n+    -612,\n+    -608,\n+    -605,\n+    -602,\n+    -598,\n+    -595,\n+    -592,\n+    -588,\n+    -585,\n+    -582,\n+    -578,\n+    -575,\n+    -572,\n+    -568,\n+    -565,\n+    -562,\n+    -558,\n+    -555,\n+    -552,\n+    -549,\n+    -545,\n+    -542,\n+    -539,\n+    -535,\n+    -532,\n+    -529,\n+    -525,\n+    -522,\n+    -519,\n+    -515,\n+    -512,\n+    -509,\n+    -505,\n+    -502,\n+    -499,\n+    -495,\n+    -492,\n+    -489,\n+    -485,\n+    -482,\n+    -479,\n+    -475,\n+    -472,\n+    -469,\n+    -465,\n+    -462,\n+    -459,\n+    -455,\n+    -452,\n+    -449,\n+    -446,\n+    -442,\n+    -439,\n+    -436,\n+    -432,\n+    -429,\n+    -426,\n+    -422,\n+    -419,\n+    -416,\n+    -412,\n+    -409,\n+    -406,\n+    -402,\n+    -399,\n+    -396,\n+    -392,\n+    -389,\n+    -386,\n+    -382,\n+    -379,\n+    -376,\n+    -372,\n+    -369,\n+    -366,\n+    -362,\n+    -359,\n+    -356,\n+    -353,\n+    -349,\n+    -346,\n+    -343,\n+    -339,\n+    -336,\n+    -333,\n+    -329,\n+    -326,\n+    -323,\n+    -319,\n+    -316,\n+    -313,\n+    -309,\n+    -306,\n+    -303,\n+    -299,\n+    -296,\n+    -293,\n+    -289,\n+    -286,\n+    -283,\n+    -279,\n+    -276,\n+    -273,\n+    -269,\n+    -266,\n+    -263,\n+    -259,\n+    -256,\n+    -253,\n+    -250,\n+    -246,\n+    -243,\n+    -240,\n+    -236,\n+    -233,\n+    -230,\n+    -226,\n+    -223,\n+    -220,\n+    -216,\n+    -213,\n+    -210,\n+    -206,\n+    -203,\n+    -200,\n+    -196,\n+    -193,\n+    -190,\n+    -186,\n+    -183,\n+    -180,\n+    -176,\n+    -173,\n+    -170,\n+    -166,\n+    -163,\n+    -160,\n+    -157,\n+    -153,\n+    -150,\n+    -147,\n+    -143,\n+    -140,\n+    -137,\n+    -133,\n+    -130,\n+    -127,\n+    -123,\n+    -120,\n+    -117,\n+    -113,\n+    -110,\n+    -107,\n+    -103,\n+    -100,\n+    -97,\n+    -93,\n+    -90,\n+    -87,\n+    -83,\n+    -80,\n+    -77,\n+    -73,\n+    -70,\n+    -67,\n+    -63,\n+    -60,\n+    -57,\n+    -54,\n+    -50,\n+    -47,\n+    -44,\n+    -40,\n+    -37,\n+    -34,\n+    -30,\n+    -27,\n+    -24,\n+    -20,\n+    -17,\n+    -14,\n+    -10,\n+    -7,\n+    -4,\n+    0,\n+    3,\n+    6,\n+    10,\n+    13,\n+    16,\n+    20,\n+    23,\n+    26,\n+    30,\n+    33,\n+    36,\n+    39,\n+    43,\n+    46,\n+    49,\n+    53,\n+    56,\n+    59,\n+    63,\n+    66,\n+    69,\n+    73,\n+    76,\n+    79,\n+    83,\n+    86,\n+    89,\n+    93,\n+    96,\n+    99,\n+    103,\n+    106,\n+    109,\n+    113,\n+    116,\n+    119,\n+    123,\n+    126,\n+    129,\n+    132,\n+    136,\n+    139,\n+    142,\n+    146,\n+    149,\n+    152,\n+    156,\n+    159,\n+    162,\n+    166,\n+    169,\n+    172,\n+    176,\n+    179,\n+    182,\n+    186,\n+    189,\n+    192,\n+    196,\n+    199,\n+    202,\n+    206,\n+    209,\n+    212,\n+    216,\n+    219,\n+    222,\n+    226,\n+    229,\n+    232,\n+    235,\n+    239,\n+    242,\n+    245,\n+    249,\n+    252,\n+    255,\n+    259,\n+    262,\n+    265,\n+    269,\n+    272,\n+    275,\n+    279,\n+    282,\n+    285,\n+    289,\n+    292,\n+    295,\n+    299,\n+    302,\n+    305,\n+    309,\n+    312,\n+    315,\n+    319,\n+    322,\n+    325,\n+    328,\n+    332,\n+    335,\n+    338,\n+    342,\n+    345,\n+    348,\n+    352,\n+    355,\n+    358,\n+    362,\n+    365,\n+    368,\n+    372,\n+    375,\n+    378,\n+    382,\n+    385,\n+    388,\n+    392,\n+    395,\n+    398,\n+    402,\n+    405,\n+    408,\n+    412,\n+    415,\n+    418,\n+    422,\n+    425,\n+    428,\n+    431,\n+    435,\n+    438,\n+    441,\n+    445,\n+    448,\n+    451,\n+    455,\n+    458,\n+    461,\n+    465,\n+    468,\n+    471,\n+    475,\n+    478,\n+    481,\n+    485,\n+    488,\n+    491,\n+    495,\n+    498,\n+    501,\n+    505,\n+    508,\n+    511,\n+    515,\n+    518,\n+    521,\n+    524,\n+    528,\n+    531,\n+    534,\n+    538,\n+    541,\n+    544,\n+    548,\n+    551,\n+    554,\n+    558,\n+    561,\n+    564,\n+    568,\n+    571,\n+    574,\n+    578,\n+    581,\n+    584,\n+    588,\n+    591,\n+    594,\n+    598,\n+    601,\n+    604,\n+    608,\n+    611,\n+    614,\n+    617,\n+    621,\n+    624,\n+    627,\n+    631,\n+    634,\n+    637,\n+    641,\n+    644,\n+    647,\n+    651,\n+    654,\n+    657,\n+    661,\n+    664,\n+    667,\n+    671,\n+    674,\n+    677,\n+    681,\n+    684,\n+    687,\n+    691,\n+    694,\n+    697,\n+    701,\n+    704,\n+    707,\n+    711,\n+    714,\n+    717,\n+    720,\n+    724,\n+    727,\n+    730,\n+    734,\n+    737,\n+    740,\n+    744,\n+    747,\n+    750,\n+    754,\n+    757,\n+    760,\n+    764,\n+    767,\n+    770,\n+    774,\n+    777,\n+    780,\n+    784,\n+    787,\n+    790,\n+    794,\n+    797,\n+    800,\n+    804,\n+    807,\n+    810,\n+    813,\n+    817,\n+    820,\n+    823,\n+    827,\n+    830,\n+    833,\n+    837,\n+    840,\n+    843,\n+    847,\n+    850,\n+    853,\n+    857,\n+    860,\n+    863,\n+    867,\n+    870,\n+    873,\n+    877,\n+    880,\n+    883,\n+    887,\n+    890,\n+    893,\n+    897,\n+    900,\n+    903,\n+    907,\n+    910,\n+    913,\n+    916,\n+    920,\n+    923,\n+    926,\n+    930,\n+    933,\n+    936,\n+    940,\n+    943,\n+    946,\n+    950,\n+]);"}, {"sha": "ee1f6ffdd0aefba6314fc7f7d45ab682db045b7d", "filename": "src/libcore/num/flt2dec/bignum.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs?ref=ba792a4baa856d83c3001afa181db91c5b4c9732", "patch": "@@ -171,20 +171,19 @@ macro_rules! define_bignum {\n             pub fn bit_length(&self) -> usize {\n                 use mem;\n \n-                let digitbits = mem::size_of::<$ty>()* 8;\n                 // Skip over the most significant digits which are zero.\n-                let nonzero = match self.digits().iter().rposition(|&x| x != 0) {\n-                    Some(n) => {\n-                        let end = self.size - n;\n-                        &self.digits()[..end]\n-                    }\n-                    None => {\n-                        // There are no non-zero digits, i.e. the number is zero.\n-                        return 0;\n-                    }\n-                };\n+                let digits = self.digits();\n+                let zeros = digits.iter().rev().take_while(|&&x| x == 0).count();\n+                let end = digits.len() - zeros;\n+                let nonzero = &digits[..end];\n+\n+                if nonzero.is_empty() {\n+                    // There are no non-zero digits, i.e. the number is zero.\n+                    return 0;\n+                }\n                 // This could be optimized with leading_zeros() and bit shifts, but that's\n                 // probably not worth the hassle.\n+                let digitbits = mem::size_of::<$ty>()* 8;\n                 let mut i = nonzero.len() * digitbits - 1;\n                 while self.get_bit(i) == 0 {\n                     i -= 1;"}, {"sha": "19ca83b6ea40ae36e33dc7f134985dd09e0770fb", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=ba792a4baa856d83c3001afa181db91c5b4c9732", "patch": "@@ -44,6 +44,7 @@ pub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n \n pub mod wrapping;\n pub mod flt2dec;\n+pub mod dec2flt;\n \n /// Types that have a \"zero\" value.\n ///\n@@ -1364,7 +1365,7 @@ pub trait Float {\n }\n \n macro_rules! from_str_float_impl {\n-    ($t:ty) => {\n+    ($t:ty, $func:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl FromStr for $t {\n             type Err = ParseFloatError;\n@@ -1397,13 +1398,13 @@ macro_rules! from_str_float_impl {\n             #[inline]\n             #[allow(deprecated)]\n             fn from_str(src: &str) -> Result<Self, ParseFloatError> {\n-                Self::from_str_radix(src, 10)\n+                dec2flt::$func(src)\n             }\n         }\n     }\n }\n-from_str_float_impl!(f32);\n-from_str_float_impl!(f64);\n+from_str_float_impl!(f32, to_f32);\n+from_str_float_impl!(f64, to_f64);\n \n macro_rules! from_str_radix_int_impl {\n     ($($t:ty)*) => {$("}, {"sha": "4262be83361a3f68019e39e4bd90baf5cd5f3158", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=ba792a4baa856d83c3001afa181db91c5b4c9732", "patch": "@@ -19,6 +19,7 @@\n #![feature(float_extras)]\n #![feature(float_from_str_radix)]\n #![feature(flt2dec)]\n+#![feature(dec2flt)]\n #![feature(fmt_radix)]\n #![feature(hash_default)]\n #![feature(hasher_write)]"}, {"sha": "bd8cfc74f0c63a8e958ec652df58d9eb142c62b4", "filename": "src/libcoretest/num/dec2flt/mod.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcoretest%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcoretest%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fdec2flt%2Fmod.rs?ref=ba792a4baa856d83c3001afa181db91c5b4c9732", "patch": "@@ -0,0 +1,174 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(overflowing_literals)]\n+\n+use std::{i64, f32, f64};\n+use test;\n+use core::num::dec2flt::{to_f32, to_f64};\n+\n+mod parse;\n+mod rawfp;\n+\n+// Take an float literal, turn it into a string in various ways (that are all trusted\n+// to be correct) and see if those strings are parsed back to the value of the literal.\n+// Requires a *polymorphic literal*, i.e. one that can serve as f64 as well as f32.\n+macro_rules! test_literal {\n+    ($x: expr) => ({\n+        let x32: f32 = $x;\n+        let x64: f64 = $x;\n+        let inputs = &[stringify!($x).into(), format!(\"{:?}\", x64), format!(\"{:e}\", x64)];\n+        for input in inputs {\n+            if input != \"inf\" {\n+                assert_eq!(to_f64(input), Ok(x64));\n+                assert_eq!(to_f32(input), Ok(x32));\n+                let neg_input = &format!(\"-{}\", input);\n+                assert_eq!(to_f64(neg_input), Ok(-x64));\n+                assert_eq!(to_f32(neg_input), Ok(-x32));\n+            }\n+        }\n+    })\n+}\n+\n+#[test]\n+fn ordinary() {\n+    test_literal!(1.0);\n+    test_literal!(3e-5);\n+    test_literal!(0.1);\n+    test_literal!(12345.);\n+    test_literal!(0.9999999);\n+    test_literal!(2.2250738585072014e-308);\n+}\n+\n+#[test]\n+fn special_code_paths() {\n+    test_literal!(36893488147419103229.0); // 2^65 - 3, triggers half-to-even with even significand\n+    test_literal!(101e-33); // Triggers the tricky underflow case in AlgorithmM (for f32)\n+    test_literal!(1e23); // Triggers AlgorithmR\n+    test_literal!(2075e23); // Triggers another path through AlgorithmR\n+    test_literal!(8713e-23); // ... and yet another.\n+}\n+\n+#[test]\n+fn large() {\n+    test_literal!(1e300);\n+    test_literal!(123456789.34567e250);\n+    test_literal!(943794359898089732078308743689303290943794359843568973207830874368930329.);\n+}\n+\n+#[test]\n+fn subnormals() {\n+    test_literal!(5e-324);\n+    test_literal!(91e-324);\n+    test_literal!(1e-322);\n+    test_literal!(13245643e-320);\n+    test_literal!(2.22507385851e-308);\n+    test_literal!(2.1e-308);\n+    test_literal!(4.9406564584124654e-324);\n+}\n+\n+#[test]\n+fn infinity() {\n+    test_literal!(1e400);\n+    test_literal!(1e309);\n+    test_literal!(2e308);\n+    test_literal!(1.7976931348624e308);\n+}\n+\n+#[test]\n+fn zero() {\n+    test_literal!(0.0);\n+    test_literal!(1e-325);\n+    test_literal!(1e-326);\n+    test_literal!(1e-500);\n+}\n+\n+#[test]\n+fn lonely_dot() {\n+    assert_eq!(to_f64(\".\"), Ok(0.0));\n+}\n+\n+#[test]\n+fn nan() {\n+    assert!(to_f64(\"NaN\").unwrap().is_nan());\n+    assert!(to_f32(\"NaN\").unwrap().is_nan());\n+}\n+\n+#[test]\n+fn inf() {\n+    assert_eq!(to_f64(\"inf\"), Ok(f64::INFINITY));\n+    assert_eq!(to_f64(\"-inf\"), Ok(f64::NEG_INFINITY));\n+    assert_eq!(to_f32(\"inf\"), Ok(f32::INFINITY));\n+    assert_eq!(to_f32(\"-inf\"), Ok(f32::NEG_INFINITY));\n+}\n+\n+#[test]\n+fn massive_exponent() {\n+    let max = i64::MAX;\n+    assert_eq!(to_f64(&format!(\"1e{}000\", max)), Ok(f64::INFINITY));\n+    assert_eq!(to_f64(&format!(\"1e-{}000\", max)), Ok(0.0));\n+    assert_eq!(to_f64(&format!(\"1e{}000\", max)), Ok(f64::INFINITY));\n+}\n+\n+#[bench]\n+fn bench_0(b: &mut test::Bencher) {\n+    b.iter(|| to_f64(\"0.0\"));\n+}\n+\n+#[bench]\n+fn bench_42(b: &mut test::Bencher) {\n+    b.iter(|| to_f64(\"42\"));\n+}\n+\n+#[bench]\n+fn bench_huge_int(b: &mut test::Bencher) {\n+    // 2^128 - 1\n+    b.iter(|| to_f64(\"170141183460469231731687303715884105727\"));\n+}\n+\n+#[bench]\n+fn bench_short_decimal(b: &mut test::Bencher) {\n+    b.iter(|| to_f64(\"1234.5678\"));\n+}\n+\n+#[bench]\n+fn bench_pi_long(b: &mut test::Bencher) {\n+    b.iter(|| to_f64(\"3.14159265358979323846264338327950288\"));\n+}\n+\n+#[bench]\n+fn bench_pi_short(b: &mut test::Bencher) {\n+    b.iter(|| to_f64(\"3.141592653589793\"))\n+}\n+\n+#[bench]\n+fn bench_1e150(b: &mut test::Bencher) {\n+    b.iter(|| to_f64(\"1e150\"));\n+}\n+\n+#[bench]\n+fn bench_long_decimal_and_exp(b: &mut test::Bencher) {\n+    b.iter(|| to_f64(\"727501488517303786137132964064381141071e-123\"));\n+}\n+\n+#[bench]\n+fn bench_min_subnormal(b: &mut test::Bencher) {\n+    b.iter(|| to_f64(\"5e-324\"));\n+}\n+\n+#[bench]\n+fn bench_min_normal(b: &mut test::Bencher) {\n+    b.iter(|| to_f64(\"2.2250738585072014e-308\"));\n+}\n+\n+#[bench]\n+fn bench_max(b: &mut test::Bencher) {\n+    b.iter(|| to_f64(\"1.7976931348623157e308\"));\n+}"}, {"sha": "09acf2bc517b086decd12413e4399c84e6cce8a9", "filename": "src/libcoretest/num/dec2flt/parse.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcoretest%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcoretest%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fdec2flt%2Fparse.rs?ref=ba792a4baa856d83c3001afa181db91c5b4c9732", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::iter;\n+use core::num::dec2flt::parse::{Decimal, parse_decimal};\n+use core::num::dec2flt::parse::ParseResult::{Valid, Invalid};\n+\n+#[test]\n+fn missing_pieces() {\n+    let permutations = &[\".e\", \"1e\", \"e4\", \"e\", \".12e\", \"321.e\", \"32.12e+\", \"12.32e-\"];\n+    for &s in permutations {\n+        assert_eq!(parse_decimal(s), Invalid);\n+    }\n+}\n+\n+#[test]\n+fn invalid_chars() {\n+    let invalid = \"r,?<j\";\n+    let valid_strings = &[\"123\", \"666.\", \".1\", \"5e1\", \"7e-3\", \"0.0e+1\"];\n+    for c in invalid.chars() {\n+        for s in valid_strings {\n+            for i in 0..s.len() {\n+                let mut input = String::new();\n+                input.push_str(s);\n+                input.insert(i, c);\n+                assert!(parse_decimal(&input) == Invalid, \"did not reject invalid {:?}\", input);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn valid() {\n+    assert_eq!(parse_decimal(\"123.456e789\"), Valid(Decimal::new(b\"123\", b\"456\", 789)));\n+    assert_eq!(parse_decimal(\"123.456e+789\"), Valid(Decimal::new(b\"123\", b\"456\", 789)));\n+    assert_eq!(parse_decimal(\"123.456e-789\"), Valid(Decimal::new(b\"123\", b\"456\", -789)));\n+    assert_eq!(parse_decimal(\".050\"), Valid(Decimal::new(b\"\", b\"050\", 0)));\n+    assert_eq!(parse_decimal(\"999\"), Valid(Decimal::new(b\"999\", b\"\", 0)));\n+    assert_eq!(parse_decimal(\"1.e300\"), Valid(Decimal::new(b\"1\", b\"\", 300)));\n+    assert_eq!(parse_decimal(\".1e300\"), Valid(Decimal::new(b\"\", b\"1\", 300)));\n+    assert_eq!(parse_decimal(\"101e-33\"), Valid(Decimal::new(b\"101\", b\"\", -33)));\n+    let zeros: String = iter::repeat('0').take(25).collect();\n+    let s = format!(\"1.5e{}\", zeros);\n+    assert_eq!(parse_decimal(&s), Valid(Decimal::new(b\"1\", b\"5\", 0)));\n+}"}, {"sha": "a40d360f1054a0ef17b6180e78df2cf3968e3dea", "filename": "src/libcoretest/num/dec2flt/rawfp.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcoretest%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcoretest%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fdec2flt%2Frawfp.rs?ref=ba792a4baa856d83c3001afa181db91c5b4c9732", "patch": "@@ -0,0 +1,139 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::f64;\n+use core::num::flt2dec::strategy::grisu::Fp;\n+use core::num::dec2flt::rawfp::{fp_to_float, prev_float, next_float, round_normal};\n+\n+#[test]\n+fn fp_to_float_half_to_even() {\n+    fn is_normalized(sig: u64) -> bool {\n+            // intentionally written without {min,max}_sig() as a sanity check\n+            sig >> 52 == 1 && sig >> 53 == 0\n+    }\n+\n+    fn conv(sig: u64) -> u64 {\n+        // The significands are perfectly in range, so the exponent should not matter\n+        let (m1, e1, _) = fp_to_float::<f64>(Fp { f: sig, e: 0 }).integer_decode();\n+        assert_eq!(e1, 0 + 64 - 53);\n+        let (m2, e2, _) = fp_to_float::<f64>(Fp { f: sig, e: 55 }).integer_decode();\n+        assert_eq!(e2, 55 + 64 - 53);\n+        assert_eq!(m2, m1);\n+        let (m3, e3, _) = fp_to_float::<f64>(Fp { f: sig, e: -78 }).integer_decode();\n+        assert_eq!(e3, -78 + 64 - 53);\n+        assert_eq!(m3, m2);\n+        m3\n+    }\n+\n+    let odd = 0x1F_EDCB_A012_345F;\n+    let even = odd - 1;\n+    assert!(is_normalized(odd));\n+    assert!(is_normalized(even));\n+    assert_eq!(conv(odd << 11), odd);\n+    assert_eq!(conv(even << 11), even);\n+    assert_eq!(conv(odd << 11 | 1 << 10), odd + 1);\n+    assert_eq!(conv(even << 11 | 1 << 10), even);\n+    assert_eq!(conv(even << 11 | 1 << 10 | 1), even + 1);\n+    assert_eq!(conv(odd << 11 | 1 << 9), odd);\n+    assert_eq!(conv(even << 11 | 1 << 9), even);\n+    assert_eq!(conv(odd << 11 | 0x7FF), odd + 1);\n+    assert_eq!(conv(even << 11 | 0x7FF), even + 1);\n+    assert_eq!(conv(odd << 11 | 0x3FF), odd);\n+    assert_eq!(conv(even << 11 | 0x3FF), even);\n+}\n+\n+#[test]\n+fn integers_to_f64() {\n+    assert_eq!(fp_to_float::<f64>(Fp { f: 1, e: 0 }), 1.0);\n+    assert_eq!(fp_to_float::<f64>(Fp { f: 42, e: 7 }), (42 << 7) as f64);\n+    assert_eq!(fp_to_float::<f64>(Fp { f: 1 << 20, e: 30 }), (1u64 << 50) as f64);\n+    assert_eq!(fp_to_float::<f64>(Fp { f: 4, e: -3 }), 0.5);\n+}\n+\n+const SOME_FLOATS: [f64; 9] =\n+    [0.1f64, 33.568, 42.1e-5, 777.0e9, 1.1111, 0.347997,\n+     9843579834.35892, 12456.0e-150, 54389573.0e-150];\n+\n+\n+#[test]\n+fn human_f64_roundtrip() {\n+    for &x in &SOME_FLOATS {\n+        let (f, e, _) = x.integer_decode();\n+        let fp = Fp { f: f, e: e};\n+        assert_eq!(fp_to_float::<f64>(fp), x);\n+    }\n+}\n+\n+#[test]\n+fn rounding_overflow() {\n+    let x = Fp { f: 0xFF_FF_FF_FF_FF_FF_FF_00u64, e: 42 };\n+    let rounded = round_normal::<f64>(x);\n+    let adjusted_k = x.e + 64 - 53;\n+    assert_eq!(rounded.sig, 1 << 52);\n+    assert_eq!(rounded.k, adjusted_k + 1);\n+}\n+\n+#[test]\n+fn prev_float_monotonic() {\n+    let mut x = 1.0;\n+    for _ in 0..100 {\n+        let x1 = prev_float(x);\n+        assert!(x1 < x);\n+        assert!(x - x1 < 1e-15);\n+        x = x1;\n+    }\n+}\n+\n+const MIN_SUBNORMAL: f64 = 5e-324;\n+\n+#[test]\n+fn next_float_zero() {\n+    let tiny = next_float(0.0);\n+    assert_eq!(tiny, MIN_SUBNORMAL);\n+    assert!(tiny != 0.0);\n+}\n+\n+#[test]\n+fn next_float_subnormal() {\n+    let second = next_float(MIN_SUBNORMAL);\n+    // For subnormals, MIN_SUBNORMAL is the ULP\n+    assert!(second != MIN_SUBNORMAL);\n+    assert!(second > 0.0);\n+    assert_eq!(second - MIN_SUBNORMAL, MIN_SUBNORMAL);\n+}\n+\n+#[test]\n+fn next_float_inf() {\n+    assert_eq!(next_float(f64::MAX), f64::INFINITY);\n+    assert_eq!(next_float(f64::INFINITY), f64::INFINITY);\n+}\n+\n+#[test]\n+fn next_prev_identity() {\n+    for &x in &SOME_FLOATS {\n+        assert_eq!(prev_float(next_float(x)), x);\n+        assert_eq!(prev_float(prev_float(next_float(next_float(x)))), x);\n+        assert_eq!(next_float(prev_float(x)), x);\n+        assert_eq!(next_float(next_float(prev_float(prev_float(x)))), x);\n+    }\n+}\n+\n+#[test]\n+fn next_float_monotonic() {\n+    let mut x = 0.49999999999999;\n+    assert!(x < 0.5);\n+    for _ in 0..200 {\n+        let x1 = next_float(x);\n+        assert!(x1 > x);\n+        assert!(x1 - x < 1e-15, \"next_float_monotonic: delta = {:?}\", x1 - x);\n+        x = x1;\n+    }\n+    assert!(x > 0.5);\n+}"}, {"sha": "9f9d2a4ca1659b14d26930c0234ba577656b8285", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba792a4baa856d83c3001afa181db91c5b4c9732/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=ba792a4baa856d83c3001afa181db91c5b4c9732", "patch": "@@ -30,6 +30,7 @@ mod u32;\n mod u64;\n \n mod flt2dec;\n+mod dec2flt;\n \n /// Helper function for testing numeric operations\n pub fn test_num<T>(ten: T, two: T) where"}]}