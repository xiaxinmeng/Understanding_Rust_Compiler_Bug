{"sha": "0157cc977fd71297ce73e2f249321f5ba2555d42", "node_id": "C_kwDOAAsO6NoAKDAxNTdjYzk3N2ZkNzEyOTdjZTczZTJmMjQ5MzIxZjViYTI1NTVkNDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-07T14:22:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-07T14:22:16Z"}, "message": "Auto merge of #89534 - camsteffen:diag-name, r=oli-obk\n\nIntroduce `tcx.get_diagnostic_name`\n\nIntroduces a \"reverse lookup\" for diagnostic items. This is mainly intended for `@rust-lang/clippy` which often does a long series of `is_diagnostic_item` calls for the same `DefId`.\n\nr? `@oli-obk`", "tree": {"sha": "be8947b6d6d893a11a676a363f1374248d34e1b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be8947b6d6d893a11a676a363f1374248d34e1b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0157cc977fd71297ce73e2f249321f5ba2555d42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0157cc977fd71297ce73e2f249321f5ba2555d42", "html_url": "https://github.com/rust-lang/rust/commit/0157cc977fd71297ce73e2f249321f5ba2555d42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0157cc977fd71297ce73e2f249321f5ba2555d42/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "680ff86391f19e12b485293f01372036e85ba87c", "url": "https://api.github.com/repos/rust-lang/rust/commits/680ff86391f19e12b485293f01372036e85ba87c", "html_url": "https://github.com/rust-lang/rust/commit/680ff86391f19e12b485293f01372036e85ba87c"}, {"sha": "a8d8bfd3763cfde5a27dc7babd6691f1b3d65840", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d8bfd3763cfde5a27dc7babd6691f1b3d65840", "html_url": "https://github.com/rust-lang/rust/commit/a8d8bfd3763cfde5a27dc7babd6691f1b3d65840"}], "stats": {"total": 288, "additions": 142, "deletions": 146}, "files": [{"sha": "243014b00270321f0f2a87d9c6ced1653aa91abd", "filename": "compiler/rustc_hir/src/diagnostic_items.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_hir%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_hir%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdiagnostic_items.rs?ref=0157cc977fd71297ce73e2f249321f5ba2555d42", "patch": "@@ -0,0 +1,17 @@\n+use crate::def_id::DefId;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_span::Symbol;\n+\n+#[derive(Debug, Default)]\n+pub struct DiagnosticItems {\n+    pub id_to_name: FxHashMap<DefId, Symbol>,\n+    pub name_to_id: FxHashMap<Symbol, DefId>,\n+}\n+\n+impl<CTX: crate::HashStableContext> HashStable<CTX> for DiagnosticItems {\n+    #[inline]\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        self.name_to_id.hash_stable(ctx, hasher);\n+    }\n+}"}, {"sha": "f5ea044e248652fb2dea7a1bdabab5330558d34f", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=0157cc977fd71297ce73e2f249321f5ba2555d42", "patch": "@@ -18,6 +18,7 @@ mod arena;\n pub mod def;\n pub mod def_path_hash_map;\n pub mod definitions;\n+pub mod diagnostic_items;\n pub use rustc_span::def_id;\n mod hir;\n pub mod hir_id;"}, {"sha": "57c1c8f3ecb5c28f033a29389fdf00edd74291f7", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=0157cc977fd71297ce73e2f249321f5ba2555d42", "patch": "@@ -2478,14 +2478,11 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                 // Find calls to `mem::{uninitialized,zeroed}` methods.\n                 if let hir::ExprKind::Path(ref qpath) = path_expr.kind {\n                     let def_id = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n-\n-                    if cx.tcx.is_diagnostic_item(sym::mem_zeroed, def_id) {\n-                        return Some(InitKind::Zeroed);\n-                    } else if cx.tcx.is_diagnostic_item(sym::mem_uninitialized, def_id) {\n-                        return Some(InitKind::Uninit);\n-                    } else if cx.tcx.is_diagnostic_item(sym::transmute, def_id) && is_zero(&args[0])\n-                    {\n-                        return Some(InitKind::Zeroed);\n+                    match cx.tcx.get_diagnostic_name(def_id) {\n+                        Some(sym::mem_zeroed) => return Some(InitKind::Zeroed),\n+                        Some(sym::mem_uninitialized) => return Some(InitKind::Uninit),\n+                        Some(sym::transmute) if is_zero(&args[0]) => return Some(InitKind::Zeroed),\n+                        _ => {}\n                     }\n                 }\n             } else if let hir::ExprKind::MethodCall(_, _, ref args, _) = expr.kind {\n@@ -2497,11 +2494,10 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                     if let hir::ExprKind::Call(ref path_expr, _) = args[0].kind {\n                         if let hir::ExprKind::Path(ref qpath) = path_expr.kind {\n                             let def_id = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n-\n-                            if cx.tcx.is_diagnostic_item(sym::maybe_uninit_zeroed, def_id) {\n-                                return Some(InitKind::Zeroed);\n-                            } else if cx.tcx.is_diagnostic_item(sym::maybe_uninit_uninit, def_id) {\n-                                return Some(InitKind::Uninit);\n+                            match cx.tcx.get_diagnostic_name(def_id) {\n+                                Some(sym::maybe_uninit_zeroed) => return Some(InitKind::Zeroed),\n+                                Some(sym::maybe_uninit_uninit) => return Some(InitKind::Uninit),\n+                                _ => {}\n                             }\n                         }\n                     }\n@@ -3091,8 +3087,10 @@ impl<'tcx> LateLintPass<'tcx> for DerefNullPtr {\n                 rustc_hir::ExprKind::Call(ref path, _) => {\n                     if let rustc_hir::ExprKind::Path(ref qpath) = path.kind {\n                         if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id() {\n-                            return cx.tcx.is_diagnostic_item(sym::ptr_null, def_id)\n-                                || cx.tcx.is_diagnostic_item(sym::ptr_null_mut, def_id);\n+                            return matches!(\n+                                cx.tcx.get_diagnostic_name(def_id),\n+                                Some(sym::ptr_null | sym::ptr_null_mut)\n+                            );\n                         }\n                     }\n                 }"}, {"sha": "50a0d211a366a913613ea622df502554413c00bd", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=0157cc977fd71297ce73e2f249321f5ba2555d42", "patch": "@@ -33,12 +33,10 @@ impl LateLintPass<'_> for DefaultHashTypes {\n             // don't lint imports, only actual usages\n             return;\n         }\n-        let replace = if cx.tcx.is_diagnostic_item(sym::HashMap, def_id) {\n-            \"FxHashMap\"\n-        } else if cx.tcx.is_diagnostic_item(sym::HashSet, def_id) {\n-            \"FxHashSet\"\n-        } else {\n-            return;\n+        let replace = match cx.tcx.get_diagnostic_name(def_id) {\n+            Some(sym::HashMap) => \"FxHashMap\",\n+            Some(sym::HashSet) => \"FxHashSet\",\n+            _ => return,\n         };\n         cx.struct_span_lint(DEFAULT_HASH_TYPES, path.span, |lint| {\n             let msg = format!(\n@@ -174,26 +172,29 @@ fn is_ty_or_ty_ctxt(cx: &LateContext<'_>, ty: &Ty<'_>) -> Option<String> {\n     if let TyKind::Path(qpath) = &ty.kind {\n         if let QPath::Resolved(_, path) = qpath {\n             match path.res {\n-                Res::Def(_, did) => {\n-                    if cx.tcx.is_diagnostic_item(sym::Ty, did) {\n-                        return Some(format!(\"Ty{}\", gen_args(path.segments.last().unwrap())));\n-                    } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, did) {\n-                        return Some(format!(\"TyCtxt{}\", gen_args(path.segments.last().unwrap())));\n+                Res::Def(_, def_id) => {\n+                    if let Some(name @ (sym::Ty | sym::TyCtxt)) = cx.tcx.get_diagnostic_name(def_id)\n+                    {\n+                        return Some(format!(\n+                            \"{}{}\",\n+                            name,\n+                            gen_args(path.segments.last().unwrap())\n+                        ));\n                     }\n                 }\n                 // Only lint on `&Ty` and `&TyCtxt` if it is used outside of a trait.\n                 Res::SelfTy(None, Some((did, _))) => {\n                     if let ty::Adt(adt, substs) = cx.tcx.type_of(did).kind() {\n-                        if cx.tcx.is_diagnostic_item(sym::Ty, adt.did) {\n+                        if let Some(name @ (sym::Ty | sym::TyCtxt)) =\n+                            cx.tcx.get_diagnostic_name(adt.did)\n+                        {\n                             // NOTE: This path is currently unreachable as `Ty<'tcx>` is\n                             // defined as a type alias meaning that `impl<'tcx> Ty<'tcx>`\n                             // is not actually allowed.\n                             //\n                             // I(@lcnr) still kept this branch in so we don't miss this\n                             // if we ever change it in the future.\n-                            return Some(format!(\"Ty<{}>\", substs[0]));\n-                        } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, adt.did) {\n-                            return Some(format!(\"TyCtxt<{}>\", substs[0]));\n+                            return Some(format!(\"{}<{}>\", name, substs[0]));\n                         }\n                     }\n                 }"}, {"sha": "103555a67524fd58d53681b0c3ca8b3ade211da2", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=0157cc977fd71297ce73e2f249321f5ba2555d42", "patch": "@@ -54,9 +54,10 @@ impl<'tcx> LateLintPass<'tcx> for NonPanicFmt {\n                     || Some(def_id) == cx.tcx.lang_items().panic_str()\n                 {\n                     if let Some(id) = f.span.ctxt().outer_expn_data().macro_def_id {\n-                        if cx.tcx.is_diagnostic_item(sym::std_panic_2015_macro, id)\n-                            || cx.tcx.is_diagnostic_item(sym::core_panic_2015_macro, id)\n-                        {\n+                        if matches!(\n+                            cx.tcx.get_diagnostic_name(id),\n+                            Some(sym::core_panic_2015_macro | sym::std_panic_2015_macro)\n+                        ) {\n                             check_panic(cx, f, arg);\n                         }\n                     }"}, {"sha": "d2c970468abc7d8de5800e76aa684710defaad18", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=0157cc977fd71297ce73e2f249321f5ba2555d42", "patch": "@@ -51,9 +51,10 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n             Some((DefKind::AssocFn, did)) => match cx.tcx.trait_of_item(did) {\n                 // Check that we're dealing with a trait method for one of the traits we care about.\n                 Some(trait_id)\n-                    if [sym::Clone, sym::Deref, sym::Borrow]\n-                        .iter()\n-                        .any(|s| cx.tcx.is_diagnostic_item(*s, trait_id)) =>\n+                    if matches!(\n+                        cx.tcx.get_diagnostic_name(trait_id),\n+                        Some(sym::Borrow | sym::Clone | sym::Deref)\n+                    ) =>\n                 {\n                     (trait_id, did)\n                 }"}, {"sha": "708cd56e068b537c40be4088eb3d961194443b2f", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=0157cc977fd71297ce73e2f249321f5ba2555d42", "patch": "@@ -1541,8 +1541,7 @@ impl InvalidAtomicOrdering {\n             if let ExprKind::Call(ref func, ref args) = expr.kind;\n             if let ExprKind::Path(ref func_qpath) = func.kind;\n             if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n-            if cx.tcx.is_diagnostic_item(sym::fence, def_id) ||\n-                cx.tcx.is_diagnostic_item(sym::compiler_fence, def_id);\n+            if matches!(cx.tcx.get_diagnostic_name(def_id), Some(sym::fence | sym::compiler_fence));\n             if let ExprKind::Path(ref ordering_qpath) = &args[0].kind;\n             if let Some(ordering_def_id) = cx.qpath_res(ordering_qpath, args[0].hir_id).opt_def_id();\n             if Self::matches_ordering(cx, ordering_def_id, &[sym::Relaxed]);"}, {"sha": "c7d0f594f0117756f10f35c49ce8b1fbd3c47589", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=0157cc977fd71297ce73e2f249321f5ba2555d42", "patch": "@@ -18,6 +18,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathData, DefPathHash};\n+use rustc_hir::diagnostic_items::DiagnosticItems;\n use rustc_hir::lang_items;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::hir::exports::Export;\n@@ -1052,16 +1053,23 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     /// Iterates over the diagnostic items in the given crate.\n-    fn get_diagnostic_items(&self) -> FxHashMap<Symbol, DefId> {\n+    fn get_diagnostic_items(&self) -> DiagnosticItems {\n         if self.root.is_proc_macro_crate() {\n             // Proc macro crates do not export any diagnostic-items to the target.\n             Default::default()\n         } else {\n-            self.root\n+            let mut id_to_name = FxHashMap::default();\n+            let name_to_id = self\n+                .root\n                 .diagnostic_items\n                 .decode(self)\n-                .map(|(name, def_index)| (name, self.local_def_id(def_index)))\n-                .collect()\n+                .map(|(name, def_index)| {\n+                    let id = self.local_def_id(def_index);\n+                    id_to_name.insert(id, name);\n+                    (name, id)\n+                })\n+                .collect();\n+            DiagnosticItems { id_to_name, name_to_id }\n         }\n     }\n "}, {"sha": "dacb1e4029c20d302a850a4d1df9d86d90a9b495", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=0157cc977fd71297ce73e2f249321f5ba2555d42", "patch": "@@ -1750,7 +1750,7 @@ impl EncodeContext<'a, 'tcx> {\n     fn encode_diagnostic_items(&mut self) -> Lazy<[(Symbol, DefIndex)]> {\n         empty_proc_macro!(self);\n         let tcx = self.tcx;\n-        let diagnostic_items = tcx.diagnostic_items(LOCAL_CRATE);\n+        let diagnostic_items = &tcx.diagnostic_items(LOCAL_CRATE).name_to_id;\n         self.lazy(diagnostic_items.iter().map(|(&name, def_id)| (name, def_id.index)))\n     }\n "}, {"sha": "9b0b1377875d1031af320d11912637d1ace2bb2f", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=0157cc977fd71297ce73e2f249321f5ba2555d42", "patch": "@@ -1442,7 +1442,7 @@ rustc_queries! {\n     }\n \n     /// Returns all diagnostic items defined in all crates.\n-    query all_diagnostic_items(_: ()) -> FxHashMap<Symbol, DefId> {\n+    query all_diagnostic_items(_: ()) -> rustc_hir::diagnostic_items::DiagnosticItems {\n         storage(ArenaCacheSelector<'tcx>)\n         eval_always\n         desc { \"calculating the diagnostic items map\" }\n@@ -1454,7 +1454,7 @@ rustc_queries! {\n     }\n \n     /// Returns the diagnostic items defined in a crate.\n-    query diagnostic_items(_: CrateNum) -> FxHashMap<Symbol, DefId> {\n+    query diagnostic_items(_: CrateNum) -> rustc_hir::diagnostic_items::DiagnosticItems {\n         storage(ArenaCacheSelector<'tcx>)\n         desc { \"calculating the diagnostic items map in a crate\" }\n     }"}, {"sha": "6a6fb30dce837e1cd942affd70deb6bc1edd5dad", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=0157cc977fd71297ce73e2f249321f5ba2555d42", "patch": "@@ -1232,12 +1232,17 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Obtain the given diagnostic item's `DefId`. Use `is_diagnostic_item` if you just want to\n     /// compare against another `DefId`, since `is_diagnostic_item` is cheaper.\n     pub fn get_diagnostic_item(self, name: Symbol) -> Option<DefId> {\n-        self.all_diagnostic_items(()).get(&name).copied()\n+        self.all_diagnostic_items(()).name_to_id.get(&name).copied()\n+    }\n+\n+    /// Obtain the diagnostic item's name\n+    pub fn get_diagnostic_name(self, id: DefId) -> Option<Symbol> {\n+        self.diagnostic_items(id.krate).id_to_name.get(&id).copied()\n     }\n \n     /// Check whether the diagnostic item with the given `name` has the given `DefId`.\n     pub fn is_diagnostic_item(self, name: Symbol, did: DefId) -> bool {\n-        self.diagnostic_items(did.krate).get(&name) == Some(&did)\n+        self.diagnostic_items(did.krate).name_to_id.get(&name) == Some(&did)\n     }\n \n     pub fn stability(self) -> &'tcx stability::Index<'tcx> {"}, {"sha": "30a0071f0f2e5c2a531a20554e8881070518e50b", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=0157cc977fd71297ce73e2f249321f5ba2555d42", "patch": "@@ -10,18 +10,17 @@\n //! * Compiler internal types like `Ty` and `TyCtxt`\n \n use rustc_ast as ast;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n+use rustc_hir::diagnostic_items::DiagnosticItems;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_span::symbol::{sym, Symbol};\n \n struct DiagnosticItemCollector<'tcx> {\n-    // items from this crate\n-    items: FxHashMap<Symbol, DefId>,\n     tcx: TyCtxt<'tcx>,\n+    diagnostic_items: DiagnosticItems,\n }\n \n impl<'v, 'tcx> ItemLikeVisitor<'v> for DiagnosticItemCollector<'tcx> {\n@@ -44,27 +43,22 @@ impl<'v, 'tcx> ItemLikeVisitor<'v> for DiagnosticItemCollector<'tcx> {\n \n impl<'tcx> DiagnosticItemCollector<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> DiagnosticItemCollector<'tcx> {\n-        DiagnosticItemCollector { tcx, items: Default::default() }\n+        DiagnosticItemCollector { tcx, diagnostic_items: DiagnosticItems::default() }\n     }\n \n     fn observe_item(&mut self, def_id: LocalDefId) {\n         let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let attrs = self.tcx.hir().attrs(hir_id);\n         if let Some(name) = extract(attrs) {\n             // insert into our table\n-            collect_item(self.tcx, &mut self.items, name, def_id.to_def_id());\n+            collect_item(self.tcx, &mut self.diagnostic_items, name, def_id.to_def_id());\n         }\n     }\n }\n \n-fn collect_item(\n-    tcx: TyCtxt<'_>,\n-    items: &mut FxHashMap<Symbol, DefId>,\n-    name: Symbol,\n-    item_def_id: DefId,\n-) {\n-    // Check for duplicates.\n-    if let Some(original_def_id) = items.insert(name, item_def_id) {\n+fn collect_item(tcx: TyCtxt<'_>, items: &mut DiagnosticItems, name: Symbol, item_def_id: DefId) {\n+    items.id_to_name.insert(item_def_id, name);\n+    if let Some(original_def_id) = items.name_to_id.insert(name, item_def_id) {\n         if original_def_id != item_def_id {\n             let mut err = match tcx.hir().span_if_local(item_def_id) {\n                 Some(span) => tcx.sess.struct_span_err(\n@@ -98,7 +92,7 @@ fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n }\n \n /// Traverse and collect the diagnostic items in the current\n-fn diagnostic_items<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> FxHashMap<Symbol, DefId> {\n+fn diagnostic_items<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> DiagnosticItems {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     // Initialize the collector.\n@@ -107,22 +101,22 @@ fn diagnostic_items<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> FxHashMap<Symbol\n     // Collect diagnostic items in this crate.\n     tcx.hir().visit_all_item_likes(&mut collector);\n \n-    collector.items\n+    collector.diagnostic_items\n }\n \n /// Traverse and collect all the diagnostic items in all crates.\n-fn all_diagnostic_items<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> FxHashMap<Symbol, DefId> {\n+fn all_diagnostic_items<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> DiagnosticItems {\n     // Initialize the collector.\n-    let mut collector = FxHashMap::default();\n+    let mut items = DiagnosticItems::default();\n \n     // Collect diagnostic items in other crates.\n     for &cnum in tcx.crates(()).iter().chain(std::iter::once(&LOCAL_CRATE)) {\n-        for (&name, &def_id) in tcx.diagnostic_items(cnum).iter() {\n-            collect_item(tcx, &mut collector, name, def_id);\n+        for (&name, &def_id) in &tcx.diagnostic_items(cnum).name_to_id {\n+            collect_item(tcx, &mut items, name, def_id);\n         }\n     }\n \n-    collector\n+    items\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "a73d2285d457650c2980c2bd00df4cd458fc5c94", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=0157cc977fd71297ce73e2f249321f5ba2555d42", "patch": "@@ -1636,12 +1636,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         // Special case the primary error message when send or sync is the trait that was\n         // not implemented.\n-        let is_send = self.tcx.is_diagnostic_item(sym::Send, trait_ref.def_id);\n-        let is_sync = self.tcx.is_diagnostic_item(sym::Sync, trait_ref.def_id);\n         let hir = self.tcx.hir();\n-        let trait_explanation = if is_send || is_sync {\n+        let trait_explanation = if let Some(name @ (sym::Send | sym::Sync)) =\n+            self.tcx.get_diagnostic_name(trait_ref.def_id)\n+        {\n             let (trait_name, trait_verb) =\n-                if is_send { (\"`Send`\", \"sent\") } else { (\"`Sync`\", \"shared\") };\n+                if name == sym::Send { (\"`Send`\", \"sent\") } else { (\"`Sync`\", \"shared\") };\n \n             err.clear_code();\n             err.set_primary_message(format!("}, {"sha": "183ebc559ae42ba0cd1a978349246c882fca57e9", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 35, "deletions": 75, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0157cc977fd71297ce73e2f249321f5ba2555d42/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=0157cc977fd71297ce73e2f249321f5ba2555d42", "patch": "@@ -1047,51 +1047,41 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         unsatisfied_predicates: &Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>)>,\n     ) {\n-        let derivables = [\n-            sym::Eq,\n-            sym::PartialEq,\n-            sym::Ord,\n-            sym::PartialOrd,\n-            sym::Clone,\n-            sym::Copy,\n-            sym::Hash,\n-            sym::Default,\n-            sym::Debug,\n-        ];\n-        let mut derives = unsatisfied_predicates\n-            .iter()\n-            .filter_map(|(pred, _)| {\n-                let trait_pred =\n-                    if let ty::PredicateKind::Trait(trait_pred) = pred.kind().skip_binder() {\n-                        trait_pred\n-                    } else {\n-                        return None;\n-                    };\n-                let trait_ref = trait_pred.trait_ref;\n-                let adt_def = if let ty::Adt(adt_def, _) = trait_ref.self_ty().kind() {\n-                    adt_def\n-                } else {\n-                    return None;\n-                };\n-                if adt_def.did.is_local() {\n-                    let diagnostic_items = self.tcx.diagnostic_items(trait_ref.def_id.krate);\n-                    return derivables.iter().find_map(|trait_derivable| {\n-                        let item_def_id = diagnostic_items.get(trait_derivable)?;\n-                        if item_def_id == &trait_pred.trait_ref.def_id\n-                            && !(adt_def.is_enum() && *trait_derivable == sym::Default)\n-                        {\n-                            return Some((\n-                                format!(\"{}\", trait_ref.self_ty()),\n-                                self.tcx.def_span(adt_def.did),\n-                                format!(\"{}\", trait_ref.print_only_trait_name()),\n-                            ));\n-                        }\n-                        None\n-                    });\n-                }\n-                None\n-            })\n-            .collect::<Vec<(String, Span, String)>>();\n+        let mut derives = Vec::<(String, Span, String)>::new();\n+        let mut traits = Vec::<Span>::new();\n+        for (pred, _) in unsatisfied_predicates {\n+            let trait_pred = match pred.kind().skip_binder() {\n+                ty::PredicateKind::Trait(trait_pred) => trait_pred,\n+                _ => continue,\n+            };\n+            let adt = match trait_pred.self_ty().ty_adt_def() {\n+                Some(adt) if adt.did.is_local() => adt,\n+                _ => continue,\n+            };\n+            let can_derive = match self.tcx.get_diagnostic_name(trait_pred.def_id()) {\n+                Some(sym::Default) => !adt.is_enum(),\n+                Some(\n+                    sym::Eq\n+                    | sym::PartialEq\n+                    | sym::Ord\n+                    | sym::PartialOrd\n+                    | sym::Clone\n+                    | sym::Copy\n+                    | sym::Hash\n+                    | sym::Debug,\n+                ) => true,\n+                _ => false,\n+            };\n+            if can_derive {\n+                derives.push((\n+                    format!(\"{}\", trait_pred.self_ty()),\n+                    self.tcx.def_span(adt.did),\n+                    format!(\"{}\", trait_pred.trait_ref.print_only_trait_name()),\n+                ));\n+            } else {\n+                traits.push(self.tcx.def_span(trait_pred.def_id()));\n+            }\n+        }\n         derives.sort();\n         let derives_grouped = derives.into_iter().fold(\n             Vec::<(String, Span, String)>::new(),\n@@ -1106,36 +1096,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 acc\n             },\n         );\n-        let mut traits: Vec<_> = unsatisfied_predicates\n-            .iter()\n-            .filter_map(|(pred, _)| {\n-                let trait_pred =\n-                    if let ty::PredicateKind::Trait(trait_pred) = pred.kind().skip_binder() {\n-                        trait_pred\n-                    } else {\n-                        return None;\n-                    };\n-                if let ty::Adt(adt_def, _) = trait_pred.trait_ref.self_ty().kind() {\n-                    if !adt_def.did.is_local() {\n-                        return None;\n-                    }\n-                } else {\n-                    return None;\n-                };\n-\n-                let did = trait_pred.def_id();\n-                let diagnostic_items = self.tcx.diagnostic_items(did.krate);\n-\n-                if !derivables\n-                    .iter()\n-                    .any(|trait_derivable| diagnostic_items.get(trait_derivable) == Some(&did))\n-                {\n-                    Some(self.tcx.def_span(did))\n-                } else {\n-                    None\n-                }\n-            })\n-            .collect();\n         traits.sort();\n         traits.dedup();\n "}, {"sha": "2af3ba1d5bb9c47c268f3e8ea94a926d73285b52", "filename": "src/test/ui/suggestions/derive-trait-for-method-call.stderr", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0157cc977fd71297ce73e2f249321f5ba2555d42/src%2Ftest%2Fui%2Fsuggestions%2Fderive-trait-for-method-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0157cc977fd71297ce73e2f249321f5ba2555d42/src%2Ftest%2Fui%2Fsuggestions%2Fderive-trait-for-method-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fderive-trait-for-method-call.stderr?ref=0157cc977fd71297ce73e2f249321f5ba2555d42", "patch": "@@ -20,6 +20,17 @@ LL |     let y = x.test();\n            `Enum: Clone`\n            `Enum: Default`\n            `CloneEnum: Default`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/default.rs:LL:COL\n+   |\n+LL | / pub trait Default: Sized {\n+LL | |     /// Returns the \"default value\" for a type.\n+LL | |     ///\n+LL | |     /// Default values are often some kind of initial value, identity value, or anything else that\n+...  |\n+LL | |     fn default() -> Self;\n+LL | | }\n+   | |_^\n help: consider annotating `Enum` with `#[derive(Clone)]`\n    |\n LL | #[derive(Clone)]"}]}