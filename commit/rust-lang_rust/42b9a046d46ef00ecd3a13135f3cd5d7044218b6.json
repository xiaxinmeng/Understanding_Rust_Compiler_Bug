{"sha": "42b9a046d46ef00ecd3a13135f3cd5d7044218b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYjlhMDQ2ZDQ2ZWYwMGVjZDNhMTMxMzVmM2NkNWQ3MDQ0MjE4YjY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-22T13:58:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-22T13:58:00Z"}, "message": "Rollup merge of #58431 - RalfJung:btree, r=Mark-Simulacrum\n\nfix overlapping references in BTree\n\nThis fixes two kinds of overlapping references in BTree (both found by running the BTree test suite in Miri).\n\nIn `into_slices_mut`, we did `k.into_key_slice_mut()` followed by `self.into_val_slice_mut()` (where `k` is a copy of `self`). Calling `into_val_slice_mut` calls `self.len()`, which creates a shared reference to `NodeHeader`, which unfortunately (due to padding) overlaps with the mutable reference returned by `into_key_slice_mut`.  Hence the key slice got (partially) invalidated.  The fix is to avoid creating an `&NodeHeader` after the first slice got created.\n\nIn the iterators, we used to first create the references that will be returned, and then perform the walk on the tree.  Walking the tree creates references (such as `&mut InternalNode`) that overlap with all of the keys and values stored in a pointer; in particular, they overlap with the references the iterator will later return. This is fixed by reordering the operations of walking the tree and obtaining the inner references.\n\nThe test suite still passes (and it passes in Miri now!), but there is a lot of code here that I do not understand...", "tree": {"sha": "092c9703b8f21afdeab9eef9ad41d8d3ada14787", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/092c9703b8f21afdeab9eef9ad41d8d3ada14787"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42b9a046d46ef00ecd3a13135f3cd5d7044218b6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcb//pCRBK7hj4Ov3rIwAAdHIIABWbaTxp1J0LBZlZgUMvmd5f\nZRPebZI7i2/SovsrVsi2K83nH6N0y9G6fHwYEGEZSlpLbq3lQpzAXtyChe2th7Lv\n4JIQnlgpSeLamB+d5iaq/Q7Mq6qWFBz+avNillw+0vd8UkP+nJ4YEtZZW1JYFKxq\nTKVDsi3cBytKZ9Yi4BaIsTTwGRgMmiWNvk2goFE0ybJwE3LqChRxKmG+1DVZU9vk\nm1pPiwKW+Dt7eajXITePHBE2n7E4/f6NbXxDATCAVuARwTEscXWxVaMXW7vmLa9+\nA6eTQUOLtEGeSUWpoFtWtWqabpUJeTKui4wt0w2FfgDPi7Vn6RZMm4Gv7Gh6ohA=\n=tSQS\n-----END PGP SIGNATURE-----\n", "payload": "tree 092c9703b8f21afdeab9eef9ad41d8d3ada14787\nparent 894141b57d5a0072eee07a4918db32bfc187e5bb\nparent f0bef49cf10c19b72b7d025aedb407ab5745c365\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1550843880 +0100\ncommitter GitHub <noreply@github.com> 1550843880 +0100\n\nRollup merge of #58431 - RalfJung:btree, r=Mark-Simulacrum\n\nfix overlapping references in BTree\n\nThis fixes two kinds of overlapping references in BTree (both found by running the BTree test suite in Miri).\n\nIn `into_slices_mut`, we did `k.into_key_slice_mut()` followed by `self.into_val_slice_mut()` (where `k` is a copy of `self`). Calling `into_val_slice_mut` calls `self.len()`, which creates a shared reference to `NodeHeader`, which unfortunately (due to padding) overlaps with the mutable reference returned by `into_key_slice_mut`.  Hence the key slice got (partially) invalidated.  The fix is to avoid creating an `&NodeHeader` after the first slice got created.\n\nIn the iterators, we used to first create the references that will be returned, and then perform the walk on the tree.  Walking the tree creates references (such as `&mut InternalNode`) that overlap with all of the keys and values stored in a pointer; in particular, they overlap with the references the iterator will later return. This is fixed by reordering the operations of walking the tree and obtaining the inner references.\n\nThe test suite still passes (and it passes in Miri now!), but there is a lot of code here that I do not understand...\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42b9a046d46ef00ecd3a13135f3cd5d7044218b6", "html_url": "https://github.com/rust-lang/rust/commit/42b9a046d46ef00ecd3a13135f3cd5d7044218b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42b9a046d46ef00ecd3a13135f3cd5d7044218b6/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "894141b57d5a0072eee07a4918db32bfc187e5bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/894141b57d5a0072eee07a4918db32bfc187e5bb", "html_url": "https://github.com/rust-lang/rust/commit/894141b57d5a0072eee07a4918db32bfc187e5bb"}, {"sha": "f0bef49cf10c19b72b7d025aedb407ab5745c365", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0bef49cf10c19b72b7d025aedb407ab5745c365", "html_url": "https://github.com/rust-lang/rust/commit/f0bef49cf10c19b72b7d025aedb407ab5745c365"}], "stats": {"total": 57, "additions": 42, "deletions": 15}, "files": [{"sha": "ce29978856ffd6315dd413c573a270771d09cb08", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/42b9a046d46ef00ecd3a13135f3cd5d7044218b6/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b9a046d46ef00ecd3a13135f3cd5d7044218b6/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=42b9a046d46ef00ecd3a13135f3cd5d7044218b6", "patch": "@@ -1634,9 +1634,11 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n \n         let mut cur_handle = match handle.right_kv() {\n             Ok(kv) => {\n-                let (k, v) = ptr::read(&kv).into_kv_mut();\n-                self.front = kv.right_edge();\n-                return (k, v);\n+                self.front = ptr::read(&kv).right_edge();\n+                // Doing the descend invalidates the references returned by `into_kv_mut`,\n+                // so we have to do this last.\n+                let (k, v) = kv.into_kv_mut();\n+                return (k, v); // coerce k from `&mut K` to `&K`\n             }\n             Err(last_edge) => {\n                 let next_level = last_edge.into_node().ascend().ok();\n@@ -1647,9 +1649,11 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n         loop {\n             match cur_handle.right_kv() {\n                 Ok(kv) => {\n-                    let (k, v) = ptr::read(&kv).into_kv_mut();\n-                    self.front = first_leaf_edge(kv.right_edge().descend());\n-                    return (k, v);\n+                    self.front = first_leaf_edge(ptr::read(&kv).right_edge().descend());\n+                    // Doing the descend invalidates the references returned by `into_kv_mut`,\n+                    // so we have to do this last.\n+                    let (k, v) = kv.into_kv_mut();\n+                    return (k, v); // coerce k from `&mut K` to `&K`\n                 }\n                 Err(last_edge) => {\n                     let next_level = last_edge.into_node().ascend().ok();\n@@ -1680,9 +1684,11 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n \n         let mut cur_handle = match handle.left_kv() {\n             Ok(kv) => {\n-                let (k, v) = ptr::read(&kv).into_kv_mut();\n-                self.back = kv.left_edge();\n-                return (k, v);\n+                self.back = ptr::read(&kv).left_edge();\n+                // Doing the descend invalidates the references returned by `into_kv_mut`,\n+                // so we have to do this last.\n+                let (k, v) = kv.into_kv_mut();\n+                return (k, v); // coerce k from `&mut K` to `&K`\n             }\n             Err(last_edge) => {\n                 let next_level = last_edge.into_node().ascend().ok();\n@@ -1693,9 +1699,11 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n         loop {\n             match cur_handle.left_kv() {\n                 Ok(kv) => {\n-                    let (k, v) = ptr::read(&kv).into_kv_mut();\n-                    self.back = last_leaf_edge(kv.left_edge().descend());\n-                    return (k, v);\n+                    self.back = last_leaf_edge(ptr::read(&kv).left_edge().descend());\n+                    // Doing the descend invalidates the references returned by `into_kv_mut`,\n+                    // so we have to do this last.\n+                    let (k, v) = kv.into_kv_mut();\n+                    return (k, v); // coerce k from `&mut K` to `&K`\n                 }\n                 Err(last_edge) => {\n                     let next_level = last_edge.into_node().ascend().ok();"}, {"sha": "66d619b1298b41e91a13a98d74afc27760ad9ecf", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/42b9a046d46ef00ecd3a13135f3cd5d7044218b6/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b9a046d46ef00ecd3a13135f3cd5d7044218b6/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=42b9a046d46ef00ecd3a13135f3cd5d7044218b6", "patch": "@@ -645,6 +645,8 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     }\n \n     fn into_key_slice_mut(mut self) -> &'a mut [K] {\n+        // Same as for `into_key_slice` above, we try to avoid a run-time check\n+        // (the alignment comparison will usually be performed at compile-time).\n         if mem::align_of::<K>() > mem::align_of::<LeafNode<(), ()>>() && self.is_shared_root() {\n             &mut []\n         } else {\n@@ -667,9 +669,26 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n-    fn into_slices_mut(self) -> (&'a mut [K], &'a mut [V]) {\n-        let k = unsafe { ptr::read(&self) };\n-        (k.into_key_slice_mut(), self.into_val_slice_mut())\n+    fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n+        debug_assert!(!self.is_shared_root());\n+        // We cannot use the getters here, because calling the second one\n+        // invalidates the reference returned by the first.\n+        // More precisely, it is the call to `len` that is the culprit,\n+        // because that creates a shared reference to the header, which *can*\n+        // overlap with the keys (and even the values, for ZST keys).\n+        unsafe {\n+            let len = self.len();\n+            let leaf = self.as_leaf_mut();\n+            let keys = slice::from_raw_parts_mut(\n+                MaybeUninit::first_ptr_mut(&mut (*leaf).keys),\n+                len\n+            );\n+            let vals = slice::from_raw_parts_mut(\n+                MaybeUninit::first_ptr_mut(&mut (*leaf).vals),\n+                len\n+            );\n+            (keys, vals)\n+        }\n     }\n }\n "}]}