{"sha": "cebe5e8e6baecd448f810f5960daab10fa2d089c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYmU1ZThlNmJhZWNkNDQ4ZjgxMGY1OTYwZGFhYjEwZmEyZDA4OWM=", "commit": {"author": {"name": "Zach Kamsler", "email": "smoo.master@gmail.com", "date": "2014-02-04T17:56:13Z"}, "committer": {"name": "Zach Kamsler", "email": "smoo.master@gmail.com", "date": "2014-02-07T22:11:28Z"}, "message": "Reduced allocations in merge_sort for short vectors\n\nAdded a seperate in-place insertion sort for short vectors.\nIncreased threshold for insertion short for 8 to 32 elements\nfor small types and 16 for larger types. Added benchmarks\nfor sorting larger types.", "tree": {"sha": "a1cc444831180a5f05d09b234001b957801aaf42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1cc444831180a5f05d09b234001b957801aaf42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cebe5e8e6baecd448f810f5960daab10fa2d089c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cebe5e8e6baecd448f810f5960daab10fa2d089c", "html_url": "https://github.com/rust-lang/rust/commit/cebe5e8e6baecd448f810f5960daab10fa2d089c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cebe5e8e6baecd448f810f5960daab10fa2d089c/comments", "author": {"login": "zkamsler", "id": 944662, "node_id": "MDQ6VXNlcjk0NDY2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/944662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zkamsler", "html_url": "https://github.com/zkamsler", "followers_url": "https://api.github.com/users/zkamsler/followers", "following_url": "https://api.github.com/users/zkamsler/following{/other_user}", "gists_url": "https://api.github.com/users/zkamsler/gists{/gist_id}", "starred_url": "https://api.github.com/users/zkamsler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zkamsler/subscriptions", "organizations_url": "https://api.github.com/users/zkamsler/orgs", "repos_url": "https://api.github.com/users/zkamsler/repos", "events_url": "https://api.github.com/users/zkamsler/events{/privacy}", "received_events_url": "https://api.github.com/users/zkamsler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zkamsler", "id": 944662, "node_id": "MDQ6VXNlcjk0NDY2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/944662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zkamsler", "html_url": "https://github.com/zkamsler", "followers_url": "https://api.github.com/users/zkamsler/followers", "following_url": "https://api.github.com/users/zkamsler/following{/other_user}", "gists_url": "https://api.github.com/users/zkamsler/gists{/gist_id}", "starred_url": "https://api.github.com/users/zkamsler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zkamsler/subscriptions", "organizations_url": "https://api.github.com/users/zkamsler/orgs", "repos_url": "https://api.github.com/users/zkamsler/repos", "events_url": "https://api.github.com/users/zkamsler/events{/privacy}", "received_events_url": "https://api.github.com/users/zkamsler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef53b7a97c58f65ac6967dfc6d30a4354afa34a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef53b7a97c58f65ac6967dfc6d30a4354afa34a3", "html_url": "https://github.com/rust-lang/rust/commit/ef53b7a97c58f65ac6967dfc6d30a4354afa34a3"}], "stats": {"total": 109, "additions": 104, "deletions": 5}, "files": [{"sha": "9ad589800b4f35c12721128c43e5c5dfd410d4c7", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 104, "deletions": 5, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/cebe5e8e6baecd448f810f5960daab10fa2d089c/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebe5e8e6baecd448f810f5960daab10fa2d089c/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=cebe5e8e6baecd448f810f5960daab10fa2d089c", "patch": "@@ -1812,12 +1812,70 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n     }\n }\n \n+fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n+    let len = v.len() as int;\n+    let buf_v = v.as_mut_ptr();\n+\n+    // 1 <= i < len;\n+    for i in range(1, len) {\n+        // j satisfies: 0 <= j <= i;\n+        let mut j = i;\n+        unsafe {\n+            // `i` is in bounds.\n+            let read_ptr = buf_v.offset(i) as *T;\n+\n+            // find where to insert, we need to do strict <,\n+            // rather than <=, to maintain stability.\n+\n+            // 0 <= j - 1 < len, so .offset(j - 1) is in bounds.\n+            while j > 0 &&\n+                    compare(&*read_ptr, &*buf_v.offset(j - 1)) == Less {\n+                j -= 1;\n+            }\n+\n+            // shift everything to the right, to make space to\n+            // insert this value.\n+\n+            // j + 1 could be `len` (for the last `i`), but in\n+            // that case, `i == j` so we don't copy. The\n+            // `.offset(j)` is always in bounds.\n+\n+            if i != j {\n+                let tmp = ptr::read_ptr(read_ptr);\n+                ptr::copy_memory(buf_v.offset(j + 1),\n+                                 buf_v.offset(j),\n+                                 (i - j) as uint);\n+                ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n+                                                &tmp as *T,\n+                                                1);\n+                cast::forget(tmp);\n+            }\n+        }\n+    }\n+}\n+\n fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n     // warning: this wildly uses unsafe.\n-    static INSERTION: uint = 8;\n+    static BASE_INSERTION: uint = 32;\n+    static LARGE_INSERTION: uint = 16;\n+\n+    // FIXME #12092: smaller insertion runs seems to make sorting\n+    // vectors of large elements a little faster on some platforms,\n+    // but hasn't been tested/tuned extensively\n+    let insertion = if size_of::<T>() <= 16 {\n+        BASE_INSERTION\n+    } else {\n+        LARGE_INSERTION\n+    };\n \n     let len = v.len();\n \n+    // short vectors get sorted in-place via insertion sort to avoid allocations\n+    if len <= insertion {\n+        insertion_sort(v, compare);\n+        return;\n+    }\n+\n     // allocate some memory to use as scratch memory, we keep the\n     // length 0 so we can keep shallow copies of the contents of `v`\n     // without risking the dtors running on an object twice if\n@@ -1837,9 +1895,9 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n     // We could hardcode the sorting comparisons here, and we could\n     // manipulate/step the pointers themselves, rather than repeatedly\n     // .offset-ing.\n-    for start in range_step(0, len, INSERTION) {\n-        // start <= i <= len;\n-        for i in range(start, cmp::min(start + INSERTION, len)) {\n+    for start in range_step(0, len, insertion) {\n+        // start <= i < len;\n+        for i in range(start, cmp::min(start + insertion, len)) {\n             // j satisfies: start <= j <= i;\n             let mut j = i as int;\n             unsafe {\n@@ -1871,7 +1929,7 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n     }\n \n     // step 2. merge the sorted runs.\n-    let mut width = INSERTION;\n+    let mut width = insertion;\n     while width < len {\n         // merge the sorted runs of length `width` in `buf_dat` two at\n         // a time, placing the result in `buf_tmp`.\n@@ -4505,4 +4563,45 @@ mod bench {\n         });\n         bh.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n     }\n+\n+    type BigSortable = (u64,u64,u64,u64);\n+\n+    #[bench]\n+    fn sort_big_random_small(bh: &mut BenchHarness) {\n+        let mut rng = weak_rng();\n+        bh.iter(|| {\n+            let mut v: ~[BigSortable] = rng.gen_vec(5);\n+            v.sort();\n+        });\n+        bh.bytes = 5 * mem::size_of::<BigSortable>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_big_random_medium(bh: &mut BenchHarness) {\n+        let mut rng = weak_rng();\n+        bh.iter(|| {\n+            let mut v: ~[BigSortable] = rng.gen_vec(100);\n+            v.sort();\n+        });\n+        bh.bytes = 100 * mem::size_of::<BigSortable>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_big_random_large(bh: &mut BenchHarness) {\n+        let mut rng = weak_rng();\n+        bh.iter(|| {\n+            let mut v: ~[BigSortable] = rng.gen_vec(10000);\n+            v.sort();\n+        });\n+        bh.bytes = 10000 * mem::size_of::<BigSortable>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_big_sorted(bh: &mut BenchHarness) {\n+        let mut v = vec::from_fn(10000u, |i| (i, i, i, i));\n+        bh.iter(|| {\n+            v.sort();\n+        });\n+        bh.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n+    }\n }"}]}