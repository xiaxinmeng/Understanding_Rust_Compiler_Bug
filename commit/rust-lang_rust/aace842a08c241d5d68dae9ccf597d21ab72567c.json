{"sha": "aace842a08c241d5d68dae9ccf597d21ab72567c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhY2U4NDJhMDhjMjQxZDVkNjhkYWU5Y2NmNTk3ZDIxYWI3MjU2N2M=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-05-01T10:18:53Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-05-22T02:15:28Z"}, "message": "Get rid of literal_alloc_cache", "tree": {"sha": "d34a2aa8c2cd382d0adf4b583151e15c4533c6d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d34a2aa8c2cd382d0adf4b583151e15c4533c6d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aace842a08c241d5d68dae9ccf597d21ab72567c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aace842a08c241d5d68dae9ccf597d21ab72567c", "html_url": "https://github.com/rust-lang/rust/commit/aace842a08c241d5d68dae9ccf597d21ab72567c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aace842a08c241d5d68dae9ccf597d21ab72567c/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56e541ddf1ee9a4e9d65a3cf6f952c31c3edf5ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/56e541ddf1ee9a4e9d65a3cf6f952c31c3edf5ef", "html_url": "https://github.com/rust-lang/rust/commit/56e541ddf1ee9a4e9d65a3cf6f952c31c3edf5ef"}], "stats": {"total": 91, "additions": 63, "deletions": 28}, "files": [{"sha": "c7fe7ffd9490b43554ea371d4eae1d52834e4aa7", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aace842a08c241d5d68dae9ccf597d21ab72567c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aace842a08c241d5d68dae9ccf597d21ab72567c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=aace842a08c241d5d68dae9ccf597d21ab72567c", "patch": "@@ -960,10 +960,6 @@ struct InterpretInternerInner<'tcx> {\n     /// Inverse map of `statics`\n     /// Used so we don't allocate a new pointer every time we need one\n     static_cache: FxHashMap<DefId, interpret::AllocId>,\n-\n-    /// A cache for basic byte allocations keyed by their contents. This is used to deduplicate\n-    /// allocations for string and bytestring literals.\n-    literal_alloc_cache: FxHashMap<Vec<u8>, interpret::AllocId>,\n }\n \n impl<'tcx> InterpretInterner<'tcx> {\n@@ -1123,22 +1119,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Allocates a byte or string literal for `mir::interpret`\n-    pub fn allocate_cached(self, bytes: &[u8]) -> interpret::AllocId {\n-        // check whether we already allocated this literal or a constant with the same memory\n-        if let Some(&alloc_id) = self.interpret_interner.inner.borrow()\n-                                     .literal_alloc_cache.get(bytes) {\n-            return alloc_id;\n-        }\n+    pub fn allocate_bytes(self, bytes: &[u8]) -> interpret::AllocId {\n         // create an allocation that just contains these bytes\n         let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes);\n         let alloc = self.intern_const_alloc(alloc);\n \n         // the next unique id\n         let id = self.interpret_interner.reserve();\n-        // make the allocation identifiable\n-        self.interpret_interner.inner.borrow_mut().alloc_by_id.insert(id, alloc);\n-        // cache it for the future\n-        self.interpret_interner.inner.borrow_mut().literal_alloc_cache.insert(bytes.to_owned(), id);\n+        self.interpret_interner.intern_at_reserved(id, alloc);\n         id\n     }\n "}, {"sha": "d9797bf4985b442dfeafcb439015530f61850afd", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aace842a08c241d5d68dae9ccf597d21ab72567c/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aace842a08c241d5d68dae9ccf597d21ab72567c/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=aace842a08c241d5d68dae9ccf597d21ab72567c", "patch": "@@ -1860,6 +1860,14 @@ impl<'tcx> Const<'tcx> {\n         }\n     }\n \n+    #[inline]\n+    pub fn to_byval_value(&self) -> Option<Value> {\n+        match self.val {\n+            ConstVal::Value(val) => val.to_byval_value(),\n+            _ => None,\n+        }\n+    }\n+\n     #[inline]\n     pub fn to_primval(&self) -> Option<PrimVal> {\n         match self.val {"}, {"sha": "390b82af48a029ad7fc09a21ed3e6534a43dbb17", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aace842a08c241d5d68dae9ccf597d21ab72567c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aace842a08c241d5d68dae9ccf597d21ab72567c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=aace842a08c241d5d68dae9ccf597d21ab72567c", "patch": "@@ -181,15 +181,15 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         let lit = match *lit {\n             LitKind::Str(ref s, _) => {\n                 let s = s.as_str();\n-                let id = self.tcx.allocate_cached(s.as_bytes());\n+                let id = self.tcx.allocate_bytes(s.as_bytes());\n                 let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n                 ConstValue::ByValPair(\n                     PrimVal::Ptr(ptr),\n                     PrimVal::from_u128(s.len() as u128),\n                 )\n             },\n             LitKind::ByteStr(ref data) => {\n-                let id = self.tcx.allocate_cached(data);\n+                let id = self.tcx.allocate_bytes(data);\n                 let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n                 ConstValue::ByVal(PrimVal::Ptr(ptr))\n             },"}, {"sha": "95ff5c24ecc00d779ea88147f6f931ed1aa05e8a", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 48, "deletions": 9, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/aace842a08c241d5d68dae9ccf597d21ab72567c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aace842a08c241d5d68dae9ccf597d21ab72567c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=aace842a08c241d5d68dae9ccf597d21ab72567c", "patch": "@@ -20,7 +20,7 @@ use interpret::{const_val_field, const_variant_index, self};\n \n use rustc::middle::const_val::ConstVal;\n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n-use rustc::mir::interpret::{PrimVal, GlobalId, ConstValue};\n+use rustc::mir::interpret::{PrimVal, GlobalId, ConstValue, Value};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::ty::layout::Size;\n use rustc::ty::subst::{Substs, Kind};\n@@ -1040,11 +1040,27 @@ pub fn compare_const_vals<'a, 'tcx>(\n     ty: Ty<'tcx>,\n ) -> Option<Ordering> {\n     trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n+\n+    let from_bool = |v: bool| {\n+        if v {\n+            Some(Ordering::Equal)\n+        } else {\n+            None\n+        }\n+    };\n+\n+    let fallback = || from_bool(a == b);\n+\n+    // Use the fallback if any type differs\n+    if a.ty != b.ty || a.ty != ty {\n+        return fallback();\n+    }\n+\n     // FIXME: This should use assert_bits(ty) instead of use_bits\n     // but triggers possibly bugs due to mismatching of arrays and slices\n     if let (Some(a), Some(b)) = (a.to_bits(ty), b.to_bits(ty)) {\n         use ::rustc_apfloat::Float;\n-        match ty.sty {\n+        return match ty.sty {\n             ty::TyFloat(ast::FloatTy::F32) => {\n                 let l = ::rustc_apfloat::ieee::Single::from_bits(a);\n                 let r = ::rustc_apfloat::ieee::Single::from_bits(b);\n@@ -1062,13 +1078,36 @@ pub fn compare_const_vals<'a, 'tcx>(\n             },\n             _ => Some(a.cmp(&b)),\n         }\n-    } else {\n-        if a == b {\n-            Some(Ordering::Equal)\n-        } else {\n-            None\n+    }\n+\n+    if let ty::TyRef(_, rty, _) = ty.sty {\n+        if let ty::TyStr = rty.sty {\n+            match (a.to_byval_value(), b.to_byval_value()) {\n+                (\n+                    Some(Value::ByValPair(\n+                        PrimVal::Ptr(ptr_a),\n+                        PrimVal::Bytes(size_a))\n+                    ),\n+                    Some(Value::ByValPair(\n+                        PrimVal::Ptr(ptr_b),\n+                        PrimVal::Bytes(size_b))\n+                    )\n+                ) if size_a == size_b => {\n+                    if ptr_a.offset == Size::from_bytes(0) && ptr_b.offset == Size::from_bytes(0) {\n+                        let map = tcx.alloc_map.lock();\n+                        let alloc_a = map.unwrap_memory(ptr_a.alloc_id);\n+                        let alloc_b = map.unwrap_memory(ptr_b.alloc_id);\n+                        if alloc_a.bytes.len() as u64 == size_a as u64 {\n+                            return from_bool(alloc_a == alloc_b);\n+                        }\n+                    }\n+                }\n+                _ => (),\n+            }\n         }\n     }\n+\n+    fallback()\n }\n \n // FIXME: Combine with rustc_mir::hair::cx::const_eval_literal\n@@ -1083,15 +1122,15 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n     let lit = match *lit {\n         LitKind::Str(ref s, _) => {\n             let s = s.as_str();\n-            let id = tcx.allocate_cached(s.as_bytes());\n+            let id = tcx.allocate_bytes(s.as_bytes());\n             let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n             ConstValue::ByValPair(\n                 PrimVal::Ptr(ptr),\n                 PrimVal::from_u128(s.len() as u128),\n             )\n         },\n         LitKind::ByteStr(ref data) => {\n-            let id = tcx.allocate_cached(data);\n+            let id = tcx.allocate_bytes(data);\n             let ptr = MemoryPointer::new(id, Size::from_bytes(0));\n             ConstValue::ByVal(PrimVal::Ptr(ptr))\n         },"}, {"sha": "cc55f90883190a522f6aa56b0b23170dc5e1d28e", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aace842a08c241d5d68dae9ccf597d21ab72567c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aace842a08c241d5d68dae9ccf597d21ab72567c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=aace842a08c241d5d68dae9ccf597d21ab72567c", "patch": "@@ -229,7 +229,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     }\n \n     pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n-        let ptr = self.memory.allocate_cached(s.as_bytes());\n+        let ptr = self.memory.allocate_bytes(s.as_bytes());\n         Ok(Value::ByValPair(\n             PrimVal::Ptr(ptr),\n             PrimVal::from_u128(s.len() as u128),"}, {"sha": "0b67e0621f6a29c0c1f8e4033dc9b3790f9e4b8b", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aace842a08c241d5d68dae9ccf597d21ab72567c/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aace842a08c241d5d68dae9ccf597d21ab72567c/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=aace842a08c241d5d68dae9ccf597d21ab72567c", "patch": "@@ -76,8 +76,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         MemoryPointer::new(id, Size::from_bytes(0))\n     }\n \n-    pub fn allocate_cached(&mut self, bytes: &[u8]) -> MemoryPointer {\n-        let id = self.tcx.allocate_cached(bytes);\n+    pub fn allocate_bytes(&mut self, bytes: &[u8]) -> MemoryPointer {\n+        let id = self.tcx.allocate_bytes(bytes);\n         MemoryPointer::new(id, Size::from_bytes(0))\n     }\n "}]}