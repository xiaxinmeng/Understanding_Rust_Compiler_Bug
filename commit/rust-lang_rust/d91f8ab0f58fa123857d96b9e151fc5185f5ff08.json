{"sha": "d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MWY4YWIwZjU4ZmExMjM4NTdkOTZiOWUxNTFmYzUxODVmNWZmMDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-07T19:36:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-07T19:36:18Z"}, "message": "Auto merge of #33487 - steveklabnik:rollup, r=steveklabnik\n\nRollup of 20 pull requests\n\n- Successful merges: #33256, #33283, #33313, #33314, #33326, #33336, #33382, #33384, #33402, #33409, #33410, #33412, #33428, #33430, #33437, #33438, #33439, #33442, #33456, #33459\n- Failed merges:", "tree": {"sha": "4a21bdfb7f514938fb2996d83ac0b97b544464ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a21bdfb7f514938fb2996d83ac0b97b544464ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "html_url": "https://github.com/rust-lang/rust/commit/d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "936b32a514b73c1d3dfcbd9d17818f9f18bf4883", "url": "https://api.github.com/repos/rust-lang/rust/commits/936b32a514b73c1d3dfcbd9d17818f9f18bf4883", "html_url": "https://github.com/rust-lang/rust/commit/936b32a514b73c1d3dfcbd9d17818f9f18bf4883"}, {"sha": "84e27738effd0c44f0dc480753fc0affa56fd4a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/84e27738effd0c44f0dc480753fc0affa56fd4a4", "html_url": "https://github.com/rust-lang/rust/commit/84e27738effd0c44f0dc480753fc0affa56fd4a4"}], "stats": {"total": 629, "additions": 510, "deletions": 119}, "files": [{"sha": "1fcb0bb4debbce6109f33d171084fadfc6704c2f", "filename": "mk/ctags.mk", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/mk%2Fctags.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/mk%2Fctags.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fctags.mk?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -15,14 +15,21 @@\n \n .PHONY: TAGS.emacs TAGS.vi\n \n-CTAGS_LOCATIONS=$(wildcard ${CFG_SRC_DIR}src/lib*)\n+CTAGS_RUSTC_LOCATIONS=$(patsubst ${CFG_SRC_DIR}src/lib%test,, \\\n+\t\t\t\t$(wildcard ${CFG_SRC_DIR}src/lib*)) ${CFG_SRC_DIR}src/libtest\n CTAGS_LOCATIONS=$(patsubst ${CFG_SRC_DIR}src/librust%,, \\\n                 $(patsubst ${CFG_SRC_DIR}src/lib%test,, \\\n \t\t\t\t$(wildcard ${CFG_SRC_DIR}src/lib*))) ${CFG_SRC_DIR}src/libtest\n-CTAGS_OPTS=--options=\"${CFG_SRC_DIR}src/etc/ctags.rust\" --languages=Rust --recurse ${CTAGS_LOCATIONS}\n+CTAGS_OPTS=--options=\"${CFG_SRC_DIR}src/etc/ctags.rust\" --languages=Rust --recurse\n+\n+TAGS.rustc.emacs:\n+\tctags -e -f $@ ${CTAGS_OPTS} ${CTAGS_RUSTC_LOCATIONS}\n \n TAGS.emacs:\n-\tctags -e -f $@ ${CTAGS_OPTS}\n+\tctags -e -f $@ ${CTAGS_OPTS} ${CTAGS_LOCATIONS}\n+\n+TAGS.rustc.vi:\n+\tctags -f $@ ${CTAGS_OPTS} ${CTAGS_RUSTC_LOCATIONS}\n \n TAGS.vi:\n-\tctags -f $@ ${CTAGS_OPTS}\n+\tctags -f $@ ${CTAGS_OPTS} ${CTAGS_LOCATIONS}"}, {"sha": "c2644621c571a64e8cb196dc7eb7e71f9c9d385d", "filename": "mk/platform.mk", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -169,7 +169,7 @@ ifdef CFG_CCACHE_BASEDIR\n   export CCACHE_BASEDIR\n endif\n \n-FIND_COMPILER = $(word 1,$(1:ccache=))\n+FIND_COMPILER = $(strip $(1:ccache=))\n \n define CFG_MAKE_TOOLCHAIN\n   # Prepend the tools with their prefix if cross compiling\n@@ -187,7 +187,7 @@ define CFG_MAKE_TOOLCHAIN\n     endif\n   endif\n \n-  CFG_COMPILE_C_$(1) = '$$(CC_$(1))' \\\n+  CFG_COMPILE_C_$(1) = '$$(call FIND_COMPILER,$$(CC_$(1)))' \\\n         $$(CFLAGS) \\\n         $$(CFG_GCCISH_CFLAGS) \\\n         $$(CFG_GCCISH_CFLAGS_$(1)) \\\n@@ -198,7 +198,7 @@ define CFG_MAKE_TOOLCHAIN\n         $$(CFG_GCCISH_LINK_FLAGS_$(1)) \\\n         $$(CFG_GCCISH_DEF_FLAG_$(1))$$(3) $$(2) \\\n         $$(call CFG_INSTALL_NAME_$(1),$$(4))\n-  CFG_COMPILE_CXX_$(1) = '$$(CXX_$(1))' \\\n+  CFG_COMPILE_CXX_$(1) = '$$(call FIND_COMPILER,$$(CXX_$(1)))' \\\n         $$(CXXFLAGS) \\\n         $$(CFG_GCCISH_CFLAGS) \\\n         $$(CFG_GCCISH_CXXFLAGS) \\"}, {"sha": "cc712413d3b1c080313585b35c1bedaa2aca6bbb", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -635,8 +635,8 @@ CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3) = \\\n         --host-rustcflags \"$(RUSTC_FLAGS_$(3)) $$(CTEST_RUSTC_FLAGS) -L $$(RT_OUTPUT_DIR_$(3))\" \\\n         --lldb-python-dir=$(CFG_LLDB_PYTHON_DIR) \\\n         --target-rustcflags \"$(RUSTC_FLAGS_$(2)) $$(CTEST_RUSTC_FLAGS) -L $$(RT_OUTPUT_DIR_$(2))\" \\\n-\t--cc '$$(CC_$(2))' \\\n-\t--cxx '$$(CXX_$(2))' \\\n+\t--cc '$$(call FIND_COMPILER,$$(CC_$(2)))' \\\n+\t--cxx '$$(call FIND_COMPILER,$$(CXX_$(2)))' \\\n \t--cflags \"$$(CFG_GCCISH_CFLAGS_$(2))\" \\\n \t--llvm-components \"$$(LLVM_ALL_COMPONENTS_$(2))\" \\\n \t--llvm-cxxflags \"$$(LLVM_CXXFLAGS_$(2))\" \\"}, {"sha": "4558e6f049432dff4b0cdd8e690deeae4adb7603", "filename": "src/bootstrap/build/job.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Fbootstrap%2Fbuild%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Fbootstrap%2Fbuild%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fjob.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -54,7 +54,7 @@ pub unsafe fn setup() {\n \n     // Indicate that when all handles to the job object are gone that all\n     // process in the object should be killed. Note that this includes our\n-    // entire process tree by default because we've added ourselves and and our\n+    // entire process tree by default because we've added ourselves and our\n     // children will reside in the job by default.\n     let mut info = mem::zeroed::<JOBOBJECT_EXTENDED_LIMIT_INFORMATION>();\n     info.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;"}, {"sha": "397abfe563c1f7ff18466bf9ed254fc1729d0378", "filename": "src/doc/reference.md", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -2063,33 +2063,41 @@ arbitrarily complex configurations through nesting.\n \n The following configurations must be defined by the implementation:\n \n-* `debug_assertions` - Enabled by default when compiling without optimizations.\n-  This can be used to enable extra debugging code in development but not in\n-  production.  For example, it controls the behavior of the standard library's\n-  `debug_assert!` macro.\n-* `target_arch = \"...\"` - Target CPU architecture, such as `\"x86\"`, `\"x86_64\"`\n-  `\"mips\"`, `\"powerpc\"`, `\"powerpc64\"`, `\"arm\"`, or `\"aarch64\"`.\n-* `target_endian = \"...\"` - Endianness of the target CPU, either `\"little\"` or\n-  `\"big\"`.\n-* `target_env = \"..\"` - An option provided by the compiler by default\n-  describing the runtime environment of the target platform. Some examples of\n-  this are `musl` for builds targeting the MUSL libc implementation, `msvc` for\n-  Windows builds targeting MSVC, and `gnu` frequently the rest of the time. This\n-  option may also be blank on some platforms.\n+* `target_arch = \"...\"` - Target CPU architecture, such as `\"x86\"`,\n+  `\"x86_64\"` `\"mips\"`, `\"powerpc\"`, `\"powerpc64\"`, `\"arm\"`, or\n+  `\"aarch64\"`. This value is closely related to the first element of\n+  the platform target triple, though it is not identical.\n+* `target_os = \"...\"` - Operating system of the target, examples\n+  include `\"windows\"`, `\"macos\"`, `\"ios\"`, `\"linux\"`, `\"android\"`,\n+  `\"freebsd\"`, `\"dragonfly\"`, `\"bitrig\"` , `\"openbsd\"` or\n+  `\"netbsd\"`. This value is closely related to the second and third\n+  element of the platform target triple, though it is not identical.\n * `target_family = \"...\"` - Operating system family of the target, e. g.\n   `\"unix\"` or `\"windows\"`. The value of this configuration option is defined\n   as a configuration itself, like `unix` or `windows`.\n-* `target_os = \"...\"` - Operating system of the target, examples include\n-  `\"windows\"`, `\"macos\"`, `\"ios\"`, `\"linux\"`, `\"android\"`, `\"freebsd\"`, `\"dragonfly\"`,\n-  `\"bitrig\"` , `\"openbsd\"` or `\"netbsd\"`.\n+* `unix` - See `target_family`.\n+* `windows` - See `target_family`.\n+* `target_env = \"..\"` - Further disambiguates the target platform with\n+  information about the ABI/libc. Presently this value is either\n+  `\"gnu\"`, `\"msvc\"`, `\"musl\"`, or the empty string. For historical\n+  reasons this value has only been defined as non-empty when needed\n+  for disambiguation. Thus on many GNU platforms this value will be\n+  empty. This value is closely related to the fourth element of the\n+  platform target triple, though it is not identical. For example,\n+  embedded ABIs such as `gnueabihf` will simply define `target_env` as\n+  `\"gnu\"`.\n+* `target_endian = \"...\"` - Endianness of the target CPU, either `\"little\"` or\n+  `\"big\"`.\n * `target_pointer_width = \"...\"` - Target pointer width in bits. This is set\n   to `\"32\"` for targets with 32-bit pointers, and likewise set to `\"64\"` for\n   64-bit pointers.\n * `target_vendor = \"...\"` - Vendor of the target, for example `apple`, `pc`, or\n   simply `\"unknown\"`.\n * `test` - Enabled when compiling the test harness (using the `--test` flag).\n-* `unix` - See `target_family`.\n-* `windows` - See `target_family`.\n+* `debug_assertions` - Enabled by default when compiling without optimizations.\n+  This can be used to enable extra debugging code in development but not in\n+  production.  For example, it controls the behavior of the standard library's\n+  `debug_assert!` macro.\n \n You can also set another attribute based on a `cfg` variable with `cfg_attr`:\n "}, {"sha": "0f77ebb3c57454a10783cc60635432f66d587361", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -419,8 +419,8 @@ impl<T> [T] {\n     ///\n     /// ```rust\n     /// let v = &[1, 2, 3, 4, 5];\n-    /// for win in v.chunks(2) {\n-    ///     println!(\"{:?}\", win);\n+    /// for chunk in v.chunks(2) {\n+    ///     println!(\"{:?}\", chunk);\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "b80f77c0d25a9c7afec7135e0ae9146e875fdff4", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -214,7 +214,7 @@ pub trait Iterator {\n     /// Like most indexing operations, the count starts from zero, so `nth(0)`\n     /// returns the first value, `nth(1)` the second, and so on.\n     ///\n-    /// `nth()` will return `None` if `n` is larger than the length of the\n+    /// `nth()` will return `None` if `n` is greater than or equal to the length of the\n     /// iterator.\n     ///\n     /// # Examples\n@@ -237,7 +237,7 @@ pub trait Iterator {\n     /// assert_eq!(iter.nth(1), None);\n     /// ```\n     ///\n-    /// Returning `None` if there are less than `n` elements:\n+    /// Returning `None` if there are less than `n + 1` elements:\n     ///\n     /// ```\n     /// let a = [1, 2, 3];"}, {"sha": "af4ac482cf7d09a35c703f8889049a914dbc7f3b", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -37,6 +37,17 @@ use slice::SliceExt;\n /// `wrapping_add`, or through the `Wrapping<T>` type, which says that\n /// all standard arithmetic operations on the underlying value are\n /// intended to have wrapping semantics.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::num::Wrapping;\n+///\n+/// let zero = Wrapping(0u32);\n+/// let one = Wrapping(1u32);\n+///\n+/// assert_eq!(std::u32::MAX, (zero - one).0);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Default, Hash)]\n pub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);"}, {"sha": "b15e0e33b84026cdc384685b8d1e81cf4528290e", "filename": "src/librustc/dep_graph/thread.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -176,6 +176,9 @@ pub fn main(swap_in: Receiver<Vec<DepMessage>>,\n                 DepMessage::Query => query_out.send(edges.query()).unwrap(),\n             }\n         }\n-        swap_out.send(messages).unwrap();\n+        if let Err(_) = swap_out.send(messages) {\n+            // the receiver must have been dropped already\n+            break;\n+        }\n     }\n }"}, {"sha": "1a2c1b9a09528850d7e15ef3ac6a0039e545501f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -1355,7 +1355,7 @@ pub mod nightly_options {\n                     early_error(ErrorOutputType::default(), &msg);\n                 }\n                 OptionStability::UnstableButNotReally => {\n-                    let msg = format!(\"the option `{}` is is unstable and should \\\n+                    let msg = format!(\"the option `{}` is unstable and should \\\n                                        only be used on the nightly compiler, but \\\n                                        it is currently accepted for backwards \\\n                                        compatibility; this will soon change, \\"}, {"sha": "7fb13f49cb4a5986419caa0868a56f027de9fd21", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -40,7 +40,7 @@ use std::rc::Rc;\n pub enum ProjectionMode {\n     /// FIXME (#32205)\n     /// At coherence-checking time, we're still constructing the\n-    /// specialization graph, and thus we only project project\n+    /// specialization graph, and thus we only project\n     /// non-`default` associated types that are defined directly in\n     /// the applicable impl. (This behavior should be improved over\n     /// time, to allow for successful projections modulo cycles"}, {"sha": "f194afaa8176286bfee8e30778704fb1e287abc6", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -176,7 +176,7 @@ impl<'tcx> TraitDef<'tcx> {\n     /// Records a trait-to-implementation mapping for a non-local impl.\n     ///\n     /// The `parent_impl` is the immediately-less-specialized impl, or the\n-    /// trait's def ID if the impl is is not a specialization -- information that\n+    /// trait's def ID if the impl is not a specialization -- information that\n     /// should be pulled from the metadata.\n     pub fn record_remote_impl(&self,\n                               tcx: &TyCtxt<'tcx>,"}, {"sha": "e362e295b414a7136cfc2e364066691cb1c07f34", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -272,7 +272,7 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n     /// into `self.out`.\n     fn compute_projection(&mut self, data: ty::ProjectionTy<'tcx>) {\n         // A projection is well-formed if (a) the trait ref itself is\n-        // WF WF and (b) the trait-ref holds.  (It may also be\n+        // WF and (b) the trait-ref holds.  (It may also be\n         // normalizable and be WF that way.)\n \n         self.compute_trait_ref(&data.trait_ref);"}, {"sha": "c2b86ce28f6c6e59654e562ea9f5978b4d53165b", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -202,7 +202,7 @@ pub struct TargetOptions {\n     pub post_link_args: Vec<String>,\n \n     /// Default CPU to pass to LLVM. Corresponds to `llc -mcpu=$cpu`. Defaults\n-    /// to \"default\".\n+    /// to \"generic\".\n     pub cpu: String,\n     /// Default target features to pass to LLVM. These features will *always* be\n     /// passed, and cannot be disabled even via `-C`. Corresponds to `llc"}, {"sha": "03fb5260c39920a5246a59ec2bf53717c055812a", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 148, "deletions": 2, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -286,6 +286,70 @@ You can read more about cell types in the API documentation:\n https://doc.rust-lang.org/std/cell/\n \"##,\n \n+E0389: r##\"\n+An attempt was made to mutate data using a non-mutable reference. This\n+commonly occurs when attempting to assign to a non-mutable reference of a\n+mutable reference (`&(&mut T)`).\n+\n+Example of erroneous code:\n+\n+```compile_fail\n+struct FancyNum {\n+    num: u8\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+    let fancy_ref = &(&mut fancy);\n+    fancy_ref.num = 6; // error: cannot assign to data in a `&` reference\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```\n+\n+Here, `&mut fancy` is mutable, but `&(&mut fancy)` is not. Creating an\n+immutable reference to a value borrows it immutably. There can be multiple\n+references of type `&(&mut T)` that point to the same value, so they must be\n+immutable to prevent multiple mutable references to the same value.\n+\n+To fix this, either remove the outer reference:\n+\n+```\n+struct FancyNum {\n+    num: u8\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+\n+    let fancy_ref = &mut fancy;\n+    // `fancy_ref` is now &mut FancyNum, rather than &(&mut FancyNum)\n+\n+    fancy_ref.num = 6; // No error!\n+\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```\n+\n+Or make the outer reference mutable:\n+\n+```\n+struct FancyNum {\n+    num: u8\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+\n+    let fancy_ref = &mut (&mut fancy);\n+    // `fancy_ref` is now &mut(&mut FancyNum), rather than &(&mut FancyNum)\n+\n+    fancy_ref.num = 6; // No error!\n+\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```\n+\"##,\n+\n E0499: r##\"\n A variable was borrowed as mutable more than once. Erroneous code example:\n \n@@ -390,6 +454,90 @@ fn foo(a: &mut i32) {\n ```\n \"##,\n \n+E0506: r##\"\n+This error occurs when an attempt is made to assign to a borrowed value.\n+\n+Example of erroneous code:\n+\n+```compile_fail\n+struct FancyNum {\n+    num: u8\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+    let fancy_ref = &fancy_num;\n+    fancy_num = FancyNum { num: 6 };\n+    // error: cannot assign to `fancy_num` because it is borrowed\n+\n+    println!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n+}\n+```\n+\n+Because `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\n+be assigned to a new value as it would invalidate the reference.\n+\n+Alternatively, we can move out of `fancy_num` into a second `fancy_num`:\n+\n+```\n+struct FancyNum {\n+    num: u8\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+    let moved_num = fancy_num;\n+    fancy_num = FancyNum { num: 6 };\n+\n+    println!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n+}\n+```\n+\n+If the value has to be borrowed, try limiting the lifetime of the borrow using\n+a scoped block:\n+\n+```\n+struct FancyNum {\n+    num: u8\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+\n+    {\n+        let fancy_ref = &fancy_num;\n+        println!(\"Ref: {}\", fancy_ref.num);\n+    }\n+\n+    // Works because `fancy_ref` is no longer in scope\n+    fancy_num = FancyNum { num: 6 };\n+    println!(\"Num: {}\", fancy_num.num);\n+}\n+```\n+\n+Or by moving the reference into a function:\n+\n+```\n+struct FancyNum {\n+    num: u8\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+\n+    print_fancy_ref(&fancy_num);\n+\n+    // Works because function borrow has ended\n+    fancy_num = FancyNum { num: 6 };\n+    println!(\"Num: {}\", fancy_num.num);\n+}\n+\n+fn print_fancy_ref(fancy_ref: &FancyNum){\n+    println!(\"Ref: {}\", fancy_ref.num);\n+}\n+```\n+\"##,\n+\n E0507: r##\"\n You tried to move out of a value which was borrowed. Erroneous code example:\n \n@@ -510,13 +658,11 @@ http://doc.rust-lang.org/stable/book/references-and-borrowing.html\n register_diagnostics! {\n     E0385, // {} in an aliasable location\n     E0388, // {} in a static location\n-    E0389, // {} in a `&` reference\n     E0500, // closure requires unique access to `..` but .. is already borrowed\n     E0502, // cannot borrow `..`.. as .. because .. is also borrowed as ...\n     E0503, // cannot use `..` because it was mutably borrowed\n     E0504, // cannot move `..` into closure because it is borrowed\n     E0505, // cannot move out of `..` because it is borrowed\n-    E0506, // cannot assign to `..` because it is borrowed\n     E0508, // cannot move out of type `..`, a non-copy fixed-size array\n     E0509, // cannot move out of type `..`, which defines the `Drop` trait\n     E0524, // two closures require unique access to `..` at the same time"}, {"sha": "3b25104437aee3e2d831c8a76e71f20b9c213c32", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -352,7 +352,13 @@ fn handle_explain(code: &str,\n     match descriptions.find_description(&normalised) {\n         Some(ref description) => {\n             // Slice off the leading newline and print.\n-            print!(\"{}\", &description[1..]);\n+            print!(\"{}\", &(&description[1..]).split(\"\\n\").map(|x| {\n+                format!(\"{}\\n\", if x.starts_with(\"```\") {\n+                    \"```\"\n+                } else {\n+                    x\n+                })\n+            }).collect::<String>());\n         }\n         None => {\n             early_error(output, &format!(\"no extended information for {}\", code));"}, {"sha": "7c5ce371ee919776caefdf37bff79f6bed993e01", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -1327,7 +1327,7 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     //          %ret = call i32 @the_real_filter_function(%ehptrs, %arg)\n     //          ret i32 %ret\n     //\n-    // The recoverfp intrinsic is used to recover the frame frame pointer of the\n+    // The recoverfp intrinsic is used to recover the frame pointer of the\n     // `rust_try_fn` function, which is then in turn passed to the\n     // `localrecover` intrinsic (pairing with the `localescape` intrinsic\n     // mentioned above). Putting all this together means that we now have a"}, {"sha": "a3200e69e3c42fc9e3a9352e709e592c16182e83", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 59, "deletions": 39, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -145,14 +145,19 @@ pub struct Implementor {\n /// Metadata about implementations for a type.\n #[derive(Clone)]\n pub struct Impl {\n-    pub impl_: clean::Impl,\n-    pub dox: Option<String>,\n-    pub stability: Option<clean::Stability>,\n+    pub impl_item: clean::Item,\n }\n \n impl Impl {\n+    fn inner_impl(&self) -> &clean::Impl {\n+        match self.impl_item.inner {\n+            clean::ImplItem(ref impl_) => impl_,\n+            _ => panic!(\"non-impl item found in impl\")\n+        }\n+    }\n+\n     fn trait_did(&self) -> Option<DefId> {\n-        self.impl_.trait_.def_id()\n+        self.inner_impl().trait_.def_id()\n     }\n }\n \n@@ -1189,31 +1194,34 @@ impl DocFolder for Cache {\n         // Once we've recursively found all the generics, then hoard off all the\n         // implementations elsewhere\n         let ret = self.fold_item_recur(item).and_then(|item| {\n-            if let clean::Item { attrs, inner: clean::ImplItem(i), .. } = item {\n+            if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n                 // Figure out the id of this impl. This may map to a\n                 // primitive rather than always to a struct/enum.\n-                let did = match i.for_ {\n-                    clean::ResolvedPath { did, .. } |\n-                    clean::BorrowedRef {\n-                        type_: box clean::ResolvedPath { did, .. }, ..\n-                    } => {\n-                        Some(did)\n-                    }\n-                    ref t => {\n-                        t.primitive_type().and_then(|t| {\n-                            self.primitive_locations.get(&t).map(|n| {\n-                                let id = t.to_def_index();\n-                                DefId { krate: *n, index: id }\n+                // Note: matching twice to restrict the lifetime of the `i` borrow.\n+                let did = if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n+                    match i.for_ {\n+                        clean::ResolvedPath { did, .. } |\n+                        clean::BorrowedRef {\n+                            type_: box clean::ResolvedPath { did, .. }, ..\n+                        } => {\n+                            Some(did)\n+                        }\n+                        ref t => {\n+                            t.primitive_type().and_then(|t| {\n+                                self.primitive_locations.get(&t).map(|n| {\n+                                    let id = t.to_def_index();\n+                                    DefId { krate: *n, index: id }\n+                                })\n                             })\n-                        })\n+                        }\n                     }\n+                } else {\n+                    unreachable!()\n                 };\n                 if !self.seen_mod {\n                     if let Some(did) = did {\n                         self.impls.entry(did).or_insert(vec![]).push(Impl {\n-                            impl_: i,\n-                            dox: attrs.value(\"doc\").map(|s|s.to_owned()),\n-                            stability: item.stability.clone(),\n+                            impl_item: item,\n                         });\n                     }\n                 }\n@@ -1510,11 +1518,15 @@ impl<'a> Item<'a> {\n         // located, then we return `None`.\n         } else {\n             let cache = cache();\n-            let path = &cache.external_paths[&self.item.def_id];\n-            let root = match cache.extern_locations[&self.item.def_id.krate] {\n-                (_, Remote(ref s)) => s.to_string(),\n-                (_, Local) => self.cx.root_path.clone(),\n-                (_, Unknown) => return None,\n+            let path = match cache.external_paths.get(&self.item.def_id) {\n+                Some(path) => path,\n+                None => return None,\n+            };\n+            let root = match cache.extern_locations.get(&self.item.def_id.krate) {\n+                Some(&(_, Remote(ref s))) => s.to_string(),\n+                Some(&(_, Local)) => self.cx.root_path.clone(),\n+                Some(&(_, Unknown)) => return None,\n+                None => return None,\n             };\n             Some(format!(\"{root}{path}/{file}?gotosrc={goto}\",\n                          root = root,\n@@ -2449,7 +2461,7 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n         None => return Ok(()),\n     };\n     let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| {\n-        i.impl_.trait_.is_none()\n+        i.inner_impl().trait_.is_none()\n     });\n     if !non_trait.is_empty() {\n         let render_header = match what {\n@@ -2473,19 +2485,19 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n     }\n     if !traits.is_empty() {\n         let deref_impl = traits.iter().find(|t| {\n-            t.impl_.trait_.def_id() == c.deref_trait_did\n+            t.inner_impl().trait_.def_id() == c.deref_trait_did\n         });\n         if let Some(impl_) = deref_impl {\n             render_deref_methods(w, cx, impl_, containing_item)?;\n         }\n         write!(w, \"<h2 id='implementations'>Trait \\\n                    Implementations</h2>\")?;\n         let (derived, manual): (Vec<_>, Vec<&Impl>) = traits.iter().partition(|i| {\n-            i.impl_.derived\n+            i.inner_impl().derived\n         });\n         for i in &manual {\n             let did = i.trait_did().unwrap();\n-            let assoc_link = AssocItemLink::GotoSource(did, &i.impl_.provided_trait_methods);\n+            let assoc_link = AssocItemLink::GotoSource(did, &i.inner_impl().provided_trait_methods);\n             render_impl(w, cx, i, assoc_link, true, containing_item.stable_since())?;\n         }\n         if !derived.is_empty() {\n@@ -2494,7 +2506,8 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n                        </h3>\")?;\n             for i in &derived {\n                 let did = i.trait_did().unwrap();\n-                let assoc_link = AssocItemLink::GotoSource(did, &i.impl_.provided_trait_methods);\n+                let assoc_link = AssocItemLink::GotoSource(did,\n+                                                           &i.inner_impl().provided_trait_methods);\n                 render_impl(w, cx, i, assoc_link, true, containing_item.stable_since())?;\n             }\n         }\n@@ -2504,8 +2517,8 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n \n fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n                         container_item: &clean::Item) -> fmt::Result {\n-    let deref_type = impl_.impl_.trait_.as_ref().unwrap();\n-    let target = impl_.impl_.items.iter().filter_map(|item| {\n+    let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n+    let target = impl_.inner_impl().items.iter().filter_map(|item| {\n         match item.inner {\n             clean::TypedefItem(ref t, true) => Some(&t.type_),\n             _ => None,\n@@ -2531,11 +2544,18 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLink,\n                render_header: bool, outer_version: Option<&str>) -> fmt::Result {\n     if render_header {\n-        write!(w, \"<h3 class='impl'><code>{}</code>\", i.impl_)?;\n-        let since = i.stability.as_ref().map(|s| &s.since[..]);\n+        write!(w, \"<h3 class='impl'><span class='in-band'><code>{}</code>\", i.inner_impl())?;\n+        let since = i.impl_item.stability.as_ref().map(|s| &s.since[..]);\n         render_stability_since_raw(w, since, outer_version)?;\n-        write!(w, \"</h3>\")?;\n-        if let Some(ref dox) = i.dox {\n+        write!(w, \"</span><span class='out-of-band'>\")?;\n+        if let Some(l) = (Item { item: &i.impl_item, cx: cx }).href() {\n+            write!(w, \"<a id='src-{}' class='srclink' \\\n+                       href='{}' title='{}'>[src]</a>\",\n+                   i.impl_item.def_id.index.as_usize(), l, \"goto source code\")?;\n+        }\n+        write!(w, \"</span>\")?;\n+        write!(w, \"</h3>\\n\")?;\n+        if let Some(ref dox) = i.impl_item.attrs.value(\"doc\") {\n             write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox))?;\n         }\n     }\n@@ -2601,7 +2621,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n     }\n \n     write!(w, \"<div class='impl-items'>\")?;\n-    for trait_item in &i.impl_.items {\n+    for trait_item in &i.inner_impl().items {\n         doctraititem(w, cx, trait_item, link, render_header, false, outer_version)?;\n     }\n \n@@ -2629,7 +2649,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n     // default items which weren't overridden in the implementation block.\n     if let Some(did) = i.trait_did() {\n         if let Some(t) = cache().traits.get(&did) {\n-            render_default_items(w, cx, t, &i.impl_, render_header, outer_version)?;\n+            render_default_items(w, cx, t, &i.inner_impl(), render_header, outer_version)?;\n         }\n     }\n     write!(w, \"</div>\")?;"}, {"sha": "a058337a50afda4e2607ca3f9cd83e1511b0dfd9", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -182,11 +182,10 @@\n //!\n //! # fn foo() -> io::Result<()> {\n //! let f = try!(File::open(\"foo.txt\"));\n-//! let mut reader = BufReader::new(f);\n+//! let reader = BufReader::new(f);\n //!\n //! for line in reader.lines() {\n-//!     let line = try!(line);\n-//!     println!(\"{}\", line);\n+//!     println!(\"{}\", try!(line));\n //! }\n //!\n //! # Ok(())"}, {"sha": "45b85d600a65639e057e14de5470b06992014f08", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -89,15 +89,15 @@ impl Ipv4Addr {\n \n     /// Returns true if this is a loopback address (127.0.0.0/8).\n     ///\n-    /// This property is defined by RFC 6890\n+    /// This property is defined by RFC 6890.\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_loopback(&self) -> bool {\n         self.octets()[0] == 127\n     }\n \n     /// Returns true if this is a private address.\n     ///\n-    /// The private address ranges are defined in RFC1918 and include:\n+    /// The private address ranges are defined in RFC 1918 and include:\n     ///\n     ///  - 10.0.0.0/8\n     ///  - 172.16.0.0/12\n@@ -114,7 +114,7 @@ impl Ipv4Addr {\n \n     /// Returns true if the address is link-local (169.254.0.0/16).\n     ///\n-    /// This property is defined by RFC 6890\n+    /// This property is defined by RFC 6890.\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_link_local(&self) -> bool {\n         self.octets()[0] == 169 && self.octets()[1] == 254\n@@ -140,7 +140,7 @@ impl Ipv4Addr {\n     /// Returns true if this is a multicast address.\n     ///\n     /// Multicast addresses have a most significant octet between 224 and 239,\n-    /// and is defined by RFC 5771\n+    /// and is defined by RFC 5771.\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_multicast(&self) -> bool {\n         self.octets()[0] >= 224 && self.octets()[0] <= 239\n@@ -354,7 +354,7 @@ impl Ipv6Addr {\n \n     /// Returns true if this is a unique local address (IPv6).\n     ///\n-    /// Unique local addresses are defined in RFC4193 and have the form fc00::/7.\n+    /// Unique local addresses are defined in RFC 4193 and have the form fc00::/7.\n     pub fn is_unique_local(&self) -> bool {\n         (self.segments()[0] & 0xfe00) == 0xfc00\n     }\n@@ -371,7 +371,7 @@ impl Ipv6Addr {\n     }\n \n     /// Returns true if this is an address reserved for documentation\n-    /// This is defined to be 2001:db8::/32 in RFC RFC 3849\n+    /// This is defined to be 2001:db8::/32 in RFC 3849.\n     pub fn is_documentation(&self) -> bool {\n         (self.segments()[0] == 0x2001) && (self.segments()[1] == 0xdb8)\n     }"}, {"sha": "7a86e726b3a6ae3a33f6aac26519fdac33146e41", "filename": "src/libstd/process.rs", "status": "modified", "additions": 196, "deletions": 4, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -215,19 +215,58 @@ impl Command {\n     ///\n     /// Builder methods are provided to change these defaults and\n     /// otherwise configure the process.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// Command::new(\"sh\")\n+    ///         .spawn()\n+    ///         .expect(\"sh command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn new<S: AsRef<OsStr>>(program: S) -> Command {\n         Command { inner: imp::Command::new(program.as_ref()) }\n     }\n \n     /// Add an argument to pass to the program.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .arg(\"-l\")\n+    ///         .arg(\"-a\")\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn arg<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command {\n         self.inner.arg(arg.as_ref());\n         self\n     }\n \n     /// Add multiple arguments to pass to the program.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .args(&[\"-l\", \"-a\"])\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn args<S: AsRef<OsStr>>(&mut self, args: &[S]) -> &mut Command {\n         for arg in args {\n@@ -240,6 +279,19 @@ impl Command {\n     ///\n     /// Note that environment variable names are case-insensitive (but case-preserving) on Windows,\n     /// and case-sensitive on all other platforms.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .env(\"PATH\", \"/bin\")\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn env<K, V>(&mut self, key: K, val: V) -> &mut Command\n         where K: AsRef<OsStr>, V: AsRef<OsStr>\n@@ -249,41 +301,119 @@ impl Command {\n     }\n \n     /// Removes an environment variable mapping.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .env_remove(\"PATH\")\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn env_remove<K: AsRef<OsStr>>(&mut self, key: K) -> &mut Command {\n         self.inner.env_remove(key.as_ref());\n         self\n     }\n \n     /// Clears the entire environment map for the child process.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .env_clear()\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn env_clear(&mut self) -> &mut Command {\n         self.inner.env_clear();\n         self\n     }\n \n     /// Sets the working directory for the child process.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .current_dir(\"/bin\")\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn current_dir<P: AsRef<Path>>(&mut self, dir: P) -> &mut Command {\n         self.inner.cwd(dir.as_ref().as_ref());\n         self\n     }\n \n     /// Configuration for the child process's stdin handle (file descriptor 0).\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::{Command, Stdio};\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .stdin(Stdio::null())\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stdin(&mut self, cfg: Stdio) -> &mut Command {\n         self.inner.stdin(cfg.0);\n         self\n     }\n \n     /// Configuration for the child process's stdout handle (file descriptor 1).\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::{Command, Stdio};\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .stdout(Stdio::null())\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stdout(&mut self, cfg: Stdio) -> &mut Command {\n         self.inner.stdout(cfg.0);\n         self\n     }\n \n     /// Configuration for the child process's stderr handle (file descriptor 2).\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::{Command, Stdio};\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .stderr(Stdio::null())\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stderr(&mut self, cfg: Stdio) -> &mut Command {\n         self.inner.stderr(cfg.0);\n@@ -293,6 +423,18 @@ impl Command {\n     /// Executes the command as a child process, returning a handle to it.\n     ///\n     /// By default, stdin, stdout and stderr are inherited from the parent.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn spawn(&mut self) -> io::Result<Child> {\n         self.inner.spawn(imp::Stdio::Inherit, true).map(Child::from_inner)\n@@ -308,8 +450,10 @@ impl Command {\n     ///\n     /// ```should_panic\n     /// use std::process::Command;\n-    /// let output = Command::new(\"/bin/cat\").arg(\"file.txt\").output()\n-    ///     .expect(\"failed to execute process\");\n+    /// let output = Command::new(\"/bin/cat\")\n+    ///                      .arg(\"file.txt\")\n+    ///                      .output()\n+    ///                      .expect(\"failed to execute process\");\n     ///\n     /// println!(\"status: {}\", output.status);\n     /// println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n@@ -333,8 +477,10 @@ impl Command {\n     /// ```should_panic\n     /// use std::process::Command;\n     ///\n-    /// let status = Command::new(\"/bin/cat\").arg(\"file.txt\").status()\n-    ///     .expect(\"failed to execute process\");\n+    /// let status = Command::new(\"/bin/cat\")\n+    ///                      .arg(\"file.txt\")\n+    ///                      .status()\n+    ///                      .expect(\"failed to execute process\");\n     ///\n     /// println!(\"process exited with: {}\", status);\n     ///\n@@ -469,12 +615,42 @@ impl fmt::Display for ExitStatus {\n impl Child {\n     /// Forces the child to exit. This is equivalent to sending a\n     /// SIGKILL on unix platforms.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// let mut command = Command::new(\"yes\");\n+    /// if let Ok(mut child) = command.spawn() {\n+    ///     child.kill().expect(\"command wasn't running\");\n+    /// } else {\n+    ///     println!(\"yes command didn't start\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn kill(&mut self) -> io::Result<()> {\n         self.handle.kill()\n     }\n \n     /// Returns the OS-assigned process identifier associated with this child.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// let mut command = Command::new(\"ls\");\n+    /// if let Ok(child) = command.spawn() {\n+    ///     println!(\"Child's id is {}\", child.id());\n+    /// } else {\n+    ///     println!(\"ls command didn't start\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"process_id\", since = \"1.3.0\")]\n     pub fn id(&self) -> u32 {\n         self.handle.id()\n@@ -488,6 +664,22 @@ impl Child {\n     /// before waiting. This helps avoid deadlock: it ensures that the\n     /// child does not block waiting for input from the parent, while\n     /// the parent waits for the child to exit.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// let mut command = Command::new(\"ls\");\n+    /// if let Ok(mut child) = command.spawn() {\n+    ///     child.wait().expect(\"command wasn't running\");\n+    ///     println!(\"Child has finished its execution!\");\n+    /// } else {\n+    ///     println!(\"ls command didn't start\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn wait(&mut self) -> io::Result<ExitStatus> {\n         drop(self.stdin.take());"}, {"sha": "b1267acdee61a177fdd9b9fa8a077d613d58efab", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -71,7 +71,7 @@ impl Barrier {\n         }\n     }\n \n-    /// Blocks the current thread until all threads has rendezvoused here.\n+    /// Blocks the current thread until all threads have rendezvoused here.\n     ///\n     /// Barriers are re-usable after all threads have rendezvoused once, and can\n     /// be used continuously."}, {"sha": "cfb8ee16cb069b53f07f30aed18ae89841bd7987", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -38,8 +38,8 @@ use sys_common::rwlock as sys;\n ///\n /// # Poisoning\n ///\n-/// RwLocks, like Mutexes, will become poisoned on panics. Note, however, that\n-/// an RwLock may only be poisoned if a panic occurs while it is locked\n+/// An `RwLock`, like `Mutex`, will become poisoned on a panic. Note, however,\n+/// that an `RwLock` may only be poisoned if a panic occurs while it is locked\n /// exclusively (write mode). If a panic occurs in any reader, then the lock\n /// will not be poisoned.\n ///"}, {"sha": "0500480add22fed74304440c748ac4c78cb0fadc", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -147,7 +147,7 @@ impl Command {\n         let new_key = pair_to_key(key, val, &mut self.saw_nul);\n         let (map, envp) = self.init_env_map();\n \n-        // If `key` is already present then we we just update `envp` in place\n+        // If `key` is already present then we just update `envp` in place\n         // (and store the owned value), but if it's not there we override the\n         // trailing NULL pointer, add a new NULL pointer, and store where we\n         // were located."}, {"sha": "2f0dec759b3d57f175473da5425e759bb6eff7c5", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -13,7 +13,8 @@\n //! ## The threading model\n //!\n //! An executing Rust program consists of a collection of native OS threads,\n-//! each with their own stack and local state.\n+//! each with their own stack and local state. Threads can be named, and\n+//! provide some built-in support for low-level synchronization.\n //!\n //! Communication between threads can be done through\n //! [channels](../../std/sync/mpsc/index.html), Rust's message-passing\n@@ -37,20 +38,6 @@\n //! convenient facilities for automatically waiting for the termination of a\n //! child thread (i.e., join).\n //!\n-//! ## The `Thread` type\n-//!\n-//! Threads are represented via the `Thread` type, which you can\n-//! get in one of two ways:\n-//!\n-//! * By spawning a new thread, e.g. using the `thread::spawn` function.\n-//! * By requesting the current thread, using the `thread::current` function.\n-//!\n-//! Threads can be named, and provide some built-in support for low-level\n-//! synchronization (described below).\n-//!\n-//! The `thread::current()` function is available even for threads not spawned\n-//! by the APIs of this module.\n-//!\n //! ## Spawning a thread\n //!\n //! A new thread can be spawned using the `thread::spawn` function:\n@@ -99,6 +86,18 @@\n //! });\n //! ```\n //!\n+//! ## The `Thread` type\n+//!\n+//! Threads are represented via the `Thread` type, which you can get in one of\n+//! two ways:\n+//!\n+//! * By spawning a new thread, e.g. using the `thread::spawn` function, and\n+//!   calling `thread()` on the `JoinHandle`.\n+//! * By requesting the current thread, using the `thread::current` function.\n+//!\n+//! The `thread::current()` function is available even for threads not spawned\n+//! by the APIs of this module.\n+//!\n //! ## Blocking support: park and unpark\n //!\n //! Every thread is equipped with some basic low-level blocking support, via the"}, {"sha": "48368cc025c85cb7498a16aad0ef38edcaf8fba2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -6013,7 +6013,7 @@ impl<'a> Parser<'a> {\n             // FOREIGN STATIC ITEM\n             return Ok(Some(self.parse_item_foreign_static(visibility, lo, attrs)?));\n         }\n-        if self.check_keyword(keywords::Fn) || self.check_keyword(keywords::Unsafe) {\n+        if self.check_keyword(keywords::Fn) {\n             // FOREIGN FUNCTION ITEM\n             return Ok(Some(self.parse_item_foreign_fn(visibility, lo, attrs)?));\n         }"}, {"sha": "546bb235a5f501c4b67f68d2482bf1a899d361ae", "filename": "src/test/codegen-units/item-collection/cross-crate-closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fcross-crate-closures.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -27,7 +27,7 @@ fn main() {\n     //~ TRANS_ITEM fn cgu_extern_closures::inlined_fn_generic[0]::{{closure}}[0]<i32>\n     let _ = cgu_extern_closures::inlined_fn_generic(3, 4, 5i32);\n \n-    // Nothing should be generated for this call, we just link to the instance instance\n+    // Nothing should be generated for this call, we just link to the instance\n     // in the extern crate.\n     let _ = cgu_extern_closures::non_inlined_fn(6, 7);\n }"}, {"sha": "acf7187cf436ff0d6ee06e40975c017099cc074f", "filename": "src/test/parse-fail/extern-no-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Ftest%2Fparse-fail%2Fextern-no-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Ftest%2Fparse-fail%2Fextern-no-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fextern-no-fn.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -11,7 +11,7 @@\n // compile-flags: -Z parse-only\n \n extern {\n-    f(); //~ ERROR expected one of `fn`, `pub`, `static`, `unsafe`, or `}`, found `f`\n+    f(); //~ ERROR expected one of `fn`, `pub`, `static`, or `}`, found `f`\n }\n \n fn main() {"}, {"sha": "e632af6c83b1d4f7950fd66e5d38da658321053d", "filename": "src/test/parse-fail/removed-syntax-extern-const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Ftest%2Fparse-fail%2Fremoved-syntax-extern-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Ftest%2Fparse-fail%2Fremoved-syntax-extern-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-extern-const.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -12,5 +12,5 @@\n \n extern {\n     const i: isize;\n-    //~^ ERROR expected one of `fn`, `pub`, `static`, `unsafe`, or `}`, found `const`\n+    //~^ ERROR expected one of `fn`, `pub`, `static`, or `}`, found `const`\n }"}, {"sha": "ade742863a9da456fa1c3ace1ffc13571af27030", "filename": "src/test/run-pass/regions-lub-ref-ref-rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Ftest%2Frun-pass%2Fregions-lub-ref-ref-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Ftest%2Frun-pass%2Fregions-lub-ref-ref-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-lub-ref-ref-rc.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // Test a corner case of LUB coercion. In this case, one arm of the\n-// match requires a deref coercion and other other doesn't, and there\n+// match requires a deref coercion and the other doesn't, and there\n // is an extra `&` on the `rc`. We want to be sure that the lifetime\n // assigned to this `&rc` value is not `'a` but something smaller.  In\n // other words, the type from `rc` is `&'a Rc<String>` and the type"}, {"sha": "a7c8c01fab8503febe4d85a50eb74e0d2ccbf4c8", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -110,7 +110,7 @@ fn walk(cache: &mut Cache,\n             if let Some(pretty_path) = pretty_path {\n                 let entry = cache.get_mut(&pretty_path).unwrap();\n                 // we don't need the source anymore,\n-                // so drop to to reduce memory-usage\n+                // so drop to reduce memory-usage\n                 entry.source = String::new();\n             }\n         }"}]}