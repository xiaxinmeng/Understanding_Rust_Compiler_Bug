{"sha": "4ac10f8f6e8e07c70fadb676170c5402442e2243", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhYzEwZjhmNmU4ZTA3YzcwZmFkYjY3NjE3MGM1NDAyNDQyZTIyNDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-14T05:16:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-14T05:16:03Z"}, "message": "auto merge of #9185 : alexcrichton/rust/less-changing-directories, r=huonw\n\nWhile usage of change_dir_locked is synchronized against itself, it's not\r\nsynchronized against other relative path usage, so I'm of the opinion that it\r\njust really doesn't help in running tests. In order to prevent the problems that\r\nhave been cropping up, this completely removes the function.\r\n\r\nAll existing tests (except one) using it have been moved to run-pass tests where\r\nthey get their own process and don't need to be synchronized with anyone else.\r\n\r\nThere is one now-ignored rustpkg test because when I moved it to a run-pass test\r\napparently run-pass isn't set up to have 'extern mod rustc' (it ends up having\r\nlinkage failures).", "tree": {"sha": "fe463d6dc17f47c5b0721fd009faa6bacf38643b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe463d6dc17f47c5b0721fd009faa6bacf38643b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ac10f8f6e8e07c70fadb676170c5402442e2243", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ac10f8f6e8e07c70fadb676170c5402442e2243", "html_url": "https://github.com/rust-lang/rust/commit/4ac10f8f6e8e07c70fadb676170c5402442e2243", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ac10f8f6e8e07c70fadb676170c5402442e2243/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52b9688f923f8fb5bd6547bc6f2dd2d340c4ee4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/52b9688f923f8fb5bd6547bc6f2dd2d340c4ee4d", "html_url": "https://github.com/rust-lang/rust/commit/52b9688f923f8fb5bd6547bc6f2dd2d340c4ee4d"}, {"sha": "0af2bd829e6aaab4faf2cc135bd8b01db728417b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0af2bd829e6aaab4faf2cc135bd8b01db728417b", "html_url": "https://github.com/rust-lang/rust/commit/0af2bd829e6aaab4faf2cc135bd8b01db728417b"}], "stats": {"total": 297, "additions": 119, "deletions": 178}, "files": [{"sha": "9044c23ff7a40409fe075c8a20dad569097cc7d6", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 3, "deletions": 94, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/4ac10f8f6e8e07c70fadb676170c5402442e2243/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac10f8f6e8e07c70fadb676170c5402442e2243/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=4ac10f8f6e8e07c70fadb676170c5402442e2243", "patch": "@@ -28,97 +28,6 @@ pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n     None\n }\n \n-#[cfg(test)]\n-mod tests {\n-\n-    use tempfile::mkdtemp;\n-\n-    use std::os;\n-\n-    #[test]\n-    fn test_mkdtemp() {\n-        let p = mkdtemp(&Path(\".\"), \"foobar\").unwrap();\n-        os::remove_dir(&p);\n-        assert!(p.to_str().ends_with(\"foobar\"));\n-    }\n-\n-    // Ideally these would be in std::os but then core would need\n-    // to depend on std\n-    #[test]\n-    fn recursive_mkdir_rel() {\n-        use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-        use std::os;\n-        use std::unstable::change_dir_locked;\n-\n-        let root = mkdtemp(&os::tmpdir(), \"recursive_mkdir_rel\").\n-            expect(\"recursive_mkdir_rel\");\n-        assert!(do change_dir_locked(&root) {\n-            let path = Path(\"frob\");\n-            debug!(\"recursive_mkdir_rel: Making: %s in cwd %s [%?]\", path.to_str(),\n-                   os::getcwd().to_str(),\n-                   os::path_exists(&path));\n-            assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-            assert!(os::path_is_dir(&path));\n-            assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-            assert!(os::path_is_dir(&path));\n-        });\n-    }\n-\n-    #[test]\n-    fn recursive_mkdir_dot() {\n-        use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-        use std::os;\n-\n-        let dot = Path(\".\");\n-        assert!(os::mkdir_recursive(&dot,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-        let dotdot = Path(\"..\");\n-        assert!(os::mkdir_recursive(&dotdot,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-    }\n-\n-    #[test]\n-    fn recursive_mkdir_rel_2() {\n-        use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-        use std::os;\n-        use std::unstable::change_dir_locked;\n-\n-        let root = mkdtemp(&os::tmpdir(), \"recursive_mkdir_rel_2\").\n-            expect(\"recursive_mkdir_rel_2\");\n-        assert!(do change_dir_locked(&root) {\n-            let path = Path(\"./frob/baz\");\n-            debug!(\"recursive_mkdir_rel_2: Making: %s in cwd %s [%?]\", path.to_str(),\n-                   os::getcwd().to_str(), os::path_exists(&path));\n-            assert!(os::mkdir_recursive(&path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-                assert!(os::path_is_dir(&path));\n-            assert!(os::path_is_dir(&path.pop()));\n-            let path2 = Path(\"quux/blat\");\n-            debug!(\"recursive_mkdir_rel_2: Making: %s in cwd %s\", path2.to_str(),\n-                   os::getcwd().to_str());\n-            assert!(os::mkdir_recursive(&path2, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-                assert!(os::path_is_dir(&path2));\n-            assert!(os::path_is_dir(&path2.pop()));\n-        });\n-    }\n-\n-    // Ideally this would be in core, but needs mkdtemp\n-    #[test]\n-    pub fn test_rmdir_recursive_ok() {\n-        use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n-        use std::os;\n-\n-        let rwx = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n-\n-        let tmpdir = mkdtemp(&os::tmpdir(), \"test\").expect(\"test_rmdir_recursive_ok: \\\n-                                            couldn't create temp dir\");\n-        let root = tmpdir.push(\"foo\");\n-\n-        debug!(\"making %s\", root.to_str());\n-        assert!(os::make_dir(&root, rwx));\n-        assert!(os::make_dir(&root.push(\"foo\"), rwx));\n-        assert!(os::make_dir(&root.push(\"foo\").push(\"bar\"), rwx));\n-        assert!(os::make_dir(&root.push(\"foo\").push(\"bar\").push(\"blat\"), rwx));\n-        assert!(os::remove_dir_recursive(&root));\n-        assert!(!os::path_exists(&root));\n-        assert!(!os::path_exists(&root.push(\"bar\")));\n-        assert!(!os::path_exists(&root.push(\"bar\").push(\"blat\")));\n-    }\n-}\n+// the tests for this module need to change the path using change_dir,\n+// and this doesn't play nicely with other tests so these unit tests are located\n+// in src/test/run-pass/tempfile.rs"}, {"sha": "30a5e438f345870a5e94b1fb32a4994e9ae2d822", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4ac10f8f6e8e07c70fadb676170c5402442e2243/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac10f8f6e8e07c70fadb676170c5402442e2243/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=4ac10f8f6e8e07c70fadb676170c5402442e2243", "patch": "@@ -819,26 +819,25 @@ fn rust_path_test() {\n }\n \n #[test]\n+#[ignore] // FIXME(#9184) tests can't change the cwd (other tests are sad then)\n fn rust_path_contents() {\n-    use std::unstable::change_dir_locked;\n-\n     let dir = mkdtemp(&os::tmpdir(), \"rust_path\").expect(\"rust_path_contents failed\");\n     let abc = &dir.push(\"A\").push(\"B\").push(\"C\");\n     assert!(os::mkdir_recursive(&abc.push(\".rust\"), U_RWX));\n     assert!(os::mkdir_recursive(&abc.pop().push(\".rust\"), U_RWX));\n     assert!(os::mkdir_recursive(&abc.pop().pop().push(\".rust\"), U_RWX));\n-    assert!(do change_dir_locked(&dir.push(\"A\").push(\"B\").push(\"C\")) {\n-        let p = rust_path();\n-        let cwd = os::getcwd().push(\".rust\");\n-        let parent = cwd.pop().pop().push(\".rust\");\n-        let grandparent = cwd.pop().pop().pop().push(\".rust\");\n-        assert!(p.contains(&cwd));\n-        assert!(p.contains(&parent));\n-        assert!(p.contains(&grandparent));\n-        for a_path in p.iter() {\n-            assert!(!a_path.components.is_empty());\n-        }\n-    });\n+    assert!(os::change_dir(abc));\n+\n+    let p = rust_path();\n+    let cwd = os::getcwd().push(\".rust\");\n+    let parent = cwd.pop().pop().push(\".rust\");\n+    let grandparent = cwd.pop().pop().pop().push(\".rust\");\n+    assert!(p.contains(&cwd));\n+    assert!(p.contains(&parent));\n+    assert!(p.contains(&grandparent));\n+    for a_path in p.iter() {\n+        assert!(!a_path.components.is_empty());\n+    }\n }\n \n #[test]"}, {"sha": "e16e6384a4f16fd268c3a71abaa5f495c7eae441", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4ac10f8f6e8e07c70fadb676170c5402442e2243/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac10f8f6e8e07c70fadb676170c5402442e2243/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=4ac10f8f6e8e07c70fadb676170c5402442e2243", "patch": "@@ -68,59 +68,6 @@ fn test_run_in_bare_thread_exchange() {\n     }\n }\n \n-\n-/// Changes the current working directory to the specified\n-/// path while acquiring a global lock, then calls `action`.\n-/// If the change is successful, releases the lock and restores the\n-/// CWD to what it was before, returning true.\n-/// Returns false if the directory doesn't exist or if the directory change\n-/// is otherwise unsuccessful.\n-///\n-/// This is used by test cases to avoid cwd races.\n-///\n-/// # Safety Note\n-///\n-/// This uses a pthread mutex so descheduling in the action callback\n-/// can lead to deadlock. Calling change_dir_locked recursively will\n-/// also deadlock.\n-pub fn change_dir_locked(p: &Path, action: &fn()) -> bool {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    use os;\n-    use os::change_dir;\n-    use unstable::sync::atomically;\n-    use unstable::finally::Finally;\n-\n-    unsafe {\n-        // This is really sketchy. Using a pthread mutex so descheduling\n-        // in the `action` callback can cause deadlock. Doing it in\n-        // `task::atomically` to try to avoid that, but ... I don't know\n-        // this is all bogus.\n-        return do atomically {\n-            rust_take_change_dir_lock();\n-\n-            do (||{\n-                let old_dir = os::getcwd();\n-                if change_dir(p) {\n-                    action();\n-                    change_dir(&old_dir)\n-                }\n-                else {\n-                    false\n-                }\n-            }).finally {\n-                rust_drop_change_dir_lock();\n-            }\n-        }\n-    }\n-\n-    extern {\n-        fn rust_take_change_dir_lock();\n-        fn rust_drop_change_dir_lock();\n-    }\n-}\n-\n-\n /// Dynamically inquire about whether we're running under V.\n /// You should usually not use this unless your test definitely\n /// can't run correctly un-altered. Valgrind is there to help"}, {"sha": "4b718303f2cb0f7da78d4da0f7783bb7e6f13b0f", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ac10f8f6e8e07c70fadb676170c5402442e2243/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4ac10f8f6e8e07c70fadb676170c5402442e2243/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=4ac10f8f6e8e07c70fadb676170c5402442e2243", "patch": "@@ -603,18 +603,6 @@ rust_get_global_args_ptr() {\n     return &global_args_ptr;\n }\n \n-static lock_and_signal change_dir_lock;\n-\n-extern \"C\" CDECL void\n-rust_take_change_dir_lock() {\n-    change_dir_lock.lock();\n-}\n-\n-extern \"C\" CDECL void\n-rust_drop_change_dir_lock() {\n-    change_dir_lock.unlock();\n-}\n-\n // Used by i386 __morestack\n extern \"C\" CDECL uintptr_t\n rust_get_task() {"}, {"sha": "4cbee0dcbd0688b0d2403aed4f3cf5396b89191d", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ac10f8f6e8e07c70fadb676170c5402442e2243/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/4ac10f8f6e8e07c70fadb676170c5402442e2243/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=4ac10f8f6e8e07c70fadb676170c5402442e2243", "patch": "@@ -186,8 +186,6 @@ rust_get_num_cpus\n rust_get_global_args_ptr\n rust_take_global_args_lock\n rust_drop_global_args_lock\n-rust_take_change_dir_lock\n-rust_drop_change_dir_lock\n rust_take_linenoise_lock\n rust_drop_linenoise_lock\n rust_get_test_int"}, {"sha": "e0c0fdd396b7a6ff48c43b0e9095379c91d010c8", "filename": "src/test/run-pass/glob-std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ac10f8f6e8e07c70fadb676170c5402442e2243/src%2Ftest%2Frun-pass%2Fglob-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac10f8f6e8e07c70fadb676170c5402442e2243/src%2Ftest%2Frun-pass%2Fglob-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fglob-std.rs?ref=4ac10f8f6e8e07c70fadb676170c5402442e2243", "patch": "@@ -19,9 +19,9 @@ use std::{io, os, unstable};\n \n pub fn main() {\n     fn change_then_remove(p: &Path, f: &fn()) {\n-        do (|| {\n-            unstable::change_dir_locked(p, || f());\n-        }).finally {\n+        assert!(os::change_dir(p));\n+\n+        do f.finally {\n             os::remove_dir_recursive(p);\n         }\n     }"}, {"sha": "cde6cc102afa3e3155a251931033bf713cd32062", "filename": "src/test/run-pass/tempfile.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/4ac10f8f6e8e07c70fadb676170c5402442e2243/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac10f8f6e8e07c70fadb676170c5402442e2243/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=4ac10f8f6e8e07c70fadb676170c5402442e2243", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast windows doesn't like 'extern mod extra'\n+\n+// These tests are here to exercise the functionality of the `tempfile` module.\n+// One might expect these tests to be located in that module, but sadly they\n+// cannot. The tests need to invoke `os::change_dir` which cannot be done in the\n+// normal test infrastructure. If the tests change the current working\n+// directory, then *all* tests which require relative paths suddenly break b/c\n+// they're in a different location than before. Hence, these tests are all run\n+// serially here.\n+\n+extern mod extra;\n+\n+use extra::tempfile::mkdtemp;\n+use std::os;\n+use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+\n+fn test_mkdtemp() {\n+    let p = mkdtemp(&Path(\".\"), \"foobar\").unwrap();\n+    os::remove_dir(&p);\n+    assert!(p.to_str().ends_with(\"foobar\"));\n+}\n+\n+// Ideally these would be in std::os but then core would need\n+// to depend on std\n+fn recursive_mkdir_rel() {\n+    let path = Path(\"frob\");\n+    debug!(\"recursive_mkdir_rel: Making: %s in cwd %s [%?]\", path.to_str(),\n+           os::getcwd().to_str(),\n+           os::path_exists(&path));\n+    assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+    assert!(os::path_is_dir(&path));\n+    assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+    assert!(os::path_is_dir(&path));\n+}\n+\n+fn recursive_mkdir_dot() {\n+    let dot = Path(\".\");\n+    assert!(os::mkdir_recursive(&dot,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+    let dotdot = Path(\"..\");\n+    assert!(os::mkdir_recursive(&dotdot,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+}\n+\n+fn recursive_mkdir_rel_2() {\n+    let path = Path(\"./frob/baz\");\n+    debug!(\"recursive_mkdir_rel_2: Making: %s in cwd %s [%?]\", path.to_str(),\n+           os::getcwd().to_str(), os::path_exists(&path));\n+    assert!(os::mkdir_recursive(&path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+        assert!(os::path_is_dir(&path));\n+    assert!(os::path_is_dir(&path.pop()));\n+    let path2 = Path(\"quux/blat\");\n+    debug!(\"recursive_mkdir_rel_2: Making: %s in cwd %s\", path2.to_str(),\n+           os::getcwd().to_str());\n+    assert!(os::mkdir_recursive(&path2, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+        assert!(os::path_is_dir(&path2));\n+    assert!(os::path_is_dir(&path2.pop()));\n+}\n+\n+// Ideally this would be in core, but needs mkdtemp\n+pub fn test_rmdir_recursive_ok() {\n+    let rwx = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n+\n+    let tmpdir = mkdtemp(&os::tmpdir(), \"test\").expect(\"test_rmdir_recursive_ok: \\\n+                                        couldn't create temp dir\");\n+    let root = tmpdir.push(\"foo\");\n+\n+    debug!(\"making %s\", root.to_str());\n+    assert!(os::make_dir(&root, rwx));\n+    assert!(os::make_dir(&root.push(\"foo\"), rwx));\n+    assert!(os::make_dir(&root.push(\"foo\").push(\"bar\"), rwx));\n+    assert!(os::make_dir(&root.push(\"foo\").push(\"bar\").push(\"blat\"), rwx));\n+    assert!(os::remove_dir_recursive(&root));\n+    assert!(!os::path_exists(&root));\n+    assert!(!os::path_exists(&root.push(\"bar\")));\n+    assert!(!os::path_exists(&root.push(\"bar\").push(\"blat\")));\n+}\n+\n+fn in_tmpdir(f: &fn()) {\n+    let tmpdir = mkdtemp(&os::tmpdir(), \"test\").expect(\"can't make tmpdir\");\n+    assert!(os::change_dir(&tmpdir));\n+\n+    f();\n+}\n+\n+fn main() {\n+    in_tmpdir(test_mkdtemp);\n+    in_tmpdir(recursive_mkdir_rel);\n+    in_tmpdir(recursive_mkdir_dot);\n+    in_tmpdir(recursive_mkdir_rel_2);\n+    in_tmpdir(test_rmdir_recursive_ok);\n+}"}]}