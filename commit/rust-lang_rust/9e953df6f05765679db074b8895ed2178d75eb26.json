{"sha": "9e953df6f05765679db074b8895ed2178d75eb26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllOTUzZGY2ZjA1NzY1Njc5ZGIwNzRiODg5NWVkMjE3OGQ3NWViMjY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-18T08:13:46Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-18T14:32:12Z"}, "message": "Rollup merge of #30420 - petrochenkov:owned2, r=nrc\n\nPart of https://github.com/rust-lang/rust/pull/30095 not causing mysterious segfaults.\n\nr? @nrc", "tree": {"sha": "e71174db4adcf4adf1709afb41ff3fc125d5c35b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e71174db4adcf4adf1709afb41ff3fc125d5c35b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e953df6f05765679db074b8895ed2178d75eb26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e953df6f05765679db074b8895ed2178d75eb26", "html_url": "https://github.com/rust-lang/rust/commit/9e953df6f05765679db074b8895ed2178d75eb26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e953df6f05765679db074b8895ed2178d75eb26/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "158a1bdd7dac47356a0cc44dd52308c7145f4afe", "url": "https://api.github.com/repos/rust-lang/rust/commits/158a1bdd7dac47356a0cc44dd52308c7145f4afe", "html_url": "https://github.com/rust-lang/rust/commit/158a1bdd7dac47356a0cc44dd52308c7145f4afe"}, {"sha": "6c87b191580be9ecd5a99a34ef97375af0b9d659", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c87b191580be9ecd5a99a34ef97375af0b9d659", "html_url": "https://github.com/rust-lang/rust/commit/6c87b191580be9ecd5a99a34ef97375af0b9d659"}], "stats": {"total": 813, "additions": 400, "deletions": 413}, "files": [{"sha": "cab7e45ee62832522f99b664a1d4b3f269967ff7", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -517,7 +517,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n         ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n             let v = adt.variant_of_ctor(ctor);\n             if let VariantKind::Struct = v.kind() {\n-                let field_pats: Vec<_> = v.fields.iter()\n+                let field_pats: hir::HirVec<_> = v.fields.iter()\n                     .zip(pats)\n                     .filter(|&(_, ref pat)| pat.node != hir::PatWild)\n                     .map(|(field, pat)| Spanned {\n@@ -540,14 +540,14 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                ty::TyArray(_, n) => match ctor {\n                     &Single => {\n                         assert_eq!(pats_len, n);\n-                        hir::PatVec(pats.collect(), None, vec!())\n+                        hir::PatVec(pats.collect(), None, hir::HirVec::new())\n                     },\n                     _ => unreachable!()\n                 },\n                 ty::TySlice(_) => match ctor {\n                     &Slice(n) => {\n                         assert_eq!(pats_len, n);\n-                        hir::PatVec(pats.collect(), None, vec!())\n+                        hir::PatVec(pats.collect(), None, hir::HirVec::new())\n                     },\n                     _ => unreachable!()\n                 },\n@@ -562,7 +562,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n \n         ty::TyArray(_, len) => {\n             assert_eq!(pats_len, len);\n-            hir::PatVec(pats.collect(), None, vec![])\n+            hir::PatVec(pats.collect(), None, hir::HirVec::new())\n         }\n \n         _ => {"}, {"sha": "54061a14d1419644ff1880c9849dbdf5a433f63b", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -357,14 +357,14 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n \n         hir::ExprVec(ref exprs) => {\n             let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect();\n-            hir::PatVec(pats, None, vec![])\n+            hir::PatVec(pats, None, hir::HirVec::new())\n         }\n \n         hir::ExprPath(_, ref path) => {\n             let opt_def = tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def());\n             match opt_def {\n                 Some(def::DefStruct(..)) =>\n-                    hir::PatStruct(path.clone(), vec![], false),\n+                    hir::PatStruct(path.clone(), hir::HirVec::new(), false),\n                 Some(def::DefVariant(..)) =>\n                     hir::PatEnum(path.clone(), None),\n                 _ => {"}, {"sha": "73776304bc846d65cec3a38d1dc0a8a9326e25c7", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -324,7 +324,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n-    fn consume_exprs(&mut self, exprs: &Vec<P<hir::Expr>>) {\n+    fn consume_exprs(&mut self, exprs: &[P<hir::Expr>]) {\n         for expr in exprs {\n             self.consume_expr(&**expr);\n         }\n@@ -651,7 +651,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n     fn walk_struct_expr(&mut self,\n                         _expr: &hir::Expr,\n-                        fields: &Vec<hir::Field>,\n+                        fields: &[hir::Field],\n                         opt_with: &Option<P<hir::Expr>>) {\n         // Consume the expressions supplying values for each field.\n         for field in fields {\n@@ -697,7 +697,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         self.walk_expr(with_expr);\n \n         fn contains_field_named(field: ty::FieldDef,\n-                                fields: &Vec<hir::Field>)\n+                                fields: &[hir::Field])\n                                 -> bool\n         {\n             fields.iter().any("}, {"sha": "2abf499185690f7c8bd9ef3f251946637cb095f4", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -90,7 +90,6 @@ use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n use std::fmt;\n use syntax::ast;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::codemap::{self, Pos, Span};\n use syntax::parse::token;\n use syntax::ptr::P;\n@@ -1154,10 +1153,10 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n \n     fn rebuild_ty_params(&self,\n-                         ty_params: OwnedSlice<hir::TyParam>,\n+                         ty_params: P<[hir::TyParam]>,\n                          lifetime: hir::Lifetime,\n                          region_names: &HashSet<ast::Name>)\n-                         -> OwnedSlice<hir::TyParam> {\n+                         -> P<[hir::TyParam]> {\n         ty_params.map(|ty_param| {\n             let bounds = self.rebuild_ty_param_bounds(ty_param.bounds.clone(),\n                                                       lifetime,\n@@ -1173,10 +1172,10 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n \n     fn rebuild_ty_param_bounds(&self,\n-                               ty_param_bounds: OwnedSlice<hir::TyParamBound>,\n+                               ty_param_bounds: hir::TyParamBounds,\n                                lifetime: hir::Lifetime,\n                                region_names: &HashSet<ast::Name>)\n-                               -> OwnedSlice<hir::TyParamBound> {\n+                               -> hir::TyParamBounds {\n         ty_param_bounds.map(|tpb| {\n             match tpb {\n                 &hir::RegionTyParamBound(lt) => {\n@@ -1249,13 +1248,13 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         add: &Vec<hir::Lifetime>,\n                         keep: &HashSet<ast::Name>,\n                         remove: &HashSet<ast::Name>,\n-                        ty_params: OwnedSlice<hir::TyParam>,\n+                        ty_params: P<[hir::TyParam]>,\n                         where_clause: hir::WhereClause)\n                         -> hir::Generics {\n         let mut lifetimes = Vec::new();\n         for lt in add {\n             lifetimes.push(hir::LifetimeDef { lifetime: *lt,\n-                                              bounds: Vec::new() });\n+                                              bounds: hir::HirVec::new() });\n         }\n         for lt in &generics.lifetimes {\n             if keep.contains(&lt.lifetime.name) ||\n@@ -1264,7 +1263,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             }\n         }\n         hir::Generics {\n-            lifetimes: lifetimes,\n+            lifetimes: lifetimes.into(),\n             ty_params: ty_params,\n             where_clause: where_clause,\n         }\n@@ -1275,7 +1274,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                        lifetime: hir::Lifetime,\n                        anon_nums: &HashSet<u32>,\n                        region_names: &HashSet<ast::Name>)\n-                       -> Vec<hir::Arg> {\n+                       -> hir::HirVec<hir::Arg> {\n         let mut new_inputs = Vec::new();\n         for arg in inputs {\n             let new_ty = self.rebuild_arg_ty_or_output(&*arg.ty, lifetime,\n@@ -1287,7 +1286,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             };\n             new_inputs.push(possibly_new_arg);\n         }\n-        new_inputs\n+        new_inputs.into()\n     }\n \n     fn rebuild_output(&self, ty: &hir::FunctionRetTy,\n@@ -1514,7 +1513,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     }\n                 });\n                 hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n-                    lifetimes: new_lts,\n+                    lifetimes: new_lts.into(),\n                     types: new_types,\n                     bindings: new_bindings,\n                })\n@@ -1530,7 +1529,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         hir::Path {\n             span: path.span,\n             global: path.global,\n-            segments: new_segs\n+            segments: new_segs.into()\n         }\n     }\n }"}, {"sha": "9b133c5401519f595ff08dbe9a6f86bc99e89ecd", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -79,10 +79,10 @@ struct LifetimeContext<'a> {\n enum ScopeChain<'a> {\n     /// EarlyScope(i, ['a, 'b, ...], s) extends s with early-bound\n     /// lifetimes, assigning indexes 'a => i, 'b => i+1, ... etc.\n-    EarlyScope(subst::ParamSpace, &'a Vec<hir::LifetimeDef>, Scope<'a>),\n+    EarlyScope(subst::ParamSpace, &'a [hir::LifetimeDef], Scope<'a>),\n     /// LateScope(['a, 'b, ...], s) extends s with late-bound\n     /// lifetimes introduced by the declaration binder_id.\n-    LateScope(&'a Vec<hir::LifetimeDef>, Scope<'a>),\n+    LateScope(&'a [hir::LifetimeDef], Scope<'a>),\n \n     /// lifetimes introduced by a fn are scoped to the call-site for that fn.\n     FnScope { fn_id: ast::NodeId, body_id: ast::NodeId, s: Scope<'a> },\n@@ -206,7 +206,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 // a trait ref, which introduces a binding scope.\n                 match self.def_map.get(&ty.id).map(|d| (d.base_def, d.depth)) {\n                     Some((def::DefTrait(..), 0)) => {\n-                        self.with(LateScope(&Vec::new(), self.scope), |_, this| {\n+                        self.with(LateScope(&[], self.scope), |_, this| {\n                             this.visit_path(path, ty.id);\n                         });\n                     }\n@@ -661,7 +661,7 @@ impl<'a> LifetimeContext<'a> {\n                     lifetime_ref.name);\n     }\n \n-    fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<hir::LifetimeDef>) {\n+    fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &[hir::LifetimeDef]) {\n         for i in 0..lifetimes.len() {\n             let lifetime_i = &lifetimes[i];\n \n@@ -753,7 +753,7 @@ impl<'a> LifetimeContext<'a> {\n     }\n }\n \n-fn search_lifetimes<'a>(lifetimes: &'a Vec<hir::LifetimeDef>,\n+fn search_lifetimes<'a>(lifetimes: &'a [hir::LifetimeDef],\n                     lifetime_ref: &hir::Lifetime)\n                     -> Option<(u32, &'a hir::Lifetime)> {\n     for (i, lifetime_decl) in lifetimes.iter().enumerate() {"}, {"sha": "a41ee51fb5546023991fd29f56b2f53a0b190806", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -82,7 +82,7 @@ struct Annotator<'a, 'tcx: 'a> {\n impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n     // Determine the stability for a node based on its attributes and inherited\n     // stability. The stability is recorded in the index and used as the parent.\n-    fn annotate<F>(&mut self, id: NodeId, attrs: &Vec<Attribute>,\n+    fn annotate<F>(&mut self, id: NodeId, attrs: &[Attribute],\n                    item_sp: Span, kind: AnnotationKind, visit_children: F)\n         where F: FnOnce(&mut Annotator)\n     {"}, {"sha": "ecb2b85fd77445c98fea253e61f4404dc4aaeb88", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -16,7 +16,7 @@ use middle::ty::fold::{TypeFoldable, TypeFolder};\n \n use std::rc::Rc;\n use syntax::abi;\n-use syntax::owned_slice::OwnedSlice;\n+use syntax::ptr::P;\n \n use rustc_front::hir;\n \n@@ -555,8 +555,8 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for OwnedSlice<T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> OwnedSlice<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for P<[T]> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> P<[T]> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n }"}, {"sha": "784428cc114dc0cd9e7dba13dd0dd4e416aac3df", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -17,7 +17,6 @@ use syntax::ast::{MetaWord, MetaList, MetaNameValue};\n use syntax::attr::ThinAttributesExt;\n use hir;\n use syntax::codemap::{respan, Span, Spanned};\n-use syntax::owned_slice::OwnedSlice;\n use syntax::ptr::P;\n use syntax::parse::token;\n use syntax::util::move_map::MoveMap;\n@@ -35,7 +34,7 @@ pub trait Folder : Sized {\n         noop_fold_crate(c, self)\n     }\n \n-    fn fold_meta_items(&mut self, meta_items: Vec<P<MetaItem>>) -> Vec<P<MetaItem>> {\n+    fn fold_meta_items(&mut self, meta_items: HirVec<P<MetaItem>>) -> HirVec<P<MetaItem>> {\n         noop_fold_meta_items(meta_items, self)\n     }\n \n@@ -199,19 +198,19 @@ pub trait Folder : Sized {\n         noop_fold_variant_data(vdata, self)\n     }\n \n-    fn fold_lifetimes(&mut self, lts: Vec<Lifetime>) -> Vec<Lifetime> {\n+    fn fold_lifetimes(&mut self, lts: HirVec<Lifetime>) -> HirVec<Lifetime> {\n         noop_fold_lifetimes(lts, self)\n     }\n \n-    fn fold_lifetime_defs(&mut self, lts: Vec<LifetimeDef>) -> Vec<LifetimeDef> {\n+    fn fold_lifetime_defs(&mut self, lts: HirVec<LifetimeDef>) -> HirVec<LifetimeDef> {\n         noop_fold_lifetime_defs(lts, self)\n     }\n \n     fn fold_ty_param(&mut self, tp: TyParam) -> TyParam {\n         noop_fold_ty_param(tp, self)\n     }\n \n-    fn fold_ty_params(&mut self, tps: OwnedSlice<TyParam>) -> OwnedSlice<TyParam> {\n+    fn fold_ty_params(&mut self, tps: P<[TyParam]>) -> P<[TyParam]> {\n         noop_fold_ty_params(tps, self)\n     }\n \n@@ -220,12 +219,12 @@ pub trait Folder : Sized {\n     }\n \n     fn fold_opt_bounds(&mut self,\n-                       b: Option<OwnedSlice<TyParamBound>>)\n-                       -> Option<OwnedSlice<TyParamBound>> {\n+                       b: Option<TyParamBounds>)\n+                       -> Option<TyParamBounds> {\n         noop_fold_opt_bounds(b, self)\n     }\n \n-    fn fold_bounds(&mut self, b: OwnedSlice<TyParamBound>) -> OwnedSlice<TyParamBound> {\n+    fn fold_bounds(&mut self, b: TyParamBounds) -> TyParamBounds {\n         noop_fold_bounds(b, self)\n     }\n \n@@ -264,9 +263,9 @@ pub trait Folder : Sized {\n     }\n }\n \n-pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<P<MetaItem>>,\n+pub fn noop_fold_meta_items<T: Folder>(meta_items: HirVec<P<MetaItem>>,\n                                        fld: &mut T)\n-                                       -> Vec<P<MetaItem>> {\n+                                       -> HirVec<P<MetaItem>> {\n     meta_items.move_map(|x| fld.fold_meta_item(x))\n }\n \n@@ -305,7 +304,7 @@ pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<\n     })\n }\n \n-pub fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribute> {\n+pub fn fold_attrs<T: Folder>(attrs: HirVec<Attribute>, fld: &mut T) -> HirVec<Attribute> {\n     attrs.move_flat_map(|x| fld.fold_attribute(x))\n }\n \n@@ -478,7 +477,7 @@ pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n             pat: fld.fold_pat(pat),\n             init: init.map(|e| fld.fold_expr(e)),\n             span: fld.new_span(span),\n-            attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs, fld)),\n+            attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs.into(), fld).into()),\n         }\n     })\n }\n@@ -576,9 +575,9 @@ pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n     }\n }\n \n-pub fn noop_fold_ty_params<T: Folder>(tps: OwnedSlice<TyParam>,\n+pub fn noop_fold_ty_params<T: Folder>(tps: P<[TyParam]>,\n                                       fld: &mut T)\n-                                      -> OwnedSlice<TyParam> {\n+                                      -> P<[TyParam]> {\n     tps.move_map(|tp| fld.fold_ty_param(tp))\n }\n \n@@ -597,11 +596,13 @@ pub fn noop_fold_lifetime_def<T: Folder>(l: LifetimeDef, fld: &mut T) -> Lifetim\n     }\n }\n \n-pub fn noop_fold_lifetimes<T: Folder>(lts: Vec<Lifetime>, fld: &mut T) -> Vec<Lifetime> {\n+pub fn noop_fold_lifetimes<T: Folder>(lts: HirVec<Lifetime>, fld: &mut T) -> HirVec<Lifetime> {\n     lts.move_map(|l| fld.fold_lifetime(l))\n }\n \n-pub fn noop_fold_lifetime_defs<T: Folder>(lts: Vec<LifetimeDef>, fld: &mut T) -> Vec<LifetimeDef> {\n+pub fn noop_fold_lifetime_defs<T: Folder>(lts: HirVec<LifetimeDef>,\n+                                          fld: &mut T)\n+                                          -> HirVec<LifetimeDef> {\n     lts.move_map(|l| fld.fold_lifetime_def(l))\n }\n \n@@ -726,9 +727,9 @@ pub fn noop_fold_mt<T: Folder>(MutTy { ty, mutbl }: MutTy, folder: &mut T) -> Mu\n     }\n }\n \n-pub fn noop_fold_opt_bounds<T: Folder>(b: Option<OwnedSlice<TyParamBound>>,\n+pub fn noop_fold_opt_bounds<T: Folder>(b: Option<TyParamBounds>,\n                                        folder: &mut T)\n-                                       -> Option<OwnedSlice<TyParamBound>> {\n+                                       -> Option<TyParamBounds> {\n     b.map(|bounds| folder.fold_bounds(bounds))\n }\n \n@@ -1140,7 +1141,7 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &\n             }\n         },\n         span: folder.new_span(span),\n-        attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs, folder)),\n+        attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs.into(), folder).into()),\n     }\n }\n "}, {"sha": "6b2664af60ba5cd3bdf998321199b3396bdf68ee", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 82, "deletions": 65, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -40,9 +40,8 @@ use std::collections::BTreeMap;\n use syntax::codemap::{self, Span, Spanned, DUMMY_SP, ExpnId};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, TokenTree, AsmDialect};\n-use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, CrateConfig};\n+use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n use syntax::attr::ThinAttributes;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n \n@@ -53,6 +52,22 @@ use std::fmt;\n use std::hash::{Hash, Hasher};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n+/// HIR doesn't commit to a concrete storage type and have its own alias for a vector.\n+/// It can be `Vec`, `P<[T]>` or potentially `Box<[T]>`, or some other container with similar\n+/// behavior. Unlike AST, HIR is mostly a static structure, so we can use an owned slice instead\n+/// of `Vec` to avoid keeping extra capacity.\n+pub type HirVec<T> = Vec<T>;\n+\n+macro_rules! hir_vec {\n+    ($elem:expr; $n:expr) => (\n+        $crate::hir::HirVec::from(vec![$elem; $n])\n+    );\n+    ($($x:expr),*) => (\n+        $crate::hir::HirVec::from(vec![$($x),*])\n+    );\n+    ($($x:expr,)*) => (vec![$($x),*])\n+}\n+\n /// Identifier in HIR\n #[derive(Clone, Copy, Eq)]\n pub struct Ident {\n@@ -130,7 +145,7 @@ impl fmt::Debug for Lifetime {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct LifetimeDef {\n     pub lifetime: Lifetime,\n-    pub bounds: Vec<Lifetime>,\n+    pub bounds: HirVec<Lifetime>,\n }\n \n /// A \"Path\" is essentially Rust's notion of a name; for instance:\n@@ -143,7 +158,7 @@ pub struct Path {\n     /// module (like paths in an import).\n     pub global: bool,\n     /// The segments in the path: the things separated by `::`.\n-    pub segments: Vec<PathSegment>,\n+    pub segments: HirVec<PathSegment>,\n }\n \n impl fmt::Debug for Path {\n@@ -192,9 +207,9 @@ pub enum PathParameters {\n impl PathParameters {\n     pub fn none() -> PathParameters {\n         AngleBracketedParameters(AngleBracketedParameterData {\n-            lifetimes: Vec::new(),\n-            types: OwnedSlice::empty(),\n-            bindings: OwnedSlice::empty(),\n+            lifetimes: HirVec::new(),\n+            types: P::empty(),\n+            bindings: P::empty(),\n         })\n     }\n \n@@ -224,7 +239,7 @@ impl PathParameters {\n \n     /// Returns the types that the user wrote. Note that these do not necessarily map to the type\n     /// parameters in the parenthesized case.\n-    pub fn types(&self) -> Vec<&P<Ty>> {\n+    pub fn types(&self) -> HirVec<&P<Ty>> {\n         match *self {\n             AngleBracketedParameters(ref data) => {\n                 data.types.iter().collect()\n@@ -238,24 +253,24 @@ impl PathParameters {\n         }\n     }\n \n-    pub fn lifetimes(&self) -> Vec<&Lifetime> {\n+    pub fn lifetimes(&self) -> HirVec<&Lifetime> {\n         match *self {\n             AngleBracketedParameters(ref data) => {\n                 data.lifetimes.iter().collect()\n             }\n             ParenthesizedParameters(_) => {\n-                Vec::new()\n+                HirVec::new()\n             }\n         }\n     }\n \n-    pub fn bindings(&self) -> Vec<&TypeBinding> {\n+    pub fn bindings(&self) -> HirVec<&TypeBinding> {\n         match *self {\n             AngleBracketedParameters(ref data) => {\n                 data.bindings.iter().collect()\n             }\n             ParenthesizedParameters(_) => {\n-                Vec::new()\n+                HirVec::new()\n             }\n         }\n     }\n@@ -265,12 +280,12 @@ impl PathParameters {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct AngleBracketedParameterData {\n     /// The lifetime parameters for this path segment.\n-    pub lifetimes: Vec<Lifetime>,\n+    pub lifetimes: HirVec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n-    pub types: OwnedSlice<P<Ty>>,\n+    pub types: P<[P<Ty>]>,\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A=Bar>`.\n-    pub bindings: OwnedSlice<TypeBinding>,\n+    pub bindings: P<[TypeBinding]>,\n }\n \n impl AngleBracketedParameterData {\n@@ -286,7 +301,7 @@ pub struct ParenthesizedParameterData {\n     pub span: Span,\n \n     /// `(A,B)`\n-    pub inputs: Vec<P<Ty>>,\n+    pub inputs: HirVec<P<Ty>>,\n \n     /// `C`\n     pub output: Option<P<Ty>>,\n@@ -310,7 +325,7 @@ pub enum TraitBoundModifier {\n     Maybe,\n }\n \n-pub type TyParamBounds = OwnedSlice<TyParamBound>;\n+pub type TyParamBounds = P<[TyParamBound]>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TyParam {\n@@ -325,8 +340,8 @@ pub struct TyParam {\n /// of a function, enum, trait, etc.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Generics {\n-    pub lifetimes: Vec<LifetimeDef>,\n-    pub ty_params: OwnedSlice<TyParam>,\n+    pub lifetimes: HirVec<LifetimeDef>,\n+    pub ty_params: P<[TyParam]>,\n     pub where_clause: WhereClause,\n }\n \n@@ -346,7 +361,7 @@ impl Generics {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereClause {\n     pub id: NodeId,\n-    pub predicates: Vec<WherePredicate>,\n+    pub predicates: HirVec<WherePredicate>,\n }\n \n /// A single predicate in a `where` clause\n@@ -365,19 +380,19 @@ pub enum WherePredicate {\n pub struct WhereBoundPredicate {\n     pub span: Span,\n     /// Any lifetimes from a `for` binding\n-    pub bound_lifetimes: Vec<LifetimeDef>,\n+    pub bound_lifetimes: HirVec<LifetimeDef>,\n     /// The type being bounded\n     pub bounded_ty: P<Ty>,\n     /// Trait and lifetime bounds (`Clone+Send+'static`)\n-    pub bounds: OwnedSlice<TyParamBound>,\n+    pub bounds: TyParamBounds,\n }\n \n /// A lifetime predicate, e.g. `'a: 'b+'c`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n-    pub bounds: Vec<Lifetime>,\n+    pub bounds: HirVec<Lifetime>,\n }\n \n /// An equality predicate (unsupported), e.g. `T=int`\n@@ -389,13 +404,15 @@ pub struct WhereEqPredicate {\n     pub ty: P<Ty>,\n }\n \n+pub type CrateConfig = HirVec<P<MetaItem>>;\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n pub struct Crate {\n     pub module: Mod,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub config: CrateConfig,\n     pub span: Span,\n-    pub exported_macros: Vec<MacroDef>,\n+    pub exported_macros: HirVec<MacroDef>,\n \n     // NB: We use a BTreeMap here so that `visit_all_items` iterates\n     // over the ids in increasing order. In principle it should not\n@@ -432,20 +449,20 @@ impl Crate {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MacroDef {\n     pub name: Name,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n     pub imported_from: Option<Name>,\n     pub export: bool,\n     pub use_locally: bool,\n     pub allow_internal_unstable: bool,\n-    pub body: Vec<TokenTree>,\n+    pub body: HirVec<TokenTree>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Block {\n     /// Statements in a block\n-    pub stmts: Vec<Stmt>,\n+    pub stmts: HirVec<Stmt>,\n     /// An expression at the end of the block\n     /// without a semicolon, if any\n     pub expr: Option<P<Expr>>,\n@@ -504,7 +521,7 @@ pub enum Pat_ {\n     PatIdent(BindingMode, Spanned<Ident>, Option<P<Pat>>),\n \n     /// \"None\" means a `Variant(..)` pattern where we don't bind the fields to names.\n-    PatEnum(Path, Option<Vec<P<Pat>>>),\n+    PatEnum(Path, Option<HirVec<P<Pat>>>),\n \n     /// An associated const named using the qualified path `<T>::CONST` or\n     /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n@@ -514,9 +531,9 @@ pub enum Pat_ {\n \n     /// Destructuring of a struct, e.g. `Foo {x, y, ..}`\n     /// The `bool` is `true` in the presence of a `..`\n-    PatStruct(Path, Vec<Spanned<FieldPat>>, bool),\n+    PatStruct(Path, HirVec<Spanned<FieldPat>>, bool),\n     /// A tuple pattern `(a, b)`\n-    PatTup(Vec<P<Pat>>),\n+    PatTup(HirVec<P<Pat>>),\n     /// A `box` pattern\n     PatBox(P<Pat>),\n     /// A reference pattern, e.g. `&mut (a, b)`\n@@ -527,7 +544,7 @@ pub enum Pat_ {\n     PatRange(P<Expr>, P<Expr>),\n     /// `[a, b, ..i, y, z]` is represented as:\n     ///     `PatVec(box [a, b], Some(i), box [y, z])`\n-    PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n+    PatVec(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -641,8 +658,8 @@ pub enum Decl_ {\n /// represents one arm of a 'match'\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Arm {\n-    pub attrs: Vec<Attribute>,\n-    pub pats: Vec<P<Pat>>,\n+    pub attrs: HirVec<Attribute>,\n+    pub pats: HirVec<P<Pat>>,\n     pub guard: Option<P<Expr>>,\n     pub body: P<Expr>,\n }\n@@ -691,12 +708,12 @@ pub enum Expr_ {\n     /// A `box x` expression.\n     ExprBox(P<Expr>),\n     /// An array (`[a, b, c, d]`)\n-    ExprVec(Vec<P<Expr>>),\n+    ExprVec(HirVec<P<Expr>>),\n     /// A function call\n     ///\n     /// The first field resolves to the function itself,\n     /// and the second field is the list of arguments\n-    ExprCall(P<Expr>, Vec<P<Expr>>),\n+    ExprCall(P<Expr>, HirVec<P<Expr>>),\n     /// A method call (`x.foo::<Bar, Baz>(a, b, c, d)`)\n     ///\n     /// The `Spanned<Name>` is the identifier for the method name.\n@@ -709,9 +726,9 @@ pub enum Expr_ {\n     ///\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprMethodCall(foo, [Bar, Baz], [x, a, b, c, d])`.\n-    ExprMethodCall(Spanned<Name>, Vec<P<Ty>>, Vec<P<Expr>>),\n+    ExprMethodCall(Spanned<Name>, HirVec<P<Ty>>, HirVec<P<Expr>>),\n     /// A tuple (`(a, b, c ,d)`)\n-    ExprTup(Vec<P<Expr>>),\n+    ExprTup(HirVec<P<Expr>>),\n     /// A binary operation (For example: `a + b`, `a * b`)\n     ExprBinary(BinOp, P<Expr>, P<Expr>),\n     /// A unary operation (For example: `!x`, `*x`)\n@@ -734,7 +751,7 @@ pub enum Expr_ {\n     ExprLoop(P<Block>, Option<Ident>),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n-    ExprMatch(P<Expr>, Vec<Arm>, MatchSource),\n+    ExprMatch(P<Expr>, HirVec<Arm>, MatchSource),\n     /// A closure (for example, `move |a, b, c| {a + b + c}`)\n     ExprClosure(CaptureClause, P<FnDecl>, P<Block>),\n     /// A block (`{ ... }`)\n@@ -761,7 +778,7 @@ pub enum Expr_ {\n     /// parameters, e.g. foo::bar::<baz>.\n     ///\n     /// Optionally \"qualified\",\n-    /// e.g. `<Vec<T> as SomeTrait>::SomeType`.\n+    /// e.g. `<HirVec<T> as SomeTrait>::SomeType`.\n     ExprPath(Option<QSelf>, Path),\n \n     /// A referencing operation (`&a` or `&mut a`)\n@@ -780,7 +797,7 @@ pub enum Expr_ {\n     ///\n     /// For example, `Foo {x: 1, y: 2}`, or\n     /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n-    ExprStruct(Path, Vec<Field>, Option<P<Expr>>),\n+    ExprStruct(Path, HirVec<Field>, Option<P<Expr>>),\n \n     /// A vector literal constructed from one repeated element.\n     ///\n@@ -794,11 +811,11 @@ pub enum Expr_ {\n /// separately. `position` represents the index of the associated\n /// item qualified with this Self type.\n ///\n-///     <Vec<T> as a::b::Trait>::AssociatedItem\n+///     <HirVec<T> as a::b::Trait>::AssociatedItem\n ///      ^~~~~     ~~~~~~~~~~~~~~^\n ///      ty        position = 3\n ///\n-///     <Vec<T>>::AssociatedItem\n+///     <HirVec<T>>::AssociatedItem\n ///      ^~~~~    ^\n ///      ty       position = 0\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -851,7 +868,7 @@ pub struct MethodSig {\n pub struct TraitItem {\n     pub id: NodeId,\n     pub name: Name,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub node: TraitItem_,\n     pub span: Span,\n }\n@@ -868,7 +885,7 @@ pub struct ImplItem {\n     pub id: NodeId,\n     pub name: Name,\n     pub vis: Visibility,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub node: ImplItemKind,\n     pub span: Span,\n }\n@@ -919,7 +936,7 @@ pub enum PrimTy {\n pub struct BareFnTy {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n-    pub lifetimes: Vec<LifetimeDef>,\n+    pub lifetimes: HirVec<LifetimeDef>,\n     pub decl: P<FnDecl>,\n }\n \n@@ -936,9 +953,9 @@ pub enum Ty_ {\n     /// A bare function (e.g. `fn(usize) -> bool`)\n     TyBareFn(P<BareFnTy>),\n     /// A tuple (`(A, B, C, D,...)`)\n-    TyTup(Vec<P<Ty>>),\n+    TyTup(HirVec<P<Ty>>),\n     /// A path (`module::module::...::Type`), optionally\n-    /// \"qualified\", e.g. `<Vec<T> as SomeTrait>::SomeType`.\n+    /// \"qualified\", e.g. `<HirVec<T> as SomeTrait>::SomeType`.\n     ///\n     /// Type parameters are stored in the Path itself\n     TyPath(Option<QSelf>, Path),\n@@ -965,9 +982,9 @@ pub struct InlineAsmOutput {\n pub struct InlineAsm {\n     pub asm: InternedString,\n     pub asm_str_style: StrStyle,\n-    pub outputs: Vec<InlineAsmOutput>,\n-    pub inputs: Vec<(InternedString, P<Expr>)>,\n-    pub clobbers: Vec<InternedString>,\n+    pub outputs: HirVec<InlineAsmOutput>,\n+    pub inputs: HirVec<(InternedString, P<Expr>)>,\n+    pub clobbers: HirVec<InternedString>,\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,\n@@ -1008,7 +1025,7 @@ impl Arg {\n /// Represents the header (not the body) of a function declaration\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FnDecl {\n-    pub inputs: Vec<Arg>,\n+    pub inputs: HirVec<Arg>,\n     pub output: FunctionRetTy,\n     pub variadic: bool,\n }\n@@ -1099,24 +1116,24 @@ pub struct Mod {\n     /// For `mod foo;`, the inner span ranges from the first token\n     /// to the last token in the external file.\n     pub inner: Span,\n-    pub item_ids: Vec<ItemId>,\n+    pub item_ids: HirVec<ItemId>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignMod {\n     pub abi: Abi,\n-    pub items: Vec<ForeignItem>,\n+    pub items: HirVec<ForeignItem>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct EnumDef {\n-    pub variants: Vec<Variant>,\n+    pub variants: HirVec<Variant>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Variant_ {\n     pub name: Name,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub data: VariantData,\n     /// Explicit discriminant, eg `Foo = 1`\n     pub disr_expr: Option<P<Expr>>,\n@@ -1177,7 +1194,7 @@ pub enum ViewPath_ {\n     ViewPathGlob(Path),\n \n     /// `foo::bar::{a,b,c}`\n-    ViewPathList(Path, Vec<PathListItem>),\n+    ViewPathList(Path, HirVec<PathListItem>),\n }\n \n /// TraitRef's appear in impls.\n@@ -1195,7 +1212,7 @@ pub struct TraitRef {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct PolyTraitRef {\n     /// The `'a` in `<'a> Foo<&'a T>`\n-    pub bound_lifetimes: Vec<LifetimeDef>,\n+    pub bound_lifetimes: HirVec<LifetimeDef>,\n \n     /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`\n     pub trait_ref: TraitRef,\n@@ -1223,7 +1240,7 @@ pub struct StructField_ {\n     pub kind: StructFieldKind,\n     pub id: NodeId,\n     pub ty: P<Ty>,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n }\n \n impl StructField_ {\n@@ -1272,8 +1289,8 @@ impl StructFieldKind {\n /// Id of the whole struct lives in `Item`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum VariantData {\n-    Struct(Vec<StructField>, NodeId),\n-    Tuple(Vec<StructField>, NodeId),\n+    Struct(HirVec<StructField>, NodeId),\n+    Tuple(HirVec<StructField>, NodeId),\n     Unit(NodeId),\n }\n \n@@ -1328,7 +1345,7 @@ pub struct ItemId {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Item {\n     pub name: Name,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub id: NodeId,\n     pub node: Item_,\n     pub vis: Visibility,\n@@ -1361,7 +1378,7 @@ pub enum Item_ {\n     /// A struct definition, e.g. `struct Foo<A> {x: A}`\n     ItemStruct(VariantData, Generics),\n     /// Represents a Trait Declaration\n-    ItemTrait(Unsafety, Generics, TyParamBounds, Vec<TraitItem>),\n+    ItemTrait(Unsafety, Generics, TyParamBounds, HirVec<TraitItem>),\n \n     // Default trait implementations\n     ///\n@@ -1373,7 +1390,7 @@ pub enum Item_ {\n              Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n-             Vec<ImplItem>),\n+             HirVec<ImplItem>),\n }\n \n impl Item_ {\n@@ -1399,7 +1416,7 @@ impl Item_ {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignItem {\n     pub name: Name,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub node: ForeignItem_,\n     pub id: NodeId,\n     pub span: Span,"}, {"sha": "60080854a6f1724441b3ce75f405220aa71b5268", "filename": "src/librustc_front/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_front%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_front%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flib.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -47,6 +47,7 @@ extern crate rustc_bitflags;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n+#[macro_use]\n pub mod hir;\n pub mod lowering;\n pub mod fold;"}, {"sha": "db30ee9a5d2d351b7c61816edcd3fb45ac9a62e5", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 67, "deletions": 64, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -70,7 +70,6 @@ use syntax::attr::{ThinAttributes, ThinAttributesExt};\n use syntax::ext::mtwt;\n use syntax::ptr::P;\n use syntax::codemap::{respan, Spanned, Span};\n-use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n use syntax::std_inject;\n use syntax::visit::{self, Visitor};\n@@ -148,6 +147,10 @@ pub fn lower_ident(_lctx: &LoweringContext, ident: Ident) -> hir::Ident {\n     }\n }\n \n+pub fn lower_attrs(_lctx: &LoweringContext, attrs: &Vec<Attribute>) -> hir::HirVec<Attribute> {\n+    attrs.clone().into()\n+}\n+\n pub fn lower_view_path(lctx: &LoweringContext, view_path: &ViewPath) -> P<hir::ViewPath> {\n     P(Spanned {\n         node: match view_path.node {\n@@ -187,7 +190,7 @@ pub fn lower_view_path(lctx: &LoweringContext, view_path: &ViewPath) -> P<hir::V\n \n pub fn lower_arm(lctx: &LoweringContext, arm: &Arm) -> hir::Arm {\n     hir::Arm {\n-        attrs: arm.attrs.clone(),\n+        attrs: lower_attrs(lctx, &arm.attrs),\n         pats: arm.pats.iter().map(|x| lower_pat(lctx, x)).collect(),\n         guard: arm.guard.as_ref().map(|ref x| lower_expr(lctx, x)),\n         body: lower_expr(lctx, &arm.body),\n@@ -276,7 +279,7 @@ pub fn lower_variant(lctx: &LoweringContext, v: &Variant) -> hir::Variant {\n     Spanned {\n         node: hir::Variant_ {\n             name: v.node.name.name,\n-            attrs: v.node.attrs.clone(),\n+            attrs: lower_attrs(lctx, &v.node.attrs),\n             data: lower_variant_data(lctx, &v.node.data),\n             disr_expr: v.node.disr_expr.as_ref().map(|e| lower_expr(lctx, e)),\n         },\n@@ -430,8 +433,8 @@ pub fn lower_ty_param(lctx: &LoweringContext, tp: &TyParam) -> hir::TyParam {\n }\n \n pub fn lower_ty_params(lctx: &LoweringContext,\n-                       tps: &OwnedSlice<TyParam>)\n-                       -> OwnedSlice<hir::TyParam> {\n+                       tps: &P<[TyParam]>)\n+                       -> P<[hir::TyParam]> {\n     tps.iter().map(|tp| lower_ty_param(lctx, tp)).collect()\n }\n \n@@ -450,13 +453,13 @@ pub fn lower_lifetime_def(lctx: &LoweringContext, l: &LifetimeDef) -> hir::Lifet\n     }\n }\n \n-pub fn lower_lifetimes(lctx: &LoweringContext, lts: &Vec<Lifetime>) -> Vec<hir::Lifetime> {\n+pub fn lower_lifetimes(lctx: &LoweringContext, lts: &Vec<Lifetime>) -> hir::HirVec<hir::Lifetime> {\n     lts.iter().map(|l| lower_lifetime(lctx, l)).collect()\n }\n \n pub fn lower_lifetime_defs(lctx: &LoweringContext,\n                            lts: &Vec<LifetimeDef>)\n-                           -> Vec<hir::LifetimeDef> {\n+                           -> hir::HirVec<hir::LifetimeDef> {\n     lts.iter().map(|l| lower_lifetime_def(lctx, l)).collect()\n }\n \n@@ -561,7 +564,7 @@ pub fn lower_struct_field(lctx: &LoweringContext, f: &StructField) -> hir::Struc\n             id: f.node.id,\n             kind: lower_struct_field_kind(lctx, &f.node.kind),\n             ty: lower_ty(lctx, &f.node.ty),\n-            attrs: f.node.attrs.clone(),\n+            attrs: lower_attrs(lctx, &f.node.attrs),\n         },\n         span: f.span,\n     }\n@@ -583,8 +586,8 @@ pub fn lower_mt(lctx: &LoweringContext, mt: &MutTy) -> hir::MutTy {\n }\n \n pub fn lower_opt_bounds(lctx: &LoweringContext,\n-                        b: &Option<OwnedSlice<TyParamBound>>)\n-                        -> Option<OwnedSlice<hir::TyParamBound>> {\n+                        b: &Option<TyParamBounds>)\n+                        -> Option<hir::TyParamBounds> {\n     b.as_ref().map(|ref bounds| lower_bounds(lctx, bounds))\n }\n \n@@ -674,7 +677,7 @@ pub fn lower_trait_item(lctx: &LoweringContext, i: &TraitItem) -> hir::TraitItem\n     hir::TraitItem {\n         id: i.id,\n         name: i.ident.name,\n-        attrs: i.attrs.clone(),\n+        attrs: lower_attrs(lctx, &i.attrs),\n         node: match i.node {\n             ConstTraitItem(ref ty, ref default) => {\n                 hir::ConstTraitItem(lower_ty(lctx, ty),\n@@ -697,7 +700,7 @@ pub fn lower_impl_item(lctx: &LoweringContext, i: &ImplItem) -> hir::ImplItem {\n     hir::ImplItem {\n         id: i.id,\n         name: i.ident.name,\n-        attrs: i.attrs.clone(),\n+        attrs: lower_attrs(lctx, &i.attrs),\n         vis: lower_visibility(lctx, i.vis),\n         node: match i.node {\n             ImplItemKind::Const(ref ty, ref expr) => {\n@@ -741,25 +744,25 @@ pub fn lower_crate(lctx: &LoweringContext, c: &Crate) -> hir::Crate {\n \n     hir::Crate {\n         module: lower_mod(lctx, &c.module),\n-        attrs: c.attrs.clone(),\n-        config: c.config.clone(),\n+        attrs: lower_attrs(lctx, &c.attrs),\n+        config: c.config.clone().into(),\n         span: c.span,\n         exported_macros: c.exported_macros.iter().map(|m| lower_macro_def(lctx, m)).collect(),\n         items: items,\n     }\n }\n \n-pub fn lower_macro_def(_lctx: &LoweringContext, m: &MacroDef) -> hir::MacroDef {\n+pub fn lower_macro_def(lctx: &LoweringContext, m: &MacroDef) -> hir::MacroDef {\n     hir::MacroDef {\n         name: m.ident.name,\n-        attrs: m.attrs.clone(),\n+        attrs: lower_attrs(lctx, &m.attrs),\n         id: m.id,\n         span: m.span,\n         imported_from: m.imported_from.map(|x| x.name),\n         export: m.export,\n         use_locally: m.use_locally,\n         allow_internal_unstable: m.allow_internal_unstable,\n-        body: m.body.clone(),\n+        body: m.body.clone().into(),\n     }\n }\n \n@@ -773,7 +776,7 @@ pub fn lower_item(lctx: &LoweringContext, i: &Item) -> hir::Item {\n     hir::Item {\n         id: i.id,\n         name: i.ident.name,\n-        attrs: i.attrs.clone(),\n+        attrs: lower_attrs(lctx, &i.attrs),\n         node: node,\n         vis: lower_visibility(lctx, i.vis),\n         span: i.span,\n@@ -784,7 +787,7 @@ pub fn lower_foreign_item(lctx: &LoweringContext, i: &ForeignItem) -> hir::Forei\n     hir::ForeignItem {\n         id: i.id,\n         name: i.ident.name,\n-        attrs: i.attrs.clone(),\n+        attrs: lower_attrs(lctx, &i.attrs),\n         node: match i.node {\n             ForeignItemFn(ref fdec, ref generics) => {\n                 hir::ForeignItemFn(lower_fn_decl(lctx, fdec), lower_generics(lctx, generics))\n@@ -1021,7 +1024,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     // let placer = <placer_expr> ;\n                     let s1 = {\n                         let placer_expr = signal_block_expr(lctx,\n-                                                            vec![],\n+                                                            hir_vec![],\n                                                             placer_expr,\n                                                             e.span,\n                                                             hir::PopUnstableBlock,\n@@ -1032,28 +1035,28 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     // let mut place = Placer::make_place(placer);\n                     let s2 = {\n                         let placer = expr_ident(lctx, e.span, placer_ident, None);\n-                        let call = make_call(lctx, &make_place, vec![placer]);\n+                        let call = make_call(lctx, &make_place, hir_vec![placer]);\n                         mk_stmt_let_mut(lctx, place_ident, call)\n                     };\n \n                     // let p_ptr = Place::pointer(&mut place);\n                     let s3 = {\n                         let agent = expr_ident(lctx, e.span, place_ident, None);\n-                        let args = vec![expr_mut_addr_of(lctx, e.span, agent, None)];\n+                        let args = hir_vec![expr_mut_addr_of(lctx, e.span, agent, None)];\n                         let call = make_call(lctx, &place_pointer, args);\n                         mk_stmt_let(lctx, p_ptr_ident, call)\n                     };\n \n                     // pop_unsafe!(EXPR));\n                     let pop_unsafe_expr = {\n                         let value_expr = signal_block_expr(lctx,\n-                                                           vec![],\n+                                                           hir_vec![],\n                                                            value_expr,\n                                                            e.span,\n                                                            hir::PopUnstableBlock,\n                                                            None);\n                         signal_block_expr(lctx,\n-                                          vec![],\n+                                          hir_vec![],\n                                           value_expr,\n                                           e.span,\n                                           hir::PopUnsafeBlock(hir::CompilerGenerated), None)\n@@ -1067,21 +1070,21 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         let ptr = expr_ident(lctx, e.span, p_ptr_ident, None);\n                         let call_move_val_init =\n                             hir::StmtSemi(\n-                                make_call(lctx, &move_val_init, vec![ptr, pop_unsafe_expr]),\n+                                make_call(lctx, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n                                 lctx.next_id());\n                         let call_move_val_init = respan(e.span, call_move_val_init);\n \n                         let place = expr_ident(lctx, e.span, place_ident, None);\n-                        let call = make_call(lctx, &inplace_finalize, vec![place]);\n+                        let call = make_call(lctx, &inplace_finalize, hir_vec![place]);\n                         signal_block_expr(lctx,\n-                                          vec![call_move_val_init],\n+                                          hir_vec![call_move_val_init],\n                                           call,\n                                           e.span,\n                                           hir::PushUnsafeBlock(hir::CompilerGenerated), None)\n                     };\n \n                     signal_block_expr(lctx,\n-                                      vec![s1, s2, s3],\n+                                      hir_vec![s1, s2, s3],\n                                       expr,\n                                       e.span,\n                                       hir::PushUnstableBlock,\n@@ -1142,7 +1145,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                 let els = lower_expr(lctx, els);\n                                 let id = lctx.next_id();\n                                 let blk = P(hir::Block {\n-                                    stmts: vec![],\n+                                    stmts: hir_vec![],\n                                     expr: Some(els),\n                                     id: id,\n                                     rules: hir::DefaultBlock,\n@@ -1239,7 +1242,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                 .collect(),\n                 asm: asm.clone(),\n                 asm_str_style: asm_str_style,\n-                clobbers: clobbers.clone(),\n+                clobbers: clobbers.clone().into(),\n                 volatile: volatile,\n                 alignstack: alignstack,\n                 dialect: dialect,\n@@ -1276,7 +1279,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     let pat_arm = {\n                         let body = lower_block(lctx, body);\n                         let body_expr = expr_block(lctx, body, None);\n-                        arm(vec![lower_pat(lctx, pat)], body_expr)\n+                        arm(hir_vec![lower_pat(lctx, pat)], body_expr)\n                     };\n \n                     // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n@@ -1291,8 +1294,8 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                         hir::ExprIf(cond, then, else_opt) => {\n                                             let pat_under = pat_wild(lctx, e.span);\n                                             arms.push(hir::Arm {\n-                                                attrs: vec![],\n-                                                pats: vec![pat_under],\n+                                                attrs: hir_vec![],\n+                                                pats: hir_vec![pat_under],\n                                                 guard: Some(cond),\n                                                 body: expr_block(lctx, then, None),\n                                             });\n@@ -1326,8 +1329,8 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         let pat_under = pat_wild(lctx, e.span);\n                         let else_expr =\n                             else_opt.unwrap_or_else(\n-                                || expr_tuple(lctx, e.span, vec![], None));\n-                        arm(vec![pat_under], else_expr)\n+                                || expr_tuple(lctx, e.span, hir_vec![], None));\n+                        arm(hir_vec![pat_under], else_expr)\n                     };\n \n                     let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n@@ -1340,7 +1343,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     expr(lctx,\n                          e.span,\n                          hir::ExprMatch(sub_expr,\n-                                        arms,\n+                                        arms.into(),\n                                         hir::MatchSource::IfLetDesugar {\n                                             contains_else_clause: contains_else_clause,\n                                         }),\n@@ -1365,18 +1368,18 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     let pat_arm = {\n                         let body = lower_block(lctx, body);\n                         let body_expr = expr_block(lctx, body, None);\n-                        arm(vec![lower_pat(lctx, pat)], body_expr)\n+                        arm(hir_vec![lower_pat(lctx, pat)], body_expr)\n                     };\n \n                     // `_ => break`\n                     let break_arm = {\n                         let pat_under = pat_wild(lctx, e.span);\n                         let break_expr = expr_break(lctx, e.span, None);\n-                        arm(vec![pat_under], break_expr)\n+                        arm(hir_vec![pat_under], break_expr)\n                     };\n \n                     // `match <sub_expr> { ... }`\n-                    let arms = vec![pat_arm, break_arm];\n+                    let arms = hir_vec![pat_arm, break_arm];\n                     let sub_expr = lower_expr(lctx, sub_expr);\n                     let match_expr = expr(lctx,\n                                           e.span,\n@@ -1432,14 +1435,14 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         let pat = lower_pat(lctx, pat);\n                         let some_pat = pat_some(lctx, e.span, pat);\n \n-                        arm(vec![some_pat], body_expr)\n+                        arm(hir_vec![some_pat], body_expr)\n                     };\n \n                     // `::std::option::Option::None => break`\n                     let break_arm = {\n                         let break_expr = expr_break(lctx, e.span, None);\n \n-                        arm(vec![pat_none(lctx, e.span)], break_expr)\n+                        arm(hir_vec![pat_none(lctx, e.span)], break_expr)\n                     };\n \n                     // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n@@ -1455,9 +1458,9 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         let next_expr = expr_call(lctx,\n                                                   e.span,\n                                                   next_path,\n-                                                  vec![ref_mut_iter],\n+                                                  hir_vec![ref_mut_iter],\n                                                   None);\n-                        let arms = vec![pat_arm, break_arm];\n+                        let arms = hir_vec![pat_arm, break_arm];\n \n                         expr(lctx,\n                              e.span,\n@@ -1477,7 +1480,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                                               e.span,\n                                                               iter,\n                                                               hir::BindByValue(hir::MutMutable));\n-                        arm(vec![iter_pat], loop_expr)\n+                        arm(hir_vec![iter_pat], loop_expr)\n                     };\n \n                     // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n@@ -1489,21 +1492,21 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         };\n \n                         let into_iter = expr_path(lctx, into_iter_path, None);\n-                        expr_call(lctx, e.span, into_iter, vec![head], None)\n+                        expr_call(lctx, e.span, into_iter, hir_vec![head], None)\n                     };\n \n                     let match_expr = expr_match(lctx,\n                                                 e.span,\n                                                 into_iter_expr,\n-                                                vec![iter_arm],\n+                                                hir_vec![iter_arm],\n                                                 hir::MatchSource::ForLoopDesugar,\n                                                 None);\n \n                     // `{ let result = ...; result }`\n                     let result_ident = lctx.str_to_ident(\"result\");\n                     let let_stmt = stmt_let(lctx, e.span, false, result_ident, match_expr, None);\n                     let result = expr_ident(lctx, e.span, result_ident, None);\n-                    let block = block_all(lctx, e.span, vec![let_stmt], Some(result));\n+                    let block = block_all(lctx, e.span, hir_vec![let_stmt], Some(result));\n                     // add the attributes to the outer returned expr node\n                     expr_block(lctx, block, e.attrs.clone())\n                 });\n@@ -1602,9 +1605,9 @@ pub fn lower_trait_bound_modifier(_lctx: &LoweringContext,\n \n // Helper methods for building HIR.\n \n-fn arm(pats: Vec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n+fn arm(pats: hir::HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n     hir::Arm {\n-        attrs: vec![],\n+        attrs: hir_vec![],\n         pats: pats,\n         guard: None,\n         body: expr,\n@@ -1619,7 +1622,7 @@ fn expr_break(lctx: &LoweringContext, span: Span,\n fn expr_call(lctx: &LoweringContext,\n              span: Span,\n              e: P<hir::Expr>,\n-             args: Vec<P<hir::Expr>>,\n+             args: hir::HirVec<P<hir::Expr>>,\n              attrs: ThinAttributes)\n              -> P<hir::Expr> {\n     expr(lctx, span, hir::ExprCall(e, args), attrs)\n@@ -1643,7 +1646,7 @@ fn expr_path(lctx: &LoweringContext, path: hir::Path,\n fn expr_match(lctx: &LoweringContext,\n               span: Span,\n               arg: P<hir::Expr>,\n-              arms: Vec<hir::Arm>,\n+              arms: hir::HirVec<hir::Arm>,\n               source: hir::MatchSource,\n               attrs: ThinAttributes)\n               -> P<hir::Expr> {\n@@ -1655,7 +1658,7 @@ fn expr_block(lctx: &LoweringContext, b: P<hir::Block>,\n     expr(lctx, b.span, hir::ExprBlock(b), attrs)\n }\n \n-fn expr_tuple(lctx: &LoweringContext, sp: Span, exprs: Vec<P<hir::Expr>>,\n+fn expr_tuple(lctx: &LoweringContext, sp: Span, exprs: hir::HirVec<P<hir::Expr>>,\n               attrs: ThinAttributes) -> P<hir::Expr> {\n     expr(lctx, sp, hir::ExprTup(exprs), attrs)\n }\n@@ -1695,12 +1698,12 @@ fn stmt_let(lctx: &LoweringContext,\n }\n \n fn block_expr(lctx: &LoweringContext, expr: P<hir::Expr>) -> P<hir::Block> {\n-    block_all(lctx, expr.span, Vec::new(), Some(expr))\n+    block_all(lctx, expr.span, hir::HirVec::new(), Some(expr))\n }\n \n fn block_all(lctx: &LoweringContext,\n              span: Span,\n-             stmts: Vec<hir::Stmt>,\n+             stmts: hir::HirVec<hir::Stmt>,\n              expr: Option<P<hir::Expr>>)\n              -> P<hir::Block> {\n     P(hir::Block {\n@@ -1715,19 +1718,19 @@ fn block_all(lctx: &LoweringContext,\n fn pat_some(lctx: &LoweringContext, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n     let some = std_path(lctx, &[\"option\", \"Option\", \"Some\"]);\n     let path = path_global(span, some);\n-    pat_enum(lctx, span, path, vec![pat])\n+    pat_enum(lctx, span, path, hir_vec![pat])\n }\n \n fn pat_none(lctx: &LoweringContext, span: Span) -> P<hir::Pat> {\n     let none = std_path(lctx, &[\"option\", \"Option\", \"None\"]);\n     let path = path_global(span, none);\n-    pat_enum(lctx, span, path, vec![])\n+    pat_enum(lctx, span, path, hir_vec![])\n }\n \n fn pat_enum(lctx: &LoweringContext,\n             span: Span,\n             path: hir::Path,\n-            subpats: Vec<P<hir::Pat>>)\n+            subpats: hir::HirVec<P<hir::Pat>>)\n             -> P<hir::Pat> {\n     let pt = hir::PatEnum(path, Some(subpats));\n     pat(lctx, span, pt)\n@@ -1768,17 +1771,17 @@ fn path_ident(span: Span, id: hir::Ident) -> hir::Path {\n }\n \n fn path(span: Span, strs: Vec<hir::Ident>) -> hir::Path {\n-    path_all(span, false, strs, Vec::new(), Vec::new(), Vec::new())\n+    path_all(span, false, strs, hir::HirVec::new(), Vec::new(), Vec::new())\n }\n \n fn path_global(span: Span, strs: Vec<hir::Ident>) -> hir::Path {\n-    path_all(span, true, strs, Vec::new(), Vec::new(), Vec::new())\n+    path_all(span, true, strs, hir::HirVec::new(), Vec::new(), Vec::new())\n }\n \n fn path_all(sp: Span,\n             global: bool,\n             mut idents: Vec<hir::Ident>,\n-            lifetimes: Vec<hir::Lifetime>,\n+            lifetimes: hir::HirVec<hir::Lifetime>,\n             types: Vec<P<hir::Ty>>,\n             bindings: Vec<hir::TypeBinding>)\n             -> hir::Path {\n@@ -1795,14 +1798,14 @@ fn path_all(sp: Span,\n         identifier: last_identifier,\n         parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n             lifetimes: lifetimes,\n-            types: OwnedSlice::from_vec(types),\n-            bindings: OwnedSlice::from_vec(bindings),\n+            types: P::from_vec(types),\n+            bindings: P::from_vec(bindings),\n         }),\n     });\n     hir::Path {\n         span: sp,\n         global: global,\n-        segments: segments,\n+        segments: segments.into(),\n     }\n }\n \n@@ -1823,7 +1826,7 @@ fn core_path(lctx: &LoweringContext, span: Span, components: &[&str]) -> hir::Pa\n }\n \n fn signal_block_expr(lctx: &LoweringContext,\n-                     stmts: Vec<hir::Stmt>,\n+                     stmts: hir::HirVec<hir::Stmt>,\n                      expr: P<hir::Expr>,\n                      span: Span,\n                      rule: hir::BlockCheckMode,"}, {"sha": "9ac0e65cba33b051e841e38f4648dc6c02b2e247", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -12,7 +12,6 @@ pub use self::AnnNode::*;\n \n use syntax::abi;\n use syntax::ast;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::codemap::{self, CodeMap, BytePos, Spanned};\n use syntax::errors;\n use syntax::parse::token::{self, BinOpToken};\n@@ -519,10 +518,10 @@ impl<'a> State<'a> {\n             hir::TyBareFn(ref f) => {\n                 let generics = hir::Generics {\n                     lifetimes: f.lifetimes.clone(),\n-                    ty_params: OwnedSlice::empty(),\n+                    ty_params: P::empty(),\n                     where_clause: hir::WhereClause {\n                         id: ast::DUMMY_NODE_ID,\n-                        predicates: Vec::new(),\n+                        predicates: hir::HirVec::new(),\n                     },\n                 };\n                 try!(self.print_ty_fn(f.abi, f.unsafety, &*f.decl, None, &generics, None));\n@@ -2257,11 +2256,11 @@ impl<'a> State<'a> {\n             try!(self.print_generics(generics));\n         }\n         let generics = hir::Generics {\n-            lifetimes: Vec::new(),\n-            ty_params: OwnedSlice::empty(),\n+            lifetimes: hir::HirVec::new(),\n+            ty_params: P::empty(),\n             where_clause: hir::WhereClause {\n                 id: ast::DUMMY_NODE_ID,\n-                predicates: Vec::new(),\n+                predicates: hir::HirVec::new(),\n             },\n         };\n         try!(self.print_fn(decl,"}, {"sha": "298904d1e0d7abdcf82df68c090b3a5cceca64eb", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -15,7 +15,6 @@ use syntax::ast_util;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID};\n use syntax::codemap::Span;\n use syntax::ptr::P;\n-use syntax::owned_slice::OwnedSlice;\n \n pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool\n     where F: FnMut(&Pat) -> bool\n@@ -335,11 +334,11 @@ pub fn is_path(e: P<Expr>) -> bool {\n \n pub fn empty_generics() -> Generics {\n     Generics {\n-        lifetimes: Vec::new(),\n-        ty_params: OwnedSlice::empty(),\n+        lifetimes: HirVec::new(),\n+        ty_params: P::empty(),\n         where_clause: WhereClause {\n             id: DUMMY_NODE_ID,\n-            predicates: Vec::new(),\n+            predicates: HirVec::new(),\n         },\n     }\n }\n@@ -350,13 +349,13 @@ pub fn ident_to_path(s: Span, ident: Ident) -> Path {\n     hir::Path {\n         span: s,\n         global: false,\n-        segments: vec!(hir::PathSegment {\n+        segments: hir_vec![hir::PathSegment {\n             identifier: ident,\n             parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n-                lifetimes: Vec::new(),\n-                types: OwnedSlice::empty(),\n-                bindings: OwnedSlice::empty(),\n+                lifetimes: HirVec::new(),\n+                types: P::empty(),\n+                bindings: P::empty(),\n             }),\n-        }),\n+        }],\n     }\n }"}, {"sha": "8f3a1c17440fc56204f3fec8a20da367f5b4ed0c", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -256,7 +256,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n         }\n     }\n \n-    fn to_pats(&mut self, pats: &'tcx Vec<P<hir::Pat>>) -> Vec<Pattern<'tcx>> {\n+    fn to_pats(&mut self, pats: &'tcx [P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n         pats.iter().map(|p| self.to_pat(p)).collect()\n     }\n \n@@ -267,9 +267,9 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n     fn slice_or_array_pattern(&mut self,\n                               pat: &'tcx hir::Pat,\n                               ty: Ty<'tcx>,\n-                              prefix: &'tcx Vec<P<hir::Pat>>,\n+                              prefix: &'tcx [P<hir::Pat>],\n                               slice: &'tcx Option<P<hir::Pat>>,\n-                              suffix: &'tcx Vec<P<hir::Pat>>)\n+                              suffix: &'tcx [P<hir::Pat>])\n                               -> PatternKind<'tcx> {\n         match ty.sty {\n             ty::TySlice(..) => {"}, {"sha": "9c6b54e13796de6b9e2682a0a9c50978b841db8e", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -41,7 +41,6 @@ use std::fs::File;\n use syntax::ast::{self, NodeId};\n use syntax::codemap::*;\n use syntax::parse::token::{self, keywords};\n-use syntax::owned_slice::OwnedSlice;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{path_to_string, ty_to_string};\n use syntax::ptr::P;\n@@ -572,7 +571,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     fn process_trait(&mut self,\n                      item: &ast::Item,\n                      generics: &ast::Generics,\n-                     trait_refs: &OwnedSlice<ast::TyParamBound>,\n+                     trait_refs: &ast::TyParamBounds,\n                      methods: &[P<ast::TraitItem>]) {\n         let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n         let val = self.span.snippet(item.span);"}, {"sha": "038e699a043ab4d755c17484959defab7227ed98", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -1037,7 +1037,7 @@ pub fn trans_static(ccx: &CrateContext,\n                     m: hir::Mutability,\n                     expr: &hir::Expr,\n                     id: ast::NodeId,\n-                    attrs: &Vec<ast::Attribute>)\n+                    attrs: &[ast::Attribute])\n                     -> Result<ValueRef, ConstEvalErr> {\n     unsafe {\n         let _icx = push_ctxt(\"trans_static\");"}, {"sha": "bddf0e9ffb0cb1d205aa00b2c8aff3f1e88010aa", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -119,7 +119,6 @@ use syntax::ast;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{self, Span, Spanned};\n-use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::{self, InternedString};\n use syntax::ptr::P;\n use syntax::util::lev_distance::lev_distance;\n@@ -4907,7 +4906,7 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &hir::Block) -> bool {\n }\n \n pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                       tps: &OwnedSlice<hir::TyParam>,\n+                                       tps: &P<[hir::TyParam]>,\n                                        ty: Ty<'tcx>) {\n     debug!(\"check_bounds_are_used(n_tps={}, ty={:?})\",\n            tps.len(),  ty);"}, {"sha": "675eef637b10b7626a83b476ae79a084b7df973b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -112,7 +112,7 @@ impl<T, U> Clean<U> for ty::Binder<T> where T: Clean<U> {\n     }\n }\n \n-impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::owned_slice::OwnedSlice<T> {\n+impl<T: Clean<U>, U> Clean<Vec<U>> for P<[T]> {\n     fn clean(&self, cx: &DocContext) -> Vec<U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n@@ -1584,8 +1584,13 @@ impl Clean<Type> for hir::Ty {\n                 resolve_type(cx, p.clean(cx), self.id)\n             }\n             TyPath(Some(ref qself), ref p) => {\n-                let mut trait_path = p.clone();\n-                trait_path.segments.pop();\n+                let mut segments: Vec<_> = p.segments.clone().into();\n+                segments.pop();\n+                let trait_path = hir::Path {\n+                    span: p.span,\n+                    global: p.global,\n+                    segments: segments.into(),\n+                };\n                 Type::QPath {\n                     name: p.segments.last().unwrap().identifier.name.clean(cx),\n                     self_type: box qself.ty.clean(cx),"}, {"sha": "fc0422b3a3f037ad6be59491121c57deb068532f", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -24,7 +24,7 @@ use rustc_front::hir;\n \n pub struct Module {\n     pub name: Option<Name>,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub where_outer: Span,\n     pub where_inner: Span,\n     pub extern_crates: Vec<ExternCrate>,\n@@ -58,7 +58,7 @@ impl Module {\n             depr: None,\n             where_outer: syntax::codemap::DUMMY_SP,\n             where_inner: syntax::codemap::DUMMY_SP,\n-            attrs      : Vec::new(),\n+            attrs      : hir::HirVec::new(),\n             extern_crates: Vec::new(),\n             imports    : Vec::new(),\n             structs    : Vec::new(),\n@@ -103,26 +103,26 @@ pub struct Struct {\n     pub struct_type: StructType,\n     pub name: Name,\n     pub generics: hir::Generics,\n-    pub attrs: Vec<ast::Attribute>,\n-    pub fields: Vec<hir::StructField>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub fields: hir::HirVec<hir::StructField>,\n     pub whence: Span,\n }\n \n pub struct Enum {\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n-    pub variants: Vec<Variant>,\n+    pub variants: hir::HirVec<Variant>,\n     pub generics: hir::Generics,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub id: NodeId,\n     pub whence: Span,\n     pub name: Name,\n }\n \n pub struct Variant {\n     pub name: Name,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub def: hir::VariantData,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n@@ -131,7 +131,7 @@ pub struct Variant {\n \n pub struct Function {\n     pub decl: hir::FnDecl,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub id: NodeId,\n     pub name: Name,\n     pub vis: hir::Visibility,\n@@ -149,7 +149,7 @@ pub struct Typedef {\n     pub gen: hir::Generics,\n     pub name: Name,\n     pub id: ast::NodeId,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n@@ -162,7 +162,7 @@ pub struct Static {\n     pub mutability: hir::Mutability,\n     pub expr: P<hir::Expr>,\n     pub name: Name,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n@@ -174,7 +174,7 @@ pub struct Constant {\n     pub type_: P<hir::Ty>,\n     pub expr: P<hir::Expr>,\n     pub name: Name,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n@@ -185,10 +185,10 @@ pub struct Constant {\n pub struct Trait {\n     pub unsafety: hir::Unsafety,\n     pub name: Name,\n-    pub items: Vec<hir::TraitItem>,\n+    pub items: hir::HirVec<hir::TraitItem>,\n     pub generics: hir::Generics,\n-    pub bounds: Vec<hir::TyParamBound>,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub bounds: hir::HirVec<hir::TyParamBound>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub id: ast::NodeId,\n     pub whence: Span,\n     pub vis: hir::Visibility,\n@@ -202,8 +202,8 @@ pub struct Impl {\n     pub generics: hir::Generics,\n     pub trait_: Option<hir::TraitRef>,\n     pub for_: P<hir::Ty>,\n-    pub items: Vec<hir::ImplItem>,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub items: hir::HirVec<hir::ImplItem>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n@@ -215,16 +215,16 @@ pub struct DefaultImpl {\n     pub unsafety: hir::Unsafety,\n     pub trait_: hir::TraitRef,\n     pub id: ast::NodeId,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n }\n \n pub struct Macro {\n     pub name: Name,\n     pub id: ast::NodeId,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n-    pub matchers: Vec<Span>,\n+    pub matchers: hir::HirVec<Span>,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub imported_from: Option<Name>,\n@@ -234,14 +234,14 @@ pub struct ExternCrate {\n     pub name: Name,\n     pub path: Option<String>,\n     pub vis: hir::Visibility,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n }\n \n pub struct Import {\n     pub id: NodeId,\n     pub vis: hir::Visibility,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub node: hir::ViewPath_,\n     pub whence: Span,\n }"}, {"sha": "ba389bc42b78cd30df66543a03e688ef923a9827", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -38,7 +38,7 @@ use doctree::*;\n \n pub struct RustdocVisitor<'a, 'tcx: 'a> {\n     pub module: Module,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub cx: &'a core::DocContext<'a, 'tcx>,\n     pub analysis: Option<&'a core::CrateAnalysis>,\n     view_item_stack: HashSet<ast::NodeId>,\n@@ -53,7 +53,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         stack.insert(ast::CRATE_NODE_ID);\n         RustdocVisitor {\n             module: Module::new(None),\n-            attrs: Vec::new(),\n+            attrs: hir::HirVec::new(),\n             cx: cx,\n             analysis: analysis,\n             view_item_stack: stack,\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n     }\n \n-    pub fn visit_mod_contents(&mut self, span: Span, attrs: Vec<ast::Attribute> ,\n+    pub fn visit_mod_contents(&mut self, span: Span, attrs: hir::HirVec<ast::Attribute>,\n                               vis: hir::Visibility, id: ast::NodeId,\n                               m: &hir::Mod,\n                               name: Option<ast::Name>) -> Module {\n@@ -192,7 +192,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let mine = paths.into_iter().filter(|path| {\n                     !self.resolve_id(path.node.id(), None, false, om,\n                                      please_inline)\n-                }).collect::<Vec<hir::PathListItem>>();\n+                }).collect::<hir::HirVec<hir::PathListItem>>();\n \n                 if mine.is_empty() {\n                     None"}, {"sha": "4b0ec8578c12ed5a869d15fb3e8472c10cef5ed0", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -50,7 +50,6 @@ use codemap::{Span, Spanned, DUMMY_SP, ExpnId};\n use abi::Abi;\n use ext::base;\n use ext::tt::macro_parser;\n-use owned_slice::OwnedSlice;\n use parse::token::InternedString;\n use parse::token;\n use parse::lexer;\n@@ -261,8 +260,8 @@ impl PathParameters {\n     pub fn none() -> PathParameters {\n         AngleBracketedParameters(AngleBracketedParameterData {\n             lifetimes: Vec::new(),\n-            types: OwnedSlice::empty(),\n-            bindings: OwnedSlice::empty(),\n+            types: P::empty(),\n+            bindings: P::empty(),\n         })\n     }\n \n@@ -334,10 +333,10 @@ pub struct AngleBracketedParameterData {\n     /// The lifetime parameters for this path segment.\n     pub lifetimes: Vec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n-    pub types: OwnedSlice<P<Ty>>,\n+    pub types: P<[P<Ty>]>,\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A=Bar>`.\n-    pub bindings: OwnedSlice<P<TypeBinding>>,\n+    pub bindings: P<[P<TypeBinding>]>,\n }\n \n impl AngleBracketedParameterData {\n@@ -394,7 +393,7 @@ pub enum TraitBoundModifier {\n     Maybe,\n }\n \n-pub type TyParamBounds = OwnedSlice<TyParamBound>;\n+pub type TyParamBounds = P<[TyParamBound]>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TyParam {\n@@ -410,7 +409,7 @@ pub struct TyParam {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Generics {\n     pub lifetimes: Vec<LifetimeDef>,\n-    pub ty_params: OwnedSlice<TyParam>,\n+    pub ty_params: P<[TyParam]>,\n     pub where_clause: WhereClause,\n }\n \n@@ -430,7 +429,7 @@ impl Default for Generics {\n     fn default() ->  Generics {\n         Generics {\n             lifetimes: Vec::new(),\n-            ty_params: OwnedSlice::empty(),\n+            ty_params: P::empty(),\n             where_clause: WhereClause {\n                 id: DUMMY_NODE_ID,\n                 predicates: Vec::new(),\n@@ -466,7 +465,7 @@ pub struct WhereBoundPredicate {\n     /// The type being bounded\n     pub bounded_ty: P<Ty>,\n     /// Trait and lifetime bounds (`Clone+Send+'static`)\n-    pub bounds: OwnedSlice<TyParamBound>,\n+    pub bounds: TyParamBounds,\n }\n \n /// A lifetime predicate, e.g. `'a: 'b+'c`"}, {"sha": "d38b771814c2874ae30e24df88d52523e2ffed68", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -12,7 +12,6 @@ use ast::*;\n use ast;\n use codemap;\n use codemap::Span;\n-use owned_slice::OwnedSlice;\n use parse::token;\n use print::pprust;\n use ptr::P;\n@@ -43,8 +42,8 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n                 identifier: identifier,\n                 parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                     lifetimes: Vec::new(),\n-                    types: OwnedSlice::empty(),\n-                    bindings: OwnedSlice::empty(),\n+                    types: P::empty(),\n+                    bindings: P::empty(),\n                 })\n             }\n         ),"}, {"sha": "46a39b98058a2382a9387b9849edb1407a60ec20", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -14,7 +14,6 @@ use ast;\n use attr;\n use codemap::{Span, respan, Spanned, DUMMY_SP, Pos};\n use ext::base::ExtCtxt;\n-use owned_slice::OwnedSlice;\n use parse::token::special_idents;\n use parse::token::InternedString;\n use parse::token;\n@@ -56,7 +55,7 @@ pub trait AstBuilder {\n \n     fn ty(&self, span: Span, ty: ast::Ty_) -> P<ast::Ty>;\n     fn ty_path(&self, ast::Path) -> P<ast::Ty>;\n-    fn ty_sum(&self, ast::Path, OwnedSlice<ast::TyParamBound>) -> P<ast::Ty>;\n+    fn ty_sum(&self, ast::Path, ast::TyParamBounds) -> P<ast::Ty>;\n     fn ty_ident(&self, span: Span, idents: ast::Ident) -> P<ast::Ty>;\n \n     fn ty_rptr(&self, span: Span,\n@@ -70,13 +69,13 @@ pub trait AstBuilder {\n     fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty>;\n     fn ty_infer(&self, sp: Span) -> P<ast::Ty>;\n \n-    fn ty_vars(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n-    fn ty_vars_global(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n+    fn ty_vars(&self, ty_params: &P<[ast::TyParam]>) -> Vec<P<ast::Ty>> ;\n+    fn ty_vars_global(&self, ty_params: &P<[ast::TyParam]>) -> Vec<P<ast::Ty>> ;\n \n     fn typaram(&self,\n                span: Span,\n                id: ast::Ident,\n-               bounds: OwnedSlice<ast::TyParamBound>,\n+               bounds: ast::TyParamBounds,\n                default: Option<P<ast::Ty>>) -> ast::TyParam;\n \n     fn trait_ref(&self, path: ast::Path) -> ast::TraitRef;\n@@ -331,8 +330,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             identifier: last_identifier,\n             parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                 lifetimes: lifetimes,\n-                types: OwnedSlice::from_vec(types),\n-                bindings: OwnedSlice::from_vec(bindings),\n+                types: P::from_vec(types),\n+                bindings: P::from_vec(bindings),\n             })\n         });\n         ast::Path {\n@@ -369,8 +368,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             identifier: ident,\n             parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                 lifetimes: lifetimes,\n-                types: OwnedSlice::from_vec(types),\n-                bindings: OwnedSlice::from_vec(bindings),\n+                types: P::from_vec(types),\n+                bindings: P::from_vec(bindings),\n             })\n         });\n \n@@ -399,7 +398,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.ty(path.span, ast::TyPath(None, path))\n     }\n \n-    fn ty_sum(&self, path: ast::Path, bounds: OwnedSlice<ast::TyParamBound>) -> P<ast::Ty> {\n+    fn ty_sum(&self, path: ast::Path, bounds: ast::TyParamBounds) -> P<ast::Ty> {\n         self.ty(path.span,\n                 ast::TyObjectSum(self.ty_path(path),\n                                  bounds))\n@@ -448,7 +447,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn typaram(&self,\n                span: Span,\n                id: ast::Ident,\n-               bounds: OwnedSlice<ast::TyParamBound>,\n+               bounds: ast::TyParamBounds,\n                default: Option<P<ast::Ty>>) -> ast::TyParam {\n         ast::TyParam {\n             ident: id,\n@@ -462,11 +461,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     // these are strange, and probably shouldn't be used outside of\n     // pipes. Specifically, the global version possible generates\n     // incorrect code.\n-    fn ty_vars(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> {\n+    fn ty_vars(&self, ty_params: &P<[ast::TyParam]>) -> Vec<P<ast::Ty>> {\n         ty_params.iter().map(|p| self.ty_ident(DUMMY_SP, p.ident)).collect()\n     }\n \n-    fn ty_vars_global(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> {\n+    fn ty_vars_global(&self, ty_params: &P<[ast::TyParam]>) -> Vec<P<ast::Ty>> {\n         ty_params\n             .iter()\n             .map(|p| self.ty_path(self.path_global(DUMMY_SP, vec!(p.ident))))"}, {"sha": "cd2210c71b89539c3420f305fccebe6c323f8664", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -23,7 +23,6 @@ use ast;\n use attr::{ThinAttributes, ThinAttributesExt};\n use ast_util;\n use codemap::{respan, Span, Spanned};\n-use owned_slice::OwnedSlice;\n use parse::token;\n use ptr::P;\n use util::small_vector::SmallVector;\n@@ -233,7 +232,7 @@ pub trait Folder : Sized {\n         noop_fold_ty_param(tp, self)\n     }\n \n-    fn fold_ty_params(&mut self, tps: OwnedSlice<TyParam>) -> OwnedSlice<TyParam> {\n+    fn fold_ty_params(&mut self, tps: P<[TyParam]>) -> P<[TyParam]> {\n         noop_fold_ty_params(tps, self)\n     }\n \n@@ -257,13 +256,13 @@ pub trait Folder : Sized {\n         noop_fold_opt_lifetime(o_lt, self)\n     }\n \n-    fn fold_opt_bounds(&mut self, b: Option<OwnedSlice<TyParamBound>>)\n-                       -> Option<OwnedSlice<TyParamBound>> {\n+    fn fold_opt_bounds(&mut self, b: Option<TyParamBounds>)\n+                       -> Option<TyParamBounds> {\n         noop_fold_opt_bounds(b, self)\n     }\n \n-    fn fold_bounds(&mut self, b: OwnedSlice<TyParamBound>)\n-                       -> OwnedSlice<TyParamBound> {\n+    fn fold_bounds(&mut self, b: TyParamBounds)\n+                       -> TyParamBounds {\n         noop_fold_bounds(b, self)\n     }\n \n@@ -714,8 +713,8 @@ pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n     }\n }\n \n-pub fn noop_fold_ty_params<T: Folder>(tps: OwnedSlice<TyParam>, fld: &mut T)\n-                                      -> OwnedSlice<TyParam> {\n+pub fn noop_fold_ty_params<T: Folder>(tps: P<[TyParam]>, fld: &mut T)\n+                                      -> P<[TyParam]> {\n     tps.move_map(|tp| fld.fold_ty_param(tp))\n }\n \n@@ -871,8 +870,8 @@ pub fn noop_fold_mt<T: Folder>(MutTy {ty, mutbl}: MutTy, folder: &mut T) -> MutT\n     }\n }\n \n-pub fn noop_fold_opt_bounds<T: Folder>(b: Option<OwnedSlice<TyParamBound>>, folder: &mut T)\n-                                       -> Option<OwnedSlice<TyParamBound>> {\n+pub fn noop_fold_opt_bounds<T: Folder>(b: Option<TyParamBounds>, folder: &mut T)\n+                                       -> Option<TyParamBounds> {\n     b.map(|bounds| folder.fold_bounds(bounds))\n }\n "}, {"sha": "33a3d5785981ae50f55b9708fecef54b0e9331f2", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 4, "deletions": 97, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -8,100 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::default::Default;\n-use std::fmt;\n-use std::iter::{IntoIterator, FromIterator};\n-use std::ops::Deref;\n-use std::slice;\n-use std::vec;\n-use serialize::{Encodable, Decodable, Encoder, Decoder};\n-\n-/// A non-growable owned slice. This is a separate type to allow the\n-/// representation to change.\n-#[derive(Hash, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct OwnedSlice<T> {\n-    data: Box<[T]>\n-}\n-\n-impl<T:fmt::Debug> fmt::Debug for OwnedSlice<T> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        self.data.fmt(fmt)\n-    }\n-}\n-\n-impl<T> OwnedSlice<T> {\n-    pub fn empty() -> OwnedSlice<T> {\n-        OwnedSlice  { data: Box::new([]) }\n-    }\n-\n-    #[inline(never)]\n-    pub fn from_vec(v: Vec<T>) -> OwnedSlice<T> {\n-        OwnedSlice { data: v.into_boxed_slice() }\n-    }\n-\n-    #[inline(never)]\n-    pub fn into_vec(self) -> Vec<T> {\n-        self.data.into_vec()\n-    }\n-\n-    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n-        &*self.data\n-    }\n-\n-    pub fn move_iter(self) -> vec::IntoIter<T> {\n-        self.into_vec().into_iter()\n-    }\n-\n-    pub fn map<U, F: FnMut(&T) -> U>(&self, f: F) -> OwnedSlice<U> {\n-        self.iter().map(f).collect()\n-    }\n-}\n-\n-impl<T> Deref for OwnedSlice<T> {\n-    type Target = [T];\n-\n-    fn deref(&self) -> &[T] {\n-        self.as_slice()\n-    }\n-}\n-\n-impl<T> Default for OwnedSlice<T> {\n-    fn default() -> OwnedSlice<T> {\n-        OwnedSlice::empty()\n-    }\n-}\n-\n-impl<T: Clone> Clone for OwnedSlice<T> {\n-    fn clone(&self) -> OwnedSlice<T> {\n-        OwnedSlice::from_vec(self.to_vec())\n-    }\n-}\n-\n-impl<T> FromIterator<T> for OwnedSlice<T> {\n-    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> OwnedSlice<T> {\n-        OwnedSlice::from_vec(iter.into_iter().collect())\n-    }\n-}\n-\n-impl<'a, T> IntoIterator for &'a OwnedSlice<T> {\n-    type Item = &'a T;\n-    type IntoIter = slice::Iter<'a, T>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.data.into_iter()\n-    }\n-}\n-\n-impl<T: Encodable> Encodable for OwnedSlice<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        Encodable::encode(&**self, s)\n-    }\n-}\n-\n-impl<T: Decodable> Decodable for OwnedSlice<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<OwnedSlice<T>, D::Error> {\n-        Ok(OwnedSlice::from_vec(match Decodable::decode(d) {\n-            Ok(t) => t,\n-            Err(e) => return Err(e)\n-        }))\n-    }\n-}\n+/// A non-growable owned slice.\n+#[unstable(feature = \"rustc_private\", issue = \"0\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"use `ptr::P<[T]>` instead\")]\n+pub type OwnedSlice<T> = ::ptr::P<[T]>;"}, {"sha": "cff106f838af234c8b72591e313986b141853f78", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -671,7 +671,6 @@ mod tests {\n     use super::*;\n     use std::rc::Rc;\n     use codemap::{Span, BytePos, Pos, Spanned, NO_EXPANSION};\n-    use owned_slice::OwnedSlice;\n     use ast::{self, TokenTree};\n     use abi;\n     use attr::{first_attr_value_str_by_name, AttrMetaMethods};\n@@ -947,7 +946,7 @@ mod tests {\n                                     abi::Rust,\n                                     ast::Generics{ // no idea on either of these:\n                                         lifetimes: Vec::new(),\n-                                        ty_params: OwnedSlice::empty(),\n+                                        ty_params: P::empty(),\n                                         where_clause: ast::WhereClause {\n                                             id: ast::DUMMY_NODE_ID,\n                                             predicates: Vec::new(),"}, {"sha": "ebfcf8c5180cf6454ff133d3902c6d4aca29e058", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -50,7 +50,7 @@ use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n use ast::{Ty, Ty_, TypeBinding, TyMac};\n use ast::{TyFixedLengthVec, TyBareFn, TyTypeof, TyInfer};\n-use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPtr};\n+use ast::{TyParam, TyParamBounds, TyParen, TyPath, TyPtr};\n use ast::{TyRptr, TyTup, TyU32, TyVec};\n use ast::TypeTraitItem;\n use ast::{UnnamedField, UnsafeBlock};\n@@ -73,7 +73,6 @@ use parse::{new_sub_parser_from_file, ParseSess};\n use util::parser::{AssocOp, Fixity};\n use print::pprust;\n use ptr::P;\n-use owned_slice::OwnedSlice;\n use parse::PResult;\n \n use std::collections::HashSet;\n@@ -751,7 +750,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_seq_to_before_gt_or_return<T, F>(&mut self,\n                                                   sep: Option<token::Token>,\n                                                   mut f: F)\n-                                                  -> PResult<(OwnedSlice<T>, bool)> where\n+                                                  -> PResult<(P<[T]>, bool)> where\n         F: FnMut(&mut Parser) -> PResult<Option<T>>,\n     {\n         let mut v = Vec::new();\n@@ -772,7 +771,7 @@ impl<'a> Parser<'a> {\n             if i % 2 == 0 {\n                 match try!(f(self)) {\n                     Some(result) => v.push(result),\n-                    None => return Ok((OwnedSlice::from_vec(v), true))\n+                    None => return Ok((P::from_vec(v), true))\n                 }\n             } else {\n                 if let Some(t) = sep.as_ref() {\n@@ -781,15 +780,15 @@ impl<'a> Parser<'a> {\n \n             }\n         }\n-        return Ok((OwnedSlice::from_vec(v), false));\n+        return Ok((P::from_vec(v), false));\n     }\n \n     /// Parse a sequence bracketed by '<' and '>', stopping\n     /// before the '>'.\n     pub fn parse_seq_to_before_gt<T, F>(&mut self,\n                                         sep: Option<token::Token>,\n                                         mut f: F)\n-                                        -> PResult<OwnedSlice<T>> where\n+                                        -> PResult<P<[T]>> where\n         F: FnMut(&mut Parser) -> PResult<T>,\n     {\n         let (result, returned) = try!(self.parse_seq_to_before_gt_or_return(sep,\n@@ -801,7 +800,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_seq_to_gt<T, F>(&mut self,\n                                  sep: Option<token::Token>,\n                                  f: F)\n-                                 -> PResult<OwnedSlice<T>> where\n+                                 -> PResult<P<[T]>> where\n         F: FnMut(&mut Parser) -> PResult<T>,\n     {\n         let v = try!(self.parse_seq_to_before_gt(sep, f));\n@@ -812,7 +811,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_seq_to_gt_or_return<T, F>(&mut self,\n                                            sep: Option<token::Token>,\n                                            f: F)\n-                                           -> PResult<(OwnedSlice<T>, bool)> where\n+                                           -> PResult<(P<[T]>, bool)> where\n         F: FnMut(&mut Parser) -> PResult<Option<T>>,\n     {\n         let (v, returned) = try!(self.parse_seq_to_before_gt_or_return(sep, f));\n@@ -1076,7 +1075,7 @@ impl<'a> Parser<'a> {\n             let other_bounds = if try!(self.eat(&token::BinOp(token::Plus)) ){\n                 try!(self.parse_ty_param_bounds(BoundParsingMode::Bare))\n             } else {\n-                OwnedSlice::empty()\n+                P::empty()\n             };\n             let all_bounds =\n                 Some(TraitTyParamBound(poly_trait_ref, TraitBoundModifier::None)).into_iter()\n@@ -1709,8 +1708,8 @@ impl<'a> Parser<'a> {\n \n                 ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                     lifetimes: lifetimes,\n-                    types: OwnedSlice::from_vec(types),\n-                    bindings: OwnedSlice::from_vec(bindings),\n+                    types: P::from_vec(types),\n+                    bindings: P::from_vec(bindings),\n                 })\n             } else if try!(self.eat(&token::OpenDelim(token::Paren)) ){\n                 let lo = self.last_span.lo;\n@@ -1773,8 +1772,8 @@ impl<'a> Parser<'a> {\n                     identifier: identifier,\n                     parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                         lifetimes: lifetimes,\n-                        types: OwnedSlice::from_vec(types),\n-                        bindings: OwnedSlice::from_vec(bindings),\n+                        types: P::from_vec(types),\n+                        bindings: P::from_vec(bindings),\n                     }),\n                 });\n \n@@ -3882,10 +3881,10 @@ impl<'a> Parser<'a> {\n     // otherwise returns empty list.\n     fn parse_colon_then_ty_param_bounds(&mut self,\n                                         mode: BoundParsingMode)\n-                                        -> PResult<OwnedSlice<TyParamBound>>\n+                                        -> PResult<TyParamBounds>\n     {\n         if !try!(self.eat(&token::Colon) ){\n-            Ok(OwnedSlice::empty())\n+            Ok(P::empty())\n         } else {\n             self.parse_ty_param_bounds(mode)\n         }\n@@ -3897,7 +3896,7 @@ impl<'a> Parser<'a> {\n     // and     bound     = 'region | trait_ref\n     fn parse_ty_param_bounds(&mut self,\n                              mode: BoundParsingMode)\n-                             -> PResult<OwnedSlice<TyParamBound>>\n+                             -> PResult<TyParamBounds>\n     {\n         let mut result = vec!();\n         loop {\n@@ -3939,7 +3938,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        return Ok(OwnedSlice::from_vec(result));\n+        return Ok(P::from_vec(result));\n     }\n \n     /// Matches typaram = IDENT (`?` unbound)? optbounds ( EQ ty )?"}, {"sha": "1f296dc5d59bd6e83153106d57e0423d1cd6e9a5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -17,7 +17,6 @@ use ast::Attribute;\n use attr::ThinAttributesExt;\n use util::parser::AssocOp;\n use attr;\n-use owned_slice::OwnedSlice;\n use attr::{AttrMetaMethods, AttributeMethods};\n use codemap::{self, CodeMap, BytePos};\n use errors;\n@@ -1001,7 +1000,7 @@ impl<'a> State<'a> {\n             ast::TyBareFn(ref f) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n-                    ty_params: OwnedSlice::empty(),\n+                    ty_params: P::empty(),\n                     where_clause: ast::WhereClause {\n                         id: ast::DUMMY_NODE_ID,\n                         predicates: Vec::new(),\n@@ -3024,7 +3023,7 @@ impl<'a> State<'a> {\n         }\n         let generics = ast::Generics {\n             lifetimes: Vec::new(),\n-            ty_params: OwnedSlice::empty(),\n+            ty_params: P::empty(),\n             where_clause: ast::WhereClause {\n                 id: ast::DUMMY_NODE_ID,\n                 predicates: Vec::new(),"}, {"sha": "1be0b08086d9ce830028441184dc1ee43a285ce7", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 88, "deletions": 18, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -37,14 +37,15 @@\n //!   Moreover, a switch to, e.g. `P<'a, T>` would be easy and mostly automated.\n \n use std::fmt::{self, Display, Debug};\n-use std::hash::{Hash, Hasher};\n+use std::iter::FromIterator;\n use std::ops::Deref;\n-use std::ptr;\n+use std::{ptr, slice, vec};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// An owned smart pointer.\n-pub struct P<T> {\n+#[derive(Hash, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct P<T: ?Sized> {\n     ptr: Box<T>\n }\n \n@@ -92,14 +93,6 @@ impl<T: 'static + Clone> Clone for P<T> {\n     }\n }\n \n-impl<T: PartialEq> PartialEq for P<T> {\n-    fn eq(&self, other: &P<T>) -> bool {\n-        **self == **other\n-    }\n-}\n-\n-impl<T: Eq> Eq for P<T> {}\n-\n impl<T: Debug> Debug for P<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         Debug::fmt(&**self, f)\n@@ -111,19 +104,12 @@ impl<T: Display> Display for P<T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Pointer for P<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Pointer::fmt(&self.ptr, f)\n     }\n }\n \n-impl<T: Hash> Hash for P<T> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        (**self).hash(state);\n-    }\n-}\n-\n impl<T: 'static + Decodable> Decodable for P<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<P<T>, D::Error> {\n         Decodable::decode(d).map(P)\n@@ -135,3 +121,87 @@ impl<T: Encodable> Encodable for P<T> {\n         (**self).encode(s)\n     }\n }\n+\n+\n+impl<T:fmt::Debug> fmt::Debug for P<[T]> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        self.ptr.fmt(fmt)\n+    }\n+}\n+\n+impl<T> P<[T]> {\n+    pub fn empty() -> P<[T]> {\n+        P { ptr: Default::default() }\n+    }\n+\n+    #[inline(never)]\n+    pub fn from_vec(v: Vec<T>) -> P<[T]> {\n+        P { ptr: v.into_boxed_slice() }\n+    }\n+\n+    #[inline(never)]\n+    pub fn into_vec(self) -> Vec<T> {\n+        self.ptr.into_vec()\n+    }\n+\n+    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n+        &*self.ptr\n+    }\n+\n+    pub fn move_iter(self) -> vec::IntoIter<T> {\n+        self.into_vec().into_iter()\n+    }\n+\n+    pub fn map<U, F: FnMut(&T) -> U>(&self, f: F) -> P<[U]> {\n+        self.iter().map(f).collect()\n+    }\n+}\n+\n+impl<T> Deref for P<[T]> {\n+    type Target = [T];\n+\n+    fn deref(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+}\n+\n+impl<T> Default for P<[T]> {\n+    fn default() -> P<[T]> {\n+        P::empty()\n+    }\n+}\n+\n+impl<T: Clone> Clone for P<[T]> {\n+    fn clone(&self) -> P<[T]> {\n+        P::from_vec(self.to_vec())\n+    }\n+}\n+\n+impl<T> FromIterator<T> for P<[T]> {\n+    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> P<[T]> {\n+        P::from_vec(iter.into_iter().collect())\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a P<[T]> {\n+    type Item = &'a T;\n+    type IntoIter = slice::Iter<'a, T>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.ptr.into_iter()\n+    }\n+}\n+\n+impl<T: Encodable> Encodable for P<[T]> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        Encodable::encode(&**self, s)\n+    }\n+}\n+\n+impl<T: Decodable> Decodable for P<[T]> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<P<[T]>, D::Error> {\n+        Ok(P::from_vec(match Decodable::decode(d) {\n+            Ok(t) => t,\n+            Err(e) => return Err(e)\n+        }))\n+    }\n+}"}, {"sha": "9a6d1f8fdab4dd3170c57c63370b8a9733fceb91", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -32,7 +32,6 @@ use ext::expand::ExpansionConfig;\n use fold::Folder;\n use util::move_map::MoveMap;\n use fold;\n-use owned_slice::OwnedSlice;\n use parse::token::{intern, InternedString};\n use parse::{token, ParseSess};\n use print::pprust;"}, {"sha": "e1078b719bf0679f07c4a64be63f6b817e556a42", "filename": "src/libsyntax/util/move_map.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Futil%2Fmove_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax%2Futil%2Fmove_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fmove_map.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use owned_slice::OwnedSlice;\n-\n use std::ptr;\n \n pub trait MoveMap<T>: Sized {\n@@ -69,11 +67,11 @@ impl<T> MoveMap<T> for Vec<T> {\n     }\n }\n \n-impl<T> MoveMap<T> for OwnedSlice<T> {\n+impl<T> MoveMap<T> for ::ptr::P<[T]> {\n     fn move_flat_map<F, I>(self, f: F) -> Self\n         where F: FnMut(T) -> I,\n               I: IntoIterator<Item=T>\n     {\n-        OwnedSlice::from_vec(self.into_vec().move_flat_map(f))\n+        ::ptr::P::from_vec(self.into_vec().move_flat_map(f))\n     }\n }"}, {"sha": "8f316649421a6511a6e2e1e1ae26ece5aadb8398", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -205,7 +205,6 @@ use syntax::codemap::{self, DUMMY_SP};\n use syntax::codemap::Span;\n use syntax::errors::Handler;\n use syntax::util::move_map::MoveMap;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::{intern, InternedString};\n use syntax::parse::token::special_idents;\n use syntax::ptr::P;\n@@ -516,7 +515,7 @@ impl<'a> TraitDef<'a> {\n \n             cx.typaram(self.span,\n                        ty_param.ident,\n-                       OwnedSlice::from_vec(bounds),\n+                       P::from_vec(bounds),\n                        None)\n         }));\n \n@@ -528,7 +527,7 @@ impl<'a> TraitDef<'a> {\n                         span: self.span,\n                         bound_lifetimes: wb.bound_lifetimes.clone(),\n                         bounded_ty: wb.bounded_ty.clone(),\n-                        bounds: OwnedSlice::from_vec(wb.bounds.iter().cloned().collect())\n+                        bounds: P::from_vec(wb.bounds.iter().cloned().collect())\n                     })\n                 }\n                 ast::WherePredicate::RegionPredicate(ref rb) => {\n@@ -579,7 +578,7 @@ impl<'a> TraitDef<'a> {\n                         span: self.span,\n                         bound_lifetimes: vec![],\n                         bounded_ty: ty,\n-                        bounds: OwnedSlice::from_vec(bounds),\n+                        bounds: P::from_vec(bounds),\n                     };\n \n                     let predicate = ast::WherePredicate::BoundPredicate(predicate);\n@@ -590,7 +589,7 @@ impl<'a> TraitDef<'a> {\n \n         let trait_generics = Generics {\n             lifetimes: lifetimes,\n-            ty_params: OwnedSlice::from_vec(ty_params),\n+            ty_params: P::from_vec(ty_params),\n             where_clause: where_clause\n         };\n "}, {"sha": "10564b5f6985b7c407b2c05a9b4b9b758ed288f5", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e953df6f05765679db074b8895ed2178d75eb26/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=9e953df6f05765679db074b8895ed2178d75eb26", "patch": "@@ -19,7 +19,6 @@ use syntax::ast::{Expr,Generics,Ident};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{Span,respan};\n-use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::special_idents;\n use syntax::ptr::P;\n \n@@ -209,7 +208,7 @@ fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam>)\n                -> Generics {\n     Generics {\n         lifetimes: lifetimes,\n-        ty_params: OwnedSlice::from_vec(ty_params),\n+        ty_params: P::from_vec(ty_params),\n         where_clause: ast::WhereClause {\n             id: ast::DUMMY_NODE_ID,\n             predicates: Vec::new(),"}]}