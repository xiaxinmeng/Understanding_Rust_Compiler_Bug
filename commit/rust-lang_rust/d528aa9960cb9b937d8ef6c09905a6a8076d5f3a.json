{"sha": "d528aa9960cb9b937d8ef6c09905a6a8076d5f3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MjhhYTk5NjBjYjliOTM3ZDhlZjZjMDk5MDVhNmE4MDc2ZDVmM2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-01T14:42:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-01T14:42:16Z"}, "message": "Auto merge of #23109 - nikomatsakis:closure-region-hierarchy, r=pnkfelix\n\nAdjust internal treatment of the region hierarchy around closures. Work towards #3696.\r\n\r\nr? @pnkfelix", "tree": {"sha": "e74bc5749004071f457bc770192023776f7696f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e74bc5749004071f457bc770192023776f7696f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a", "html_url": "https://github.com/rust-lang/rust/commit/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89436536246250ee3cbc47a61c31037ce7558c06", "url": "https://api.github.com/repos/rust-lang/rust/commits/89436536246250ee3cbc47a61c31037ce7558c06", "html_url": "https://github.com/rust-lang/rust/commit/89436536246250ee3cbc47a61c31037ce7558c06"}, {"sha": "f15813d086605775514210762ccfd61e21c25599", "url": "https://api.github.com/repos/rust-lang/rust/commits/f15813d086605775514210762ccfd61e21c25599", "html_url": "https://github.com/rust-lang/rust/commit/f15813d086605775514210762ccfd61e21c25599"}], "stats": {"total": 415, "additions": 218, "deletions": 197}, "files": [{"sha": "e44211da4a7bb4cafc94ea5c93cecfe3d55f54f1", "filename": "src/librustc/middle/infer/region_inference/README.md", "status": "modified", "additions": 55, "deletions": 108, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md?ref=d528aa9960cb9b937d8ef6c09905a6a8076d5f3a", "patch": "@@ -249,114 +249,61 @@ there is a reference created whose lifetime does not enclose\n the borrow expression, we must issue sufficient restrictions to ensure\n that the pointee remains valid.\n \n-## Adding closures\n-\n-The other significant complication to the region hierarchy is\n-closures. I will describe here how closures should work, though some\n-of the work to implement this model is ongoing at the time of this\n-writing.\n-\n-The body of closures are type-checked along with the function that\n-creates them. However, unlike other expressions that appear within the\n-function body, it is not entirely obvious when a closure body executes\n-with respect to the other expressions. This is because the closure\n-body will execute whenever the closure is called; however, we can\n-never know precisely when the closure will be called, especially\n-without some sort of alias analysis.\n-\n-However, we can place some sort of limits on when the closure\n-executes.  In particular, the type of every closure `fn:'r K` includes\n-a region bound `'r`. This bound indicates the maximum lifetime of that\n-closure; once we exit that region, the closure cannot be called\n-anymore. Therefore, we say that the lifetime of the closure body is a\n-sublifetime of the closure bound, but the closure body itself is unordered\n-with respect to other parts of the code.\n-\n-For example, consider the following fragment of code:\n-\n-    'a: {\n-         let closure: fn:'a() = || 'b: {\n-             'c: ...\n-         };\n-         'd: ...\n-    }\n-\n-Here we have four lifetimes, `'a`, `'b`, `'c`, and `'d`. The closure\n-`closure` is bounded by the lifetime `'a`. The lifetime `'b` is the\n-lifetime of the closure body, and `'c` is some statement within the\n-closure body. Finally, `'d` is a statement within the outer block that\n-created the closure.\n-\n-We can say that the closure body `'b` is a sublifetime of `'a` due to\n-the closure bound. By the usual lexical scoping conventions, the\n-statement `'c` is clearly a sublifetime of `'b`, and `'d` is a\n-sublifetime of `'d`. However, there is no ordering between `'c` and\n-`'d` per se (this kind of ordering between statements is actually only\n-an issue for dataflow; passes like the borrow checker must assume that\n-closures could execute at any time from the moment they are created\n-until they go out of scope).\n-\n-### Complications due to closure bound inference\n-\n-There is only one problem with the above model: in general, we do not\n-actually *know* the closure bounds during region inference! In fact,\n-closure bounds are almost always region variables! This is very tricky\n-because the inference system implicitly assumes that we can do things\n-like compute the LUB of two scoped lifetimes without needing to know\n-the values of any variables.\n-\n-Here is an example to illustrate the problem:\n-\n-    fn identify<T>(x: T) -> T { x }\n-\n-    fn foo() { // 'foo is the function body\n-      'a: {\n-           let closure = identity(|| 'b: {\n-               'c: ...\n-           });\n-           'd: closure();\n-      }\n-      'e: ...;\n-    }\n-\n-In this example, the closure bound is not explicit. At compile time,\n-we will create a region variable (let's call it `V0`) to represent the\n-closure bound.\n-\n-The primary difficulty arises during the constraint propagation phase.\n-Imagine there is some variable with incoming edges from `'c` and `'d`.\n-This means that the value of the variable must be `LUB('c,\n-'d)`. However, without knowing what the closure bound `V0` is, we\n-can't compute the LUB of `'c` and `'d`! Any we don't know the closure\n-bound until inference is done.\n-\n-The solution is to rely on the fixed point nature of inference.\n-Basically, when we must compute `LUB('c, 'd)`, we just use the current\n-value for `V0` as the closure's bound. If `V0`'s binding should\n-change, then we will do another round of inference, and the result of\n-`LUB('c, 'd)` will change.\n-\n-One minor implication of this is that the graph does not in fact track\n-the full set of dependencies between edges. We cannot easily know\n-whether the result of a LUB computation will change, since there may\n-be indirect dependencies on other variables that are not reflected on\n-the graph. Therefore, we must *always* iterate over all edges when\n-doing the fixed point calculation, not just those adjacent to nodes\n-whose values have changed.\n-\n-Were it not for this requirement, we could in fact avoid fixed-point\n-iteration altogether. In that universe, we could instead first\n-identify and remove strongly connected components (SCC) in the graph.\n-Note that such components must consist solely of region variables; all\n-of these variables can effectively be unified into a single variable.\n-Once SCCs are removed, we are left with a DAG.  At this point, we\n-could walk the DAG in topological order once to compute the expanding\n-nodes, and again in reverse topological order to compute the\n-contracting nodes. However, as I said, this does not work given the\n-current treatment of closure bounds, but perhaps in the future we can\n-address this problem somehow and make region inference somewhat more\n-efficient. Note that this is solely a matter of performance, not\n-expressiveness.\n+## Modeling closures\n+\n+Integrating closures properly into the model is a bit of\n+work-in-progress. In an ideal world, we would model closures as\n+closely as possible after their desugared equivalents. That is, a\n+closure type would be modeled as a struct, and the region hierarchy of\n+different closure bodies would be completely distinct from all other\n+fns. We are generally moving in that direction but there are\n+complications in terms of the implementation.\n+\n+In practice what we currently do is somewhat different. The basis for\n+the current approach is the observation that the only time that\n+regions from distinct fn bodies interact with one another is through\n+an upvar or the type of a fn parameter (since closures live in the fn\n+body namespace, they can in fact have fn parameters whose types\n+include regions from the surrounding fn body). For these cases, there\n+are separate mechanisms which ensure that the regions that appear in\n+upvars/parameters outlive the dynamic extent of each call to the\n+closure:\n+\n+1. Types must outlive the region of any expression where they are used.\n+   For a closure type `C` to outlive a region `'r`, that implies that the\n+   types of all its upvars must outlive `'r`.\n+2. Parameters must outlive the region of any fn that they are passed to.\n+\n+Therefore, we can -- sort of -- assume that any region from an\n+enclosing fns is larger than any region from one of its enclosed\n+fn. And that is precisely what we do: when building the region\n+hierarchy, each region lives in its own distinct subtree, but if we\n+are asked to compute the `LUB(r1, r2)` of two regions, and those\n+regions are in disjoint subtrees, we compare the lexical nesting of\n+the two regions.\n+\n+*Ideas for improving the situation:* (FIXME #3696) The correctness\n+argument here is subtle and a bit hand-wavy. The ideal, as stated\n+earlier, would be to model things in such a way that it corresponds\n+more closely to the desugared code. The best approach for doing this\n+is a bit unclear: it may in fact be possible to *actually* desugar\n+before we start, but I don't think so. The main option that I've been\n+thinking through is imposing a \"view shift\" as we enter the fn body,\n+so that regions appearing in the types of fn parameters and upvars are\n+translated from being regions in the outer fn into free region\n+parameters, just as they would be if we applied the desugaring. The\n+challenge here is that type inference may not have fully run, so the\n+types may not be fully known: we could probably do this translation\n+lazilly, as type variables are instantiated. We would also have to\n+apply a kind of inverse translation to the return value. This would be\n+a good idea anyway, as right now it is possible for free regions\n+instantiated within the closure to leak into the parent: this\n+currently leads to type errors, since those regions cannot outlive any\n+expressions within the parent hierarchy. Much like the current\n+handling of closures, there are no known cases where this leads to a\n+type-checking accepting incorrect code (though it sometimes rejects\n+what might be considered correct code; see rust-lang/rust#22557), but\n+it still doesn't feel like the right approach.\n \n ### Skolemization\n "}, {"sha": "b539dded12e8a65b7e622346053901bfb9a33863", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=d528aa9960cb9b937d8ef6c09905a6a8076d5f3a", "patch": "@@ -760,26 +760,25 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             // at least as big as the block fr.scope_id\".  So, we can\n             // reasonably compare free regions and scopes:\n             let fr_scope = fr.scope.to_code_extent();\n-            match self.tcx.region_maps.nearest_common_ancestor(fr_scope, s_id) {\n+            let r_id = self.tcx.region_maps.nearest_common_ancestor(fr_scope, s_id);\n+\n+            if r_id == fr_scope {\n               // if the free region's scope `fr.scope_id` is bigger than\n               // the scope region `s_id`, then the LUB is the free\n               // region itself:\n-              Some(r_id) if r_id == fr_scope => f,\n-\n+              f\n+            } else {\n               // otherwise, we don't know what the free region is,\n               // so we must conservatively say the LUB is static:\n-              _ => ReStatic\n+              ReStatic\n             }\n           }\n \n           (ReScope(a_id), ReScope(b_id)) => {\n             // The region corresponding to an outer block is a\n             // subtype of the region corresponding to an inner\n             // block.\n-            match self.tcx.region_maps.nearest_common_ancestor(a_id, b_id) {\n-              Some(r_id) => ReScope(r_id),\n-              _ => ReStatic\n-            }\n+            ReScope(self.tcx.region_maps.nearest_common_ancestor(a_id, b_id))\n           }\n \n           (ReFree(ref a_fr), ReFree(ref b_fr)) => {\n@@ -866,9 +865,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 // is the scope `s_id`.  Otherwise, as we do not know\n                 // big the free region is precisely, the GLB is undefined.\n                 let fr_scope = fr.scope.to_code_extent();\n-                match self.tcx.region_maps.nearest_common_ancestor(fr_scope, s_id) {\n-                    Some(r_id) if r_id == fr_scope => Ok(s),\n-                    _ => Err(ty::terr_regions_no_overlap(b, a))\n+                if self.tcx.region_maps.nearest_common_ancestor(fr_scope, s_id) == fr_scope {\n+                    Ok(s)\n+                } else {\n+                    Err(ty::terr_regions_no_overlap(b, a))\n                 }\n             }\n \n@@ -934,10 +934,13 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // it. Otherwise fail.\n         debug!(\"intersect_scopes(scope_a={:?}, scope_b={:?}, region_a={:?}, region_b={:?})\",\n                scope_a, scope_b, region_a, region_b);\n-        match self.tcx.region_maps.nearest_common_ancestor(scope_a, scope_b) {\n-            Some(r_id) if scope_a == r_id => Ok(ReScope(scope_b)),\n-            Some(r_id) if scope_b == r_id => Ok(ReScope(scope_a)),\n-            _ => Err(ty::terr_regions_no_overlap(region_a, region_b))\n+        let r_id = self.tcx.region_maps.nearest_common_ancestor(scope_a, scope_b);\n+        if r_id == scope_a {\n+            Ok(ReScope(scope_b))\n+        } else if r_id == scope_b {\n+            Ok(ReScope(scope_a))\n+        } else {\n+            Err(ty::terr_regions_no_overlap(region_a, region_b))\n         }\n     }\n }"}, {"sha": "b68f8fa9b988d1663b381b34d09c45b641f8fde4", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 144, "deletions": 74, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d528aa9960cb9b937d8ef6c09905a6a8076d5f3a", "patch": "@@ -206,50 +206,66 @@ impl CodeExtent {\n }\n \n /// The region maps encode information about region relationships.\n-///\n-/// - `scope_map` maps from a scope id to the enclosing scope id; this is\n-///   usually corresponding to the lexical nesting, though in the case of\n-///   closures the parent scope is the innermost conditional expression or repeating\n-///   block. (Note that the enclosing scope id for the block\n-///   associated with a closure is the closure itself.)\n-///\n-/// - `var_map` maps from a variable or binding id to the block in which\n-///   that variable is declared.\n-///\n-/// - `free_region_map` maps from a free region `a` to a list of free\n-///   regions `bs` such that `a <= b for all b in bs`\n-///   - the free region map is populated during type check as we check\n-///     each function. See the function `relate_free_regions` for\n-///     more information.\n-///\n-/// - `rvalue_scopes` includes entries for those expressions whose cleanup\n-///   scope is larger than the default. The map goes from the expression\n-///   id to the cleanup scope id. For rvalues not present in this table,\n-///   the appropriate cleanup scope is the innermost enclosing statement,\n-///   conditional expression, or repeating block (see `terminating_scopes`).\n-///\n-/// - `terminating_scopes` is a set containing the ids of each statement,\n-///   or conditional/repeating expression. These scopes are calling \"terminating\n-///   scopes\" because, when attempting to find the scope of a temporary, by\n-///   default we search up the enclosing scopes until we encounter the\n-///   terminating scope. A conditional/repeating\n-///   expression is one which is not guaranteed to execute exactly once\n-///   upon entering the parent scope. This could be because the expression\n-///   only executes conditionally, such as the expression `b` in `a && b`,\n-///   or because the expression may execute many times, such as a loop\n-///   body. The reason that we distinguish such expressions is that, upon\n-///   exiting the parent scope, we cannot statically know how many times\n-///   the expression executed, and thus if the expression creates\n-///   temporaries we cannot know statically how many such temporaries we\n-///   would have to cleanup. Therefore we ensure that the temporaries never\n-///   outlast the conditional/repeating expression, preventing the need\n-///   for dynamic checks and/or arbitrary amounts of stack space.\n pub struct RegionMaps {\n+    /// `scope_map` maps from a scope id to the enclosing scope id;\n+    /// this is usually corresponding to the lexical nesting, though\n+    /// in the case of closures the parent scope is the innermost\n+    /// conditional expression or repeating block. (Note that the\n+    /// enclosing scope id for the block associated with a closure is\n+    /// the closure itself.)\n     scope_map: RefCell<FnvHashMap<CodeExtent, CodeExtent>>,\n+\n+    /// `var_map` maps from a variable or binding id to the block in\n+    /// which that variable is declared.\n     var_map: RefCell<NodeMap<CodeExtent>>,\n+\n+    /// `free_region_map` maps from a free region `a` to a list of\n+    /// free regions `bs` such that `a <= b for all b in bs`\n+    ///\n+    /// NB. the free region map is populated during type check as we\n+    /// check each function. See the function `relate_free_regions`\n+    /// for more information.\n     free_region_map: RefCell<FnvHashMap<FreeRegion, Vec<FreeRegion>>>,\n+\n+    /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n+    /// larger than the default. The map goes from the expression id\n+    /// to the cleanup scope id. For rvalues not present in this\n+    /// table, the appropriate cleanup scope is the innermost\n+    /// enclosing statement, conditional expression, or repeating\n+    /// block (see `terminating_scopes`).\n     rvalue_scopes: RefCell<NodeMap<CodeExtent>>,\n+\n+    /// `terminating_scopes` is a set containing the ids of each\n+    /// statement, or conditional/repeating expression. These scopes\n+    /// are calling \"terminating scopes\" because, when attempting to\n+    /// find the scope of a temporary, by default we search up the\n+    /// enclosing scopes until we encounter the terminating scope. A\n+    /// conditional/repeating expression is one which is not\n+    /// guaranteed to execute exactly once upon entering the parent\n+    /// scope. This could be because the expression only executes\n+    /// conditionally, such as the expression `b` in `a && b`, or\n+    /// because the expression may execute many times, such as a loop\n+    /// body. The reason that we distinguish such expressions is that,\n+    /// upon exiting the parent scope, we cannot statically know how\n+    /// many times the expression executed, and thus if the expression\n+    /// creates temporaries we cannot know statically how many such\n+    /// temporaries we would have to cleanup. Therefore we ensure that\n+    /// the temporaries never outlast the conditional/repeating\n+    /// expression, preventing the need for dynamic checks and/or\n+    /// arbitrary amounts of stack space.\n     terminating_scopes: RefCell<FnvHashSet<CodeExtent>>,\n+\n+    /// Encodes the hierarchy of fn bodies. Every fn body (including\n+    /// closures) forms its own distinct region hierarchy, rooted in\n+    /// the block that is the fn body. This map points from the id of\n+    /// that root block to the id of the root block for the enclosing\n+    /// fn, if any. Thus the map structures the fn bodies into a\n+    /// hierarchy based on their lexical mapping. This is used to\n+    /// handle the relationships between regions in a fn and in a\n+    /// closure defined by that fn. See the \"Modeling closures\"\n+    /// section of the README in middle::infer::region_inference for\n+    /// more details.\n+    fn_tree: RefCell<NodeMap<ast::NodeId>>,\n }\n \n /// Carries the node id for the innermost block or match expression,\n@@ -320,6 +336,14 @@ impl InnermostEnclosingExpr {\n \n #[derive(Debug, Copy)]\n pub struct Context {\n+    /// the root of the current region tree. This is typically the id\n+    /// of the innermost fn body. Each fn forms its own disjoint tree\n+    /// in the region hierarchy. These fn bodies are themselves\n+    /// arranged into a tree. See the \"Modeling closures\" section of\n+    /// the README in middle::infer::region_inference for more\n+    /// details.\n+    root_id: Option<ast::NodeId>,\n+\n     /// the scope that contains any new variables declared\n     var_parent: InnermostDeclaringBlock,\n \n@@ -381,19 +405,40 @@ impl RegionMaps {\n         self.free_region_map.borrow_mut().insert(sub, vec!(sup));\n     }\n \n+    /// Records that `sub_fn` is defined within `sup_fn`. These ids\n+    /// should be the id of the block that is the fn body, which is\n+    /// also the root of the region hierarchy for that fn.\n+    fn record_fn_parent(&self, sub_fn: ast::NodeId, sup_fn: ast::NodeId) {\n+        debug!(\"record_fn_parent(sub_fn={:?}, sup_fn={:?})\", sub_fn, sup_fn);\n+        assert!(sub_fn != sup_fn);\n+        let previous = self.fn_tree.borrow_mut().insert(sub_fn, sup_fn);\n+        assert!(previous.is_none());\n+    }\n+\n+    fn fn_is_enclosed_by(&self, mut sub_fn: ast::NodeId, sup_fn: ast::NodeId) -> bool {\n+        let fn_tree = self.fn_tree.borrow();\n+        loop {\n+            if sub_fn == sup_fn { return true; }\n+            match fn_tree.get(&sub_fn) {\n+                Some(&s) => { sub_fn = s; }\n+                None => { return false; }\n+            }\n+        }\n+    }\n+\n     pub fn record_encl_scope(&self, sub: CodeExtent, sup: CodeExtent) {\n         debug!(\"record_encl_scope(sub={:?}, sup={:?})\", sub, sup);\n         assert!(sub != sup);\n         self.scope_map.borrow_mut().insert(sub, sup);\n     }\n \n-    pub fn record_var_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_var_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id());\n         self.var_map.borrow_mut().insert(var, lifetime);\n     }\n \n-    pub fn record_rvalue_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_rvalue_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id());\n         self.rvalue_scopes.borrow_mut().insert(var, lifetime);\n@@ -402,7 +447,7 @@ impl RegionMaps {\n     /// Records that a scope is a TERMINATING SCOPE. Whenever we create automatic temporaries --\n     /// e.g. by an expression like `a().f` -- they will be freed within the innermost terminating\n     /// scope.\n-    pub fn mark_as_terminating_scope(&self, scope_id: CodeExtent) {\n+    fn mark_as_terminating_scope(&self, scope_id: CodeExtent) {\n         debug!(\"record_terminating_scope(scope_id={:?})\", scope_id);\n         self.terminating_scopes.borrow_mut().insert(scope_id);\n     }\n@@ -562,15 +607,15 @@ impl RegionMaps {\n     pub fn nearest_common_ancestor(&self,\n                                    scope_a: CodeExtent,\n                                    scope_b: CodeExtent)\n-                                   -> Option<CodeExtent> {\n-        if scope_a == scope_b { return Some(scope_a); }\n+                                   -> CodeExtent {\n+        if scope_a == scope_b { return scope_a; }\n \n         let a_ancestors = ancestors_of(self, scope_a);\n         let b_ancestors = ancestors_of(self, scope_b);\n         let mut a_index = a_ancestors.len() - 1;\n         let mut b_index = b_ancestors.len() - 1;\n \n-        // Here, ~[ab]_ancestors is a vector going from narrow to broad.\n+        // Here, [ab]_ancestors is a vector going from narrow to broad.\n         // The end of each vector will be the item where the scope is\n         // defined; if there are any common ancestors, then the tails of\n         // the vector will be the same.  So basically we want to walk\n@@ -579,23 +624,47 @@ impl RegionMaps {\n         // then the corresponding scope is a superscope of the other.\n \n         if a_ancestors[a_index] != b_ancestors[b_index] {\n-            return None;\n+            // In this case, the two regions belong to completely\n+            // different functions.  Compare those fn for lexical\n+            // nesting. The reasoning behind this is subtle.  See the\n+            // \"Modeling closures\" section of the README in\n+            // middle::infer::region_inference for more details.\n+            let a_root_scope = a_ancestors[a_index];\n+            let b_root_scope = a_ancestors[a_index];\n+            return match (a_root_scope, b_root_scope) {\n+                (CodeExtent::DestructionScope(a_root_id),\n+                 CodeExtent::DestructionScope(b_root_id)) => {\n+                    if self.fn_is_enclosed_by(a_root_id, b_root_id) {\n+                        // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n+                        scope_b\n+                    } else if self.fn_is_enclosed_by(b_root_id, a_root_id) {\n+                        // `b` is enclosed by `a`, hence `a` is the ancestor of everything in `b`\n+                        scope_a\n+                    } else {\n+                        // neither fn encloses the other\n+                        unreachable!()\n+                    }\n+                }\n+                _ => {\n+                    // root ids are always Misc right now\n+                    unreachable!()\n+                }\n+            };\n         }\n \n         loop {\n             // Loop invariant: a_ancestors[a_index] == b_ancestors[b_index]\n             // for all indices between a_index and the end of the array\n-            if a_index == 0 { return Some(scope_a); }\n-            if b_index == 0 { return Some(scope_b); }\n+            if a_index == 0 { return scope_a; }\n+            if b_index == 0 { return scope_b; }\n             a_index -= 1;\n             b_index -= 1;\n             if a_ancestors[a_index] != b_ancestors[b_index] {\n-                return Some(a_ancestors[a_index + 1]);\n+                return a_ancestors[a_index + 1];\n             }\n         }\n \n-        fn ancestors_of(this: &RegionMaps, scope: CodeExtent)\n-            -> Vec<CodeExtent> {\n+        fn ancestors_of(this: &RegionMaps, scope: CodeExtent) -> Vec<CodeExtent> {\n             // debug!(\"ancestors_of(scope={:?})\", scope);\n             let mut result = vec!(scope);\n             let mut scope = scope;\n@@ -645,6 +714,7 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n     let prev_cx = visitor.cx;\n \n     let blk_scope = CodeExtent::Misc(blk.id);\n+\n     // If block was previously marked as a terminating scope during\n     // the recursive visit of its parent node in the AST, then we need\n     // to account for the destruction scope representing the extent of\n@@ -684,6 +754,7 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n     // itself has returned.\n \n     visitor.cx = Context {\n+        root_id: prev_cx.root_id,\n         var_parent: InnermostDeclaringBlock::Block(blk.id),\n         parent: InnermostEnclosingExpr::Some(blk.id),\n     };\n@@ -710,6 +781,7 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n                 record_superlifetime(\n                     visitor, declaring.to_code_extent(), statement.span);\n                 visitor.cx = Context {\n+                    root_id: prev_cx.root_id,\n                     var_parent: InnermostDeclaringBlock::Statement(declaring),\n                     parent: InnermostEnclosingExpr::Statement(declaring),\n                 };\n@@ -1103,6 +1175,7 @@ fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &ast::Item) {\n     // Items create a new outer block scope as far as we're concerned.\n     let prev_cx = visitor.cx;\n     visitor.cx = Context {\n+        root_id: None,\n         var_parent: InnermostDeclaringBlock::None,\n         parent: InnermostEnclosingExpr::None\n     };\n@@ -1111,7 +1184,7 @@ fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &ast::Item) {\n }\n \n fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n-              fk: FnKind,\n+              _: FnKind,\n               decl: &ast::FnDecl,\n               body: &ast::Block,\n               sp: Span,\n@@ -1127,42 +1200,36 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n \n     let body_scope = CodeExtent::from_node_id(body.id);\n     visitor.region_maps.mark_as_terminating_scope(body_scope);\n+\n     let dtor_scope = CodeExtent::DestructionScope(body.id);\n     visitor.region_maps.record_encl_scope(body_scope, dtor_scope);\n+\n     record_superlifetime(visitor, dtor_scope, body.span);\n \n+    if let Some(root_id) = visitor.cx.root_id {\n+        visitor.region_maps.record_fn_parent(body.id, root_id);\n+    }\n+\n     let outer_cx = visitor.cx;\n \n     // The arguments and `self` are parented to the body of the fn.\n     visitor.cx = Context {\n+        root_id: Some(body.id),\n         parent: InnermostEnclosingExpr::Some(body.id),\n         var_parent: InnermostDeclaringBlock::Block(body.id)\n     };\n     visit::walk_fn_decl(visitor, decl);\n \n-    // The body of the fn itself is either a root scope (top-level fn)\n-    // or it continues with the inherited scope (closures).\n-    match fk {\n-        visit::FkItemFn(..) | visit::FkMethod(..) => {\n-            visitor.cx = Context {\n-                parent: InnermostEnclosingExpr::None,\n-                var_parent: InnermostDeclaringBlock::None\n-            };\n-            visitor.visit_block(body);\n-            visitor.cx = outer_cx;\n-        }\n-        visit::FkFnBlock(..) => {\n-            // FIXME(#3696) -- at present we are place the closure body\n-            // within the region hierarchy exactly where it appears lexically.\n-            // This is wrong because the closure may live longer\n-            // than the enclosing expression. We should probably fix this,\n-            // but the correct fix is a bit subtle, and I am also not sure\n-            // that the present approach is unsound -- it may not permit\n-            // any illegal programs. See issue for more details.\n-            visitor.cx = outer_cx;\n-            visitor.visit_block(body);\n-        }\n-    }\n+    // The body of the every fn is a root scope.\n+    visitor.cx = Context {\n+        root_id: Some(body.id),\n+        parent: InnermostEnclosingExpr::None,\n+        var_parent: InnermostDeclaringBlock::None\n+    };\n+    visitor.visit_block(body);\n+\n+    // Restore context we had at the start.\n+    visitor.cx = outer_cx;\n }\n \n impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n@@ -1203,12 +1270,14 @@ pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n         free_region_map: RefCell::new(FnvHashMap()),\n         rvalue_scopes: RefCell::new(NodeMap()),\n         terminating_scopes: RefCell::new(FnvHashSet()),\n+        fn_tree: RefCell::new(NodeMap()),\n     };\n     {\n         let mut visitor = RegionResolutionVisitor {\n             sess: sess,\n             region_maps: &maps,\n             cx: Context {\n+                root_id: None,\n                 parent: InnermostEnclosingExpr::None,\n                 var_parent: InnermostDeclaringBlock::None,\n             }\n@@ -1225,6 +1294,7 @@ pub fn resolve_inlined_item(sess: &Session,\n         sess: sess,\n         region_maps: region_maps,\n         cx: Context {\n+            root_id: None,\n             parent: InnermostEnclosingExpr::None,\n             var_parent: InnermostDeclaringBlock::None\n         }"}, {"sha": "ed4d30f300c7803f1dc6a57c94ffb18dc420236d", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=d528aa9960cb9b937d8ef6c09905a6a8076d5f3a", "patch": "@@ -588,6 +588,7 @@ fn lub_free_free() {\n fn lub_returning_scope() {\n     test_env(EMPTY_SOURCE_STR,\n              errors(&[\"cannot infer an appropriate lifetime\"]), |env| {\n+                 env.create_simple_region_hierarchy();\n                  let t_rptr_scope10 = env.t_rptr_scope(10);\n                  let t_rptr_scope11 = env.t_rptr_scope(11);\n "}]}