{"sha": "b921587c91cffe5205b472d562432d5f93374218", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MjE1ODdjOTFjZmZlNTIwNWI0NzJkNTYyNDMyZDVmOTMzNzQyMTg=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-20T16:07:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-20T16:07:12Z"}, "message": "Rollup merge of #71334 - ehuss:pattern-docs, r=kennytm\n\nUpdate pattern docs.\n\nA few changes to help clarify string pattern usage:\n\n* Add some examples and stability information in the `pattern` module.\n* Fixes the links at https://doc.rust-lang.org/std/str/pattern/ because intra-doc-links don't work with re-exported modules (#65983 I think?).\n* Consistently use the same phrasing for `str` methods taking a pattern.\n    * Also mention that array of `char` is also accepted.\n\nWhen `Pattern` is stabilized, the phrasing in the `str` methods can be updated to be more general to reflect the exact behavior. I'm reluctant to do this now because the stability story for `Pattern` is uncertain. It may perhaps look something like:\n\n> The pattern can be any type that implements the [`Pattern`] trait. Notable examples are `&str`, [`char`], arrays of [`char`], or functions or closures that determines if a character matches. Additional libraries might provide more complex patterns like regular expressions.\n\nThis is complicated because methods like `trim_matches` have bounds, which for example don't support `str`, so those methods may need more elaboration.", "tree": {"sha": "dfabe458b912b67789905471180c6bd45171efa4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfabe458b912b67789905471180c6bd45171efa4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b921587c91cffe5205b472d562432d5f93374218", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJencixCRBK7hj4Ov3rIwAAdHIIADkHXZGhNq7WEGGyEumaqL7K\nbhhnxUTefPGms3hnDOh0LNApTPVxqFuuTQHX+IvezwqW7J431htMVosb/z5oedsW\nZilIb8N0HTygOauuvX+CygGuM8aQZNFNftjloSWm4PoPfm+KhjFDY6xeGJuWRkfx\nEJ6wq54nO0W4N+qAhdn7Z0nr7Ij8CQ6RZZnOKbkndfdR6OuDEmsX2Fivy/njBqPv\n3xZLIIuRosQ4M7yzsGY1Txqe4osrmCOrNHMm/82S7PdsKMaMN7fXrt5T3CxB6kz8\n1qY2fdKdNU7DbZg6Sq0p8MSy1DL0DIRnZvyygKvQ3cOF5nyHVr+l2AJY9M6Ne1A=\n=QrxA\n-----END PGP SIGNATURE-----\n", "payload": "tree dfabe458b912b67789905471180c6bd45171efa4\nparent 7561714aa1e4b3478f62357b6826c3587aedfeb5\nparent ca61fd56360f7fb289df11fd51e7392b87100cfd\nauthor Dylan DPC <dylan.dpc@gmail.com> 1587398832 +0200\ncommitter GitHub <noreply@github.com> 1587398832 +0200\n\nRollup merge of #71334 - ehuss:pattern-docs, r=kennytm\n\nUpdate pattern docs.\n\nA few changes to help clarify string pattern usage:\n\n* Add some examples and stability information in the `pattern` module.\n* Fixes the links at https://doc.rust-lang.org/std/str/pattern/ because intra-doc-links don't work with re-exported modules (#65983 I think?).\n* Consistently use the same phrasing for `str` methods taking a pattern.\n    * Also mention that array of `char` is also accepted.\n\nWhen `Pattern` is stabilized, the phrasing in the `str` methods can be updated to be more general to reflect the exact behavior. I'm reluctant to do this now because the stability story for `Pattern` is uncertain. It may perhaps look something like:\n\n> The pattern can be any type that implements the [`Pattern`] trait. Notable examples are `&str`, [`char`], arrays of [`char`], or functions or closures that determines if a character matches. Additional libraries might provide more complex patterns like regular expressions.\n\nThis is complicated because methods like `trim_matches` have bounds, which for example don't support `str`, so those methods may need more elaboration.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b921587c91cffe5205b472d562432d5f93374218", "html_url": "https://github.com/rust-lang/rust/commit/b921587c91cffe5205b472d562432d5f93374218", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b921587c91cffe5205b472d562432d5f93374218/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7561714aa1e4b3478f62357b6826c3587aedfeb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7561714aa1e4b3478f62357b6826c3587aedfeb5", "html_url": "https://github.com/rust-lang/rust/commit/7561714aa1e4b3478f62357b6826c3587aedfeb5"}, {"sha": "ca61fd56360f7fb289df11fd51e7392b87100cfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca61fd56360f7fb289df11fd51e7392b87100cfd", "html_url": "https://github.com/rust-lang/rust/commit/ca61fd56360f7fb289df11fd51e7392b87100cfd"}], "stats": {"total": 187, "additions": 150, "deletions": 37}, "files": [{"sha": "2c11d5cd25759f7d3386719a8d32e4fa83ae6786", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 115, "deletions": 36, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/b921587c91cffe5205b472d562432d5f93374218/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b921587c91cffe5205b472d562432d5f93374218/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=b921587c91cffe5205b472d562432d5f93374218", "patch": "@@ -3010,6 +3010,12 @@ impl str {\n     ///\n     /// Returns `false` if it does not.\n     ///\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -3031,6 +3037,12 @@ impl str {\n     ///\n     /// Returns `false` if it does not.\n     ///\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -3051,6 +3063,12 @@ impl str {\n     ///\n     /// Returns `false` if it does not.\n     ///\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -3074,10 +3092,12 @@ impl str {\n     ///\n     /// Returns [`None`] if the pattern doesn't match.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n     ///\n     /// [`None`]: option/enum.Option.html#variant.None\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// # Examples\n     ///\n@@ -3121,10 +3141,12 @@ impl str {\n     ///\n     /// Returns [`None`] if the pattern doesn't match.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n     ///\n     /// [`None`]: option/enum.Option.html#variant.None\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// # Examples\n     ///\n@@ -3166,8 +3188,11 @@ impl str {\n     /// An iterator over substrings of this string slice, separated by\n     /// characters matched by a pattern.\n     ///\n-    /// The pattern can be any type that implements the Pattern trait. Notable\n-    /// examples are `&str`, [`char`], and closures that determines the split.\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3285,6 +3310,12 @@ impl str {\n     /// `split` in that `split_inclusive` leaves the matched part as the\n     /// terminator of the substring.\n     ///\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -3319,8 +3350,11 @@ impl str {\n     /// An iterator over substrings of the given string slice, separated by\n     /// characters matched by a pattern and yielded in reverse order.\n     ///\n-    /// The pattern can be any type that implements the Pattern trait. Notable\n-    /// examples are `&str`, [`char`], and closures that determines the split.\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3370,8 +3404,11 @@ impl str {\n     /// An iterator over substrings of the given string slice, separated by\n     /// characters matched by a pattern.\n     ///\n-    /// The pattern can be any type that implements the Pattern trait. Notable\n-    /// examples are `&str`, [`char`], and closures that determines the split.\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// Equivalent to [`split`], except that the trailing substring\n     /// is skipped if empty.\n@@ -3414,10 +3451,11 @@ impl str {\n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by a pattern and yielded in reverse order.\n     ///\n-    /// The pattern can be any type that implements the Pattern trait. Notable\n-    /// examples are `&str`, [`char`], and closures that determines the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// Equivalent to [`split`], except that the trailing substring is\n     /// skipped if empty.\n@@ -3462,8 +3500,11 @@ impl str {\n     /// If `n` substrings are returned, the last substring (the `n`th substring)\n     /// will contain the remainder of the string.\n     ///\n-    /// The pattern can be any type that implements the Pattern trait. Notable\n-    /// examples are `&str`, [`char`], and closures that determines the split.\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3512,8 +3553,11 @@ impl str {\n     /// If `n` substrings are returned, the last substring (the `n`th substring)\n     /// will contain the remainder of the string.\n     ///\n-    /// The pattern can be any type that implements the Pattern trait. Notable\n-    /// examples are `&str`, [`char`], and closures that determines the split.\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3557,8 +3601,11 @@ impl str {\n     /// An iterator over the disjoint matches of a pattern within the given string\n     /// slice.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3593,8 +3640,11 @@ impl str {\n     /// An iterator over the disjoint matches of a pattern within this string slice,\n     /// yielded in reverse order.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3634,8 +3684,11 @@ impl str {\n     /// For matches of `pat` within `self` that overlap, only the indices\n     /// corresponding to the first match are returned.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines\n-    /// if a character matches.\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3676,8 +3729,11 @@ impl str {\n     /// For matches of `pat` within `self` that overlap, only the indices\n     /// corresponding to the last match are returned.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if a\n-    /// character matches.\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// # Iterator behavior\n     ///\n@@ -3894,8 +3950,11 @@ impl str {\n     /// Returns a string slice with all prefixes and suffixes that match a\n     /// pattern repeatedly removed.\n     ///\n-    /// The pattern can be a [`char`] or a closure that determines if a\n-    /// character matches.\n+    /// The [pattern] can be a [`char`], a slice of [`char`]s, or a function\n+    /// or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// # Examples\n     ///\n@@ -3939,8 +3998,11 @@ impl str {\n     /// Returns a string slice with all prefixes that match a pattern\n     /// repeatedly removed.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// # Text directionality\n     ///\n@@ -3981,6 +4043,12 @@ impl str {\n     ///\n     /// If the string does not start with `prefix`, `None` is returned.\n     ///\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -4005,6 +4073,12 @@ impl str {\n     ///\n     /// If the string does not end with `suffix`, `None` is returned.\n     ///\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -4027,8 +4101,11 @@ impl str {\n     /// Returns a string slice with all suffixes that match a pattern\n     /// repeatedly removed.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines if a character matches.\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// # Text directionality\n     ///\n@@ -4073,10 +4150,11 @@ impl str {\n     /// Returns a string slice with all prefixes that match a pattern\n     /// repeatedly removed.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n-    /// a character matches.\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n     ///\n     /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// # Text directionality\n     ///\n@@ -4109,10 +4187,11 @@ impl str {\n     /// Returns a string slice with all suffixes that match a pattern\n     /// repeatedly removed.\n     ///\n-    /// The pattern can be a `&str`, [`char`], or a closure that\n-    /// determines if a character matches.\n+    /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n+    /// function or closure that determines if a character matches.\n     ///\n     /// [`char`]: primitive.char.html\n+    /// [pattern]: str/pattern/index.html\n     ///\n     /// # Text directionality\n     ///"}, {"sha": "2377536c156fa815ea9d0c7979b202c5983ba632", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b921587c91cffe5205b472d562432d5f93374218/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b921587c91cffe5205b472d562432d5f93374218/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=b921587c91cffe5205b472d562432d5f93374218", "patch": "@@ -1,7 +1,41 @@\n //! The string Pattern API.\n //!\n+//! The Pattern API provides a generic mechanism for using different pattern\n+//! types when searching through a string.\n+//!\n //! For more details, see the traits [`Pattern`], [`Searcher`],\n //! [`ReverseSearcher`], and [`DoubleEndedSearcher`].\n+//!\n+//! Although this API is unstable, it is exposed via stable APIs on the\n+//! [`str`] type.\n+//!\n+//! # Examples\n+//!\n+//! [`Pattern`] is [implemented][pattern-impls] in the stable API for\n+//! [`&str`], [`char`], slices of [`char`], and functions and closures\n+//! implementing `FnMut(char) -> bool`.\n+//!\n+//! ```\n+//! let s = \"Can you find a needle in a haystack?\";\n+//!\n+//! // &str pattern\n+//! assert_eq!(s.find(\"you\"), Some(4));\n+//! // char pattern\n+//! assert_eq!(s.find('n'), Some(2));\n+//! // slice of chars pattern\n+//! assert_eq!(s.find(&['a', 'e', 'i', 'o', 'u'][..]), Some(1));\n+//! // closure pattern\n+//! assert_eq!(s.find(|c: char| c.is_ascii_punctuation()), Some(35));\n+//! ```\n+//!\n+//! [`&str`]: ../../../std/primitive.str.html\n+//! [`char`]: ../../../std/primitive.char.html\n+//! [`str`]: ../../../std/primitive.str.html\n+//! [`DoubleEndedSearcher`]: trait.DoubleEndedSearcher.html\n+//! [`Pattern`]: trait.Pattern.html\n+//! [`ReverseSearcher`]: trait.ReverseSearcher.html\n+//! [`Searcher`]: trait.Searcher.html\n+//! [pattern-impls]: trait.Pattern.html#implementors\n \n #![unstable(\n     feature = \"pattern\",\n@@ -702,7 +736,7 @@ unsafe impl<'a, 'b> ReverseSearcher<'a> for CharSliceSearcher<'a, 'b> {\n \n impl<'a, 'b> DoubleEndedSearcher<'a> for CharSliceSearcher<'a, 'b> {}\n \n-/// Searches for chars that are equal to any of the chars in the array.\n+/// Searches for chars that are equal to any of the chars in the slice.\n ///\n /// # Examples\n ///"}]}