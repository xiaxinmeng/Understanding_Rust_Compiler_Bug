{"sha": "221edbae3843848047825701e25b6f9d8b096075", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyMWVkYmFlMzg0Mzg0ODA0NzgyNTcwMWUyNWI2ZjlkOGIwOTYwNzU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-04T02:52:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-06T11:48:23Z"}, "message": "Support parenthesized paths `Foo(A,B) -> C` that expand to `Foo<(A,B),C>`. These paths also bind anonymous regions (or will, once HRTB is fully working).\n\nFixes #18423.", "tree": {"sha": "db2ef27822cf4598c34ff28e3b1bd4ec27cbb910", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db2ef27822cf4598c34ff28e3b1bd4ec27cbb910"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/221edbae3843848047825701e25b6f9d8b096075", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/221edbae3843848047825701e25b6f9d8b096075", "html_url": "https://github.com/rust-lang/rust/commit/221edbae3843848047825701e25b6f9d8b096075", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/221edbae3843848047825701e25b6f9d8b096075/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e352892c8ca76f49332fb74d9903677dea2c5fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e352892c8ca76f49332fb74d9903677dea2c5fe", "html_url": "https://github.com/rust-lang/rust/commit/4e352892c8ca76f49332fb74d9903677dea2c5fe"}], "stats": {"total": 1103, "additions": 840, "deletions": 263}, "files": [{"sha": "d5e9c1ef99f111f160310b936b5713de02a886d0", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -57,7 +57,6 @@ register_diagnostics!(\n     E0044,\n     E0045,\n     E0046,\n-    E0047,\n     E0049,\n     E0050,\n     E0051,\n@@ -111,7 +110,6 @@ register_diagnostics!(\n     E0108,\n     E0109,\n     E0110,\n-    E0113,\n     E0116,\n     E0117,\n     E0118,\n@@ -145,5 +143,6 @@ register_diagnostics!(\n     E0163,\n     E0164,\n     E0165,\n-    E0166\n+    E0166,\n+    E0167\n )"}, {"sha": "2838456630367e53b5d76f4459582dde9a509ecd", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -138,7 +138,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n             // to handle on-demand instantiation of functions via\n             // foo::<bar> in a const. Currently that is only done on\n             // a path in trans::callee that only works in block contexts.\n-            if !pth.segments.iter().all(|segment| segment.types.is_empty()) {\n+            if !pth.segments.iter().all(|segment| segment.parameters.is_empty()) {\n                 span_err!(v.tcx.sess, e.span, E0013,\n                           \"paths in constants may only refer to items without \\\n                            type parameters\");"}, {"sha": "f1d8c550d04fa9d5ab859e6edf5e8d93fac07bcd", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -16,7 +16,6 @@ use std::collections::HashMap;\n use syntax::ast::*;\n use syntax::ast_util::{walk_pat};\n use syntax::codemap::{Span, DUMMY_SP};\n-use syntax::owned_slice::OwnedSlice;\n \n pub type PatIdMap = HashMap<Ident, NodeId>;\n \n@@ -133,8 +132,7 @@ pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n         global: false,\n         segments: path.last().map(|elem| PathSegment {\n             identifier: Ident::new(elem.name()),\n-            lifetimes: vec!(),\n-            types: OwnedSlice::empty()\n+            parameters: PathParameters::none(),\n         }).into_iter().collect(),\n         span: DUMMY_SP,\n     })"}, {"sha": "7124488f7c1661033b7eadb011616d5dfe2f2a2f", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -27,7 +27,6 @@ use syntax::ast_map;\n use syntax::ast_util::{is_local, local_def, PostExpansionMethod};\n use syntax::codemap::Span;\n use syntax::parse::token;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -945,8 +944,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                                     debug!(\"privacy - ident item {}\", id);\n                                     let seg = ast::PathSegment {\n                                         identifier: name,\n-                                        lifetimes: Vec::new(),\n-                                        types: OwnedSlice::empty(),\n+                                        parameters: ast::PathParameters::none(),\n                                     };\n                                     let segs = vec![seg];\n                                     let path = ast::Path {"}, {"sha": "34f0cb7c19823f26e87e0f4ef453ff24e0deb39b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -4951,12 +4951,12 @@ impl<'a> Resolver<'a> {\n \n                             if path.segments\n                                    .iter()\n-                                   .any(|s| !s.lifetimes.is_empty()) {\n+                                   .any(|s| s.parameters.has_lifetimes()) {\n                                 span_err!(self.session, path.span, E0157,\n                                     \"lifetime parameters are not allowed on this type\");\n                             } else if path.segments\n                                           .iter()\n-                                          .any(|s| s.types.len() > 0) {\n+                                          .any(|s| !s.parameters.is_empty()) {\n                                 span_err!(self.session, path.span, E0153,\n                                     \"type parameters are not allowed on this type\");\n                             }\n@@ -5234,7 +5234,7 @@ impl<'a> Resolver<'a> {\n                     // Check the types in the path pattern.\n                     for ty in path.segments\n                                   .iter()\n-                                  .flat_map(|s| s.types.iter()) {\n+                                  .flat_map(|s| s.parameters.types().into_iter()) {\n                         self.resolve_type(&**ty);\n                     }\n                 }\n@@ -5340,7 +5340,7 @@ impl<'a> Resolver<'a> {\n                     namespace: Namespace,\n                     check_ribs: bool) -> Option<(Def, LastPrivate)> {\n         // First, resolve the types.\n-        for ty in path.segments.iter().flat_map(|s| s.types.iter()) {\n+        for ty in path.segments.iter().flat_map(|s| s.parameters.types().into_iter()) {\n             self.resolve_type(&**ty);\n         }\n "}, {"sha": "c73268317bdc1c5aa01cba87b4fc1d431f914475", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -1836,11 +1836,7 @@ pub fn trans_closure(ccx: &CrateContext,\n         NotUnboxedClosure => monomorphized_arg_types,\n \n         // Tuple up closure argument types for the \"rust-call\" ABI.\n-        IsUnboxedClosure => vec![if monomorphized_arg_types.is_empty() {\n-            ty::mk_nil()\n-        } else {\n-            ty::mk_tup(ccx.tcx(), monomorphized_arg_types)\n-        }]\n+        IsUnboxedClosure => vec![ty::mk_tup_or_nil(ccx.tcx(), monomorphized_arg_types)]\n     };\n     for monomorphized_arg_type in monomorphized_arg_types.iter() {\n         debug!(\"trans_closure: monomorphized_arg_type: {}\","}, {"sha": "bd43aa47906e6d35fd1e71b64a5092c3056f43c8", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -625,7 +625,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n           }\n           ast::ExprPath(ref pth) => {\n             // Assert that there are no type parameters in this path.\n-            assert!(pth.segments.iter().all(|seg| seg.types.is_empty()));\n+            assert!(pth.segments.iter().all(|seg| !seg.parameters.has_types()));\n \n             let opt_def = cx.tcx().def_map.borrow().find_copy(&e.id);\n             match opt_def {"}, {"sha": "9c717b98f35de4a50ad9a1d5e8fe023c06fd87cf", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -1838,6 +1838,14 @@ pub fn mk_slice(cx: &ctxt, r: Region, tm: mt) -> t {\n \n pub fn mk_tup(cx: &ctxt, ts: Vec<t>) -> t { mk_t(cx, ty_tup(ts)) }\n \n+pub fn mk_tup_or_nil(cx: &ctxt, ts: Vec<t>) -> t {\n+    if ts.len() == 0 {\n+        ty::mk_nil()\n+    } else {\n+        mk_t(cx, ty_tup(ts))\n+    }\n+}\n+\n pub fn mk_closure(cx: &ctxt, fty: ClosureTy) -> t {\n     mk_t(cx, ty_closure(box fty))\n }"}, {"sha": "f2cc3bfd29b9f5a2ec93bf990b5f25196bcc254d", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 139, "deletions": 91, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -59,7 +59,7 @@ use middle::subst::{VecPerParamSpace};\n use middle::ty;\n use middle::typeck::lookup_def_tcx;\n use middle::typeck::infer;\n-use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope};\n+use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope, BindingRscope};\n use middle::typeck::rscope;\n use middle::typeck::TypeAndSubsts;\n use middle::typeck;\n@@ -207,15 +207,16 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n }\n \n fn ast_path_substs<'tcx,AC,RS>(\n-                   this: &AC,\n-                   rscope: &RS,\n-                   decl_def_id: ast::DefId,\n-                   decl_generics: &ty::Generics,\n-                   self_ty: Option<ty::t>,\n-                   associated_ty: Option<ty::t>,\n-                   path: &ast::Path)\n-                   -> Substs\n-                   where AC: AstConv<'tcx>, RS: RegionScope\n+    this: &AC,\n+    rscope: &RS,\n+    decl_def_id: ast::DefId,\n+    decl_generics: &ty::Generics,\n+    self_ty: Option<ty::t>,\n+    associated_ty: Option<ty::t>,\n+    path: &ast::Path,\n+    binder_id: ast::NodeId)\n+    -> Substs\n+    where AC: AstConv<'tcx>, RS: RegionScope\n {\n     /*!\n      * Given a path `path` that refers to an item `I` with the\n@@ -236,67 +237,73 @@ fn ast_path_substs<'tcx,AC,RS>(\n     assert!(decl_generics.regions.all(|d| d.space == TypeSpace));\n     assert!(decl_generics.types.all(|d| d.space != FnSpace));\n \n+    let (regions, types) = match path.segments.last().unwrap().parameters {\n+        ast::AngleBracketedParameters(ref data) =>\n+            angle_bracketed_parameters(this, rscope, data),\n+        ast::ParenthesizedParameters(ref data) =>\n+            parenthesized_parameters(this, binder_id, data),\n+    };\n+\n     // If the type is parameterized by the this region, then replace this\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n     let expected_num_region_params = decl_generics.regions.len(TypeSpace);\n-    let supplied_num_region_params = path.segments.last().unwrap().lifetimes.len();\n+    let supplied_num_region_params = regions.len();\n     let regions = if expected_num_region_params == supplied_num_region_params {\n-        path.segments.last().unwrap().lifetimes.iter().map(\n-            |l| ast_region_to_region(this.tcx(), l)).collect::<Vec<_>>()\n+        regions\n     } else {\n         let anon_regions =\n             rscope.anon_regions(path.span, expected_num_region_params);\n \n         if supplied_num_region_params != 0 || anon_regions.is_err() {\n             span_err!(tcx.sess, path.span, E0107,\n-                \"wrong number of lifetime parameters: expected {}, found {}\",\n-                expected_num_region_params, supplied_num_region_params);\n+                      \"wrong number of lifetime parameters: expected {}, found {}\",\n+                      expected_num_region_params, supplied_num_region_params);\n         }\n \n         match anon_regions {\n             Ok(v) => v.into_iter().collect(),\n             Err(_) => Vec::from_fn(expected_num_region_params,\n-                                    |_| ty::ReStatic) // hokey\n+                                   |_| ty::ReStatic) // hokey\n         }\n     };\n \n     // Convert the type parameters supplied by the user.\n     let ty_param_defs = decl_generics.types.get_slice(TypeSpace);\n-    let supplied_ty_param_count = path.segments.iter().flat_map(|s| s.types.iter()).count();\n+    let supplied_ty_param_count = types.len();\n     let formal_ty_param_count =\n         ty_param_defs.iter()\n-                     .take_while(|x| !ty::is_associated_type(tcx, x.def_id))\n-                     .count();\n+        .take_while(|x| !ty::is_associated_type(tcx, x.def_id))\n+        .count();\n     let required_ty_param_count =\n         ty_param_defs.iter()\n-                     .take_while(|x| {\n-                        x.default.is_none() &&\n-                        !ty::is_associated_type(tcx, x.def_id)\n-                     })\n-                     .count();\n+        .take_while(|x| {\n+            x.default.is_none() &&\n+                !ty::is_associated_type(tcx, x.def_id)\n+        })\n+        .count();\n     if supplied_ty_param_count < required_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at least\"\n         } else {\n             \"expected\"\n         };\n         this.tcx().sess.span_fatal(path.span,\n-            format!(\"wrong number of type arguments: {} {}, found {}\",\n-                    expected,\n-                    required_ty_param_count,\n-                    supplied_ty_param_count).as_slice());\n+                                   format!(\"wrong number of type arguments: {} {}, found {}\",\n+                                           expected,\n+                                           required_ty_param_count,\n+                                           supplied_ty_param_count).as_slice());\n     } else if supplied_ty_param_count > formal_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at most\"\n         } else {\n             \"expected\"\n         };\n         this.tcx().sess.span_fatal(path.span,\n-            format!(\"wrong number of type arguments: {} {}, found {}\",\n-                    expected,\n-                    formal_ty_param_count,\n-                    supplied_ty_param_count).as_slice());\n+                                   format!(\"wrong number of type arguments: {} {}, found {}\",\n+                                           expected,\n+                                           formal_ty_param_count,\n+                                           supplied_ty_param_count).as_slice());\n     }\n \n     if supplied_ty_param_count > required_ty_param_count\n@@ -307,13 +314,7 @@ fn ast_path_substs<'tcx,AC,RS>(\n             \"add #![feature(default_type_params)] to the crate attributes to enable\");\n     }\n \n-    let tps = path.segments\n-                  .iter()\n-                  .flat_map(|s| s.types.iter())\n-                  .map(|a_t| ast_ty_to_ty(this, rscope, &**a_t))\n-                  .collect();\n-\n-    let mut substs = Substs::new_type(tps, regions);\n+    let mut substs = Substs::new_type(types, regions);\n \n     match self_ty {\n         None => {\n@@ -354,15 +355,56 @@ fn ast_path_substs<'tcx,AC,RS>(\n                                          param.def_id))\n     }\n \n-    substs\n+    return substs;\n+\n+    fn angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n+                                                rscope: &RS,\n+                                                data: &ast::AngleBracketedParameterData)\n+                                                -> (Vec<ty::Region>, Vec<ty::t>)\n+        where AC: AstConv<'tcx>, RS: RegionScope\n+    {\n+        let regions: Vec<_> =\n+            data.lifetimes.iter()\n+            .map(|l| ast_region_to_region(this.tcx(), l))\n+            .collect();\n+\n+        let types: Vec<_> =\n+            data.types.iter()\n+            .map(|t| ast_ty_to_ty(this, rscope, &**t))\n+            .collect();\n+\n+        (regions, types)\n+    }\n+\n+    fn parenthesized_parameters<'tcx,AC>(this: &AC,\n+                                         binder_id: ast::NodeId,\n+                                         data: &ast::ParenthesizedParameterData)\n+                                         -> (Vec<ty::Region>, Vec<ty::t>)\n+        where AC: AstConv<'tcx>\n+    {\n+        let binding_rscope = BindingRscope::new(binder_id);\n+\n+        let inputs = data.inputs.iter()\n+                                .map(|a_t| ast_ty_to_ty(this, &binding_rscope, &**a_t))\n+                                .collect();\n+        let input_ty = ty::mk_tup_or_nil(this.tcx(), inputs);\n+\n+        let output = match data.output {\n+            Some(ref output_ty) => ast_ty_to_ty(this, &binding_rscope, &**output_ty),\n+            None => ty::mk_nil()\n+        };\n+\n+        (Vec::new(), vec![input_ty, output])\n+    }\n }\n \n pub fn ast_path_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                          rscope: &RS,\n                                          trait_def_id: ast::DefId,\n                                          self_ty: Option<ty::t>,\n                                          associated_type: Option<ty::t>,\n-                                         path: &ast::Path)\n+                                         path: &ast::Path,\n+                                         binder_id: ast::NodeId)\n                                          -> Rc<ty::TraitRef>\n                                          where AC: AstConv<'tcx>,\n                                                RS: RegionScope {\n@@ -375,16 +417,19 @@ pub fn ast_path_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                 &trait_def.generics,\n                                 self_ty,\n                                 associated_type,\n-                                path)\n+                                path,\n+                                binder_id)\n     })\n }\n \n pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     did: ast::DefId,\n-    path: &ast::Path)\n-    -> TypeAndSubsts {\n+    path: &ast::Path,\n+    binder_id: ast::NodeId)\n+    -> TypeAndSubsts\n+{\n     let tcx = this.tcx();\n     let ty::Polytype {\n         generics,\n@@ -397,7 +442,8 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                  &generics,\n                                  None,\n                                  None,\n-                                 path);\n+                                 path,\n+                                 binder_id);\n     let ty = decl_ty.subst(tcx, &substs);\n     TypeAndSubsts { substs: substs, ty: ty }\n }\n@@ -407,24 +453,29 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n /// and/or region variables are substituted.\n ///\n /// This is used when checking the constructor in struct literals.\n-pub fn ast_path_to_ty_relaxed<'tcx, AC: AstConv<'tcx>,\n-                              RS:RegionScope>(\n-                              this: &AC,\n-                              rscope: &RS,\n-                              did: ast::DefId,\n-                              path: &ast::Path)\n-                              -> TypeAndSubsts {\n+pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n+    this: &AC,\n+    rscope: &RS,\n+    did: ast::DefId,\n+    path: &ast::Path,\n+    binder_id: ast::NodeId)\n+    -> TypeAndSubsts\n+    where AC : AstConv<'tcx>, RS : RegionScope\n+{\n     let tcx = this.tcx();\n     let ty::Polytype {\n         generics,\n         ty: decl_ty\n     } = this.get_item_ty(did);\n \n-    let substs = if (generics.has_type_params(TypeSpace) ||\n-        generics.has_region_params(TypeSpace)) &&\n-            path.segments.iter().all(|s| {\n-                s.lifetimes.len() == 0 && s.types.len() == 0\n-            }) {\n+    let wants_params =\n+        generics.has_type_params(TypeSpace) || generics.has_region_params(TypeSpace);\n+\n+    let needs_defaults =\n+        wants_params &&\n+        path.segments.iter().all(|s| s.parameters.is_empty());\n+\n+    let substs = if needs_defaults {\n         let type_params = Vec::from_fn(generics.types.len(TypeSpace),\n                                        |_| this.ty_infer(path.span));\n         let region_params =\n@@ -433,7 +484,7 @@ pub fn ast_path_to_ty_relaxed<'tcx, AC: AstConv<'tcx>,\n         Substs::new(VecPerParamSpace::params_from_type(type_params),\n                     VecPerParamSpace::params_from_type(region_params))\n     } else {\n-        ast_path_substs(this, rscope, did, &generics, None, None, path)\n+        ast_path_substs(this, rscope, did, &generics, None, None, path, binder_id)\n     };\n \n     let ty = decl_ty.subst(tcx, &substs);\n@@ -450,14 +501,14 @@ fn check_path_args(tcx: &ty::ctxt,\n                    path: &ast::Path,\n                    flags: uint) {\n     if (flags & NO_TPS) != 0u {\n-        if !path.segments.iter().all(|s| s.types.is_empty()) {\n+        if path.segments.iter().any(|s| s.parameters.has_types()) {\n             span_err!(tcx.sess, path.span, E0109,\n                 \"type parameters are not allowed on this type\");\n         }\n     }\n \n     if (flags & NO_REGIONS) != 0u {\n-        if !path.segments.last().unwrap().lifetimes.is_empty() {\n+        if path.segments.iter().any(|s| s.parameters.has_lifetimes()) {\n             span_err!(tcx.sess, path.span, E0110,\n                 \"region parameters are not allowed on this type\");\n         }\n@@ -538,29 +589,23 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             // FIXME(#12938): This is a hack until we have full support for\n             // DST.\n             match a_def {\n-                def::DefTy(did, _) | def::DefStruct(did)\n-                        if Some(did) == this.tcx().lang_items.owned_box() => {\n-                    if path.segments\n-                           .iter()\n-                           .flat_map(|s| s.types.iter())\n-                           .count() > 1 {\n-                        span_err!(this.tcx().sess, path.span, E0047,\n-                                  \"`Box` has only one type parameter\");\n-                    }\n-\n-                    for inner_ast_type in path.segments\n-                                              .iter()\n-                                              .flat_map(|s| s.types.iter()) {\n-                        return Some(mk_pointer(this,\n-                                               rscope,\n-                                               ast::MutImmutable,\n-                                               &**inner_ast_type,\n-                                               Uniq,\n-                                               |typ| ty::mk_uniq(this.tcx(), typ)));\n+                def::DefTy(did, _) |\n+                def::DefStruct(did) if Some(did) == this.tcx().lang_items.owned_box() => {\n+                    let ty = ast_path_to_ty(this, rscope, did, path, id).ty;\n+                    match ty::get(ty).sty {\n+                        ty::ty_struct(struct_def_id, ref substs) => {\n+                            assert_eq!(struct_def_id, did);\n+                            assert_eq!(substs.types.len(TypeSpace), 1);\n+                            let referent_ty = *substs.types.get(TypeSpace, 0);\n+                            Some(ty::mk_uniq(this.tcx(), referent_ty))\n+                        }\n+                        _ => {\n+                            this.tcx().sess.span_bug(\n+                                path.span,\n+                                format!(\"converting `Box` to `{}`\",\n+                                        ty.repr(this.tcx()))[]);\n+                        }\n                     }\n-                    span_err!(this.tcx().sess, path.span, E0113,\n-                              \"not enough type parameters supplied to `Box<T>`\");\n-                    Some(ty::mk_err())\n                 }\n                 _ => None\n             }\n@@ -603,11 +648,7 @@ pub fn trait_ref_for_unboxed_function<'tcx, AC: AstConv<'tcx>,\n                           .map(|input| {\n                             ast_ty_to_ty(this, rscope, &*input.ty)\n                           }).collect::<Vec<_>>();\n-    let input_tuple = if input_types.len() == 0 {\n-        ty::mk_nil()\n-    } else {\n-        ty::mk_tup(this.tcx(), input_types)\n-    };\n+    let input_tuple = ty::mk_tup_or_nil(this.tcx(), input_types);\n     let output_type = ast_ty_to_ty(this, rscope, &*decl.output);\n     let mut substs = Substs::new_type(vec!(input_tuple, output_type),\n                                       Vec::new());\n@@ -693,7 +734,8 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                        trait_def_id,\n                                                        None,\n                                                        None,\n-                                                       path);\n+                                                       path,\n+                                                       id);\n                     let bounds = match *opt_bounds {\n                         None => {\n                             conv_existential_bounds(this,\n@@ -771,7 +813,12 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n                                           trait_did,\n                                           None,\n                                           Some(for_type),\n-                                          trait_path);\n+                                          trait_path,\n+                                          ast::DUMMY_NODE_ID); // *see below\n+\n+    // * The trait in a qualified path cannot be \"higher-ranked\" and\n+    // hence cannot use the parenthetical sugar, so the binder-id is\n+    // irrelevant.\n \n     debug!(\"associated_ty_to_ty(trait_ref={})\",\n            trait_ref.repr(this.tcx()));\n@@ -925,7 +972,8 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                            trait_def_id,\n                                                            None,\n                                                            None,\n-                                                           path);\n+                                                           path,\n+                                                           id);\n                         let empty_bounds: &[ast::TyParamBound] = &[];\n                         let ast_bounds = match *bounds {\n                             Some(ref b) => b.as_slice(),\n@@ -942,7 +990,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                      bounds)\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n-                        ast_path_to_ty(this, rscope, did, path).ty\n+                        ast_path_to_ty(this, rscope, did, path, id).ty\n                     }\n                     def::DefTyParam(space, id, n) => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);"}, {"sha": "322275218e1bae80cc3978f61ced9e129891d229", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 78, "deletions": 12, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -3481,11 +3481,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `unboxed_closures` table.\n-        fn_ty.sig.inputs = if fn_ty.sig.inputs.len() == 0 {\n-            vec![ty::mk_nil()]\n-        } else {\n-            vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.inputs)]\n-        };\n+        fn_ty.sig.inputs = vec![ty::mk_tup_or_nil(fcx.tcx(), fn_ty.sig.inputs)];\n \n         let kind = match kind {\n             ast::FnUnboxedClosureKind => ty::FnUnboxedClosureKind,\n@@ -4478,7 +4474,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             let type_and_substs = astconv::ast_path_to_ty_relaxed(fcx,\n                                                                   fcx.infcx(),\n                                                                   struct_id,\n-                                                                  path);\n+                                                                  path,\n+                                                                  expr.id);\n             match fcx.mk_subty(false,\n                                infer::Misc(path.span),\n                                actual_structure_type,\n@@ -5339,6 +5336,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n             Some(space) => {\n                 push_explicit_parameters_from_segment_to_substs(fcx,\n                                                                 space,\n+                                                                path.span,\n                                                                 type_defs,\n                                                                 region_defs,\n                                                                 segment,\n@@ -5374,13 +5372,13 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         fcx: &FnCtxt,\n         segment: &ast::PathSegment)\n     {\n-        for typ in segment.types.iter() {\n+        for typ in segment.parameters.types().iter() {\n             span_err!(fcx.tcx().sess, typ.span, E0085,\n                 \"type parameters may not appear here\");\n             break;\n         }\n \n-        for lifetime in segment.lifetimes.iter() {\n+        for lifetime in segment.parameters.lifetimes().iter() {\n             span_err!(fcx.tcx().sess, lifetime.span, E0086,\n                 \"lifetime parameters may not appear here\");\n             break;\n@@ -5390,6 +5388,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n     fn push_explicit_parameters_from_segment_to_substs(\n         fcx: &FnCtxt,\n         space: subst::ParamSpace,\n+        span: Span,\n         type_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n         region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n         segment: &ast::PathSegment,\n@@ -5412,10 +5411,31 @@ pub fn instantiate_path(fcx: &FnCtxt,\n          * span of the N+1'th parameter.\n          */\n \n+        match segment.parameters {\n+            ast::AngleBracketedParameters(ref data) => {\n+                push_explicit_angle_bracketed_parameters_from_segment_to_substs(\n+                    fcx, space, type_defs, region_defs, data, substs);\n+            }\n+\n+            ast::ParenthesizedParameters(ref data) => {\n+                push_explicit_parenthesized_parameters_from_segment_to_substs(\n+                    fcx, space, span, type_defs, data, substs);\n+            }\n+        }\n+    }\n+\n+    fn push_explicit_angle_bracketed_parameters_from_segment_to_substs(\n+        fcx: &FnCtxt,\n+        space: subst::ParamSpace,\n+        type_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n+        region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n+        data: &ast::AngleBracketedParameterData,\n+        substs: &mut Substs)\n+    {\n         {\n             let type_count = type_defs.len(space);\n             assert_eq!(substs.types.len(space), 0);\n-            for (i, typ) in segment.types.iter().enumerate() {\n+            for (i, typ) in data.types.iter().enumerate() {\n                 let t = fcx.to_ty(&**typ);\n                 if i < type_count {\n                     substs.types.push(space, t);\n@@ -5424,7 +5444,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n                         \"too many type parameters provided: \\\n                          expected at most {} parameter(s), \\\n                          found {} parameter(s)\",\n-                         type_count, segment.types.len());\n+                         type_count, data.types.len());\n                     substs.types.truncate(space, 0);\n                 }\n             }\n@@ -5433,7 +5453,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         {\n             let region_count = region_defs.len(space);\n             assert_eq!(substs.regions().len(space), 0);\n-            for (i, lifetime) in segment.lifetimes.iter().enumerate() {\n+            for (i, lifetime) in data.lifetimes.iter().enumerate() {\n                 let r = ast_region_to_region(fcx.tcx(), lifetime);\n                 if i < region_count {\n                     substs.mut_regions().push(space, r);\n@@ -5442,13 +5462,59 @@ pub fn instantiate_path(fcx: &FnCtxt,\n                         \"too many lifetime parameters provided: \\\n                          expected {} parameter(s), found {} parameter(s)\",\n                         region_count,\n-                        segment.lifetimes.len());\n+                        data.lifetimes.len());\n                     substs.mut_regions().truncate(space, 0);\n                 }\n             }\n         }\n     }\n \n+    fn push_explicit_parenthesized_parameters_from_segment_to_substs(\n+        fcx: &FnCtxt,\n+        space: subst::ParamSpace,\n+        span: Span,\n+        type_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n+        data: &ast::ParenthesizedParameterData,\n+        substs: &mut Substs)\n+    {\n+        /*!\n+         * As with\n+         * `push_explicit_angle_bracketed_parameters_from_segment_to_substs`,\n+         * but intended for `Foo(A,B) -> C` form. This expands to\n+         * roughly the same thing as `Foo<(A,B),C>`. One important\n+         * difference has to do with the treatment of anonymous\n+         * regions, which are translated into bound regions (NYI).\n+         */\n+\n+        let type_count = type_defs.len(space);\n+        if type_count < 2 {\n+            span_err!(fcx.tcx().sess, span, E0167,\n+                      \"parenthesized form always supplies 2 type parameters, \\\n+                      but only {} parameter(s) were expected\",\n+                      type_count);\n+        }\n+\n+        let input_tys: Vec<ty::t> =\n+            data.inputs.iter().map(|ty| fcx.to_ty(&**ty)).collect();\n+\n+        let tuple_ty =\n+            ty::mk_tup_or_nil(fcx.tcx(), input_tys);\n+\n+        if type_count >= 1 {\n+            substs.types.push(space, tuple_ty);\n+        }\n+\n+        let output_ty: Option<ty::t> =\n+            data.output.as_ref().map(|ty| fcx.to_ty(&**ty));\n+\n+        let output_ty =\n+            output_ty.unwrap_or(ty::mk_nil());\n+\n+        if type_count >= 2 {\n+            substs.types.push(space, output_ty);\n+        }\n+    }\n+\n     fn adjust_type_parameters(\n         fcx: &FnCtxt,\n         span: Span,"}, {"sha": "7a26cc51114540b538152f7114992014aa1e08f0", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -1340,7 +1340,8 @@ pub fn instantiate_trait_ref<'tcx,AC>(this: &AC,\n                                                trait_did,\n                                                Some(self_ty),\n                                                associated_type,\n-                                               &ast_trait_ref.path);\n+                                               &ast_trait_ref.path,\n+                                               ast_trait_ref.ref_id);\n \n             this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n                                                       trait_ref.clone());"}, {"sha": "64efae486b7e9733fc6a67f02759ad9e941b7240", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 42, "deletions": 29, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -1108,15 +1108,16 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 &ast::TraitTyParamBound(ref tr) => {\n                     let last_seg = tr.path.segments.last().unwrap();\n                     let mut insert = Vec::new();\n-                    for (i, lt) in last_seg.lifetimes.iter().enumerate() {\n+                    let lifetimes = last_seg.parameters.lifetimes();\n+                    for (i, lt) in lifetimes.iter().enumerate() {\n                         if region_names.contains(&lt.name) {\n                             insert.push(i);\n                         }\n                     }\n                     let rebuild_info = RebuildPathInfo {\n                         path: &tr.path,\n                         indexes: insert,\n-                        expected: last_seg.lifetimes.len(),\n+                        expected: lifetimes.len(),\n                         anon_nums: &HashSet::new(),\n                         region_names: region_names\n                     };\n@@ -1257,7 +1258,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                             let expected =\n                                 generics.regions.len(subst::TypeSpace);\n                             let lifetimes =\n-                                &path.segments.last().unwrap().lifetimes;\n+                                path.segments.last().unwrap().parameters.lifetimes();\n                             let mut insert = Vec::new();\n                             if lifetimes.len() == 0 {\n                                 let anon = self.cur_anon.get();\n@@ -1357,7 +1358,8 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     fn rebuild_path(&self,\n                     rebuild_info: RebuildPathInfo,\n                     lifetime: ast::Lifetime)\n-                    -> ast::Path {\n+                    -> ast::Path\n+    {\n         let RebuildPathInfo {\n             path,\n             indexes,\n@@ -1367,37 +1369,48 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         } = rebuild_info;\n \n         let last_seg = path.segments.last().unwrap();\n-        let mut new_lts = Vec::new();\n-        if last_seg.lifetimes.len() == 0 {\n-            // traverse once to see if there's a need to insert lifetime\n-            let need_insert = range(0, expected).any(|i| {\n-                indexes.contains(&i)\n-            });\n-            if need_insert {\n-                for i in range(0, expected) {\n-                    if indexes.contains(&i) {\n-                        new_lts.push(lifetime);\n-                    } else {\n-                        new_lts.push(self.life_giver.give_lifetime());\n+        let new_parameters = match last_seg.parameters {\n+            ast::ParenthesizedParameters(..) => {\n+                last_seg.parameters.clone()\n+            }\n+\n+            ast::AngleBracketedParameters(ref data) => {\n+                let mut new_lts = Vec::new();\n+                if data.lifetimes.len() == 0 {\n+                    // traverse once to see if there's a need to insert lifetime\n+                    let need_insert = range(0, expected).any(|i| {\n+                        indexes.contains(&i)\n+                    });\n+                    if need_insert {\n+                        for i in range(0, expected) {\n+                            if indexes.contains(&i) {\n+                                new_lts.push(lifetime);\n+                            } else {\n+                                new_lts.push(self.life_giver.give_lifetime());\n+                            }\n+                        }\n                     }\n-                }\n-            }\n-        } else {\n-            for (i, lt) in last_seg.lifetimes.iter().enumerate() {\n-                if indexes.contains(&i) {\n-                    new_lts.push(lifetime);\n                 } else {\n-                    new_lts.push(*lt);\n+                    for (i, lt) in data.lifetimes.iter().enumerate() {\n+                        if indexes.contains(&i) {\n+                            new_lts.push(lifetime);\n+                        } else {\n+                            new_lts.push(*lt);\n+                        }\n+                    }\n                 }\n+                let new_types = data.types.map(|t| {\n+                    self.rebuild_arg_ty_or_output(&**t, lifetime, anon_nums, region_names)\n+                });\n+                ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                    lifetimes: new_lts,\n+                    types: new_types\n+                })\n             }\n-        }\n-        let new_types = last_seg.types.map(|t| {\n-            self.rebuild_arg_ty_or_output(&**t, lifetime, anon_nums, region_names)\n-        });\n+        };\n         let new_seg = ast::PathSegment {\n             identifier: last_seg.identifier,\n-            lifetimes: new_lts,\n-            types: new_types,\n+            parameters: new_parameters\n         };\n         let mut new_segs = Vec::new();\n         new_segs.push_all(path.segments.init());"}, {"sha": "cfd183b4c453b4a1c2354e752d200e3fbb29ba57", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -1641,10 +1641,23 @@ pub struct PathSegment {\n \n impl Clean<PathSegment> for ast::PathSegment {\n     fn clean(&self, cx: &DocContext) -> PathSegment {\n+        let (lifetimes, types) = match self.parameters {\n+            ast::AngleBracketedParameters(ref data) => {\n+                (data.lifetimes.clean(cx), data.types.clean(cx))\n+            }\n+\n+            ast::ParenthesizedParameters(ref data) => {\n+                // FIXME -- rustdoc should be taught about Foo() notation\n+                let inputs = Tuple(data.inputs.clean(cx));\n+                let output = data.output.as_ref().map(|t| t.clean(cx)).unwrap_or(Tuple(Vec::new()));\n+                (Vec::new(), vec![inputs, output])\n+            }\n+        };\n+\n         PathSegment {\n             name: self.identifier.clean(cx),\n-            lifetimes: self.lifetimes.clean(cx),\n-            types: self.types.clean(cx),\n+            lifetimes: lifetimes,\n+            types: types,\n         }\n     }\n }"}, {"sha": "a2089a3e2a35c2d0fd0227e14e77c00f27eec3e8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 96, "deletions": 1, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -171,7 +171,7 @@ pub struct Path {\n     /// module (like paths in an import).\n     pub global: bool,\n     /// The segments in the path: the things separated by `::`.\n-    pub segments: Vec<PathSegment> ,\n+    pub segments: Vec<PathSegment>,\n }\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n@@ -180,12 +180,107 @@ pub struct Path {\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub identifier: Ident,\n+\n+    /// Type/lifetime parameters attached to this path. They come in\n+    /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`. Note that\n+    /// this is more than just simple syntactic sugar; the use of\n+    /// parens affects the region binding rules, so we preserve the\n+    /// distinction.\n+    pub parameters: PathParameters,\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub enum PathParameters {\n+    AngleBracketedParameters(AngleBracketedParameterData),\n+    ParenthesizedParameters(ParenthesizedParameterData),\n+}\n+\n+impl PathParameters {\n+    pub fn none() -> PathParameters {\n+        AngleBracketedParameters(AngleBracketedParameterData {\n+            lifetimes: Vec::new(),\n+            types: OwnedSlice::empty(),\n+        })\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        match *self {\n+            AngleBracketedParameters(ref data) => data.is_empty(),\n+\n+            // Even if the user supplied no types, something like\n+            // `X()` is equivalent to `X<(),()>`.\n+            ParenthesizedParameters(..) => false,\n+        }\n+    }\n+\n+    pub fn has_lifetimes(&self) -> bool {\n+        match *self {\n+            AngleBracketedParameters(ref data) => !data.lifetimes.is_empty(),\n+            ParenthesizedParameters(_) => false,\n+        }\n+    }\n+\n+    pub fn has_types(&self) -> bool {\n+        match *self {\n+            AngleBracketedParameters(ref data) => !data.types.is_empty(),\n+            ParenthesizedParameters(..) => true,\n+        }\n+    }\n+\n+    pub fn types(&self) -> Vec<&P<Ty>> {\n+        /*!\n+         * Returns the types that the user wrote. Note that these do not\n+         * necessarily map to the type parameters in the parenthesized case.\n+         */\n+        match *self {\n+            AngleBracketedParameters(ref data) => {\n+                data.types.iter().collect()\n+            }\n+            ParenthesizedParameters(ref data) => {\n+                data.inputs.iter()\n+                    .chain(data.output.iter())\n+                    .collect()\n+            }\n+        }\n+    }\n+\n+    pub fn lifetimes(&self) -> Vec<&Lifetime> {\n+        match *self {\n+            AngleBracketedParameters(ref data) => {\n+                data.lifetimes.iter().collect()\n+            }\n+            ParenthesizedParameters(_) => {\n+                Vec::new()\n+            }\n+        }\n+    }\n+}\n+\n+/// A path like `Foo<'a, T>`\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct AngleBracketedParameterData {\n     /// The lifetime parameters for this path segment.\n     pub lifetimes: Vec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n     pub types: OwnedSlice<P<Ty>>,\n }\n \n+impl AngleBracketedParameterData {\n+    fn is_empty(&self) -> bool {\n+        self.lifetimes.is_empty() && self.types.is_empty()\n+    }\n+}\n+\n+/// A path like `Foo(A,B) -> C`\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct ParenthesizedParameterData {\n+    /// `(A,B)`\n+    pub inputs: Vec<P<Ty>>,\n+\n+    /// `C`\n+    pub output: Option<P<Ty>>,\n+}\n+\n pub type CrateNum = u32;\n \n pub type NodeId = u32;"}, {"sha": "2e3a15bfd4b4b1826a8cdb654718d04faf380779", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -171,8 +171,10 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n         segments: vec!(\n             ast::PathSegment {\n                 identifier: identifier,\n-                lifetimes: Vec::new(),\n-                types: OwnedSlice::empty(),\n+                parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                    lifetimes: Vec::new(),\n+                    types: OwnedSlice::empty(),\n+                })\n             }\n         ),\n     }\n@@ -681,11 +683,11 @@ pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> boo\n         false\n     } else {\n         for (idx,seg) in a.iter().enumerate() {\n-            if (seg.identifier.name != b[idx].identifier.name)\n+            if seg.identifier.name != b[idx].identifier.name\n                 // FIXME #7743: ident -> name problems in lifetime comparison?\n-                || (seg.lifetimes != b[idx].lifetimes)\n                 // can types contain idents?\n-                || (seg.types != b[idx].types) {\n+                || seg.parameters != b[idx].parameters\n+            {\n                 return false;\n             }\n         }\n@@ -747,12 +749,10 @@ impl PostExpansionMethod for Method {\n mod test {\n     use ast::*;\n     use super::*;\n-    use owned_slice::OwnedSlice;\n \n     fn ident_to_segment(id : &Ident) -> PathSegment {\n-        PathSegment {identifier:id.clone(),\n-                     lifetimes: Vec::new(),\n-                     types: OwnedSlice::empty()}\n+        PathSegment {identifier: id.clone(),\n+                     parameters: PathParameters::none()}\n     }\n \n     #[test] fn idents_name_eq_test() {"}, {"sha": "5921d630b8979c6a44e9f850c6b1bbb2878aa3ce", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -313,14 +313,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                                                       .map(|ident| {\n             ast::PathSegment {\n                 identifier: ident,\n-                lifetimes: Vec::new(),\n-                types: OwnedSlice::empty(),\n+                parameters: ast::PathParameters::none(),\n             }\n         }).collect();\n         segments.push(ast::PathSegment {\n             identifier: last_identifier,\n-            lifetimes: lifetimes,\n-            types: OwnedSlice::from_vec(types),\n+            parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                lifetimes: lifetimes,\n+                types: OwnedSlice::from_vec(types),\n+            })\n         });\n         ast::Path {\n             span: sp,"}, {"sha": "aa18b1be31acc46e9b6615e509e43704efbaa9fd", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -12,7 +12,6 @@ use ast;\n use codemap::Span;\n use ext::base::*;\n use ext::base;\n-use owned_slice::OwnedSlice;\n use parse::token;\n use parse::token::{str_to_ident};\n use ptr::P;\n@@ -52,8 +51,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n                  segments: vec!(\n                     ast::PathSegment {\n                         identifier: res,\n-                        lifetimes: Vec::new(),\n-                        types: OwnedSlice::empty(),\n+                        parameters: ast::PathParameters::none(),\n                     }\n                 )\n             }"}, {"sha": "79e2c656e41f4a8796a63a03275df25a366c2eb8", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -166,6 +166,22 @@ pub trait Folder {\n         noop_fold_path(p, self)\n     }\n \n+    fn fold_path_parameters(&mut self, p: PathParameters) -> PathParameters {\n+        noop_fold_path_parameters(p, self)\n+    }\n+\n+    fn fold_angle_bracketed_parameter_data(&mut self, p: AngleBracketedParameterData)\n+                                           -> AngleBracketedParameterData\n+    {\n+        noop_fold_angle_bracketed_parameter_data(p, self)\n+    }\n+\n+    fn fold_parenthesized_parameter_data(&mut self, p: ParenthesizedParameterData)\n+                                         -> ParenthesizedParameterData\n+    {\n+        noop_fold_parenthesized_parameter_data(p, self)\n+    }\n+\n     fn fold_local(&mut self, l: P<Local>) -> P<Local> {\n         noop_fold_local(l, self)\n     }\n@@ -480,15 +496,43 @@ pub fn noop_fold_uint<T: Folder>(i: uint, _: &mut T) -> uint {\n pub fn noop_fold_path<T: Folder>(Path {global, segments, span}: Path, fld: &mut T) -> Path {\n     Path {\n         global: global,\n-        segments: segments.move_map(|PathSegment {identifier, lifetimes, types}| PathSegment {\n+        segments: segments.move_map(|PathSegment {identifier, parameters}| PathSegment {\n             identifier: fld.fold_ident(identifier),\n-            lifetimes: fld.fold_lifetimes(lifetimes),\n-            types: types.move_map(|typ| fld.fold_ty(typ)),\n+            parameters: fld.fold_path_parameters(parameters),\n         }),\n         span: fld.new_span(span)\n     }\n }\n \n+pub fn noop_fold_path_parameters<T: Folder>(path_parameters: PathParameters, fld: &mut T)\n+                                            -> PathParameters\n+{\n+    match path_parameters {\n+        AngleBracketedParameters(data) =>\n+            AngleBracketedParameters(fld.fold_angle_bracketed_parameter_data(data)),\n+        ParenthesizedParameters(data) =>\n+            ParenthesizedParameters(fld.fold_parenthesized_parameter_data(data)),\n+    }\n+}\n+\n+pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedParameterData,\n+                                                           fld: &mut T)\n+                                                           -> AngleBracketedParameterData\n+{\n+    let AngleBracketedParameterData { lifetimes, types } = data;\n+    AngleBracketedParameterData { lifetimes: fld.fold_lifetimes(lifetimes),\n+                                  types: types.move_map(|ty| fld.fold_ty(ty)) }\n+}\n+\n+pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedParameterData,\n+                                                         fld: &mut T)\n+                                                         -> ParenthesizedParameterData\n+{\n+    let ParenthesizedParameterData { inputs, output } = data;\n+    ParenthesizedParameterData { inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n+                                 output: output.map(|ty| fld.fold_ty(ty)) }\n+}\n+\n pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n     l.map(|Local {id, pat, ty, init, source, span}| Local {\n         id: fld.new_id(id),"}, {"sha": "996708b217426d186a5d7b44f39ca3c3850a9252", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -749,8 +749,7 @@ mod test {\n                         segments: vec!(\n                             ast::PathSegment {\n                                 identifier: str_to_ident(\"a\"),\n-                                lifetimes: Vec::new(),\n-                                types: OwnedSlice::empty(),\n+                                parameters: ast::PathParameters::none(),\n                             }\n                         ),\n                     }),\n@@ -768,13 +767,11 @@ mod test {\n                             segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"a\"),\n-                                    lifetimes: Vec::new(),\n-                                    types: OwnedSlice::empty(),\n+                                    parameters: ast::PathParameters::none(),\n                                 },\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n-                                    lifetimes: Vec::new(),\n-                                    types: OwnedSlice::empty(),\n+                                    parameters: ast::PathParameters::none(),\n                                 }\n                             )\n                         }),\n@@ -952,8 +949,7 @@ mod test {\n                             segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"d\"),\n-                                    lifetimes: Vec::new(),\n-                                    types: OwnedSlice::empty(),\n+                                    parameters: ast::PathParameters::none(),\n                                 }\n                             ),\n                         }),\n@@ -974,8 +970,7 @@ mod test {\n                                segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n-                                    lifetimes: Vec::new(),\n-                                    types: OwnedSlice::empty(),\n+                                    parameters: ast::PathParameters::none(),\n                                 }\n                                ),\n                             }),\n@@ -1022,8 +1017,7 @@ mod test {\n                                             ast::PathSegment {\n                                                 identifier:\n                                                     str_to_ident(\"int\"),\n-                                                lifetimes: Vec::new(),\n-                                                types: OwnedSlice::empty(),\n+                                                parameters: ast::PathParameters::none(),\n                                             }\n                                         ),\n                                         }, None, ast::DUMMY_NODE_ID),\n@@ -1072,10 +1066,8 @@ mod test {\n                                                                 identifier:\n                                                                 str_to_ident(\n                                                                     \"b\"),\n-                                                                lifetimes:\n-                                                                Vec::new(),\n-                                                                types:\n-                                                                OwnedSlice::empty()\n+                                                                parameters:\n+                                                                ast::PathParameters::none(),\n                                                             }\n                                                         ),\n                                                       }),"}, {"sha": "1c65a47350ea827cb20dd6b15321f848a12628a5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 54, "deletions": 44, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -1487,9 +1487,9 @@ impl<'a> Parser<'a> {\n                 trait_name: trait_name.path,\n                 item_name: item_name,\n             }))\n-        } else if self.token == token::ModSep\n-            || self.token.is_ident()\n-            || self.token.is_path() {\n+        } else if self.token == token::ModSep ||\n+                  self.token.is_ident() ||\n+                  self.token.is_path() {\n             // NAMED TYPE\n             let mode = if plus_allowed {\n                 LifetimeAndTypesAndBounds\n@@ -1771,27 +1771,36 @@ impl<'a> Parser<'a> {\n             let identifier = self.parse_ident();\n \n             // Parse types, optionally.\n-            let (lifetimes, types) = if self.eat_lt(false) {\n-                self.parse_generic_values_after_lt()\n-            } else if false && self.eat(&token::LParen) {\n-                let mut types = self.parse_seq_to_end(\n-                    &token::RParen,\n+            let parameters = if self.eat_lt(false) {\n+                let (lifetimes, types) = self.parse_generic_values_after_lt();\n+\n+                ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                    lifetimes: lifetimes,\n+                    types: OwnedSlice::from_vec(types),\n+                })\n+            } else if self.eat(&token::OpenDelim(token::Paren)) {\n+                let inputs = self.parse_seq_to_end(\n+                    &token::CloseDelim(token::Paren),\n                     seq_sep_trailing_allowed(token::Comma),\n                     |p| p.parse_ty(true));\n \n-                if self.eat(&token::RArrow) {\n-                    types.push(self.parse_ty(true))\n-                }\n+                let output_ty = if self.eat(&token::RArrow) {\n+                    Some(self.parse_ty(true))\n+                } else {\n+                    None\n+                };\n \n-                (Vec::new(), types)\n+                ast::ParenthesizedParameters(ast::ParenthesizedParameterData {\n+                    inputs: inputs,\n+                    output: output_ty\n+                })\n             } else {\n-                (Vec::new(), Vec::new())\n+                ast::PathParameters::none()\n             };\n \n             // Assemble and push the result.\n             segments.push(ast::PathSegment { identifier: identifier,\n-                                             lifetimes: lifetimes,\n-                                             types: OwnedSlice::from_vec(types), });\n+                                             parameters: parameters });\n \n             // Continue only if we see a `::`\n             if !self.eat(&token::ModSep) {\n@@ -1810,29 +1819,38 @@ impl<'a> Parser<'a> {\n \n             // If we do not see a `::`, stop.\n             if !self.eat(&token::ModSep) {\n-                segments.push(ast::PathSegment { identifier: identifier,\n-                                                 lifetimes: Vec::new(),\n-                                                 types: OwnedSlice::empty() });\n+                segments.push(ast::PathSegment {\n+                    identifier: identifier,\n+                    parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                        lifetimes: Vec::new(),\n+                        types: OwnedSlice::empty(),\n+                    })\n+                });\n                 return segments;\n             }\n \n             // Check for a type segment.\n             if self.eat_lt(false) {\n                 // Consumed `a::b::<`, go look for types\n                 let (lifetimes, types) = self.parse_generic_values_after_lt();\n-                segments.push(ast::PathSegment { identifier: identifier,\n-                                                 lifetimes: lifetimes,\n-                                                 types: OwnedSlice::from_vec(types) });\n+                segments.push(ast::PathSegment {\n+                    identifier: identifier,\n+                    parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                        lifetimes: lifetimes,\n+                        types: OwnedSlice::from_vec(types),\n+                    }),\n+                });\n \n                 // Consumed `a::b::<T,U>`, check for `::` before proceeding\n                 if !self.eat(&token::ModSep) {\n                     return segments;\n                 }\n             } else {\n                 // Consumed `a::`, go look for `b`\n-                segments.push(ast::PathSegment { identifier: identifier,\n-                                                 lifetimes: Vec::new(),\n-                                                 types: OwnedSlice::empty() });\n+                segments.push(ast::PathSegment {\n+                    identifier: identifier,\n+                    parameters: ast::PathParameters::none(),\n+                });\n             }\n         }\n     }\n@@ -1847,9 +1865,10 @@ impl<'a> Parser<'a> {\n             let identifier = self.parse_ident();\n \n             // Assemble and push the result.\n-            segments.push(ast::PathSegment { identifier: identifier,\n-                                             lifetimes: Vec::new(),\n-                                             types: OwnedSlice::empty(), });\n+            segments.push(ast::PathSegment {\n+                identifier: identifier,\n+                parameters: ast::PathParameters::none()\n+            });\n \n             // If we do not see a `::`, stop.\n             if !self.eat(&token::ModSep) {\n@@ -3455,13 +3474,9 @@ impl<'a> Parser<'a> {\n                           },\n                           _ => {\n                               if !enum_path.global &&\n-                                    enum_path.segments.len() == 1 &&\n-                                    enum_path.segments[0]\n-                                             .lifetimes\n-                                             .len() == 0 &&\n-                                    enum_path.segments[0]\n-                                             .types\n-                                             .len() == 0 {\n+                                  enum_path.segments.len() == 1 &&\n+                                  enum_path.segments[0].parameters.is_empty()\n+                              {\n                                   // it could still be either an enum\n                                   // or an identifier pattern, resolve\n                                   // will sort it out:\n@@ -3960,8 +3975,7 @@ impl<'a> Parser<'a> {\n     fn trait_ref_from_ident(ident: Ident, span: Span) -> ast::TraitRef {\n         let segment = ast::PathSegment {\n             identifier: ident,\n-            lifetimes: Vec::new(),\n-            types: OwnedSlice::empty(),\n+            parameters: ast::PathParameters::none()\n         };\n         let path = ast::Path {\n             span: span,\n@@ -5677,8 +5691,7 @@ impl<'a> Parser<'a> {\n                 segments: path.into_iter().map(|identifier| {\n                     ast::PathSegment {\n                         identifier: identifier,\n-                        lifetimes: Vec::new(),\n-                        types: OwnedSlice::empty(),\n+                        parameters: ast::PathParameters::none(),\n                     }\n                 }).collect()\n             };\n@@ -5712,8 +5725,7 @@ impl<'a> Parser<'a> {\n                         segments: path.into_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n-                                lifetimes: Vec::new(),\n-                                types: OwnedSlice::empty(),\n+                                parameters: ast::PathParameters::none(),\n                             }\n                         }).collect()\n                     };\n@@ -5730,8 +5742,7 @@ impl<'a> Parser<'a> {\n                         segments: path.into_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n-                                lifetimes: Vec::new(),\n-                                types: OwnedSlice::empty(),\n+                                parameters: ast::PathParameters::none(),\n                             }\n                         }).collect()\n                     };\n@@ -5752,8 +5763,7 @@ impl<'a> Parser<'a> {\n             segments: path.into_iter().map(|identifier| {\n                 ast::PathSegment {\n                     identifier: identifier,\n-                    lifetimes: Vec::new(),\n-                    types: OwnedSlice::empty(),\n+                    parameters: ast::PathParameters::none(),\n                 }\n             }).collect()\n         };"}, {"sha": "d83ea5f76b1fc0f48246aec351bdebb2b736daa5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -1995,39 +1995,73 @@ impl<'a> State<'a> {\n \n             try!(self.print_ident(segment.identifier));\n \n-            if !segment.lifetimes.is_empty() || !segment.types.is_empty() {\n-                if colons_before_params {\n-                    try!(word(&mut self.s, \"::\"))\n-                }\n+            try!(self.print_path_parameters(&segment.parameters, colons_before_params));\n+        }\n+\n+        match *opt_bounds {\n+            None => Ok(()),\n+            Some(ref bounds) => self.print_bounds(\"+\", bounds)\n+        }\n+    }\n+\n+    fn print_path_parameters(&mut self,\n+                             parameters: &ast::PathParameters,\n+                             colons_before_params: bool)\n+                             -> IoResult<()>\n+    {\n+        if parameters.is_empty() {\n+            return Ok(());\n+        }\n+\n+        if colons_before_params {\n+            try!(word(&mut self.s, \"::\"))\n+        }\n+\n+        match *parameters {\n+            ast::AngleBracketedParameters(ref data) => {\n                 try!(word(&mut self.s, \"<\"));\n \n                 let mut comma = false;\n-                for lifetime in segment.lifetimes.iter() {\n+                for lifetime in data.lifetimes.iter() {\n                     if comma {\n                         try!(self.word_space(\",\"))\n                     }\n                     try!(self.print_lifetime(lifetime));\n                     comma = true;\n                 }\n \n-                if !segment.types.is_empty() {\n+                if !data.types.is_empty() {\n                     if comma {\n                         try!(self.word_space(\",\"))\n                     }\n                     try!(self.commasep(\n                         Inconsistent,\n-                        segment.types.as_slice(),\n+                        data.types.as_slice(),\n                         |s, ty| s.print_type(&**ty)));\n                 }\n \n                 try!(word(&mut self.s, \">\"))\n             }\n-        }\n \n-        match *opt_bounds {\n-            None => Ok(()),\n-            Some(ref bounds) => self.print_bounds(\"+\", bounds)\n+            ast::ParenthesizedParameters(ref data) => {\n+                try!(word(&mut self.s, \"(\"));\n+                try!(self.commasep(\n+                    Inconsistent,\n+                    data.inputs.as_slice(),\n+                    |s, ty| s.print_type(&**ty)));\n+                try!(word(&mut self.s, \")\"));\n+\n+                match data.output {\n+                    None => { }\n+                    Some(ref ty) => {\n+                        try!(self.word_space(\"->\"));\n+                        try!(self.print_type(&**ty));\n+                    }\n+                }\n+            }\n         }\n+\n+        Ok(())\n     }\n \n     fn print_path(&mut self, path: &ast::Path,"}, {"sha": "6a4ab365a50b2930c9870ada96f8d23c2cfe72b3", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -14,7 +14,6 @@ use codemap::DUMMY_SP;\n use codemap;\n use fold::Folder;\n use fold;\n-use owned_slice::OwnedSlice;\n use parse::token::InternedString;\n use parse::token::special_idents;\n use parse::token;\n@@ -181,13 +180,11 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n             segments: vec!(\n                 ast::PathSegment {\n                     identifier: token::str_to_ident(\"std\"),\n-                    lifetimes: Vec::new(),\n-                    types: OwnedSlice::empty(),\n+                    parameters: ast::PathParameters::none(),\n                 },\n                 ast::PathSegment {\n                     identifier: token::str_to_ident(\"prelude\"),\n-                    lifetimes: Vec::new(),\n-                    types: OwnedSlice::empty(),\n+                    parameters: ast::PathParameters::none(),\n                 }),\n         };\n "}, {"sha": "a7db8e800a9d0e54503d2b86bc7fca21cc2b1af1", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -453,8 +453,7 @@ fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n         global: false,\n         segments: ids.into_iter().map(|identifier| ast::PathSegment {\n             identifier: identifier,\n-            lifetimes: Vec::new(),\n-            types: OwnedSlice::empty(),\n+            parameters: ast::PathParameters::none(),\n         }).collect()\n     }\n }"}, {"sha": "b4141af07336a3d912ec6f5e39136200858c2835", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -407,11 +407,23 @@ pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n     for segment in path.segments.iter() {\n         visitor.visit_ident(path.span, segment.identifier);\n \n-        for typ in segment.types.iter() {\n-            visitor.visit_ty(&**typ);\n-        }\n-        for lifetime in segment.lifetimes.iter() {\n-            visitor.visit_lifetime_ref(lifetime);\n+        match segment.parameters {\n+            ast::AngleBracketedParameters(ref data) => {\n+                for typ in data.types.iter() {\n+                    visitor.visit_ty(&**typ);\n+                }\n+                for lifetime in data.lifetimes.iter() {\n+                    visitor.visit_lifetime_ref(lifetime);\n+                }\n+            }\n+            ast::ParenthesizedParameters(ref data) => {\n+                for typ in data.inputs.iter() {\n+                    visitor.visit_ty(&**typ);\n+                }\n+                for typ in data.output.iter() {\n+                    visitor.visit_ty(&**typ);\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "0ab37a888267f44eed1c158dc69f0ff1d3a3d038", "filename": "src/test/compile-fail/issue-14092.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Fissue-14092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Fissue-14092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14092.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn fn1(0: Box) {} //~ ERROR: not enough type parameters supplied to `Box<T>`\n+fn fn1(0: Box) {} //~ ERROR: wrong number of type arguments: expected 1, found 0\n \n fn main() {}\n "}, {"sha": "63b110b5579344901453bcbbbc00bf6b1e182c8d", "filename": "src/test/compile-fail/issue-18423.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Fissue-18423.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Fissue-18423.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18423.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that `Box` cannot be used with a lifetime parameter.\n+\n+struct Foo<'a> {\n+    x: Box<'a, int> //~ ERROR wrong number of lifetime parameters\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "9866a20004527f0520063f680bab36af044057f7", "filename": "src/test/compile-fail/unboxed-closure-sugar-default.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test interaction between unboxed closure sugar and default type\n+// parameters (should be exactly as if angle brackets were used).\n+\n+#![feature(default_type_params)]\n+#![allow(dead_code)]\n+\n+struct Foo<T,U,V=T> {\n+    t: T, u: U\n+}\n+\n+trait Eq<X> { }\n+impl<X> Eq<X> for X { }\n+fn eq<A,B:Eq<A>>() { }\n+\n+fn test<'a,'b>() {\n+    // Parens are equivalent to omitting default in angle.\n+    eq::< Foo<(int,),()>,               Foo(int)                      >();\n+\n+    // In angle version, we supply something other than the default\n+    eq::< Foo<(int,),(),int>,           Foo(int)                      >();\n+    //~^ ERROR not implemented\n+\n+    // Supply default explicitly.\n+    eq::< Foo<(int,),(),(int,)>,        Foo(int)                      >();\n+}\n+\n+fn main() { }"}, {"sha": "c38010c1ee260a9bb5fcd610bf63d1dd2edc89b9", "filename": "src/test/compile-fail/unboxed-closure-sugar-equiv.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the unboxed closure sugar can be used with an arbitrary\n+// struct type and that it is equivalent to the same syntax using\n+// angle brackets. This test covers only simple types and in\n+// particular doesn't test bound regions.\n+\n+#![allow(dead_code)]\n+\n+struct Foo<T,U> {\n+    t: T, u: U\n+}\n+\n+trait Eq<X> { }\n+impl<X> Eq<X> for X { }\n+fn eq<A,B:Eq<A>>() { }\n+\n+fn test<'a,'b>() {\n+    // No errors expected:\n+    eq::< Foo<(),()>,                   Foo()                         >();\n+    eq::< Foo<(int,),()>,               Foo(int)                      >();\n+    eq::< Foo<(int,uint),()>,           Foo(int,uint)                 >();\n+    eq::< Foo<(int,uint),uint>,         Foo(int,uint) -> uint         >();\n+    eq::< Foo<(&'a int,&'b uint),uint>, Foo(&'a int,&'b uint) -> uint >();\n+\n+    // Errors expected:\n+    eq::< Foo<(),()>,                   Foo(char)                     >();\n+    //~^ ERROR not implemented\n+}\n+\n+fn main() { }"}, {"sha": "d89c3802508c593c653330580acb96d7635ee745", "filename": "src/test/compile-fail/unboxed-closure-sugar-nonexistent-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f<F:Nonexist(int) -> int>(x: F) {} //~ ERROR unresolved trait\n+fn f<F:Nonexist(int) -> int>(x: F) {} //~ ERROR nonexistent trait `Nonexist`\n \n type Typedef = int;\n "}, {"sha": "962e233dea696651ee56bb33753ffc3d02db6423", "filename": "src/test/compile-fail/unboxed-closure-sugar-region.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test interaction between unboxed closure sugar and region\n+// parameters (should be exactly as if angle brackets were used\n+// and regions omitted).\n+\n+#![feature(default_type_params)]\n+#![allow(dead_code)]\n+\n+use std::kinds::marker;\n+\n+struct Foo<'a,T,U> {\n+    t: T,\n+    u: U,\n+    m: marker::InvariantLifetime<'a>\n+}\n+\n+trait Eq<X> { }\n+impl<X> Eq<X> for X { }\n+fn eq<A,B:Eq<A>>() { }\n+fn same_type<A,B:Eq<A>>(a: A, b: B) { }\n+\n+fn test<'a,'b>() {\n+    // Parens are equivalent to omitting default in angle.\n+    eq::< Foo<(int,),()>,               Foo(int)                      >();\n+\n+    // Here we specify 'static explicitly in angle-bracket version.\n+    // Parenthesized winds up getting inferred.\n+    eq::< Foo<'static, (int,),()>,               Foo(int)                      >();\n+}\n+\n+fn test2(x: Foo<(int,),()>, y: Foo(int)) {\n+    // Here, the omitted lifetimes are expanded to distinct things.\n+    same_type(x, y) //~ ERROR cannot infer\n+}\n+\n+fn main() { }"}, {"sha": "e122b87b1e0f04c9b4094d6a764ecb7434b1a9ca", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct One<A>;\n+\n+fn foo(_: One()) //~ ERROR wrong number of type arguments\n+{}\n+\n+fn main() { }"}, {"sha": "7a66abb39df58e1e01da72422c651e1ba6c86291", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Three<A,B,C>;\n+\n+fn foo(_: Three()) //~ ERROR wrong number of type arguments\n+{}\n+\n+fn main() { }"}, {"sha": "e265a3d56b871cc56af5f340fbe1b9c7b10d8b62", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Zero;\n+\n+fn foo(_: Zero()) //~ ERROR wrong number of type arguments\n+{}\n+\n+fn main() { }"}, {"sha": "1394f8fa65fccb9cd0d07f08b4a0de2dd824d89b", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -11,7 +11,7 @@\n trait Trait {}\n \n fn f<F:Trait(int) -> int>(x: F) {}\n-//~^ ERROR unboxed function trait must be one of `Fn`, `FnMut`, or `FnOnce`\n+//~^ ERROR wrong number of type arguments: expected 0, found 2\n \n fn main() {}\n "}, {"sha": "f9d2ba02123c464775abab2ca5f52acd0a3b96fa", "filename": "src/test/run-pass/unboxed-closures-prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -13,7 +13,7 @@\n #![feature(unboxed_closures, unboxed_closure_sugar)]\n \n fn main() {\n-    let task: Box<|: int| -> int> = box |: x| x;\n+    let task: Box<FnOnce(int) -> int> = box |: x| x;\n     task.call_once((0i, ));\n }\n "}, {"sha": "b358e7ce288339f26a6a727dadeb85ac4666d1ad", "filename": "src/test/run-pass/unboxed-closures-sugar-1.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-1.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the unboxed closure sugar can be used with an arbitrary\n+// struct type and that it is equivalent to the same syntax using\n+// angle brackets. This test covers only simple types and in\n+// particular doesn't test bound regions.\n+\n+#![allow(dead_code)]\n+\n+struct Foo<T,U> {\n+    t: T, u: U\n+}\n+\n+trait Eq<X> { }\n+impl<X> Eq<X> for X { }\n+fn eq<A,B:Eq<A>>() { }\n+\n+fn test<'a,'b>() {\n+    eq::< Foo<(),()>,                   Foo()                         >();\n+    eq::< Foo<(int,),()>,               Foo(int)                      >();\n+    eq::< Foo<(int,uint),()>,           Foo(int,uint)                 >();\n+    eq::< Foo<(int,uint),uint>,         Foo(int,uint) -> uint         >();\n+    eq::< Foo<(&'a int,&'b uint),uint>, Foo(&'a int,&'b uint) -> uint >();\n+}\n+\n+fn main() { }"}, {"sha": "3b38f72432f179c32e9a5320b2396afb5c19f2e7", "filename": "src/test/run-pass/unboxed-closures-sugar-object.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-object.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test unboxed closure sugar used in object types.\n+\n+#![allow(dead_code)]\n+\n+struct Foo<T,U> {\n+    t: T, u: U\n+}\n+\n+trait Getter<A,R> {\n+    fn get(&self, arg: A) -> R;\n+}\n+\n+struct Identity;\n+impl<X> Getter<X,X> for Identity {\n+    fn get(&self, arg: X) -> X {\n+        arg\n+    }\n+}\n+\n+fn main() {\n+    let x: &Getter(int) -> (int,) = &Identity;\n+    let (y,) = x.get((22,));\n+    assert_eq!(y, 22);\n+}"}, {"sha": "426352cadd87fbcf05e312d65a439032a07c28dc", "filename": "src/test/run-pass/unboxed-closures-unboxing-shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Frun-pass%2Funboxed-closures-unboxing-shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221edbae3843848047825701e25b6f9d8b096075/src%2Ftest%2Frun-pass%2Funboxed-closures-unboxing-shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-unboxing-shim.rs?ref=221edbae3843848047825701e25b6f9d8b096075", "patch": "@@ -13,7 +13,7 @@\n use std::ops::FnOnce;\n \n fn main() {\n-    let task: Box<|: int| -> int> = box |: x| x;\n+    let task: Box<FnOnce(int) -> int> = box |: x| x;\n     assert!(task.call_once((1234i,)) == 1234i);\n }\n "}]}