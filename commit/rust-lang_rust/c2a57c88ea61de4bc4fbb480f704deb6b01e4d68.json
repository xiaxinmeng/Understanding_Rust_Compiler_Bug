{"sha": "c2a57c88ea61de4bc4fbb480f704deb6b01e4d68", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYTU3Yzg4ZWE2MWRlNGJjNGZiYjQ4MGY3MDRkZWI2YjAxZTRkNjg=", "commit": {"author": {"name": "chansuke", "email": "chansuke@georepublic.de", "date": "2019-06-11T17:34:34Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-16T11:17:01Z"}, "message": "Separate libtest module", "tree": {"sha": "56c69e06390aa146d8589957736736dfa35e4e83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56c69e06390aa146d8589957736736dfa35e4e83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2a57c88ea61de4bc4fbb480f704deb6b01e4d68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2a57c88ea61de4bc4fbb480f704deb6b01e4d68", "html_url": "https://github.com/rust-lang/rust/commit/c2a57c88ea61de4bc4fbb480f704deb6b01e4d68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2a57c88ea61de4bc4fbb480f704deb6b01e4d68/comments", "author": null, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db55aafd72d88c64a8fe3959625edcd207f0d25d", "url": "https://api.github.com/repos/rust-lang/rust/commits/db55aafd72d88c64a8fe3959625edcd207f0d25d", "html_url": "https://github.com/rust-lang/rust/commit/db55aafd72d88c64a8fe3959625edcd207f0d25d"}], "stats": {"total": 2060, "additions": 1029, "deletions": 1031}, "files": [{"sha": "53bf67bdf671f181db9378d731fa0990a0403ead", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 455, "changes": 456, "blob_url": "https://github.com/rust-lang/rust/blob/c2a57c88ea61de4bc4fbb480f704deb6b01e4d68/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a57c88ea61de4bc4fbb480f704deb6b01e4d68/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=c2a57c88ea61de4bc4fbb480f704deb6b01e4d68", "patch": "@@ -1772,458 +1772,4 @@ pub mod bench {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use crate::bench;\n-    use crate::test::{\n-        filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n-        ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed, TrFailedMsg,\n-        TrIgnored, TrOk,\n-    };\n-    use crate::Bencher;\n-    use crate::Concurrent;\n-    use std::sync::mpsc::channel;\n-\n-    fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n-        vec![\n-            TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(\"1\"),\n-                    ignore: true,\n-                    should_panic: ShouldPanic::No,\n-                    allow_fail: false,\n-                },\n-                testfn: DynTestFn(Box::new(move || {})),\n-            },\n-            TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(\"2\"),\n-                    ignore: false,\n-                    should_panic: ShouldPanic::No,\n-                    allow_fail: false,\n-                },\n-                testfn: DynTestFn(Box::new(move || {})),\n-            },\n-        ]\n-    }\n-\n-    #[test]\n-    pub fn do_not_run_ignored_tests() {\n-        fn f() {\n-            panic!();\n-        }\n-        let desc = TestDescAndFn {\n-            desc: TestDesc {\n-                name: StaticTestName(\"whatever\"),\n-                ignore: true,\n-                should_panic: ShouldPanic::No,\n-                allow_fail: false,\n-            },\n-            testfn: DynTestFn(Box::new(f)),\n-        };\n-        let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-        let (_, res, _) = rx.recv().unwrap();\n-        assert!(res != TrOk);\n-    }\n-\n-    #[test]\n-    pub fn ignored_tests_result_in_ignored() {\n-        fn f() {}\n-        let desc = TestDescAndFn {\n-            desc: TestDesc {\n-                name: StaticTestName(\"whatever\"),\n-                ignore: true,\n-                should_panic: ShouldPanic::No,\n-                allow_fail: false,\n-            },\n-            testfn: DynTestFn(Box::new(f)),\n-        };\n-        let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-        let (_, res, _) = rx.recv().unwrap();\n-        assert!(res == TrIgnored);\n-    }\n-\n-    #[test]\n-    fn test_should_panic() {\n-        fn f() {\n-            panic!();\n-        }\n-        let desc = TestDescAndFn {\n-            desc: TestDesc {\n-                name: StaticTestName(\"whatever\"),\n-                ignore: false,\n-                should_panic: ShouldPanic::Yes,\n-                allow_fail: false,\n-            },\n-            testfn: DynTestFn(Box::new(f)),\n-        };\n-        let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-        let (_, res, _) = rx.recv().unwrap();\n-        assert!(res == TrOk);\n-    }\n-\n-    #[test]\n-    fn test_should_panic_good_message() {\n-        fn f() {\n-            panic!(\"an error message\");\n-        }\n-        let desc = TestDescAndFn {\n-            desc: TestDesc {\n-                name: StaticTestName(\"whatever\"),\n-                ignore: false,\n-                should_panic: ShouldPanic::YesWithMessage(\"error message\"),\n-                allow_fail: false,\n-            },\n-            testfn: DynTestFn(Box::new(f)),\n-        };\n-        let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-        let (_, res, _) = rx.recv().unwrap();\n-        assert!(res == TrOk);\n-    }\n-\n-    #[test]\n-    fn test_should_panic_bad_message() {\n-        fn f() {\n-            panic!(\"an error message\");\n-        }\n-        let expected = \"foobar\";\n-        let failed_msg = \"panic did not include expected string\";\n-        let desc = TestDescAndFn {\n-            desc: TestDesc {\n-                name: StaticTestName(\"whatever\"),\n-                ignore: false,\n-                should_panic: ShouldPanic::YesWithMessage(expected),\n-                allow_fail: false,\n-            },\n-            testfn: DynTestFn(Box::new(f)),\n-        };\n-        let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-        let (_, res, _) = rx.recv().unwrap();\n-        assert!(res == TrFailedMsg(format!(\"{} '{}'\", failed_msg, expected)));\n-    }\n-\n-    #[test]\n-    fn test_should_panic_but_succeeds() {\n-        fn f() {}\n-        let desc = TestDescAndFn {\n-            desc: TestDesc {\n-                name: StaticTestName(\"whatever\"),\n-                ignore: false,\n-                should_panic: ShouldPanic::Yes,\n-                allow_fail: false,\n-            },\n-            testfn: DynTestFn(Box::new(f)),\n-        };\n-        let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-        let (_, res, _) = rx.recv().unwrap();\n-        assert!(res == TrFailed);\n-    }\n-\n-    #[test]\n-    fn parse_ignored_flag() {\n-        let args = vec![\n-            \"progname\".to_string(),\n-            \"filter\".to_string(),\n-            \"--ignored\".to_string(),\n-        ];\n-        let opts = parse_opts(&args).unwrap().unwrap();\n-        assert_eq!(opts.run_ignored, RunIgnored::Only);\n-    }\n-\n-    #[test]\n-    fn parse_include_ignored_flag() {\n-        let args = vec![\n-            \"progname\".to_string(),\n-            \"filter\".to_string(),\n-            \"-Zunstable-options\".to_string(),\n-            \"--include-ignored\".to_string(),\n-        ];\n-        let opts = parse_opts(&args).unwrap().unwrap();\n-        assert_eq!(opts.run_ignored, RunIgnored::Yes);\n-    }\n-\n-    #[test]\n-    pub fn filter_for_ignored_option() {\n-        // When we run ignored tests the test filter should filter out all the\n-        // unignored tests and flip the ignore flag on the rest to false\n-\n-        let mut opts = TestOpts::new();\n-        opts.run_tests = true;\n-        opts.run_ignored = RunIgnored::Only;\n-\n-        let tests = one_ignored_one_unignored_test();\n-        let filtered = filter_tests(&opts, tests);\n-\n-        assert_eq!(filtered.len(), 1);\n-        assert_eq!(filtered[0].desc.name.to_string(), \"1\");\n-        assert!(!filtered[0].desc.ignore);\n-    }\n-\n-    #[test]\n-    pub fn run_include_ignored_option() {\n-        // When we \"--include-ignored\" tests, the ignore flag should be set to false on\n-        // all tests and no test filtered out\n-\n-        let mut opts = TestOpts::new();\n-        opts.run_tests = true;\n-        opts.run_ignored = RunIgnored::Yes;\n-\n-        let tests = one_ignored_one_unignored_test();\n-        let filtered = filter_tests(&opts, tests);\n-\n-        assert_eq!(filtered.len(), 2);\n-        assert!(!filtered[0].desc.ignore);\n-        assert!(!filtered[1].desc.ignore);\n-    }\n-\n-    #[test]\n-    pub fn exclude_should_panic_option() {\n-        let mut opts = TestOpts::new();\n-        opts.run_tests = true;\n-        opts.exclude_should_panic = true;\n-\n-        let mut tests = one_ignored_one_unignored_test();\n-        tests.push(TestDescAndFn {\n-            desc: TestDesc {\n-                name: StaticTestName(\"3\"),\n-                ignore: false,\n-                should_panic: ShouldPanic::Yes,\n-                allow_fail: false,\n-            },\n-            testfn: DynTestFn(Box::new(move || {})),\n-        });\n-\n-        let filtered = filter_tests(&opts, tests);\n-\n-        assert_eq!(filtered.len(), 2);\n-        assert!(filtered.iter().all(|test| test.desc.should_panic == ShouldPanic::No));\n-    }\n-\n-    #[test]\n-    pub fn exact_filter_match() {\n-        fn tests() -> Vec<TestDescAndFn> {\n-            vec![\"base\", \"base::test\", \"base::test1\", \"base::test2\"]\n-                .into_iter()\n-                .map(|name| TestDescAndFn {\n-                    desc: TestDesc {\n-                        name: StaticTestName(name),\n-                        ignore: false,\n-                        should_panic: ShouldPanic::No,\n-                        allow_fail: false,\n-                    },\n-                    testfn: DynTestFn(Box::new(move || {})),\n-                })\n-                .collect()\n-        }\n-\n-        let substr = filter_tests(\n-            &TestOpts {\n-                filter: Some(\"base\".into()),\n-                ..TestOpts::new()\n-            },\n-            tests(),\n-        );\n-        assert_eq!(substr.len(), 4);\n-\n-        let substr = filter_tests(\n-            &TestOpts {\n-                filter: Some(\"bas\".into()),\n-                ..TestOpts::new()\n-            },\n-            tests(),\n-        );\n-        assert_eq!(substr.len(), 4);\n-\n-        let substr = filter_tests(\n-            &TestOpts {\n-                filter: Some(\"::test\".into()),\n-                ..TestOpts::new()\n-            },\n-            tests(),\n-        );\n-        assert_eq!(substr.len(), 3);\n-\n-        let substr = filter_tests(\n-            &TestOpts {\n-                filter: Some(\"base::test\".into()),\n-                ..TestOpts::new()\n-            },\n-            tests(),\n-        );\n-        assert_eq!(substr.len(), 3);\n-\n-        let exact = filter_tests(\n-            &TestOpts {\n-                filter: Some(\"base\".into()),\n-                filter_exact: true,\n-                ..TestOpts::new()\n-            },\n-            tests(),\n-        );\n-        assert_eq!(exact.len(), 1);\n-\n-        let exact = filter_tests(\n-            &TestOpts {\n-                filter: Some(\"bas\".into()),\n-                filter_exact: true,\n-                ..TestOpts::new()\n-            },\n-            tests(),\n-        );\n-        assert_eq!(exact.len(), 0);\n-\n-        let exact = filter_tests(\n-            &TestOpts {\n-                filter: Some(\"::test\".into()),\n-                filter_exact: true,\n-                ..TestOpts::new()\n-            },\n-            tests(),\n-        );\n-        assert_eq!(exact.len(), 0);\n-\n-        let exact = filter_tests(\n-            &TestOpts {\n-                filter: Some(\"base::test\".into()),\n-                filter_exact: true,\n-                ..TestOpts::new()\n-            },\n-            tests(),\n-        );\n-        assert_eq!(exact.len(), 1);\n-    }\n-\n-    #[test]\n-    pub fn sort_tests() {\n-        let mut opts = TestOpts::new();\n-        opts.run_tests = true;\n-\n-        let names = vec![\n-            \"sha1::test\".to_string(),\n-            \"isize::test_to_str\".to_string(),\n-            \"isize::test_pow\".to_string(),\n-            \"test::do_not_run_ignored_tests\".to_string(),\n-            \"test::ignored_tests_result_in_ignored\".to_string(),\n-            \"test::first_free_arg_should_be_a_filter\".to_string(),\n-            \"test::parse_ignored_flag\".to_string(),\n-            \"test::parse_include_ignored_flag\".to_string(),\n-            \"test::filter_for_ignored_option\".to_string(),\n-            \"test::run_include_ignored_option\".to_string(),\n-            \"test::sort_tests\".to_string(),\n-        ];\n-        let tests = {\n-            fn testfn() {}\n-            let mut tests = Vec::new();\n-            for name in &names {\n-                let test = TestDescAndFn {\n-                    desc: TestDesc {\n-                        name: DynTestName((*name).clone()),\n-                        ignore: false,\n-                        should_panic: ShouldPanic::No,\n-                        allow_fail: false,\n-                    },\n-                    testfn: DynTestFn(Box::new(testfn)),\n-                };\n-                tests.push(test);\n-            }\n-            tests\n-        };\n-        let filtered = filter_tests(&opts, tests);\n-\n-        let expected = vec![\n-            \"isize::test_pow\".to_string(),\n-            \"isize::test_to_str\".to_string(),\n-            \"sha1::test\".to_string(),\n-            \"test::do_not_run_ignored_tests\".to_string(),\n-            \"test::filter_for_ignored_option\".to_string(),\n-            \"test::first_free_arg_should_be_a_filter\".to_string(),\n-            \"test::ignored_tests_result_in_ignored\".to_string(),\n-            \"test::parse_ignored_flag\".to_string(),\n-            \"test::parse_include_ignored_flag\".to_string(),\n-            \"test::run_include_ignored_option\".to_string(),\n-            \"test::sort_tests\".to_string(),\n-        ];\n-\n-        for (a, b) in expected.iter().zip(filtered) {\n-            assert!(*a == b.desc.name.to_string());\n-        }\n-    }\n-\n-    #[test]\n-    pub fn test_metricmap_compare() {\n-        let mut m1 = MetricMap::new();\n-        let mut m2 = MetricMap::new();\n-        m1.insert_metric(\"in-both-noise\", 1000.0, 200.0);\n-        m2.insert_metric(\"in-both-noise\", 1100.0, 200.0);\n-\n-        m1.insert_metric(\"in-first-noise\", 1000.0, 2.0);\n-        m2.insert_metric(\"in-second-noise\", 1000.0, 2.0);\n-\n-        m1.insert_metric(\"in-both-want-downwards-but-regressed\", 1000.0, 10.0);\n-        m2.insert_metric(\"in-both-want-downwards-but-regressed\", 2000.0, 10.0);\n-\n-        m1.insert_metric(\"in-both-want-downwards-and-improved\", 2000.0, 10.0);\n-        m2.insert_metric(\"in-both-want-downwards-and-improved\", 1000.0, 10.0);\n-\n-        m1.insert_metric(\"in-both-want-upwards-but-regressed\", 2000.0, -10.0);\n-        m2.insert_metric(\"in-both-want-upwards-but-regressed\", 1000.0, -10.0);\n-\n-        m1.insert_metric(\"in-both-want-upwards-and-improved\", 1000.0, -10.0);\n-        m2.insert_metric(\"in-both-want-upwards-and-improved\", 2000.0, -10.0);\n-    }\n-\n-    #[test]\n-    pub fn test_bench_once_no_iter() {\n-        fn f(_: &mut Bencher) {}\n-        bench::run_once(f);\n-    }\n-\n-    #[test]\n-    pub fn test_bench_once_iter() {\n-        fn f(b: &mut Bencher) {\n-            b.iter(|| {})\n-        }\n-        bench::run_once(f);\n-    }\n-\n-    #[test]\n-    pub fn test_bench_no_iter() {\n-        fn f(_: &mut Bencher) {}\n-\n-        let (tx, rx) = channel();\n-\n-        let desc = TestDesc {\n-            name: StaticTestName(\"f\"),\n-            ignore: false,\n-            should_panic: ShouldPanic::No,\n-            allow_fail: false,\n-        };\n-\n-        crate::bench::benchmark(desc, tx, true, f);\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    pub fn test_bench_iter() {\n-        fn f(b: &mut Bencher) {\n-            b.iter(|| {})\n-        }\n-\n-        let (tx, rx) = channel();\n-\n-        let desc = TestDesc {\n-            name: StaticTestName(\"f\"),\n-            ignore: false,\n-            should_panic: ShouldPanic::No,\n-            allow_fail: false,\n-        };\n-\n-        crate::bench::benchmark(desc, tx, true, f);\n-        rx.recv().unwrap();\n-    }\n-}\n+mod tests;"}, {"sha": "32c30061983aba7482b20b3d093611a293fbfad8", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 576, "changes": 577, "blob_url": "https://github.com/rust-lang/rust/blob/c2a57c88ea61de4bc4fbb480f704deb6b01e4d68/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a57c88ea61de4bc4fbb480f704deb6b01e4d68/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=c2a57c88ea61de4bc4fbb480f704deb6b01e4d68", "patch": "@@ -318,582 +318,7 @@ pub fn winsorize(samples: &mut [f64], pct: f64) {\n // Test vectors generated from R, using the script src/etc/stat-test-vectors.r.\n \n #[cfg(test)]\n-mod tests {\n-    use crate::stats::Stats;\n-    use crate::stats::Summary;\n-    use std::f64;\n-    use std::io::prelude::*;\n-    use std::io;\n-\n-    macro_rules! assert_approx_eq {\n-        ($a: expr, $b: expr) => {{\n-            let (a, b) = (&$a, &$b);\n-            assert!(\n-                (*a - *b).abs() < 1.0e-6,\n-                \"{} is not approximately equal to {}\",\n-                *a,\n-                *b\n-            );\n-        }};\n-    }\n-\n-    fn check(samples: &[f64], summ: &Summary) {\n-        let summ2 = Summary::new(samples);\n-\n-        let mut w = io::sink();\n-        let w = &mut w;\n-        (write!(w, \"\\n\")).unwrap();\n-\n-        assert_eq!(summ.sum, summ2.sum);\n-        assert_eq!(summ.min, summ2.min);\n-        assert_eq!(summ.max, summ2.max);\n-        assert_eq!(summ.mean, summ2.mean);\n-        assert_eq!(summ.median, summ2.median);\n-\n-        // We needed a few more digits to get exact equality on these\n-        // but they're within float epsilon, which is 1.0e-6.\n-        assert_approx_eq!(summ.var, summ2.var);\n-        assert_approx_eq!(summ.std_dev, summ2.std_dev);\n-        assert_approx_eq!(summ.std_dev_pct, summ2.std_dev_pct);\n-        assert_approx_eq!(summ.median_abs_dev, summ2.median_abs_dev);\n-        assert_approx_eq!(summ.median_abs_dev_pct, summ2.median_abs_dev_pct);\n-\n-        assert_eq!(summ.quartiles, summ2.quartiles);\n-        assert_eq!(summ.iqr, summ2.iqr);\n-    }\n-\n-    #[test]\n-    fn test_min_max_nan() {\n-        let xs = &[1.0, 2.0, f64::NAN, 3.0, 4.0];\n-        let summary = Summary::new(xs);\n-        assert_eq!(summary.min, 1.0);\n-        assert_eq!(summary.max, 4.0);\n-    }\n-\n-    #[test]\n-    fn test_norm2() {\n-        let val = &[958.0000000000, 924.0000000000];\n-        let summ = &Summary {\n-            sum: 1882.0000000000,\n-            min: 924.0000000000,\n-            max: 958.0000000000,\n-            mean: 941.0000000000,\n-            median: 941.0000000000,\n-            var: 578.0000000000,\n-            std_dev: 24.0416305603,\n-            std_dev_pct: 2.5549022912,\n-            median_abs_dev: 25.2042000000,\n-            median_abs_dev_pct: 2.6784484591,\n-            quartiles: (932.5000000000, 941.0000000000, 949.5000000000),\n-            iqr: 17.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_norm10narrow() {\n-        let val = &[\n-            966.0000000000,\n-            985.0000000000,\n-            1110.0000000000,\n-            848.0000000000,\n-            821.0000000000,\n-            975.0000000000,\n-            962.0000000000,\n-            1157.0000000000,\n-            1217.0000000000,\n-            955.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 9996.0000000000,\n-            min: 821.0000000000,\n-            max: 1217.0000000000,\n-            mean: 999.6000000000,\n-            median: 970.5000000000,\n-            var: 16050.7111111111,\n-            std_dev: 126.6914010938,\n-            std_dev_pct: 12.6742097933,\n-            median_abs_dev: 102.2994000000,\n-            median_abs_dev_pct: 10.5408964451,\n-            quartiles: (956.7500000000, 970.5000000000, 1078.7500000000),\n-            iqr: 122.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_norm10medium() {\n-        let val = &[\n-            954.0000000000,\n-            1064.0000000000,\n-            855.0000000000,\n-            1000.0000000000,\n-            743.0000000000,\n-            1084.0000000000,\n-            704.0000000000,\n-            1023.0000000000,\n-            357.0000000000,\n-            869.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 8653.0000000000,\n-            min: 357.0000000000,\n-            max: 1084.0000000000,\n-            mean: 865.3000000000,\n-            median: 911.5000000000,\n-            var: 48628.4555555556,\n-            std_dev: 220.5186059170,\n-            std_dev_pct: 25.4846418487,\n-            median_abs_dev: 195.7032000000,\n-            median_abs_dev_pct: 21.4704552935,\n-            quartiles: (771.0000000000, 911.5000000000, 1017.2500000000),\n-            iqr: 246.2500000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_norm10wide() {\n-        let val = &[\n-            505.0000000000,\n-            497.0000000000,\n-            1591.0000000000,\n-            887.0000000000,\n-            1026.0000000000,\n-            136.0000000000,\n-            1580.0000000000,\n-            940.0000000000,\n-            754.0000000000,\n-            1433.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 9349.0000000000,\n-            min: 136.0000000000,\n-            max: 1591.0000000000,\n-            mean: 934.9000000000,\n-            median: 913.5000000000,\n-            var: 239208.9888888889,\n-            std_dev: 489.0899599142,\n-            std_dev_pct: 52.3146817750,\n-            median_abs_dev: 611.5725000000,\n-            median_abs_dev_pct: 66.9482758621,\n-            quartiles: (567.2500000000, 913.5000000000, 1331.2500000000),\n-            iqr: 764.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_norm25verynarrow() {\n-        let val = &[\n-            991.0000000000,\n-            1018.0000000000,\n-            998.0000000000,\n-            1013.0000000000,\n-            974.0000000000,\n-            1007.0000000000,\n-            1014.0000000000,\n-            999.0000000000,\n-            1011.0000000000,\n-            978.0000000000,\n-            985.0000000000,\n-            999.0000000000,\n-            983.0000000000,\n-            982.0000000000,\n-            1015.0000000000,\n-            1002.0000000000,\n-            977.0000000000,\n-            948.0000000000,\n-            1040.0000000000,\n-            974.0000000000,\n-            996.0000000000,\n-            989.0000000000,\n-            1015.0000000000,\n-            994.0000000000,\n-            1024.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 24926.0000000000,\n-            min: 948.0000000000,\n-            max: 1040.0000000000,\n-            mean: 997.0400000000,\n-            median: 998.0000000000,\n-            var: 393.2066666667,\n-            std_dev: 19.8294393937,\n-            std_dev_pct: 1.9888308788,\n-            median_abs_dev: 22.2390000000,\n-            median_abs_dev_pct: 2.2283567134,\n-            quartiles: (983.0000000000, 998.0000000000, 1013.0000000000),\n-            iqr: 30.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_exp10a() {\n-        let val = &[\n-            23.0000000000,\n-            11.0000000000,\n-            2.0000000000,\n-            57.0000000000,\n-            4.0000000000,\n-            12.0000000000,\n-            5.0000000000,\n-            29.0000000000,\n-            3.0000000000,\n-            21.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 167.0000000000,\n-            min: 2.0000000000,\n-            max: 57.0000000000,\n-            mean: 16.7000000000,\n-            median: 11.5000000000,\n-            var: 287.7888888889,\n-            std_dev: 16.9643416875,\n-            std_dev_pct: 101.5828843560,\n-            median_abs_dev: 13.3434000000,\n-            median_abs_dev_pct: 116.0295652174,\n-            quartiles: (4.2500000000, 11.5000000000, 22.5000000000),\n-            iqr: 18.2500000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_exp10b() {\n-        let val = &[\n-            24.0000000000,\n-            17.0000000000,\n-            6.0000000000,\n-            38.0000000000,\n-            25.0000000000,\n-            7.0000000000,\n-            51.0000000000,\n-            2.0000000000,\n-            61.0000000000,\n-            32.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 263.0000000000,\n-            min: 2.0000000000,\n-            max: 61.0000000000,\n-            mean: 26.3000000000,\n-            median: 24.5000000000,\n-            var: 383.5666666667,\n-            std_dev: 19.5848580967,\n-            std_dev_pct: 74.4671410520,\n-            median_abs_dev: 22.9803000000,\n-            median_abs_dev_pct: 93.7971428571,\n-            quartiles: (9.5000000000, 24.5000000000, 36.5000000000),\n-            iqr: 27.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_exp10c() {\n-        let val = &[\n-            71.0000000000,\n-            2.0000000000,\n-            32.0000000000,\n-            1.0000000000,\n-            6.0000000000,\n-            28.0000000000,\n-            13.0000000000,\n-            37.0000000000,\n-            16.0000000000,\n-            36.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 242.0000000000,\n-            min: 1.0000000000,\n-            max: 71.0000000000,\n-            mean: 24.2000000000,\n-            median: 22.0000000000,\n-            var: 458.1777777778,\n-            std_dev: 21.4050876611,\n-            std_dev_pct: 88.4507754589,\n-            median_abs_dev: 21.4977000000,\n-            median_abs_dev_pct: 97.7168181818,\n-            quartiles: (7.7500000000, 22.0000000000, 35.0000000000),\n-            iqr: 27.2500000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_exp25() {\n-        let val = &[\n-            3.0000000000,\n-            24.0000000000,\n-            1.0000000000,\n-            19.0000000000,\n-            7.0000000000,\n-            5.0000000000,\n-            30.0000000000,\n-            39.0000000000,\n-            31.0000000000,\n-            13.0000000000,\n-            25.0000000000,\n-            48.0000000000,\n-            1.0000000000,\n-            6.0000000000,\n-            42.0000000000,\n-            63.0000000000,\n-            2.0000000000,\n-            12.0000000000,\n-            108.0000000000,\n-            26.0000000000,\n-            1.0000000000,\n-            7.0000000000,\n-            44.0000000000,\n-            25.0000000000,\n-            11.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 593.0000000000,\n-            min: 1.0000000000,\n-            max: 108.0000000000,\n-            mean: 23.7200000000,\n-            median: 19.0000000000,\n-            var: 601.0433333333,\n-            std_dev: 24.5161851301,\n-            std_dev_pct: 103.3565983562,\n-            median_abs_dev: 19.2738000000,\n-            median_abs_dev_pct: 101.4410526316,\n-            quartiles: (6.0000000000, 19.0000000000, 31.0000000000),\n-            iqr: 25.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_binom25() {\n-        let val = &[\n-            18.0000000000,\n-            17.0000000000,\n-            27.0000000000,\n-            15.0000000000,\n-            21.0000000000,\n-            25.0000000000,\n-            17.0000000000,\n-            24.0000000000,\n-            25.0000000000,\n-            24.0000000000,\n-            26.0000000000,\n-            26.0000000000,\n-            23.0000000000,\n-            15.0000000000,\n-            23.0000000000,\n-            17.0000000000,\n-            18.0000000000,\n-            18.0000000000,\n-            21.0000000000,\n-            16.0000000000,\n-            15.0000000000,\n-            31.0000000000,\n-            20.0000000000,\n-            17.0000000000,\n-            15.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 514.0000000000,\n-            min: 15.0000000000,\n-            max: 31.0000000000,\n-            mean: 20.5600000000,\n-            median: 20.0000000000,\n-            var: 20.8400000000,\n-            std_dev: 4.5650848842,\n-            std_dev_pct: 22.2037202539,\n-            median_abs_dev: 5.9304000000,\n-            median_abs_dev_pct: 29.6520000000,\n-            quartiles: (17.0000000000, 20.0000000000, 24.0000000000),\n-            iqr: 7.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_pois25lambda30() {\n-        let val = &[\n-            27.0000000000,\n-            33.0000000000,\n-            34.0000000000,\n-            34.0000000000,\n-            24.0000000000,\n-            39.0000000000,\n-            28.0000000000,\n-            27.0000000000,\n-            31.0000000000,\n-            28.0000000000,\n-            38.0000000000,\n-            21.0000000000,\n-            33.0000000000,\n-            36.0000000000,\n-            29.0000000000,\n-            37.0000000000,\n-            32.0000000000,\n-            34.0000000000,\n-            31.0000000000,\n-            39.0000000000,\n-            25.0000000000,\n-            31.0000000000,\n-            32.0000000000,\n-            40.0000000000,\n-            24.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 787.0000000000,\n-            min: 21.0000000000,\n-            max: 40.0000000000,\n-            mean: 31.4800000000,\n-            median: 32.0000000000,\n-            var: 26.5933333333,\n-            std_dev: 5.1568724372,\n-            std_dev_pct: 16.3814245145,\n-            median_abs_dev: 5.9304000000,\n-            median_abs_dev_pct: 18.5325000000,\n-            quartiles: (28.0000000000, 32.0000000000, 34.0000000000),\n-            iqr: 6.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_pois25lambda40() {\n-        let val = &[\n-            42.0000000000,\n-            50.0000000000,\n-            42.0000000000,\n-            46.0000000000,\n-            34.0000000000,\n-            45.0000000000,\n-            34.0000000000,\n-            49.0000000000,\n-            39.0000000000,\n-            28.0000000000,\n-            40.0000000000,\n-            35.0000000000,\n-            37.0000000000,\n-            39.0000000000,\n-            46.0000000000,\n-            44.0000000000,\n-            32.0000000000,\n-            45.0000000000,\n-            42.0000000000,\n-            37.0000000000,\n-            48.0000000000,\n-            42.0000000000,\n-            33.0000000000,\n-            42.0000000000,\n-            48.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 1019.0000000000,\n-            min: 28.0000000000,\n-            max: 50.0000000000,\n-            mean: 40.7600000000,\n-            median: 42.0000000000,\n-            var: 34.4400000000,\n-            std_dev: 5.8685603004,\n-            std_dev_pct: 14.3978417577,\n-            median_abs_dev: 5.9304000000,\n-            median_abs_dev_pct: 14.1200000000,\n-            quartiles: (37.0000000000, 42.0000000000, 45.0000000000),\n-            iqr: 8.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_pois25lambda50() {\n-        let val = &[\n-            45.0000000000,\n-            43.0000000000,\n-            44.0000000000,\n-            61.0000000000,\n-            51.0000000000,\n-            53.0000000000,\n-            59.0000000000,\n-            52.0000000000,\n-            49.0000000000,\n-            51.0000000000,\n-            51.0000000000,\n-            50.0000000000,\n-            49.0000000000,\n-            56.0000000000,\n-            42.0000000000,\n-            52.0000000000,\n-            51.0000000000,\n-            43.0000000000,\n-            48.0000000000,\n-            48.0000000000,\n-            50.0000000000,\n-            42.0000000000,\n-            43.0000000000,\n-            42.0000000000,\n-            60.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 1235.0000000000,\n-            min: 42.0000000000,\n-            max: 61.0000000000,\n-            mean: 49.4000000000,\n-            median: 50.0000000000,\n-            var: 31.6666666667,\n-            std_dev: 5.6273143387,\n-            std_dev_pct: 11.3913245723,\n-            median_abs_dev: 4.4478000000,\n-            median_abs_dev_pct: 8.8956000000,\n-            quartiles: (44.0000000000, 50.0000000000, 52.0000000000),\n-            iqr: 8.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_unif25() {\n-        let val = &[\n-            99.0000000000,\n-            55.0000000000,\n-            92.0000000000,\n-            79.0000000000,\n-            14.0000000000,\n-            2.0000000000,\n-            33.0000000000,\n-            49.0000000000,\n-            3.0000000000,\n-            32.0000000000,\n-            84.0000000000,\n-            59.0000000000,\n-            22.0000000000,\n-            86.0000000000,\n-            76.0000000000,\n-            31.0000000000,\n-            29.0000000000,\n-            11.0000000000,\n-            41.0000000000,\n-            53.0000000000,\n-            45.0000000000,\n-            44.0000000000,\n-            98.0000000000,\n-            98.0000000000,\n-            7.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 1242.0000000000,\n-            min: 2.0000000000,\n-            max: 99.0000000000,\n-            mean: 49.6800000000,\n-            median: 45.0000000000,\n-            var: 1015.6433333333,\n-            std_dev: 31.8691595957,\n-            std_dev_pct: 64.1488719719,\n-            median_abs_dev: 45.9606000000,\n-            median_abs_dev_pct: 102.1346666667,\n-            quartiles: (29.0000000000, 45.0000000000, 79.0000000000),\n-            iqr: 50.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-\n-    #[test]\n-    fn test_sum_f64s() {\n-        assert_eq!([0.5f64, 3.2321f64, 1.5678f64].sum(), 5.2999);\n-    }\n-    #[test]\n-    fn test_sum_f64_between_ints_that_sum_to_0() {\n-        assert_eq!([1e30f64, 1.2f64, -1e30f64].sum(), 1.2);\n-    }\n-}\n+mod tests;\n \n #[cfg(test)]\n mod bench {"}, {"sha": "59f936453602a1b5719fececdc09b10ddde97579", "filename": "src/libtest/stats/tests.rs", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/rust-lang/rust/blob/c2a57c88ea61de4bc4fbb480f704deb6b01e4d68/src%2Flibtest%2Fstats%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a57c88ea61de4bc4fbb480f704deb6b01e4d68/src%2Flibtest%2Fstats%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats%2Ftests.rs?ref=c2a57c88ea61de4bc4fbb480f704deb6b01e4d68", "patch": "@@ -0,0 +1,574 @@\n+use crate::stats::Stats;\n+use crate::stats::Summary;\n+use std::f64;\n+use std::io::prelude::*;\n+use std::io;\n+\n+macro_rules! assert_approx_eq {\n+    ($a: expr, $b: expr) => {{\n+        let (a, b) = (&$a, &$b);\n+        assert!(\n+            (*a - *b).abs() < 1.0e-6,\n+            \"{} is not approximately equal to {}\",\n+            *a,\n+            *b\n+        );\n+    }};\n+}\n+\n+fn check(samples: &[f64], summ: &Summary) {\n+    let summ2 = Summary::new(samples);\n+\n+    let mut w = io::sink();\n+    let w = &mut w;\n+    (write!(w, \"\\n\")).unwrap();\n+\n+    assert_eq!(summ.sum, summ2.sum);\n+    assert_eq!(summ.min, summ2.min);\n+    assert_eq!(summ.max, summ2.max);\n+    assert_eq!(summ.mean, summ2.mean);\n+    assert_eq!(summ.median, summ2.median);\n+\n+    // We needed a few more digits to get exact equality on these\n+    // but they're within float epsilon, which is 1.0e-6.\n+    assert_approx_eq!(summ.var, summ2.var);\n+    assert_approx_eq!(summ.std_dev, summ2.std_dev);\n+    assert_approx_eq!(summ.std_dev_pct, summ2.std_dev_pct);\n+    assert_approx_eq!(summ.median_abs_dev, summ2.median_abs_dev);\n+    assert_approx_eq!(summ.median_abs_dev_pct, summ2.median_abs_dev_pct);\n+\n+    assert_eq!(summ.quartiles, summ2.quartiles);\n+    assert_eq!(summ.iqr, summ2.iqr);\n+}\n+\n+#[test]\n+fn test_min_max_nan() {\n+    let xs = &[1.0, 2.0, f64::NAN, 3.0, 4.0];\n+    let summary = Summary::new(xs);\n+    assert_eq!(summary.min, 1.0);\n+    assert_eq!(summary.max, 4.0);\n+}\n+\n+#[test]\n+fn test_norm2() {\n+    let val = &[958.0000000000, 924.0000000000];\n+    let summ = &Summary {\n+        sum: 1882.0000000000,\n+        min: 924.0000000000,\n+        max: 958.0000000000,\n+        mean: 941.0000000000,\n+        median: 941.0000000000,\n+        var: 578.0000000000,\n+        std_dev: 24.0416305603,\n+        std_dev_pct: 2.5549022912,\n+        median_abs_dev: 25.2042000000,\n+        median_abs_dev_pct: 2.6784484591,\n+        quartiles: (932.5000000000, 941.0000000000, 949.5000000000),\n+        iqr: 17.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_norm10narrow() {\n+    let val = &[\n+        966.0000000000,\n+        985.0000000000,\n+        1110.0000000000,\n+        848.0000000000,\n+        821.0000000000,\n+        975.0000000000,\n+        962.0000000000,\n+        1157.0000000000,\n+        1217.0000000000,\n+        955.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 9996.0000000000,\n+        min: 821.0000000000,\n+        max: 1217.0000000000,\n+        mean: 999.6000000000,\n+        median: 970.5000000000,\n+        var: 16050.7111111111,\n+        std_dev: 126.6914010938,\n+        std_dev_pct: 12.6742097933,\n+        median_abs_dev: 102.2994000000,\n+        median_abs_dev_pct: 10.5408964451,\n+        quartiles: (956.7500000000, 970.5000000000, 1078.7500000000),\n+        iqr: 122.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_norm10medium() {\n+    let val = &[\n+        954.0000000000,\n+        1064.0000000000,\n+        855.0000000000,\n+        1000.0000000000,\n+        743.0000000000,\n+        1084.0000000000,\n+        704.0000000000,\n+        1023.0000000000,\n+        357.0000000000,\n+        869.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 8653.0000000000,\n+        min: 357.0000000000,\n+        max: 1084.0000000000,\n+        mean: 865.3000000000,\n+        median: 911.5000000000,\n+        var: 48628.4555555556,\n+        std_dev: 220.5186059170,\n+        std_dev_pct: 25.4846418487,\n+        median_abs_dev: 195.7032000000,\n+        median_abs_dev_pct: 21.4704552935,\n+        quartiles: (771.0000000000, 911.5000000000, 1017.2500000000),\n+        iqr: 246.2500000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_norm10wide() {\n+    let val = &[\n+        505.0000000000,\n+        497.0000000000,\n+        1591.0000000000,\n+        887.0000000000,\n+        1026.0000000000,\n+        136.0000000000,\n+        1580.0000000000,\n+        940.0000000000,\n+        754.0000000000,\n+        1433.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 9349.0000000000,\n+        min: 136.0000000000,\n+        max: 1591.0000000000,\n+        mean: 934.9000000000,\n+        median: 913.5000000000,\n+        var: 239208.9888888889,\n+        std_dev: 489.0899599142,\n+        std_dev_pct: 52.3146817750,\n+        median_abs_dev: 611.5725000000,\n+        median_abs_dev_pct: 66.9482758621,\n+        quartiles: (567.2500000000, 913.5000000000, 1331.2500000000),\n+        iqr: 764.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_norm25verynarrow() {\n+    let val = &[\n+        991.0000000000,\n+        1018.0000000000,\n+        998.0000000000,\n+        1013.0000000000,\n+        974.0000000000,\n+        1007.0000000000,\n+        1014.0000000000,\n+        999.0000000000,\n+        1011.0000000000,\n+        978.0000000000,\n+        985.0000000000,\n+        999.0000000000,\n+        983.0000000000,\n+        982.0000000000,\n+        1015.0000000000,\n+        1002.0000000000,\n+        977.0000000000,\n+        948.0000000000,\n+        1040.0000000000,\n+        974.0000000000,\n+        996.0000000000,\n+        989.0000000000,\n+        1015.0000000000,\n+        994.0000000000,\n+        1024.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 24926.0000000000,\n+        min: 948.0000000000,\n+        max: 1040.0000000000,\n+        mean: 997.0400000000,\n+        median: 998.0000000000,\n+        var: 393.2066666667,\n+        std_dev: 19.8294393937,\n+        std_dev_pct: 1.9888308788,\n+        median_abs_dev: 22.2390000000,\n+        median_abs_dev_pct: 2.2283567134,\n+        quartiles: (983.0000000000, 998.0000000000, 1013.0000000000),\n+        iqr: 30.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_exp10a() {\n+    let val = &[\n+        23.0000000000,\n+        11.0000000000,\n+        2.0000000000,\n+        57.0000000000,\n+        4.0000000000,\n+        12.0000000000,\n+        5.0000000000,\n+        29.0000000000,\n+        3.0000000000,\n+        21.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 167.0000000000,\n+        min: 2.0000000000,\n+        max: 57.0000000000,\n+        mean: 16.7000000000,\n+        median: 11.5000000000,\n+        var: 287.7888888889,\n+        std_dev: 16.9643416875,\n+        std_dev_pct: 101.5828843560,\n+        median_abs_dev: 13.3434000000,\n+        median_abs_dev_pct: 116.0295652174,\n+        quartiles: (4.2500000000, 11.5000000000, 22.5000000000),\n+        iqr: 18.2500000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_exp10b() {\n+    let val = &[\n+        24.0000000000,\n+        17.0000000000,\n+        6.0000000000,\n+        38.0000000000,\n+        25.0000000000,\n+        7.0000000000,\n+        51.0000000000,\n+        2.0000000000,\n+        61.0000000000,\n+        32.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 263.0000000000,\n+        min: 2.0000000000,\n+        max: 61.0000000000,\n+        mean: 26.3000000000,\n+        median: 24.5000000000,\n+        var: 383.5666666667,\n+        std_dev: 19.5848580967,\n+        std_dev_pct: 74.4671410520,\n+        median_abs_dev: 22.9803000000,\n+        median_abs_dev_pct: 93.7971428571,\n+        quartiles: (9.5000000000, 24.5000000000, 36.5000000000),\n+        iqr: 27.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_exp10c() {\n+    let val = &[\n+        71.0000000000,\n+        2.0000000000,\n+        32.0000000000,\n+        1.0000000000,\n+        6.0000000000,\n+        28.0000000000,\n+        13.0000000000,\n+        37.0000000000,\n+        16.0000000000,\n+        36.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 242.0000000000,\n+        min: 1.0000000000,\n+        max: 71.0000000000,\n+        mean: 24.2000000000,\n+        median: 22.0000000000,\n+        var: 458.1777777778,\n+        std_dev: 21.4050876611,\n+        std_dev_pct: 88.4507754589,\n+        median_abs_dev: 21.4977000000,\n+        median_abs_dev_pct: 97.7168181818,\n+        quartiles: (7.7500000000, 22.0000000000, 35.0000000000),\n+        iqr: 27.2500000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_exp25() {\n+    let val = &[\n+        3.0000000000,\n+        24.0000000000,\n+        1.0000000000,\n+        19.0000000000,\n+        7.0000000000,\n+        5.0000000000,\n+        30.0000000000,\n+        39.0000000000,\n+        31.0000000000,\n+        13.0000000000,\n+        25.0000000000,\n+        48.0000000000,\n+        1.0000000000,\n+        6.0000000000,\n+        42.0000000000,\n+        63.0000000000,\n+        2.0000000000,\n+        12.0000000000,\n+        108.0000000000,\n+        26.0000000000,\n+        1.0000000000,\n+        7.0000000000,\n+        44.0000000000,\n+        25.0000000000,\n+        11.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 593.0000000000,\n+        min: 1.0000000000,\n+        max: 108.0000000000,\n+        mean: 23.7200000000,\n+        median: 19.0000000000,\n+        var: 601.0433333333,\n+        std_dev: 24.5161851301,\n+        std_dev_pct: 103.3565983562,\n+        median_abs_dev: 19.2738000000,\n+        median_abs_dev_pct: 101.4410526316,\n+        quartiles: (6.0000000000, 19.0000000000, 31.0000000000),\n+        iqr: 25.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_binom25() {\n+    let val = &[\n+        18.0000000000,\n+        17.0000000000,\n+        27.0000000000,\n+        15.0000000000,\n+        21.0000000000,\n+        25.0000000000,\n+        17.0000000000,\n+        24.0000000000,\n+        25.0000000000,\n+        24.0000000000,\n+        26.0000000000,\n+        26.0000000000,\n+        23.0000000000,\n+        15.0000000000,\n+        23.0000000000,\n+        17.0000000000,\n+        18.0000000000,\n+        18.0000000000,\n+        21.0000000000,\n+        16.0000000000,\n+        15.0000000000,\n+        31.0000000000,\n+        20.0000000000,\n+        17.0000000000,\n+        15.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 514.0000000000,\n+        min: 15.0000000000,\n+        max: 31.0000000000,\n+        mean: 20.5600000000,\n+        median: 20.0000000000,\n+        var: 20.8400000000,\n+        std_dev: 4.5650848842,\n+        std_dev_pct: 22.2037202539,\n+        median_abs_dev: 5.9304000000,\n+        median_abs_dev_pct: 29.6520000000,\n+        quartiles: (17.0000000000, 20.0000000000, 24.0000000000),\n+        iqr: 7.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_pois25lambda30() {\n+    let val = &[\n+        27.0000000000,\n+        33.0000000000,\n+        34.0000000000,\n+        34.0000000000,\n+        24.0000000000,\n+        39.0000000000,\n+        28.0000000000,\n+        27.0000000000,\n+        31.0000000000,\n+        28.0000000000,\n+        38.0000000000,\n+        21.0000000000,\n+        33.0000000000,\n+        36.0000000000,\n+        29.0000000000,\n+        37.0000000000,\n+        32.0000000000,\n+        34.0000000000,\n+        31.0000000000,\n+        39.0000000000,\n+        25.0000000000,\n+        31.0000000000,\n+        32.0000000000,\n+        40.0000000000,\n+        24.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 787.0000000000,\n+        min: 21.0000000000,\n+        max: 40.0000000000,\n+        mean: 31.4800000000,\n+        median: 32.0000000000,\n+        var: 26.5933333333,\n+        std_dev: 5.1568724372,\n+        std_dev_pct: 16.3814245145,\n+        median_abs_dev: 5.9304000000,\n+        median_abs_dev_pct: 18.5325000000,\n+        quartiles: (28.0000000000, 32.0000000000, 34.0000000000),\n+        iqr: 6.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_pois25lambda40() {\n+    let val = &[\n+        42.0000000000,\n+        50.0000000000,\n+        42.0000000000,\n+        46.0000000000,\n+        34.0000000000,\n+        45.0000000000,\n+        34.0000000000,\n+        49.0000000000,\n+        39.0000000000,\n+        28.0000000000,\n+        40.0000000000,\n+        35.0000000000,\n+        37.0000000000,\n+        39.0000000000,\n+        46.0000000000,\n+        44.0000000000,\n+        32.0000000000,\n+        45.0000000000,\n+        42.0000000000,\n+        37.0000000000,\n+        48.0000000000,\n+        42.0000000000,\n+        33.0000000000,\n+        42.0000000000,\n+        48.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 1019.0000000000,\n+        min: 28.0000000000,\n+        max: 50.0000000000,\n+        mean: 40.7600000000,\n+        median: 42.0000000000,\n+        var: 34.4400000000,\n+        std_dev: 5.8685603004,\n+        std_dev_pct: 14.3978417577,\n+        median_abs_dev: 5.9304000000,\n+        median_abs_dev_pct: 14.1200000000,\n+        quartiles: (37.0000000000, 42.0000000000, 45.0000000000),\n+        iqr: 8.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_pois25lambda50() {\n+    let val = &[\n+        45.0000000000,\n+        43.0000000000,\n+        44.0000000000,\n+        61.0000000000,\n+        51.0000000000,\n+        53.0000000000,\n+        59.0000000000,\n+        52.0000000000,\n+        49.0000000000,\n+        51.0000000000,\n+        51.0000000000,\n+        50.0000000000,\n+        49.0000000000,\n+        56.0000000000,\n+        42.0000000000,\n+        52.0000000000,\n+        51.0000000000,\n+        43.0000000000,\n+        48.0000000000,\n+        48.0000000000,\n+        50.0000000000,\n+        42.0000000000,\n+        43.0000000000,\n+        42.0000000000,\n+        60.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 1235.0000000000,\n+        min: 42.0000000000,\n+        max: 61.0000000000,\n+        mean: 49.4000000000,\n+        median: 50.0000000000,\n+        var: 31.6666666667,\n+        std_dev: 5.6273143387,\n+        std_dev_pct: 11.3913245723,\n+        median_abs_dev: 4.4478000000,\n+        median_abs_dev_pct: 8.8956000000,\n+        quartiles: (44.0000000000, 50.0000000000, 52.0000000000),\n+        iqr: 8.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_unif25() {\n+    let val = &[\n+        99.0000000000,\n+        55.0000000000,\n+        92.0000000000,\n+        79.0000000000,\n+        14.0000000000,\n+        2.0000000000,\n+        33.0000000000,\n+        49.0000000000,\n+        3.0000000000,\n+        32.0000000000,\n+        84.0000000000,\n+        59.0000000000,\n+        22.0000000000,\n+        86.0000000000,\n+        76.0000000000,\n+        31.0000000000,\n+        29.0000000000,\n+        11.0000000000,\n+        41.0000000000,\n+        53.0000000000,\n+        45.0000000000,\n+        44.0000000000,\n+        98.0000000000,\n+        98.0000000000,\n+        7.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 1242.0000000000,\n+        min: 2.0000000000,\n+        max: 99.0000000000,\n+        mean: 49.6800000000,\n+        median: 45.0000000000,\n+        var: 1015.6433333333,\n+        std_dev: 31.8691595957,\n+        std_dev_pct: 64.1488719719,\n+        median_abs_dev: 45.9606000000,\n+        median_abs_dev_pct: 102.1346666667,\n+        quartiles: (29.0000000000, 45.0000000000, 79.0000000000),\n+        iqr: 50.0000000000,\n+    };\n+    check(val, summ);\n+}\n+\n+#[test]\n+fn test_sum_f64s() {\n+    assert_eq!([0.5f64, 3.2321f64, 1.5678f64].sum(), 5.2999);\n+}\n+#[test]\n+fn test_sum_f64_between_ints_that_sum_to_0() {\n+    assert_eq!([1e30f64, 1.2f64, -1e30f64].sum(), 1.2);\n+}"}, {"sha": "d8734d8caa03ed1a0e850ef732db6522349c766a", "filename": "src/libtest/tests.rs", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/c2a57c88ea61de4bc4fbb480f704deb6b01e4d68/src%2Flibtest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2a57c88ea61de4bc4fbb480f704deb6b01e4d68/src%2Flibtest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftests.rs?ref=c2a57c88ea61de4bc4fbb480f704deb6b01e4d68", "patch": "@@ -0,0 +1,453 @@\n+use crate::bench;\n+use crate::test::{\n+    filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n+    ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed, TrFailedMsg,\n+    TrIgnored, TrOk,\n+};\n+use crate::Bencher;\n+use crate::Concurrent;\n+use std::sync::mpsc::channel;\n+\n+fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n+    vec![\n+        TestDescAndFn {\n+            desc: TestDesc {\n+                name: StaticTestName(\"1\"),\n+                ignore: true,\n+                should_panic: ShouldPanic::No,\n+                allow_fail: false,\n+            },\n+            testfn: DynTestFn(Box::new(move || {})),\n+        },\n+        TestDescAndFn {\n+            desc: TestDesc {\n+                name: StaticTestName(\"2\"),\n+                ignore: false,\n+                should_panic: ShouldPanic::No,\n+                allow_fail: false,\n+            },\n+            testfn: DynTestFn(Box::new(move || {})),\n+        },\n+    ]\n+}\n+\n+#[test]\n+pub fn do_not_run_ignored_tests() {\n+    fn f() {\n+        panic!();\n+    }\n+    let desc = TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"whatever\"),\n+            ignore: true,\n+            should_panic: ShouldPanic::No,\n+            allow_fail: false,\n+        },\n+        testfn: DynTestFn(Box::new(f)),\n+    };\n+    let (tx, rx) = channel();\n+    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    let (_, res, _) = rx.recv().unwrap();\n+    assert!(res != TrOk);\n+}\n+\n+#[test]\n+pub fn ignored_tests_result_in_ignored() {\n+    fn f() {}\n+    let desc = TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"whatever\"),\n+            ignore: true,\n+            should_panic: ShouldPanic::No,\n+            allow_fail: false,\n+        },\n+        testfn: DynTestFn(Box::new(f)),\n+    };\n+    let (tx, rx) = channel();\n+    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    let (_, res, _) = rx.recv().unwrap();\n+    assert!(res == TrIgnored);\n+}\n+\n+#[test]\n+fn test_should_panic() {\n+    fn f() {\n+        panic!();\n+    }\n+    let desc = TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"whatever\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::Yes,\n+            allow_fail: false,\n+        },\n+        testfn: DynTestFn(Box::new(f)),\n+    };\n+    let (tx, rx) = channel();\n+    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    let (_, res, _) = rx.recv().unwrap();\n+    assert!(res == TrOk);\n+}\n+\n+#[test]\n+fn test_should_panic_good_message() {\n+    fn f() {\n+        panic!(\"an error message\");\n+    }\n+    let desc = TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"whatever\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::YesWithMessage(\"error message\"),\n+            allow_fail: false,\n+        },\n+        testfn: DynTestFn(Box::new(f)),\n+    };\n+    let (tx, rx) = channel();\n+    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    let (_, res, _) = rx.recv().unwrap();\n+    assert!(res == TrOk);\n+}\n+\n+#[test]\n+fn test_should_panic_bad_message() {\n+    fn f() {\n+        panic!(\"an error message\");\n+    }\n+    let expected = \"foobar\";\n+    let failed_msg = \"panic did not include expected string\";\n+    let desc = TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"whatever\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::YesWithMessage(expected),\n+            allow_fail: false,\n+        },\n+        testfn: DynTestFn(Box::new(f)),\n+    };\n+    let (tx, rx) = channel();\n+    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    let (_, res, _) = rx.recv().unwrap();\n+    assert!(res == TrFailedMsg(format!(\"{} '{}'\", failed_msg, expected)));\n+}\n+\n+#[test]\n+fn test_should_panic_but_succeeds() {\n+    fn f() {}\n+    let desc = TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"whatever\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::Yes,\n+            allow_fail: false,\n+        },\n+        testfn: DynTestFn(Box::new(f)),\n+    };\n+    let (tx, rx) = channel();\n+    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    let (_, res, _) = rx.recv().unwrap();\n+    assert!(res == TrFailed);\n+}\n+\n+#[test]\n+fn parse_ignored_flag() {\n+    let args = vec![\n+        \"progname\".to_string(),\n+        \"filter\".to_string(),\n+        \"--ignored\".to_string(),\n+    ];\n+    let opts = parse_opts(&args).unwrap().unwrap();\n+    assert_eq!(opts.run_ignored, RunIgnored::Only);\n+}\n+\n+#[test]\n+fn parse_include_ignored_flag() {\n+    let args = vec![\n+        \"progname\".to_string(),\n+        \"filter\".to_string(),\n+        \"-Zunstable-options\".to_string(),\n+        \"--include-ignored\".to_string(),\n+    ];\n+    let opts = parse_opts(&args).unwrap().unwrap();\n+    assert_eq!(opts.run_ignored, RunIgnored::Yes);\n+}\n+\n+#[test]\n+pub fn filter_for_ignored_option() {\n+    // When we run ignored tests the test filter should filter out all the\n+    // unignored tests and flip the ignore flag on the rest to false\n+\n+    let mut opts = TestOpts::new();\n+    opts.run_tests = true;\n+    opts.run_ignored = RunIgnored::Only;\n+\n+    let tests = one_ignored_one_unignored_test();\n+    let filtered = filter_tests(&opts, tests);\n+\n+    assert_eq!(filtered.len(), 1);\n+    assert_eq!(filtered[0].desc.name.to_string(), \"1\");\n+    assert!(!filtered[0].desc.ignore);\n+}\n+\n+#[test]\n+pub fn run_include_ignored_option() {\n+    // When we \"--include-ignored\" tests, the ignore flag should be set to false on\n+    // all tests and no test filtered out\n+\n+    let mut opts = TestOpts::new();\n+    opts.run_tests = true;\n+    opts.run_ignored = RunIgnored::Yes;\n+\n+    let tests = one_ignored_one_unignored_test();\n+    let filtered = filter_tests(&opts, tests);\n+\n+    assert_eq!(filtered.len(), 2);\n+    assert!(!filtered[0].desc.ignore);\n+    assert!(!filtered[1].desc.ignore);\n+}\n+\n+#[test]\n+pub fn exclude_should_panic_option() {\n+    let mut opts = TestOpts::new();\n+    opts.run_tests = true;\n+    opts.exclude_should_panic = true;\n+\n+    let mut tests = one_ignored_one_unignored_test();\n+    tests.push(TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"3\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::Yes,\n+            allow_fail: false,\n+        },\n+        testfn: DynTestFn(Box::new(move || {})),\n+    });\n+\n+    let filtered = filter_tests(&opts, tests);\n+\n+    assert_eq!(filtered.len(), 2);\n+    assert!(filtered.iter().all(|test| test.desc.should_panic == ShouldPanic::No));\n+}\n+\n+#[test]\n+pub fn exact_filter_match() {\n+    fn tests() -> Vec<TestDescAndFn> {\n+        vec![\"base\", \"base::test\", \"base::test1\", \"base::test2\"]\n+            .into_iter()\n+            .map(|name| TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(name),\n+                    ignore: false,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            })\n+            .collect()\n+    }\n+\n+    let substr = filter_tests(\n+        &TestOpts {\n+            filter: Some(\"base\".into()),\n+            ..TestOpts::new()\n+        },\n+        tests(),\n+    );\n+    assert_eq!(substr.len(), 4);\n+\n+    let substr = filter_tests(\n+        &TestOpts {\n+            filter: Some(\"bas\".into()),\n+            ..TestOpts::new()\n+        },\n+        tests(),\n+    );\n+    assert_eq!(substr.len(), 4);\n+\n+    let substr = filter_tests(\n+        &TestOpts {\n+            filter: Some(\"::test\".into()),\n+            ..TestOpts::new()\n+        },\n+        tests(),\n+    );\n+    assert_eq!(substr.len(), 3);\n+\n+    let substr = filter_tests(\n+        &TestOpts {\n+            filter: Some(\"base::test\".into()),\n+            ..TestOpts::new()\n+        },\n+        tests(),\n+    );\n+    assert_eq!(substr.len(), 3);\n+\n+    let exact = filter_tests(\n+        &TestOpts {\n+            filter: Some(\"base\".into()),\n+            filter_exact: true,\n+            ..TestOpts::new()\n+        },\n+        tests(),\n+    );\n+    assert_eq!(exact.len(), 1);\n+\n+    let exact = filter_tests(\n+        &TestOpts {\n+            filter: Some(\"bas\".into()),\n+            filter_exact: true,\n+            ..TestOpts::new()\n+        },\n+        tests(),\n+    );\n+    assert_eq!(exact.len(), 0);\n+\n+    let exact = filter_tests(\n+        &TestOpts {\n+            filter: Some(\"::test\".into()),\n+            filter_exact: true,\n+            ..TestOpts::new()\n+        },\n+        tests(),\n+    );\n+    assert_eq!(exact.len(), 0);\n+\n+    let exact = filter_tests(\n+        &TestOpts {\n+            filter: Some(\"base::test\".into()),\n+            filter_exact: true,\n+            ..TestOpts::new()\n+        },\n+        tests(),\n+    );\n+    assert_eq!(exact.len(), 1);\n+}\n+\n+#[test]\n+pub fn sort_tests() {\n+    let mut opts = TestOpts::new();\n+    opts.run_tests = true;\n+\n+    let names = vec![\n+        \"sha1::test\".to_string(),\n+        \"isize::test_to_str\".to_string(),\n+        \"isize::test_pow\".to_string(),\n+        \"test::do_not_run_ignored_tests\".to_string(),\n+        \"test::ignored_tests_result_in_ignored\".to_string(),\n+        \"test::first_free_arg_should_be_a_filter\".to_string(),\n+        \"test::parse_ignored_flag\".to_string(),\n+        \"test::parse_include_ignored_flag\".to_string(),\n+        \"test::filter_for_ignored_option\".to_string(),\n+        \"test::run_include_ignored_option\".to_string(),\n+        \"test::sort_tests\".to_string(),\n+    ];\n+    let tests = {\n+        fn testfn() {}\n+        let mut tests = Vec::new();\n+        for name in &names {\n+            let test = TestDescAndFn {\n+                desc: TestDesc {\n+                    name: DynTestName((*name).clone()),\n+                    ignore: false,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(testfn)),\n+            };\n+            tests.push(test);\n+        }\n+        tests\n+    };\n+    let filtered = filter_tests(&opts, tests);\n+\n+    let expected = vec![\n+        \"isize::test_pow\".to_string(),\n+        \"isize::test_to_str\".to_string(),\n+        \"sha1::test\".to_string(),\n+        \"test::do_not_run_ignored_tests\".to_string(),\n+        \"test::filter_for_ignored_option\".to_string(),\n+        \"test::first_free_arg_should_be_a_filter\".to_string(),\n+        \"test::ignored_tests_result_in_ignored\".to_string(),\n+        \"test::parse_ignored_flag\".to_string(),\n+        \"test::parse_include_ignored_flag\".to_string(),\n+        \"test::run_include_ignored_option\".to_string(),\n+        \"test::sort_tests\".to_string(),\n+    ];\n+\n+    for (a, b) in expected.iter().zip(filtered) {\n+        assert!(*a == b.desc.name.to_string());\n+    }\n+}\n+\n+#[test]\n+pub fn test_metricmap_compare() {\n+    let mut m1 = MetricMap::new();\n+    let mut m2 = MetricMap::new();\n+    m1.insert_metric(\"in-both-noise\", 1000.0, 200.0);\n+    m2.insert_metric(\"in-both-noise\", 1100.0, 200.0);\n+\n+    m1.insert_metric(\"in-first-noise\", 1000.0, 2.0);\n+    m2.insert_metric(\"in-second-noise\", 1000.0, 2.0);\n+\n+    m1.insert_metric(\"in-both-want-downwards-but-regressed\", 1000.0, 10.0);\n+    m2.insert_metric(\"in-both-want-downwards-but-regressed\", 2000.0, 10.0);\n+\n+    m1.insert_metric(\"in-both-want-downwards-and-improved\", 2000.0, 10.0);\n+    m2.insert_metric(\"in-both-want-downwards-and-improved\", 1000.0, 10.0);\n+\n+    m1.insert_metric(\"in-both-want-upwards-but-regressed\", 2000.0, -10.0);\n+    m2.insert_metric(\"in-both-want-upwards-but-regressed\", 1000.0, -10.0);\n+\n+    m1.insert_metric(\"in-both-want-upwards-and-improved\", 1000.0, -10.0);\n+    m2.insert_metric(\"in-both-want-upwards-and-improved\", 2000.0, -10.0);\n+}\n+\n+#[test]\n+pub fn test_bench_once_no_iter() {\n+    fn f(_: &mut Bencher) {}\n+    bench::run_once(f);\n+}\n+\n+#[test]\n+pub fn test_bench_once_iter() {\n+    fn f(b: &mut Bencher) {\n+        b.iter(|| {})\n+    }\n+    bench::run_once(f);\n+}\n+\n+#[test]\n+pub fn test_bench_no_iter() {\n+    fn f(_: &mut Bencher) {}\n+\n+    let (tx, rx) = channel();\n+\n+    let desc = TestDesc {\n+        name: StaticTestName(\"f\"),\n+        ignore: false,\n+        should_panic: ShouldPanic::No,\n+        allow_fail: false,\n+    };\n+\n+    crate::bench::benchmark(desc, tx, true, f);\n+    rx.recv().unwrap();\n+}\n+\n+#[test]\n+pub fn test_bench_iter() {\n+    fn f(b: &mut Bencher) {\n+        b.iter(|| {})\n+    }\n+\n+    let (tx, rx) = channel();\n+\n+    let desc = TestDesc {\n+        name: StaticTestName(\"f\"),\n+        ignore: false,\n+        should_panic: ShouldPanic::No,\n+        allow_fail: false,\n+    };\n+\n+    crate::bench::benchmark(desc, tx, true, f);\n+    rx.recv().unwrap();\n+}"}]}