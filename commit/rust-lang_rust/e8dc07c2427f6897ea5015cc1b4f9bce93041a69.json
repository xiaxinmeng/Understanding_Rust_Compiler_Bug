{"sha": "e8dc07c2427f6897ea5015cc1b4f9bce93041a69", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZGMwN2MyNDI3ZjY4OTdlYTUwMTVjYzFiNGY5YmNlOTMwNDFhNjk=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-09-25T17:42:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-25T17:42:31Z"}, "message": "Rollup merge of #77005 - ssomers:btree_cleanup_3, r=Mark-Simulacrum\n\nBtreeMap: refactoring around edges\n\nParts chipped off a more daring effort, that the btree benchmarks judge to be performance-neutral.\n\nr? @Mark-Simulacrum", "tree": {"sha": "d8282385029666c0c1bcf8aabcdf07470e5ca3b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8282385029666c0c1bcf8aabcdf07470e5ca3b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8dc07c2427f6897ea5015cc1b4f9bce93041a69", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfbiwHCRBK7hj4Ov3rIwAAdHIIAHNHmrJkjP+lvhbkVga+1Z/m\n6QzVodZwLFQOEhYJ/6F0FTa2ffVEtwi/KEYi5vr6wD8IrV0EQ/UjY8tWV8XGDCpt\nvh3c//1VI/zRIUJh5AWKmC74YSW4sahhoxBCWO2fT3dtr2d239u1E+KnByjZTUz7\nYC6WKUcY3fMZ/+Yh0FmThO3oZg70vUOaPuDswUjJnc7APvKFD6YPYHqBmX6N/JnQ\nZ/CeY7tZeU/cPy3gBNbK2WooKpntP+hsO8L1hPcd2m98uZ8MveExzXhkMJ7B54f/\n3wF6nGVLEuIm1wj6TQlktjrYaUvWtgyUqYavfH6sjZ8dEUr6x//bS/rxlu3ghOM=\n=UUsv\n-----END PGP SIGNATURE-----\n", "payload": "tree d8282385029666c0c1bcf8aabcdf07470e5ca3b2\nparent 1b8c939a8d7bcfdb8e3336526927544321bc6602\nparent 55fa8afe94019cb1da29d5fab7fd7ad5795b2c39\nauthor Jonas Schievink <jonasschievink@gmail.com> 1601055751 +0200\ncommitter GitHub <noreply@github.com> 1601055751 +0200\n\nRollup merge of #77005 - ssomers:btree_cleanup_3, r=Mark-Simulacrum\n\nBtreeMap: refactoring around edges\n\nParts chipped off a more daring effort, that the btree benchmarks judge to be performance-neutral.\n\nr? @Mark-Simulacrum\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8dc07c2427f6897ea5015cc1b4f9bce93041a69", "html_url": "https://github.com/rust-lang/rust/commit/e8dc07c2427f6897ea5015cc1b4f9bce93041a69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8dc07c2427f6897ea5015cc1b4f9bce93041a69/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b8c939a8d7bcfdb8e3336526927544321bc6602", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b8c939a8d7bcfdb8e3336526927544321bc6602", "html_url": "https://github.com/rust-lang/rust/commit/1b8c939a8d7bcfdb8e3336526927544321bc6602"}, {"sha": "55fa8afe94019cb1da29d5fab7fd7ad5795b2c39", "url": "https://api.github.com/repos/rust-lang/rust/commits/55fa8afe94019cb1da29d5fab7fd7ad5795b2c39", "html_url": "https://github.com/rust-lang/rust/commit/55fa8afe94019cb1da29d5fab7fd7ad5795b2c39"}], "stats": {"total": 209, "additions": 99, "deletions": 110}, "files": [{"sha": "c3f27c105994fc81cdf046442201b345fbf5b36f", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 99, "deletions": 110, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/e8dc07c2427f6897ea5015cc1b4f9bce93041a69/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8dc07c2427f6897ea5015cc1b4f9bce93041a69/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=e8dc07c2427f6897ea5015cc1b4f9bce93041a69", "patch": "@@ -47,8 +47,7 @@ const KV_IDX_CENTER: usize = B - 1;\n const EDGE_IDX_LEFT_OF_CENTER: usize = B - 1;\n const EDGE_IDX_RIGHT_OF_CENTER: usize = B;\n \n-/// The underlying representation of leaf nodes.\n-#[repr(C)]\n+/// The underlying representation of leaf nodes and part of the representation of internal nodes.\n struct LeafNode<K, V> {\n     /// We want to be covariant in `K` and `V`.\n     parent: Option<NonNull<InternalNode<K, V>>>,\n@@ -59,9 +58,6 @@ struct LeafNode<K, V> {\n     parent_idx: MaybeUninit<u16>,\n \n     /// The number of keys and values this node stores.\n-    ///\n-    /// This next to `parent_idx` to encourage the compiler to join `len` and\n-    /// `parent_idx` into the same 32-bit word, reducing space overhead.\n     len: u16,\n \n     /// The arrays storing the actual data of the node. Only the first `len` elements of each\n@@ -92,7 +88,9 @@ impl<K, V> LeafNode<K, V> {\n /// node, allowing code to act on leaf and internal nodes generically without having to even check\n /// which of the two a pointer is pointing at. This property is enabled by the use of `repr(C)`.\n #[repr(C)]\n+// gdb_providers.py uses this type name for introspection.\n struct InternalNode<K, V> {\n+    // gdb_providers.py uses this field name for introspection.\n     data: LeafNode<K, V>,\n \n     /// The pointers to the children of this node. `len + 1` of these are considered\n@@ -183,9 +181,9 @@ impl<K, V> Root<K, V> {\n         NodeRef { height: self.height, node: self.node.as_ptr(), _marker: PhantomData }\n     }\n \n-    /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n-    /// new node the root. This increases the height by 1 and is the opposite of\n-    /// `pop_internal_level`.\n+    /// Adds a new internal node with a single edge pointing to the previous root node,\n+    /// make that new node the root node, and return it. This increases the height by 1\n+    /// and is the opposite of `pop_internal_level`.\n     pub fn push_internal_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n         new_node.edges[0].write(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n@@ -322,7 +320,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n-    /// Exposes the leaf \"portion\" of any leaf or internal node.\n+    /// Exposes the leaf portion of any leaf or internal node.\n     /// If the node is a leaf, this function simply opens up its data.\n     /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n     /// (header, keys and values), and this function exposes that.\n@@ -351,7 +349,22 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     unsafe fn val_at(&self, idx: usize) -> &V {\n         unsafe { self.reborrow().into_val_at(idx) }\n     }\n+}\n+\n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n+    /// Borrows a reference to the contents of one of the edges that delimit\n+    /// the elements of the node, without invalidating other references.\n+    ///\n+    /// # Safety\n+    /// The node has more than `idx` initialized elements.\n+    unsafe fn edge_at(&self, idx: usize) -> &BoxedNode<K, V> {\n+        debug_assert!(idx <= self.len());\n+        let node = self.as_internal_ptr();\n+        unsafe { (*node).edges.get_unchecked(idx).assume_init_ref() }\n+    }\n+}\n \n+impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Finds the parent of the current node. Returns `Ok(handle)` if the current\n     /// node actually has a parent, where `handle` points to the edge of the parent\n     /// that points to the current node. Returns `Err(self)` if the current node has\n@@ -457,7 +470,7 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n \n-    /// Exposes the leaf \"portion\" of any leaf or internal node for writing.\n+    /// Exposes the leaf portion of any leaf or internal node for writing.\n     /// If the node is a leaf, this function simply opens up its data.\n     /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n     /// (header, keys and values), and this function exposes that.\n@@ -483,18 +496,49 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         unsafe { self.reborrow_mut().into_val_mut_at(idx) }\n     }\n \n-    fn keys_mut(&mut self) -> &mut [K] {\n+    fn keys_mut(&mut self) -> &mut [K]\n+    where\n+        K: 'a,\n+        V: 'a,\n+    {\n         // SAFETY: the caller will not be able to call further methods on self\n         // until the key slice reference is dropped, as we have unique access\n         // for the lifetime of the borrow.\n-        unsafe { self.reborrow_mut().into_key_slice_mut() }\n+        // SAFETY: The keys of a node must always be initialized up to length.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().keys),\n+                self.len(),\n+            )\n+        }\n     }\n \n-    fn vals_mut(&mut self) -> &mut [V] {\n+    fn vals_mut(&mut self) -> &mut [V]\n+    where\n+        K: 'a,\n+        V: 'a,\n+    {\n         // SAFETY: the caller will not be able to call further methods on self\n         // until the value slice reference is dropped, as we have unique access\n         // for the lifetime of the borrow.\n-        unsafe { self.reborrow_mut().into_val_slice_mut() }\n+        // SAFETY: The values of a node must always be initialized up to length.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().vals),\n+                self.len(),\n+            )\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n+    fn edges_mut(&mut self) -> &mut [BoxedNode<K, V>] {\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::slice_as_mut_ptr(&mut self.as_internal_mut().edges),\n+                self.len() + 1,\n+            )\n+        }\n     }\n }\n \n@@ -513,26 +557,6 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n-    fn into_key_slice_mut(mut self) -> &'a mut [K] {\n-        // SAFETY: The keys of a node must always be initialized up to length.\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().keys),\n-                self.len(),\n-            )\n-        }\n-    }\n-\n-    fn into_val_slice_mut(mut self) -> &'a mut [V] {\n-        // SAFETY: The values of a node must always be initialized up to length.\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::slice_as_mut_ptr(&mut self.as_leaf_mut().vals),\n-                self.len(),\n-            )\n-        }\n-    }\n-\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n     unsafe fn into_key_mut_at(mut self, idx: usize) -> &'a mut K {\n@@ -584,8 +608,8 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     }\n \n     /// Adds a key/value pair to the beginning of the node.\n-    pub fn push_front(&mut self, key: K, val: V) {\n-        assert!(self.len() < CAPACITY);\n+    fn push_front(&mut self, key: K, val: V) {\n+        debug_assert!(self.len() < CAPACITY);\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -597,18 +621,17 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     /// # Safety\n-    /// 'first' and 'after_last' must be in range.\n-    unsafe fn correct_childrens_parent_links(&mut self, first: usize, after_last: usize) {\n-        debug_assert!(first <= self.len());\n-        debug_assert!(after_last <= self.len() + 1);\n-        for i in first..after_last {\n+    /// Every item returned by `range` is a valid edge index for the node.\n+    unsafe fn correct_childrens_parent_links<R: Iterator<Item = usize>>(&mut self, range: R) {\n+        for i in range {\n+            debug_assert!(i <= self.len());\n             unsafe { Handle::new_edge(self.reborrow_mut(), i) }.correct_parent_link();\n         }\n     }\n \n     fn correct_all_childrens_parent_links(&mut self) {\n         let len = self.len();\n-        unsafe { self.correct_childrens_parent_links(0, len + 1) };\n+        unsafe { self.correct_childrens_parent_links(0..=len) };\n     }\n }\n \n@@ -658,10 +681,9 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     /// Removes a key/value pair from the end of this node and returns the pair.\n     /// If this is an internal node, also removes the edge that was to the right\n-    /// of that pair and returns the orphaned node that this edge owned with its\n-    /// parent erased.\n-    pub fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n-        assert!(self.len() > 0);\n+    /// of that pair and returns the orphaned node that this edge owned.\n+    fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n+        debug_assert!(self.len() > 0);\n \n         let idx = self.len() - 1;\n \n@@ -670,9 +692,8 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n             let val = ptr::read(self.val_at(idx));\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n-                ForceResult::Internal(mut internal) => {\n-                    let edge =\n-                        ptr::read(internal.as_internal().edges.get_unchecked(idx + 1).as_ptr());\n+                ForceResult::Internal(internal) => {\n+                    let edge = ptr::read(internal.edge_at(idx + 1));\n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n                     new_root.node_as_mut().as_leaf_mut().parent = None;\n                     Some(new_root)\n@@ -684,10 +705,11 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n-    /// Removes a key/value pair from the beginning of this node. If this is an internal node,\n-    /// also removes the edge that was to the left of that pair.\n-    pub fn pop_front(&mut self) -> (K, V, Option<Root<K, V>>) {\n-        assert!(self.len() > 0);\n+    /// Removes a key/value pair from the beginning of this node and returns the pair.\n+    /// If this is an internal node, also removes the edge that was to the left\n+    /// of that pair and returns the orphaned node that this edge owned.\n+    fn pop_front(&mut self) -> (K, V, Option<Root<K, V>>) {\n+        debug_assert!(self.len() > 0);\n \n         let old_len = self.len();\n \n@@ -697,20 +719,11 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(mut internal) => {\n-                    let edge = slice_remove(\n-                        slice::from_raw_parts_mut(\n-                            MaybeUninit::slice_as_mut_ptr(&mut internal.as_internal_mut().edges),\n-                            old_len + 1,\n-                        ),\n-                        0,\n-                    );\n-\n+                    let edge = slice_remove(internal.edges_mut(), 0);\n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n                     new_root.node_as_mut().as_leaf_mut().parent = None;\n \n-                    for i in 0..old_len {\n-                        Handle::new_edge(internal.reborrow_mut(), i).correct_parent_link();\n-                    }\n+                    internal.correct_childrens_parent_links(0..old_len);\n \n                     Some(new_root)\n                 }\n@@ -898,7 +911,6 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n     /// this edge. This method assumes that there is enough space in the node for the new\n     /// pair to fit.\n     fn leafy_insert_fit(&mut self, key: K, val: V) {\n-        // Necessary for correctness, but in a private module\n         debug_assert!(self.node.len() < CAPACITY);\n \n         unsafe {\n@@ -936,18 +948,18 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n             let (middle_kv_idx, insertion) = splitpoint(self.idx);\n             let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n             let (mut left, k, v, mut right) = middle.split();\n-            let val_ptr = match insertion {\n+            let mut insertion_edge = match insertion {\n                 InsertionPlace::Left(insert_idx) => unsafe {\n-                    Handle::new_edge(left.reborrow_mut(), insert_idx).insert_fit(key, val)\n+                    Handle::new_edge(left.reborrow_mut(), insert_idx)\n                 },\n                 InsertionPlace::Right(insert_idx) => unsafe {\n                     Handle::new_edge(\n                         right.node_as_mut().cast_unchecked::<marker::Leaf>(),\n                         insert_idx,\n                     )\n-                    .insert_fit(key, val)\n                 },\n             };\n+            let val_ptr = insertion_edge.insert_fit(key, val);\n             (InsertResult::Split(SplitResult { left: left.forget_type(), k, v, right }), val_ptr)\n         }\n     }\n@@ -970,25 +982,13 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// between this edge and the key/value pair to the right of this edge. This method assumes\n     /// that there is enough space in the node for the new pair to fit.\n     fn insert_fit(&mut self, key: K, val: V, edge: Root<K, V>) {\n-        // Necessary for correctness, but in an internal module\n-        debug_assert!(self.node.len() < CAPACITY);\n         debug_assert!(edge.height == self.node.height - 1);\n \n         unsafe {\n+            slice_insert(self.node.edges_mut(), self.idx + 1, edge.node);\n             self.leafy_insert_fit(key, val);\n \n-            slice_insert(\n-                slice::from_raw_parts_mut(\n-                    MaybeUninit::slice_as_mut_ptr(&mut self.node.as_internal_mut().edges),\n-                    self.node.len(),\n-                ),\n-                self.idx + 1,\n-                edge.node,\n-            );\n-\n-            for i in (self.idx + 1)..(self.node.len() + 1) {\n-                Handle::new_edge(self.node.reborrow_mut(), i).correct_parent_link();\n-            }\n+            self.node.correct_childrens_parent_links((self.idx + 1)..=self.node.len());\n         }\n     }\n \n@@ -1131,12 +1131,12 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n \n             ptr::copy_nonoverlapping(\n                 self.node.key_at(self.idx + 1),\n-                new_node.keys.as_mut_ptr() as *mut K,\n+                MaybeUninit::slice_as_mut_ptr(&mut new_node.keys),\n                 new_len,\n             );\n             ptr::copy_nonoverlapping(\n                 self.node.val_at(self.idx + 1),\n-                new_node.vals.as_mut_ptr() as *mut V,\n+                MaybeUninit::slice_as_mut_ptr(&mut new_node.vals),\n                 new_len,\n             );\n \n@@ -1215,9 +1215,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n \n             let mut new_root = Root { node: BoxedNode::from_internal(new_node), height };\n \n-            for i in 0..(new_len + 1) {\n-                Handle::new_edge(new_root.node_as_mut().cast_unchecked(), i).correct_parent_link();\n-            }\n+            new_root.node_as_mut().cast_unchecked().correct_childrens_parent_links(0..=new_len);\n \n             (self.node, k, v, new_root)\n         }\n@@ -1260,28 +1258,25 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                 right_len,\n             );\n \n-            slice_remove(&mut self.node.as_internal_mut().edges, self.idx + 1);\n-            for i in self.idx + 1..self.node.len() {\n-                Handle::new_edge(self.node.reborrow_mut(), i).correct_parent_link();\n-            }\n+            slice_remove(&mut self.node.edges_mut(), self.idx + 1);\n+            let self_len = self.node.len();\n+            self.node.correct_childrens_parent_links(self.idx + 1..self_len);\n             self.node.as_leaf_mut().len -= 1;\n \n             left_node.as_leaf_mut().len += right_len as u16 + 1;\n \n             if self.node.height > 1 {\n                 // SAFETY: the height of the nodes being merged is one below the height\n                 // of the node of this edge, thus above zero, so they are internal.\n-                let mut left_node = left_node.cast_unchecked();\n-                let mut right_node = right_node.cast_unchecked();\n+                let mut left_node = left_node.cast_unchecked::<marker::Internal>();\n+                let right_node = right_node.cast_unchecked::<marker::Internal>();\n                 ptr::copy_nonoverlapping(\n-                    right_node.as_internal().edges.as_ptr(),\n-                    left_node.as_internal_mut().edges.as_mut_ptr().add(left_len + 1),\n+                    right_node.edge_at(0),\n+                    left_node.edges_mut().as_mut_ptr().add(left_len + 1),\n                     right_len + 1,\n                 );\n \n-                for i in left_len + 1..left_len + right_len + 2 {\n-                    Handle::new_edge(left_node.reborrow_mut(), i).correct_parent_link();\n-                }\n+                left_node.correct_childrens_parent_links(left_len + 1..=left_len + 1 + right_len);\n \n                 Global.dealloc(right_node.node.cast(), Layout::new::<InternalNode<K, V>>());\n             } else {\n@@ -1371,14 +1366,12 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                     // Make room for stolen edges.\n                     let right_edges = right.reborrow_mut().as_internal_mut().edges.as_mut_ptr();\n                     ptr::copy(right_edges, right_edges.add(count), right_len + 1);\n-                    right.correct_childrens_parent_links(count, count + right_len + 1);\n+                    right.correct_childrens_parent_links(count..count + right_len + 1);\n \n                     move_edges(left, new_left_len + 1, right, 0, count);\n                 }\n                 (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n-                _ => {\n-                    unreachable!();\n-                }\n+                _ => unreachable!(),\n             }\n         }\n     }\n@@ -1430,12 +1423,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n                     // Fix right indexing.\n                     let right_edges = right.reborrow_mut().as_internal_mut().edges.as_mut_ptr();\n                     ptr::copy(right_edges.add(count), right_edges, new_right_len + 1);\n-                    right.correct_childrens_parent_links(0, new_right_len + 1);\n+                    right.correct_childrens_parent_links(0..=new_right_len);\n                 }\n                 (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n-                _ => {\n-                    unreachable!();\n-                }\n+                _ => unreachable!(),\n             }\n         }\n     }\n@@ -1466,7 +1457,7 @@ unsafe fn move_edges<K, V>(\n     let dest_ptr = dest.as_internal_mut().edges.as_mut_ptr();\n     unsafe {\n         ptr::copy_nonoverlapping(source_ptr.add(source_offset), dest_ptr.add(dest_offset), count);\n-        dest.correct_childrens_parent_links(dest_offset, dest_offset + count);\n+        dest.correct_childrens_parent_links(dest_offset..dest_offset + count);\n     }\n }\n \n@@ -1568,9 +1559,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n                         move_edges(left, left_new_len + 1, right, 1, right_new_len);\n                     }\n                     (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n-                    _ => {\n-                        unreachable!();\n-                    }\n+                    _ => unreachable!(),\n                 }\n             }\n         }"}]}