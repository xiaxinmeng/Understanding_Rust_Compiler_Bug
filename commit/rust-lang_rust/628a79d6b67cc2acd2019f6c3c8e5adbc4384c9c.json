{"sha": "628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c", "node_id": "C_kwDOAAsO6NoAKDYyOGE3OWQ2YjY3Y2MyYWNkMjAxOWY2YzNjOGU1YWRiYzQzODRjOWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-23T15:31:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-23T15:31:46Z"}, "message": "Auto merge of #9368 - nahuakang:improve-equatable-if-let, r=flip1995\n\nImprovement for  `equatable_if_let`\n\nfixes #9221\n\nThis PR makes sure that enums or structs not implementing `PartialEq` trait but still using the `if let` patterns can be linted to be rewritten with `matches!`.\n\nIf you added a new lint, here's a checklist for things that will be\nchecked during review or continuous integration.\n\n- \\[ ] Followed [lint naming conventions][lint_naming]\n- \\[x] Added passing UI tests (including committed `.stderr` file)\n- \\[x] `cargo test` passes locally\n- \\[ ] Executed `cargo dev update_lints`\n- \\[ ] Added lint documentation\n- \\[x] Run `cargo dev fmt`\n\n---\n\nchangelog: Improve [`equatable_if_let`] with additional `matches!` suggestions.", "tree": {"sha": "0d85fe47712a6d00b2fa563d1f0cc38a97b78d6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d85fe47712a6d00b2fa563d1f0cc38a97b78d6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c", "html_url": "https://github.com/rust-lang/rust/commit/628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe57ab7c6414bbef66097c972e613492b8d95065", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe57ab7c6414bbef66097c972e613492b8d95065", "html_url": "https://github.com/rust-lang/rust/commit/fe57ab7c6414bbef66097c972e613492b8d95065"}, {"sha": "4eaadd622d21948c488a4952b3c65fd5b9d852dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eaadd622d21948c488a4952b3c65fd5b9d852dc", "html_url": "https://github.com/rust-lang/rust/commit/4eaadd622d21948c488a4952b3c65fd5b9d852dc"}], "stats": {"total": 87, "additions": 65, "deletions": 22}, "files": [{"sha": "c691e6c5402d4808fc4b0be6ec2bc2079b5c1f41", "filename": "clippy_lints/src/equatable_if_let.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c/clippy_lints%2Fsrc%2Fequatable_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c/clippy_lints%2Fsrc%2Fequatable_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fequatable_if_let.rs?ref=628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_context;\n use clippy_utils::ty::implements_trait;\n-use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -67,16 +66,14 @@ fn is_structural_partial_eq<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: T\n \n impl<'tcx> LateLintPass<'tcx> for PatternEquality {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if_chain! {\n-            if !in_external_macro(cx.sess(), expr.span);\n-            if let ExprKind::Let(let_expr) = expr.kind;\n-            if unary_pattern(let_expr.pat);\n+        if !in_external_macro(cx.sess(), expr.span)\n+            && let ExprKind::Let(let_expr) = expr.kind\n+            && unary_pattern(let_expr.pat) {\n             let exp_ty = cx.typeck_results().expr_ty(let_expr.init);\n             let pat_ty = cx.typeck_results().pat_ty(let_expr.pat);\n-            if is_structural_partial_eq(cx, exp_ty, pat_ty);\n-            then {\n+            let mut applicability = Applicability::MachineApplicable;\n \n-                let mut applicability = Applicability::MachineApplicable;\n+            if is_structural_partial_eq(cx, exp_ty, pat_ty) {\n                 let pat_str = match let_expr.pat.kind {\n                     PatKind::Struct(..) => format!(\n                         \"({})\",\n@@ -96,6 +93,20 @@ impl<'tcx> LateLintPass<'tcx> for PatternEquality {\n                     ),\n                     applicability,\n                 );\n+            } else {\n+                span_lint_and_sugg(\n+                    cx,\n+                    EQUATABLE_IF_LET,\n+                    expr.span,\n+                    \"this pattern matching can be expressed using `matches!`\",\n+                    \"try\",\n+                    format!(\n+                        \"matches!({}, {})\",\n+                        snippet_with_context(cx, let_expr.init.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n+                        snippet_with_context(cx, let_expr.pat.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n+                    ),\n+                    applicability,\n+                );\n             }\n         }\n     }"}, {"sha": "9af2ba9627200e69d1840214c16f132ec492c729", "filename": "tests/ui/equatable_if_let.fixed", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c/tests%2Fui%2Fequatable_if_let.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c/tests%2Fui%2Fequatable_if_let.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fequatable_if_let.fixed?ref=628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c", "patch": "@@ -23,6 +23,11 @@ struct Struct {\n     b: bool,\n }\n \n+struct NoPartialEqStruct {\n+    a: i32,\n+    b: bool,\n+}\n+\n enum NotPartialEq {\n     A,\n     B,\n@@ -47,6 +52,7 @@ fn main() {\n     let e = Enum::UnitVariant;\n     let f = NotPartialEq::A;\n     let g = NotStructuralEq::A;\n+    let h = NoPartialEqStruct { a: 2, b: false };\n \n     // true\n \n@@ -66,10 +72,11 @@ fn main() {\n     if let Some(3 | 4) = c {}\n     if let Struct { a, b: false } = d {}\n     if let Struct { a: 2, b: x } = d {}\n-    if let NotPartialEq::A = f {}\n+    if matches!(f, NotPartialEq::A) {}\n     if g == NotStructuralEq::A {}\n-    if let Some(NotPartialEq::A) = Some(f) {}\n+    if matches!(Some(f), Some(NotPartialEq::A)) {}\n     if Some(g) == Some(NotStructuralEq::A) {}\n+    if matches!(h, NoPartialEqStruct { a: 2, b: false }) {}\n \n     macro_rules! m1 {\n         (x) => {"}, {"sha": "c3626c081dd5e37d9c9ebc5522340473562d9954", "filename": "tests/ui/equatable_if_let.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c/tests%2Fui%2Fequatable_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c/tests%2Fui%2Fequatable_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fequatable_if_let.rs?ref=628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c", "patch": "@@ -23,6 +23,11 @@ struct Struct {\n     b: bool,\n }\n \n+struct NoPartialEqStruct {\n+    a: i32,\n+    b: bool,\n+}\n+\n enum NotPartialEq {\n     A,\n     B,\n@@ -47,6 +52,7 @@ fn main() {\n     let e = Enum::UnitVariant;\n     let f = NotPartialEq::A;\n     let g = NotStructuralEq::A;\n+    let h = NoPartialEqStruct { a: 2, b: false };\n \n     // true\n \n@@ -70,6 +76,7 @@ fn main() {\n     if let NotStructuralEq::A = g {}\n     if let Some(NotPartialEq::A) = Some(f) {}\n     if let Some(NotStructuralEq::A) = Some(g) {}\n+    if let NoPartialEqStruct { a: 2, b: false } = h {}\n \n     macro_rules! m1 {\n         (x) => {"}, {"sha": "40ca75b8da22cbdf0e1f03bd6635604706baf0c8", "filename": "tests/ui/equatable_if_let.stderr", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c/tests%2Fui%2Fequatable_if_let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c/tests%2Fui%2Fequatable_if_let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fequatable_if_let.stderr?ref=628a79d6b67cc2acd2019f6c3c8e5adbc4384c9c", "patch": "@@ -1,70 +1,88 @@\n error: this pattern matching can be expressed using equality\n-  --> $DIR/equatable_if_let.rs:53:8\n+  --> $DIR/equatable_if_let.rs:59:8\n    |\n LL |     if let 2 = a {}\n    |        ^^^^^^^^^ help: try: `a == 2`\n    |\n    = note: `-D clippy::equatable-if-let` implied by `-D warnings`\n \n error: this pattern matching can be expressed using equality\n-  --> $DIR/equatable_if_let.rs:54:8\n+  --> $DIR/equatable_if_let.rs:60:8\n    |\n LL |     if let Ordering::Greater = a.cmp(&b) {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `a.cmp(&b) == Ordering::Greater`\n \n error: this pattern matching can be expressed using equality\n-  --> $DIR/equatable_if_let.rs:55:8\n+  --> $DIR/equatable_if_let.rs:61:8\n    |\n LL |     if let Some(2) = c {}\n    |        ^^^^^^^^^^^^^^^ help: try: `c == Some(2)`\n \n error: this pattern matching can be expressed using equality\n-  --> $DIR/equatable_if_let.rs:56:8\n+  --> $DIR/equatable_if_let.rs:62:8\n    |\n LL |     if let Struct { a: 2, b: false } = d {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `d == (Struct { a: 2, b: false })`\n \n error: this pattern matching can be expressed using equality\n-  --> $DIR/equatable_if_let.rs:57:8\n+  --> $DIR/equatable_if_let.rs:63:8\n    |\n LL |     if let Enum::TupleVariant(32, 64) = e {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `e == Enum::TupleVariant(32, 64)`\n \n error: this pattern matching can be expressed using equality\n-  --> $DIR/equatable_if_let.rs:58:8\n+  --> $DIR/equatable_if_let.rs:64:8\n    |\n LL |     if let Enum::RecordVariant { a: 64, b: 32 } = e {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `e == (Enum::RecordVariant { a: 64, b: 32 })`\n \n error: this pattern matching can be expressed using equality\n-  --> $DIR/equatable_if_let.rs:59:8\n+  --> $DIR/equatable_if_let.rs:65:8\n    |\n LL |     if let Enum::UnitVariant = e {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `e == Enum::UnitVariant`\n \n error: this pattern matching can be expressed using equality\n-  --> $DIR/equatable_if_let.rs:60:8\n+  --> $DIR/equatable_if_let.rs:66:8\n    |\n LL |     if let (Enum::UnitVariant, &Struct { a: 2, b: false }) = (e, &d) {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(e, &d) == (Enum::UnitVariant, &Struct { a: 2, b: false })`\n \n+error: this pattern matching can be expressed using `matches!`\n+  --> $DIR/equatable_if_let.rs:75:8\n+   |\n+LL |     if let NotPartialEq::A = f {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `matches!(f, NotPartialEq::A)`\n+\n error: this pattern matching can be expressed using equality\n-  --> $DIR/equatable_if_let.rs:70:8\n+  --> $DIR/equatable_if_let.rs:76:8\n    |\n LL |     if let NotStructuralEq::A = g {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `g == NotStructuralEq::A`\n \n+error: this pattern matching can be expressed using `matches!`\n+  --> $DIR/equatable_if_let.rs:77:8\n+   |\n+LL |     if let Some(NotPartialEq::A) = Some(f) {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `matches!(Some(f), Some(NotPartialEq::A))`\n+\n error: this pattern matching can be expressed using equality\n-  --> $DIR/equatable_if_let.rs:72:8\n+  --> $DIR/equatable_if_let.rs:78:8\n    |\n LL |     if let Some(NotStructuralEq::A) = Some(g) {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Some(g) == Some(NotStructuralEq::A)`\n \n-error: this pattern matching can be expressed using equality\n+error: this pattern matching can be expressed using `matches!`\n   --> $DIR/equatable_if_let.rs:79:8\n    |\n+LL |     if let NoPartialEqStruct { a: 2, b: false } = h {}\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `matches!(h, NoPartialEqStruct { a: 2, b: false })`\n+\n+error: this pattern matching can be expressed using equality\n+  --> $DIR/equatable_if_let.rs:86:8\n+   |\n LL |     if let m1!(x) = \"abc\" {\n    |        ^^^^^^^^^^^^^^^^^^ help: try: `\"abc\" == m1!(x)`\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 14 previous errors\n "}]}