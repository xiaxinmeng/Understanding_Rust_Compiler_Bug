{"sha": "54129fa1132afa50afb4159673132c654244571d", "node_id": "C_kwDOAAsO6NoAKDU0MTI5ZmExMTMyYWZhNTBhZmI0MTU5NjczMTMyYzY1NDI0NDU3MWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-18T15:54:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-18T15:54:14Z"}, "message": "Auto merge of #14789 - HKalbasi:mir, r=HKalbasi\n\nAdd `moved-out-of-ref` diagnostic\n\nThis is marked as experimental, since spans are terrible, there are some false positives due #14754, and it doesn't play well with unknown types. But I hope we can soon lift it.", "tree": {"sha": "758d65ace08a4d514a7fc8e4ee9c3efaed391b4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/758d65ace08a4d514a7fc8e4ee9c3efaed391b4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54129fa1132afa50afb4159673132c654244571d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54129fa1132afa50afb4159673132c654244571d", "html_url": "https://github.com/rust-lang/rust/commit/54129fa1132afa50afb4159673132c654244571d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54129fa1132afa50afb4159673132c654244571d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09d1265e1ef428da469e6eb53b5e6e91efa70d87", "url": "https://api.github.com/repos/rust-lang/rust/commits/09d1265e1ef428da469e6eb53b5e6e91efa70d87", "html_url": "https://github.com/rust-lang/rust/commit/09d1265e1ef428da469e6eb53b5e6e91efa70d87"}, {"sha": "b55fbd3ad7eea6492815c0cc1e3c6adf0ebf246c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b55fbd3ad7eea6492815c0cc1e3c6adf0ebf246c", "html_url": "https://github.com/rust-lang/rust/commit/b55fbd3ad7eea6492815c0cc1e3c6adf0ebf246c"}], "stats": {"total": 362, "additions": 352, "deletions": 10}, "files": [{"sha": "b800c2e32a9d596a334134d23c3f5c7636da49e2", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/54129fa1132afa50afb4159673132c654244571d/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54129fa1132afa50afb4159673132c654244571d/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=54129fa1132afa50afb4159673132c654244571d", "patch": "@@ -934,7 +934,18 @@ impl<'a> InferenceContext<'a> {\n         match fn_x {\n             FnTrait::FnOnce => (),\n             FnTrait::FnMut => {\n-                if !matches!(derefed_callee.kind(Interner), TyKind::Ref(Mutability::Mut, _, _)) {\n+                if let TyKind::Ref(Mutability::Mut, _, inner) = derefed_callee.kind(Interner) {\n+                    if adjustments\n+                        .last()\n+                        .map(|x| matches!(x.kind, Adjust::Borrow(_)))\n+                        .unwrap_or(true)\n+                    {\n+                        // prefer reborrow to move\n+                        adjustments\n+                            .push(Adjustment { kind: Adjust::Deref(None), target: inner.clone() });\n+                        adjustments.push(Adjustment::borrow(Mutability::Mut, inner.clone()))\n+                    }\n+                } else {\n                     adjustments.push(Adjustment::borrow(Mutability::Mut, derefed_callee.clone()));\n                 }\n             }"}, {"sha": "412390d3fa1d430c236bc4f717a72473683465fe", "filename": "crates/hir-ty/src/mir/borrowck.rs", "status": "modified", "additions": 115, "deletions": 3, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/54129fa1132afa50afb4159673132c654244571d/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54129fa1132afa50afb4159673132c654244571d/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs?ref=54129fa1132afa50afb4159673132c654244571d", "patch": "@@ -5,12 +5,14 @@\n \n use std::iter;\n \n-use hir_def::DefWithBodyId;\n+use hir_def::{DefWithBodyId, HasModule};\n use la_arena::ArenaMap;\n use stdx::never;\n use triomphe::Arc;\n \n-use crate::{db::HirDatabase, ClosureId};\n+use crate::{\n+    db::HirDatabase, mir::Operand, utils::ClosureSubst, ClosureId, Interner, Ty, TyExt, TypeFlags,\n+};\n \n use super::{\n     BasicBlockId, BorrowKind, LocalId, MirBody, MirLowerError, MirSpan, Place, ProjectionElem,\n@@ -24,10 +26,17 @@ pub enum MutabilityReason {\n     Not,\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct MovedOutOfRef {\n+    pub ty: Ty,\n+    pub span: MirSpan,\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct BorrowckResult {\n     pub mir_body: Arc<MirBody>,\n     pub mutability_of_locals: ArenaMap<LocalId, MutabilityReason>,\n+    pub moved_out_of_ref: Vec<MovedOutOfRef>,\n }\n \n fn all_mir_bodies(\n@@ -68,12 +77,115 @@ pub fn borrowck_query(\n     let r = all_mir_bodies(db, def)\n         .map(|body| {\n             let body = body?;\n-            Ok(BorrowckResult { mutability_of_locals: mutability_of_locals(&body), mir_body: body })\n+            Ok(BorrowckResult {\n+                mutability_of_locals: mutability_of_locals(&body),\n+                moved_out_of_ref: moved_out_of_ref(db, &body),\n+                mir_body: body,\n+            })\n         })\n         .collect::<Result<Vec<_>, MirLowerError>>()?;\n     Ok(r.into())\n }\n \n+fn moved_out_of_ref(db: &dyn HirDatabase, body: &MirBody) -> Vec<MovedOutOfRef> {\n+    let mut result = vec![];\n+    let mut for_operand = |op: &Operand, span: MirSpan| match op {\n+        Operand::Copy(p) | Operand::Move(p) => {\n+            let mut ty: Ty = body.locals[p.local].ty.clone();\n+            let mut is_dereference_of_ref = false;\n+            for proj in &p.projection {\n+                if *proj == ProjectionElem::Deref && ty.as_reference().is_some() {\n+                    is_dereference_of_ref = true;\n+                }\n+                ty = proj.projected_ty(\n+                    ty,\n+                    db,\n+                    |c, subst, f| {\n+                        let (def, _) = db.lookup_intern_closure(c.into());\n+                        let infer = db.infer(def);\n+                        let (captures, _) = infer.closure_info(&c);\n+                        let parent_subst = ClosureSubst(subst).parent_subst();\n+                        captures\n+                            .get(f)\n+                            .expect(\"broken closure field\")\n+                            .ty\n+                            .clone()\n+                            .substitute(Interner, parent_subst)\n+                    },\n+                    body.owner.module(db.upcast()).krate(),\n+                );\n+            }\n+            if is_dereference_of_ref\n+                && !ty.clone().is_copy(db, body.owner)\n+                && !ty.data(Interner).flags.intersects(TypeFlags::HAS_ERROR)\n+            {\n+                result.push(MovedOutOfRef { span, ty });\n+            }\n+        }\n+        Operand::Constant(_) | Operand::Static(_) => (),\n+    };\n+    for (_, block) in body.basic_blocks.iter() {\n+        for statement in &block.statements {\n+            match &statement.kind {\n+                StatementKind::Assign(_, r) => match r {\n+                    Rvalue::ShallowInitBoxWithAlloc(_) => (),\n+                    Rvalue::ShallowInitBox(o, _)\n+                    | Rvalue::UnaryOp(_, o)\n+                    | Rvalue::Cast(_, o, _)\n+                    | Rvalue::Repeat(o, _)\n+                    | Rvalue::Use(o) => for_operand(o, statement.span),\n+                    Rvalue::CopyForDeref(_)\n+                    | Rvalue::Discriminant(_)\n+                    | Rvalue::Len(_)\n+                    | Rvalue::Ref(_, _) => (),\n+                    Rvalue::CheckedBinaryOp(_, o1, o2) => {\n+                        for_operand(o1, statement.span);\n+                        for_operand(o2, statement.span);\n+                    }\n+                    Rvalue::Aggregate(_, ops) => {\n+                        for op in ops {\n+                            for_operand(op, statement.span);\n+                        }\n+                    }\n+                },\n+                StatementKind::Deinit(_)\n+                | StatementKind::StorageLive(_)\n+                | StatementKind::StorageDead(_)\n+                | StatementKind::Nop => (),\n+            }\n+        }\n+        match &block.terminator {\n+            Some(terminator) => match &terminator.kind {\n+                TerminatorKind::SwitchInt { discr, .. } => for_operand(discr, terminator.span),\n+                TerminatorKind::FalseEdge { .. }\n+                | TerminatorKind::FalseUnwind { .. }\n+                | TerminatorKind::Goto { .. }\n+                | TerminatorKind::Resume\n+                | TerminatorKind::GeneratorDrop\n+                | TerminatorKind::Abort\n+                | TerminatorKind::Return\n+                | TerminatorKind::Unreachable\n+                | TerminatorKind::Drop { .. } => (),\n+                TerminatorKind::DropAndReplace { value, .. } => {\n+                    for_operand(value, terminator.span);\n+                }\n+                TerminatorKind::Call { func, args, .. } => {\n+                    for_operand(func, terminator.span);\n+                    args.iter().for_each(|x| for_operand(x, terminator.span));\n+                }\n+                TerminatorKind::Assert { cond, .. } => {\n+                    for_operand(cond, terminator.span);\n+                }\n+                TerminatorKind::Yield { value, .. } => {\n+                    for_operand(value, terminator.span);\n+                }\n+            },\n+            None => (),\n+        }\n+    }\n+    result\n+}\n+\n fn is_place_direct(lvalue: &Place) -> bool {\n     !lvalue.projection.iter().any(|x| *x == ProjectionElem::Deref)\n }"}, {"sha": "10893b62bfb5720eb4c77dba80c93722636e1cc3", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/54129fa1132afa50afb4159673132c654244571d/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54129fa1132afa50afb4159673132c654244571d/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=54129fa1132afa50afb4159673132c654244571d", "patch": "@@ -46,6 +46,7 @@ diagnostics![\n     MissingFields,\n     MissingMatchArms,\n     MissingUnsafe,\n+    MovedOutOfRef,\n     NeedMut,\n     NoSuchField,\n     PrivateAssocItem,\n@@ -252,3 +253,9 @@ pub struct NeedMut {\n pub struct UnusedMut {\n     pub local: Local,\n }\n+\n+#[derive(Debug)]\n+pub struct MovedOutOfRef {\n+    pub ty: Type,\n+    pub span: InFile<SyntaxNodePtr>,\n+}"}, {"sha": "bc925552f34a5b5d6bdf9b170c42577239026bdc", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/54129fa1132afa50afb4159673132c654244571d/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54129fa1132afa50afb4159673132c654244571d/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=54129fa1132afa50afb4159673132c654244571d", "patch": "@@ -90,10 +90,11 @@ pub use crate::{\n         AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncoherentImpl,\n         IncorrectCase, InvalidDeriveTarget, MacroDefError, MacroError, MacroExpansionParseError,\n         MalformedDerive, MismatchedArgCount, MissingFields, MissingMatchArms, MissingUnsafe,\n-        NeedMut, NoSuchField, PrivateAssocItem, PrivateField, ReplaceFilterMapNextWithFindMap,\n-        TypeMismatch, UndeclaredLabel, UnimplementedBuiltinMacro, UnreachableLabel,\n-        UnresolvedExternCrate, UnresolvedField, UnresolvedImport, UnresolvedMacroCall,\n-        UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro, UnusedMut,\n+        MovedOutOfRef, NeedMut, NoSuchField, PrivateAssocItem, PrivateField,\n+        ReplaceFilterMapNextWithFindMap, TypeMismatch, UndeclaredLabel, UnimplementedBuiltinMacro,\n+        UnreachableLabel, UnresolvedExternCrate, UnresolvedField, UnresolvedImport,\n+        UnresolvedMacroCall, UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro,\n+        UnusedMut,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -1575,6 +1576,26 @@ impl DefWithBody {\n         if let Ok(borrowck_results) = db.borrowck(self.into()) {\n             for borrowck_result in borrowck_results.iter() {\n                 let mir_body = &borrowck_result.mir_body;\n+                for moof in &borrowck_result.moved_out_of_ref {\n+                    let span: InFile<SyntaxNodePtr> = match moof.span {\n+                        mir::MirSpan::ExprId(e) => match source_map.expr_syntax(e) {\n+                            Ok(s) => s.map(|x| x.into()),\n+                            Err(_) => continue,\n+                        },\n+                        mir::MirSpan::PatId(p) => match source_map.pat_syntax(p) {\n+                            Ok(s) => s.map(|x| match x {\n+                                Either::Left(e) => e.into(),\n+                                Either::Right(e) => e.into(),\n+                            }),\n+                            Err(_) => continue,\n+                        },\n+                        mir::MirSpan::Unknown => continue,\n+                    };\n+                    acc.push(\n+                        MovedOutOfRef { ty: Type::new_for_crate(krate, moof.ty.clone()), span }\n+                            .into(),\n+                    )\n+                }\n                 let mol = &borrowck_result.mutability_of_locals;\n                 for (binding_id, _) in hir_body.bindings.iter() {\n                     let Some(&local) = mir_body.binding_locals.get(binding_id) else {"}, {"sha": "3f13b97a44734271ec070f02e38f06c238b28c40", "filename": "crates/ide-diagnostics/src/handlers/missing_match_arms.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54129fa1132afa50afb4159673132c654244571d/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54129fa1132afa50afb4159673132c654244571d/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs?ref=54129fa1132afa50afb4159673132c654244571d", "patch": "@@ -1027,6 +1027,7 @@ fn main() {\n \n             check_diagnostics(\n                 r#\"\n+//- minicore: copy\n fn main() {\n     match &false {\n         &true => {}\n@@ -1041,6 +1042,7 @@ fn main() {\n             cov_mark::check_count!(validate_match_bailed_out, 1);\n             check_diagnostics(\n                 r#\"\n+//- minicore: copy\n fn main() {\n     match (&false,) {\n         //^^^^^^^^^ error: missing match arm: `(&false,)` not covered"}, {"sha": "2026b6fcef537132ea3728cfc4d921965a862931", "filename": "crates/ide-diagnostics/src/handlers/missing_unsafe.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/54129fa1132afa50afb4159673132c654244571d/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54129fa1132afa50afb4159673132c654244571d/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs?ref=54129fa1132afa50afb4159673132c654244571d", "patch": "@@ -142,6 +142,8 @@ fn main() {\n     fn missing_unsafe_diagnostic_with_static_mut() {\n         check_diagnostics(\n             r#\"\n+//- minicore: copy\n+\n struct Ty {\n     a: u8,\n }\n@@ -256,6 +258,7 @@ fn main() {\n     fn add_unsafe_block_when_accessing_mutable_static() {\n         check_fix(\n             r#\"\n+//- minicore: copy\n struct Ty {\n     a: u8,\n }\n@@ -374,6 +377,7 @@ fn main() {\n     fn unsafe_expr_as_right_hand_side_of_assignment() {\n         check_fix(\n             r#\"\n+//- minicore: copy\n static mut STATIC_MUT: u8 = 0;\n \n fn main() {\n@@ -396,6 +400,7 @@ fn main() {\n     fn unsafe_expr_in_binary_plus() {\n         check_fix(\n             r#\"\n+//- minicore: copy\n static mut STATIC_MUT: u8 = 0;\n \n fn main() {"}, {"sha": "99243a5ab86776a75bd18831bbff13817c566653", "filename": "crates/ide-diagnostics/src/handlers/moved_out_of_ref.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/54129fa1132afa50afb4159673132c654244571d/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmoved_out_of_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54129fa1132afa50afb4159673132c654244571d/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmoved_out_of_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmoved_out_of_ref.rs?ref=54129fa1132afa50afb4159673132c654244571d", "patch": "@@ -0,0 +1,154 @@\n+use crate::{Diagnostic, DiagnosticsContext};\n+use hir::HirDisplay;\n+\n+// Diagnostic: moved-out-of-ref\n+//\n+// This diagnostic is triggered on moving non copy things out of references.\n+pub(crate) fn moved_out_of_ref(ctx: &DiagnosticsContext<'_>, d: &hir::MovedOutOfRef) -> Diagnostic {\n+    Diagnostic::new(\n+        \"moved-out-of-ref\",\n+        format!(\"cannot move `{}` out of reference\", d.ty.display(ctx.sema.db)),\n+        ctx.sema.diagnostics_display_range(d.span.clone()).range,\n+    )\n+    .experimental() // spans are broken, and I'm not sure how precise we can detect copy types\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    // FIXME: spans are broken\n+\n+    #[test]\n+    fn move_by_explicit_deref() {\n+        check_diagnostics(\n+            r#\"\n+struct X;\n+fn main() {\n+    let a = &X;\n+    let b = *a;\n+      //^ error: cannot move `X` out of reference\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn move_out_of_field() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: copy\n+struct X;\n+struct Y(X, i32);\n+fn main() {\n+    let a = &Y(X, 5);\n+    let b = a.0;\n+      //^ error: cannot move `X` out of reference\n+    let y = a.1;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn move_out_of_static() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: copy\n+struct X;\n+fn main() {\n+    static S: X = X;\n+    let s = S;\n+      //^ error: cannot move `X` out of reference\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn generic_types() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: derive, copy\n+\n+#[derive(Copy)]\n+struct X<T>(T);\n+struct Y;\n+\n+fn consume<T>(_: X<T>) {\n+\n+}\n+\n+fn main() {\n+    let a = &X(Y);\n+    consume(*a);\n+  //^^^^^^^^^^^ error: cannot move `X<Y>` out of reference\n+    let a = &X(5);\n+    consume(*a);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_false_positive_simple() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: copy\n+fn f(_: i32) {}\n+fn main() {\n+    let x = &2;\n+    f(*x);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_false_positive_unknown_type() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: derive, copy\n+fn f(x: &Unknown) -> Unknown {\n+    *x\n+}\n+\n+#[derive(Copy)]\n+struct X<T>(T);\n+\n+struct Y<T>(T);\n+\n+fn g(x: &X<Unknown>) -> X<Unknown> {\n+    *x\n+}\n+\n+fn h(x: &Y<Unknown>) -> Y<Unknown> {\n+    // FIXME: we should show error for this, as `Y` is not copy\n+    // regardless of its generic parameter.\n+    *x\n+}\n+\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_false_positive_dyn_fn() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: copy, fn\n+fn f(x: &mut &mut dyn Fn()) {\n+    x();\n+}\n+\n+struct X<'a> {\n+    field: &'a mut dyn Fn(),\n+}\n+\n+fn f(x: &mut X<'_>) {\n+    (x.field)();\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "9d6a862cb11929282d1a06d45034b09cf937e62a", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/54129fa1132afa50afb4159673132c654244571d/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54129fa1132afa50afb4159673132c654244571d/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=54129fa1132afa50afb4159673132c654244571d", "patch": "@@ -340,6 +340,7 @@ fn main() {\n     fn regression_14310() {\n         check_diagnostics(\n             r#\"\n+            //- minicore: copy, builtin_impls\n             fn clone(mut i: &!) -> ! {\n                    //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n                 *i"}, {"sha": "048dedf6bd15e4ed7c63deb7ab02713016092f80", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54129fa1132afa50afb4159673132c654244571d/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54129fa1132afa50afb4159673132c654244571d/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=54129fa1132afa50afb4159673132c654244571d", "patch": "@@ -38,6 +38,7 @@ mod handlers {\n     pub(crate) mod missing_fields;\n     pub(crate) mod missing_match_arms;\n     pub(crate) mod missing_unsafe;\n+    pub(crate) mod moved_out_of_ref;\n     pub(crate) mod mutability_errors;\n     pub(crate) mod no_such_field;\n     pub(crate) mod private_assoc_item;\n@@ -283,6 +284,7 @@ pub fn diagnostics(\n             AnyDiagnostic::MissingFields(d) => handlers::missing_fields::missing_fields(&ctx, &d),\n             AnyDiagnostic::MissingMatchArms(d) => handlers::missing_match_arms::missing_match_arms(&ctx, &d),\n             AnyDiagnostic::MissingUnsafe(d) => handlers::missing_unsafe::missing_unsafe(&ctx, &d),\n+            AnyDiagnostic::MovedOutOfRef(d) => handlers::moved_out_of_ref::moved_out_of_ref(&ctx, &d),\n             AnyDiagnostic::NeedMut(d) => handlers::mutability_errors::need_mut(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => handlers::no_such_field::no_such_field(&ctx, &d),\n             AnyDiagnostic::PrivateAssocItem(d) => handlers::private_assoc_item::private_assoc_item(&ctx, &d),"}, {"sha": "b5cd4e0d68911edb19c6d2f2c0677af030a2c836", "filename": "crates/ide-diagnostics/src/tests.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/54129fa1132afa50afb4159673132c654244571d/crates%2Fide-diagnostics%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54129fa1132afa50afb4159673132c654244571d/crates%2Fide-diagnostics%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Ftests.rs?ref=54129fa1132afa50afb4159673132c654244571d", "patch": "@@ -121,6 +121,15 @@ pub(crate) fn check_diagnostics_with_config(config: DiagnosticsConfig, ra_fixtur\n             })\n             .collect::<Vec<_>>();\n         actual.sort_by_key(|(range, _)| range.start());\n+        if expected.is_empty() {\n+            // makes minicore smoke test debugable\n+            for (e, _) in &actual {\n+                eprintln!(\n+                    \"Code in range {e:?} = {}\",\n+                    &db.file_text(file_id)[usize::from(e.start())..usize::from(e.end())]\n+                )\n+            }\n+        }\n         assert_eq!(expected, actual);\n     }\n }\n@@ -156,6 +165,11 @@ fn minicore_smoke_test() {\n \n     // Checks that there is no diagnostic in minicore for each flag.\n     for flag in MiniCore::available_flags() {\n+        if flag == \"clone\" {\n+            // Clone without copy has `moved-out-of-ref`, so ignoring.\n+            // FIXME: Maybe we should merge copy and clone in a single flag?\n+            continue;\n+        }\n         eprintln!(\"Checking minicore flag {flag}\");\n         check(MiniCore::from_flags([flag]));\n     }"}, {"sha": "6d6c9af7f046268a71818a4f182aa02bc60fb87a", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/54129fa1132afa50afb4159673132c654244571d/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54129fa1132afa50afb4159673132c654244571d/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=54129fa1132afa50afb4159673132c654244571d", "patch": "@@ -111,6 +111,7 @@ pub mod marker {\n         impl<T: ?Sized> Copy for *const T {}\n         impl<T: ?Sized> Copy for *mut T {}\n         impl<T: ?Sized> Copy for &T {}\n+        impl Copy for ! {}\n     }\n     // endregion:copy\n \n@@ -246,6 +247,12 @@ pub mod clone {\n         f32 f64\n         bool char\n     }\n+\n+    impl Clone for ! {\n+        fn clone(&self) {\n+            *self\n+        }\n+    }\n     // endregion:builtin_impls\n \n     // region:derive\n@@ -319,8 +326,8 @@ pub mod mem {\n     pub fn drop<T>(_x: T) {}\n     pub const fn replace<T>(dest: &mut T, src: T) -> T {\n         unsafe {\n-            let result = *dest;\n-            *dest = src;\n+            let result = crate::ptr::read(dest);\n+            crate::ptr::write(dest, src);\n             result\n         }\n     }\n@@ -339,6 +346,12 @@ pub mod ptr {\n     pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n         unsafe { drop_in_place(to_drop) }\n     }\n+    pub const unsafe fn read<T>(src: *const T) -> T {\n+        *src\n+    }\n+    pub const unsafe fn write<T>(dst: *mut T, src: T) {\n+        *dst = src;\n+    }\n     // endregion:drop\n }\n "}]}