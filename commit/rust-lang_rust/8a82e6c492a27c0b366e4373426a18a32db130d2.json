{"sha": "8a82e6c492a27c0b366e4373426a18a32db130d2", "node_id": "C_kwDOAAsO6NoAKDhhODJlNmM0OTJhMjdjMGIzNjZlNDM3MzQyNmExOGEzMmRiMTMwZDI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-22T15:23:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-22T15:23:23Z"}, "message": "Merge #10284\n\n10284: internal: definition based hover functions r=Veykril a=HKalbasi\n\nThis is part of #10181 but since it is blocked and `hover.rs` is moving quickly so will cause conflicts, I submitted this PR.\r\n\r\nThis PR extract some parts of `hover` to `find_definition` (maybe this need to be moved to some other file?) and `hover_for_definition`, with those functions I will be able to calculate definition of every token, and calculate hover (and probably other queries) for each definition only once.\n\nCo-authored-by: hamidreza kalbasi <hamidrezakalbasi@protonmail.com>", "tree": {"sha": "eea57006eb3ef36eeab8685efcba1cc80991172f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eea57006eb3ef36eeab8685efcba1cc80991172f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a82e6c492a27c0b366e4373426a18a32db130d2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhS0prCRBK7hj4Ov3rIwAAImcIAHmxXaW/NPlyjUXnowmGc/HE\nSpVZrpV7c3O+gL8MgtMzQhWrmr+xpbIIzBkIniqm7/1ekAbjjLVY1tohuDDWSn+E\n5DUdDUDjJaqlGf6s706RM/3/d6nLrPrbRPJHeqk0JKo+ZVnGsCGP/8hQfKPvAhnY\nUscWeO9umCXwub32g1UchHHgGyCxIK9HteIAyleIZaqCfpv4Y6I7fGKlxZcBZCBC\nRmx3o8H10DHDQvLHm6SqmrfwpaIgnV5tbtuIlxOeq5HUV7ink1ow0tlY+uJcaOMs\nE4794AjIwjuk5M9fPzRMQ69DXW8kzZQ28E3+RJhe5XAdRFawDFhmnecFCdHgzHk=\n=PezI\n-----END PGP SIGNATURE-----\n", "payload": "tree eea57006eb3ef36eeab8685efcba1cc80991172f\nparent 6b77e320f038beabb7adf1ec34b87292419fc695\nparent 589c1dfa04bbb4429223c810c2fefc2f12beb6cd\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1632324203 +0000\ncommitter GitHub <noreply@github.com> 1632324203 +0000\n\nMerge #10284\n\n10284: internal: definition based hover functions r=Veykril a=HKalbasi\n\nThis is part of #10181 but since it is blocked and `hover.rs` is moving quickly so will cause conflicts, I submitted this PR.\r\n\r\nThis PR extract some parts of `hover` to `find_definition` (maybe this need to be moved to some other file?) and `hover_for_definition`, with those functions I will be able to calculate definition of every token, and calculate hover (and probably other queries) for each definition only once.\n\nCo-authored-by: hamidreza kalbasi <hamidrezakalbasi@protonmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a82e6c492a27c0b366e4373426a18a32db130d2", "html_url": "https://github.com/rust-lang/rust/commit/8a82e6c492a27c0b366e4373426a18a32db130d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a82e6c492a27c0b366e4373426a18a32db130d2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b77e320f038beabb7adf1ec34b87292419fc695", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b77e320f038beabb7adf1ec34b87292419fc695", "html_url": "https://github.com/rust-lang/rust/commit/6b77e320f038beabb7adf1ec34b87292419fc695"}, {"sha": "589c1dfa04bbb4429223c810c2fefc2f12beb6cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/589c1dfa04bbb4429223c810c2fefc2f12beb6cd", "html_url": "https://github.com/rust-lang/rust/commit/589c1dfa04bbb4429223c810c2fefc2f12beb6cd"}], "stats": {"total": 436, "additions": 236, "deletions": 200}, "files": [{"sha": "4c01231f4a2b5aeb3329294d8265355f254d5ff2", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 44, "deletions": 100, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/8a82e6c492a27c0b366e4373426a18a32db130d2/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a82e6c492a27c0b366e4373426a18a32db130d2/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=8a82e6c492a27c0b366e4373426a18a32db130d2", "patch": "@@ -1,21 +1,19 @@\n-use std::{convert::TryInto, iter};\n+use std::convert::TryInto;\n \n-use either::Either;\n+use crate::{\n+    display::TryToNav,\n+    doc_links::{doc_attributes, extract_definitions_from_docs, resolve_doc_path_for_def},\n+    FilePosition, NavigationTarget, RangeInfo,\n+};\n use hir::{AsAssocItem, InFile, ModuleDef, Semantics};\n use ide_db::{\n     base_db::{AnchoredPath, FileId, FileLoader},\n-    defs::{Definition, NameClass, NameRefClass},\n-    helpers::{pick_best_token, try_resolve_derive_input_at},\n+    defs::Definition,\n+    helpers::pick_best_token,\n     RootDatabase,\n };\n use itertools::Itertools;\n-use syntax::{ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, TextRange, T};\n-\n-use crate::{\n-    display::{ToNav, TryToNav},\n-    doc_links::{doc_attributes, extract_definitions_from_docs, resolve_doc_path_for_def},\n-    FilePosition, NavigationTarget, RangeInfo,\n-};\n+use syntax::{ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, TextRange, T};\n \n // Feature: Go to Definition\n //\n@@ -58,39 +56,22 @@ pub(crate) fn goto_definition(\n         .into_iter()\n         .filter_map(|token| {\n             let parent = token.parent()?;\n-            let navs = match_ast! {\n-                match parent {\n-                    ast::NameRef(name_ref) => {\n-                        reference_definition(&sema, Either::Right(&name_ref))\n-                    },\n-                    ast::Name(name) => {\n-                        match NameClass::classify(&sema, &name)? {\n-                            NameClass::Definition(def) | NameClass::ConstReference(def) => {\n-                                try_find_trait_item_definition(sema.db, &def)\n-                                    .unwrap_or_else(|| def_to_nav(sema.db, def))\n-                            }\n-                            NameClass::PatFieldShorthand { local_def, field_ref } => {\n-                                local_and_field_to_nav(sema.db, local_def, field_ref)\n-                            },\n-                        }\n-                    },\n-                    ast::Lifetime(lt) => {\n-                        match NameClass::classify_lifetime(&sema, &lt) {\n-                            Some(name_class) => {\n-                                match name_class {\n-                                    NameClass::Definition(def) => def_to_nav(sema.db, def),\n-                                    _ => return None,\n-                                }\n-                            }\n-                            None => reference_definition(&sema, Either::Left(&lt)),\n-                        }\n-                    },\n-                    ast::TokenTree(tt) =>\n-                        try_lookup_include_path_or_derive(&sema, tt, token, position.file_id)?,\n-                    _ => return None,\n+            if let Some(tt) = ast::TokenTree::cast(parent.clone()) {\n+                if let x @ Some(_) =\n+                    try_lookup_include_path(&sema, tt, token.clone(), position.file_id)\n+                {\n+                    return x;\n                 }\n-            };\n-            Some(navs)\n+            }\n+            Some(\n+                Definition::from_node(&sema, &token)\n+                    .into_iter()\n+                    .flat_map(|def| {\n+                        try_find_trait_item_definition(sema.db, &def)\n+                            .unwrap_or_else(|| def_to_nav(sema.db, def))\n+                    })\n+                    .collect::<Vec<_>>(),\n+            )\n         })\n         .flatten()\n         .unique()\n@@ -99,41 +80,31 @@ pub(crate) fn goto_definition(\n     Some(RangeInfo::new(original_token.text_range(), navs))\n }\n \n-fn try_lookup_include_path_or_derive(\n+fn try_lookup_include_path(\n     sema: &Semantics<RootDatabase>,\n     tt: ast::TokenTree,\n     token: SyntaxToken,\n     file_id: FileId,\n ) -> Option<Vec<NavigationTarget>> {\n-    match ast::String::cast(token.clone()) {\n-        Some(token) => {\n-            let path = token.value()?.into_owned();\n-            let macro_call = tt.syntax().parent().and_then(ast::MacroCall::cast)?;\n-            let name = macro_call.path()?.segment()?.name_ref()?;\n-            if !matches!(&*name.text(), \"include\" | \"include_str\" | \"include_bytes\") {\n-                return None;\n-            }\n-            let file_id = sema.db.resolve_path(AnchoredPath { anchor: file_id, path: &path })?;\n-            let size = sema.db.file_text(file_id).len().try_into().ok()?;\n-            Some(vec![NavigationTarget {\n-                file_id,\n-                full_range: TextRange::new(0.into(), size),\n-                name: path.into(),\n-                focus_range: None,\n-                kind: None,\n-                container_name: None,\n-                description: None,\n-                docs: None,\n-            }])\n-        }\n-        None => try_resolve_derive_input_at(\n-            sema,\n-            &tt.syntax().ancestors().nth(2).and_then(ast::Attr::cast)?,\n-            &token,\n-        )\n-        .and_then(|it| it.try_to_nav(sema.db))\n-        .map(|it| vec![it]),\n-    }\n+    let token = ast::String::cast(token.clone())?;\n+    let path = token.value()?.into_owned();\n+    let macro_call = tt.syntax().parent().and_then(ast::MacroCall::cast)?;\n+    let name = macro_call.path()?.segment()?.name_ref()?;\n+    if !matches!(&*name.text(), \"include\" | \"include_str\" | \"include_bytes\") {\n+        return None;\n+    }\n+    let file_id = sema.db.resolve_path(AnchoredPath { anchor: file_id, path: &path })?;\n+    let size = sema.db.file_text(file_id).len().try_into().ok()?;\n+    Some(vec![NavigationTarget {\n+        file_id,\n+        full_range: TextRange::new(0.into(), size),\n+        name: path.into(),\n+        focus_range: None,\n+        kind: None,\n+        container_name: None,\n+        description: None,\n+        docs: None,\n+    }])\n }\n \n /// finds the trait definition of an impl'd item\n@@ -168,37 +139,10 @@ fn try_find_trait_item_definition(\n         .map(|it| vec![it])\n }\n \n-pub(crate) fn reference_definition(\n-    sema: &Semantics<RootDatabase>,\n-    name_ref: Either<&ast::Lifetime, &ast::NameRef>,\n-) -> Vec<NavigationTarget> {\n-    let name_kind = match name_ref.either(\n-        |lifetime| NameRefClass::classify_lifetime(sema, lifetime),\n-        |name_ref| NameRefClass::classify(sema, name_ref),\n-    ) {\n-        Some(class) => class,\n-        None => return Vec::new(),\n-    };\n-    match name_kind {\n-        NameRefClass::Definition(def) => def_to_nav(sema.db, def),\n-        NameRefClass::FieldShorthand { local_ref, field_ref } => {\n-            local_and_field_to_nav(sema.db, local_ref, field_ref)\n-        }\n-    }\n-}\n-\n fn def_to_nav(db: &RootDatabase, def: Definition) -> Vec<NavigationTarget> {\n     def.try_to_nav(db).map(|it| vec![it]).unwrap_or_default()\n }\n \n-fn local_and_field_to_nav(\n-    db: &RootDatabase,\n-    local: hir::Local,\n-    field: hir::Field,\n-) -> Vec<NavigationTarget> {\n-    iter::once(local.to_nav(db)).chain(field.try_to_nav(db)).collect()\n-}\n-\n #[cfg(test)]\n mod tests {\n     use ide_db::base_db::FileRange;"}, {"sha": "80e91f303cd1358019312731e16fd973a9702042", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 134, "deletions": 98, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/8a82e6c492a27c0b366e4373426a18a32db130d2/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a82e6c492a27c0b366e4373426a18a32db130d2/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=8a82e6c492a27c0b366e4373426a18a32db130d2", "patch": "@@ -4,10 +4,10 @@ use either::Either;\n use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo};\n use ide_db::{\n     base_db::{FileRange, SourceDatabase},\n-    defs::{Definition, NameClass, NameRefClass},\n+    defs::Definition,\n     helpers::{\n         generated_lints::{CLIPPY_LINTS, DEFAULT_LINTS, FEATURES},\n-        pick_best_token, try_resolve_derive_input_at, FamousDefs,\n+        pick_best_token, FamousDefs,\n     },\n     RootDatabase,\n };\n@@ -107,7 +107,7 @@ pub(crate) fn hover(\n     }\n     let offset = range.start();\n \n-    let token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n+    let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n         IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] => 3,\n         T!['('] | T![')'] => 2,\n         kind if kind.is_trivia() => 0,\n@@ -117,11 +117,35 @@ pub(crate) fn hover(\n     let mut seen = HashSet::default();\n \n     let mut fallback = None;\n-    sema.descend_into_macros_many(token.clone())\n+    // attributes, require special machinery as they are mere ident tokens\n+\n+    let descend_macros = sema.descend_into_macros_many(original_token.clone());\n+\n+    for token in &descend_macros {\n+        if token.kind() != COMMENT {\n+            if let Some(attr) = token.ancestors().find_map(ast::Attr::cast) {\n+                // lints\n+                if let Some(res) = try_hover_for_lint(&attr, &token) {\n+                    return Some(res);\n+                }\n+            }\n+        }\n+    }\n+\n+    descend_macros\n         .iter()\n         .filter_map(|token| match token.parent() {\n             Some(node) => {\n-                match find_hover_result(&sema, file_id, offset, config, token, &node, &mut seen) {\n+                match find_hover_result(\n+                    &sema,\n+                    file_id,\n+                    offset,\n+                    config,\n+                    &original_token,\n+                    token,\n+                    &node,\n+                    &mut seen,\n+                ) {\n                     Some(res) => match res {\n                         ControlFlow::Break(inner) => Some(inner),\n                         ControlFlow::Continue(_) => {\n@@ -159,6 +183,7 @@ fn find_hover_result(\n     file_id: FileId,\n     offset: TextSize,\n     config: &HoverConfig,\n+    original_token: &SyntaxToken,\n     token: &SyntaxToken,\n     node: &SyntaxNode,\n     seen: &mut HashSet<Definition>,\n@@ -169,71 +194,39 @@ fn find_hover_result(\n     // so don't add them to the `seen` duplicate check\n     let mut add_to_seen_definitions = true;\n \n-    let definition = match_ast! {\n-        match node {\n-            ast::Name(name) => NameClass::classify(sema, &name).map(|class| match class {\n-                NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n-                NameClass::PatFieldShorthand { local_def, field_ref: _ } => Definition::Local(local_def),\n-            }),\n-            ast::NameRef(name_ref) => NameRefClass::classify(sema, &name_ref).map(|class| match class {\n-                NameRefClass::Definition(def) => def,\n-                NameRefClass::FieldShorthand { local_ref: _, field_ref } => {\n-                    Definition::Field(field_ref)\n-                }\n-            }),\n-            ast::Lifetime(lifetime) => NameClass::classify_lifetime(&sema, &lifetime).map_or_else(\n-                || {\n-                    NameRefClass::classify_lifetime(&sema, &lifetime).and_then(|class| match class {\n-                        NameRefClass::Definition(it) => Some(it),\n-                        _ => None,\n-                    })\n+    let definition = Definition::from_node(sema, token).into_iter().next().or_else(|| {\n+        // intra-doc links\n+        // FIXME: move comment + attribute special cases somewhere else to simplify control flow,\n+        // hopefully simplifying the return type of this function in the process\n+        // (the `Break`/`Continue` distinction is needed to decide whether to use fallback hovers)\n+        //\n+        // FIXME: hovering the intra doc link to `Foo` not working:\n+        //\n+        // #[identity]\n+        // trait Foo {\n+        //    /// [`Foo`]\n+        // fn foo() {}\n+        if token.kind() == COMMENT {\n+            add_to_seen_definitions = false;\n+            cov_mark::hit!(no_highlight_on_comment_hover);\n+            let (attributes, def) = doc_attributes(sema, node)?;\n+            let (docs, doc_mapping) = attributes.docs_with_rangemap(sema.db)?;\n+            let (idl_range, link, ns) = extract_definitions_from_docs(&docs).into_iter().find_map(\n+                |(range, link, ns)| {\n+                    let mapped = doc_mapping.map(range)?;\n+                    (mapped.file_id == file_id.into() && mapped.value.contains(offset))\n+                        .then(|| (mapped.value, link, ns))\n                 },\n-                NameClass::defined,\n-            ),\n-            _ => {\n-                // intra-doc links\n-                // FIXME: move comment + attribute special cases somewhere else to simplify control flow,\n-                // hopefully simplifying the return type of this function in the process\n-                // (the `Break`/`Continue` distinction is needed to decide whether to use fallback hovers)\n-                //\n-                // FIXME: hovering the intra doc link to `Foo` not working:\n-                //\n-                // #[identity]\n-                // trait Foo {\n-                //    /// [`Foo`]\n-                // fn foo() {}\n-                if token.kind() == COMMENT {\n-                    add_to_seen_definitions = false;\n-                    cov_mark::hit!(no_highlight_on_comment_hover);\n-                    let (attributes, def) = doc_attributes(sema, node)?;\n-                    let (docs, doc_mapping) = attributes.docs_with_rangemap(sema.db)?;\n-                    let (idl_range, link, ns) =\n-                        extract_definitions_from_docs(&docs).into_iter().find_map(|(range, link, ns)| {\n-                            let mapped = doc_mapping.map(range)?;\n-                            (mapped.file_id == file_id.into() && mapped.value.contains(offset)).then(||(mapped.value, link, ns))\n-                        })?;\n-                    range_override = Some(idl_range);\n-                    Some(match resolve_doc_path_for_def(sema.db,def, &link,ns)? {\n-                        Either::Left(it) => Definition::ModuleDef(it),\n-                        Either::Right(it) => Definition::Macro(it),\n-                    })\n-                // attributes, require special machinery as they are mere ident tokens\n-                } else if let Some(attr) = token.ancestors().find_map(ast::Attr::cast) {\n-                    add_to_seen_definitions = false;\n-                    // lints\n-                    if let Some(res) = try_hover_for_lint(&attr, &token) {\n-                        return Some(ControlFlow::Break(res));\n-                    // derives\n-                    } else {\n-                        range_override = Some(token.text_range());\n-                        try_resolve_derive_input_at(&sema, &attr, &token).map(Definition::Macro)\n-                    }\n-                } else {\n-                    None\n-                }\n-            },\n+            )?;\n+            range_override = Some(idl_range);\n+            Some(match resolve_doc_path_for_def(sema.db, def, &link, ns)? {\n+                Either::Left(it) => Definition::ModuleDef(it),\n+                Either::Right(it) => Definition::Macro(it),\n+            })\n+        } else {\n+            None\n         }\n-    };\n+    });\n \n     if let Some(definition) = definition {\n         // skip duplicates\n@@ -243,34 +236,8 @@ fn find_hover_result(\n         if add_to_seen_definitions {\n             seen.insert(definition);\n         }\n-        let famous_defs = match &definition {\n-            Definition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n-                Some(FamousDefs(&sema, sema.scope(&node).krate()))\n-            }\n-            _ => None,\n-        };\n-        if let Some(markup) =\n-            hover_for_definition(sema.db, definition, famous_defs.as_ref(), config)\n-        {\n-            let mut res = HoverResult::default();\n-            res.markup = process_markup(sema.db, definition, &markup, config);\n-            if let Some(action) = show_implementations_action(sema.db, definition) {\n-                res.actions.push(action);\n-            }\n-\n-            if let Some(action) = show_fn_references_action(sema.db, definition) {\n-                res.actions.push(action);\n-            }\n-\n-            if let Some(action) = runnable_action(&sema, definition, file_id) {\n-                res.actions.push(action);\n-            }\n-\n-            if let Some(action) = goto_type_action_for_def(sema.db, definition) {\n-                res.actions.push(action);\n-            }\n-\n-            let range = range_override.unwrap_or_else(|| sema.original_range(&node).range);\n+        if let Some(res) = hover_for_definition(sema, file_id, definition, &node, config) {\n+            let range = range_override.unwrap_or_else(|| original_token.text_range());\n             return Some(ControlFlow::Break(RangeInfo::new(range, res)));\n         }\n     }\n@@ -283,6 +250,9 @@ fn type_hover(\n     config: &HoverConfig,\n     token: &SyntaxToken,\n ) -> Option<RangeInfo<HoverResult>> {\n+    if token.kind() == COMMENT {\n+        return None;\n+    }\n     let node = token\n         .ancestors()\n         .take_while(|it| !ast::Item::can_cast(it.kind()))\n@@ -749,7 +719,43 @@ fn definition_mod_path(db: &RootDatabase, def: &Definition) -> Option<String> {\n     def.module(db).map(|module| render_path(db, module, definition_owner_name(db, def)))\n }\n \n-fn hover_for_definition(\n+pub(crate) fn hover_for_definition(\n+    sema: &Semantics<RootDatabase>,\n+    file_id: FileId,\n+    definition: Definition,\n+    node: &SyntaxNode,\n+    config: &HoverConfig,\n+) -> Option<HoverResult> {\n+    let famous_defs = match &definition {\n+        Definition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n+            Some(FamousDefs(&sema, sema.scope(&node).krate()))\n+        }\n+        _ => None,\n+    };\n+    if let Some(markup) = markup_for_definition(sema.db, definition, famous_defs.as_ref(), config) {\n+        let mut res = HoverResult::default();\n+        res.markup = process_markup(sema.db, definition, &markup, config);\n+        if let Some(action) = show_implementations_action(sema.db, definition) {\n+            res.actions.push(action);\n+        }\n+\n+        if let Some(action) = show_fn_references_action(sema.db, definition) {\n+            res.actions.push(action);\n+        }\n+\n+        if let Some(action) = runnable_action(&sema, definition, file_id) {\n+            res.actions.push(action);\n+        }\n+\n+        if let Some(action) = goto_type_action_for_def(sema.db, definition) {\n+            res.actions.push(action);\n+        }\n+        return Some(res);\n+    }\n+    None\n+}\n+\n+fn markup_for_definition(\n     db: &RootDatabase,\n     def: Definition,\n     famous_defs: Option<&FamousDefs>,\n@@ -885,7 +891,7 @@ mod tests {\n                 FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n             )\n             .unwrap();\n-        assert!(hover.is_none());\n+        assert!(hover.is_none(), \"hover not expected but found: {:?}\", hover.unwrap());\n     }\n \n     fn check(ra_fixture: &str, expect: Expect) {\n@@ -4529,6 +4535,36 @@ use crate as foo$0;\n         );\n     }\n \n+    #[test]\n+    fn hover_attribute_in_macro() {\n+        check(\n+            r#\"\n+macro_rules! identity {\n+    ($struct:item) => {\n+        $struct\n+    };\n+}\n+#[rustc_builtin_macro]\n+pub macro Copy {}\n+identity!{\n+    #[derive(Copy$0)]\n+    struct Foo;\n+}\n+\"#,\n+            expect![[r#\"\n+                *Copy*\n+\n+                ```rust\n+                test\n+                ```\n+\n+                ```rust\n+                pub macro Copy\n+                ```\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn hover_derive_input() {\n         check("}, {"sha": "d42af9c38f590abc1e8686e1f55311c29f9a2751", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8a82e6c492a27c0b366e4373426a18a32db130d2/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a82e6c492a27c0b366e4373426a18a32db130d2/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=8a82e6c492a27c0b366e4373426a18a32db130d2", "patch": "@@ -11,10 +11,10 @@ use hir::{\n };\n use syntax::{\n     ast::{self, AstNode},\n-    match_ast, SyntaxKind,\n+    match_ast, SyntaxKind, SyntaxToken,\n };\n \n-use crate::RootDatabase;\n+use crate::{helpers::try_resolve_derive_input_at, RootDatabase};\n \n // FIXME: a more precise name would probably be `Symbol`?\n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -29,6 +29,62 @@ pub enum Definition {\n }\n \n impl Definition {\n+    pub fn from_node(sema: &Semantics<RootDatabase>, token: &SyntaxToken) -> Vec<Definition> {\n+        let node = if let Some(x) = token.parent() {\n+            x\n+        } else {\n+            return vec![];\n+        };\n+        if token.kind() != SyntaxKind::COMMENT {\n+            if let Some(attr) = token.ancestors().find_map(ast::Attr::cast) {\n+                // derives\n+                let def = try_resolve_derive_input_at(&sema, &attr, &token).map(Definition::Macro);\n+                if let Some(def) = def {\n+                    return vec![def];\n+                }\n+            }\n+        }\n+        match_ast! {\n+            match node {\n+                ast::Name(name) => {\n+                    let class = if let Some(x) = NameClass::classify(&sema, &name) {\n+                        x\n+                    } else {\n+                        return vec![];\n+                    };\n+                    match class {\n+                        NameClass::Definition(it) | NameClass::ConstReference(it) => vec![it],\n+                        NameClass::PatFieldShorthand { local_def, field_ref } => vec![Definition::Local(local_def), Definition::Field(field_ref)],\n+                    }\n+                },\n+                ast::NameRef(name_ref) => {\n+                    let class = if let Some(x) = NameRefClass::classify(sema, &name_ref) {\n+                        x\n+                    } else {\n+                        return vec![];\n+                    };\n+                    match class {\n+                        NameRefClass::Definition(def) => vec![def],\n+                        NameRefClass::FieldShorthand { local_ref, field_ref } => {\n+                            vec![Definition::Field(field_ref), Definition::Local(local_ref)]\n+                        }\n+                    }\n+                },\n+                ast::Lifetime(lifetime) => {\n+                    (if let Some(x) = NameClass::classify_lifetime(&sema, &lifetime) {\n+                        NameClass::defined(x)\n+                    } else {\n+                        NameRefClass::classify_lifetime(&sema, &lifetime).and_then(|class| match class {\n+                            NameRefClass::Definition(it) => Some(it),\n+                            _ => None,\n+                        })\n+                    }).into_iter().collect()\n+                },\n+                _ => vec![],\n+            }\n+        }\n+    }\n+\n     pub fn module(&self, db: &RootDatabase) -> Option<Module> {\n         match self {\n             Definition::Macro(it) => it.module(db),"}]}