{"sha": "5b53de17752a11c52679dca46e8a4b4ea3fe1354", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNTNkZTE3NzUyYTExYzUyNjc5ZGNhNDZlOGE0YjRlYTNmZTEzNTQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-24T03:49:20Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-29T05:26:22Z"}, "message": "debuginfo: extract create.rs", "tree": {"sha": "173367e0974c91b09655acadf47ef1cb7b83eeb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/173367e0974c91b09655acadf47ef1cb7b83eeb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b53de17752a11c52679dca46e8a4b4ea3fe1354", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b53de17752a11c52679dca46e8a4b4ea3fe1354", "html_url": "https://github.com/rust-lang/rust/commit/5b53de17752a11c52679dca46e8a4b4ea3fe1354", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b53de17752a11c52679dca46e8a4b4ea3fe1354/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a01554789430fa171b1b7206ecac7e6c2bc045b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a01554789430fa171b1b7206ecac7e6c2bc045b7", "html_url": "https://github.com/rust-lang/rust/commit/a01554789430fa171b1b7206ecac7e6c2bc045b7"}], "stats": {"total": 225, "additions": 129, "deletions": 96}, "files": [{"sha": "246a22a6211d87bea28ba00ff14dffebdfecab9b", "filename": "src/librustc_trans/trans/debuginfo/create.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/5b53de17752a11c52679dca46e8a4b4ea3fe1354/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b53de17752a11c52679dca46e8a4b4ea3fe1354/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate.rs?ref=5b53de17752a11c52679dca46e8a4b4ea3fe1354", "patch": "@@ -0,0 +1,124 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://!rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://!www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://!opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Module-Internal debug info creation functions.\n+\n+use super::utils::{span_start, DIB};\n+\n+use super::{set_debug_location, type_metadata, file_metadata, DW_TAG_auto_variable, DW_TAG_arg_variable};\n+use super::VariableKind::{self, ArgumentVariable, CapturedVariable, LocalVariable};\n+use super::VariableAccess::{self, DirectVariable, IndirectVariable};\n+use super::InternalDebugLocation::{self, UnknownLocation};\n+\n+use llvm;\n+use llvm::debuginfo::{DIScope, DIBuilderRef, DIDescriptor, DIArray};\n+\n+use trans;\n+use trans::common::{CrateContext, Block};\n+use middle::ty::Ty;\n+use session::config;\n+\n+use libc::c_uint;\n+use std::ffi::CString;\n+use syntax::codemap::{Span, Pos};\n+use syntax::ast;\n+use syntax::parse::token;\n+\n+pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n+{\n+    // The is_local_to_unit flag indicates whether a function is local to the\n+    // current compilation unit (i.e. if it is *static* in the C-sense). The\n+    // *reachable* set should provide a good approximation of this, as it\n+    // contains everything that might leak out of the current crate (by being\n+    // externally visible or by being inlined into something externally\n+    // visible). It might better to use the `exported_items` set from\n+    // `driver::CrateAnalysis` in the future, but (atm) this set is not\n+    // available in the translation pass.\n+    !cx.reachable().contains(&node_id)\n+}\n+\n+#[allow(non_snake_case)]\n+pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n+    return unsafe {\n+        llvm::LLVMDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32)\n+    };\n+}\n+\n+pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 variable_name: ast::Name,\n+                                 variable_type: Ty<'tcx>,\n+                                 scope_metadata: DIScope,\n+                                 variable_access: VariableAccess,\n+                                 variable_kind: VariableKind,\n+                                 span: Span) {\n+    let cx: &CrateContext = bcx.ccx();\n+\n+    let filename = span_start(cx, span).file.name.clone();\n+    let file_metadata = file_metadata(cx, &filename[..]);\n+\n+    let name = token::get_name(variable_name);\n+    let loc = span_start(cx, span);\n+    let type_metadata = type_metadata(cx, variable_type, span);\n+\n+    let (argument_index, dwarf_tag) = match variable_kind {\n+        ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),\n+        LocalVariable    |\n+        CapturedVariable => (0, DW_TAG_auto_variable)\n+    };\n+\n+    let name = CString::new(name.as_bytes()).unwrap();\n+    match (variable_access, &[][..]) {\n+        (DirectVariable { alloca }, address_operations) |\n+        (IndirectVariable {alloca, address_operations}, _) => {\n+            let metadata = unsafe {\n+                llvm::LLVMDIBuilderCreateVariable(\n+                    DIB(cx),\n+                    dwarf_tag,\n+                    scope_metadata,\n+                    name.as_ptr(),\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    type_metadata,\n+                    cx.sess().opts.optimize != config::No,\n+                    0,\n+                    address_operations.as_ptr(),\n+                    address_operations.len() as c_uint,\n+                    argument_index)\n+            };\n+            set_debug_location(cx, InternalDebugLocation::new(scope_metadata,\n+                                                      loc.line,\n+                                                      loc.col.to_usize()));\n+            unsafe {\n+                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n+                    DIB(cx),\n+                    alloca,\n+                    metadata,\n+                    address_operations.as_ptr(),\n+                    address_operations.len() as c_uint,\n+                    bcx.llbb);\n+\n+                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n+            }\n+        }\n+    }\n+\n+    match variable_kind {\n+        ArgumentVariable(_) | CapturedVariable => {\n+            assert!(!bcx.fcx\n+                        .debug_context\n+                        .get_ref(cx, span)\n+                        .source_locations_enabled\n+                        .get());\n+            set_debug_location(cx, UnknownLocation);\n+        }\n+        _ => { /* nothing to do */ }\n+    }\n+}\n+"}, {"sha": "c1cdfb587b3ef2f947b105b000d5e85a6bc1e3ae", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 5, "deletions": 96, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/5b53de17752a11c52679dca46e8a4b4ea3fe1354/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b53de17752a11c52679dca46e8a4b4ea3fe1354/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=5b53de17752a11c52679dca46e8a4b4ea3fe1354", "patch": "@@ -13,10 +13,12 @@ mod doc;\n \n pub mod gdb;\n mod utils;\n+mod create;\n \n use self::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n                   assert_type_for_node_id, get_namespace_and_span_for_item, fn_should_be_ignored,\n                   contains_nodebug_attribute, create_scope_map};\n+use self::create::{declare_local, create_DIArray, is_node_local_to_unit};\n \n use self::VariableAccess::*;\n use self::VariableKind::*;\n@@ -31,7 +33,7 @@ use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::*;\n use metadata::csearch;\n use middle::subst::{self, Substs};\n-use trans::{self, adt, machine, type_of};\n+use trans::{adt, machine, type_of};\n use trans::common::{self, NodeIdAndSpan, CrateContext, FunctionContext, Block,\n                     NormalizingClosureTyper};\n use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n@@ -535,15 +537,15 @@ struct FunctionDebugContextData {\n     source_location_override: Cell<bool>,\n }\n \n-enum VariableAccess<'a> {\n+pub enum VariableAccess<'a> {\n     // The llptr given is an alloca containing the variable's value\n     DirectVariable { alloca: ValueRef },\n     // The llptr given is an alloca containing the start of some pointer chain\n     // leading to the variable's content.\n     IndirectVariable { alloca: ValueRef, address_operations: &'a [i64] }\n }\n \n-enum VariableKind {\n+pub enum VariableKind {\n     ArgumentVariable(usize /*index*/),\n     LocalVariable,\n     CapturedVariable,\n@@ -1430,29 +1432,6 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-//=-----------------------------------------------------------------------------\n-// Module-Internal debug info creation functions\n-//=-----------------------------------------------------------------------------\n-\n-fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n-{\n-    // The is_local_to_unit flag indicates whether a function is local to the\n-    // current compilation unit (i.e. if it is *static* in the C-sense). The\n-    // *reachable* set should provide a good approximation of this, as it\n-    // contains everything that might leak out of the current crate (by being\n-    // externally visible or by being inlined into something externally\n-    // visible). It might better to use the `exported_items` set from\n-    // `driver::CrateAnalysis` in the future, but (atm) this set is not\n-    // available in the translation pass.\n-    !cx.reachable().contains(&node_id)\n-}\n-\n-#[allow(non_snake_case)]\n-fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n-    return unsafe {\n-        llvm::LLVMDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32)\n-    };\n-}\n \n fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n     let work_dir = &cx.sess().working_dir;\n@@ -1504,76 +1483,6 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n     }\n }\n \n-fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             variable_name: ast::Name,\n-                             variable_type: Ty<'tcx>,\n-                             scope_metadata: DIScope,\n-                             variable_access: VariableAccess,\n-                             variable_kind: VariableKind,\n-                             span: Span) {\n-    let cx: &CrateContext = bcx.ccx();\n-\n-    let filename = span_start(cx, span).file.name.clone();\n-    let file_metadata = file_metadata(cx, &filename[..]);\n-\n-    let name = token::get_name(variable_name);\n-    let loc = span_start(cx, span);\n-    let type_metadata = type_metadata(cx, variable_type, span);\n-\n-    let (argument_index, dwarf_tag) = match variable_kind {\n-        ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),\n-        LocalVariable    |\n-        CapturedVariable => (0, DW_TAG_auto_variable)\n-    };\n-\n-    let name = CString::new(name.as_bytes()).unwrap();\n-    match (variable_access, &[][..]) {\n-        (DirectVariable { alloca }, address_operations) |\n-        (IndirectVariable {alloca, address_operations}, _) => {\n-            let metadata = unsafe {\n-                llvm::LLVMDIBuilderCreateVariable(\n-                    DIB(cx),\n-                    dwarf_tag,\n-                    scope_metadata,\n-                    name.as_ptr(),\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    type_metadata,\n-                    cx.sess().opts.optimize != config::No,\n-                    0,\n-                    address_operations.as_ptr(),\n-                    address_operations.len() as c_uint,\n-                    argument_index)\n-            };\n-            set_debug_location(cx, InternalDebugLocation::new(scope_metadata,\n-                                                      loc.line,\n-                                                      loc.col.to_usize()));\n-            unsafe {\n-                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n-                    DIB(cx),\n-                    alloca,\n-                    metadata,\n-                    address_operations.as_ptr(),\n-                    address_operations.len() as c_uint,\n-                    bcx.llbb);\n-\n-                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n-            }\n-        }\n-    }\n-\n-    match variable_kind {\n-        ArgumentVariable(_) | CapturedVariable => {\n-            assert!(!bcx.fcx\n-                        .debug_context\n-                        .get_ref(cx, span)\n-                        .source_locations_enabled\n-                        .get());\n-            set_debug_location(cx, UnknownLocation);\n-        }\n-        _ => { /* nothing to do */ }\n-    }\n-}\n \n fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n     match debug_context(cx).created_files.borrow().get(full_path) {"}]}