{"sha": "45439945c9cb1122c882cefbe0e38c3bb6f20514", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NDM5OTQ1YzljYjExMjJjODgyY2VmYmUwZTM4YzNiYjZmMjA1MTQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-24T13:00:33Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-12-01T12:48:19Z"}, "message": "incr.comp.: Store Spans as (file,line,col,length) in incr.comp. cache.\n\nThe previous method ran into problems because ICH would treat Spans\nas (file,line,col) but the cache contained byte offsets and its\npossible for the latter to change while the former stayed stable.", "tree": {"sha": "32f823eec65f8b4de4f12e49eafbd41c55f51e4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32f823eec65f8b4de4f12e49eafbd41c55f51e4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45439945c9cb1122c882cefbe0e38c3bb6f20514", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45439945c9cb1122c882cefbe0e38c3bb6f20514", "html_url": "https://github.com/rust-lang/rust/commit/45439945c9cb1122c882cefbe0e38c3bb6f20514", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45439945c9cb1122c882cefbe0e38c3bb6f20514/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "409e39285d2189eb8bb656a93074473f9f186cc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/409e39285d2189eb8bb656a93074473f9f186cc5", "html_url": "https://github.com/rust-lang/rust/commit/409e39285d2189eb8bb656a93074473f9f186cc5"}], "stats": {"total": 292, "additions": 178, "deletions": 114}, "files": [{"sha": "d95b825b9e562782a07e30ac539f01a03b79cf12", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 32, "deletions": 43, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/45439945c9cb1122c882cefbe0e38c3bb6f20514/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45439945c9cb1122c882cefbe0e38c3bb6f20514/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=45439945c9cb1122c882cefbe0e38c3bb6f20514", "patch": "@@ -28,7 +28,7 @@ use syntax::attr;\n use syntax::codemap::CodeMap;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::symbol::Symbol;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHashingContextProvider,\n                                            StableHasher, StableHasherResult,\n@@ -362,63 +362,52 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        use syntax_pos::Pos;\n+        const TAG_VALID_SPAN: u8 = 0;\n+        const TAG_INVALID_SPAN: u8 = 1;\n+        const TAG_EXPANSION: u8 = 0;\n+        const TAG_NO_EXPANSION: u8 = 1;\n \n         if !hcx.hash_spans {\n             return\n         }\n \n+        if *self == DUMMY_SP {\n+            return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n+        }\n+\n         // If this is not an empty or invalid span, we want to hash the last\n         // position that belongs to it, as opposed to hashing the first\n         // position past it.\n         let span = self.data();\n-        let span_hi = if span.hi > span.lo {\n-            // We might end up in the middle of a multibyte character here,\n-            // but that's OK, since we are not trying to decode anything at\n-            // this position.\n-            span.hi - ::syntax_pos::BytePos(1)\n-        } else {\n-            span.hi\n-        };\n \n-        {\n-            let loc1 = hcx.codemap().byte_pos_to_line_and_col(span.lo);\n-            let loc1 = loc1.as_ref()\n-                           .map(|&(ref fm, line, col)| (&fm.name[..], line, col.to_usize()))\n-                           .unwrap_or((\"???\", 0, 0));\n-\n-            let loc2 = hcx.codemap().byte_pos_to_line_and_col(span_hi);\n-            let loc2 = loc2.as_ref()\n-                           .map(|&(ref fm, line, col)| (&fm.name[..], line, col.to_usize()))\n-                           .unwrap_or((\"???\", 0, 0));\n-\n-            if loc1.0 == loc2.0 {\n-                std_hash::Hash::hash(&0u8, hasher);\n-\n-                std_hash::Hash::hash(loc1.0, hasher);\n-                std_hash::Hash::hash(&loc1.1, hasher);\n-                std_hash::Hash::hash(&loc1.2, hasher);\n-\n-                // Do not hash the file name twice\n-                std_hash::Hash::hash(&loc2.1, hasher);\n-                std_hash::Hash::hash(&loc2.2, hasher);\n-            } else {\n-                std_hash::Hash::hash(&1u8, hasher);\n-\n-                std_hash::Hash::hash(loc1.0, hasher);\n-                std_hash::Hash::hash(&loc1.1, hasher);\n-                std_hash::Hash::hash(&loc1.2, hasher);\n-\n-                std_hash::Hash::hash(loc2.0, hasher);\n-                std_hash::Hash::hash(&loc2.1, hasher);\n-                std_hash::Hash::hash(&loc2.2, hasher);\n+        if span.hi < span.lo {\n+            return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n+        }\n+\n+        let (file_lo, line_lo, col_lo) = match hcx.codemap()\n+                                                  .byte_pos_to_line_and_col(span.lo) {\n+            Some(pos) => pos,\n+            None => {\n+                return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n             }\n+        };\n+\n+        if !file_lo.contains(span.hi) {\n+            return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n         }\n \n+        let len = span.hi - span.lo;\n+\n+        std_hash::Hash::hash(&TAG_VALID_SPAN, hasher);\n+        std_hash::Hash::hash(&file_lo.name, hasher);\n+        std_hash::Hash::hash(&line_lo, hasher);\n+        std_hash::Hash::hash(&col_lo, hasher);\n+        std_hash::Hash::hash(&len, hasher);\n+\n         if span.ctxt == SyntaxContext::empty() {\n-            0u8.hash_stable(hcx, hasher);\n+            TAG_NO_EXPANSION.hash_stable(hcx, hasher);\n         } else {\n-            1u8.hash_stable(hcx, hasher);\n+            TAG_EXPANSION.hash_stable(hcx, hasher);\n             span.ctxt.outer().expn_info().hash_stable(hcx, hasher);\n         }\n     }"}, {"sha": "40103571afadfe458daef2b0700fbb17c73c5320", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 140, "deletions": 70, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/45439945c9cb1122c882cefbe0e38c3bb6f20514/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45439945c9cb1122c882cefbe0e38c3bb6f20514/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=45439945c9cb1122c882cefbe0e38c3bb6f20514", "patch": "@@ -14,6 +14,7 @@ use hir;\n use hir::def_id::{CrateNum, DefIndex, DefId, LocalDefId,\n                   RESERVED_FOR_INCR_COMP_CACHE, LOCAL_CRATE};\n use hir::map::definitions::DefPathHash;\n+use ich::CachingCodemapView;\n use middle::cstore::CrateStore;\n use mir;\n use rustc_data_structures::fx::FxHashMap;\n@@ -23,11 +24,11 @@ use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n                       UseSpecializedDecodable, UseSpecializedEncodable};\n use session::{CrateDisambiguator, Session};\n use std::cell::RefCell;\n-use std::collections::BTreeMap;\n use std::mem;\n+use std::rc::Rc;\n use syntax::ast::NodeId;\n use syntax::codemap::{CodeMap, StableFilemapId};\n-use syntax_pos::{BytePos, Span, DUMMY_SP};\n+use syntax_pos::{BytePos, Span, DUMMY_SP, FileMap};\n use syntax_pos::hygiene::{Mark, SyntaxContext, ExpnInfo};\n use ty;\n use ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n@@ -45,6 +46,9 @@ const TAG_NO_EXPANSION_INFO: u8 = 0;\n const TAG_EXPANSION_INFO_SHORTHAND: u8 = 1;\n const TAG_EXPANSION_INFO_INLINE: u8 = 2;\n \n+const TAG_VALID_SPAN: u8 = 0;\n+const TAG_INVALID_SPAN: u8 = 1;\n+\n /// `OnDiskCache` provides an interface to incr. comp. data cached from the\n /// previous compilation session. This data will eventually include the results\n /// of a few selected queries (like `typeck_tables_of` and `mir_optimized`) and\n@@ -64,8 +68,11 @@ pub struct OnDiskCache<'sess> {\n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n     cnum_map: RefCell<Option<IndexVec<CrateNum, Option<CrateNum>>>>,\n \n-    prev_filemap_starts: BTreeMap<BytePos, StableFilemapId>,\n     codemap: &'sess CodeMap,\n+    file_index_to_stable_id: FxHashMap<FileMapIndex, StableFilemapId>,\n+\n+    // These two fields caches that are populated lazily during decoding.\n+    file_index_to_file: RefCell<FxHashMap<FileMapIndex, Rc<FileMap>>>,\n     synthetic_expansion_infos: RefCell<FxHashMap<usize, SyntaxContext>>,\n \n     // A map from dep-node to the position of the cached query result in\n@@ -76,13 +83,16 @@ pub struct OnDiskCache<'sess> {\n // This type is used only for (de-)serialization.\n #[derive(RustcEncodable, RustcDecodable)]\n struct Header {\n-    prev_filemap_starts: BTreeMap<BytePos, StableFilemapId>,\n+    file_index_to_stable_id: FxHashMap<FileMapIndex, StableFilemapId>,\n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n }\n \n type EncodedPrevDiagnostics = Vec<(SerializedDepNodeIndex, Vec<Diagnostic>)>;\n type EncodedQueryResultIndex = Vec<(SerializedDepNodeIndex, usize)>;\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+struct FileMapIndex(u32);\n+\n impl<'sess> OnDiskCache<'sess> {\n     /// Create a new OnDiskCache instance from the serialized data in `data`.\n     pub fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> OnDiskCache<'sess> {\n@@ -97,15 +107,17 @@ impl<'sess> OnDiskCache<'sess> {\n         };\n \n         let mut synthetic_expansion_infos = FxHashMap();\n+        let mut file_index_to_file = FxHashMap();\n \n         let (prev_diagnostics, query_result_index) = {\n             let mut decoder = CacheDecoder {\n                 tcx: None,\n                 opaque: opaque::Decoder::new(&data[..], post_header_pos),\n                 codemap: sess.codemap(),\n-                prev_filemap_starts: &header.prev_filemap_starts,\n                 cnum_map: &IndexVec::new(),\n                 synthetic_expansion_infos: &mut synthetic_expansion_infos,\n+                file_index_to_file: &mut file_index_to_file,\n+                file_index_to_stable_id: &header.file_index_to_stable_id,\n             };\n \n             // Decode Diagnostics\n@@ -138,7 +150,8 @@ impl<'sess> OnDiskCache<'sess> {\n         OnDiskCache {\n             serialized_data: data,\n             prev_diagnostics,\n-            prev_filemap_starts: header.prev_filemap_starts,\n+            file_index_to_stable_id: header.file_index_to_stable_id,\n+            file_index_to_file: RefCell::new(file_index_to_file),\n             prev_cnums: header.prev_cnums,\n             cnum_map: RefCell::new(None),\n             codemap: sess.codemap(),\n@@ -152,7 +165,8 @@ impl<'sess> OnDiskCache<'sess> {\n         OnDiskCache {\n             serialized_data: Vec::new(),\n             prev_diagnostics: FxHashMap(),\n-            prev_filemap_starts: BTreeMap::new(),\n+            file_index_to_stable_id: FxHashMap(),\n+            file_index_to_file: RefCell::new(FxHashMap()),\n             prev_cnums: vec![],\n             cnum_map: RefCell::new(None),\n             codemap,\n@@ -172,23 +186,32 @@ impl<'sess> OnDiskCache<'sess> {\n         // Serializing the DepGraph should not modify it:\n         let _in_ignore = tcx.dep_graph.in_ignore();\n \n+        // Allocate FileMapIndices\n+        let (file_to_file_index, file_index_to_stable_id) = {\n+            let mut file_to_file_index = FxHashMap();\n+            let mut file_index_to_stable_id = FxHashMap();\n+\n+            for (index, file) in tcx.sess.codemap().files().iter().enumerate() {\n+                let index = FileMapIndex(index as u32);\n+                let file_ptr: *const FileMap = &**file as *const _;\n+                file_to_file_index.insert(file_ptr, index);\n+                file_index_to_stable_id.insert(index, StableFilemapId::new(&file));\n+            }\n+\n+            (file_to_file_index, file_index_to_stable_id)\n+        };\n+\n         let mut encoder = CacheEncoder {\n             tcx,\n             encoder,\n             type_shorthands: FxHashMap(),\n             predicate_shorthands: FxHashMap(),\n             expn_info_shorthands: FxHashMap(),\n+            codemap: CachingCodemapView::new(tcx.sess.codemap()),\n+            file_to_file_index,\n         };\n \n-\n         // Encode the file header\n-        let prev_filemap_starts: BTreeMap<_, _> = self\n-            .codemap\n-            .files()\n-            .iter()\n-            .map(|fm| (fm.start_pos, StableFilemapId::new(fm)))\n-            .collect();\n-\n         let sorted_cnums = sorted_cnums_including_local_crate(cstore);\n \n         let prev_cnums: Vec<_> = sorted_cnums.iter().map(|&cnum| {\n@@ -198,7 +221,7 @@ impl<'sess> OnDiskCache<'sess> {\n         }).collect();\n \n         Header {\n-            prev_filemap_starts,\n+            file_index_to_stable_id,\n             prev_cnums,\n         }.encode(&mut encoder)?;\n \n@@ -282,14 +305,16 @@ impl<'sess> OnDiskCache<'sess> {\n         }\n \n         let mut synthetic_expansion_infos = self.synthetic_expansion_infos.borrow_mut();\n+        let mut file_index_to_file = self.file_index_to_file.borrow_mut();\n \n         let mut decoder = CacheDecoder {\n             tcx: Some(tcx),\n             opaque: opaque::Decoder::new(&self.serialized_data[..], pos),\n             codemap: self.codemap,\n-            prev_filemap_starts: &self.prev_filemap_starts,\n             cnum_map: cnum_map.as_ref().unwrap(),\n-            synthetic_expansion_infos: &mut *synthetic_expansion_infos,\n+            file_index_to_file: &mut file_index_to_file,\n+            file_index_to_stable_id: &self.file_index_to_stable_id,\n+            synthetic_expansion_infos: &mut synthetic_expansion_infos,\n         };\n \n         match decode_tagged(&mut decoder, dep_node_index) {\n@@ -363,20 +388,26 @@ struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n     tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n     opaque: opaque::Decoder<'x>,\n     codemap: &'x CodeMap,\n-    prev_filemap_starts: &'x BTreeMap<BytePos, StableFilemapId>,\n     cnum_map: &'x IndexVec<CrateNum, Option<CrateNum>>,\n     synthetic_expansion_infos: &'x mut FxHashMap<usize, SyntaxContext>,\n+    file_index_to_file: &'x mut FxHashMap<FileMapIndex, Rc<FileMap>>,\n+    file_index_to_stable_id: &'x FxHashMap<FileMapIndex, StableFilemapId>,\n }\n \n impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n-    fn find_filemap_prev_bytepos(&self,\n-                                 prev_bytepos: BytePos)\n-                                 -> Option<(BytePos, StableFilemapId)> {\n-        for (start, id) in self.prev_filemap_starts.range(BytePos(0) ..= prev_bytepos).rev() {\n-            return Some((*start, *id))\n-        }\n+    fn file_index_to_file(&mut self, index: FileMapIndex) -> Rc<FileMap> {\n+        let CacheDecoder {\n+            ref mut file_index_to_file,\n+            ref file_index_to_stable_id,\n+            ref codemap,\n+            ..\n+        } = *self;\n \n-        None\n+        file_index_to_file.entry(index).or_insert_with(|| {\n+            let stable_id = file_index_to_stable_id[&index];\n+            codemap.filemap_by_stable_id(stable_id)\n+                   .expect(\"Failed to lookup FileMap in new context.\")\n+        }).clone()\n     }\n }\n \n@@ -466,50 +497,55 @@ implement_ty_decoder!( CacheDecoder<'a, 'tcx, 'x> );\n \n impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n     fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n-        let lo = BytePos::decode(self)?;\n-        let hi = BytePos::decode(self)?;\n-\n-        if let Some((prev_filemap_start, filemap_id)) = self.find_filemap_prev_bytepos(lo) {\n-            if let Some(current_filemap) = self.codemap.filemap_by_stable_id(filemap_id) {\n-                let lo = (lo + current_filemap.start_pos) - prev_filemap_start;\n-                let hi = (hi + current_filemap.start_pos) - prev_filemap_start;\n-\n-                let expn_info_tag = u8::decode(self)?;\n-\n-                let ctxt = match expn_info_tag {\n-                    TAG_NO_EXPANSION_INFO => {\n-                        SyntaxContext::empty()\n-                    }\n-                    TAG_EXPANSION_INFO_INLINE => {\n-                        let pos = self.position();\n-                        let expn_info: ExpnInfo = Decodable::decode(self)?;\n-                        let ctxt = SyntaxContext::allocate_directly(expn_info);\n-                        self.synthetic_expansion_infos.insert(pos, ctxt);\n-                        ctxt\n-                    }\n-                    TAG_EXPANSION_INFO_SHORTHAND => {\n-                        let pos = usize::decode(self)?;\n-                        if let Some(ctxt) = self.synthetic_expansion_infos.get(&pos).cloned() {\n-                            ctxt\n-                        } else {\n-                            let expn_info = self.with_position(pos, |this| {\n-                                 ExpnInfo::decode(this)\n-                            })?;\n-                            let ctxt = SyntaxContext::allocate_directly(expn_info);\n-                            self.synthetic_expansion_infos.insert(pos, ctxt);\n-                            ctxt\n-                        }\n-                    }\n-                    _ => {\n-                        unreachable!()\n-                    }\n-                };\n-\n-                return Ok(Span::new(lo, hi, ctxt));\n-            }\n+        let tag: u8 = Decodable::decode(self)?;\n+\n+        if tag == TAG_INVALID_SPAN {\n+            return Ok(DUMMY_SP);\n+        } else {\n+            debug_assert_eq!(tag, TAG_VALID_SPAN);\n         }\n \n-        Ok(DUMMY_SP)\n+        let file_lo_index = FileMapIndex::decode(self)?;\n+        let line_lo = usize::decode(self)?;\n+        let col_lo = BytePos::decode(self)?;\n+        let len = BytePos::decode(self)?;\n+\n+        let file_lo = self.file_index_to_file(file_lo_index);\n+        let lo = file_lo.lines.borrow()[line_lo - 1] + col_lo;\n+        let hi = lo + len;\n+\n+        let expn_info_tag = u8::decode(self)?;\n+\n+        let ctxt = match expn_info_tag {\n+            TAG_NO_EXPANSION_INFO => {\n+                SyntaxContext::empty()\n+            }\n+            TAG_EXPANSION_INFO_INLINE => {\n+                let pos = self.position();\n+                let expn_info: ExpnInfo = Decodable::decode(self)?;\n+                let ctxt = SyntaxContext::allocate_directly(expn_info);\n+                self.synthetic_expansion_infos.insert(pos, ctxt);\n+                ctxt\n+            }\n+            TAG_EXPANSION_INFO_SHORTHAND => {\n+                let pos = usize::decode(self)?;\n+                if let Some(ctxt) = self.synthetic_expansion_infos.get(&pos).cloned() {\n+                    ctxt\n+                } else {\n+                    let expn_info = self.with_position(pos, |this| {\n+                         ExpnInfo::decode(this)\n+                    })?;\n+                    let ctxt = SyntaxContext::allocate_directly(expn_info);\n+                    self.synthetic_expansion_infos.insert(pos, ctxt);\n+                    ctxt\n+                }\n+            }\n+            _ => {\n+                unreachable!()\n+            }\n+        };\n+\n+        Ok(Span::new(lo, hi, ctxt))\n     }\n }\n \n@@ -609,11 +645,17 @@ struct CacheEncoder<'enc, 'a, 'tcx, E>\n     type_shorthands: FxHashMap<ty::Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n     expn_info_shorthands: FxHashMap<Mark, usize>,\n+    codemap: CachingCodemapView<'tcx>,\n+    file_to_file_index: FxHashMap<*const FileMap, FileMapIndex>,\n }\n \n impl<'enc, 'a, 'tcx, E> CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {\n+    fn filemap_index(&mut self, filemap: Rc<FileMap>) -> FileMapIndex {\n+        self.file_to_file_index[&(&*filemap as *const FileMap)]\n+    }\n+\n     /// Encode something with additional information that allows to do some\n     /// sanity checks when decoding the data again. This method will first\n     /// encode the specified tag, then the given value, then the number of\n@@ -639,10 +681,38 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'enc, 'a, 'tcx\n     where E: 'enc + ty_codec::TyEncoder\n {\n     fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n+\n+        if *span == DUMMY_SP {\n+            return TAG_INVALID_SPAN.encode(self);\n+        }\n+\n         let span_data = span.data();\n \n-        span_data.lo.encode(self)?;\n-        span_data.hi.encode(self)?;\n+        if span_data.hi < span_data.lo {\n+            return TAG_INVALID_SPAN.encode(self);\n+        }\n+\n+        let (file_lo, line_lo, col_lo) = match self.codemap\n+                                                   .byte_pos_to_line_and_col(span_data.lo) {\n+            Some(pos) => pos,\n+            None => {\n+                return TAG_INVALID_SPAN.encode(self);\n+            }\n+        };\n+\n+        if !file_lo.contains(span_data.hi) {\n+            return TAG_INVALID_SPAN.encode(self);\n+        }\n+\n+        let len = span_data.hi - span_data.lo;\n+\n+        let filemap_index = self.filemap_index(file_lo);\n+\n+        TAG_VALID_SPAN.encode(self)?;\n+        filemap_index.encode(self)?;\n+        line_lo.encode(self)?;\n+        col_lo.encode(self)?;\n+        len.encode(self)?;\n \n         if span_data.ctxt == SyntaxContext::empty() {\n             TAG_NO_EXPANSION_INFO.encode(self)"}, {"sha": "3aac5334a38d6780db5f2abec1d70af5629d7cfd", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45439945c9cb1122c882cefbe0e38c3bb6f20514/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45439945c9cb1122c882cefbe0e38c3bb6f20514/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=45439945c9cb1122c882cefbe0e38c3bb6f20514", "patch": "@@ -105,7 +105,7 @@ impl FileLoader for RealFileLoader {\n // This is a FileMap identifier that is used to correlate FileMaps between\n // subsequent compilation sessions (which is something we need to do during\n // incremental compilation).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct StableFilemapId(u128);\n \n impl StableFilemapId {"}, {"sha": "bf059cac89152572efd1e72bdbc9734de2d4c233", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/45439945c9cb1122c882cefbe0e38c3bb6f20514/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45439945c9cb1122c882cefbe0e38c3bb6f20514/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=45439945c9cb1122c882cefbe0e38c3bb6f20514", "patch": "@@ -931,6 +931,11 @@ impl FileMap {\n             (lines[line_index], lines[line_index + 1])\n         }\n     }\n+\n+    #[inline]\n+    pub fn contains(&self, byte_pos: BytePos) -> bool {\n+        byte_pos >= self.start_pos && byte_pos <= self.end_pos\n+    }\n }\n \n /// Remove utf-8 BOM if any."}]}