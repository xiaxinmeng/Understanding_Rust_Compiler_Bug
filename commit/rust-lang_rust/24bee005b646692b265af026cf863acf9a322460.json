{"sha": "24bee005b646692b265af026cf863acf9a322460", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0YmVlMDA1YjY0NjY5MmIyNjVhZjAyNmNmODYzYWNmOWEzMjI0NjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-10T18:42:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-15T20:05:31Z"}, "message": "add `force_instantiate_unchecked` method", "tree": {"sha": "bd3c6a6b44f070bbbfedcf58f6bcb37633e6122e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd3c6a6b44f070bbbfedcf58f6bcb37633e6122e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24bee005b646692b265af026cf863acf9a322460", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24bee005b646692b265af026cf863acf9a322460", "html_url": "https://github.com/rust-lang/rust/commit/24bee005b646692b265af026cf863acf9a322460", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24bee005b646692b265af026cf863acf9a322460/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b69edc19e5a752011d867a2ac6c8d8a58548c07", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b69edc19e5a752011d867a2ac6c8d8a58548c07", "html_url": "https://github.com/rust-lang/rust/commit/4b69edc19e5a752011d867a2ac6c8d8a58548c07"}], "stats": {"total": 59, "additions": 59, "deletions": 0}, "files": [{"sha": "cbfdf58adee02b9986fa81f3b9d18c27145b9ee6", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/24bee005b646692b265af026cf863acf9a322460/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24bee005b646692b265af026cf863acf9a322460/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=24bee005b646692b265af026cf863acf9a322460", "patch": "@@ -1230,6 +1230,65 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.inlined_shallow_resolve(typ)\n     }\n \n+    /// A hacky sort of method used by the NLL type-relating code:\n+    ///\n+    /// - `var` must be some unbound type variable.\n+    /// - `value` must be a suitable type to use as its value.\n+    ///\n+    /// `var` will then be equated with `value`. Note that this\n+    /// sidesteps a number of important checks, such as the \"occurs\n+    /// check\" that prevents cyclic types, so it is important not to\n+    /// use this method during regular type-check.\n+    pub fn force_instantiate_unchecked(&self, var: Ty<'tcx>, value: Ty<'tcx>) {\n+        match (&var.sty, &value.sty) {\n+            (&ty::Infer(ty::TyVar(vid)), _) => {\n+                let mut type_variables = self.type_variables.borrow_mut();\n+\n+                // In NLL, we don't have type inference variables\n+                // floating around, so we can do this rather imprecise\n+                // variant of the occurs-check.\n+                assert!(!value.has_infer_types());\n+\n+                type_variables.instantiate(vid, value);\n+            }\n+\n+            (&ty::Infer(ty::IntVar(vid)), &ty::Int(value)) => {\n+                let mut int_unification_table = self.int_unification_table.borrow_mut();\n+                int_unification_table\n+                    .unify_var_value(vid, Some(ty::IntVarValue::IntType(value)))\n+                    .unwrap_or_else(|_| {\n+                        bug!(\"failed to unify int var `{:?}` with `{:?}`\", vid, value);\n+                    });\n+            }\n+\n+            (&ty::Infer(ty::IntVar(vid)), &ty::Uint(value)) => {\n+                let mut int_unification_table = self.int_unification_table.borrow_mut();\n+                int_unification_table\n+                    .unify_var_value(vid, Some(ty::IntVarValue::UintType(value)))\n+                    .unwrap_or_else(|_| {\n+                        bug!(\"failed to unify int var `{:?}` with `{:?}`\", vid, value);\n+                    });\n+            }\n+\n+            (&ty::Infer(ty::FloatVar(vid)), &ty::Float(value)) => {\n+                let mut float_unification_table = self.float_unification_table.borrow_mut();\n+                float_unification_table\n+                    .unify_var_value(vid, Some(ty::FloatVarValue(value)))\n+                    .unwrap_or_else(|_| {\n+                        bug!(\"failed to unify float var `{:?}` with `{:?}`\", vid, value)\n+                    });\n+            }\n+\n+            _ => {\n+                bug!(\n+                    \"force_instantiate_unchecked invoked with bad combination: var={:?} value={:?}\",\n+                    var,\n+                    value,\n+                );\n+            }\n+        }\n+    }\n+\n     pub fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,"}]}