{"sha": "c0a20d2929a7c0d6af0de899198df4f26453d877", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYTIwZDI5MjlhN2MwZDZhZjBkZTg5OTE5OGRmNGYyNjQ1M2Q4Nzc=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-29T05:05:50Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-30T11:59:44Z"}, "message": "Remove vec::{map, mapi, zip_map} and the methods, except for .map, since this\nis very common, and the replacement (.iter().transform().collect()) is very\nugly.", "tree": {"sha": "8347aea61a2f042c6114cadae3e11233582d22d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8347aea61a2f042c6114cadae3e11233582d22d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0a20d2929a7c0d6af0de899198df4f26453d877", "comment_count": 12, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0a20d2929a7c0d6af0de899198df4f26453d877", "html_url": "https://github.com/rust-lang/rust/commit/c0a20d2929a7c0d6af0de899198df4f26453d877", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0a20d2929a7c0d6af0de899198df4f26453d877/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a396e1e2e95acc07f2804be2079d5b692753d4bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a396e1e2e95acc07f2804be2079d5b692753d4bb", "html_url": "https://github.com/rust-lang/rust/commit/a396e1e2e95acc07f2804be2079d5b692753d4bb"}], "stats": {"total": 494, "additions": 184, "deletions": 310}, "files": [{"sha": "715f6d91e09dd7e36cf58970729757c2cb0fffa2", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -345,9 +345,9 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         fatal(~\"process did not return an error status\");\n     }\n \n-    let prefixes = vec::map(expected_errors, |ee| {\n+    let prefixes = expected_errors.iter().transform(|ee| {\n         fmt!(\"%s:%u:\", testfile.to_str(), ee.line)\n-    });\n+    }).collect::<~[~str]>();\n \n     // Scan and extract our error/warning messages,\n     // which look like:"}, {"sha": "f91260f475288539af5a7a6395bbe697ab3ac64a", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -100,7 +100,6 @@ total line count).\n use std::io::ReaderUtil;\n use std::io;\n use std::os;\n-use std::vec;\n \n /**\n A summary of the internal state of a `FileInput` object. `line_num`\n@@ -353,13 +352,13 @@ a literal `-`.\n */\n // XXX: stupid, unclear name\n pub fn pathify(vec: &[~str], stdin_hyphen : bool) -> ~[Option<Path>] {\n-    vec::map(vec, |&str : & ~str| {\n-        if stdin_hyphen && str == ~\"-\" {\n+    vec.iter().transform(|str| {\n+        if stdin_hyphen && \"-\" == *str {\n             None\n         } else {\n-            Some(Path(str))\n+            Some(Path(*str))\n         }\n-    })\n+    }).collect()\n }\n \n /**"}, {"sha": "1a494f36c646960789294fa80b2594a7f995a35e", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -592,9 +592,9 @@ pub mod groups {\n      */\n     pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n \n-        let desc_sep = ~\"\\n\" + \" \".repeat(24);\n+        let desc_sep = \"\\n\" + \" \".repeat(24);\n \n-        let rows = vec::map(opts, |optref| {\n+        let mut rows = opts.iter().transform(|optref| {\n             let OptGroup{short_name: short_name,\n                          long_name: long_name,\n                          hint: hint,\n@@ -669,7 +669,7 @@ pub mod groups {\n \n         return str::to_owned(brief) +\n                \"\\n\\nOptions:\\n\" +\n-               rows.connect(\"\\n\") +\n+               rows.collect::<~[~str]>().connect(\"\\n\") +\n                \"\\n\\n\";\n     }\n } // end groups module"}, {"sha": "9422ad0c9f2e0043b37f70f1223617f7c4df8a5a", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -283,13 +283,13 @@ impl Mul<BigUint, BigUint> for BigUint {\n             if n == 1 { return copy *a; }\n \n             let mut carry = 0;\n-            let prod = do vec::map(a.data) |ai| {\n+            let prod = do a.data.iter().transform |ai| {\n                 let (hi, lo) = BigDigit::from_uint(\n                     (*ai as uint) * (n as uint) + (carry as uint)\n                 );\n                 carry = hi;\n                 lo\n-            };\n+            }.collect::<~[BigDigit]>();\n             if carry == 0 { return BigUint::new(prod) };\n             return BigUint::new(prod + [carry]);\n         }\n@@ -618,13 +618,13 @@ impl BigUint {\n         if n_bits == 0 || self.is_zero() { return copy *self; }\n \n         let mut carry = 0;\n-        let shifted = do vec::map(self.data) |elem| {\n+        let shifted = do self.data.iter().transform |elem| {\n             let (hi, lo) = BigDigit::from_uint(\n                 (*elem as uint) << n_bits | (carry as uint)\n             );\n             carry = hi;\n             lo\n-        };\n+        }.collect::<~[BigDigit]>();\n         if carry == 0 { return BigUint::new(shifted); }\n         return BigUint::new(shifted + [carry]);\n     }\n@@ -1172,7 +1172,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_cmp() {\n-        let data = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n+        let data: ~[BigUint] = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n             .map(|v| BigUint::from_slice(*v));\n         for data.iter().enumerate().advance |(i, ni)| {\n             for data.slice(i, data.len()).iter().enumerate().advance |(j0, nj)| {"}, {"sha": "2878a3ee12215c48f718cda16db559a98d4bfe23", "filename": "src/libextra/par.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -92,7 +92,7 @@ pub fn map<A:Copy + Send,B:Copy + Send>(\n     vec::concat(map_slices(xs, || {\n         let f = fn_factory();\n         let result: ~fn(uint, &[A]) -> ~[B] =\n-            |_, slice| vec::map(slice, |x| f(x));\n+            |_, slice| slice.iter().transform(|x| f(x)).collect();\n         result\n     }))\n }\n@@ -104,9 +104,9 @@ pub fn mapi<A:Copy + Send,B:Copy + Send>(\n     let slices = map_slices(xs, || {\n         let f = fn_factory();\n         let result: ~fn(uint, &[A]) -> ~[B] = |base, slice| {\n-            vec::mapi(slice, |i, x| {\n+            slice.iter().enumerate().transform(|(i, x)| {\n                 f(i + base, x)\n-            })\n+            }).collect()\n         };\n         result\n     });"}, {"sha": "6c9453a5a3ba1140067c1286bc46c39ddfd342ae", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -78,12 +78,12 @@ impl ToStr for Version {\n         let s = if self.pre.is_empty() {\n             s\n         } else {\n-            s + \"-\" + self.pre.map(|i| i.to_str()).connect(\".\")\n+            fmt!(\"%s-%s\", s, self.pre.map(|i| i.to_str()).connect(\".\"))\n         };\n         if self.build.is_empty() {\n             s\n         } else {\n-            s + \"+\" + self.build.map(|i| i.to_str()).connect(\".\")\n+            fmt!(\"%s+%s\", s, self.build.map(|i| i.to_str()).connect(\".\"))\n         }\n     }\n }"}, {"sha": "19dbb941e556669f76022b301922fadef4d143a0", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -52,7 +52,7 @@ fn get_sysroot_absolute_rt_lib(sess: session::Session) -> Path {\n }\n \n pub fn rpaths_to_flags(rpaths: &[Path]) -> ~[~str] {\n-    vec::map(rpaths, |rpath| fmt!(\"-Wl,-rpath,%s\",rpath.to_str()))\n+    rpaths.iter().transform(|rpath| fmt!(\"-Wl,-rpath,%s\",rpath.to_str())).collect()\n }\n \n fn get_rpaths(os: session::os,\n@@ -103,9 +103,7 @@ fn get_rpaths(os: session::os,\n fn get_rpaths_relative_to_output(os: session::os,\n                                  output: &Path,\n                                  libs: &[Path]) -> ~[Path] {\n-    vec::map(libs, |a| {\n-        get_rpath_relative_to_output(os, output, a)\n-    })\n+    libs.iter().transform(|a| get_rpath_relative_to_output(os, output, a)).collect()\n }\n \n pub fn get_rpath_relative_to_output(os: session::os,\n@@ -163,7 +161,7 @@ pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n }\n \n fn get_absolute_rpaths(libs: &[Path]) -> ~[Path] {\n-    vec::map(libs, |a| get_absolute_rpath(a) )\n+    libs.iter().transform(|a| get_absolute_rpath(a)).collect()\n }\n \n pub fn get_absolute_rpath(lib: &Path) -> Path {"}, {"sha": "b1d4820f062eb797bd57d4d21c52460f0424c0bd", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -90,7 +90,7 @@ fn fold_foreign_mod(\n     ast::foreign_mod {\n         sort: nm.sort,\n         abis: nm.abis,\n-        view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(*x)),\n+        view_items: filtered_view_items.iter().transform(|x| fld.fold_view_item(*x)).collect(),\n         items: filtered_items\n     }\n }"}, {"sha": "6998410bae0e52adf85079143b61afe2a0971bd5", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -117,7 +117,7 @@ fn fold_mod(cx: @mut TestCtxt,\n \n     let mod_nomain = ast::_mod {\n         view_items: /*bad*/copy m.view_items,\n-        items: vec::map(m.items, |i| nomain(cx, *i)),\n+        items: m.items.iter().transform(|i| nomain(cx, *i)).collect(),\n     };\n \n     fold::noop_fold_mod(&mod_nomain, fld)"}, {"sha": "77a8d1792dbc8f667ba7e8fa97c95092bbc492a4", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -1441,8 +1441,7 @@ fn encode_crate_deps(ecx: &EncodeContext,\n             expected_cnum += 1;\n         }\n \n-        // mut -> immutable hack for vec::map\n-        deps.slice(0, deps.len()).to_owned()\n+        deps\n     }\n \n     // We're just going to write a list of crate 'name-hash-version's, with"}, {"sha": "72896258b2d326052e20bfc8e56369fc652b5bc7", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -642,13 +642,13 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                                          ty_to_str(cx.tcx, left_ty)));\n                             }\n                         }\n-                        let args = vec::map(class_fields, |class_field| {\n+                        let args = class_fields.iter().transform(|class_field| {\n                             match flds.iter().find_(|f|\n                                             f.ident == class_field.ident) {\n                                 Some(f) => f.pat,\n                                 _ => wild()\n                             }\n-                        });\n+                        }).collect();\n                         Some(vec::append(args, vec::to_owned(r.tail())))\n                     }\n                 }"}, {"sha": "bf91b6771dcd8110cf452d4704d35cdee20dbdd5", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -19,7 +19,6 @@ use syntax::ast::*;\n \n use std::float;\n use std::hashmap::{HashMap, HashSet};\n-use std::vec;\n \n //\n // This pass classifies expressions by their constant-ness.\n@@ -70,8 +69,8 @@ pub fn join(a: constness, b: constness) -> constness {\n     }\n }\n \n-pub fn join_all(cs: &[constness]) -> constness {\n-    cs.iter().fold(integral_const, |a, b| join(a, *b))\n+pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n+    cs.fold(integral_const, |a, b| join(a, b))\n }\n \n pub fn classify(e: &expr,\n@@ -104,7 +103,7 @@ pub fn classify(e: &expr,\n \n               ast::expr_tup(ref es) |\n               ast::expr_vec(ref es, ast::m_imm) => {\n-                join_all(vec::map(*es, |e| classify(*e, tcx)))\n+                join_all(es.iter().transform(|e| classify(*e, tcx)))\n               }\n \n               ast::expr_vstore(e, vstore) => {\n@@ -118,7 +117,7 @@ pub fn classify(e: &expr,\n               }\n \n               ast::expr_struct(_, ref fs, None) => {\n-                let cs = do vec::map((*fs)) |f| {\n+                let cs = do fs.iter().transform |f| {\n                     classify(f.node.expr, tcx)\n                 };\n                 join_all(cs)"}, {"sha": "ce09f790ef45f4c2b626666328c18cb717f4c0b9", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -740,11 +740,10 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n     }\n \n     fn check_foreign_fn(cx: &Context, decl: &ast::fn_decl) {\n-        let tys = vec::map(decl.inputs, |a| a.ty );\n-        let r = vec::append_one(tys, decl.output);\n-        for r.iter().advance |ty| {\n-            check_ty(cx, *ty);\n+        for decl.inputs.iter().advance |in| {\n+            check_ty(cx, in.ty);\n         }\n+        check_ty(cx, decl.output)\n     }\n \n     match it.node {"}, {"sha": "ab813c0ffc546cf410829db6defc079f8e7bd2b4", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -519,10 +519,10 @@ pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: int,\n                 C_struct(build_const_struct(ccx, nonnull, vals))\n             } else {\n                 assert_eq!(vals.len(), 0);\n-                let vals = do nonnull.fields.mapi |i, &ty| {\n+                let vals = do nonnull.fields.iter().enumerate().transform |(i, &ty)| {\n                     let llty = type_of::sizing_type_of(ccx, ty);\n                     if i == ptrfield { C_null(llty) } else { C_undef(llty) }\n-                };\n+                }.collect::<~[ValueRef]>();\n                 C_struct(build_const_struct(ccx, nonnull, vals))\n             }\n         }"}, {"sha": "8535c84c5cb5e30d4e839dab3bc4216b860671dd", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -615,12 +615,12 @@ pub fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     // we care about.\n     if ixs.len() < 16 {\n         let mut small_vec = [ C_i32(0), ..16 ];\n-        for ixs.iter().enumerate().advance |(i, &ix)| {\n-            small_vec[i] = C_i32(ix as i32)\n+        for small_vec.mut_iter().zip(ixs.iter()).advance |(small_vec_e, &ix)| {\n+            *small_vec_e = C_i32(ix as i32);\n         }\n         InBoundsGEP(cx, base, small_vec.slice(0, ixs.len()))\n     } else {\n-        let v = do vec::map(ixs) |i| { C_i32(*i as i32) };\n+        let v = do ixs.iter().transform |i| { C_i32(*i as i32) }.collect::<~[ValueRef]>();\n         count_insn(cx, \"gepi\");\n         InBoundsGEP(cx, base, v)\n     }"}, {"sha": "d00479194308b5f8475d66f54a1c7d9631a21325", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -17,7 +17,6 @@ use middle::trans::type_::Type;\n \n use std::libc::c_uint;\n use std::option;\n-use std::vec;\n \n pub trait ABIInfo {\n     fn compute_info(&self, atys: &[Type], rty: Type, ret_def: bool) -> FnType;\n@@ -37,7 +36,7 @@ pub struct FnType {\n \n impl FnType {\n     pub fn decl_fn(&self, decl: &fn(fnty: Type) -> ValueRef) -> ValueRef {\n-        let atys = vec::map(self.arg_tys, |t| t.ty);\n+        let atys = self.arg_tys.iter().transform(|t| t.ty).collect::<~[Type]>();\n         let rty = self.ret_ty.ty;\n         let fnty = Type::func(atys, &rty);\n         let llfn = decl(fnty);"}, {"sha": "5be8c63dba10d9482dda27e8bb03c741f05ab494", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -980,9 +980,9 @@ pub fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n \n     match bcx.fcx.param_substs {\n       Some(substs) => {\n-        do vec::map(params) |t| {\n+        do params.iter().transform |t| {\n             ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n-        }\n+        }.collect()\n       }\n       _ => params\n     }\n@@ -1006,9 +1006,11 @@ pub fn resolve_vtables_under_param_substs(tcx: ty::ctxt,\n                                           param_substs: Option<@param_substs>,\n                                           vts: typeck::vtable_res)\n     -> typeck::vtable_res {\n-    @vec::map(*vts, |ds|\n-      @vec::map(**ds, |d|\n-                resolve_vtable_under_param_substs(tcx, param_substs, copy *d)))\n+    @vts.iter().transform(|ds|\n+      @ds.iter().transform(\n+          |d| resolve_vtable_under_param_substs(tcx, param_substs, copy *d))\n+                          .collect::<~[typeck::vtable_origin]>())\n+        .collect::<~[typeck::vtable_param_res]>()\n }\n \n \n@@ -1029,9 +1031,9 @@ pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n         typeck::vtable_static(trait_id, tys, sub) => {\n             let tys = match param_substs {\n                 Some(substs) => {\n-                    do vec::map(tys) |t| {\n+                    do tys.iter().transform |t| {\n                         ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n-                    }\n+                    }.collect()\n                 }\n                 _ => tys\n             };"}, {"sha": "df197ded629ea6210c62e0dc6637a9a219388d08", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -588,8 +588,9 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         }\n         ast::expr_tup(ref args) => {\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n-            return trans_adt(bcx, repr, 0, args.mapi(|i, arg| (i, *arg)),\n-                             None, dest);\n+            let numbered_fields: ~[(uint, @ast::expr)] =\n+                args.iter().enumerate().transform(|(i, arg)| (i, *arg)).collect();\n+            return trans_adt(bcx, repr, 0, numbered_fields, None, dest);\n         }\n         ast::expr_lit(@codemap::spanned {node: ast::lit_str(s), _}) => {\n             return tvec::trans_lit_str(bcx, expr, s, dest);"}, {"sha": "ad48c30747edcc2dc1b68882817719b3ad74335b", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -30,7 +30,6 @@ use middle::ty::{FnSig};\n use middle::typeck;\n use util::ppaux::{Repr,ty_to_str};\n \n-use std::vec;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_map::path_name;\n@@ -62,12 +61,12 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     assert!(real_substs.tps.iter().all(|t| !ty::type_needs_infer(*t)));\n     let _icx = push_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n-    let substs = vec::map(real_substs.tps, |t| {\n+    let substs = real_substs.tps.iter().transform(|t| {\n         match normalize_for_monomorphization(ccx.tcx, *t) {\n           Some(t) => { must_cast = true; t }\n           None => *t\n         }\n-    });\n+    }).collect::<~[ty::t]>();\n \n     for real_substs.tps.iter().advance |s| { assert!(!ty::type_has_params(*s)); }\n     for substs.iter().advance |s| { assert!(!ty::type_has_params(*s)); }\n@@ -325,22 +324,22 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n                     vtables: Option<typeck::vtable_res>,\n                     impl_did_opt: Option<ast::def_id>,\n                     param_uses: Option<@~[type_use::type_uses]>) -> mono_id {\n-    let precise_param_ids = match vtables {\n+    // FIXME (possibly #5801): Need a lot of type hints to get\n+    // .collect() to work.\n+    let precise_param_ids: ~[(ty::t, Option<@~[mono_id]>)] = match vtables {\n       Some(vts) => {\n         debug!(\"make_mono_id vtables=%s substs=%s\",\n                vts.repr(ccx.tcx), substs.repr(ccx.tcx));\n-        vec::map_zip(*vts, substs, |vtable, subst| {\n+        vts.iter().zip(substs.iter()).transform(|(vtable, subst)| {\n             let v = vtable.map(|vt| meth::vtable_id(ccx, vt));\n             (*subst, if !v.is_empty() { Some(@v) } else { None })\n-        })\n-      }\n-      None => {\n-        vec::map(substs, |subst| (*subst, None))\n+        }).collect()\n       }\n+      None => substs.iter().transform(|subst| (*subst, None::<@~[mono_id]>)).collect()\n     };\n     let param_ids = match param_uses {\n       Some(ref uses) => {\n-        vec::map_zip(precise_param_ids, **uses, |id, uses| {\n+        precise_param_ids.iter().zip(uses.iter()).transform(|(id, uses)| {\n             if ccx.sess.no_monomorphic_collapse() {\n                 match copy *id {\n                     (a, b) => mono_precise(a, b)\n@@ -377,13 +376,13 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n                     }\n                 }\n             }\n-        })\n+        }).collect()\n       }\n       None => {\n-          precise_param_ids.map(|x| {\n+          precise_param_ids.iter().transform(|x| {\n               let (a, b) = copy *x;\n               mono_precise(a, b)\n-          })\n+          }).collect()\n       }\n     };\n     @mono_id_ {def: item, params: param_ids, impl_did_opt: impl_did_opt}"}, {"sha": "bbf548d2659a1e77c2e501be71ce07f305fd0ffa", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -3674,15 +3674,15 @@ pub fn substd_enum_variants(cx: ctxt,\n                             id: ast::def_id,\n                             substs: &substs)\n                          -> ~[VariantInfo] {\n-    do vec::map(*enum_variants(cx, id)) |variant_info| {\n-        let substd_args = vec::map(variant_info.args,\n-                                   |aty| subst(cx, substs, *aty));\n+    do enum_variants(cx, id).iter().transform |variant_info| {\n+        let substd_args = variant_info.args.iter()\n+            .transform(|aty| subst(cx, substs, *aty)).collect();\n \n         let substd_ctor_ty = subst(cx, substs, variant_info.ctor_ty);\n \n         @VariantInfo_{args: substd_args, ctor_ty: substd_ctor_ty,\n                       ../*bad*/copy **variant_info}\n-    }\n+    }.collect()\n }\n \n pub fn item_path_str(cx: ctxt, id: ast::def_id) -> ~str {\n@@ -3815,7 +3815,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n                     _\n                 }, _) => {\n             let mut disr_val = -1;\n-            @vec::map(enum_definition.variants, |variant| {\n+            @enum_definition.variants.iter().transform(|variant| {\n                 match variant.node.kind {\n                     ast::tuple_variant_kind(ref args) => {\n                         let ctor_ty = node_id_to_type(cx, variant.node.id);\n@@ -3848,7 +3848,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n                         fail!(\"struct variant kinds unimpl in enum_variants\")\n                     }\n                 }\n-            })\n+            }).collect()\n           }\n           _ => cx.sess.bug(\"tag_variants: id not bound to an enum\")\n         }"}, {"sha": "4d2849c521058a42faa3a3da503036256e0b21dc", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -718,14 +718,14 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n     let bound_lifetime_names = bound_lifetimes(this, lifetimes);\n     let rb = in_binding_rscope(rscope, RegionParamNames(copy bound_lifetime_names));\n \n-    let input_tys = do decl.inputs.mapi |i, a| {\n+    let input_tys = do decl.inputs.iter().enumerate().transform |(i, a)| {\n         let expected_arg_ty = do expected_sig.chain_ref |e| {\n             // no guarantee that the correct number of expected args\n             // were supplied\n             if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n         };\n         ty_of_arg(this, &rb, *a, expected_arg_ty)\n-    };\n+    }.collect();\n \n     let expected_ret_ty = expected_sig.map(|e| e.output);\n     let output_ty = match decl.output.node {"}, {"sha": "91b8f01f33623644d47bd6709ea163383e836ead", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -1781,7 +1781,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             _ => ()\n         }\n \n-        let tps = vec::map(tys, |ty| fcx.to_ty(*ty));\n+        let tps = tys.iter().transform(|ty| fcx.to_ty(*ty)).collect::<~[ty::t]>();\n         match method::lookup(fcx,\n                              expr,\n                              base,\n@@ -2766,7 +2766,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let mut bot_field = false;\n         let mut err_field = false;\n \n-        let elt_ts = do elts.mapi |i, e| {\n+        let elt_ts = do elts.iter().enumerate().transform |(i, e)| {\n             let opt_hint = match flds {\n                 Some(ref fs) if i < fs.len() => Some(fs[i]),\n                 _ => None\n@@ -2776,7 +2776,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             err_field = err_field || ty::type_is_error(t);\n             bot_field = bot_field || ty::type_is_bot(t);\n             t\n-        };\n+        }.collect();\n         if bot_field {\n             fcx.write_bot(id);\n         } else if err_field {"}, {"sha": "85bd2bc2d75ea28c1f5436cac7c8ce12693a43a0", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -712,7 +712,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n                     -> ~[ConvertedMethod]\n {\n     let tcx = ccx.tcx;\n-    return vec::map(ms, |m| {\n+    return ms.iter().transform(|m| {\n         let num_rcvr_ty_params = rcvr_ty_generics.type_param_defs.len();\n         let m_ty_generics =\n             ty_generics(ccx, rcvr_ty_generics.region_param, &m.generics,\n@@ -742,7 +742,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n         tcx.methods.insert(mty.def_id, mty);\n         ConvertedMethod {mty: mty, id: m.id,\n                          span: m.span, body_id: m.body.node.id}\n-    });\n+    }).collect();\n \n     fn ty_of_method(ccx: &CrateCtxt,\n                     m: &ast::method,"}, {"sha": "db17405fc26639cc70f082f75ec478bcbbbd8f30", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -1478,7 +1478,7 @@ impl RegionVarBindings {\n         // overlapping locations.\n         let mut dup_vec = graph.nodes.map(|_| uint::max_value);\n \n-        graph.nodes.mapi(|idx, node| {\n+        graph.nodes.iter().enumerate().transform(|(idx, node)| {\n             match node.value {\n                 Value(_) => {\n                     /* Inference successful */\n@@ -1528,7 +1528,7 @@ impl RegionVarBindings {\n             }\n \n             node.value\n-        })\n+        }).collect()\n     }\n \n     pub fn report_error_for_expanding_node(&mut self,"}, {"sha": "2a9442fbe525b51812c155c09b45e87457f47341", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -26,7 +26,6 @@ use fold::Fold;\n use fold;\n use pass::Pass;\n \n-use std::vec;\n use syntax::ast;\n use syntax::ast_map;\n \n@@ -124,7 +123,7 @@ fn fold_enum(\n     let doc = fold::default_seq_fold_enum(fold, doc);\n \n     doc::EnumDoc {\n-        variants: do vec::map(doc.variants) |variant| {\n+        variants: do doc.variants.iter().transform |variant| {\n             let variant = copy *variant;\n             let desc = {\n                 let variant = copy variant;\n@@ -153,7 +152,7 @@ fn fold_enum(\n                 desc: desc,\n                 .. variant\n             }\n-        },\n+        }.collect(),\n         .. doc\n     }\n }\n@@ -183,7 +182,7 @@ fn merge_method_attrs(\n             ast_map::node_item(@ast::item {\n                 node: ast::item_trait(_, _, ref methods), _\n             }, _) => {\n-                vec::map(*methods, |method| {\n+                methods.iter().transform(|method| {\n                     match copy *method {\n                         ast::required(ty_m) => {\n                             (to_str(ty_m.ident),\n@@ -193,29 +192,29 @@ fn merge_method_attrs(\n                             (to_str(m.ident), attr_parser::parse_desc(copy m.attrs))\n                         }\n                     }\n-                })\n+                }).collect()\n             }\n             ast_map::node_item(@ast::item {\n                 node: ast::item_impl(_, _, _, ref methods), _\n             }, _) => {\n-                vec::map(*methods, |method| {\n+                methods.iter().transform(|method| {\n                     (to_str(method.ident),\n                      attr_parser::parse_desc(copy method.attrs))\n-                })\n+                }).collect()\n             }\n             _ => fail!(\"unexpected item\")\n         }\n     };\n \n-    do vec::map_zip(docs, attrs) |doc, attrs| {\n+    do docs.iter().zip(attrs.iter()).transform |(doc, attrs)| {\n         assert!(doc.name == attrs.first());\n         let desc = attrs.second();\n \n         doc::MethodDoc {\n             desc: desc,\n             .. copy *doc\n         }\n-    }\n+    }.collect()\n }\n \n "}, {"sha": "d5d2b4ce6286cea90f1480af57b35880ad05be5d", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -186,7 +186,7 @@ fn enumdoc_from_enum(\n fn variantdocs_from_variants(\n     variants: ~[ast::variant]\n ) -> ~[doc::VariantDoc] {\n-    vec::map(variants, variantdoc_from_variant)\n+    variants.iter().transform(variantdoc_from_variant).collect()\n }\n \n fn variantdoc_from_variant(variant: &ast::variant) -> doc::VariantDoc {\n@@ -203,7 +203,7 @@ fn traitdoc_from_trait(\n ) -> doc::TraitDoc {\n     doc::TraitDoc {\n         item: itemdoc,\n-        methods: do vec::map(methods) |method| {\n+        methods: do methods.iter().transform |method| {\n             match copy *method {\n               ast::required(ty_m) => {\n                 doc::MethodDoc {\n@@ -226,7 +226,7 @@ fn traitdoc_from_trait(\n                 }\n               }\n             }\n-        }\n+        }.collect()\n     }\n }\n \n@@ -239,7 +239,7 @@ fn impldoc_from_impl(\n         bounds_str: None,\n         trait_types: ~[],\n         self_ty: None,\n-        methods: do vec::map(methods) |method| {\n+        methods: do methods.iter().transform |method| {\n             doc::MethodDoc {\n                 name: to_str(method.ident),\n                 brief: None,\n@@ -248,7 +248,7 @@ fn impldoc_from_impl(\n                 sig: None,\n                 implementation: doc::Provided,\n             }\n-        }\n+        }.collect()\n     }\n }\n "}, {"sha": "6510384ef01dd8877aaa58274ab2b898b8e53d37", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -13,8 +13,6 @@ use doc;\n #[cfg(test)] use extract;\n #[cfg(test)] use parse;\n \n-use std::vec;\n-\n pub struct Fold<T> {\n     ctxt: T,\n     fold_doc: FoldDoc<T>,\n@@ -155,7 +153,7 @@ pub fn default_par_fold<T:Clone>(ctxt: T) -> Fold<T> {\n \n pub fn default_seq_fold_doc<T>(fold: &Fold<T>, doc: doc::Doc) -> doc::Doc {\n     doc::Doc {\n-        pages: do vec::map(doc.pages) |page| {\n+        pages: do doc.pages.iter().transform |page| {\n             match copy *page {\n               doc::CratePage(doc) => {\n                 doc::CratePage((fold.fold_crate)(fold, doc))\n@@ -164,7 +162,7 @@ pub fn default_seq_fold_doc<T>(fold: &Fold<T>, doc: doc::Doc) -> doc::Doc {\n                 doc::ItemPage(fold_ItemTag(fold, doc))\n               }\n             }\n-        },\n+        }.collect(),\n         .. doc\n     }\n }\n@@ -191,9 +189,9 @@ pub fn default_any_fold_mod<T:Clone>(\n ) -> doc::ModDoc {\n     doc::ModDoc {\n         item: (fold.fold_item)(fold, copy doc.item),\n-        items: vec::map(doc.items, |ItemTag| {\n+        items: doc.items.iter().transform(|ItemTag| {\n             fold_ItemTag(fold, copy *ItemTag)\n-        }),\n+        }).collect(),\n         .. doc\n     }\n }\n@@ -204,9 +202,9 @@ pub fn default_seq_fold_mod<T>(\n ) -> doc::ModDoc {\n     doc::ModDoc {\n         item: (fold.fold_item)(fold, copy doc.item),\n-        items: vec::map(doc.items, |ItemTag| {\n+        items: doc.items.iter().transform(|ItemTag| {\n             fold_ItemTag(fold, copy *ItemTag)\n-        }),\n+        }).collect(),\n         .. doc\n     }\n }\n@@ -217,9 +215,9 @@ pub fn default_par_fold_mod<T:Clone>(\n ) -> doc::ModDoc {\n     doc::ModDoc {\n         item: (fold.fold_item)(fold, copy doc.item),\n-        items: vec::map(doc.items, |ItemTag| {\n+        items: doc.items.iter().transform(|ItemTag| {\n             fold_ItemTag(fold, copy *ItemTag)\n-        }),\n+        }).collect(),\n         .. doc\n     }\n }\n@@ -230,9 +228,9 @@ pub fn default_any_fold_nmod<T:Clone>(\n ) -> doc::NmodDoc {\n     doc::NmodDoc {\n         item: (fold.fold_item)(fold, copy doc.item),\n-        fns: vec::map(doc.fns, |FnDoc| {\n+        fns: doc.fns.iter().transform(|FnDoc| {\n             (fold.fold_fn)(fold, copy *FnDoc)\n-        }),\n+        }).collect(),\n         .. doc\n     }\n }\n@@ -243,9 +241,9 @@ pub fn default_seq_fold_nmod<T>(\n ) -> doc::NmodDoc {\n     doc::NmodDoc {\n         item: (fold.fold_item)(fold, copy doc.item),\n-        fns: vec::map(doc.fns, |FnDoc| {\n+        fns: doc.fns.iter().transform(|FnDoc| {\n             (fold.fold_fn)(fold, copy *FnDoc)\n-        }),\n+        }).collect(),\n         .. doc\n     }\n }\n@@ -256,9 +254,9 @@ pub fn default_par_fold_nmod<T:Clone>(\n ) -> doc::NmodDoc {\n     doc::NmodDoc {\n         item: (fold.fold_item)(fold, copy doc.item),\n-        fns: vec::map(doc.fns, |FnDoc| {\n+        fns: doc.fns.iter().transform(|FnDoc| {\n             (fold.fold_fn)(fold, copy *FnDoc)\n-        }),\n+        }).collect(),\n         .. doc\n     }\n }"}, {"sha": "e40bdb532da932e8fc228b9a6e5bbf910cee7c92", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -20,7 +20,6 @@ use fold::Fold;\n use fold;\n use pass::Pass;\n \n-use std::vec;\n use syntax::ast;\n use syntax::print::pprust;\n use syntax::parse::token;\n@@ -114,7 +113,7 @@ fn fold_enum(\n     let srv = fold.ctxt.clone();\n \n     doc::EnumDoc {\n-        variants: do vec::map(doc.variants) |variant| {\n+        variants: do doc.variants.iter().transform |variant| {\n             let sig = {\n                 let variant = copy *variant;\n                 do astsrv::exec(srv.clone()) |ctxt| {\n@@ -139,7 +138,7 @@ fn fold_enum(\n                 sig: Some(sig),\n                 .. copy *variant\n             }\n-        },\n+        }.collect(),\n         .. doc\n     }\n }\n@@ -159,12 +158,12 @@ fn merge_methods(\n     item_id: doc::AstId,\n     docs: ~[doc::MethodDoc]\n ) -> ~[doc::MethodDoc] {\n-    do vec::map(docs) |doc| {\n+    do docs.iter().transform |doc| {\n         doc::MethodDoc {\n             sig: get_method_sig(srv.clone(), item_id, copy doc.name),\n             .. copy *doc\n         }\n-    }\n+    }.collect()\n }\n \n fn get_method_sig("}, {"sha": "bdcad15f45c444fd9ad8bc70dbab1ec7fc869b6c", "filename": "src/libstd/io.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -1912,7 +1912,9 @@ mod tests {\n                 if len <= ivals.len() {\n                     assert_eq!(res.len(), len);\n                 }\n-                assert!(ivals.slice(0u, res.len()) == vec::map(res, |x| *x as int));\n+                for ivals.iter().zip(res.iter()).advance |(iv, c)| {\n+                    assert!(*iv == *c as int)\n+                }\n             }\n         }\n         let mut i = 0;"}, {"sha": "77befbf19aa92f9afb5fe3dc5782bb5f37b6d60a", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -85,8 +85,7 @@ pub trait IteratorUtil<A> {\n \n     // FIXME: #5898: should be called map\n     /// Creates a new iterator which will apply the specified function to each\n-    /// element returned by the first, yielding the mapped element instead. This\n-    /// similar to the `vec::map` function.\n+    /// element returned by the first, yielding the mapped element instead.\n     ///\n     /// # Example\n     ///"}, {"sha": "4570254627833a795cd49eeb9d9a296f17e6ec6b", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -14,6 +14,8 @@\n \n use kinds::Copy;\n use vec;\n+use vec::ImmutableVector;\n+use iterator::IteratorUtil;\n \n pub use self::inner::*;\n \n@@ -96,7 +98,7 @@ impl<'self,A:Copy,B:Copy> ExtendedTupleOps<A,B> for (&'self [A], &'self [B]) {\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n         match *self {\n             (ref a, ref b) => {\n-                vec::map_zip(*a, *b, f)\n+                a.iter().zip(b.iter()).transform(|(aa, bb)| f(aa, bb)).collect()\n             }\n         }\n     }\n@@ -116,7 +118,7 @@ impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n         match *self {\n             (ref a, ref b) => {\n-                vec::map_zip(*a, *b, f)\n+                a.iter().zip(b.iter()).transform(|(aa, bb)| f(aa, bb)).collect()\n             }\n         }\n     }"}, {"sha": "65f962c36ef8c312ad428b79e14b21f7831d0e05", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 18, "deletions": 113, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -365,15 +365,6 @@ pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n \n // Functional utilities\n \n-/// Apply a function to each element of a vector and return the results\n-pub fn map<T, U>(v: &[T], f: &fn(t: &T) -> U) -> ~[U] {\n-    let mut result = with_capacity(v.len());\n-    for v.iter().advance |elem| {\n-        result.push(f(elem));\n-    }\n-    result\n-}\n-\n /// Consumes a vector, mapping it into a different vector. This function takes\n /// ownership of the supplied vector `v`, moving each element into the closure\n /// provided to generate a new element. The vector of new elements is then\n@@ -388,16 +379,6 @@ pub fn map_consume<T, U>(v: ~[T], f: &fn(v: T) -> U) -> ~[U] {\n     }\n     result\n }\n-\n-/// Apply a function to each element of a vector and return the results\n-pub fn mapi<T, U>(v: &[T], f: &fn(uint, t: &T) -> U) -> ~[U] {\n-    let mut i = 0;\n-    do map(v) |e| {\n-        i += 1;\n-        f(i - 1, e)\n-    }\n-}\n-\n /**\n  * Apply a function to each element of a vector and return a concatenation\n  * of each result vector\n@@ -408,23 +389,6 @@ pub fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n     result\n }\n \n-/**\n- * Apply a function to each pair of elements and return the results.\n- * Equivalent to `map(zip(v0, v1), f)`.\n- */\n-pub fn map_zip<T:Copy,U:Copy,V>(v0: &[T], v1: &[U],\n-                                  f: &fn(t: &T, v: &U) -> V) -> ~[V] {\n-    let v0_len = v0.len();\n-    if v0_len != v1.len() { fail!(); }\n-    let mut u: ~[V] = ~[];\n-    let mut i = 0u;\n-    while i < v0_len {\n-        u.push(f(&v0[i], &v1[i]));\n-        i += 1u;\n-    }\n-    u\n-}\n-\n pub fn filter_map<T, U>(\n     v: ~[T],\n     f: &fn(t: T) -> Option<U>) -> ~[U]\n@@ -983,14 +947,13 @@ pub trait ImmutableVector<'self, T> {\n     fn last(&self) -> &'self T;\n     fn last_opt(&self) -> Option<&'self T>;\n     fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n-    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n-    fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n-    fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U];\n     fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n     fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n     unsafe fn unsafe_ref(&self, index: uint) -> *T;\n \n     fn bsearch(&self, f: &fn(&T) -> Ordering) -> Option<uint>;\n+\n+    fn map<U>(&self, &fn(t: &T) -> U) -> ~[U];\n }\n \n /// Extension methods for vectors\n@@ -1087,29 +1050,6 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         None\n     }\n \n-    /// Apply a function to each element of a vector and return the results\n-    #[inline]\n-    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n-\n-    /**\n-     * Apply a function to the index and value of each element in the vector\n-     * and return the results\n-     */\n-    fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U] {\n-        mapi(*self, f)\n-    }\n-\n-    #[inline]\n-    fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U] {\n-        let mut r = ~[];\n-        let mut i = 0;\n-        while i < self.len() {\n-            r.push(f(&self[i]));\n-            i += 1;\n-        }\n-        r\n-    }\n-\n     /**\n      * Apply a function to each element of a vector and return a concatenation\n      * of each result vector\n@@ -1165,6 +1105,13 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         }\n         return None;\n     }\n+\n+    /// Deprecated, use iterators where possible\n+    /// (`self.iter().transform(f)`). Apply a function to each element\n+    /// of a vector and return the results.\n+    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] {\n+        self.iter().transform(f).collect()\n+    }\n }\n \n #[allow(missing_doc)]\n@@ -2101,7 +2048,7 @@ pub mod bytes {\n impl<A:Clone> Clone for ~[A] {\n     #[inline]\n     fn clone(&self) -> ~[A] {\n-        self.map(|item| item.clone())\n+        self.iter().transform(|item| item.clone()).collect()\n     }\n }\n \n@@ -2648,16 +2595,16 @@ mod tests {\n     #[test]\n     fn test_map() {\n         // Test on-stack map.\n-        let mut v = ~[1u, 2u, 3u];\n-        let mut w = map(v, square_ref);\n+        let v = &[1u, 2u, 3u];\n+        let mut w = v.map(square_ref);\n         assert_eq!(w.len(), 3u);\n         assert_eq!(w[0], 1u);\n         assert_eq!(w[1], 4u);\n         assert_eq!(w[2], 9u);\n \n         // Test on-heap map.\n-        v = ~[1u, 2u, 3u, 4u, 5u];\n-        w = map(v, square_ref);\n+        let v = ~[1u, 2u, 3u, 4u, 5u];\n+        w = v.map(square_ref);\n         assert_eq!(w.len(), 5u);\n         assert_eq!(w[0], 1u);\n         assert_eq!(w[1], 4u);\n@@ -2666,17 +2613,6 @@ mod tests {\n         assert_eq!(w[4], 25u);\n     }\n \n-    #[test]\n-    fn test_map_zip() {\n-        fn times(x: &int, y: &int) -> int { *x * *y }\n-        let f = times;\n-        let v0 = ~[1, 2, 3, 4, 5];\n-        let v1 = ~[5, 4, 3, 2, 1];\n-        let u = map_zip::<int, int, int>(v0, v1, f);\n-        let mut i = 0;\n-        while i < 5 { assert!(v0[i] * v1[i] == u[i]); i += 1; }\n-    }\n-\n     #[test]\n     fn test_filter_mapped() {\n         // Test on-stack filter-map.\n@@ -2708,7 +2644,7 @@ mod tests {\n         let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n         let mix_dest: ~[int] = ~[1, 3, 0, 0];\n         assert!(filter_mapped(all_even, halve) ==\n-                     map(all_even, halve_for_sure));\n+                     all_even.map(halve_for_sure));\n         assert_eq!(filter_mapped(all_odd1, halve), ~[]);\n         assert_eq!(filter_mapped(all_odd2, halve), ~[]);\n         assert_eq!(filter_mapped(mix, halve), mix_dest);\n@@ -2746,7 +2682,7 @@ mod tests {\n         let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n         let mix_dest: ~[int] = ~[1, 3, 0, 0];\n         assert!(filter_map(all_even, halve) ==\n-                     map(all_even0, halve_for_sure));\n+                     all_even0.map(halve_for_sure));\n         assert_eq!(filter_map(all_odd1, halve), ~[]);\n         assert_eq!(filter_map(all_odd2, halve), ~[]);\n         assert_eq!(filter_map(mix, halve), mix_dest);\n@@ -3278,7 +3214,7 @@ mod tests {\n     fn test_map_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do map(v) |_elt| {\n+        do v.map |_elt| {\n             if i == 2 {\n                 fail!()\n             }\n@@ -3302,44 +3238,13 @@ mod tests {\n         };\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_mapi_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do mapi(v) |_i, _elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            ~[(~0, @0)]\n-        };\n-    }\n-\n     #[test]\n     #[ignore(windows)]\n     #[should_fail]\n     fn test_flat_map_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do map(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            ~[(~0, @0)]\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_map_zip_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do map_zip(v, v) |_elt1, _elt2| {\n+        do flat_map(v) |_elt| {\n             if i == 2 {\n                 fail!()\n             }"}, {"sha": "529d5bfe70b49f8a6c975024e209ba9433eb0b8a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -814,7 +814,7 @@ mod test {\n     // convert a list of uints to an @[ident]\n     // (ignores the interner completely)\n     fn uints_to_idents (uints: &~[uint]) -> @~[ident] {\n-        @uints.map(|u|{ ident {name:*u, ctxt: empty_ctxt} })\n+        @uints.map(|u| ident {name:*u, ctxt: empty_ctxt})\n     }\n \n     fn id (u : uint, s: SyntaxContext) -> ident {"}, {"sha": "405f9e3438beb1b23706c7089107577c1bcb0ba8", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -91,9 +91,9 @@ fn decodable_substructure(cx: @ExtCtxt, span: span,\n                     }\n                 }\n                 Right(ref fields) => {\n-                    let fields = do fields.mapi |i, f| {\n+                    let fields = do fields.iter().enumerate().transform |(i, f)| {\n                         cx.field_imm(span, *f, getarg(cx.str_of(*f), i))\n-                    };\n+                    }.collect();\n                     cx.expr_struct_ident(span, substr.type_ident, fields)\n                 }\n             };\n@@ -133,9 +133,9 @@ fn decodable_substructure(cx: @ExtCtxt, span: span,\n                         }\n                     }\n                     Right(ref fields) => {\n-                        let fields = do fields.mapi |i, f| {\n+                        let fields = do fields.iter().enumerate().transform |(i, f)| {\n                             cx.field_imm(span, *f, getarg(i))\n-                        };\n+                        }.collect();\n                         cx.expr_struct_ident(span, name, fields)\n                     }\n                 };"}, {"sha": "0e4fc9d96fa875cad58d3e626875b6aea3e6915e", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -591,14 +591,14 @@ impl<'self> MethodDef<'self> {\n         // transpose raw_fields\n         let fields = match raw_fields {\n             [self_arg, .. rest] => {\n-                do self_arg.mapi |i, &(opt_id, field)| {\n+                do self_arg.iter().enumerate().transform |(i, &(opt_id, field))| {\n                     let other_fields = do rest.map |l| {\n                         match &l[i] {\n                             &(_, ex) => ex\n                         }\n                     };\n                     (opt_id, field, other_fields)\n-                }\n+                }.collect()\n             }\n             [] => { cx.span_bug(span, \"No self arguments to non-static \\\n                                        method in generic `deriving`\") }\n@@ -745,10 +745,11 @@ impl<'self> MethodDef<'self> {\n                         }\n                     }\n                     let field_tuples =\n-                        do vec::map_zip(*self_vec,\n-                                        enum_matching_fields) |&(id, self_f), &other| {\n+                        do self_vec.iter()\n+                           .zip(enum_matching_fields.iter())\n+                           .transform |(&(id, self_f), &other)| {\n                         (id, self_f, other)\n-                    };\n+                    }.collect();\n                     substructure = EnumMatching(variant_index, variant, field_tuples);\n                 }\n                 None => {"}, {"sha": "cc2050d9bd7a0a31bc4ad4c2a5f23258af7de010", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -91,7 +91,7 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n             let rand_variant = cx.expr_binary(span, ast::rem,\n                                               rv_call, variant_count);\n \n-            let mut arms = do variants.mapi |i, id_sum| {\n+            let mut arms = do variants.iter().enumerate().transform |(i, id_sum)| {\n                 let i_expr = cx.expr_uint(span, i);\n                 let pat = cx.pat_lit(span, i_expr);\n \n@@ -102,7 +102,7 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n                                rand_thing(cx, span, ident, summary, || rand_call()))\n                     }\n                 }\n-            };\n+            }.collect::<~[ast::arm]>();\n \n             // _ => {} at the end. Should never occur\n             arms.push(cx.arm_unreachable(span));"}, {"sha": "0e24725ea990ce86e109e2c1a2f8c186c7280fe7", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -54,8 +54,9 @@ impl gen_send for message {\n             let next = this.proto.get_state(next_state.state);\n             assert!(next_state.tys.len() ==\n                 next.generics.ty_params.len());\n-            let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n-            let args_ast = vec::map_zip(arg_names, *tys, |n, t| cx.arg(span, *n, *t));\n+            let arg_names = vec::from_fn(tys.len(), |i| cx.ident_of(\"x_\"+i.to_str()));\n+            let args_ast: ~[ast::arg] = arg_names.iter().zip(tys.iter())\n+                .transform(|(n, t)| cx.arg(span, *n, *t)).collect();\n \n             let pipe_ty = cx.ty_path(\n                 path(~[this.data_name()], span)\n@@ -133,11 +134,10 @@ impl gen_send for message {\n \n             message(ref _id, span, ref tys, this, None) => {\n                 debug!(\"pipec: no next state\");\n-                let arg_names = tys.mapi(|i, _ty| (~\"x_\" + i.to_str()));\n+                let arg_names = vec::from_fn(tys.len(), |i| \"x_\" + i.to_str());\n \n-                let args_ast = do vec::map_zip(arg_names, *tys) |n, t| {\n-                    cx.arg(span, cx.ident_of(*n), *t)\n-                };\n+                let args_ast: ~[ast::arg] = arg_names.iter().zip(tys.iter())\n+                    .transform(|(n, t)| cx.arg(span, cx.ident_of(*n), *t)).collect();\n \n                 let args_ast = vec::append(\n                     ~[cx.arg(span,"}, {"sha": "f6325c2eb2c123819e826be1997dde393edcded9", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -21,7 +21,6 @@ use print::pprust;\n \n use std::io;\n use std::result;\n-use std::vec;\n \n // These macros all relate to the file system; they either return\n // the column/row/filename of the expression, or they include\n@@ -106,9 +105,7 @@ pub fn expand_include_bin(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n       result::Ok(src) => {\n-        let u8_exprs = vec::map(src, |char| {\n-            cx.expr_u8(sp, *char)\n-        });\n+        let u8_exprs: ~[@ast::expr] = src.iter().transform(|char| cx.expr_u8(sp, *char)).collect();\n         base::MRExpr(cx.expr_vec(sp, u8_exprs))\n       }\n       result::Err(ref e) => {"}, {"sha": "cddba3583734d9e1003b4eba8070e6d7224f7872", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -326,8 +326,7 @@ pub fn parse(\n                         cur_eis.push(new_ei);\n                     }\n \n-                    let matches = vec::map(ei.matches, // fresh, same size:\n-                                           |_m| ~[]);\n+                    let matches = vec::from_elem(ei.matches.len(), ~[]);\n                     let ei_t = ei;\n                     cur_eis.push(~MatcherPos {\n                         elts: copy *matchers,"}, {"sha": "4e1451239962f5937fe1069928f5f63ee4e11201", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -699,7 +699,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n // ...nor do modules\n pub fn noop_fold_mod(m: &_mod, fld: @ast_fold) -> _mod {\n     ast::_mod {\n-        view_items: vec::map(m.view_items, |x| fld.fold_view_item(*x)),\n+        view_items: m.view_items.iter().transform(|x| fld.fold_view_item(*x)).collect(),\n         items: vec::filter_mapped(m.items, |x| fld.fold_item(*x)),\n     }\n }\n@@ -708,8 +708,8 @@ fn noop_fold_foreign_mod(nm: &foreign_mod, fld: @ast_fold) -> foreign_mod {\n     ast::foreign_mod {\n         sort: nm.sort,\n         abis: nm.abis,\n-        view_items: vec::map(nm.view_items, |x| fld.fold_view_item(*x)),\n-        items: vec::map(nm.items, |x| fld.fold_foreign_item(*x)),\n+        view_items: nm.view_items.iter().transform(|x| fld.fold_view_item(*x)).collect(),\n+        items: nm.items.iter().transform(|x| fld.fold_foreign_item(*x)).collect(),\n     }\n }\n \n@@ -728,8 +728,8 @@ fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n         }\n         struct_variant_kind(struct_def) => {\n             kind = struct_variant_kind(@ast::struct_def {\n-                fields: vec::map(struct_def.fields,\n-                                 |f| fld.fold_struct_field(*f)),\n+                fields: struct_def.fields.iter()\n+                    .transform(|f| fld.fold_struct_field(*f)).collect(),\n                 ctor_id: struct_def.ctor_id.map(|c| fld.new_id(*c))\n             })\n         }\n@@ -824,8 +824,7 @@ impl ast_fold for AstFoldFns {\n        @view_item {\n         @ast::view_item {\n             node: (self.fold_view_item)(&x.node, self as @ast_fold),\n-            attrs: vec::map(x.attrs, |a|\n-                  fold_attribute_(*a, self as @ast_fold)),\n+            attrs: x.attrs.iter().transform(|a| fold_attribute_(*a, self as @ast_fold)).collect(),\n             vis: x.vis,\n             span: (self.new_span)(x.span),\n         }"}, {"sha": "bc5efc5fca1f0ad26156a01c5e9f33d513a8fe23", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -191,13 +191,13 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n         // Do the BFS.\n         info!(\"PBFS iteration %?\", i);\n         i += 1;\n-        colors = do colors.mapi() |i, c| {\n+        colors = do colors.iter().enumerate().transform |(i, c)| {\n             let c : color = *c;\n             match c {\n               white => {\n                 let i = i as node_id;\n \n-                let neighbors = copy graph[i];\n+                let neighbors = &graph[i];\n \n                 let mut color = white;\n \n@@ -214,17 +214,17 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n               gray(parent) => { black(parent) }\n               black(parent) => { black(parent) }\n             }\n-        }\n+        }.collect()\n     }\n \n     // Convert the results.\n-    do vec::map(colors) |c| {\n+    do colors.iter().transform |c| {\n         match *c {\n           white => { -1i64 }\n           black(parent) => { parent }\n           _ => { fail!(\"Found remaining gray nodes in BFS\") }\n         }\n-    }\n+    }.collect()\n }\n \n /// A parallel version of the bfs function."}, {"sha": "deb2d4b300bc625114bae1df65fe3aaef9eedbf8", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -152,7 +152,7 @@ fn rendezvous(nn: uint, set: ~[color]) {\n \n     // these channels will allow us to talk to each creature by 'name'/index\n     let to_creature: ~[Chan<Option<CreatureInfo>>] =\n-        vec::mapi(set, |ii, col| {\n+        set.iter().enumerate().transform(|(ii, col)| {\n             // create each creature as a listener with a port, and\n             // give us a channel to talk to each\n             let ii = ii;\n@@ -166,7 +166,7 @@ fn rendezvous(nn: uint, set: ~[color]) {\n                          to_rendezvous_log.clone());\n             }\n             to_creature\n-        });\n+        }).collect();\n \n     let mut creatures_met = 0;\n "}, {"sha": "974cdb0a0ef6320c7e6782e0ea74c9884fb32b3d", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-pretty (extra blank line is inserted in vec::mapi call)\n+// xfail-pretty the `let to_child` line gets an extra newline\n // multi tasking k-nucleotide\n \n extern mod extra;\n@@ -163,14 +163,13 @@ fn main() {\n \n \n \n-   // initialize each sequence sorter\n-   let sizes = ~[1,2,3,4,6,12,18];\n-    let streams = vec::map(sizes, |_sz| Some(stream()));\n-    let mut streams = streams;\n+    // initialize each sequence sorter\n+    let sizes = ~[1u,2,3,4,6,12,18];\n+    let mut streams = vec::from_fn(sizes.len(), |_| Some(stream::<~str>()));\n     let mut from_child = ~[];\n-    let to_child   = vec::mapi(sizes, |ii, sz| {\n+    let to_child   = do sizes.iter().zip(streams.mut_iter()).transform |(sz, stream_ref)| {\n         let sz = *sz;\n-        let stream = util::replace(&mut streams[ii], None);\n+        let stream = util::replace(stream_ref, None);\n         let (from_child_, to_parent_) = stream.unwrap();\n \n         from_child.push(from_child_);\n@@ -182,7 +181,7 @@ fn main() {\n         };\n \n         to_child\n-    });\n+    }.collect::<~[Chan<~[u8]>]>();\n \n \n    // latch stores true after we've started"}, {"sha": "e61de0ac11f4c45ad1e490a8bbff0d97b441c50b", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -30,7 +30,7 @@ use std::io::WriterUtil;\n \n // Make sure this import is warned about when at least one of its imported names\n // is unused\n-use std::vec::{filter, map};   //~ ERROR unused import\n+use std::vec::{filter, from_elem};   //~ ERROR unused import\n \n mod foo {\n     pub struct Point{x: int, y: int}\n@@ -58,7 +58,5 @@ fn main() {\n     let a = 3;\n     ignore(a);\n     io::stdout().write_str(\"a\");\n-    let _a = do map([2]) |&x| {\n-      x + 2\n-    };\n+    let _a = from_elem(0, 0);\n }"}, {"sha": "8ea2a88fa09a793319e26f9b25b6742f41d1413f", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -28,7 +28,7 @@ pub fn main() {\n     assert!(any_negative);\n \n     // Higher precedence than unary operations:\n-    let abs_v = do vec::map(v) |e| { e.abs() };\n+    let abs_v = do v.iter().transform |e| { e.abs() }.collect::<~[float]>();\n     assert!(do abs_v.iter().all |e| { e.is_positive() });\n     assert!(!do abs_v.iter().any_ |e| { e.is_negative() });\n "}, {"sha": "739dbab4d3af4f25e7e7d3abfc0f118df07c3bcd", "filename": "src/test/run-pass/block-vec-map_zip.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a396e1e2e95acc07f2804be2079d5b692753d4bb/src%2Ftest%2Frun-pass%2Fblock-vec-map_zip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a396e1e2e95acc07f2804be2079d5b692753d4bb/src%2Ftest%2Frun-pass%2Fblock-vec-map_zip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-vec-map_zip.rs?ref=a396e1e2e95acc07f2804be2079d5b692753d4bb", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::vec;\n-\n-pub fn main() {\n-    let v =\n-        vec::map_zip(~[1, 2, 3, 4, 5],\n-                  ~[true, false, false, true, true],\n-                  |i, b| if *b { -(*i) } else { *i } );\n-    error!(v.clone());\n-    assert_eq!(v, ~[-1, 2, 3, -4, -5]);\n-}"}, {"sha": "3e4cfdc105cadb966debf83ebfc0cae52902e073", "filename": "src/test/run-pass/trait-to-str.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a20d2929a7c0d6af0de899198df4f26453d877/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs?ref=c0a20d2929a7c0d6af0de899198df4f26453d877", "patch": "@@ -15,7 +15,9 @@\n extern mod std;\n \n use std::str::StrVector;\n-use std::{int, vec};\n+use std::vec::ImmutableVector;\n+use std::iterator::IteratorUtil;\n+use std::int;\n \n trait to_str {\n     fn to_str(&self) -> ~str;\n@@ -27,7 +29,7 @@ impl to_str for int {\n \n impl<T:to_str> to_str for ~[T] {\n     fn to_str(&self) -> ~str {\n-        ~\"[\" + vec::map(*self, |e| e.to_str()).connect(\", \") + \"]\"\n+        fmt!(\"[%s]\", self.iter().transform(|e| e.to_str()).collect::<~[~str]>().connect(\", \"))\n     }\n }\n "}]}