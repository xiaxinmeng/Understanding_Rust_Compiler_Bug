{"sha": "f837c730caaf5d7f1d9105e623a64f978dacea70", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4MzdjNzMwY2FhZjVkN2YxZDkxMDVlNjIzYTY0Zjk3OGRhY2VhNzA=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-01-30T00:46:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-30T00:46:42Z"}, "message": "Rollup merge of #68468 - ssomers:btreemap_prefer_middle, r=Mark-Simulacrum\n\nBTreeMap: tag and explain unsafe internal functions or assert preconditions\n\n#68418 concluded that it's not desirable to tag all internal functions with preconditions as being unsafe. This PR does it to some functions, documents why, and elsewhere enforces the preconditions with asserts.", "tree": {"sha": "635f66d2edaecab5a34a5f46614696b537d65bf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/635f66d2edaecab5a34a5f46614696b537d65bf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f837c730caaf5d7f1d9105e623a64f978dacea70", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeMidyCRBK7hj4Ov3rIwAAdHIIAHBOlY5ApG8t5QpxIPndIR7u\nMpAyR0iC7UbtI5XJz919cBaEqV+V7dvFcQE+x2BY7uz9RxFA1t71TkUkQoyM6AMl\nKuMjNJTL070YriEFltqqO8IjsXJ4YvjfHnrC20Hg0b2TDplgFWcaylBSO71hra/0\nMIzzUgmIOvgaOV20VG+Go5nxgVNpe9Urp4+MiOD4nbUEnuCRLuSnHJJzYl8vhvRv\nl7o4teCq58iqOHdIWh2TKbdnMvOWfSVY2yXDVr/crujmm/YZFFfD7KlBvUmAOcH6\n9B3IUhKDjMvTaqmSRdCTzEM22EGqafjho0f6Wq/Ys4lsN3NKdfmXLGmMRjXgK5Y=\n=mJ43\n-----END PGP SIGNATURE-----\n", "payload": "tree 635f66d2edaecab5a34a5f46614696b537d65bf3\nparent 12c9562486224afb083cbe04d846c3f02cffe8c2\nparent ba87a50332e2f0e636c97917df7d228ceefde5e4\nauthor Dylan DPC <dylan.dpc@gmail.com> 1580345202 +0100\ncommitter GitHub <noreply@github.com> 1580345202 +0100\n\nRollup merge of #68468 - ssomers:btreemap_prefer_middle, r=Mark-Simulacrum\n\nBTreeMap: tag and explain unsafe internal functions or assert preconditions\n\n#68418 concluded that it's not desirable to tag all internal functions with preconditions as being unsafe. This PR does it to some functions, documents why, and elsewhere enforces the preconditions with asserts.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f837c730caaf5d7f1d9105e623a64f978dacea70", "html_url": "https://github.com/rust-lang/rust/commit/f837c730caaf5d7f1d9105e623a64f978dacea70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f837c730caaf5d7f1d9105e623a64f978dacea70/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12c9562486224afb083cbe04d846c3f02cffe8c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/12c9562486224afb083cbe04d846c3f02cffe8c2", "html_url": "https://github.com/rust-lang/rust/commit/12c9562486224afb083cbe04d846c3f02cffe8c2"}, {"sha": "ba87a50332e2f0e636c97917df7d228ceefde5e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba87a50332e2f0e636c97917df7d228ceefde5e4", "html_url": "https://github.com/rust-lang/rust/commit/ba87a50332e2f0e636c97917df7d228ceefde5e4"}], "stats": {"total": 251, "additions": 132, "deletions": 119}, "files": [{"sha": "399df33d2b95a190c6331bd165db7bfeabdb75e6", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f837c730caaf5d7f1d9105e623a64f978dacea70/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f837c730caaf5d7f1d9105e623a64f978dacea70/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=f837c730caaf5d7f1d9105e623a64f978dacea70", "patch": "@@ -2096,8 +2096,13 @@ where\n             }\n         }\n \n-        let front = Handle::new_edge(min_node, min_edge);\n-        let back = Handle::new_edge(max_node, max_edge);\n+        // Safety guarantee: `min_edge` is always in range for `min_node`, because\n+        // `min_edge` is unconditionally calculated for each iteration's value of `min_node`,\n+        // either (if not found) as the edge index returned by `search_linear`,\n+        // or (if found) as the KV index returned by `search_linear`, possibly + 1.\n+        // Likewise for `max_node` versus `max_edge`.\n+        let front = unsafe { Handle::new_edge(min_node, min_edge) };\n+        let back = unsafe { Handle::new_edge(max_node, max_edge) };\n         match (front.force(), back.force()) {\n             (Leaf(f), Leaf(b)) => {\n                 return (f, b);"}, {"sha": "d85a263b5d54773b47ac5c0d00f63fd323483f2a", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 123, "deletions": 115, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/f837c730caaf5d7f1d9105e623a64f978dacea70/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f837c730caaf5d7f1d9105e623a64f978dacea70/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=f837c730caaf5d7f1d9105e623a64f978dacea70", "patch": "@@ -263,10 +263,10 @@ impl<K, V> Root<K, V> {\n \n     /// Removes the root node, using its first child as the new root. This cannot be called when\n     /// the tree consists only of a leaf node. As it is intended only to be called when the root\n-    /// has only one edge, no cleanup is done on any of the other children are elements of the root.\n+    /// has only one edge, no cleanup is done on any of the other children of the root.\n     /// This decreases the height by 1 and is the opposite of `push_level`.\n     pub fn pop_level(&mut self) {\n-        debug_assert!(self.height > 0);\n+        assert!(self.height > 0);\n \n         let top = self.node.ptr;\n \n@@ -344,6 +344,9 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Finds the length of the node. This is the number of keys or values. In an\n     /// internal node, the number of edges is `len() + 1`.\n+    /// For any node, the number of possible edge handles is also `len() + 1`.\n+    /// Note that, despite being safe, calling this function can have the side effect\n+    /// of invalidating mutable references that unsafe code has created.\n     pub fn len(&self) -> usize {\n         self.as_header().len as usize\n     }\n@@ -369,7 +372,8 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// If the node is a leaf, this function simply opens up its data.\n     /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n     /// (header, keys and values), and this function exposes that.\n-    /// See `NodeRef` on why the node may not be a shared root.\n+    /// Unsafe because the node must not be the shared root. For more information,\n+    /// see the `NodeRef` comments.\n     unsafe fn as_leaf(&self) -> &LeafNode<K, V> {\n         debug_assert!(!self.is_shared_root());\n         self.node.as_ref()\n@@ -385,14 +389,14 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n \n     /// Borrows a view into the keys stored in the node.\n-    /// The caller must ensure that the node is not the shared root.\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n     pub unsafe fn keys(&self) -> &[K] {\n         self.reborrow().into_key_slice()\n     }\n \n     /// Borrows a view into the values stored in the node.\n-    /// The caller must ensure that the node is not the shared root.\n-    fn vals(&self) -> &[V] {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn vals(&self) -> &[V] {\n         self.reborrow().into_val_slice()\n     }\n \n@@ -424,25 +428,26 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n \n     pub fn first_edge(self) -> Handle<Self, marker::Edge> {\n-        Handle::new_edge(self, 0)\n+        unsafe { Handle::new_edge(self, 0) }\n     }\n \n     pub fn last_edge(self) -> Handle<Self, marker::Edge> {\n         let len = self.len();\n-        Handle::new_edge(self, len)\n+        unsafe { Handle::new_edge(self, len) }\n     }\n \n     /// Note that `self` must be nonempty.\n     pub fn first_kv(self) -> Handle<Self, marker::KV> {\n-        debug_assert!(self.len() > 0);\n-        Handle::new_kv(self, 0)\n+        let len = self.len();\n+        assert!(len > 0);\n+        unsafe { Handle::new_kv(self, 0) }\n     }\n \n     /// Note that `self` must be nonempty.\n     pub fn last_kv(self) -> Handle<Self, marker::KV> {\n         let len = self.len();\n-        debug_assert!(len > 0);\n-        Handle::new_kv(self, len - 1)\n+        assert!(len > 0);\n+        unsafe { Handle::new_kv(self, len - 1) }\n     }\n }\n \n@@ -453,7 +458,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n     pub unsafe fn deallocate_and_ascend(\n         self,\n     ) -> Option<Handle<NodeRef<marker::Owned, K, V, marker::Internal>, marker::Edge>> {\n-        debug_assert!(!self.is_shared_root());\n+        assert!(!self.is_shared_root());\n         let node = self.node;\n         let ret = self.ascend().ok();\n         Global.dealloc(node.cast(), Layout::new::<LeafNode<K, V>>());\n@@ -508,36 +513,36 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         self.node.as_ptr()\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn keys_mut(&mut self) -> &mut [K] {\n-        unsafe { self.reborrow_mut().into_key_slice_mut() }\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn keys_mut(&mut self) -> &mut [K] {\n+        self.reborrow_mut().into_key_slice_mut()\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn vals_mut(&mut self) -> &mut [V] {\n-        unsafe { self.reborrow_mut().into_val_slice_mut() }\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn vals_mut(&mut self) -> &mut [V] {\n+        self.reborrow_mut().into_val_slice_mut()\n     }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    /// The caller must ensure that the node is not the shared root.\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n     unsafe fn into_key_slice(self) -> &'a [K] {\n         debug_assert!(!self.is_shared_root());\n         // We cannot be the shared root, so `as_leaf` is okay.\n         slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().keys), self.len())\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn into_val_slice(self) -> &'a [V] {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_val_slice(self) -> &'a [V] {\n         debug_assert!(!self.is_shared_root());\n         // We cannot be the shared root, so `as_leaf` is okay.\n-        unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n+        slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len())\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn into_slices(self) -> (&'a [K], &'a [V]) {\n-        let k = unsafe { ptr::read(&self) };\n-        (unsafe { k.into_key_slice() }, self.into_val_slice())\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_slices(self) -> (&'a [K], &'a [V]) {\n+        let k = ptr::read(&self);\n+        (k.into_key_slice(), self.into_val_slice())\n     }\n }\n \n@@ -548,54 +553,45 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         unsafe { &mut *(self.root as *mut Root<K, V>) }\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn into_key_slice_mut(mut self) -> &'a mut [K] {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_key_slice_mut(mut self) -> &'a mut [K] {\n         debug_assert!(!self.is_shared_root());\n         // We cannot be the shared root, so `as_leaf_mut` is okay.\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n-                self.len(),\n-            )\n-        }\n+        slice::from_raw_parts_mut(\n+            MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n+            self.len(),\n+        )\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn into_val_slice_mut(mut self) -> &'a mut [V] {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_val_slice_mut(mut self) -> &'a mut [V] {\n         debug_assert!(!self.is_shared_root());\n-        unsafe {\n-            slice::from_raw_parts_mut(\n-                MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n-                self.len(),\n-            )\n-        }\n+        slice::from_raw_parts_mut(\n+            MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n+            self.len(),\n+        )\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n         debug_assert!(!self.is_shared_root());\n         // We cannot use the getters here, because calling the second one\n         // invalidates the reference returned by the first.\n         // More precisely, it is the call to `len` that is the culprit,\n         // because that creates a shared reference to the header, which *can*\n         // overlap with the keys (and even the values, for ZST keys).\n-        unsafe {\n-            let len = self.len();\n-            let leaf = self.as_leaf_mut();\n-            let keys =\n-                slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).keys), len);\n-            let vals =\n-                slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len);\n-            (keys, vals)\n-        }\n+        let len = self.len();\n+        let leaf = self.as_leaf_mut();\n+        let keys = slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).keys), len);\n+        let vals = slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len);\n+        (keys, vals)\n     }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(self.len() < CAPACITY);\n+        assert!(self.len() < CAPACITY);\n         debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n@@ -610,8 +606,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n \n     /// Adds a key/value pair to the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(self.len() < CAPACITY);\n+        assert!(self.len() < CAPACITY);\n         debug_assert!(!self.is_shared_root());\n \n         unsafe {\n@@ -627,9 +622,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     /// Adds a key/value pair and an edge to go to the right of that pair to\n     /// the end of the node.\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(edge.height == self.height - 1);\n-        debug_assert!(self.len() < CAPACITY);\n+        assert!(edge.height == self.height - 1);\n+        assert!(self.len() < CAPACITY);\n         debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n@@ -645,23 +639,25 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         }\n     }\n \n-    fn correct_childrens_parent_links(&mut self, first: usize, after_last: usize) {\n+    // Unsafe because 'first' and 'after_last' must be in range\n+    unsafe fn correct_childrens_parent_links(&mut self, first: usize, after_last: usize) {\n+        debug_assert!(first <= self.len());\n+        debug_assert!(after_last <= self.len() + 1);\n         for i in first..after_last {\n-            Handle::new_edge(unsafe { self.reborrow_mut() }, i).correct_parent_link();\n+            Handle::new_edge(self.reborrow_mut(), i).correct_parent_link();\n         }\n     }\n \n     fn correct_all_childrens_parent_links(&mut self) {\n         let len = self.len();\n-        self.correct_childrens_parent_links(0, len + 1);\n+        unsafe { self.correct_childrens_parent_links(0, len + 1) };\n     }\n \n     /// Adds a key/value pair and an edge to go to the left of that pair to\n     /// the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(edge.height == self.height - 1);\n-        debug_assert!(self.len() < CAPACITY);\n+        assert!(edge.height == self.height - 1);\n+        assert!(self.len() < CAPACITY);\n         debug_assert!(!self.is_shared_root());\n \n         unsafe {\n@@ -687,8 +683,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     /// Removes a key/value pair from the end of this node. If this is an internal node,\n     /// also removes the edge that was to the right of that pair.\n     pub fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(self.len() > 0);\n+        assert!(self.len() > 0);\n \n         let idx = self.len() - 1;\n \n@@ -714,8 +709,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     /// Removes a key/value pair from the beginning of this node. If this is an internal node,\n     /// also removes the edge that was to the left of that pair.\n     pub fn pop_front(&mut self) -> (K, V, Option<Root<K, V>>) {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(self.len() > 0);\n+        assert!(self.len() > 0);\n \n         let old_len = self.len();\n \n@@ -750,8 +744,8 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n-    /// The caller must ensure that the node is not the shared root.\n-    fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n+    /// Unsafe because the caller must ensure that the node is not the shared root.\n+    unsafe fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n         (self.keys_mut().as_mut_ptr(), self.vals_mut().as_mut_ptr())\n     }\n }\n@@ -813,20 +807,20 @@ impl<Node, Type> Handle<Node, Type> {\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV> {\n-    /// Creates a new handle to a key/value pair in `node`. `idx` must be less than `node.len()`.\n-    pub fn new_kv(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n-        // Necessary for correctness, but in a private module\n+    /// Creates a new handle to a key/value pair in `node`.\n+    /// Unsafe because the caller must ensure that `idx < node.len()`.\n+    pub unsafe fn new_kv(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         debug_assert!(idx < node.len());\n \n         Handle { node, idx, _marker: PhantomData }\n     }\n \n     pub fn left_edge(self) -> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n-        Handle::new_edge(self.node, self.idx)\n+        unsafe { Handle::new_edge(self.node, self.idx) }\n     }\n \n     pub fn right_edge(self) -> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n-        Handle::new_edge(self.node, self.idx + 1)\n+        unsafe { Handle::new_edge(self.node, self.idx + 1) }\n     }\n }\n \n@@ -868,21 +862,28 @@ impl<'a, K, V, NodeType, HandleType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeT\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n-    /// Creates a new handle to an edge in `node`. `idx` must be less than or equal to\n-    /// `node.len()`.\n-    pub fn new_edge(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n-        // Necessary for correctness, but in a private module\n+    /// Creates a new handle to an edge in `node`.\n+    /// Unsafe because the caller must ensure that `idx <= node.len()`.\n+    pub unsafe fn new_edge(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n         debug_assert!(idx <= node.len());\n \n         Handle { node, idx, _marker: PhantomData }\n     }\n \n     pub fn left_kv(self) -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {\n-        if self.idx > 0 { Ok(Handle::new_kv(self.node, self.idx - 1)) } else { Err(self) }\n+        if self.idx > 0 {\n+            Ok(unsafe { Handle::new_kv(self.node, self.idx - 1) })\n+        } else {\n+            Err(self)\n+        }\n     }\n \n     pub fn right_kv(self) -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {\n-        if self.idx < self.node.len() { Ok(Handle::new_kv(self.node, self.idx)) } else { Err(self) }\n+        if self.idx < self.node.len() {\n+            Ok(unsafe { Handle::new_kv(self.node, self.idx) })\n+        } else {\n+            Err(self)\n+        }\n     }\n }\n \n@@ -914,9 +915,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     pub fn insert(mut self, key: K, val: V) -> (InsertResult<'a, K, V, marker::Leaf>, *mut V) {\n         if self.node.len() < CAPACITY {\n             let ptr = self.insert_fit(key, val);\n-            (InsertResult::Fit(Handle::new_kv(self.node, self.idx)), ptr)\n+            let kv = unsafe { Handle::new_kv(self.node, self.idx) };\n+            (InsertResult::Fit(kv), ptr)\n         } else {\n-            let middle = Handle::new_kv(self.node, B);\n+            let middle = unsafe { Handle::new_kv(self.node, B) };\n             let (mut left, k, v, mut right) = middle.split();\n             let ptr = if self.idx <= B {\n                 unsafe { Handle::new_edge(left.reborrow_mut(), self.idx).insert_fit(key, val) }\n@@ -991,14 +993,14 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         val: V,\n         edge: Root<K, V>,\n     ) -> InsertResult<'a, K, V, marker::Internal> {\n-        // Necessary for correctness, but this is an internal module\n-        debug_assert!(edge.height == self.node.height - 1);\n+        assert!(edge.height == self.node.height - 1);\n \n         if self.node.len() < CAPACITY {\n             self.insert_fit(key, val, edge);\n-            InsertResult::Fit(Handle::new_kv(self.node, self.idx))\n+            let kv = unsafe { Handle::new_kv(self.node, self.idx) };\n+            InsertResult::Fit(kv)\n         } else {\n-            let middle = Handle::new_kv(self.node, B);\n+            let middle = unsafe { Handle::new_kv(self.node, B) };\n             let (mut left, k, v, mut right) = middle.split();\n             if self.idx <= B {\n                 unsafe {\n@@ -1037,15 +1039,19 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marke\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_kv(self) -> (&'a K, &'a V) {\n-        let (keys, vals) = self.node.into_slices();\n-        unsafe { (keys.get_unchecked(self.idx), vals.get_unchecked(self.idx)) }\n+        unsafe {\n+            let (keys, vals) = self.node.into_slices();\n+            (keys.get_unchecked(self.idx), vals.get_unchecked(self.idx))\n+        }\n     }\n }\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_kv_mut(self) -> (&'a mut K, &'a mut V) {\n-        let (keys, vals) = self.node.into_slices_mut();\n-        unsafe { (keys.get_unchecked_mut(self.idx), vals.get_unchecked_mut(self.idx)) }\n+        unsafe {\n+            let (keys, vals) = self.node.into_slices_mut();\n+            (keys.get_unchecked_mut(self.idx), vals.get_unchecked_mut(self.idx))\n+        }\n     }\n }\n \n@@ -1067,7 +1073,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     /// - All the key/value pairs to the right of this handle are put into a newly\n     ///   allocated node.\n     pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n-        debug_assert!(!self.node.is_shared_root());\n+        assert!(!self.node.is_shared_root());\n         unsafe {\n             let mut new_node = Box::new(LeafNode::new());\n \n@@ -1099,7 +1105,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     pub fn remove(\n         mut self,\n     ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n-        debug_assert!(!self.node.is_shared_root());\n+        assert!(!self.node.is_shared_root());\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n             let v = slice_remove(self.node.vals_mut(), self.idx);\n@@ -1182,7 +1188,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         let right_len = right_node.len();\n \n         // necessary for correctness, but in a private module\n-        debug_assert!(left_len + right_len + 1 <= CAPACITY);\n+        assert!(left_len + right_len + 1 <= CAPACITY);\n \n         unsafe {\n             ptr::write(\n@@ -1281,8 +1287,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             let right_len = right_node.len();\n \n             // Make sure that we may steal safely.\n-            debug_assert!(right_len + count <= CAPACITY);\n-            debug_assert!(left_len >= count);\n+            assert!(right_len + count <= CAPACITY);\n+            assert!(left_len >= count);\n \n             let new_left_len = left_len - count;\n \n@@ -1338,8 +1344,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             let right_len = right_node.len();\n \n             // Make sure that we may steal safely.\n-            debug_assert!(left_len + count <= CAPACITY);\n-            debug_assert!(right_len >= count);\n+            assert!(left_len + count <= CAPACITY);\n+            assert!(right_len >= count);\n \n             let new_right_len = right_len - count;\n \n@@ -1447,24 +1453,26 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n             let right_new_len = left_node.len() - left_new_len;\n             let mut right_node = right.reborrow_mut();\n \n-            debug_assert!(right_node.len() == 0);\n-            debug_assert!(left_node.height == right_node.height);\n+            assert!(right_node.len() == 0);\n+            assert!(left_node.height == right_node.height);\n \n-            let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n-            let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n+            if right_new_len > 0 {\n+                let left_kv = left_node.reborrow_mut().into_kv_pointers_mut();\n+                let right_kv = right_node.reborrow_mut().into_kv_pointers_mut();\n \n-            move_kv(left_kv, left_new_len, right_kv, 0, right_new_len);\n+                move_kv(left_kv, left_new_len, right_kv, 0, right_new_len);\n \n-            (*left_node.reborrow_mut().as_leaf_mut()).len = left_new_len as u16;\n-            (*right_node.reborrow_mut().as_leaf_mut()).len = right_new_len as u16;\n+                (*left_node.reborrow_mut().as_leaf_mut()).len = left_new_len as u16;\n+                (*right_node.reborrow_mut().as_leaf_mut()).len = right_new_len as u16;\n \n-            match (left_node.force(), right_node.force()) {\n-                (ForceResult::Internal(left), ForceResult::Internal(right)) => {\n-                    move_edges(left, left_new_len + 1, right, 1, right_new_len);\n-                }\n-                (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n-                _ => {\n-                    unreachable!();\n+                match (left_node.force(), right_node.force()) {\n+                    (ForceResult::Internal(left), ForceResult::Internal(right)) => {\n+                        move_edges(left, left_new_len + 1, right, 1, right_new_len);\n+                    }\n+                    (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n+                    _ => {\n+                        unreachable!();\n+                    }\n                 }\n             }\n         }"}, {"sha": "e680e364147472ecfe5fdbf3f75dc83769ecbb48", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f837c730caaf5d7f1d9105e623a64f978dacea70/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f837c730caaf5d7f1d9105e623a64f978dacea70/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=f837c730caaf5d7f1d9105e623a64f978dacea70", "patch": "@@ -41,8 +41,8 @@ where\n     K: Borrow<Q>,\n {\n     match search_linear(&node, key) {\n-        (idx, true) => Found(Handle::new_kv(node, idx)),\n-        (idx, false) => SearchResult::GoDown(Handle::new_edge(node, idx)),\n+        (idx, true) => Found(unsafe { Handle::new_kv(node, idx) }),\n+        (idx, false) => SearchResult::GoDown(unsafe { Handle::new_edge(node, idx) }),\n     }\n }\n "}]}