{"sha": "d93df5775cbbd076bf438a4063c5c98a6293addf", "node_id": "C_kwDOAAsO6NoAKGQ5M2RmNTc3NWNiYmQwNzZiZjQzOGE0MDYzYzVjOThhNjI5M2FkZGY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-01T09:50:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-01T09:50:20Z"}, "message": "Rollup merge of #91207 - richkadel:rk-bump-coverage-version, r=tmandry\n\nAdd support for LLVM coverage mapping format versions 5 and 6\n\nThis PR cherry-pick's Swatinem's initial commit in unsubmitted PR #90047.\n\nMy additional commit augments Swatinem's great starting point, but adds full support for LLVM\nCoverage Mapping Format version 6, conditionally, if compiling with LLVM 13.\n\nVersion 6 requires adding the compilation directory when file paths are\nrelative, and since Rustc coverage maps use relative paths, we should\nadd the expected compilation directory entry.\n\nNote, however, that with the compilation directory, coverage reports\nfrom `llvm-cov show` can now report file names (when the report includes\nmore than one file) with the full absolute path to the file.\n\nThis would be a problem for test results, but the workaround (for the\nrust coverage tests) is to include an additional `llvm-cov show`\nparameter: `--compilation-dir=.`", "tree": {"sha": "b7471352a41558a6110108957bd3952a863572a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7471352a41558a6110108957bd3952a863572a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d93df5775cbbd076bf438a4063c5c98a6293addf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhp0VdCRBK7hj4Ov3rIwAAL2oIAGugL5UDT3Zmf0IJvhkoecpA\nglBtYVyvOd3MEjFq9gR7yqiu58LuiIM5lCnI6PG42ip/FU2sE7SopW5yBQXRE34y\niLmEXrGaL1G8WcHqY2JTSZujTdiF9utwVpu0kCg/D8XqsAxK+uXkFFVhk/nYVDWL\n4INoQQ/f4v0HECsJ3dFkMOQ/v2DC9+LtIK33tkK5bMRo4PgwM4k1ebzSBcLlNsx7\nZI9xBGJUOnzrsKt7tZVpjzI2aZC24UkQQ5BV9bFJhySuXt5NyvYNrEmTKXNBL6Tb\nNAzNXAhiApmdErsjn3vqIrMammkxi5lMxO7vGq9aGgZXW+D3j7rrtdzM1jcPr7s=\n=EAUg\n-----END PGP SIGNATURE-----\n", "payload": "tree b7471352a41558a6110108957bd3952a863572a6\nparent 2695e85c09cc70736c0e473d640bcfbf03055f46\nparent 0c57fab5fcd19244df6fa946bb504ce0601b29d1\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1638352220 +0100\ncommitter GitHub <noreply@github.com> 1638352220 +0100\n\nRollup merge of #91207 - richkadel:rk-bump-coverage-version, r=tmandry\n\nAdd support for LLVM coverage mapping format versions 5 and 6\n\nThis PR cherry-pick's Swatinem's initial commit in unsubmitted PR #90047.\n\nMy additional commit augments Swatinem's great starting point, but adds full support for LLVM\nCoverage Mapping Format version 6, conditionally, if compiling with LLVM 13.\n\nVersion 6 requires adding the compilation directory when file paths are\nrelative, and since Rustc coverage maps use relative paths, we should\nadd the expected compilation directory entry.\n\nNote, however, that with the compilation directory, coverage reports\nfrom `llvm-cov show` can now report file names (when the report includes\nmore than one file) with the full absolute path to the file.\n\nThis would be a problem for test results, but the workaround (for the\nrust coverage tests) is to include an additional `llvm-cov show`\nparameter: `--compilation-dir=.`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d93df5775cbbd076bf438a4063c5c98a6293addf", "html_url": "https://github.com/rust-lang/rust/commit/d93df5775cbbd076bf438a4063c5c98a6293addf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d93df5775cbbd076bf438a4063c5c98a6293addf/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2695e85c09cc70736c0e473d640bcfbf03055f46", "url": "https://api.github.com/repos/rust-lang/rust/commits/2695e85c09cc70736c0e473d640bcfbf03055f46", "html_url": "https://github.com/rust-lang/rust/commit/2695e85c09cc70736c0e473d640bcfbf03055f46"}, {"sha": "0c57fab5fcd19244df6fa946bb504ce0601b29d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c57fab5fcd19244df6fa946bb504ce0601b29d1", "html_url": "https://github.com/rust-lang/rust/commit/0c57fab5fcd19244df6fa946bb504ce0601b29d1"}], "stats": {"total": 125, "additions": 101, "deletions": 24}, "files": [{"sha": "0390caaec33e55ef40f8710c521cd56134837e88", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d93df5775cbbd076bf438a4063c5c98a6293addf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d93df5775cbbd076bf438a4063c5c98a6293addf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=d93df5775cbbd076bf438a4063c5c98a6293addf", "patch": "@@ -9,6 +9,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_hir::def_id::{DefId, DefIdSet};\n use rustc_llvm::RustString;\n use rustc_middle::mir::coverage::CodeRegion;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::Symbol;\n \n use std::ffi::CString;\n@@ -17,10 +18,11 @@ use tracing::debug;\n \n /// Generates and exports the Coverage Map.\n ///\n-/// This Coverage Map complies with Coverage Mapping Format version 4 (zero-based encoded as 3),\n-/// as defined at [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format)\n-/// and published in Rust's November 2020 fork of LLVM. This version is supported by the LLVM\n-/// coverage tools (`llvm-profdata` and `llvm-cov`) bundled with Rust's fork of LLVM.\n+/// Rust Coverage Map generation supports LLVM Coverage Mapping Format versions\n+/// 5 (LLVM 12, only) and 6 (zero-based encoded as 4 and 5, respectively), as defined at\n+/// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n+/// These versions are supported by the LLVM coverage tools (`llvm-profdata` and `llvm-cov`)\n+/// bundled with Rust's fork of LLVM.\n ///\n /// Consequently, Rust's bundled version of Clang also generates Coverage Maps compliant with\n /// the same version. Clang's implementation of Coverage Map generation was referenced when\n@@ -30,11 +32,12 @@ use tracing::debug;\n pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n     let tcx = cx.tcx;\n \n-    // Ensure LLVM supports Coverage Map Version 4 (encoded as a zero-based value: 3).\n-    // If not, the LLVM Version must be less than 11.\n+    // Ensure the installed version of LLVM supports at least Coverage Map\n+    // Version 5 (encoded as a zero-based value: 4), which was introduced with\n+    // LLVM 12.\n     let version = coverageinfo::mapping_version();\n-    if version != 3 {\n-        tcx.sess.fatal(\"rustc option `-Z instrument-coverage` requires LLVM 11 or higher.\");\n+    if version < 4 {\n+        tcx.sess.fatal(\"rustc option `-Z instrument-coverage` requires LLVM 12 or higher.\");\n     }\n \n     debug!(\"Generating coverage map for CodegenUnit: `{}`\", cx.codegen_unit.name());\n@@ -57,7 +60,7 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n         return;\n     }\n \n-    let mut mapgen = CoverageMapGenerator::new();\n+    let mut mapgen = CoverageMapGenerator::new(tcx, version);\n \n     // Encode coverage mappings and generate function records\n     let mut function_data = Vec::new();\n@@ -112,8 +115,26 @@ struct CoverageMapGenerator {\n }\n \n impl CoverageMapGenerator {\n-    fn new() -> Self {\n-        Self { filenames: FxIndexSet::default() }\n+    fn new(tcx: TyCtxt<'_>, version: u32) -> Self {\n+        let mut filenames = FxIndexSet::default();\n+        if version >= 5 {\n+            // LLVM Coverage Mapping Format version 6 (zero-based encoded as 5)\n+            // requires setting the first filename to the compilation directory.\n+            // Since rustc generates coverage maps with relative paths, the\n+            // compilation directory can be combined with the the relative paths\n+            // to get absolute paths, if needed.\n+            let working_dir = tcx\n+                .sess\n+                .opts\n+                .working_dir\n+                .remapped_path_if_available()\n+                .to_string_lossy()\n+                .to_string();\n+            let c_filename =\n+                CString::new(working_dir).expect(\"null error converting filename to C string\");\n+            filenames.insert(c_filename);\n+        }\n+        Self { filenames }\n     }\n \n     /// Using the `expressions` and `counter_regions` collected for the current function, generate"}, {"sha": "2ef4c871825cbdc6f28881a01aac9abe43677033", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d93df5775cbbd076bf438a4063c5c98a6293addf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d93df5775cbbd076bf438a4063c5c98a6293addf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=d93df5775cbbd076bf438a4063c5c98a6293addf", "patch": "@@ -685,7 +685,7 @@ pub type InlineAsmDiagHandlerTy = unsafe extern \"C\" fn(&SMDiagnostic, *const c_v\n pub mod coverageinfo {\n     use super::coverage_map;\n \n-    /// Aligns with [llvm::coverage::CounterMappingRegion::RegionKind](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L206-L222)\n+    /// Aligns with [llvm::coverage::CounterMappingRegion::RegionKind](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L209-L230)\n     #[derive(Copy, Clone, Debug)]\n     #[repr(C)]\n     pub enum RegionKind {\n@@ -704,11 +704,16 @@ pub mod coverageinfo {\n         /// A GapRegion is like a CodeRegion, but its count is only set as the\n         /// line execution count when its the only region in the line.\n         GapRegion = 3,\n+\n+        /// A BranchRegion represents leaf-level boolean expressions and is\n+        /// associated with two counters, each representing the number of times the\n+        /// expression evaluates to true or false.\n+        BranchRegion = 4,\n     }\n \n     /// This struct provides LLVM's representation of a \"CoverageMappingRegion\", encoded into the\n     /// coverage map, in accordance with the\n-    /// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n+    /// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n     /// The struct composes fields representing the `Counter` type and value(s) (injected counter\n     /// ID, or expression type and operands), the source file (an indirect index into a \"filenames\n     /// array\", encoded separately), and source location (start and end positions of the represented\n@@ -721,6 +726,10 @@ pub mod coverageinfo {\n         /// The counter type and type-dependent counter data, if any.\n         counter: coverage_map::Counter,\n \n+        /// If the `RegionKind` is a `BranchRegion`, this represents the counter\n+        /// for the false branch of the region.\n+        false_counter: coverage_map::Counter,\n+\n         /// An indirect reference to the source filename. In the LLVM Coverage Mapping Format, the\n         /// file_id is an index into a function-specific `virtual_file_mapping` array of indexes\n         /// that, in turn, are used to look up the filename for this region.\n@@ -758,6 +767,7 @@ pub mod coverageinfo {\n         ) -> Self {\n             Self {\n                 counter,\n+                false_counter: coverage_map::Counter::zero(),\n                 file_id,\n                 expanded_file_id: 0,\n                 start_line,\n@@ -768,6 +778,31 @@ pub mod coverageinfo {\n             }\n         }\n \n+        // This function might be used in the future; the LLVM API is still evolving, as is coverage\n+        // support.\n+        #[allow(dead_code)]\n+        crate fn branch_region(\n+            counter: coverage_map::Counter,\n+            false_counter: coverage_map::Counter,\n+            file_id: u32,\n+            start_line: u32,\n+            start_col: u32,\n+            end_line: u32,\n+            end_col: u32,\n+        ) -> Self {\n+            Self {\n+                counter,\n+                false_counter,\n+                file_id,\n+                expanded_file_id: 0,\n+                start_line,\n+                start_col,\n+                end_line,\n+                end_col,\n+                kind: RegionKind::BranchRegion,\n+            }\n+        }\n+\n         // This function might be used in the future; the LLVM API is still evolving, as is coverage\n         // support.\n         #[allow(dead_code)]\n@@ -781,6 +816,7 @@ pub mod coverageinfo {\n         ) -> Self {\n             Self {\n                 counter: coverage_map::Counter::zero(),\n+                false_counter: coverage_map::Counter::zero(),\n                 file_id,\n                 expanded_file_id,\n                 start_line,\n@@ -803,6 +839,7 @@ pub mod coverageinfo {\n         ) -> Self {\n             Self {\n                 counter: coverage_map::Counter::zero(),\n+                false_counter: coverage_map::Counter::zero(),\n                 file_id,\n                 expanded_file_id: 0,\n                 start_line,\n@@ -826,6 +863,7 @@ pub mod coverageinfo {\n         ) -> Self {\n             Self {\n                 counter,\n+                false_counter: coverage_map::Counter::zero(),\n                 file_id,\n                 expanded_file_id: 0,\n                 start_line,"}, {"sha": "e288760a02b186612249db0225f4ec2a42a57ee4", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/ffi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d93df5775cbbd076bf438a4063c5c98a6293addf/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d93df5775cbbd076bf438a4063c5c98a6293addf/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs?ref=d93df5775cbbd076bf438a4063c5c98a6293addf", "patch": "@@ -1,6 +1,6 @@\n use rustc_middle::mir::coverage::{CounterValueReference, MappedExpressionIndex};\n \n-/// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L206-L222)\n+/// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L95)\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub enum CounterKind {\n@@ -17,7 +17,7 @@ pub enum CounterKind {\n ///     `instrprof.increment()`)\n ///   * For `CounterKind::Expression`, `id` is the index into the coverage map's array of\n ///     counter expressions.\n-/// Aligns with [llvm::coverage::Counter](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L99-L100)\n+/// Aligns with [llvm::coverage::Counter](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L102-L103)\n /// Important: The Rust struct layout (order and types of fields) must match its C++ counterpart.\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n@@ -59,15 +59,15 @@ impl Counter {\n     }\n }\n \n-/// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L147)\n+/// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L150)\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub enum ExprKind {\n     Subtract = 0,\n     Add = 1,\n }\n \n-/// Aligns with [llvm::coverage::CounterExpression](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L148-L149)\n+/// Aligns with [llvm::coverage::CounterExpression](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L151-L152)\n /// Important: The Rust struct layout (order and types of fields) must match its C++\n /// counterpart.\n #[derive(Copy, Clone, Debug)]"}, {"sha": "154f554d607dfb60af9afaa03d54952f96d4a178", "filename": "compiler/rustc_llvm/llvm-wrapper/CoverageMappingWrapper.cpp", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d93df5775cbbd076bf438a4063c5c98a6293addf/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d93df5775cbbd076bf438a4063c5c98a6293addf/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp?ref=d93df5775cbbd076bf438a4063c5c98a6293addf", "patch": "@@ -10,6 +10,7 @@ using namespace llvm;\n \n struct LLVMRustCounterMappingRegion {\n   coverage::Counter Count;\n+  coverage::Counter FalseCount;\n   uint32_t FileID;\n   uint32_t ExpandedFileID;\n   uint32_t LineStart;\n@@ -53,7 +54,7 @@ extern \"C\" void LLVMRustCoverageWriteMappingToBuffer(\n   MappingRegions.reserve(NumMappingRegions);\n   for (const auto &Region : makeArrayRef(RustMappingRegions, NumMappingRegions)) {\n     MappingRegions.emplace_back(\n-        Region.Count, Region.FileID, Region.ExpandedFileID,\n+        Region.Count, Region.FalseCount, Region.FileID, Region.ExpandedFileID,\n         Region.LineStart, Region.ColumnStart, Region.LineEnd, Region.ColumnEnd,\n         Region.Kind);\n   }\n@@ -108,5 +109,9 @@ extern \"C\" void LLVMRustCoverageWriteMappingVarNameToString(RustStringRef Str) {\n }\n \n extern \"C\" uint32_t LLVMRustCoverageMappingVersion() {\n-  return coverage::CovMapVersion::Version4;\n+#if LLVM_VERSION_GE(13, 0)\n+  return coverage::CovMapVersion::Version6;\n+#else\n+  return coverage::CovMapVersion::Version5;\n+#endif\n }"}, {"sha": "640d3a5a02b0f0ae7e1efc759a9f13a9997096a5", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d93df5775cbbd076bf438a4063c5c98a6293addf/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d93df5775cbbd076bf438a4063c5c98a6293addf/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=d93df5775cbbd076bf438a4063c5c98a6293addf", "patch": "@@ -21,9 +21,9 @@ rustc_index::newtype_index! {\n impl ExpressionOperandId {\n     /// An expression operand for a \"zero counter\", as described in the following references:\n     ///\n-    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#counter>\n-    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#tag>\n-    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#counter-expressions>\n+    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/docs/CoverageMappingFormat.rst#counter>\n+    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/docs/CoverageMappingFormat.rst#tag>\n+    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/docs/CoverageMappingFormat.rst#counter-expressions>\n     ///\n     /// This operand can be used to count two or more separate code regions with a single counter,\n     /// if they run sequentially with no branches, by injecting the `Counter` in a `BasicBlock` for"}, {"sha": "f4d1ca0ec691130ffe2bcd74006655ae213d1012", "filename": "src/doc/unstable-book/src/compiler-flags/instrument-coverage.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d93df5775cbbd076bf438a4063c5c98a6293addf/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Finstrument-coverage.md", "raw_url": "https://github.com/rust-lang/rust/raw/d93df5775cbbd076bf438a4063c5c98a6293addf/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Finstrument-coverage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Finstrument-coverage.md?ref=d93df5775cbbd076bf438a4063c5c98a6293addf", "patch": "@@ -20,7 +20,7 @@ This document describes how to enable and use the LLVM instrumentation-based cov\n When `-Z instrument-coverage` is enabled, the Rust compiler enhances rust-based libraries and binaries by:\n \n -   Automatically injecting calls to an LLVM intrinsic ([`llvm.instrprof.increment`]), at functions and branches in compiled code, to increment counters when conditional sections of code are executed.\n--   Embedding additional information in the data section of each library and binary (using the [LLVM Code Coverage Mapping Format] _Version 4_, supported _only_ in LLVM 11 and up), to define the code regions (start and end positions in the source code) being counted.\n+-   Embedding additional information in the data section of each library and binary (using the [LLVM Code Coverage Mapping Format] _Version 5_, if compiling with LLVM 12, or _Version 6_, if compiling with LLVM 13 or higher), to define the code regions (start and end positions in the source code) being counted.\n \n When running a coverage-instrumented program, the counter values are written to a `profraw` file at program termination. LLVM bundles tools that read the counter results, combine those results with the coverage map (embedded in the program binary), and generate coverage reports in multiple formats.\n \n@@ -123,7 +123,7 @@ If `LLVM_PROFILE_FILE` contains a path to a non-existent directory, the missing\n \n ## Installing LLVM coverage tools\n \n-LLVM's supplies two tools\u2014`llvm-profdata` and `llvm-cov`\u2014that process coverage data and generate reports. There are several ways to find and/or install these tools, but note that the coverage mapping data generated by the Rust compiler requires LLVM version 11 or higher. (`llvm-cov --version` typically shows the tool's LLVM version number.):\n+LLVM's supplies two tools\u2014`llvm-profdata` and `llvm-cov`\u2014that process coverage data and generate reports. There are several ways to find and/or install these tools, but note that the coverage mapping data generated by the Rust compiler requires LLVM version 12 or higher. (`llvm-cov --version` typically shows the tool's LLVM version number.):\n \n -   The LLVM tools may be installed (or installable) directly to your OS (such as via `apt-get`, for Linux).\n -   If you are building the Rust compiler from source, you can optionally use the bundled LLVM tools, built from source. Those tool binaries can typically be found in your build platform directory at something like: `rust/build/x86_64-unknown-linux-gnu/llvm/bin/llvm-*`."}, {"sha": "3c4df3533e147f512a481954d373fdd95e20214a", "filename": "src/test/run-make-fulldeps/coverage-llvmir/Makefile", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d93df5775cbbd076bf438a4063c5c98a6293addf/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d93df5775cbbd076bf438a4063c5c98a6293addf/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir%2FMakefile?ref=d93df5775cbbd076bf438a4063c5c98a6293addf", "patch": "@@ -1,5 +1,11 @@\n # needs-profiler-support\n \n+# Rust coverage maps support LLVM Coverage Mapping Format versions 5 and 6,\n+# corresponding with LLVM versions 12 and 13, respectively.\n+# When upgrading LLVM versions, consider whether to enforce a minimum LLVM\n+# version during testing, with an additional directive at the top of this file\n+# that sets, for example: `min-llvm-version: 12.0`\n+\n -include ../coverage/coverage_tools.mk\n \n BASEDIR=../coverage-llvmir"}, {"sha": "9122e0406c2efc49ce6d7131de87b01d3b5264b5", "filename": "src/test/run-make-fulldeps/coverage-reports/Makefile", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d93df5775cbbd076bf438a4063c5c98a6293addf/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d93df5775cbbd076bf438a4063c5c98a6293addf/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2FMakefile?ref=d93df5775cbbd076bf438a4063c5c98a6293addf", "patch": "@@ -1,6 +1,12 @@\n # needs-profiler-support\n # ignore-windows-gnu\n \n+# Rust coverage maps support LLVM Coverage Mapping Format versions 5 and 6,\n+# corresponding with LLVM versions 12 and 13, respectively.\n+# When upgrading LLVM versions, consider whether to enforce a minimum LLVM\n+# version during testing, with an additional directive at the top of this file\n+# that sets, for example: `min-llvm-version: 12.0`\n+\n # FIXME(mati865): MinGW GCC miscompiles compiler-rt profiling library but with Clang it works\n # properly. Since we only have GCC on the CI ignore the test for now.\n \n@@ -115,6 +121,7 @@ endif\n \t\"$(LLVM_BIN_DIR)\"/llvm-cov show \\\n \t\t\t$(DEBUG_FLAG) \\\n \t\t\t$(LLVM_COV_IGNORE_FILES) \\\n+\t\t\t--compilation-dir=. \\\n \t\t\t--Xdemangler=\"$(RUST_DEMANGLER)\" \\\n \t\t\t--show-line-counts-or-regions \\\n \t\t\t--instr-profile=\"$(TMPDIR)\"/$@.profdata \\"}]}