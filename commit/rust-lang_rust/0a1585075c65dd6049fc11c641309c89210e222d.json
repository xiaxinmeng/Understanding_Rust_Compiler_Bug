{"sha": "0a1585075c65dd6049fc11c641309c89210e222d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMTU4NTA3NWM2NWRkNjA0OWZjMTFjNjQxMzA5Yzg5MjEwZTIyMmQ=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-17T08:30:39Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-17T08:30:39Z"}, "message": "Merge branch 'master' of github.com:rust-analyzer/rust-analyzer", "tree": {"sha": "ceda5ef63d2179f25a7d5abaa16fa1dc30c9867b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ceda5ef63d2179f25a7d5abaa16fa1dc30c9867b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a1585075c65dd6049fc11c641309c89210e222d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a1585075c65dd6049fc11c641309c89210e222d", "html_url": "https://github.com/rust-lang/rust/commit/0a1585075c65dd6049fc11c641309c89210e222d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a1585075c65dd6049fc11c641309c89210e222d/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "071ef268b5c8fb9afec1db912ebcc5d6577f5e73", "url": "https://api.github.com/repos/rust-lang/rust/commits/071ef268b5c8fb9afec1db912ebcc5d6577f5e73", "html_url": "https://github.com/rust-lang/rust/commit/071ef268b5c8fb9afec1db912ebcc5d6577f5e73"}, {"sha": "8d296be1090b21b60e509c831864ae85feec2490", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d296be1090b21b60e509c831864ae85feec2490", "html_url": "https://github.com/rust-lang/rust/commit/8d296be1090b21b60e509c831864ae85feec2490"}], "stats": {"total": 1490, "additions": 1126, "deletions": 364}, "files": [{"sha": "89a734c9bb935cae217aa20213debe4aaff6fe9c", "filename": "Cargo.lock", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -114,17 +114,18 @@ checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n [[package]]\n name = \"chalk-derive\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=039fc904a05f8cb3d0c682c9a57a63dda7a35356#039fc904a05f8cb3d0c682c9a57a63dda7a35356\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=28cef6ff403d403e6ad2f3d27d944e9ffac1bce8#28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"syn\",\n+ \"synstructure\",\n ]\n \n [[package]]\n name = \"chalk-engine\"\n version = \"0.9.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=039fc904a05f8cb3d0c682c9a57a63dda7a35356#039fc904a05f8cb3d0c682c9a57a63dda7a35356\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=28cef6ff403d403e6ad2f3d27d944e9ffac1bce8#28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\"\n dependencies = [\n  \"chalk-macros\",\n  \"rustc-hash\",\n@@ -133,7 +134,7 @@ dependencies = [\n [[package]]\n name = \"chalk-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=039fc904a05f8cb3d0c682c9a57a63dda7a35356#039fc904a05f8cb3d0c682c9a57a63dda7a35356\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=28cef6ff403d403e6ad2f3d27d944e9ffac1bce8#28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-engine\",\n@@ -143,15 +144,15 @@ dependencies = [\n [[package]]\n name = \"chalk-macros\"\n version = \"0.1.1\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=039fc904a05f8cb3d0c682c9a57a63dda7a35356#039fc904a05f8cb3d0c682c9a57a63dda7a35356\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=28cef6ff403d403e6ad2f3d27d944e9ffac1bce8#28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\"\n dependencies = [\n  \"lazy_static\",\n ]\n \n [[package]]\n name = \"chalk-rust-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=039fc904a05f8cb3d0c682c9a57a63dda7a35356#039fc904a05f8cb3d0c682c9a57a63dda7a35356\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=28cef6ff403d403e6ad2f3d27d944e9ffac1bce8#28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-engine\",\n@@ -162,7 +163,7 @@ dependencies = [\n [[package]]\n name = \"chalk-solve\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=039fc904a05f8cb3d0c682c9a57a63dda7a35356#039fc904a05f8cb3d0c682c9a57a63dda7a35356\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=28cef6ff403d403e6ad2f3d27d944e9ffac1bce8#28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-engine\",\n@@ -446,9 +447,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.10\"\n+version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"725cf19794cf90aa94e65050cb4191ff5d8fa87a498383774c47b332e3af952e\"\n+checksum = \"8a0d737e0f947a1864e93d33fdef4af8445a00d1ed8dc0c8ddb73139ea6abf15\"\n dependencies = [\n  \"libc\",\n ]\n@@ -495,9 +496,9 @@ dependencies = [\n \n [[package]]\n name = \"insta\"\n-version = \"0.15.0\"\n+version = \"0.16.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8de3f029212a3fe78a6090f1f2b993877ca245a9ded863f3fcbd6eae084fc1ed\"\n+checksum = \"8386e795fb3927131ea4cede203c529a333652eb6dc4ff29616b832b27e9b096\"\n dependencies = [\n  \"console\",\n  \"difference\",\n@@ -593,15 +594,15 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.68\"\n+version = \"0.2.69\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dea0c0405123bba743ee3f91f49b1c7cfb684eef0da0a50110f758ccf24cdff0\"\n+checksum = \"99e85c08494b21a9054e7fe1374a732aeadaff3980b6990b94bfd3a70f690005\"\n \n [[package]]\n name = \"libloading\"\n-version = \"0.6.0\"\n+version = \"0.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2c979a19ffb457f0273965c333053f3d586bf759bf7b683fbebc37f9a9ebedc4\"\n+checksum = \"3c4f51b790f5bdb65acb4cc94bb81d7b2ee60348a5431ac1467d390b017600b0\"\n dependencies = [\n  \"winapi 0.3.8\",\n ]\n@@ -757,9 +758,9 @@ dependencies = [\n \n [[package]]\n name = \"num_cpus\"\n-version = \"1.12.0\"\n+version = \"1.13.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"46203554f085ff89c235cd12f7075f3233af9b11ed7c9e16dfe2560d03313ce6\"\n+checksum = \"05499f3756671c15885fee9034446956fff3f243d6077b91e5767df161f766b3\"\n dependencies = [\n  \"hermit-abi\",\n  \"libc\",\n@@ -779,9 +780,9 @@ checksum = \"a86ed3f5f244b372d6b1a00b72ef7f8876d0bc6a78a4c9985c53614041512063\"\n \n [[package]]\n name = \"parking_lot\"\n-version = \"0.10.1\"\n+version = \"0.10.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6fdfcb5f20930a79e326f7ec992a9fdb5b7bd809254b1e735bdd5a99f78bee0d\"\n+checksum = \"d3a704eb390aafdc107b0e392f56a82b668e3a71366993b5340f5833fd62505e\"\n dependencies = [\n  \"lock_api\",\n  \"parking_lot_core\",\n@@ -1013,6 +1014,7 @@ dependencies = [\n  \"chalk-solve\",\n  \"ena\",\n  \"insta\",\n+ \"itertools\",\n  \"log\",\n  \"ra_arena\",\n  \"ra_db\",\n@@ -1339,6 +1341,7 @@ dependencies = [\n  \"ra_hir_def\",\n  \"ra_hir_ty\",\n  \"ra_ide\",\n+ \"ra_proc_macro_srv\",\n  \"ra_prof\",\n  \"ra_project_model\",\n  \"ra_syntax\",\n@@ -1564,6 +1567,18 @@ dependencies = [\n  \"unicode-xid\",\n ]\n \n+[[package]]\n+name = \"synstructure\"\n+version = \"0.12.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"67656ea1dc1b41b1451851562ea232ec2e5a80242139f7e679ceccfb5d61f545\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"unicode-xid\",\n+]\n+\n [[package]]\n name = \"tempfile\"\n version = \"3.1.0\""}, {"sha": "b39e60870e5d808fd06276f6606a6ee106917b6f", "filename": "crates/ra_assists/src/doc_tests/generated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -78,7 +78,7 @@ fn foo() {\n }\n \n fn bar(arg: &str, baz: Baz) {\n-    unimplemented!()\n+    todo!()\n }\n \n \"#####,"}, {"sha": "ad4ab66edef025b3b39e4b608520e82e9d561b2b", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -29,7 +29,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n // }\n //\n // fn bar(arg: &str, baz: Baz) {\n-//     unimplemented!()\n+//     todo!()\n // }\n //\n // ```\n@@ -80,7 +80,7 @@ impl FunctionBuilder {\n         Some(Self { append_fn_at, fn_name, type_params, params })\n     }\n     fn render(self) -> Option<FunctionTemplate> {\n-        let placeholder_expr = ast::make::expr_unimplemented();\n+        let placeholder_expr = ast::make::expr_todo();\n         let fn_body = ast::make::block_expr(vec![], Some(placeholder_expr));\n         let fn_def = ast::make::fn_def(self.fn_name, self.type_params, self.params, fn_body);\n         let fn_def = ast::make::add_newlines(2, fn_def);\n@@ -225,7 +225,7 @@ fn foo() {\n }\n \n fn bar() {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \",\n         )\n@@ -252,7 +252,7 @@ impl Foo {\n }\n \n fn bar() {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \",\n         )\n@@ -276,7 +276,7 @@ fn foo1() {\n }\n \n fn bar() {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \n fn foo2() {}\n@@ -302,7 +302,7 @@ mod baz {\n     }\n \n     fn bar() {\n-        <|>unimplemented!()\n+        <|>todo!()\n     }\n }\n \",\n@@ -315,20 +315,20 @@ mod baz {\n             add_function,\n             r\"\n struct Baz;\n-fn baz() -> Baz { unimplemented!() }\n+fn baz() -> Baz { todo!() }\n fn foo() {\n     bar<|>(baz());\n }\n \",\n             r\"\n struct Baz;\n-fn baz() -> Baz { unimplemented!() }\n+fn baz() -> Baz { todo!() }\n fn foo() {\n     bar(baz());\n }\n \n fn bar(baz: Baz) {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \",\n         );\n@@ -361,7 +361,7 @@ impl Baz {\n }\n \n fn bar(baz: Baz) {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \",\n         )\n@@ -382,7 +382,7 @@ fn foo() {\n }\n \n fn bar(arg: &str) {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \"#,\n         )\n@@ -403,7 +403,7 @@ fn foo() {\n }\n \n fn bar(arg: char) {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \"#,\n         )\n@@ -424,7 +424,7 @@ fn foo() {\n }\n \n fn bar(arg: i32) {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \",\n         )\n@@ -445,7 +445,7 @@ fn foo() {\n }\n \n fn bar(arg: u8) {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \",\n         )\n@@ -470,7 +470,7 @@ fn foo() {\n }\n \n fn bar(x: u8) {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \",\n         )\n@@ -493,7 +493,7 @@ fn foo() {\n }\n \n fn bar(worble: ()) {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \",\n         )\n@@ -506,7 +506,7 @@ fn bar(worble: ()) {\n             r\"\n trait Foo {}\n fn foo() -> impl Foo {\n-    unimplemented!()\n+    todo!()\n }\n fn baz() {\n     <|>bar(foo())\n@@ -515,14 +515,14 @@ fn baz() {\n             r\"\n trait Foo {}\n fn foo() -> impl Foo {\n-    unimplemented!()\n+    todo!()\n }\n fn baz() {\n     bar(foo())\n }\n \n fn bar(foo: impl Foo) {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \",\n         )\n@@ -556,7 +556,7 @@ mod Foo {\n     }\n \n     fn bar(baz: super::Baz::Bof) {\n-        <|>unimplemented!()\n+        <|>todo!()\n     }\n }\n \",\n@@ -580,7 +580,7 @@ fn foo<T>(t: T) {\n }\n \n fn bar<T>(t: T) {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \",\n         )\n@@ -611,7 +611,7 @@ fn foo() {\n }\n \n fn bar(arg: fn() -> Baz) {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \",\n         )\n@@ -636,7 +636,7 @@ fn foo() {\n }\n \n fn bar(closure: impl Fn(i64) -> i64) {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \",\n         )\n@@ -657,7 +657,7 @@ fn foo() {\n }\n \n fn bar(baz: ()) {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \",\n         )\n@@ -682,7 +682,7 @@ fn foo() {\n }\n \n fn bar(baz_1: Baz, baz_2: Baz) {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \",\n         )\n@@ -707,7 +707,7 @@ fn foo() {\n }\n \n fn bar(baz_1: Baz, baz_2: Baz, arg_1: &str, arg_2: &str) {\n-    <|>unimplemented!()\n+    <|>todo!()\n }\n \"#,\n         )\n@@ -779,7 +779,7 @@ impl Foo {\n         self.bar();\n     }\n     fn bar(&self) {\n-        unimplemented!();\n+        todo!();\n     }\n }\n         \","}, {"sha": "76e5cada4f1543f1c1c3a972369c67dda2ecf550", "filename": "crates/ra_flycheck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_flycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_flycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2FCargo.toml?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -13,4 +13,4 @@ serde_json = \"1.0.48\"\n jod-thread = \"0.1.1\"\n \n [dev-dependencies]\n-insta = \"0.15.0\"\n+insta = \"0.16.0\""}, {"sha": "3801fce23aeb5222d071d3b7630617fc74acfa06", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -25,7 +25,7 @@ use hir_ty::{\n     autoderef, display::HirFormatter, expr::ExprValidator, method_resolution, ApplicationTy,\n     Canonical, InEnvironment, Substs, TraitEnvironment, Ty, TyDefId, TypeCtor,\n };\n-use ra_db::{CrateId, Edition, FileId};\n+use ra_db::{CrateId, CrateName, Edition, FileId};\n use ra_prof::profile;\n use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner},\n@@ -91,6 +91,10 @@ impl Crate {\n         db.crate_graph()[self.id].edition\n     }\n \n+    pub fn display_name(self, db: &dyn HirDatabase) -> Option<CrateName> {\n+        db.crate_graph()[self.id].display_name.as_ref().cloned()\n+    }\n+\n     pub fn all(db: &dyn HirDatabase) -> Vec<Crate> {\n         db.crate_graph().iter().map(|id| Crate { id }).collect()\n     }"}, {"sha": "b853583088cfa77c3f0b60b2d508e10dd72c4fdc", "filename": "crates/ra_hir_def/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -28,4 +28,4 @@ ra_cfg = { path = \"../ra_cfg\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n \n [dev-dependencies]\n-insta = \"0.15.0\"\n+insta = \"0.16.0\""}, {"sha": "ccb682f9abb2f42bd10ae387119cfb1d7b1ea129", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -9,13 +9,14 @@ use hir_expand::{\n };\n use ra_prof::profile;\n use ra_syntax::ast::{\n-    self, AstNode, ImplItem, ModuleItemOwner, NameOwner, TypeAscriptionOwner, VisibilityOwner,\n+    self, AstNode, ImplItem, ModuleItemOwner, NameOwner, TypeAscriptionOwner, TypeBoundsOwner,\n+    VisibilityOwner,\n };\n \n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n-    path::{path, GenericArgs, Path},\n+    path::{path, AssociatedTypeBinding, GenericArgs, Path},\n     src::HasSource,\n     type_ref::{Mutability, TypeBound, TypeRef},\n     visibility::RawVisibility,\n@@ -95,7 +96,11 @@ fn desugar_future_path(orig: TypeRef) -> Path {\n     let path = path![std::future::Future];\n     let mut generic_args: Vec<_> = std::iter::repeat(None).take(path.segments.len() - 1).collect();\n     let mut last = GenericArgs::empty();\n-    last.bindings.push((name![Output], orig));\n+    last.bindings.push(AssociatedTypeBinding {\n+        name: name![Output],\n+        type_ref: Some(orig),\n+        bounds: Vec::new(),\n+    });\n     generic_args.push(Some(Arc::new(last)));\n \n     Path::from_known_path(path, generic_args)\n@@ -106,6 +111,7 @@ pub struct TypeAliasData {\n     pub name: Name,\n     pub type_ref: Option<TypeRef>,\n     pub visibility: RawVisibility,\n+    pub bounds: Vec<TypeBound>,\n }\n \n impl TypeAliasData {\n@@ -118,9 +124,17 @@ impl TypeAliasData {\n         let name = node.value.name().map_or_else(Name::missing, |n| n.as_name());\n         let type_ref = node.value.type_ref().map(TypeRef::from_ast);\n         let vis_default = RawVisibility::default_for_container(loc.container);\n-        let visibility =\n-            RawVisibility::from_ast_with_default(db, vis_default, node.map(|n| n.visibility()));\n-        Arc::new(TypeAliasData { name, type_ref, visibility })\n+        let visibility = RawVisibility::from_ast_with_default(\n+            db,\n+            vis_default,\n+            node.as_ref().map(|n| n.visibility()),\n+        );\n+        let bounds = if let Some(bound_list) = node.value.type_bound_list() {\n+            bound_list.bounds().map(TypeBound::from_ast).collect()\n+        } else {\n+            Vec::new()\n+        };\n+        Arc::new(TypeAliasData { name, type_ref, visibility, bounds })\n     }\n }\n "}, {"sha": "162b3c8c74fea05a02a2e5bfa8f7601aa99d508c", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -14,7 +14,10 @@ use hir_expand::{\n use ra_db::CrateId;\n use ra_syntax::ast;\n \n-use crate::{type_ref::TypeRef, InFile};\n+use crate::{\n+    type_ref::{TypeBound, TypeRef},\n+    InFile,\n+};\n \n #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct ModPath {\n@@ -111,7 +114,21 @@ pub struct GenericArgs {\n     /// is left out.\n     pub has_self_type: bool,\n     /// Associated type bindings like in `Iterator<Item = T>`.\n-    pub bindings: Vec<(Name, TypeRef)>,\n+    pub bindings: Vec<AssociatedTypeBinding>,\n+}\n+\n+/// An associated type binding like in `Iterator<Item = T>`.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct AssociatedTypeBinding {\n+    /// The name of the associated type.\n+    pub name: Name,\n+    /// The type bound to this associated type (in `Item = T`, this would be the\n+    /// `T`). This can be `None` if there are bounds instead.\n+    pub type_ref: Option<TypeRef>,\n+    /// Bounds for the associated type, like in `Iterator<Item:\n+    /// SomeOtherTrait>`. (This is the unstable `associated_type_bounds`\n+    /// feature.)\n+    pub bounds: Vec<TypeBound>,\n }\n \n /// A single generic argument."}, {"sha": "9ec2e0dcdf01ca5bf7bce26eef39ac1c61a4761f", "filename": "crates/ra_hir_def/src/path/lower.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -9,11 +9,12 @@ use hir_expand::{\n     hygiene::Hygiene,\n     name::{name, AsName},\n };\n-use ra_syntax::ast::{self, AstNode, TypeAscriptionOwner};\n+use ra_syntax::ast::{self, AstNode, TypeAscriptionOwner, TypeBoundsOwner};\n \n+use super::AssociatedTypeBinding;\n use crate::{\n     path::{GenericArg, GenericArgs, ModPath, Path, PathKind},\n-    type_ref::TypeRef,\n+    type_ref::{TypeBound, TypeRef},\n };\n \n pub(super) use lower_use::lower_use_tree;\n@@ -136,10 +137,16 @@ pub(super) fn lower_generic_args(node: ast::TypeArgList) -> Option<GenericArgs>\n     // lifetimes ignored for now\n     let mut bindings = Vec::new();\n     for assoc_type_arg in node.assoc_type_args() {\n+        let assoc_type_arg: ast::AssocTypeArg = assoc_type_arg;\n         if let Some(name_ref) = assoc_type_arg.name_ref() {\n             let name = name_ref.as_name();\n-            let type_ref = TypeRef::from_ast_opt(assoc_type_arg.type_ref());\n-            bindings.push((name, type_ref));\n+            let type_ref = assoc_type_arg.type_ref().map(TypeRef::from_ast);\n+            let bounds = if let Some(l) = assoc_type_arg.type_bound_list() {\n+                l.bounds().map(TypeBound::from_ast).collect()\n+            } else {\n+                Vec::new()\n+            };\n+            bindings.push(AssociatedTypeBinding { name, type_ref, bounds });\n         }\n     }\n     if args.is_empty() && bindings.is_empty() {\n@@ -168,7 +175,11 @@ fn lower_generic_args_from_fn_path(\n     }\n     if let Some(ret_type) = ret_type {\n         let type_ref = TypeRef::from_ast_opt(ret_type.type_ref());\n-        bindings.push((name![Output], type_ref))\n+        bindings.push(AssociatedTypeBinding {\n+            name: name![Output],\n+            type_ref: Some(type_ref),\n+            bounds: Vec::new(),\n+        });\n     }\n     if args.is_empty() && bindings.is_empty() {\n         None"}, {"sha": "f308c6bdfc3edc0853fc98abc493678d3e75e815", "filename": "crates/ra_hir_def/src/type_ref.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -163,8 +163,16 @@ impl TypeRef {\n                         let crate::path::GenericArg::Type(type_ref) = arg;\n                         go(type_ref, f);\n                     }\n-                    for (_, type_ref) in &args_and_bindings.bindings {\n-                        go(type_ref, f);\n+                    for binding in &args_and_bindings.bindings {\n+                        if let Some(type_ref) = &binding.type_ref {\n+                            go(type_ref, f);\n+                        }\n+                        for bound in &binding.bounds {\n+                            match bound {\n+                                TypeBound::Path(path) => go_path(path, f),\n+                                TypeBound::Error => (),\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "177bdbcb0eb6ace64e23bd016baa81480905efaa", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -8,6 +8,7 @@ authors = [\"rust-analyzer developers\"]\n doctest = false\n \n [dependencies]\n+itertools = \"0.9.0\"\n arrayvec = \"0.5.1\"\n smallvec = \"1.2.0\"\n ena = \"0.13.1\"\n@@ -26,9 +27,9 @@ test_utils = { path = \"../test_utils\" }\n \n scoped-tls = \"1\"\n \n-chalk-solve =   { git = \"https://github.com/rust-lang/chalk.git\", rev = \"039fc904a05f8cb3d0c682c9a57a63dda7a35356\" }\n-chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"039fc904a05f8cb3d0c682c9a57a63dda7a35356\" }\n-chalk-ir =      { git = \"https://github.com/rust-lang/chalk.git\", rev = \"039fc904a05f8cb3d0c682c9a57a63dda7a35356\" }\n+chalk-solve =   { git = \"https://github.com/rust-lang/chalk.git\", rev = \"28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\" }\n+chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\" }\n+chalk-ir =      { git = \"https://github.com/rust-lang/chalk.git\", rev = \"28cef6ff403d403e6ad2f3d27d944e9ffac1bce8\" }\n \n [dev-dependencies]\n-insta = \"0.15.0\"\n+insta = \"0.16.0\""}, {"sha": "688026a0408d2401fa2802172d02e3a84bcc4753", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -194,9 +194,10 @@ use smallvec::{smallvec, SmallVec};\n use crate::{\n     db::HirDatabase,\n     expr::{Body, Expr, Literal, Pat, PatId},\n-    InferenceResult,\n+    ApplicationTy, InferenceResult, Ty, TypeCtor,\n };\n-use hir_def::{adt::VariantData, EnumVariantId, VariantId};\n+use hir_def::{adt::VariantData, AdtId, EnumVariantId, VariantId};\n+use ra_arena::Idx;\n \n #[derive(Debug, Clone, Copy)]\n /// Either a pattern from the source code being analyzed, represented as\n@@ -512,6 +513,7 @@ pub enum Usefulness {\n }\n \n pub struct MatchCheckCtx<'a> {\n+    pub match_expr: Idx<Expr>,\n     pub body: Arc<Body>,\n     pub infer: Arc<InferenceResult>,\n     pub db: &'a dyn HirDatabase,\n@@ -530,6 +532,16 @@ pub(crate) fn is_useful(\n     matrix: &Matrix,\n     v: &PatStack,\n ) -> MatchCheckResult<Usefulness> {\n+    // Handle the special case of enums with no variants. In that case, no match\n+    // arm is useful.\n+    if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(AdtId::EnumId(enum_id)), .. }) =\n+        cx.infer[cx.match_expr].strip_references()\n+    {\n+        if cx.db.enum_data(*enum_id).variants.is_empty() {\n+            return Ok(Usefulness::NotUseful);\n+        }\n+    }\n+\n     if v.is_empty() {\n         let result = if matrix.is_empty() { Usefulness::Useful } else { Usefulness::NotUseful };\n \n@@ -1618,6 +1630,32 @@ mod tests {\n \n         check_no_diagnostic(content);\n     }\n+\n+    #[test]\n+    fn enum_never() {\n+        let content = r\"\n+            enum Never {}\n+\n+            fn test_fn(never: Never) {\n+                match never {}\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_never_ref() {\n+        let content = r\"\n+            enum Never {}\n+\n+            fn test_fn(never: &Never) {\n+                match never {}\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "1b0f84c5c752eb3b890827dfdf4a3f5994e67090", "filename": "crates/ra_hir_ty/src/autoderef.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -14,7 +14,7 @@ use crate::{\n     db::HirDatabase,\n     traits::{InEnvironment, Solution},\n     utils::generics,\n-    BoundVar, Canonical, DebruijnIndex, Substs, Ty,\n+    BoundVar, Canonical, DebruijnIndex, Obligation, Substs, TraitRef, Ty,\n };\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;\n@@ -66,6 +66,20 @@ fn deref_by_trait(\n     let parameters =\n         Substs::build_for_generics(&generic_params).push(ty.value.value.clone()).build();\n \n+    // Check that the type implements Deref at all\n+    let trait_ref = TraitRef { trait_: deref_trait, substs: parameters.clone() };\n+    let implements_goal = super::Canonical {\n+        num_vars: ty.value.num_vars,\n+        value: InEnvironment {\n+            value: Obligation::Trait(trait_ref),\n+            environment: ty.environment.clone(),\n+        },\n+    };\n+    if db.trait_solve(krate, implements_goal).is_none() {\n+        return None;\n+    }\n+\n+    // Now do the assoc type projection\n     let projection = super::traits::ProjectionPredicate {\n         ty: Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, ty.value.num_vars)),\n         projection_ty: super::ProjectionTy { associated_ty: target, parameters },\n@@ -91,6 +105,11 @@ fn deref_by_trait(\n             // they're just being 'passed through'. In the 'standard' case where\n             // we have `impl<T> Deref for Foo<T> { Target = T }`, that should be\n             // the case.\n+\n+            // FIXME: if the trait solver decides to truncate the type, these\n+            // assumptions will be broken. We would need to properly introduce\n+            // new variables in that case\n+\n             for i in 1..vars.0.num_vars {\n                 if vars.0.value[i - 1] != Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, i - 1))\n                 {"}, {"sha": "fd59f43207e428fa448ecdbb10fb76061a2a9051", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -156,7 +156,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             None => return,\n         };\n \n-        let cx = MatchCheckCtx { body, infer: infer.clone(), db };\n+        let cx = MatchCheckCtx { match_expr, body, infer: infer.clone(), db };\n         let pats = arms.iter().map(|arm| arm.pat);\n \n         let mut seen = Matrix::empty();"}, {"sha": "5f6cea8d318e13863f8c33d4aff81128ed08783a", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -32,6 +32,7 @@ where\n     var_stack: Vec<TypeVarId>,\n }\n \n+#[derive(Debug)]\n pub(super) struct Canonicalized<T> {\n     pub value: Canonical<T>,\n     free_vars: Vec<InferTy>,"}, {"sha": "2677f3af2d752e1e791513fb47ad1552e48beed7", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -680,6 +680,16 @@ impl Ty {\n         }\n     }\n \n+    pub fn strip_references(&self) -> &Ty {\n+        let mut t: &Ty = self;\n+\n+        while let Ty::Apply(ApplicationTy { ctor: TypeCtor::Ref(_mutability), parameters }) = t {\n+            t = parameters.as_single();\n+        }\n+\n+        t\n+    }\n+\n     pub fn as_adt(&self) -> Option<(AdtId, &Substs)> {\n         match self {\n             Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(adt_def), parameters }) => {"}, {"sha": "cc1ac8e3e972b9b04a36305dc6a9b2b1d9ede2b3", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -8,6 +8,8 @@\n use std::iter;\n use std::sync::Arc;\n \n+use smallvec::SmallVec;\n+\n use hir_def::{\n     adt::StructKind,\n     builtin_type::BuiltinType,\n@@ -360,13 +362,23 @@ impl Ty {\n             },\n             Some(TypeNs::GenericParam(param_id)) => {\n                 let predicates = ctx.db.generic_predicates_for_param(param_id);\n-                predicates\n+                let mut traits_: Vec<_> = predicates\n                     .iter()\n                     .filter_map(|pred| match &pred.value {\n                         GenericPredicate::Implemented(tr) => Some(tr.trait_),\n                         _ => None,\n                     })\n-                    .collect()\n+                    .collect();\n+                // Handle `Self::Type` referring to own associated type in trait definitions\n+                if let GenericDefId::TraitId(trait_id) = param_id.parent {\n+                    let generics = generics(ctx.db.upcast(), trait_id.into());\n+                    if generics.params.types[param_id.local_id].provenance\n+                        == TypeParamProvenance::TraitSelf\n+                    {\n+                        traits_.push(trait_id);\n+                    }\n+                }\n+                traits_\n             }\n             _ => return Ty::Unknown,\n         };\n@@ -596,21 +608,35 @@ fn assoc_type_bindings_from_type_bound<'a>(\n         .into_iter()\n         .flat_map(|segment| segment.args_and_bindings.into_iter())\n         .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n-        .map(move |(name, type_ref)| {\n+        .flat_map(move |binding| {\n             let associated_ty = associated_type_by_name_including_super_traits(\n                 ctx.db.upcast(),\n                 trait_ref.trait_,\n-                &name,\n+                &binding.name,\n             );\n             let associated_ty = match associated_ty {\n-                None => return GenericPredicate::Error,\n+                None => return SmallVec::<[GenericPredicate; 1]>::new(),\n                 Some(t) => t,\n             };\n             let projection_ty =\n                 ProjectionTy { associated_ty, parameters: trait_ref.substs.clone() };\n-            let ty = Ty::from_hir(ctx, type_ref);\n-            let projection_predicate = ProjectionPredicate { projection_ty, ty };\n-            GenericPredicate::Projection(projection_predicate)\n+            let mut preds = SmallVec::with_capacity(\n+                binding.type_ref.as_ref().map_or(0, |_| 1) + binding.bounds.len(),\n+            );\n+            if let Some(type_ref) = &binding.type_ref {\n+                let ty = Ty::from_hir(ctx, type_ref);\n+                let projection_predicate =\n+                    ProjectionPredicate { projection_ty: projection_ty.clone(), ty };\n+                preds.push(GenericPredicate::Projection(projection_predicate));\n+            }\n+            for bound in &binding.bounds {\n+                preds.extend(GenericPredicate::from_type_bound(\n+                    ctx,\n+                    bound,\n+                    Ty::Projection(projection_ty.clone()),\n+                ));\n+            }\n+            preds\n         })\n }\n "}, {"sha": "d69115a2f527bd32e81e2bf046799a8d6aeb4923", "filename": "crates/ra_hir_ty/src/tests/regression.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -451,8 +451,7 @@ pub mod str {\n \"#,\n     );\n \n-    // should be Option<char>, but currently not because of Chalk ambiguity problem\n-    assert_eq!(\"(Option<{unknown}>, Option<{unknown}>)\", super::type_at_pos(&db, pos));\n+    assert_eq!(\"(Option<char>, Option<char>)\", super::type_at_pos(&db, pos));\n }\n \n #[test]"}, {"sha": "0a889f8057e60eeebed77041d6c89cef394f0109", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 185, "deletions": 27, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -349,7 +349,6 @@ trait Trait: SuperTrait {\n \n #[test]\n fn infer_project_associated_type() {\n-    // y, z, a don't yet work because of https://github.com/rust-lang/chalk/issues/234\n     assert_snapshot!(\n         infer(r#\"\n trait Iterable {\n@@ -368,12 +367,12 @@ fn test<T: Iterable>() {\n     [108; 261) '{     ...ter; }': ()\n     [118; 119) 'x': u32\n     [145; 146) '1': u32\n-    [156; 157) 'y': {unknown}\n-    [183; 192) 'no_matter': {unknown}\n-    [202; 203) 'z': {unknown}\n-    [215; 224) 'no_matter': {unknown}\n-    [234; 235) 'a': {unknown}\n-    [249; 258) 'no_matter': {unknown}\n+    [156; 157) 'y': Iterable::Item<T>\n+    [183; 192) 'no_matter': Iterable::Item<T>\n+    [202; 203) 'z': Iterable::Item<T>\n+    [215; 224) 'no_matter': Iterable::Item<T>\n+    [234; 235) 'a': Iterable::Item<T>\n+    [249; 258) 'no_matter': Iterable::Item<T>\n     \"###\n     );\n }\n@@ -433,8 +432,8 @@ fn test<T: Iterable<Item=u32>>() {\n \"#),\n         @r###\"\n     [67; 100) '{     ...own; }': ()\n-    [77; 78) 'y': {unknown}\n-    [90; 97) 'unknown': {unknown}\n+    [77; 78) 'y': u32\n+    [90; 97) 'unknown': u32\n     \"###\n     );\n }\n@@ -549,7 +548,7 @@ impl std::ops::Index<u32> for Bar {\n \n fn test() {\n     let a = Bar;\n-    let b = a[1];\n+    let b = a[1u32];\n     b<|>;\n }\n \n@@ -574,7 +573,7 @@ fn infer_ops_index_autoderef() {\n //- /main.rs crate:main deps:std\n fn test() {\n     let a = &[1u32, 2, 3];\n-    let b = a[1];\n+    let b = a[1u32];\n     b<|>;\n }\n \n@@ -916,11 +915,7 @@ fn test<T: ApplyL>(t: T) {\n }\n \"#,\n     );\n-    // FIXME here Chalk doesn't normalize the type to a placeholder. I think we\n-    // need to add a rule like Normalize(<T as ApplyL>::Out -> ApplyL::Out<T>)\n-    // to the trait env ourselves here; probably Chalk can't do this by itself.\n-    // assert_eq!(t, \"ApplyL::Out<[missing name]>\");\n-    assert_eq!(t, \"{unknown}\");\n+    assert_eq!(t, \"ApplyL::Out<T>\");\n }\n \n #[test]\n@@ -1329,16 +1324,16 @@ fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n     [263; 264) 'y': impl Trait<Type = i64>\n     [290; 398) '{     ...r>); }': ()\n     [296; 299) 'get': fn get<T>(T) -> <T as Trait>::Type\n-    [296; 302) 'get(x)': {unknown}\n+    [296; 302) 'get(x)': u32\n     [300; 301) 'x': T\n-    [308; 312) 'get2': fn get2<{unknown}, T>(T) -> {unknown}\n-    [308; 315) 'get2(x)': {unknown}\n+    [308; 312) 'get2': fn get2<u32, T>(T) -> u32\n+    [308; 315) 'get2(x)': u32\n     [313; 314) 'x': T\n     [321; 324) 'get': fn get<impl Trait<Type = i64>>(impl Trait<Type = i64>) -> <impl Trait<Type = i64> as Trait>::Type\n-    [321; 327) 'get(y)': {unknown}\n+    [321; 327) 'get(y)': i64\n     [325; 326) 'y': impl Trait<Type = i64>\n-    [333; 337) 'get2': fn get2<{unknown}, impl Trait<Type = i64>>(impl Trait<Type = i64>) -> {unknown}\n-    [333; 340) 'get2(y)': {unknown}\n+    [333; 337) 'get2': fn get2<i64, impl Trait<Type = i64>>(impl Trait<Type = i64>) -> i64\n+    [333; 340) 'get2(y)': i64\n     [338; 339) 'y': impl Trait<Type = i64>\n     [346; 349) 'get': fn get<S<u64>>(S<u64>) -> <S<u64> as Trait>::Type\n     [346; 357) 'get(set(S))': u64\n@@ -1402,7 +1397,6 @@ mod iter {\n \n #[test]\n fn projection_eq_within_chalk() {\n-    // std::env::set_var(\"CHALK_DEBUG\", \"1\");\n     assert_snapshot!(\n         infer(r#\"\n trait Trait1 {\n@@ -1422,7 +1416,7 @@ fn test<T: Trait1<Type = u32>>(x: T) {\n     [164; 165) 'x': T\n     [170; 186) '{     ...o(); }': ()\n     [176; 177) 'x': T\n-    [176; 183) 'x.foo()': {unknown}\n+    [176; 183) 'x.foo()': u32\n     \"###\n     );\n }\n@@ -1578,7 +1572,7 @@ fn test<F: FnOnce(u32, u64) -> u128>(f: F) {\n     [150; 151) 'f': F\n     [156; 184) '{     ...2)); }': ()\n     [162; 163) 'f': F\n-    [162; 181) 'f.call...1, 2))': {unknown}\n+    [162; 181) 'f.call...1, 2))': u128\n     [174; 180) '(1, 2)': (u32, u64)\n     [175; 176) '1': u32\n     [178; 179) '2': u64\n@@ -1803,7 +1797,7 @@ fn test<T, U>() where T::Item: Trait2, T: Trait<U::Item>, U: Trait<()> {\n }\n \n #[test]\n-fn unselected_projection_on_trait_self() {\n+fn unselected_projection_on_impl_self() {\n     assert_snapshot!(infer(\n         r#\"\n //- /main.rs\n@@ -1829,7 +1823,7 @@ impl Trait for S2 {\n \"#,\n     ), @r###\"\n     [54; 58) 'self': &Self\n-    [60; 61) 'x': {unknown}\n+    [60; 61) 'x': Trait::Item<Self>\n     [140; 144) 'self': &S\n     [146; 147) 'x': u32\n     [161; 175) '{ let y = x; }': ()\n@@ -1843,6 +1837,30 @@ impl Trait for S2 {\n     \"###);\n }\n \n+#[test]\n+fn unselected_projection_on_trait_self() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait {\n+    type Item;\n+\n+    fn f(&self) -> Self::Item { loop {} }\n+}\n+\n+struct S;\n+impl Trait for S {\n+    type Item = u32;\n+}\n+\n+fn test() {\n+    S.f()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n #[test]\n fn trait_impl_self_ty() {\n     let t = type_at(\n@@ -1923,6 +1941,119 @@ fn test<T, U>() where T: Trait<U::Item>, U: Trait<T::Item> {\n     assert_eq!(t, \"{unknown}\");\n }\n \n+#[test]\n+fn inline_assoc_type_bounds_1() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Iterator {\n+    type Item;\n+}\n+trait OtherTrait<T> {\n+    fn foo(&self) -> T;\n+}\n+\n+// workaround for Chalk assoc type normalization problems\n+pub struct S<T>;\n+impl<T: Iterator> Iterator for S<T> {\n+    type Item = <T as Iterator>::Item;\n+}\n+\n+fn test<I: Iterator<Item: OtherTrait<u32>>>() {\n+    let x: <S<I> as Iterator>::Item;\n+    x.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n+#[test]\n+fn inline_assoc_type_bounds_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Iterator {\n+    type Item;\n+}\n+\n+fn test<I: Iterator<Item: Iterator<Item = u32>>>() {\n+    let x: <<I as Iterator>::Item as Iterator>::Item;\n+    x<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n+#[test]\n+fn proc_macro_server_types() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+macro_rules! with_api {\n+    ($S:ident, $self:ident, $m:ident) => {\n+        $m! {\n+            TokenStream {\n+                fn new() -> $S::TokenStream;\n+            },\n+            Group {\n+            },\n+        }\n+    };\n+}\n+macro_rules! associated_item {\n+    (type TokenStream) =>\n+        (type TokenStream: 'static + Clone;);\n+    (type Group) =>\n+        (type Group: 'static + Clone;);\n+    ($($item:tt)*) => ($($item)*;)\n+}\n+macro_rules! declare_server_traits {\n+    ($($name:ident {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n+    }),* $(,)?) => {\n+        pub trait Types {\n+            $(associated_item!(type $name);)*\n+        }\n+\n+        $(pub trait $name: Types {\n+            $(associated_item!(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n+        })*\n+\n+        pub trait Server: Types $(+ $name)* {}\n+        impl<S: Types $(+ $name)*> Server for S {}\n+    }\n+}\n+with_api!(Self, self_, declare_server_traits);\n+struct Group {}\n+struct TokenStream {}\n+struct Rustc;\n+impl Types for Rustc {\n+    type TokenStream = TokenStream;\n+    type Group = Group;\n+}\n+fn make<T>() -> T { loop {} }\n+impl TokenStream for Rustc {\n+    fn new() -> Self::TokenStream {\n+        let group: Self::Group = make();\n+        make()\n+    }\n+}\n+\"#, true),\n+        @r###\"\n+    [1115; 1126) '{ loop {} }': T\n+    [1117; 1124) 'loop {}': !\n+    [1122; 1124) '{}': ()\n+    [1190; 1253) '{     ...     }': {unknown}\n+    [1204; 1209) 'group': {unknown}\n+    [1225; 1229) 'make': fn make<{unknown}>() -> {unknown}\n+    [1225; 1231) 'make()': {unknown}\n+    [1241; 1245) 'make': fn make<{unknown}>() -> {unknown}\n+    [1241; 1247) 'make()': {unknown}\n+    \"###\n+    );\n+}\n+\n #[test]\n fn unify_impl_trait() {\n     assert_snapshot!(\n@@ -2022,6 +2153,33 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn associated_type_bound() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+pub trait Trait {\n+    type Item: OtherTrait<u32>;\n+}\n+pub trait OtherTrait<T> {\n+    fn foo(&self) -> T;\n+}\n+\n+// this is just a workaround for chalk#234\n+pub struct S<T>;\n+impl<T: Trait> Trait for S<T> {\n+    type Item = <T as Trait>::Item;\n+}\n+\n+fn test<T: Trait>() {\n+    let y: <S<T> as Trait>::Item = no_matter;\n+    y.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n #[test]\n fn dyn_trait_through_chalk() {\n     let t = type_at("}, {"sha": "05791a84868fdef628434a2e11d17e772191a6bc", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -16,10 +16,12 @@ use self::chalk::{from_chalk, Interner, ToChalk};\n pub(crate) mod chalk;\n mod builtin;\n \n-/// This controls the maximum size of types Chalk considers. If we set this too\n-/// high, we can run into slow edge cases; if we set it too low, Chalk won't\n-/// find some solutions.\n-const CHALK_SOLVER_MAX_SIZE: usize = 10;\n+// This controls the maximum size of types Chalk considers. If we set this too\n+// high, we can run into slow edge cases; if we set it too low, Chalk won't\n+// find some solutions.\n+// FIXME this is currently hardcoded in the recursive solver\n+// const CHALK_SOLVER_MAX_SIZE: usize = 10;\n+\n /// This controls how much 'time' we give the Chalk solver before giving up.\n const CHALK_SOLVER_FUEL: i32 = 100;\n \n@@ -30,8 +32,7 @@ struct ChalkContext<'a> {\n }\n \n fn create_chalk_solver() -> chalk_solve::Solver<Interner> {\n-    let solver_choice =\n-        chalk_solve::SolverChoice::SLG { max_size: CHALK_SOLVER_MAX_SIZE, expected_answers: None };\n+    let solver_choice = chalk_solve::SolverChoice::recursive();\n     solver_choice.into_solver()\n }\n \n@@ -194,13 +195,16 @@ fn solve(\n         }\n         remaining > 0\n     };\n-    let mut solve = || solver.solve_limited(&context, goal, should_continue);\n+    let mut solve = || {\n+        let solution = solver.solve_limited(&context, goal, should_continue);\n+        log::debug!(\"solve({:?}) => {:?}\", goal, solution);\n+        solution\n+    };\n     // don't set the TLS for Chalk unless Chalk debugging is active, to make\n     // extra sure we only use it for debugging\n     let solution =\n         if is_chalk_debug() { chalk::tls::set_current_program(db, solve) } else { solve() };\n \n-    log::debug!(\"solve({:?}) => {:?}\", goal, solution);\n     solution\n }\n "}, {"sha": "60d70d18e89d031612e196e4fc177ef66587daa8", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 138, "deletions": 22, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -32,6 +32,9 @@ impl chalk_ir::interner::Interner for Interner {\n     type InternedGoal = Arc<GoalData<Self>>;\n     type InternedGoals = Vec<Goal<Self>>;\n     type InternedSubstitution = Vec<Parameter<Self>>;\n+    type InternedProgramClause = chalk_ir::ProgramClauseData<Self>;\n+    type InternedProgramClauses = Vec<chalk_ir::ProgramClause<Self>>;\n+    type InternedQuantifiedWhereClauses = Vec<chalk_ir::QuantifiedWhereClause<Self>>;\n     type Identifier = TypeAliasId;\n     type DefId = InternId;\n \n@@ -181,6 +184,48 @@ impl chalk_ir::interner::Interner for Interner {\n     ) -> &'a [Parameter<Self>] {\n         substitution\n     }\n+\n+    fn intern_program_clause(\n+        &self,\n+        data: chalk_ir::ProgramClauseData<Self>,\n+    ) -> chalk_ir::ProgramClauseData<Self> {\n+        data\n+    }\n+\n+    fn program_clause_data<'a>(\n+        &self,\n+        clause: &'a chalk_ir::ProgramClauseData<Self>,\n+    ) -> &'a chalk_ir::ProgramClauseData<Self> {\n+        clause\n+    }\n+\n+    fn intern_program_clauses(\n+        &self,\n+        data: impl IntoIterator<Item = chalk_ir::ProgramClause<Self>>,\n+    ) -> Vec<chalk_ir::ProgramClause<Self>> {\n+        data.into_iter().collect()\n+    }\n+\n+    fn program_clauses_data<'a>(\n+        &self,\n+        clauses: &'a Vec<chalk_ir::ProgramClause<Self>>,\n+    ) -> &'a [chalk_ir::ProgramClause<Self>] {\n+        clauses\n+    }\n+\n+    fn intern_quantified_where_clauses(\n+        &self,\n+        data: impl IntoIterator<Item = chalk_ir::QuantifiedWhereClause<Self>>,\n+    ) -> Self::InternedQuantifiedWhereClauses {\n+        data.into_iter().collect()\n+    }\n+\n+    fn quantified_where_clauses_data<'a>(\n+        &self,\n+        clauses: &'a Self::InternedQuantifiedWhereClauses,\n+    ) -> &'a [chalk_ir::QuantifiedWhereClause<Self>] {\n+        clauses\n+    }\n }\n \n impl chalk_ir::interner::HasInterner for Interner {\n@@ -238,12 +283,10 @@ impl ToChalk for Ty {\n             Ty::Bound(idx) => chalk_ir::TyData::BoundVar(idx).intern(&Interner),\n             Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n             Ty::Dyn(predicates) => {\n-                let where_clauses = predicates\n-                    .iter()\n-                    .filter(|p| !p.is_error())\n-                    .cloned()\n-                    .map(|p| p.to_chalk(db))\n-                    .collect();\n+                let where_clauses = chalk_ir::QuantifiedWhereClauses::from(\n+                    &Interner,\n+                    predicates.iter().filter(|p| !p.is_error()).cloned().map(|p| p.to_chalk(db)),\n+                );\n                 let bounded_ty = chalk_ir::DynTy { bounds: make_binders(where_clauses, 1) };\n                 chalk_ir::TyData::Dyn(bounded_ty).intern(&Interner)\n             }\n@@ -281,8 +324,12 @@ impl ToChalk for Ty {\n             chalk_ir::TyData::InferenceVar(_iv) => Ty::Unknown,\n             chalk_ir::TyData::Dyn(where_clauses) => {\n                 assert_eq!(where_clauses.bounds.binders.len(), 1);\n-                let predicates =\n-                    where_clauses.bounds.value.into_iter().map(|c| from_chalk(db, c)).collect();\n+                let predicates = where_clauses\n+                    .bounds\n+                    .skip_binders()\n+                    .iter(&Interner)\n+                    .map(|c| from_chalk(db, c.clone()))\n+                    .collect();\n                 Ty::Dyn(predicates)\n             }\n         }\n@@ -426,7 +473,7 @@ impl ToChalk for GenericPredicate {\n     ) -> GenericPredicate {\n         // we don't produce any where clauses with binders and can't currently deal with them\n         match where_clause\n-            .value\n+            .skip_binders()\n             .shifted_out(&Interner)\n             .expect(\"unexpected bound vars in where clause\")\n         {\n@@ -464,13 +511,13 @@ impl ToChalk for ProjectionTy {\n }\n \n impl ToChalk for super::ProjectionPredicate {\n-    type Chalk = chalk_ir::Normalize<Interner>;\n+    type Chalk = chalk_ir::AliasEq<Interner>;\n \n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Normalize<Interner> {\n-        chalk_ir::Normalize { alias: self.projection_ty.to_chalk(db), ty: self.ty.to_chalk(db) }\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::AliasEq<Interner> {\n+        chalk_ir::AliasEq { alias: self.projection_ty.to_chalk(db), ty: self.ty.to_chalk(db) }\n     }\n \n-    fn from_chalk(_db: &dyn HirDatabase, _normalize: chalk_ir::Normalize<Interner>) -> Self {\n+    fn from_chalk(_db: &dyn HirDatabase, _normalize: chalk_ir::AliasEq<Interner>) -> Self {\n         unimplemented!()\n     }\n }\n@@ -521,7 +568,7 @@ impl ToChalk for Arc<super::TraitEnvironment> {\n                 pred.clone().to_chalk(db).cast(&Interner);\n             clauses.push(program_clause.into_from_env_clause(&Interner));\n         }\n-        chalk_ir::Environment::new().add_clauses(clauses)\n+        chalk_ir::Environment::new(&Interner).add_clauses(&Interner, clauses)\n     }\n \n     fn from_chalk(\n@@ -603,10 +650,10 @@ impl ToChalk for builtin::BuiltinImplAssocTyValueData {\n }\n \n fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T> {\n-    chalk_ir::Binders {\n+    chalk_ir::Binders::new(\n+        std::iter::repeat(chalk_ir::ParameterKind::Ty(())).take(num_vars).collect(),\n         value,\n-        binders: std::iter::repeat(chalk_ir::ParameterKind::Ty(())).take(num_vars).collect(),\n-    }\n+    )\n }\n \n fn convert_where_clauses(\n@@ -626,6 +673,55 @@ fn convert_where_clauses(\n     result\n }\n \n+fn generic_predicate_to_inline_bound(\n+    db: &dyn HirDatabase,\n+    pred: &GenericPredicate,\n+    self_ty: &Ty,\n+) -> Option<chalk_rust_ir::InlineBound<Interner>> {\n+    // An InlineBound is like a GenericPredicate, except the self type is left out.\n+    // We don't have a special type for this, but Chalk does.\n+    match pred {\n+        GenericPredicate::Implemented(trait_ref) => {\n+            if &trait_ref.substs[0] != self_ty {\n+                // we can only convert predicates back to type bounds if they\n+                // have the expected self type\n+                return None;\n+            }\n+            let args_no_self = trait_ref.substs[1..]\n+                .iter()\n+                .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n+                .collect();\n+            let trait_bound =\n+                chalk_rust_ir::TraitBound { trait_id: trait_ref.trait_.to_chalk(db), args_no_self };\n+            Some(chalk_rust_ir::InlineBound::TraitBound(trait_bound))\n+        }\n+        GenericPredicate::Projection(proj) => {\n+            if &proj.projection_ty.parameters[0] != self_ty {\n+                return None;\n+            }\n+            let trait_ = match proj.projection_ty.associated_ty.lookup(db.upcast()).container {\n+                AssocContainerId::TraitId(t) => t,\n+                _ => panic!(\"associated type not in trait\"),\n+            };\n+            let args_no_self = proj.projection_ty.parameters[1..]\n+                .iter()\n+                .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n+                .collect();\n+            let alias_eq_bound = chalk_rust_ir::AliasEqBound {\n+                value: proj.ty.clone().to_chalk(db),\n+                trait_bound: chalk_rust_ir::TraitBound {\n+                    trait_id: trait_.to_chalk(db),\n+                    args_no_self,\n+                },\n+                associated_ty_id: proj.projection_ty.associated_ty.to_chalk(db),\n+                parameters: Vec::new(), // FIXME we don't support generic associated types yet\n+            };\n+            Some(chalk_rust_ir::InlineBound::AliasEqBound(alias_eq_bound))\n+        }\n+        GenericPredicate::Error => None,\n+    }\n+}\n+\n impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     fn associated_ty_data(&self, id: AssocTypeId) -> Arc<AssociatedTyDatum> {\n         self.db.associated_ty_data(id)\n@@ -696,6 +792,13 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     fn interner(&self) -> &Interner {\n         &Interner\n     }\n+    fn well_known_trait_id(\n+        &self,\n+        _well_known_trait: chalk_rust_ir::WellKnownTrait,\n+    ) -> Option<chalk_ir::TraitId<Interner>> {\n+        // FIXME tell Chalk about well-known traits (here and in trait_datum)\n+        None\n+    }\n }\n \n pub(crate) fn associated_ty_data_query(\n@@ -708,12 +811,25 @@ pub(crate) fn associated_ty_data_query(\n         AssocContainerId::TraitId(t) => t,\n         _ => panic!(\"associated type not in trait\"),\n     };\n+\n+    // Lower bounds -- we could/should maybe move this to a separate query in `lower`\n+    let type_alias_data = db.type_alias_data(type_alias);\n     let generic_params = generics(db.upcast(), type_alias.into());\n-    let bound_data = chalk_rust_ir::AssociatedTyDatumBound {\n-        // FIXME add bounds and where clauses\n-        bounds: vec![],\n-        where_clauses: vec![],\n-    };\n+    let bound_vars = Substs::bound_vars(&generic_params);\n+    let resolver = hir_def::resolver::HasResolver::resolver(type_alias, db.upcast());\n+    let ctx = crate::TyLoweringContext::new(db, &resolver)\n+        .with_type_param_mode(crate::lower::TypeParamLoweringMode::Variable);\n+    let self_ty = Ty::Bound(crate::BoundVar::new(crate::DebruijnIndex::INNERMOST, 0));\n+    let bounds = type_alias_data\n+        .bounds\n+        .iter()\n+        .flat_map(|bound| GenericPredicate::from_type_bound(&ctx, bound, self_ty.clone()))\n+        .filter_map(|pred| generic_predicate_to_inline_bound(db, &pred, &self_ty))\n+        .map(|bound| make_binders(bound.shifted_in(&Interner), 0))\n+        .collect();\n+\n+    let where_clauses = convert_where_clauses(db, type_alias.into(), &bound_vars);\n+    let bound_data = chalk_rust_ir::AssociatedTyDatumBound { bounds, where_clauses };\n     let datum = AssociatedTyDatum {\n         trait_id: trait_.to_chalk(db),\n         id,"}, {"sha": "fa8e4d1ad182da56909d1e9d044b61c95fddc2cd", "filename": "crates/ra_hir_ty/src/traits/chalk/tls.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -2,10 +2,11 @@\n use std::fmt;\n \n use chalk_ir::{AliasTy, Goal, Goals, Lifetime, Parameter, ProgramClauseImplication, TypeName};\n+use itertools::Itertools;\n \n use super::{from_chalk, Interner};\n use crate::{db::HirDatabase, CallableDef, TypeCtor};\n-use hir_def::{AdtId, AssocContainerId, Lookup, TypeAliasId};\n+use hir_def::{AdtId, AssocContainerId, DefWithBodyId, Lookup, TypeAliasId};\n \n pub use unsafe_tls::{set_current_program, with_current_program};\n \n@@ -69,7 +70,27 @@ impl DebugContext<'_> {\n                 write!(f, \"{}::{}\", trait_name, name)?;\n             }\n             TypeCtor::Closure { def, expr } => {\n-                write!(f, \"{{closure {:?} in {:?}}}\", expr.into_raw(), def)?;\n+                write!(f, \"{{closure {:?} in \", expr.into_raw())?;\n+                match def {\n+                    DefWithBodyId::FunctionId(func) => {\n+                        write!(f, \"fn {}\", self.0.function_data(func).name)?\n+                    }\n+                    DefWithBodyId::StaticId(s) => {\n+                        if let Some(name) = self.0.static_data(s).name.as_ref() {\n+                            write!(f, \"body of static {}\", name)?;\n+                        } else {\n+                            write!(f, \"body of unnamed static {:?}\", s)?;\n+                        }\n+                    }\n+                    DefWithBodyId::ConstId(c) => {\n+                        if let Some(name) = self.0.const_data(c).name.as_ref() {\n+                            write!(f, \"body of const {}\", name)?;\n+                        } else {\n+                            write!(f, \"body of unnamed const {:?}\", c)?;\n+                        }\n+                    }\n+                };\n+                write!(f, \"}}\")?;\n             }\n         }\n         Ok(())\n@@ -113,14 +134,15 @@ impl DebugContext<'_> {\n         };\n         let trait_data = self.0.trait_data(trait_);\n         let params = alias.substitution.parameters(&Interner);\n-        write!(\n-            fmt,\n-            \"<{:?} as {}<{:?}>>::{}\",\n-            &params[0],\n-            trait_data.name,\n-            &params[1..],\n-            type_alias_data.name\n-        )\n+        write!(fmt, \"<{:?} as {}\", &params[0], trait_data.name,)?;\n+        if params.len() > 1 {\n+            write!(\n+                fmt,\n+                \"<{}>\",\n+                &params[1..].iter().format_with(\", \", |x, f| f(&format_args!(\"{:?}\", x))),\n+            )?;\n+        }\n+        write!(fmt, \">::{}\", type_alias_data.name)\n     }\n \n     pub fn debug_ty("}, {"sha": "05c940605222c23c4bf11c74fcd4a3e16410f3e8", "filename": "crates/ra_ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_ide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_ide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2FCargo.toml?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -35,4 +35,4 @@ ra_assists = { path = \"../ra_assists\" }\n hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n \n [dev-dependencies]\n-insta = \"0.15.0\"\n+insta = \"0.16.0\""}, {"sha": "6289f53f3f0ffe7ade71b38bdf99a0673e0095a6", "filename": "crates/ra_ide/src/display/navigation_target.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -175,7 +175,7 @@ impl ToNav for FileSymbol {\n         NavigationTarget {\n             file_id: self.file_id,\n             name: self.name.clone(),\n-            kind: self.ptr.kind(),\n+            kind: self.kind,\n             full_range: self.ptr.range(),\n             focus_range: self.name_range,\n             container_name: self.container_name.clone(),"}, {"sha": "937abb4330e0c2378242005cc605851e85c9561e", "filename": "crates/ra_ide_db/src/symbol_index.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -285,7 +285,7 @@ impl Query {\n                 let (start, end) = SymbolIndex::map_value_to_range(indexed_value.value);\n \n                 for symbol in &symbol_index.symbols[start..end] {\n-                    if self.only_types && !is_type(symbol.ptr.kind()) {\n+                    if self.only_types && !is_type(symbol.kind) {\n                         continue;\n                     }\n                     if self.exact && symbol.name != self.query {\n@@ -312,6 +312,7 @@ fn is_type(kind: SyntaxKind) -> bool {\n pub struct FileSymbol {\n     pub file_id: FileId,\n     pub name: SmolStr,\n+    pub kind: SyntaxKind,\n     pub ptr: SyntaxNodePtr,\n     pub name_range: Option<TextRange>,\n     pub container_name: Option<SmolStr>,\n@@ -377,6 +378,7 @@ fn to_symbol(node: &SyntaxNode) -> Option<(SmolStr, SyntaxNodePtr, TextRange)> {\n fn to_file_symbol(node: &SyntaxNode, file_id: FileId) -> Option<FileSymbol> {\n     to_symbol(node).map(move |(name, ptr, name_range)| FileSymbol {\n         name,\n+        kind: node.kind(),\n         ptr,\n         file_id,\n         name_range: Some(name_range),"}, {"sha": "31e9b22e7dc415bc40504f3016dabf80e71a3d21", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -607,12 +607,13 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n             let text: SmolStr = match self.cursor.token_tree() {\n                 Some(tt::TokenTree::Leaf(leaf)) => {\n                     // Mark the range if needed\n-                    let id = match leaf {\n-                        tt::Leaf::Ident(ident) => ident.id,\n-                        tt::Leaf::Punct(punct) => punct.id,\n-                        tt::Leaf::Literal(lit) => lit.id,\n+                    let (text, id) = match leaf {\n+                        tt::Leaf::Ident(ident) => (ident.text.clone(), ident.id),\n+                        tt::Leaf::Punct(punct) => {\n+                            (SmolStr::new_inline_from_ascii(1, &[punct.char as u8]), punct.id)\n+                        }\n+                        tt::Leaf::Literal(lit) => (lit.text.clone(), lit.id),\n                     };\n-                    let text = SmolStr::new(format!(\"{}\", leaf));\n                     let range = TextRange::offset_len(self.text_pos, TextUnit::of_str(&text));\n                     self.token_map.insert(id, range);\n                     self.cursor = self.cursor.bump();"}, {"sha": "b200fd12633e0e262082835829e60e43263d0b19", "filename": "crates/ra_proc_macro/src/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_proc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_proc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Flib.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -12,6 +12,7 @@ pub mod msg;\n use process::{ProcMacroProcessSrv, ProcMacroProcessThread};\n use ra_tt::{SmolStr, Subtree};\n use std::{\n+    ffi::OsStr,\n     path::{Path, PathBuf},\n     sync::Arc,\n };\n@@ -56,8 +57,15 @@ pub struct ProcMacroClient {\n }\n \n impl ProcMacroClient {\n-    pub fn extern_process(process_path: &Path) -> Result<ProcMacroClient, std::io::Error> {\n-        let (thread, process) = ProcMacroProcessSrv::run(process_path)?;\n+    pub fn extern_process<I, S>(\n+        process_path: &Path,\n+        args: I,\n+    ) -> Result<ProcMacroClient, std::io::Error>\n+    where\n+        I: IntoIterator<Item = S>,\n+        S: AsRef<OsStr>,\n+    {\n+        let (thread, process) = ProcMacroProcessSrv::run(process_path, args)?;\n         Ok(ProcMacroClient {\n             kind: ProcMacroClientKind::Process { process: Arc::new(process), thread },\n         })"}, {"sha": "f851570bca9f4c562e5d8eecc8411ce08f67cc8d", "filename": "crates/ra_proc_macro/src/process.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_proc_macro%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_proc_macro%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro%2Fsrc%2Fprocess.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -9,6 +9,7 @@ use crate::rpc::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTas\n use io::{BufRead, BufReader};\n use std::{\n     convert::{TryFrom, TryInto},\n+    ffi::OsStr,\n     io::{self, Write},\n     path::{Path, PathBuf},\n     process::{Child, Command, Stdio},\n@@ -44,8 +45,13 @@ impl Drop for Process {\n }\n \n impl Process {\n-    fn run(process_path: &Path) -> Result<Process, io::Error> {\n+    fn run<I, S>(process_path: &Path, args: I) -> Result<Process, io::Error>\n+    where\n+        I: IntoIterator<Item = S>,\n+        S: AsRef<OsStr>,\n+    {\n         let child = Command::new(process_path.clone())\n+            .args(args)\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped())\n             .stderr(Stdio::null())\n@@ -74,10 +80,15 @@ impl Process {\n }\n \n impl ProcMacroProcessSrv {\n-    pub fn run(\n+    pub fn run<I, S>(\n         process_path: &Path,\n-    ) -> Result<(ProcMacroProcessThread, ProcMacroProcessSrv), io::Error> {\n-        let process = Process::run(process_path)?;\n+        args: I,\n+    ) -> Result<(ProcMacroProcessThread, ProcMacroProcessSrv), io::Error>\n+    where\n+        I: IntoIterator<Item = S>,\n+        S: AsRef<OsStr>,\n+    {\n+        let process = Process::run(process_path, args)?;\n \n         let (task_tx, task_rx) = bounded(0);\n         let handle = jod_thread::spawn(move || {"}, {"sha": "c771f2b389115deb6078b4116eecec15bb6852b5", "filename": "crates/ra_proc_macro_srv/src/cli.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_proc_macro_srv%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_proc_macro_srv%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fcli.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -1,7 +1,7 @@\n //! Driver for proc macro server\n \n+use crate::{expand_task, list_macros};\n use ra_proc_macro::msg::{self, Message};\n-use ra_proc_macro_srv::{expand_task, list_macros};\n \n use std::io;\n \n@@ -24,7 +24,8 @@ fn write_response(res: Result<msg::Response, String>) -> Result<(), io::Error> {\n     let mut stdout = stdout.lock();\n     msg.write(&mut stdout)\n }\n-fn main() {\n+\n+pub fn run() {\n     loop {\n         let req = match read_request() {\n             Err(err) => {", "previous_filename": "crates/ra_proc_macro_srv/src/main.rs"}, {"sha": "c62b0ed893c03db3610ce2f969a2f430cf3a095d", "filename": "crates/ra_proc_macro_srv/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Flib.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -22,7 +22,7 @@ mod dylib;\n use proc_macro::bridge::client::TokenStream;\n use ra_proc_macro::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask};\n \n-pub fn expand_task(task: &ExpansionTask) -> Result<ExpansionResult, String> {\n+pub(crate) fn expand_task(task: &ExpansionTask) -> Result<ExpansionResult, String> {\n     let expander = dylib::Expander::new(&task.lib)\n         .expect(&format!(\"Cannot expand with provided libraries: ${:?}\", &task.lib));\n \n@@ -39,7 +39,7 @@ pub fn expand_task(task: &ExpansionTask) -> Result<ExpansionResult, String> {\n     }\n }\n \n-pub fn list_macros(task: &ListMacrosTask) -> Result<ListMacrosResult, String> {\n+pub(crate) fn list_macros(task: &ListMacrosTask) -> Result<ListMacrosResult, String> {\n     let expander = dylib::Expander::new(&task.lib)\n         .expect(&format!(\"Cannot expand with provided libraries: ${:?}\", &task.lib));\n \n@@ -53,5 +53,7 @@ pub fn list_macros(task: &ListMacrosTask) -> Result<ListMacrosResult, String> {\n     }\n }\n \n+pub mod cli;\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "03f2629dae0c76f970e503d92b0bd544d28e449e", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 110, "deletions": 121, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -5,9 +5,8 @@ mod json_project;\n mod sysroot;\n \n use std::{\n-    error::Error,\n     fs::{read_dir, File, ReadDir},\n-    io::BufReader,\n+    io::{self, BufReader},\n     path::{Path, PathBuf},\n     process::Command,\n };\n@@ -25,25 +24,6 @@ pub use crate::{\n };\n pub use ra_proc_macro::ProcMacroClient;\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct CargoTomlNotFoundError {\n-    pub searched_at: PathBuf,\n-    pub reason: String,\n-}\n-\n-impl std::fmt::Display for CargoTomlNotFoundError {\n-    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        write!(\n-            fmt,\n-            \"can't find Cargo.toml at {}, due to {}\",\n-            self.searched_at.display(),\n-            self.reason\n-        )\n-    }\n-}\n-\n-impl Error for CargoTomlNotFoundError {}\n-\n #[derive(Debug, Clone)]\n pub enum ProjectWorkspace {\n     /// Project workspace was discovered by running `cargo metadata` and `rustc --print sysroot`.\n@@ -77,31 +57,119 @@ impl PackageRoot {\n     }\n }\n \n-impl ProjectWorkspace {\n-    pub fn discover(path: &Path, cargo_features: &CargoConfig) -> Result<ProjectWorkspace> {\n-        ProjectWorkspace::discover_with_sysroot(path, true, cargo_features)\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum ProjectRoot {\n+    ProjectJson(PathBuf),\n+    CargoToml(PathBuf),\n+}\n+\n+impl ProjectRoot {\n+    pub fn from_manifest_file(path: PathBuf) -> Result<ProjectRoot> {\n+        if path.ends_with(\"rust-project.json\") {\n+            return Ok(ProjectRoot::ProjectJson(path));\n+        }\n+        if path.ends_with(\"Cargo.toml\") {\n+            return Ok(ProjectRoot::CargoToml(path));\n+        }\n+        bail!(\"project root must point to Cargo.toml or rust-project.json: {}\", path.display())\n     }\n \n-    pub fn discover_with_sysroot(\n-        path: &Path,\n-        with_sysroot: bool,\n+    pub fn discover_single(path: &Path) -> Result<ProjectRoot> {\n+        let mut candidates = ProjectRoot::discover(path)?;\n+        let res = match candidates.pop() {\n+            None => bail!(\"no projects\"),\n+            Some(it) => it,\n+        };\n+\n+        if !candidates.is_empty() {\n+            bail!(\"more than one project\")\n+        }\n+        Ok(res)\n+    }\n+\n+    pub fn discover(path: &Path) -> io::Result<Vec<ProjectRoot>> {\n+        if let Some(project_json) = find_rust_project_json(path) {\n+            return Ok(vec![ProjectRoot::ProjectJson(project_json)]);\n+        }\n+        return find_cargo_toml(path)\n+            .map(|paths| paths.into_iter().map(ProjectRoot::CargoToml).collect());\n+\n+        fn find_rust_project_json(path: &Path) -> Option<PathBuf> {\n+            if path.ends_with(\"rust-project.json\") {\n+                return Some(path.to_path_buf());\n+            }\n+\n+            let mut curr = Some(path);\n+            while let Some(path) = curr {\n+                let candidate = path.join(\"rust-project.json\");\n+                if candidate.exists() {\n+                    return Some(candidate);\n+                }\n+                curr = path.parent();\n+            }\n+\n+            None\n+        }\n+\n+        fn find_cargo_toml(path: &Path) -> io::Result<Vec<PathBuf>> {\n+            if path.ends_with(\"Cargo.toml\") {\n+                return Ok(vec![path.to_path_buf()]);\n+            }\n+\n+            if let Some(p) = find_cargo_toml_in_parent_dir(path) {\n+                return Ok(vec![p]);\n+            }\n+\n+            let entities = read_dir(path)?;\n+            Ok(find_cargo_toml_in_child_dir(entities))\n+        }\n+\n+        fn find_cargo_toml_in_parent_dir(path: &Path) -> Option<PathBuf> {\n+            let mut curr = Some(path);\n+            while let Some(path) = curr {\n+                let candidate = path.join(\"Cargo.toml\");\n+                if candidate.exists() {\n+                    return Some(candidate);\n+                }\n+                curr = path.parent();\n+            }\n+\n+            None\n+        }\n+\n+        fn find_cargo_toml_in_child_dir(entities: ReadDir) -> Vec<PathBuf> {\n+            // Only one level down to avoid cycles the easy way and stop a runaway scan with large projects\n+            let mut valid_canditates = vec![];\n+            for entity in entities.filter_map(Result::ok) {\n+                let candidate = entity.path().join(\"Cargo.toml\");\n+                if candidate.exists() {\n+                    valid_canditates.push(candidate)\n+                }\n+            }\n+            valid_canditates\n+        }\n+    }\n+}\n+\n+impl ProjectWorkspace {\n+    pub fn load(\n+        root: ProjectRoot,\n         cargo_features: &CargoConfig,\n+        with_sysroot: bool,\n     ) -> Result<ProjectWorkspace> {\n-        match find_rust_project_json(path) {\n-            Some(json_path) => {\n-                let file = File::open(&json_path)\n-                    .with_context(|| format!(\"Failed to open json file {}\", json_path.display()))?;\n+        let res = match root {\n+            ProjectRoot::ProjectJson(project_json) => {\n+                let file = File::open(&project_json).with_context(|| {\n+                    format!(\"Failed to open json file {}\", project_json.display())\n+                })?;\n                 let reader = BufReader::new(file);\n-                Ok(ProjectWorkspace::Json {\n+                ProjectWorkspace::Json {\n                     project: from_reader(reader).with_context(|| {\n-                        format!(\"Failed to deserialize json file {}\", json_path.display())\n+                        format!(\"Failed to deserialize json file {}\", project_json.display())\n                     })?,\n-                })\n+                }\n             }\n-            None => {\n-                let cargo_toml = find_cargo_toml(path).with_context(|| {\n-                    format!(\"Failed to find Cargo.toml for path {}\", path.display())\n-                })?;\n+            ProjectRoot::CargoToml(cargo_toml) => {\n                 let cargo = CargoWorkspace::from_cargo_metadata(&cargo_toml, cargo_features)\n                     .with_context(|| {\n                         format!(\n@@ -119,9 +187,11 @@ impl ProjectWorkspace {\n                 } else {\n                     Sysroot::default()\n                 };\n-                Ok(ProjectWorkspace::Cargo { cargo, sysroot })\n+                ProjectWorkspace::Cargo { cargo, sysroot }\n             }\n-        }\n+        };\n+\n+        Ok(res)\n     }\n \n     /// Returns the roots for the current `ProjectWorkspace`\n@@ -469,87 +539,6 @@ impl ProjectWorkspace {\n     }\n }\n \n-fn find_rust_project_json(path: &Path) -> Option<PathBuf> {\n-    if path.ends_with(\"rust-project.json\") {\n-        return Some(path.to_path_buf());\n-    }\n-\n-    let mut curr = Some(path);\n-    while let Some(path) = curr {\n-        let candidate = path.join(\"rust-project.json\");\n-        if candidate.exists() {\n-            return Some(candidate);\n-        }\n-        curr = path.parent();\n-    }\n-\n-    None\n-}\n-\n-fn find_cargo_toml_in_parent_dir(path: &Path) -> Option<PathBuf> {\n-    let mut curr = Some(path);\n-    while let Some(path) = curr {\n-        let candidate = path.join(\"Cargo.toml\");\n-        if candidate.exists() {\n-            return Some(candidate);\n-        }\n-        curr = path.parent();\n-    }\n-\n-    None\n-}\n-\n-fn find_cargo_toml_in_child_dir(entities: ReadDir) -> Vec<PathBuf> {\n-    // Only one level down to avoid cycles the easy way and stop a runaway scan with large projects\n-    let mut valid_canditates = vec![];\n-    for entity in entities.filter_map(Result::ok) {\n-        let candidate = entity.path().join(\"Cargo.toml\");\n-        if candidate.exists() {\n-            valid_canditates.push(candidate)\n-        }\n-    }\n-    valid_canditates\n-}\n-\n-fn find_cargo_toml(path: &Path) -> Result<PathBuf> {\n-    if path.ends_with(\"Cargo.toml\") {\n-        return Ok(path.to_path_buf());\n-    }\n-\n-    if let Some(p) = find_cargo_toml_in_parent_dir(path) {\n-        return Ok(p);\n-    }\n-\n-    let entities = match read_dir(path) {\n-        Ok(entities) => entities,\n-        Err(e) => {\n-            return Err(CargoTomlNotFoundError {\n-                searched_at: path.to_path_buf(),\n-                reason: format!(\"file system error: {}\", e),\n-            }\n-            .into());\n-        }\n-    };\n-\n-    let mut valid_canditates = find_cargo_toml_in_child_dir(entities);\n-    match valid_canditates.len() {\n-        1 => Ok(valid_canditates.remove(0)),\n-        0 => Err(CargoTomlNotFoundError {\n-            searched_at: path.to_path_buf(),\n-            reason: \"no Cargo.toml file found\".to_string(),\n-        }\n-        .into()),\n-        _ => Err(CargoTomlNotFoundError {\n-            searched_at: path.to_path_buf(),\n-            reason: format!(\n-                \"multiple equally valid Cargo.toml files found: {:?}\",\n-                valid_canditates\n-            ),\n-        }\n-        .into()),\n-    }\n-}\n-\n pub fn get_rustc_cfg_options() -> CfgOptions {\n     let mut cfg_options = CfgOptions::default();\n "}, {"sha": "ea41bf85d16684086e45ced8ecea0b555a3bf533", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -351,7 +351,7 @@ fn with_children(\n     // FIXME: use a more elegant way to re-fetch the node (#1185), make\n     // `range` private afterwards\n     let mut ptr = SyntaxNodePtr::new(parent);\n-    ptr.range = TextRange::offset_len(ptr.range().start(), len);\n+    ptr.range = TextRange::offset_len(ptr.range.start(), len);\n     ptr.to_node(&new_root_node)\n }\n "}, {"sha": "3be648c2ae5c12397fb5df34e8e225450697c80c", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -34,12 +34,8 @@ impl SyntaxNodePtr {\n         self.range\n     }\n \n-    pub fn kind(&self) -> SyntaxKind {\n-        self.kind\n-    }\n-\n     pub fn cast<N: AstNode>(self) -> Option<AstPtr<N>> {\n-        if !N::can_cast(self.kind()) {\n+        if !N::can_cast(self.kind) {\n             return None;\n         }\n         Some(AstPtr { raw: self, _ty: PhantomData })\n@@ -88,7 +84,7 @@ impl<N: AstNode> AstPtr<N> {\n     }\n \n     pub fn cast<U: AstNode>(self) -> Option<AstPtr<U>> {\n-        if !U::can_cast(self.raw.kind()) {\n+        if !U::can_cast(self.raw.kind) {\n             return None;\n         }\n         Some(AstPtr { raw: self.raw, _ty: PhantomData })"}, {"sha": "cee0248b62c545f55917a151e33fd313db08ca1a", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -46,7 +46,7 @@ ra_db = { path = \"../ra_db\" }\n hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n hir_ty = { path = \"../ra_hir_ty\", package = \"ra_hir_ty\" }\n-\n+ra_proc_macro_srv = { path = \"../ra_proc_macro_srv\" }\n \n [target.'cfg(windows)'.dependencies]\n winapi = \"0.3.8\""}, {"sha": "5e19253a65cc69b7add9d7e3dc9b26e05fdf8d95", "filename": "crates/rust-analyzer/src/bin/args.rs", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -29,12 +29,23 @@ pub(crate) enum Command {\n         with_deps: bool,\n         path: PathBuf,\n         load_output_dirs: bool,\n+        with_proc_macro: bool,\n     },\n     Bench {\n         path: PathBuf,\n         what: BenchWhat,\n         load_output_dirs: bool,\n+        with_proc_macro: bool,\n     },\n+    Diagnostics {\n+        path: PathBuf,\n+        load_output_dirs: bool,\n+        with_proc_macro: bool,\n+        /// Include files which are not modules. In rust-analyzer\n+        /// this would include the parser test files.\n+        all: bool,\n+    },\n+    ProcMacro,\n     RunServer,\n     Version,\n }\n@@ -141,6 +152,7 @@ FLAGS:\n     -h, --help              Prints help information\n         --memory-usage\n         --load-output-dirs  Load OUT_DIR values by running `cargo check` before analysis\n+        --with-proc-macro    Use ra-proc-macro-srv for proc-macro expanding\n     -v, --verbose\n     -q, --quiet\n \n@@ -158,6 +170,7 @@ ARGS:\n                 let only: Option<String> = matches.opt_value_from_str([\"-o\", \"--only\"])?;\n                 let with_deps: bool = matches.contains(\"--with-deps\");\n                 let load_output_dirs = matches.contains(\"--load-output-dirs\");\n+                let with_proc_macro = matches.contains(\"--with-proc-macro\");\n                 let path = {\n                     let mut trailing = matches.free()?;\n                     if trailing.len() != 1 {\n@@ -166,7 +179,15 @@ ARGS:\n                     trailing.pop().unwrap().into()\n                 };\n \n-                Command::Stats { randomize, memory_usage, only, with_deps, path, load_output_dirs }\n+                Command::Stats {\n+                    randomize,\n+                    memory_usage,\n+                    only,\n+                    with_deps,\n+                    path,\n+                    load_output_dirs,\n+                    with_proc_macro,\n+                }\n             }\n             \"analysis-bench\" => {\n                 if matches.contains([\"-h\", \"--help\"]) {\n@@ -180,6 +201,7 @@ USAGE:\n FLAGS:\n     -h, --help          Prints help information\n     --load-output-dirs  Load OUT_DIR values by running `cargo check` before analysis\n+    --with-proc-macro    Use ra-proc-macro-srv for proc-macro expanding\n     -v, --verbose\n \n OPTIONS:\n@@ -207,8 +229,43 @@ ARGS:\n                     ),\n                 };\n                 let load_output_dirs = matches.contains(\"--load-output-dirs\");\n-                Command::Bench { path, what, load_output_dirs }\n+                let with_proc_macro = matches.contains(\"--with-proc-macro\");\n+                Command::Bench { path, what, load_output_dirs, with_proc_macro }\n+            }\n+            \"diagnostics\" => {\n+                if matches.contains([\"-h\", \"--help\"]) {\n+                    eprintln!(\n+                        \"\\\n+ra-cli-diagnostics\n+\n+USAGE:\n+    rust-analyzer diagnostics [FLAGS] [PATH]\n+\n+FLAGS:\n+    -h, --help              Prints help information\n+        --load-output-dirs  Load OUT_DIR values by running `cargo check` before analysis\n+        --all               Include all files rather than only modules\n+\n+ARGS:\n+    <PATH>\"\n+                    );\n+                    return Ok(Err(HelpPrinted));\n+                }\n+\n+                let load_output_dirs = matches.contains(\"--load-output-dirs\");\n+                let with_proc_macro = matches.contains(\"--with-proc-macro\");\n+                let all = matches.contains(\"--all\");\n+                let path = {\n+                    let mut trailing = matches.free()?;\n+                    if trailing.len() != 1 {\n+                        bail!(\"Invalid flags\");\n+                    }\n+                    trailing.pop().unwrap().into()\n+                };\n+\n+                Command::Diagnostics { path, load_output_dirs, with_proc_macro, all }\n             }\n+            \"proc-macro\" => Command::ProcMacro,\n             _ => {\n                 eprintln!(\n                     \"\\"}, {"sha": "28b67cfe2aa47125ad947a9e286c73f106c8bcac", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -25,6 +25,7 @@ fn main() -> Result<()> {\n             with_deps,\n             path,\n             load_output_dirs,\n+            with_proc_macro,\n         } => cli::analysis_stats(\n             args.verbosity,\n             memory_usage,\n@@ -33,12 +34,24 @@ fn main() -> Result<()> {\n             with_deps,\n             randomize,\n             load_output_dirs,\n+            with_proc_macro,\n         )?,\n \n-        args::Command::Bench { path, what, load_output_dirs } => {\n-            cli::analysis_bench(args.verbosity, path.as_ref(), what, load_output_dirs)?\n+        args::Command::Bench { path, what, load_output_dirs, with_proc_macro } => {\n+            cli::analysis_bench(\n+                args.verbosity,\n+                path.as_ref(),\n+                what,\n+                load_output_dirs,\n+                with_proc_macro,\n+            )?\n         }\n \n+        args::Command::Diagnostics { path, load_output_dirs, with_proc_macro, all } => {\n+            cli::diagnostics(path.as_ref(), load_output_dirs, with_proc_macro, all)?\n+        }\n+\n+        args::Command::ProcMacro => run_proc_macro_sv()?,\n         args::Command::RunServer => run_server()?,\n         args::Command::Version => println!(\"rust-analyzer {}\", env!(\"REV\")),\n     }\n@@ -52,6 +65,11 @@ fn setup_logging() -> Result<()> {\n     Ok(())\n }\n \n+fn run_proc_macro_sv() -> Result<()> {\n+    ra_proc_macro_srv::cli::run();\n+    Ok(())\n+}\n+\n fn run_server() -> Result<()> {\n     log::info!(\"lifecycle: server started\");\n "}, {"sha": "a865a7c7e23be3f98e222a368ac0075f32aeab85", "filename": "crates/rust-analyzer/src/cli.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -3,6 +3,7 @@\n mod load_cargo;\n mod analysis_stats;\n mod analysis_bench;\n+mod diagnostics;\n mod progress_report;\n \n use std::io::Read;\n@@ -12,6 +13,10 @@ use ra_ide::{file_structure, Analysis};\n use ra_prof::profile;\n use ra_syntax::{AstNode, SourceFile};\n \n+pub use analysis_bench::{analysis_bench, BenchWhat, Position};\n+pub use analysis_stats::analysis_stats;\n+pub use diagnostics::diagnostics;\n+\n #[derive(Clone, Copy)]\n pub enum Verbosity {\n     Spammy,\n@@ -60,9 +65,6 @@ pub fn highlight(rainbow: bool) -> Result<()> {\n     Ok(())\n }\n \n-pub use analysis_bench::{analysis_bench, BenchWhat, Position};\n-pub use analysis_stats::analysis_stats;\n-\n fn file() -> Result<SourceFile> {\n     let text = read_stdin()?;\n     Ok(SourceFile::parse(&text).tree())"}, {"sha": "6147ae20743c4d7fbb7ed593876e9d4be2e8f29d", "filename": "crates/rust-analyzer/src/cli/analysis_bench.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -47,12 +47,13 @@ pub fn analysis_bench(\n     path: &Path,\n     what: BenchWhat,\n     load_output_dirs: bool,\n+    with_proc_macro: bool,\n ) -> Result<()> {\n     ra_prof::init();\n \n     let start = Instant::now();\n     eprint!(\"loading: \");\n-    let (mut host, roots) = load_cargo(path, load_output_dirs)?;\n+    let (mut host, roots) = load_cargo(path, load_output_dirs, with_proc_macro)?;\n     let db = host.raw_database();\n     eprintln!(\"{:?}\\n\", start.elapsed());\n "}, {"sha": "d442cbd63e31f5d3fcbd76a68587c03bc9e15bdb", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -25,9 +25,10 @@ pub fn analysis_stats(\n     with_deps: bool,\n     randomize: bool,\n     load_output_dirs: bool,\n+    with_proc_macro: bool,\n ) -> Result<()> {\n     let db_load_time = Instant::now();\n-    let (mut host, roots) = load_cargo(path, load_output_dirs)?;\n+    let (mut host, roots) = load_cargo(path, load_output_dirs, with_proc_macro)?;\n     let db = host.raw_database();\n     println!(\"Database loaded, {} roots, {:?}\", roots.len(), db_load_time.elapsed());\n     let analysis_time = Instant::now();"}, {"sha": "60daefa3ef7ffd4efbb330c7830dd741cf2a9df4", "filename": "crates/rust-analyzer/src/cli/diagnostics.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -0,0 +1,79 @@\n+//! Analyze all modules in a project for diagnostics. Exits with a non-zero status\n+//! code if any errors are found.\n+\n+use anyhow::anyhow;\n+use ra_db::SourceDatabaseExt;\n+use ra_ide::Severity;\n+use std::{collections::HashSet, path::Path};\n+\n+use crate::cli::{load_cargo::load_cargo, Result};\n+use hir::Semantics;\n+\n+pub fn diagnostics(\n+    path: &Path,\n+    load_output_dirs: bool,\n+    with_proc_macro: bool,\n+    all: bool,\n+) -> Result<()> {\n+    let (host, roots) = load_cargo(path, load_output_dirs, with_proc_macro)?;\n+    let db = host.raw_database();\n+    let analysis = host.analysis();\n+    let semantics = Semantics::new(db);\n+    let members = roots\n+        .into_iter()\n+        .filter_map(|(source_root_id, project_root)| {\n+            // filter out dependencies\n+            if project_root.is_member() {\n+                Some(source_root_id)\n+            } else {\n+                None\n+            }\n+        })\n+        .collect::<HashSet<_>>();\n+\n+    let mut found_error = false;\n+    let mut visited_files = HashSet::new();\n+    for source_root_id in members {\n+        for file_id in db.source_root(source_root_id).walk() {\n+            // Filter out files which are not actually modules (unless `--all` flag is\n+            // passed). In the rust-analyzer repository this filters out the parser test files.\n+            if semantics.to_module_def(file_id).is_some() || all {\n+                if !visited_files.contains(&file_id) {\n+                    let crate_name = if let Some(module) = semantics.to_module_def(file_id) {\n+                        if let Some(name) = module.krate().display_name(db) {\n+                            format!(\"{}\", name)\n+                        } else {\n+                            String::from(\"unknown\")\n+                        }\n+                    } else {\n+                        String::from(\"unknown\")\n+                    };\n+                    println!(\n+                        \"processing crate: {}, module: {}\",\n+                        crate_name,\n+                        db.file_relative_path(file_id)\n+                    );\n+                    for diagnostic in analysis.diagnostics(file_id).unwrap() {\n+                        if matches!(diagnostic.severity, Severity::Error) {\n+                            found_error = true;\n+                        }\n+\n+                        println!(\"{:?}\", diagnostic);\n+                    }\n+\n+                    visited_files.insert(file_id);\n+                }\n+            }\n+        }\n+    }\n+\n+    println!();\n+    println!(\"diagnostic scan complete\");\n+\n+    if found_error {\n+        println!();\n+        Err(anyhow!(\"diagnostic error detected\"))\n+    } else {\n+        Ok(())\n+    }\n+}"}, {"sha": "eb9ac32c3e8cdcd0c94512a0ce5ae4084e128d11", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -8,7 +8,7 @@ use crossbeam_channel::{unbounded, Receiver};\n use ra_db::{ExternSourceId, FileId, SourceRootId};\n use ra_ide::{AnalysisChange, AnalysisHost};\n use ra_project_model::{\n-    get_rustc_cfg_options, CargoConfig, PackageRoot, ProcMacroClient, ProjectWorkspace,\n+    get_rustc_cfg_options, CargoConfig, PackageRoot, ProcMacroClient, ProjectRoot, ProjectWorkspace,\n };\n use ra_vfs::{RootEntry, Vfs, VfsChange, VfsTask, Watch};\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -25,11 +25,14 @@ fn vfs_root_to_id(r: ra_vfs::VfsRoot) -> SourceRootId {\n pub(crate) fn load_cargo(\n     root: &Path,\n     load_out_dirs_from_check: bool,\n+    with_proc_macro: bool,\n ) -> Result<(AnalysisHost, FxHashMap<SourceRootId, PackageRoot>)> {\n     let root = std::env::current_dir()?.join(root);\n-    let ws = ProjectWorkspace::discover(\n-        root.as_ref(),\n+    let root = ProjectRoot::discover_single(&root)?;\n+    let ws = ProjectWorkspace::load(\n+        root,\n         &CargoConfig { load_out_dirs_from_check, ..Default::default() },\n+        true,\n     )?;\n \n     let mut extern_dirs = FxHashSet::default();\n@@ -69,7 +72,14 @@ pub(crate) fn load_cargo(\n         })\n         .collect::<FxHashMap<_, _>>();\n \n-    let proc_macro_client = ProcMacroClient::dummy();\n+    let proc_macro_client = if !with_proc_macro {\n+        ProcMacroClient::dummy()\n+    } else {\n+        let mut path = std::env::current_exe()?;\n+        path.pop();\n+        path.push(\"rust-analyzer\");\n+        ProcMacroClient::extern_process(&path, &[\"proc-macro\"]).unwrap()\n+    };\n     let host = load(&source_roots, ws, &mut vfs, receiver, extern_dirs, &proc_macro_client);\n     Ok((host, source_roots))\n }\n@@ -175,7 +185,7 @@ mod tests {\n     #[test]\n     fn test_loading_rust_analyzer() {\n         let path = Path::new(env!(\"CARGO_MANIFEST_DIR\")).parent().unwrap().parent().unwrap();\n-        let (host, _roots) = load_cargo(path, false).unwrap();\n+        let (host, _roots) = load_cargo(path, false, false).unwrap();\n         let n_crates = Crate::all(host.raw_database()).len();\n         // RA has quite a few crates, but the exact count doesn't matter\n         assert!(n_crates > 20);"}, {"sha": "2b45f131031574a3aff7c1fd38fe00b0696ae0f0", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -20,7 +20,7 @@ pub struct Config {\n     pub with_sysroot: bool,\n     pub publish_diagnostics: bool,\n     pub lru_capacity: Option<usize>,\n-    pub proc_macro_srv: Option<String>,\n+    pub proc_macro_srv: Option<(String, Vec<String>)>,\n     pub files: FilesConfig,\n     pub notifications: NotificationsConfig,\n \n@@ -131,6 +131,18 @@ impl Config {\n         set(value, \"/cargo/allFeatures\", &mut self.cargo.all_features);\n         set(value, \"/cargo/features\", &mut self.cargo.features);\n         set(value, \"/cargo/loadOutDirsFromCheck\", &mut self.cargo.load_out_dirs_from_check);\n+\n+        match get::<bool>(value, \"/procMacro/enabled\") {\n+            Some(true) => {\n+                if let Ok(mut path) = std::env::current_exe() {\n+                    path.pop();\n+                    path.push(\"rust-analyzer\");\n+                    self.proc_macro_srv = Some((path.to_string_lossy().to_string(), vec![\"proc-macro\".to_string()]));\n+                }\n+            }\n+            _ => self.proc_macro_srv = None,\n+        }\n+\n         match get::<Vec<String>>(value, \"/rustfmt/overrideCommand\") {\n             Some(mut args) if !args.is_empty() => {\n                 let command = args.remove(0);"}, {"sha": "fc4c77f8aa5cab89b926cff3c0c468cb9574d3f7", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -15,6 +15,7 @@ use std::{\n };\n \n use crossbeam_channel::{never, select, unbounded, RecvError, Sender};\n+use itertools::Itertools;\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n use lsp_types::{\n     NumberOrString, WorkDoneProgress, WorkDoneProgressBegin, WorkDoneProgressCreateParams,\n@@ -88,37 +89,46 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n \n     let mut loop_state = LoopState::default();\n     let mut world_state = {\n-        // FIXME: support dynamic workspace loading.\n         let workspaces = {\n-            let mut loaded_workspaces = Vec::new();\n-            for ws_root in &ws_roots {\n-                let workspace = ra_project_model::ProjectWorkspace::discover_with_sysroot(\n-                    ws_root.as_path(),\n-                    config.with_sysroot,\n-                    &config.cargo,\n-                );\n-                match workspace {\n-                    Ok(workspace) => loaded_workspaces.push(workspace),\n-                    Err(e) => {\n-                        log::error!(\"loading workspace failed: {:?}\", e);\n-\n-                        if let Some(ra_project_model::CargoTomlNotFoundError { .. }) =\n-                            e.downcast_ref()\n-                        {\n-                            if !config.notifications.cargo_toml_not_found {\n-                                continue;\n-                            }\n-                        }\n+            // FIXME: support dynamic workspace loading.\n+            let mut visited = FxHashSet::default();\n+            let project_roots = ws_roots\n+                .iter()\n+                .filter_map(|it| ra_project_model::ProjectRoot::discover(it).ok())\n+                .flatten()\n+                .filter(|it| visited.insert(it.clone()))\n+                .collect::<Vec<_>>();\n+\n+            if project_roots.is_empty() && config.notifications.cargo_toml_not_found {\n+                show_message(\n+                        req::MessageType::Error,\n+                        format!(\n+                            \"rust-analyzer failed to discover workspace, no Cargo.toml found, dirs searched: {}\",\n+                            ws_roots.iter().format_with(\", \", |it, f| f(&it.display()))\n+                        ),\n+                        &connection.sender,\n+                    );\n+            };\n \n+            project_roots\n+                .into_iter()\n+                .filter_map(|root| {\n+                    ra_project_model::ProjectWorkspace::load(\n+                        root,\n+                        &config.cargo,\n+                        config.with_sysroot,\n+                    )\n+                    .map_err(|err| {\n+                        log::error!(\"failed to load workspace: {:#}\", err);\n                         show_message(\n                             req::MessageType::Error,\n-                            format!(\"rust-analyzer failed to load workspace: {:?}\", e),\n+                            format!(\"rust-analyzer failed to load workspace: {:#}\", err),\n                             &connection.sender,\n                         );\n-                    }\n-                }\n-            }\n-            loaded_workspaces\n+                    })\n+                    .ok()\n+                })\n+                .collect::<Vec<_>>()\n         };\n \n         let globs = config"}, {"sha": "f2ad453fafe40ada08c71a450faaca1b1f51b92a", "filename": "crates/rust-analyzer/src/world.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fworld.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -64,6 +64,7 @@ pub struct WorldState {\n     pub latest_requests: Arc<RwLock<LatestRequests>>,\n     pub flycheck: Option<Flycheck>,\n     pub diagnostics: DiagnosticCollection,\n+    pub proc_macro_client: ProcMacroClient,\n }\n \n /// An immutable snapshot of the world's state at a point in time.\n@@ -147,9 +148,9 @@ impl WorldState {\n \n         let proc_macro_client = match &config.proc_macro_srv {\n             None => ProcMacroClient::dummy(),\n-            Some(srv) => {\n-                let path = Path::new(&srv);\n-                match ProcMacroClient::extern_process(path) {\n+            Some((path, args)) => {\n+                let path = std::path::Path::new(path);\n+                match ProcMacroClient::extern_process(path, args) {\n                     Ok(it) => it,\n                     Err(err) => {\n                         log::error!(\n@@ -192,6 +193,7 @@ impl WorldState {\n             latest_requests: Default::default(),\n             flycheck,\n             diagnostics: Default::default(),\n+            proc_macro_client,\n         }\n     }\n "}, {"sha": "1dd2676b6e960428c77050579f71284ff98fe1b1", "filename": "crates/rust-analyzer/tests/heavy_tests/main.rs", "status": "modified", "additions": 90, "deletions": 1, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -9,7 +9,7 @@ use lsp_types::{\n };\n use rust_analyzer::req::{\n     CodeActionParams, CodeActionRequest, Completion, CompletionParams, DidOpenTextDocument,\n-    Formatting, GotoDefinition, OnEnter, Runnables, RunnablesParams,\n+    Formatting, GotoDefinition, HoverRequest, OnEnter, Runnables, RunnablesParams,\n };\n use serde_json::json;\n use tempfile::TempDir;\n@@ -625,3 +625,92 @@ fn main() { message(); }\n     ));\n     assert!(format!(\"{}\", res).contains(\"hello.rs\"));\n }\n+\n+#[test]\n+fn resolve_proc_macro() {\n+    if skip_slow_tests() {\n+        return;\n+    }\n+    let server = Project::with_fixture(\n+        r###\"\n+//- foo/Cargo.toml\n+[package]\n+name = \"foo\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+[dependencies]\n+bar = {path = \"../bar\"}\n+\n+//- foo/src/main.rs\n+use bar::Bar;\n+trait Bar {\n+  fn bar();\n+}\n+#[derive(Bar)]\n+struct Foo {}\n+fn main() {\n+  Foo::bar();\n+}\n+\n+//- bar/Cargo.toml\n+[package]\n+name = \"bar\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+proc-macro = true\n+\n+//- bar/src/lib.rs\n+extern crate proc_macro;\n+use proc_macro::{Delimiter, Group, Ident, Span, TokenStream, TokenTree};\n+macro_rules! t {\n+    ($n:literal) => {\n+        TokenTree::from(Ident::new($n, Span::call_site()))\n+    };\n+    ({}) => {\n+        TokenTree::from(Group::new(Delimiter::Brace, TokenStream::new()))\n+    };\n+    (()) => {\n+        TokenTree::from(Group::new(Delimiter::Parenthesis, TokenStream::new()))\n+    };\n+}\n+#[proc_macro_derive(Bar)]\n+pub fn foo(_input: TokenStream) -> TokenStream {\n+    // We hard code the output here for preventing to use any deps\n+    let mut res = TokenStream::new();\n+\n+    // impl Bar for Foo { fn bar() {} }\n+    let mut tokens = vec![t!(\"impl\"), t!(\"Bar\"), t!(\"for\"), t!(\"Foo\")];\n+    let mut fn_stream = TokenStream::new();\n+    fn_stream.extend(vec![t!(\"fn\"), t!(\"bar\"), t!(()), t!({})]);\n+    tokens.push(Group::new(Delimiter::Brace, fn_stream).into());\n+    res.extend(tokens);\n+    res\n+}\n+\n+\"###,\n+    )\n+    .with_config(|config| {\n+        // FIXME: Use env!(\"CARGO_BIN_EXE_ra-analyzer\") instead after\n+        // https://github.com/rust-lang/cargo/pull/7697 landed\n+        let macro_srv_path = std::path::Path::new(std::env!(\"CARGO_MANIFEST_DIR\"))\n+            .join(\"../../target/debug/rust-analyzer\")\n+            .to_string_lossy()\n+            .to_string();\n+\n+        config.cargo.load_out_dirs_from_check = true;\n+        config.proc_macro_srv = Some((macro_srv_path, vec![\"proc-macro\".to_string()]));\n+    })\n+    .root(\"foo\")\n+    .root(\"bar\")\n+    .server();\n+    server.wait_until_workspace_is_loaded();\n+    let res = server.send_request::<HoverRequest>(TextDocumentPositionParams::new(\n+        server.doc_id(\"foo/src/main.rs\"),\n+        Position::new(7, 9),\n+    ));\n+\n+    let value = res.get(\"contents\").unwrap().get(\"value\").unwrap().to_string();\n+    assert_eq!(value, r#\"\"```rust\\nfoo::Bar\\nfn bar()\\n```\"\"#)\n+}"}, {"sha": "6483ba4f3e35c37659a451e43ba75506f2c63bdb", "filename": "docs/user/assists.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -77,7 +77,7 @@ fn foo() {\n }\n \n fn bar(arg: &str, baz: Baz) {\n-    unimplemented!()\n+    todo!()\n }\n \n ```"}, {"sha": "e11cffd68fdcbf5a5e3d6985f8e2d8ae8a642ebd", "filename": "editors/code/package-lock.json", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/editors%2Fcode%2Fpackage-lock.json", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/editors%2Fcode%2Fpackage-lock.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage-lock.json?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -109,9 +109,9 @@\n             }\n         },\n         \"@types/vscode\": {\n-            \"version\": \"1.43.0\",\n-            \"resolved\": \"https://registry.npmjs.org/@types/vscode/-/vscode-1.43.0.tgz\",\n-            \"integrity\": \"sha512-kIaR9qzd80rJOxePKpCB/mdy00mz8Apt2QA5Y6rdrKFn13QNFNeP3Hzmsf37Bwh/3cS7QjtAeGSK7wSqAU0sYQ==\",\n+            \"version\": \"1.44.0\",\n+            \"resolved\": \"https://registry.npmjs.org/@types/vscode/-/vscode-1.44.0.tgz\",\n+            \"integrity\": \"sha512-WJZtZlinE3meRdH+I7wTsIhpz/GLhqEQwmPGeh4s1irWLwMzCeTV8WZ+pgPTwrDXoafVUWwo1LiZ9HJVHFlJSQ==\",\n             \"dev\": true\n         },\n         \"@typescript-eslint/eslint-plugin\": {\n@@ -1776,32 +1776,32 @@\n             }\n         },\n         \"vscode-jsonrpc\": {\n-            \"version\": \"5.0.1\",\n-            \"resolved\": \"https://registry.npmjs.org/vscode-jsonrpc/-/vscode-jsonrpc-5.0.1.tgz\",\n-            \"integrity\": \"sha512-JvONPptw3GAQGXlVV2utDcHx0BiY34FupW/kI6mZ5x06ER5DdPG/tXWMVHjTNULF5uKPOUUD0SaXg5QaubJL0A==\"\n+            \"version\": \"5.1.0-next.1\",\n+            \"resolved\": \"https://registry.npmjs.org/vscode-jsonrpc/-/vscode-jsonrpc-5.1.0-next.1.tgz\",\n+            \"integrity\": \"sha512-mwLDojZkbmpizSJSmp690oa9FB9jig18SIDGZeBCvFc2/LYSRvMm/WwWtMBJuJ1MfFh7rZXfQige4Uje5Z9NzA==\"\n         },\n         \"vscode-languageclient\": {\n-            \"version\": \"6.1.3\",\n-            \"resolved\": \"https://registry.npmjs.org/vscode-languageclient/-/vscode-languageclient-6.1.3.tgz\",\n-            \"integrity\": \"sha512-YciJxk08iU5LmWu7j5dUt9/1OLjokKET6rME3cI4BRpiF6HZlusm2ZwPt0MYJ0lV5y43sZsQHhyon2xBg4ZJVA==\",\n+            \"version\": \"7.0.0-next.1\",\n+            \"resolved\": \"https://registry.npmjs.org/vscode-languageclient/-/vscode-languageclient-7.0.0-next.1.tgz\",\n+            \"integrity\": \"sha512-JrjCUhLpQZxQ5VpWpilOHDMhVsn0fdN5jBh1uFNhSr5c2loJvRdr9Km2EuSQOFfOQsBKx0+xvY8PbsypNEcJ6w==\",\n             \"requires\": {\n                 \"semver\": \"^6.3.0\",\n-                \"vscode-languageserver-protocol\": \"^3.15.3\"\n+                \"vscode-languageserver-protocol\": \"3.16.0-next.2\"\n             }\n         },\n         \"vscode-languageserver-protocol\": {\n-            \"version\": \"3.15.3\",\n-            \"resolved\": \"https://registry.npmjs.org/vscode-languageserver-protocol/-/vscode-languageserver-protocol-3.15.3.tgz\",\n-            \"integrity\": \"sha512-zrMuwHOAQRhjDSnflWdJG+O2ztMWss8GqUUB8dXLR/FPenwkiBNkMIJJYfSN6sgskvsF0rHAoBowNQfbyZnnvw==\",\n+            \"version\": \"3.16.0-next.2\",\n+            \"resolved\": \"https://registry.npmjs.org/vscode-languageserver-protocol/-/vscode-languageserver-protocol-3.16.0-next.2.tgz\",\n+            \"integrity\": \"sha512-atmkGT/W6tF0cx4SaWFYtFs2UeSeC28RPiap9myv2YZTaTCFvTBEPNWrU5QRKfkyM0tbgtGo6T3UCQ8tkDpjzA==\",\n             \"requires\": {\n-                \"vscode-jsonrpc\": \"^5.0.1\",\n-                \"vscode-languageserver-types\": \"3.15.1\"\n+                \"vscode-jsonrpc\": \"5.1.0-next.1\",\n+                \"vscode-languageserver-types\": \"3.16.0-next.1\"\n             }\n         },\n         \"vscode-languageserver-types\": {\n-            \"version\": \"3.15.1\",\n-            \"resolved\": \"https://registry.npmjs.org/vscode-languageserver-types/-/vscode-languageserver-types-3.15.1.tgz\",\n-            \"integrity\": \"sha512-+a9MPUQrNGRrGU630OGbYVQ+11iOIovjCkqxajPa9w57Sd5ruK8WQNsslzpa0x/QJqC8kRc2DUxWjIFwoNm4ZQ==\"\n+            \"version\": \"3.16.0-next.1\",\n+            \"resolved\": \"https://registry.npmjs.org/vscode-languageserver-types/-/vscode-languageserver-types-3.16.0-next.1.tgz\",\n+            \"integrity\": \"sha512-tZFUSbyjUcrh+qQf13ALX4QDdOfDX0cVaBFgy7ktJ0VwS7AW/yRKgGPSxVqqP9OCMNPdqP57O5q47w2pEwfaUg==\"\n         },\n         \"which\": {\n             \"version\": \"1.3.1\","}, {"sha": "5ce59e54a96975208bc335fed03738de912e80d4", "filename": "editors/code/package.json", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -34,14 +34,14 @@\n     \"dependencies\": {\n         \"jsonc-parser\": \"^2.2.1\",\n         \"node-fetch\": \"^2.6.0\",\n-        \"vscode-languageclient\": \"6.1.3\"\n+        \"vscode-languageclient\": \"7.0.0-next.1\"\n     },\n     \"devDependencies\": {\n         \"@rollup/plugin-commonjs\": \"^11.0.2\",\n         \"@rollup/plugin-node-resolve\": \"^7.1.1\",\n         \"@types/node\": \"^12.12.34\",\n         \"@types/node-fetch\": \"^2.5.5\",\n-        \"@types/vscode\": \"^1.43.0\",\n+        \"@types/vscode\": \"^1.44.0\",\n         \"@typescript-eslint/eslint-plugin\": \"^2.27.0\",\n         \"@typescript-eslint/parser\": \"^2.27.0\",\n         \"eslint\": \"^6.8.0\",\n@@ -154,7 +154,7 @@\n         \"keybindings\": [\n             {\n                 \"command\": \"rust-analyzer.parentModule\",\n-                \"key\": \"ctrl+u\",\n+                \"key\": \"ctrl+shift+u\",\n                 \"when\": \"editorTextFocus && editorLangId == rust\"\n             },\n             {\n@@ -388,6 +388,11 @@\n                     \"description\": \"Enable logging of VS Code extensions itself\",\n                     \"type\": \"boolean\",\n                     \"default\": false\n+                },\n+                \"rust-analyzer.procMacro.enabled\": {\n+                    \"description\": \"Enable Proc macro support, cargo.loadOutDirsFromCheck must be enabled.\",\n+                    \"type\": \"boolean\",\n+                    \"default\": false\n                 }\n             }\n         },"}, {"sha": "3b2eec8baa70cb3a93d3b93b3f00db7bb5d33736", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -12,6 +12,7 @@ export class Config {\n     private readonly requiresReloadOpts = [\n         \"serverPath\",\n         \"cargo\",\n+        \"procMacro\",\n         \"files\",\n         \"highlighting\",\n         \"updates.channel\","}, {"sha": "a09531797064fc947dd5a3c4099972c40fcc7dc9", "filename": "editors/code/src/inlay_hints.ts", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/editors%2Fcode%2Fsrc%2Finlay_hints.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/editors%2Fcode%2Fsrc%2Finlay_hints.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Finlay_hints.ts?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -3,20 +3,21 @@ import * as vscode from 'vscode';\n import * as ra from './rust-analyzer-api';\n \n import { Ctx, Disposable } from './ctx';\n-import { sendRequestWithRetry, isRustDocument, RustDocument, RustEditor } from './util';\n+import { sendRequestWithRetry, isRustDocument, RustDocument, RustEditor, sleep } from './util';\n \n \n export function activateInlayHints(ctx: Ctx) {\n     const maybeUpdater = {\n         updater: null as null | HintsUpdater,\n-        onConfigChange() {\n+        async onConfigChange() {\n             if (\n                 !ctx.config.inlayHints.typeHints &&\n                 !ctx.config.inlayHints.parameterHints &&\n                 !ctx.config.inlayHints.chainingHints\n             ) {\n                 return this.dispose();\n             }\n+            await sleep(100);\n             if (this.updater) {\n                 this.updater.syncCacheAndRenderHints();\n             } else {"}, {"sha": "ead642acc6db0a71fc59eac730b8d69d15ba1b39", "filename": "xtask/tests/tidy-tests/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a1585075c65dd6049fc11c641309c89210e222d/xtask%2Ftests%2Ftidy-tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1585075c65dd6049fc11c641309c89210e222d/xtask%2Ftests%2Ftidy-tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy-tests%2Fmain.rs?ref=0a1585075c65dd6049fc11c641309c89210e222d", "patch": "@@ -26,6 +26,7 @@ fn check_todo(path: &Path, text: &str) {\n         // Some of our assists generate `todo!()` so those files are whitelisted.\n         \"doc_tests/generated.rs\",\n         \"handlers/add_missing_impl_members.rs\",\n+        \"handlers/add_function.rs\",\n         // To support generating `todo!()` in assists, we have `expr_todo()` in ast::make.\n         \"ast/make.rs\",\n     ];"}]}