{"sha": "ab6bb035e50f735cb36cc1959e5a097f076a3b74", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNmJiMDM1ZTUwZjczNWNiMzZjYzE5NTllNWEwOTdmMDc2YTNiNzQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-02T00:27:58Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-02T00:27:58Z"}, "message": "Rename std::istr to std::str. Issue #855", "tree": {"sha": "21cb2954ef9cfe15134fec56f8888ddefce771bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21cb2954ef9cfe15134fec56f8888ddefce771bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab6bb035e50f735cb36cc1959e5a097f076a3b74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab6bb035e50f735cb36cc1959e5a097f076a3b74", "html_url": "https://github.com/rust-lang/rust/commit/ab6bb035e50f735cb36cc1959e5a097f076a3b74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab6bb035e50f735cb36cc1959e5a097f076a3b74/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "913667ba2550cbc6b8673580ef90d025d4abd205", "url": "https://api.github.com/repos/rust-lang/rust/commits/913667ba2550cbc6b8673580ef90d025d4abd205", "html_url": "https://github.com/rust-lang/rust/commit/913667ba2550cbc6b8673580ef90d025d4abd205"}], "stats": {"total": 1482, "additions": 741, "deletions": 741}, "files": [{"sha": "7ff80d70ce5632e521f701726569443d3157895e", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -5,7 +5,7 @@ import front::attr;\n import middle::ty;\n import metadata::encoder;\n import middle::trans_common::crate_ctxt;\n-import std::istr;\n+import std::str;\n import std::fs;\n import std::vec;\n import std::option;\n@@ -37,15 +37,15 @@ fn llvm_err(sess: session::session, msg: &istr) {\n         sess.fatal(msg);\n     } else {\n         sess.fatal(\n-            msg + ~\": \" + istr::str_from_cstr(buf));\n+            msg + ~\": \" + str::str_from_cstr(buf));\n     }\n }\n \n fn link_intrinsics(sess: session::session, llmod: ModuleRef) {\n     let path =\n         fs::connect(sess.get_opts().sysroot,\n                     ~\"lib/intrinsics.bc\");\n-    let membuf = istr::as_buf(path, { |buf|\n+    let membuf = str::as_buf(path, { |buf|\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n     });\n     if membuf as uint == 0u {\n@@ -78,11 +78,11 @@ mod write {\n     // Decides what to call an intermediate file, given the name of the output\n     // and the extension to use.\n     fn mk_intermediate_name(output_path: &istr, extension: &istr) -> istr {\n-        let dot_pos = istr::index(output_path, '.' as u8);\n+        let dot_pos = str::index(output_path, '.' as u8);\n         let stem;\n         if dot_pos < 0 {\n             stem = output_path;\n-        } else { stem = istr::substr(output_path, 0u, dot_pos as uint); }\n+        } else { stem = str::substr(output_path, 0u, dot_pos as uint); }\n         ret stem + ~\".\" + extension;\n     }\n     fn run_passes(sess: session::session, llmod: ModuleRef, output: &istr) {\n@@ -103,14 +103,14 @@ mod write {\n               output_type_bitcode. {\n                 if opts.optimize != 0u {\n                     let filename = mk_intermediate_name(output, ~\"no-opt.bc\");\n-                    istr::as_buf(filename, { |buf|\n+                    str::as_buf(filename, { |buf|\n                         llvm::LLVMWriteBitcodeToFile(llmod, buf)\n                     });\n                 }\n               }\n               _ {\n                 let filename = mk_intermediate_name(output, ~\"bc\");\n-                istr::as_buf(filename, { |buf|\n+                str::as_buf(filename, { |buf|\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf)\n                 });\n               }\n@@ -185,16 +185,16 @@ mod write {\n \n                 let filename = mk_intermediate_name(output, ~\"opt.bc\");\n                 llvm::LLVMRunPassManager(pm.llpm, llmod);\n-                istr::as_buf(filename, { |buf|\n+                str::as_buf(filename, { |buf|\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf)\n                 });\n                 pm = mk_pass_manager();\n                 // Save the assembly file if -S is used\n \n                 if opts.output_type == output_type_assembly {\n                     let _: () =\n-                        istr::as_buf(x86::get_target_triple(), { |buf_t|\n-                            istr::as_buf(output, { |buf_o|\n+                        str::as_buf(x86::get_target_triple(), { |buf_t|\n+                            str::as_buf(output, { |buf_o|\n                                 llvm::LLVMRustWriteOutputFile(\n                                     pm.llpm, llmod,\n                                     buf_t,\n@@ -210,8 +210,8 @@ mod write {\n                 if opts.output_type == output_type_object ||\n                        opts.output_type == output_type_exe {\n                     let _: () =\n-                        istr::as_buf(x86::get_target_triple(), { |buf_t|\n-                            istr::as_buf(output, { |buf_o|\n+                        str::as_buf(x86::get_target_triple(), { |buf_t|\n+                            str::as_buf(output, { |buf_o|\n                                 llvm::LLVMRustWriteOutputFile(\n                                     pm.llpm, llmod,\n                                     buf_t,\n@@ -224,8 +224,8 @@ mod write {\n                 // If we aren't saving temps then just output the file\n                 // type corresponding to the '-c' or '-S' flag used\n \n-                let _: () = istr::as_buf(x86::get_target_triple(), { |buf_t|\n-                    istr::as_buf(output, { |buf_o|\n+                let _: () = str::as_buf(x86::get_target_triple(), { |buf_t|\n+                    str::as_buf(output, { |buf_o|\n                         llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n                                                       buf_t,\n                                                       buf_o,\n@@ -243,7 +243,7 @@ mod write {\n         // flag, then output it here\n \n         llvm::LLVMRunPassManager(pm.llpm, llmod);\n-        istr::as_buf(output, { |buf|\n+        str::as_buf(output, { |buf|\n             llvm::LLVMWriteBitcodeToFile(llmod, buf)\n         });\n         llvm::LLVMDisposeModule(llmod);\n@@ -340,7 +340,7 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &istr,\n     fn crate_meta_extras_hash(sha: sha1, _crate: &ast::crate,\n                               metas: &provided_metas) -> istr {\n         fn len_and_str(s: &istr) -> istr {\n-            ret #ifmt[\"%u_%s\", istr::byte_len(s), s];\n+            ret #ifmt[\"%u_%s\", str::byte_len(s), s];\n         }\n \n         fn len_and_str_lit(l: &ast::lit) -> istr {\n@@ -383,12 +383,12 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &istr,\n               none. {\n                 let name =\n                     {\n-                        let os = istr::split(\n+                        let os = str::split(\n                             fs::basename(output),\n                             '.' as u8);\n                         assert (vec::len(os) >= 2u);\n                         vec::pop(os);\n-                        istr::connect(os, ~\".\")\n+                        str::connect(os, ~\".\")\n                     };\n                 warn_missing(sess, ~\"name\", name);\n                 name\n@@ -417,7 +417,7 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &istr,\n }\n \n fn truncated_sha1_result(sha: sha1) -> istr {\n-    ret istr::substr(sha.result_str(), 0u, 16u);\n+    ret str::substr(sha.result_str(), 0u, 16u);\n }\n \n \n@@ -458,7 +458,7 @@ fn mangle(ss: &[istr]) -> istr {\n     let n = ~\"_ZN\"; // Begin name-sequence.\n \n     for s: istr in ss {\n-        n += #ifmt[\"%u%s\", istr::byte_len(s), s];\n+        n += #ifmt[\"%u%s\", str::byte_len(s), s];\n     }\n     n += ~\"E\"; // End name-sequence.\n "}, {"sha": "13186bcbca4e0df366038d141d6a3acfcd2e1018", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,5 +1,5 @@\n \n-import std::istr;\n+import std::str;\n import middle::trans;\n import trans::decl_cdecl_fn;\n import middle::trans_common::T_f32;"}, {"sha": "02b33ff105cac06c894bff921ae0a5c7c83997e7", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,34 +1,34 @@\n \n import lib::llvm::llvm;\n import lib::llvm::llvm::ModuleRef;\n-import std::istr;\n+import std::str;\n import std::os::target_os;\n \n fn get_module_asm() -> istr { ret ~\"\"; }\n \n fn get_meta_sect_name() -> istr {\n-    if istr::eq(target_os(), ~\"macos\") { ret ~\"__DATA,__note.rustc\"; }\n-    if istr::eq(target_os(), ~\"win32\") { ret ~\".note.rustc\"; }\n+    if str::eq(target_os(), ~\"macos\") { ret ~\"__DATA,__note.rustc\"; }\n+    if str::eq(target_os(), ~\"win32\") { ret ~\".note.rustc\"; }\n     ret ~\".note.rustc\";\n }\n \n fn get_data_layout() -> istr {\n-    if istr::eq(target_os(), ~\"macos\") {\n+    if str::eq(target_os(), ~\"macos\") {\n         ret ~\"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\" +\n             ~\"-i32:32:32-i64:32:64\" +\n             ~\"-f32:32:32-f64:32:64-v64:64:64\" +\n             ~\"-v128:128:128-a0:0:64-f80:128:128\" +\n             ~\"-n8:16:32\";\n     }\n-    if istr::eq(target_os(), ~\"win32\") {\n+    if str::eq(target_os(), ~\"win32\") {\n         ret ~\"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\";\n     }\n     ret ~\"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\";\n }\n \n fn get_target_triple() -> istr {\n-    if istr::eq(target_os(), ~\"macos\") { ret ~\"i686-apple-darwin\"; }\n-    if istr::eq(target_os(), ~\"win32\") { ret ~\"i686-pc-mingw32\"; }\n+    if str::eq(target_os(), ~\"macos\") { ret ~\"i686-apple-darwin\"; }\n+    if str::eq(target_os(), ~\"win32\") { ret ~\"i686-pc-mingw32\"; }\n     ret ~\"i686-unknown-linux-gnu\";\n }\n //"}, {"sha": "3ae222369dce94516d55b4dc935d5af83331a877", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -26,7 +26,7 @@ import std::map::mk_hashmap;\n import std::option;\n import std::option::some;\n import std::option::none;\n-import std::istr;\n+import std::str;\n import std::vec;\n import std::int;\n import std::io;\n@@ -107,7 +107,7 @@ fn parse_input_src(sess: session::session, cfg: &ast::crate_cfg,\n         if infile != ~\"-\" {\n             io::file_reader(infile)\n         } else { io::stdin() }.read_whole_stream();\n-    let src = istr::unsafe_from_bytes(srcbytes);\n+    let src = str::unsafe_from_bytes(srcbytes);\n     let crate =\n         parser::parse_crate_from_source_str(\n             infile,\n@@ -260,7 +260,7 @@ fn version(argv0: &istr) {\n     // FIXME: Restore after istr conversion\n     //let env_vers = #env[\"CFG_VERSION\"];\n     let env_vers = ~\"FIXME\";\n-    if istr::byte_len(env_vers) != 0u { vers = env_vers; }\n+    if str::byte_len(env_vers) != 0u { vers = env_vers; }\n     io::stdout().write_str(\n         #ifmt[\"%s %s\\n\",\n                              argv0,\n@@ -307,40 +307,40 @@ options:\n }\n \n fn get_os(triple: &istr) -> session::os {\n-    ret if istr::find(triple, ~\"win32\") >= 0 ||\n-               istr::find(triple, ~\"mingw32\") >= 0 {\n+    ret if str::find(triple, ~\"win32\") >= 0 ||\n+               str::find(triple, ~\"mingw32\") >= 0 {\n             session::os_win32\n-        } else if istr::find(triple, ~\"darwin\") >= 0 {\n+        } else if str::find(triple, ~\"darwin\") >= 0 {\n             session::os_macos\n-        } else if istr::find(triple, ~\"linux\") >= 0 {\n+        } else if str::find(triple, ~\"linux\") >= 0 {\n             session::os_linux\n         } else { log_err ~\"Unknown operating system!\"; fail };\n }\n \n fn get_arch(triple: &istr) -> session::arch {\n-    ret if istr::find(triple, ~\"i386\") >= 0 ||\n-        istr::find(triple, ~\"i486\") >= 0 ||\n-               istr::find(triple, ~\"i586\") >= 0 ||\n-               istr::find(triple, ~\"i686\") >= 0 ||\n-               istr::find(triple, ~\"i786\") >= 0 {\n+    ret if str::find(triple, ~\"i386\") >= 0 ||\n+        str::find(triple, ~\"i486\") >= 0 ||\n+               str::find(triple, ~\"i586\") >= 0 ||\n+               str::find(triple, ~\"i686\") >= 0 ||\n+               str::find(triple, ~\"i786\") >= 0 {\n             session::arch_x86\n-        } else if istr::find(triple, ~\"x86_64\") >= 0 {\n+        } else if str::find(triple, ~\"x86_64\") >= 0 {\n             session::arch_x64\n-        } else if istr::find(triple, ~\"arm\") >= 0 ||\n-                      istr::find(triple, ~\"xscale\") >= 0 {\n+        } else if str::find(triple, ~\"arm\") >= 0 ||\n+                      str::find(triple, ~\"xscale\") >= 0 {\n             session::arch_arm\n         } else { log_err ~\"Unknown architecture! \" + triple; fail };\n }\n \n fn get_default_sysroot(binary: &istr) -> istr {\n     let dirname = fs::dirname(binary);\n-    if istr::eq(dirname, binary) { ret ~\".\"; }\n+    if str::eq(dirname, binary) { ret ~\".\"; }\n     ret dirname;\n }\n \n fn build_target_config() -> @session::config {\n     let triple: istr =\n-        istr::str_from_cstr(llvm::llvm::LLVMRustGetHostTriple());\n+        str::str_from_cstr(llvm::llvm::LLVMRustGetHostTriple());\n     let target_cfg: @session::config =\n         @{os: get_os(triple),\n           arch: get_arch(triple),\n@@ -442,13 +442,13 @@ fn build_session(sopts: @session::options) -> session::session {\n }\n \n fn parse_pretty(sess: session::session, name: &istr) -> pp_mode {\n-    if istr::eq(name, ~\"normal\") {\n+    if str::eq(name, ~\"normal\") {\n         ret ppm_normal;\n-    } else if istr::eq(name, ~\"expanded\") {\n+    } else if str::eq(name, ~\"expanded\") {\n         ret ppm_expanded;\n-    } else if istr::eq(name, ~\"typed\") {\n+    } else if str::eq(name, ~\"typed\") {\n         ret ppm_typed;\n-    } else if istr::eq(name, ~\"identified\") { ret ppm_identified; }\n+    } else if str::eq(name, ~\"identified\") { ret ppm_identified; }\n     sess.fatal(~\"argument to `pretty` must be one of `normal`, `typed`, or \"\n                + ~\"`identified`\");\n }\n@@ -533,10 +533,10 @@ fn main(args: [istr]) {\n         // We want to toss everything after the final '.'\n         let parts =\n             if !input_is_stdin(ifile) {\n-                istr::split(ifile, '.' as u8)\n+                str::split(ifile, '.' as u8)\n             } else { [~\"default\", ~\"rs\"] };\n         vec::pop(parts);\n-        saved_out_filename = istr::connect(parts, ~\".\");\n+        saved_out_filename = str::connect(parts, ~\".\");\n         let suffix =\n             alt sopts.output_type {\n               link::output_type_none. { ~\"none\" }\n@@ -591,15 +591,15 @@ fn main(args: [istr]) {\n             bind fn (config: @session::config, filename: &istr) -> istr {\n             if config.os == session::os_macos ||\n                 config.os == session::os_linux &&\n-                istr::find(filename, ~\"lib\") == 0 {\n-                ret istr::slice(filename, 3u,\n-                                istr::byte_len(filename));\n+                str::find(filename, ~\"lib\") == 0 {\n+                ret str::slice(filename, 3u,\n+                                str::byte_len(filename));\n             } else { ret filename; }\n         }(config, _);\n         fn rmext(filename: &istr) -> istr {\n-            let parts = istr::split(filename, '.' as u8);\n+            let parts = str::split(filename, '.' as u8);\n             vec::pop(parts);\n-            ret istr::connect(parts, ~\".\");\n+            ret str::connect(parts, ~\".\");\n         }\n         ret alt config.os {\n               session::os_macos. { rmext(rmlib(filename)) }\n@@ -610,7 +610,7 @@ fn main(args: [istr]) {\n \n     let cstore = sess.get_cstore();\n     for cratepath: istr in cstore::get_used_crate_files(cstore) {\n-        if istr::ends_with(cratepath, ~\".rlib\") {\n+        if str::ends_with(cratepath, ~\".rlib\") {\n             gcc_args += [cratepath];\n             cont;\n         }\n@@ -641,7 +641,7 @@ fn main(args: [istr]) {\n             #ifmt[\"linking with gcc failed with code %d\", err_code]);\n         sess.note(\n             #ifmt[\"gcc arguments: %s\",\n-                       istr::connect(gcc_args, ~\" \")]);\n+                       str::connect(gcc_args, ~\" \")]);\n         sess.abort_if_errors();\n     }\n     // Clean up on Darwin"}, {"sha": "7f40921088dc0bdaf92d83606e022f4cdfbf4ac0", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -9,7 +9,7 @@ import std::map;\n import std::option;\n import std::option::some;\n import std::option::none;\n-import std::istr;\n+import std::str;\n import syntax::parse::parser::parse_sess;\n \n tag os { os_win32; os_macos; os_linux; }"}, {"sha": "4ad38e2274e271cee3dc4e2f979878b8c77ba418", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,7 +1,7 @@\n // Functions dealing with attributes and meta_items\n \n import std::vec;\n-import std::istr;\n+import std::str;\n import std::map;\n import std::option;\n import syntax::ast;"}, {"sha": "f2eced8663460a5d763ec3ec491c8617816bcf9d", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -2,7 +2,7 @@\n \n import std::option;\n import std::vec;\n-import std::istr;\n+import std::str;\n import syntax::ast;\n import syntax::ast_util;\n import syntax::ast_util::*;"}, {"sha": "d59f689381513909703dbf49e5d758ee7c5aba37", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,6 +1,6 @@\n import std::vec;\n-import std::istr;\n-import std::istr::sbuf;\n+import std::str;\n+import std::str::sbuf;\n \n import llvm::ModuleRef;\n import llvm::ContextRef;\n@@ -1070,7 +1070,7 @@ resource target_data_res(TD: TargetDataRef) {\n type target_data = {lltd: TargetDataRef, dtor: @target_data_res};\n \n fn mk_target_data(string_rep: &istr) -> target_data {\n-    let lltd = istr::as_buf(string_rep, { |buf|\n+    let lltd = str::as_buf(string_rep, { |buf|\n         llvm::LLVMCreateTargetData(buf)\n     });\n     ret {lltd: lltd, dtor: @target_data_res(lltd)};"}, {"sha": "05c0de1bb2bb6d525a6cabd828d42a5861a725dc", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,6 +1,6 @@\n // EBML tag definitions and utils shared by the encoder and decoder\n \n-import std::istr;\n+import std::str;\n \n const tag_paths: uint = 0x01u;\n \n@@ -69,7 +69,7 @@ fn hash_node_id(node_id: &int) -> uint { ret 177573u ^ (node_id as uint); }\n \n fn hash_path(s: &istr) -> uint {\n     let h = 5381u;\n-    for ch: u8 in istr::bytes(s) { h = (h << 5u) + h ^ (ch as uint); }\n+    for ch: u8 in str::bytes(s) { h = (h << 5u) + h ^ (ch as uint); }\n     ret h;\n }\n "}, {"sha": "81978664a07fd8f54bc52e175a244abd5064d07f", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -14,7 +14,7 @@ import syntax::codemap::span;\n import back::x86;\n import util::common;\n import std::vec;\n-import std::istr;\n+import std::str;\n import std::fs;\n import std::io;\n import std::option;\n@@ -173,7 +173,7 @@ fn find_library_crate_aux(nn: &{prefix: istr, suffix: istr},\n         for path: istr in fs::list_dir(library_search_path) {\n             log #ifmt[\"searching %s\", path];\n             let f: istr = fs::basename(path);\n-            if !(istr::starts_with(f, prefix) && istr::ends_with(f, suffix))\n+            if !(str::starts_with(f, prefix) && str::ends_with(f, suffix))\n                {\n                 log #ifmt[\"skipping %s, doesn't look like %s*%s\",\n                          path,\n@@ -200,16 +200,16 @@ fn find_library_crate_aux(nn: &{prefix: istr, suffix: istr},\n }\n \n fn get_metadata_section(filename: &istr) -> option::t<@[u8]> {\n-    let mb = istr::as_buf(filename, { |buf|\n+    let mb = str::as_buf(filename, { |buf|\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n     });\n     if mb as int == 0 { ret option::none::<@[u8]>; }\n     let of = mk_object_file(mb);\n     let si = mk_section_iter(of.llof);\n     while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n         let name_buf = llvm::LLVMGetSectionName(si.llsi);\n-        let name = istr::str_from_cstr(name_buf);\n-        if istr::eq(name, x86::get_meta_sect_name()) {\n+        let name = str::str_from_cstr(name_buf);\n+        if str::eq(name, x86::get_meta_sect_name()) {\n             let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n             let csz = llvm::LLVMGetSectionSize(si.llsi);\n             let cvbuf: *u8 = std::unsafe::reinterpret_cast(cbuf);"}, {"sha": "c5f161394bd847b3f482af82b1b1cffe33e25eea", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -3,7 +3,7 @@\n \n import std::vec;\n import std::map;\n-import std::istr;\n+import std::str;\n import syntax::ast;\n \n export cstore;\n@@ -106,7 +106,7 @@ fn get_used_libraries(cstore: &cstore) -> [istr] {\n }\n \n fn add_used_link_args(cstore: &cstore, args: &istr) {\n-    p(cstore).used_link_args += istr::split(args, ' ' as u8);\n+    p(cstore).used_link_args += str::split(args, ' ' as u8);\n }\n \n fn get_used_link_args(cstore: &cstore) -> [istr] {"}, {"sha": "c3365f4f57c80b81886ee89469a568916af1522c", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -3,7 +3,7 @@\n import std::ebml;\n import std::vec;\n import std::option;\n-import std::istr;\n+import std::str;\n import std::io;\n import std::map::hashmap;\n import syntax::ast;\n@@ -85,7 +85,7 @@ fn item_family(item: &ebml::doc) -> u8 {\n \n fn item_symbol(item: &ebml::doc) -> istr {\n     let sym = ebml::get_doc(item, tag_items_data_item_symbol);\n-    ret istr::unsafe_from_bytes(ebml::doc_data(sym));\n+    ret str::unsafe_from_bytes(ebml::doc_data(sym));\n }\n \n fn variant_tag_id(d: &ebml::doc) -> ast::def_id {\n@@ -98,7 +98,7 @@ fn item_type(item: &ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n     fn parse_external_def_id(this_cnum: ast::crate_num,\n                              extres: &external_resolver, s: &istr) ->\n        ast::def_id {\n-        let buf = istr::bytes(s);\n+        let buf = str::bytes(s);\n         let external_def_id = parse_def_id(buf);\n \n \n@@ -150,9 +150,9 @@ fn tag_variant_ids(item: &ebml::doc, this_cnum: ast::crate_num) ->\n // definition the path refers to.\n fn resolve_path(path: &[ast::ident], data: @[u8]) -> [ast::def_id] {\n     fn eq_item(data: &[u8], s: &istr) -> bool {\n-        ret istr::eq(istr::unsafe_from_bytes(data), s);\n+        ret str::eq(str::unsafe_from_bytes(data), s);\n     }\n-    let s = istr::connect(path, ~\"::\");\n+    let s = str::connect(path, ~\"::\");\n     let md = ebml::new_doc(data);\n     let paths = ebml::get_doc(md, tag_paths);\n     let eqer = bind eq_item(_, s);\n@@ -272,7 +272,7 @@ fn read_path(d: &ebml::doc) -> {path: istr, pos: uint} {\n     let desc = ebml::doc_data(d);\n     let pos = ebml::be_uint_from_bytes(@desc, 0u, 4u);\n     let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n-    let path = istr::unsafe_from_bytes(pathbytes);\n+    let path = str::unsafe_from_bytes(pathbytes);\n     ret {path: path, pos: pos};\n }\n \n@@ -301,23 +301,23 @@ fn get_meta_items(md: &ebml::doc) -> [@ast::meta_item] {\n     for each meta_item_doc: ebml::doc in\n              ebml::tagged_docs(md, tag_meta_item_word) {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = istr::unsafe_from_bytes(ebml::doc_data(nd));\n+        let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n         items += [attr::mk_word_item(n)];\n     }\n     for each meta_item_doc: ebml::doc in\n              ebml::tagged_docs(md, tag_meta_item_name_value) {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = ebml::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = istr::unsafe_from_bytes(ebml::doc_data(nd));\n-        let v = istr::unsafe_from_bytes(ebml::doc_data(vd));\n+        let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n+        let v = str::unsafe_from_bytes(ebml::doc_data(vd));\n         // FIXME (#611): Should be able to decode meta_name_value variants,\n         // but currently they can't be encoded\n         items += [attr::mk_name_value_item_str(n, v)];\n     }\n     for each meta_item_doc: ebml::doc in\n              ebml::tagged_docs(md, tag_meta_item_list) {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = istr::unsafe_from_bytes(ebml::doc_data(nd));\n+        let n = str::unsafe_from_bytes(ebml::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n         items += [attr::mk_list_item(n, subitems)];\n     }\n@@ -377,7 +377,7 @@ fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n     let depsdoc = ebml::get_doc(cratedoc, tag_crate_deps);\n     let crate_num = 1;\n     for each depdoc: ebml::doc in ebml::tagged_docs(depsdoc, tag_crate_dep) {\n-        let depname = istr::unsafe_from_bytes(ebml::doc_data(depdoc));\n+        let depname = str::unsafe_from_bytes(ebml::doc_data(depdoc));\n         deps += [{cnum: crate_num, ident: depname}];\n         crate_num += 1;\n     }"}, {"sha": "384088c59e6e3057a7170d67ad678ea626466254", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,7 +1,7 @@\n // Metadata encoding\n \n import std::vec;\n-import std::istr;\n+import std::str;\n import std::uint;\n import std::io;\n import std::option;\n@@ -28,13 +28,13 @@ type encode_ctxt = {ccx: @crate_ctxt, type_abbrevs: abbrev_map};\n // Path table encoding\n fn encode_name(ebml_w: &ebml::writer, name: &istr) {\n     ebml::start_tag(ebml_w, tag_paths_data_name);\n-    ebml_w.writer.write(istr::bytes(name));\n+    ebml_w.writer.write(str::bytes(name));\n     ebml::end_tag(ebml_w);\n }\n \n fn encode_def_id(ebml_w: &ebml::writer, id: &def_id) {\n     ebml::start_tag(ebml_w, tag_def_id);\n-    ebml_w.writer.write(istr::bytes(def_to_str(id)));\n+    ebml_w.writer.write(str::bytes(def_to_str(id)));\n     ebml::end_tag(ebml_w);\n }\n \n@@ -55,7 +55,7 @@ fn add_to_index(ebml_w: &ebml::writer, path: &[istr],\n                 index: &mutable [entry<istr>], name: &istr) {\n     let full_path = path + [name];\n     index +=\n-        [{val: istr::connect(full_path, ~\"::\"), pos: ebml_w.writer.tell()}];\n+        [{val: str::connect(full_path, ~\"::\"), pos: ebml_w.writer.tell()}];\n }\n \n fn encode_native_module_item_paths(ebml_w: &ebml::writer, nmod: &native_mod,\n@@ -197,7 +197,7 @@ fn encode_type_param_kinds(ebml_w: &ebml::writer, tps: &[ty_param]) {\n \n fn encode_variant_id(ebml_w: &ebml::writer, vid: &def_id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_variant);\n-    ebml_w.writer.write(istr::bytes(def_to_str(vid)));\n+    ebml_w.writer.write(str::bytes(def_to_str(vid)));\n     ebml::end_tag(ebml_w);\n }\n \n@@ -214,20 +214,20 @@ fn encode_type(ecx: &@encode_ctxt, ebml_w: &ebml::writer, typ: ty::t) {\n \n fn encode_symbol(ecx: &@encode_ctxt, ebml_w: &ebml::writer, id: node_id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n-    ebml_w.writer.write(istr::bytes(ecx.ccx.item_symbols.get(id)));\n+    ebml_w.writer.write(str::bytes(ecx.ccx.item_symbols.get(id)));\n     ebml::end_tag(ebml_w);\n }\n \n fn encode_discriminant(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n                        id: node_id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n-    ebml_w.writer.write(istr::bytes(ecx.ccx.discrim_symbols.get(id)));\n+    ebml_w.writer.write(str::bytes(ecx.ccx.discrim_symbols.get(id)));\n     ebml::end_tag(ebml_w);\n }\n \n fn encode_tag_id(ebml_w: &ebml::writer, id: &def_id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_tag_id);\n-    ebml_w.writer.write(istr::bytes(def_to_str(id)));\n+    ebml_w.writer.write(str::bytes(def_to_str(id)));\n     ebml::end_tag(ebml_w);\n }\n \n@@ -454,7 +454,7 @@ fn encode_meta_item(ebml_w: &ebml::writer, mi: &meta_item) {\n       meta_word(name) {\n         ebml::start_tag(ebml_w, tag_meta_item_word);\n         ebml::start_tag(ebml_w, tag_meta_item_name);\n-        ebml_w.writer.write(istr::bytes(name));\n+        ebml_w.writer.write(str::bytes(name));\n         ebml::end_tag(ebml_w);\n         ebml::end_tag(ebml_w);\n       }\n@@ -463,10 +463,10 @@ fn encode_meta_item(ebml_w: &ebml::writer, mi: &meta_item) {\n           lit_str(value, _) {\n             ebml::start_tag(ebml_w, tag_meta_item_name_value);\n             ebml::start_tag(ebml_w, tag_meta_item_name);\n-            ebml_w.writer.write(istr::bytes(name));\n+            ebml_w.writer.write(str::bytes(name));\n             ebml::end_tag(ebml_w);\n             ebml::start_tag(ebml_w, tag_meta_item_value);\n-            ebml_w.writer.write(istr::bytes(value));\n+            ebml_w.writer.write(str::bytes(value));\n             ebml::end_tag(ebml_w);\n             ebml::end_tag(ebml_w);\n           }\n@@ -476,7 +476,7 @@ fn encode_meta_item(ebml_w: &ebml::writer, mi: &meta_item) {\n       meta_list(name, items) {\n         ebml::start_tag(ebml_w, tag_meta_item_list);\n         ebml::start_tag(ebml_w, tag_meta_item_name);\n-        ebml_w.writer.write(istr::bytes(name));\n+        ebml_w.writer.write(str::bytes(name));\n         ebml::end_tag(ebml_w);\n         for inner_item: @meta_item in items {\n             encode_meta_item(ebml_w, *inner_item);\n@@ -588,7 +588,7 @@ fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n     ebml::start_tag(ebml_w, tag_crate_deps);\n     for cname: istr in get_ordered_names(cstore) {\n         ebml::start_tag(ebml_w, tag_crate_dep);\n-        ebml_w.writer.write(istr::bytes(cname));\n+        ebml_w.writer.write(str::bytes(cname));\n         ebml::end_tag(ebml_w);\n     }\n     ebml::end_tag(ebml_w);"}, {"sha": "23ba2fa01a6960ab41f2433053dbea03beffbaf1", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,7 +1,7 @@\n // Type decoding\n \n import std::vec;\n-import std::istr;\n+import std::str;\n import std::uint;\n import std::option;\n import std::option::none;\n@@ -44,7 +44,7 @@ fn parse_ident_(st: @pstate, _sd: str_def, is_last: fn(char) -> bool) ->\n    ast::ident {\n     let rslt = ~\"\";\n     while !is_last(peek(st) as char) {\n-        rslt += istr::unsafe_from_byte(next(st));\n+        rslt += str::unsafe_from_byte(next(st));\n     }\n     ret rslt;\n }\n@@ -227,7 +227,7 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n         while peek(st) as char != ']' {\n             let name = ~\"\";\n             while peek(st) as char != '=' {\n-                name += istr::unsafe_from_byte(next(st));\n+                name += str::unsafe_from_byte(next(st));\n             }\n             st.pos = st.pos + 1u;\n             fields += [{ident: name, mt: parse_mt(st, sd)}];\n@@ -280,7 +280,7 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n             }\n             let name = ~\"\";\n             while peek(st) as char != '[' {\n-                name += istr::unsafe_from_byte(next(st));\n+                name += str::unsafe_from_byte(next(st));\n             }\n             let func = parse_ty_fn(st, sd);\n             methods +=\n@@ -345,7 +345,7 @@ fn parse_mt(st: @pstate, sd: str_def) -> ty::mt {\n fn parse_def(st: @pstate, sd: str_def) -> ast::def_id {\n     let def = ~\"\";\n     while peek(st) as char != '|' {\n-        def += istr::unsafe_from_byte(next(st));\n+        def += str::unsafe_from_byte(next(st));\n     }\n     st.pos = st.pos + 1u;\n     ret sd(def);"}, {"sha": "c76cd75a285248f9742ab9662d828912819b0a55", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,6 +1,6 @@\n // Type encoding\n \n-import std::istr;\n+import std::str;\n import std::io;\n import std::map::hashmap;\n import std::option::some;"}, {"sha": "aaa97399294412b1d34e7cb48b282000d95ba221", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -10,7 +10,7 @@ import syntax::codemap::span;\n import syntax::visit;\n import visit::vt;\n import std::vec;\n-import std::istr;\n+import std::str;\n import std::option;\n import std::option::some;\n import std::option::none;"}, {"sha": "706e814a01c17513bfe1fdc30b3a1bbf9f0a33e5", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -5,7 +5,7 @@ import std::map;\n import std::map::*;\n import std::option;\n import std::int;\n-import std::istr;\n+import std::str;\n import std::option::*;\n import syntax::ast;\n import syntax::ast_util;"}, {"sha": "d985805797027a913b016627c9060e06e8f1c08c", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -10,7 +10,7 @@ import middle::ty;\n import std::option::none;\n import std::option::some;\n import std::ptr;\n-import std::istr;\n+import std::str;\n import std::unsafe;\n import std::vec;\n \n@@ -22,7 +22,7 @@ type ctxt = @{mutable next_tydesc_num: uint};\n fn mk_ctxt() -> ctxt { ret @{mutable next_tydesc_num: 0u}; }\n \n fn add_global(ccx: &@crate_ctxt, llval: ValueRef, name: &istr) -> ValueRef {\n-    let llglobal = istr::as_buf(name, { |buf|\n+    let llglobal = str::as_buf(name, { |buf|\n         lll::LLVMAddGlobal(ccx.llmod, val_ty(llval), buf)\n     });\n     lll::LLVMSetInitializer(llglobal, llval);"}, {"sha": "71b211109621d3b24385b6dc2854e907a044d356", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -77,7 +77,7 @@ import syntax::visit;\n \n import std::vec;\n import std::option;\n-import std::istr;\n+import std::str;\n \n import ast::kind;\n import ast::kind_unique;"}, {"sha": "bf54a5d01d6fbbf53e4ab479de9851ae20ce26f1", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,4 +1,4 @@\n-import std::{vec, istr, option};\n+import std::{vec, str, option};\n import option::{some, none};\n import syntax::ast::*;\n import syntax::visit;\n@@ -54,7 +54,7 @@ fn expr_root(tcx: &ty::ctxt, ex: @expr, autoderef: bool)\n             alt ty::struct(tcx, auto_unbox.t) {\n               ty::ty_rec(fields) {\n                 for fld: ty::field in fields {\n-                    if istr::eq(ident, fld.ident) {\n+                    if str::eq(ident, fld.ident) {\n                         mut = fld.mt.mut != imm;\n                         break;\n                     }"}, {"sha": "117c10b0db7502c0aa6d0fda3493cb8475418451", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -32,7 +32,7 @@ import std::option;\n import std::option::is_none;\n import std::option::some;\n import std::option::none;\n-import std::istr;\n+import std::str;\n import syntax::print::pprust::*;\n \n export resolve_crate;\n@@ -79,7 +79,7 @@ type ext_hash = hashmap<{did: def_id, ident: istr, ns: namespace}, def>;\n fn new_ext_hash() -> ext_hash {\n     type key = {did: def_id, ident: istr, ns: namespace};\n     fn hash(v: &key) -> uint {\n-        ret istr::hash(v.ident) + util::common::hash_def(v.did) +\n+        ret str::hash(v.ident) + util::common::hash_def(v.did) +\n                 alt v.ns {\n                   ns_value. { 1u }\n                   ns_type. { 2u }\n@@ -88,7 +88,7 @@ fn new_ext_hash() -> ext_hash {\n     }\n     fn eq(v1: &key, v2: &key) -> bool {\n         ret util::common::def_eq(v1.did, v2.did) &&\n-                istr::eq(v1.ident, v2.ident) && v1.ns == v2.ns;\n+                str::eq(v1.ident, v2.ident) && v1.ns == v2.ns;\n     }\n     ret std::map::mk_hashmap::<key, def>(hash, eq);\n }\n@@ -430,7 +430,7 @@ fn follow_import(e: &env, sc: &scopes, path: &[ident], sp: &span) ->\n           ast::def_mod(_) | ast::def_native_mod(_) { ret dcur; }\n           _ {\n             e.sess.span_err(sp,\n-                            istr::connect(path, ~\"::\") +\n+                            str::connect(path, ~\"::\") +\n                                 ~\" does not name a module.\");\n             ret none;\n           }\n@@ -463,7 +463,7 @@ fn resolve_import(e: &env, defid: ast::def_id, name: &ast::ident,\n     let end_id = ids[n_idents - 1u];\n     // Ignore the current scope if this import would shadow itself.\n     let sc =\n-        if istr::eq(name, ids[0]) { std::list::cdr(sc_in) } else { sc_in };\n+        if str::eq(name, ids[0]) { std::list::cdr(sc_in) } else { sc_in };\n     if n_idents == 1u {\n         register(e, defid, sp, end_id, sc_in,\n                  lookup_in_scope(e, sc, sp, end_id, ns_value),\n@@ -560,7 +560,7 @@ fn unresolved_err(e: &env, sc: &scopes, sp: &span,\n     }\n     let err_scope = find_fn_or_mod_scope(sc);\n     for rs: {ident: istr, sc: scope} in e.reported {\n-        if istr::eq(rs.ident, name)\n+        if str::eq(rs.ident, name)\n             && err_scope == rs.sc { ret; }\n     }\n     e.reported += [{ident: name, sc: err_scope}];\n@@ -759,7 +759,7 @@ fn lookup_in_ty_params(name: &ident, ty_params: &[ast::ty_param]) ->\n    option::t<def> {\n     let i = 0u;\n     for tp: ast::ty_param in ty_params {\n-        if istr::eq(tp.ident, name) { ret some(ast::def_ty_arg(i, tp.kind)); }\n+        if str::eq(tp.ident, name) { ret some(ast::def_ty_arg(i, tp.kind)); }\n         i += 1u;\n     }\n     ret none::<def>;\n@@ -769,7 +769,7 @@ fn lookup_in_pat(name: &ident, pat: &@ast::pat) -> option::t<def_id> {\n     let found = none;\n     for each bound in ast_util::pat_bindings(pat) {\n         let p_name = alt bound.node { ast::pat_bind(n) { n } };\n-        if istr::eq(p_name, name) { found = some(local_def(bound.id)); }\n+        if str::eq(p_name, name) { found = some(local_def(bound.id)); }\n     }\n     ret found;\n }\n@@ -780,7 +780,7 @@ fn lookup_in_fn(name: &ident, decl: &ast::fn_decl,\n     alt ns {\n       ns_value. {\n         for a: ast::arg in decl.inputs {\n-            if istr::eq(a.ident, name) {\n+            if str::eq(a.ident, name) {\n                 ret some(ast::def_arg(local_def(a.id), a.mode));\n             }\n         }\n@@ -796,7 +796,7 @@ fn lookup_in_obj(name: &ident, ob: &ast::_obj, ty_params: &[ast::ty_param],\n     alt ns {\n       ns_value. {\n         for f: ast::obj_field in ob.fields {\n-            if istr::eq(f.ident, name) {\n+            if str::eq(f.ident, name) {\n                 ret some(ast::def_obj_field(local_def(f.id), f.mut));\n             }\n         }\n@@ -835,12 +835,12 @@ fn lookup_in_block(name: &ident, b: &ast::blk_, pos: uint, loc_pos: uint,\n                 alt it.node {\n                   ast::item_tag(variants, _) {\n                     if ns == ns_type {\n-                        if istr::eq(it.ident, name) {\n+                        if str::eq(it.ident, name) {\n                             ret some(ast::def_ty(local_def(it.id)));\n                         }\n                     } else if ns == ns_value {\n                         for v: ast::variant in variants {\n-                            if istr::eq(v.node.name, name) {\n+                            if str::eq(v.node.name, name) {\n                                 let i = v.node.id;\n                                 ret some(ast::def_variant(local_def(it.id),\n                                                           local_def(i)));\n@@ -849,7 +849,7 @@ fn lookup_in_block(name: &ident, b: &ast::blk_, pos: uint, loc_pos: uint,\n                     }\n                   }\n                   _ {\n-                    if istr::eq(it.ident, name) {\n+                    if str::eq(it.ident, name) {\n                         let found = found_def_item(it, ns);\n                         if !is_none(found) { ret found; }\n                     }\n@@ -1332,7 +1332,7 @@ fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt<()>) {\n                             ~\"inconsistent number of bindings\");\n         } else {\n             for name: ident in ch.seen {\n-                if is_none(vec::find(bind istr::eq(name, _), seen0)) {\n+                if is_none(vec::find(bind str::eq(name, _), seen0)) {\n                     // Fight the alias checker\n                     let name_ = name;\n                     e.sess.span_err(a.pats[i].span,\n@@ -1428,7 +1428,7 @@ fn checker(e: &env, kind: &istr) -> checker {\n \n fn check_name(ch: &checker, sp: &span, name: &ident) {\n     for s: ident in ch.seen {\n-        if istr::eq(s, name) {\n+        if str::eq(s, name) {\n             ch.sess.span_fatal(sp, ~\"duplicate \" + ch.kind\n                                + ~\" name: \" + name);\n         }"}, {"sha": "181eaa0251a9bb6dd1c4e20a5a242cf5f0cf2366", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -30,7 +30,7 @@ import std::vec;\n import std::map::hashmap;\n import std::option::none;\n import std::option::some;\n-import std::istr;\n+import std::str;\n \n import ty_ctxt = middle::ty::ctxt;\n \n@@ -86,7 +86,7 @@ fn eq_res_info(a: &res_info, b: &res_info) -> bool {\n \n fn mk_global(ccx: &@crate_ctxt, name: &istr, llval: ValueRef,\n              internal: bool) -> ValueRef {\n-    let llglobal = istr::as_buf(name, { |buf|\n+    let llglobal = str::as_buf(name, { |buf|\n         lib::llvm::llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval), buf)\n     });\n     lib::llvm::llvm::LLVMSetInitializer(llglobal, llval);\n@@ -248,7 +248,7 @@ fn s_float(_tcx: &ty_ctxt) -> u8 {\n \n fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n     let llshapetablesty = trans_common::T_named_struct(~\"shapes\");\n-    let llshapetables = istr::as_buf(~\"shapes\", { |buf|\n+    let llshapetables = str::as_buf(~\"shapes\", { |buf|\n         lib::llvm::llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n     });\n "}, {"sha": "8aafae528206c23b8dc9cb0afde12c8d5c77038e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -13,7 +13,7 @@\n //     but many TypeRefs correspond to one ty::t; for instance, tup(int, int,\n //     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n import std::int;\n-import std::istr;\n+import std::str;\n import std::uint;\n import std::map;\n import std::map::hashmap;\n@@ -301,7 +301,7 @@ fn sanitize(s: &istr) -> istr {\n                            c != ' ' as u8 && c != '\\t' as u8 && c != ';' as u8\n                        {\n                         let v = [c];\n-                        result += istr::unsafe_from_bytes(v);\n+                        result += str::unsafe_from_bytes(v);\n                     }\n                 }\n             }\n@@ -322,7 +322,7 @@ fn log_fn_time(ccx: &@crate_ctxt, name: &istr, start: &time::timeval,\n \n fn decl_fn(llmod: ModuleRef, name: &istr, cc: uint, llty: TypeRef) ->\n    ValueRef {\n-    let llfn: ValueRef = istr::as_buf(name, { |buf|\n+    let llfn: ValueRef = str::as_buf(name, { |buf|\n         llvm::LLVMAddFunction(llmod, buf, llty)\n     });\n     llvm::LLVMSetFunctionCallConv(llfn, cc);\n@@ -336,7 +336,7 @@ fn decl_cdecl_fn(llmod: ModuleRef, name: &istr, llty: TypeRef) -> ValueRef {\n fn decl_fastcall_fn(llmod: ModuleRef, name: &istr,\n                     llty: TypeRef) -> ValueRef {\n     let llfn = decl_fn(llmod, name, lib::llvm::LLVMFastCallConv, llty);\n-    let _: () = istr::as_buf(~\"rust\", { |buf|\n+    let _: () = str::as_buf(~\"rust\", { |buf|\n         llvm::LLVMSetGC(llfn, buf)\n     });\n     ret llfn;\n@@ -350,7 +350,7 @@ fn decl_internal_fastcall_fn(llmod: ModuleRef, name: &istr, llty: TypeRef) ->\n     let llfn = decl_fn(llmod, name, lib::llvm::LLVMFastCallConv, llty);\n     llvm::LLVMSetLinkage(llfn,\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-    let _: () = istr::as_buf(~\"rust\", { |buf|\n+    let _: () = str::as_buf(~\"rust\", { |buf|\n         llvm::LLVMSetGC(llfn, buf)\n     });\n     ret llfn;\n@@ -375,7 +375,7 @@ fn get_extern_const(externs: &hashmap<istr, ValueRef>, llmod: ModuleRef,\n     if externs.contains_key(name) {\n         ret externs.get(name);\n     }\n-    let c = istr::as_buf(name, { |buf|\n+    let c = str::as_buf(name, { |buf|\n         llvm::LLVMAddGlobal(llmod, ty, buf)\n     });\n     externs.insert(name, c);\n@@ -1137,7 +1137,7 @@ fn declare_tydesc(cx: &@local_ctxt, sp: &span, t: ty::t, ty_params: &[uint])\n         name = mangle_internal_name_by_type_only(cx.ccx, t, ~\"tydesc\");\n         name = sanitize(name);\n     } else { name = mangle_internal_name_by_seq(cx.ccx, ~\"tydesc\"); }\n-    let gvar = istr::as_buf(name, { |buf|\n+    let gvar = str::as_buf(name, { |buf|\n         llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n     });\n     let info =\n@@ -1501,7 +1501,7 @@ fn decr_refcnt_maybe_free(cx: &@block_ctxt, box_ptr_alias: ValueRef,\n // Structural comparison: a rather involved form of glue.\n fn maybe_name_value(cx: &@crate_ctxt, v: ValueRef, s: &istr) {\n     if cx.sess.get_opts().save_temps {\n-        let _: () = istr::as_buf(s, { |buf|\n+        let _: () = str::as_buf(s, { |buf|\n             llvm::LLVMSetValueName(v, buf)\n         });\n     }\n@@ -3050,7 +3050,7 @@ fn lookup_discriminant(lcx: &@local_ctxt, vid: &ast::def_id) -> ValueRef {\n         // It's an external discriminant that we haven't seen yet.\n         assert (vid.crate != ast::local_crate);\n         let sym = csearch::get_symbol(lcx.ccx.sess.get_cstore(), vid);\n-        let gvar = istr::as_buf(sym, { |buf|\n+        let gvar = str::as_buf(sym, { |buf|\n             llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), buf)\n         });\n         llvm::LLVMSetLinkage(gvar,\n@@ -3998,7 +3998,7 @@ fn trans_rec(cx: &@block_ctxt, fields: &[ast::field],\n         bcx = dst_res.bcx;\n         let expr_provided = false;\n         for f: ast::field in fields {\n-            if istr::eq(f.node.ident, tf.ident) {\n+            if str::eq(f.node.ident, tf.ident) {\n                 expr_provided = true;\n                 let lv = trans_lval(bcx, f.node.expr);\n                 bcx = move_val_if_temp(lv.res.bcx, INIT, dst_res.val,\n@@ -4288,7 +4288,7 @@ fn load_if_immediate(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> ValueRef {\n \n fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n     let lcx = cx.fcx.lcx;\n-    let modname = istr::connect(lcx.module_path, ~\"::\");\n+    let modname = str::connect(lcx.module_path, ~\"::\");\n     let global;\n     if lcx.ccx.module_data.contains_key(modname) {\n         global = lcx.ccx.module_data.get(modname);\n@@ -4298,7 +4298,7 @@ fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n                 lcx.ccx,\n                 lcx.module_path,\n                 ~\"loglevel\");\n-        global = istr::as_buf(s, { |buf|\n+        global = str::as_buf(s, { |buf|\n             llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), buf)\n         });\n         llvm::LLVMSetGlobalConstant(global, False);\n@@ -4677,7 +4677,7 @@ fn new_block_ctxt(cx: &@fn_ctxt, parent: &block_parent, kind: block_kind,\n            cx.lcx.ccx.sess.get_opts().debuginfo {\n         s = cx.lcx.ccx.names.next(name);\n     }\n-    let llbb: BasicBlockRef = istr::as_buf(s, { |buf|\n+    let llbb: BasicBlockRef = str::as_buf(s, { |buf|\n         llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n     });\n     ret @{llbb: llbb,\n@@ -4836,7 +4836,7 @@ fn alloc_local(cx: &@block_ctxt, local: &@ast::local) -> result {\n     alt local.node.pat.node {\n       ast::pat_bind(ident) {\n         if bcx_ccx(cx).sess.get_opts().debuginfo {\n-            let _: () = istr::as_buf(ident, { |buf|\n+            let _: () = str::as_buf(ident, { |buf|\n                 llvm::LLVMSetValueName(r.val, buf)\n             });\n         }\n@@ -4922,19 +4922,19 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n     dt: BasicBlockRef,\n     da: BasicBlockRef,\n     rt: BasicBlockRef} {\n-    ret {sa: istr::as_buf(~\"statuc_allocas\", { |buf|\n+    ret {sa: str::as_buf(~\"statuc_allocas\", { |buf|\n              llvm::LLVMAppendBasicBlock(llfn, buf)\n                                              }),\n-         ca: istr::as_buf(~\"copy_args\", { |buf|\n+         ca: str::as_buf(~\"copy_args\", { |buf|\n              llvm::LLVMAppendBasicBlock(llfn, buf)\n                                         }),\n-         dt: istr::as_buf(~\"derived_tydescs\", { |buf|\n+         dt: str::as_buf(~\"derived_tydescs\", { |buf|\n              llvm::LLVMAppendBasicBlock(llfn, buf)\n                                               }),\n-         da: istr::as_buf(~\"dynamic_allocas\", { |buf|\n+         da: str::as_buf(~\"dynamic_allocas\", { |buf|\n              llvm::LLVMAppendBasicBlock(llfn, buf)\n                                               }),\n-         rt: istr::as_buf(~\"return\", { |buf|\n+         rt: str::as_buf(~\"return\", { |buf|\n              llvm::LLVMAppendBasicBlock(llfn, buf)\n                                      })};\n }\n@@ -5254,7 +5254,7 @@ fn trans_fn(cx: @local_ctxt, sp: &span, f: &ast::_fn, llfndecl: ValueRef,\n     let start = time::get_time();\n     trans_fn_inner(cx, sp, f, llfndecl, ty_self, ty_params, id);\n     let end = time::get_time();\n-    log_fn_time(cx.ccx, istr::connect(cx.path, ~\"::\"),\n+    log_fn_time(cx.ccx, str::connect(cx.path, ~\"::\"),\n                 start, end);\n }\n \n@@ -5546,7 +5546,7 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span, main_llfn: ValueRef,\n \n     // FIXME: This is a transitional way to let the runtime know\n     // it needs to feed us istrs\n-    let lltakesistr = istr::as_buf(~\"_rust_main_takes_istr\", { |buf|\n+    let lltakesistr = str::as_buf(~\"_rust_main_takes_istr\", { |buf|\n         llvm::LLVMAddGlobal(ccx.llmod, T_int(), buf)\n     });\n     llvm::LLVMSetInitializer(lltakesistr, C_uint(main_takes_istr as uint));\n@@ -5597,7 +5597,7 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span, main_llfn: ValueRef,\n // space for the function's environment.\n fn create_fn_pair(cx: &@crate_ctxt, ps: &istr, llfnty: TypeRef,\n                   llfn: ValueRef, external: bool) -> ValueRef {\n-    let gvar = istr::as_buf(ps, { |buf|\n+    let gvar = str::as_buf(ps, { |buf|\n         llvm::LLVMAddGlobal(cx.llmod, T_fn_pair(*cx, llfnty), buf)\n     });\n     let pair = C_struct([llfn, C_null(T_opaque_closure_ptr(*cx))]);\n@@ -5874,7 +5874,7 @@ fn collect_item_1(ccx: @crate_ctxt, i: &@ast::item, pt: &[istr],\n         let s =\n             mangle_exported_name(ccx, pt + [i.ident],\n                                  node_id_type(ccx, i.id));\n-        let g = istr::as_buf(s, { |buf|\n+        let g = str::as_buf(s, { |buf|\n             llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, i.span, typ), buf)\n         });\n         ccx.item_symbols.insert(i.id, s);\n@@ -5966,7 +5966,7 @@ fn trans_constant(ccx: @crate_ctxt, it: &@ast::item, pt: &[istr],\n                               ~\"discrim\"];\n             let s = mangle_exported_name(ccx, p,\n                                          ty::mk_int(ccx.tcx));\n-            let discrim_gvar = istr::as_buf(s, { |buf|\n+            let discrim_gvar = str::as_buf(s, { |buf|\n                 llvm::LLVMAddGlobal(ccx.llmod, T_int(), buf)\n             });\n             if n_variants != 1u {\n@@ -6074,19 +6074,19 @@ fn make_common_glue(sess: &session::session, output: &istr) {\n     let task_type = T_task();\n     let taskptr_type = T_ptr(task_type);\n \n-    let llmod = istr::as_buf(~\"rust_out\", { |buf|\n+    let llmod = str::as_buf(~\"rust_out\", { |buf|\n         llvm::LLVMModuleCreateWithNameInContext(buf,\n                                                 llvm::LLVMGetGlobalContext())\n     });\n-    let _: () = istr::as_buf(x86::get_data_layout(), { |buf|\n+    let _: () = str::as_buf(x86::get_data_layout(), { |buf|\n         llvm::LLVMSetDataLayout(llmod, buf)\n     });\n-    let _: () = istr::as_buf(x86::get_target_triple(), { |buf|\n+    let _: () = str::as_buf(x86::get_target_triple(), { |buf|\n         llvm::LLVMSetTarget(llmod, buf)\n     });\n     mk_target_data(x86::get_data_layout());\n     declare_intrinsics(llmod);\n-    let _: () = istr::as_buf(x86::get_module_asm(), { |buf|\n+    let _: () = str::as_buf(x86::get_module_asm(), { |buf|\n         llvm::LLVMSetModuleInlineAsm(llmod, buf)\n     });\n     make_glues(llmod, taskptr_type);\n@@ -6096,7 +6096,7 @@ fn make_common_glue(sess: &session::session, output: &istr) {\n fn create_module_map(ccx: &@crate_ctxt) -> ValueRef {\n     let elttype = T_struct([T_int(), T_int()]);\n     let maptype = T_array(elttype, ccx.module_data.size() + 1u);\n-    let map = istr::as_buf(~\"_rust_mod_map\", { |buf|\n+    let map = str::as_buf(~\"_rust_mod_map\", { |buf|\n         llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n     });\n     llvm::LLVMSetLinkage(map,\n@@ -6122,7 +6122,7 @@ fn create_crate_map(ccx: &@crate_ctxt) -> ValueRef {\n     while cstore::have_crate_data(cstore, i) {\n         let nm = ~\"_rust_crate_map_\" +\n             cstore::get_crate_data(cstore, i).name;\n-        let cr = istr::as_buf(nm, { |buf|\n+        let cr = str::as_buf(nm, { |buf|\n             llvm::LLVMAddGlobal(ccx.llmod, T_int(), buf)\n         });\n         subcrates += [p2i(cr)];\n@@ -6136,7 +6136,7 @@ fn create_crate_map(ccx: &@crate_ctxt) -> ValueRef {\n     let sym_name = ~\"_rust_crate_map_\" + mapname;\n     let arrtype = T_array(T_int(), std::vec::len::<ValueRef>(subcrates));\n     let maptype = T_struct([T_int(), arrtype]);\n-    let map = istr::as_buf(sym_name, { |buf|\n+    let map = str::as_buf(sym_name, { |buf|\n         llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n     });\n     llvm::LLVMSetLinkage(map,\n@@ -6152,19 +6152,19 @@ fn write_metadata(cx: &@crate_ctxt, crate: &@ast::crate) {\n     let llmeta = C_postr(\n         metadata::encoder::encode_metadata(cx, crate));\n     let llconst = trans_common::C_struct([llmeta]);\n-    let llglobal = istr::as_buf(~\"rust_metadata\", { |buf|\n+    let llglobal = str::as_buf(~\"rust_metadata\", { |buf|\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)\n     });\n     llvm::LLVMSetInitializer(llglobal, llconst);\n-    let _: () = istr::as_buf(x86::get_meta_sect_name(), { |buf|\n+    let _: () = str::as_buf(x86::get_meta_sect_name(), { |buf|\n         llvm::LLVMSetSection(llglobal, buf)\n     });\n     llvm::LLVMSetLinkage(llglobal,\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n \n     let t_ptr_i8 = T_ptr(T_i8());\n     llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8);\n-    let llvm_used = istr::as_buf(~\"llvm.used\", { |buf|\n+    let llvm_used = str::as_buf(~\"llvm.used\", { |buf|\n         llvm::LLVMAddGlobal(cx.llmod, T_array(t_ptr_i8, 1u), buf)\n     });\n     llvm::LLVMSetLinkage(llvm_used,\n@@ -6181,14 +6181,14 @@ fn write_abi_version(ccx: &@crate_ctxt) {\n fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n                output: &istr, amap: &ast_map::map, mut_map: mut::mut_map)\n     -> ModuleRef {\n-    let llmod = istr::as_buf(~\"rust_out\", { |buf|\n+    let llmod = str::as_buf(~\"rust_out\", { |buf|\n         llvm::LLVMModuleCreateWithNameInContext(buf,\n                                                 llvm::LLVMGetGlobalContext())\n     });\n-    let _: () = istr::as_buf(x86::get_data_layout(), { |buf|\n+    let _: () = str::as_buf(x86::get_data_layout(), { |buf|\n         llvm::LLVMSetDataLayout(llmod, buf)\n     });\n-    let _: () = istr::as_buf(x86::get_target_triple(), { |buf|\n+    let _: () = str::as_buf(x86::get_target_triple(), { |buf|\n         llvm::LLVMSetTarget(llmod, buf)\n     });\n     let td = mk_target_data(x86::get_data_layout());"}, {"sha": "a4cdb44f5741706a5a240d7b51f2063eb96c432f", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,4 +1,4 @@\n-import std::istr;\n+import std::str;\n import std::vec;\n import std::option;\n import option::some;\n@@ -59,7 +59,7 @@ fn variant_opt(ccx: &@crate_ctxt, pat_id: ast::node_id) -> opt {\n type bind_map = [{ident: ast::ident, val: ValueRef}];\n fn assoc(key: &istr, list: &bind_map) -> option::t<ValueRef> {\n     for elt: {ident: ast::ident, val: ValueRef} in list {\n-        if istr::eq(elt.ident, key) { ret some(elt.val); }\n+        if str::eq(elt.ident, key) { ret some(elt.val); }\n     }\n     ret none;\n }\n@@ -145,7 +145,7 @@ fn enter_rec(m: &match, col: uint, fields: &[ast::ident], val: ValueRef) ->\n             for fname: ast::ident in fields {\n                 let pat = dummy;\n                 for fpat: ast::field_pat in fpats {\n-                    if istr::eq(fpat.ident, fname) { pat = fpat.pat; break; }\n+                    if str::eq(fpat.ident, fname) { pat = fpat.pat; break; }\n                 }\n                 pats += [pat];\n             }\n@@ -233,7 +233,7 @@ fn collect_record_fields(m: &match, col: uint) -> [ast::ident] {\n         alt br.pats[col].node {\n           ast::pat_rec(fs, _) {\n             for f: ast::field_pat in fs {\n-                if !vec::any(bind istr::eq(f.ident, _), fields) {\n+                if !vec::any(bind str::eq(f.ident, _), fields) {\n                     fields += [f.ident];\n                 }\n             }"}, {"sha": "1355bbff0aadbd4ac113ea436cdc4bc1b362b43d", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 81, "deletions": 81, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,5 +1,5 @@\n-import std::{vec, istr};\n-import std::istr::sbuf;\n+import std::{vec, str};\n+import std::str::sbuf;\n import lib::llvm::llvm;\n import llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef,\n               Opcode, ModuleRef};\n@@ -61,7 +61,7 @@ fn Invoke(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef],\n           Then: BasicBlockRef, Catch: BasicBlockRef) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n                               vec::len(Args), Then, Catch, buf)\n     });\n@@ -75,212 +75,212 @@ fn Unreachable(cx: &@block_ctxt) -> ValueRef {\n \n /* Arithmetic */\n fn Add(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildAdd(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn NSWAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn NUWAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn FAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildFAdd(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn Sub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildSub(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn NSWSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn NUWSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn FSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildFSub(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn Mul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildMul(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn NSWMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn NUWMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn FMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildFMul(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn UDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildUDiv(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn SDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildSDiv(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn ExactSDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn FDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildFDiv(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn URem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildURem(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn SRem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildSRem(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn FRem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildFRem(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn Shl(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildShl(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn LShr(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildLShr(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn AShr(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildAShr(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn And(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildAnd(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn Or(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildOr(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn Xor(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildXor(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn BinOp(cx: &@block_ctxt, Op: Opcode, LHS: ValueRef,\n          RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, buf)\n     });\n }\n \n fn Neg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildNeg(B(cx), V, buf)\n     });\n }\n \n fn NSWNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildNSWNeg(B(cx), V, buf)\n     });\n }\n \n fn NUWNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildNUWNeg(B(cx), V, buf)\n     });\n }\n fn FNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildFNeg(B(cx), V, buf)\n     });\n }\n \n fn Not(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildNot(B(cx), V, buf)\n     });\n }\n \n /* Memory */\n fn Malloc(cx: &@block_ctxt, Ty: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildMalloc(B(cx), Ty, buf)\n     });\n }\n \n fn ArrayMalloc(cx: &@block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, buf)\n     });\n }\n \n fn Alloca(cx: &@block_ctxt, Ty: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildAlloca(B(cx), Ty, buf)\n     });\n }\n \n fn ArrayAlloca(cx: &@block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, buf)\n     });\n }\n@@ -290,7 +290,7 @@ fn Free(cx: &@block_ctxt, PointerVal: ValueRef) -> ValueRef {\n }\n \n fn Load(cx: &@block_ctxt, PointerVal: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildLoad(B(cx), PointerVal, buf)\n     });\n }\n@@ -301,156 +301,156 @@ fn Store(cx: &@block_ctxt, Val: ValueRef, Ptr: ValueRef) -> ValueRef {\n \n fn GEP(cx: &@block_ctxt, Pointer: ValueRef,\n        Indices: &[ValueRef]) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildGEP(B(cx), Pointer, vec::to_ptr(Indices),\n                            vec::len(Indices), buf)\n     });\n }\n \n fn InBoundsGEP(cx: &@block_ctxt, Pointer: ValueRef,\n                Indices: &[ValueRef]) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildInBoundsGEP(B(cx), Pointer, vec::to_ptr(Indices),\n                                    vec::len(Indices), buf)\n     });\n }\n \n fn StructGEP(cx: &@block_ctxt, Pointer: ValueRef, Idx: uint) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx, buf)\n     });\n }\n \n fn GlobalString(cx: &@block_ctxt, _Str: sbuf) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildGlobalString(B(cx), _Str, buf)\n     });\n }\n \n fn GlobalStringPtr(cx: &@block_ctxt, _Str: sbuf) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, buf)\n     });\n }\n \n /* Casts */\n fn Trunc(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildTrunc(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn ZExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildZExt(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn SExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildSExt(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn FPToUI(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn FPToSI(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn UIToFP(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn SIToFP(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn FPTrunc(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn FPExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildFPExt(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn PtrToInt(cx: &@block_ctxt, Val: ValueRef,\n             DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn IntToPtr(cx: &@block_ctxt, Val: ValueRef,\n             DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn BitCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildBitCast(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn ZExtOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n                  DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn SExtOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n                  DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn TruncOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n                   DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn Cast(cx: &@block_ctxt, Op: Opcode, Val: ValueRef,\n         DestTy: TypeRef, _Name: sbuf) ->\n     ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, buf)\n     });\n }\n \n fn PointerCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn IntCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildIntCast(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn FPCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildFPCast(B(cx), Val, DestTy, buf)\n     });\n }\n@@ -459,14 +459,14 @@ fn FPCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n /* Comparisons */\n fn ICmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef,\n         RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildICmp(B(cx), Op, LHS, RHS, buf)\n     });\n }\n \n fn FCmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef,\n         RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildFCmp(B(cx), Op, LHS, RHS, buf)\n     });\n }\n@@ -475,7 +475,7 @@ fn FCmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef,\n /* Miscellaneous instructions */\n fn Phi(cx: &@block_ctxt, Ty: TypeRef, vals: &[ValueRef],\n        bbs: &[BasicBlockRef]) -> ValueRef {\n-    let phi = istr::as_buf(~\"\", { |buf|\n+    let phi = str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildPhi(B(cx), Ty, buf)\n     });\n     assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n@@ -491,14 +491,14 @@ fn AddIncomingToPhi(phi: ValueRef, vals: &[ValueRef], bbs: &[BasicBlockRef]) {\n }\n \n fn Call(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n                             vec::len(Args), buf)\n     });\n }\n \n fn FastCall(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n-    let v = istr::as_buf(~\"\", { |buf|\n+    let v = str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args), vec::len(Args), buf)\n     });\n     llvm::LLVMSetInstructionCallConv(v, lib::llvm::LLVMFastCallConv);\n@@ -507,7 +507,7 @@ fn FastCall(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n \n fn CallWithConv(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef],\n                 Conv: uint) -> ValueRef {\n-    let v = istr::as_buf(~\"\", { |buf|\n+    let v = str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args), vec::len(Args), buf)\n     });\n     llvm::LLVMSetInstructionCallConv(v, Conv);\n@@ -516,66 +516,66 @@ fn CallWithConv(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef],\n \n fn Select(cx: &@block_ctxt, If: ValueRef, Then: ValueRef,\n           Else: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildSelect(B(cx), If, Then, Else, buf)\n     });\n }\n \n fn VAArg(cx: &@block_ctxt, list: ValueRef, Ty: TypeRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildVAArg(B(cx), list, Ty, buf)\n     });\n }\n \n fn ExtractElement(cx: &@block_ctxt, VecVal: ValueRef,\n                   Index: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, buf)\n     });\n }\n \n fn InsertElement(cx: &@block_ctxt, VecVal: ValueRef, EltVal: ValueRef,\n                  Index: ValueRef) ->\n     ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, buf)\n     });\n }\n \n fn ShuffleVector(cx: &@block_ctxt, V1: ValueRef, V2: ValueRef,\n                  Mask: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, buf)\n     });\n }\n \n fn ExtractValue(cx: &@block_ctxt, AggVal: ValueRef, Index: uint) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildExtractValue(B(cx), AggVal, Index, buf)\n     });\n }\n \n fn InsertValue(cx: &@block_ctxt, AggVal: ValueRef,\n                EltVal: ValueRef, Index: uint) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index, buf)\n     });\n }\n \n fn IsNull(cx: &@block_ctxt, Val: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildIsNull(B(cx), Val, buf)\n     });\n }\n \n fn IsNotNull(cx: &@block_ctxt, Val: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildIsNotNull(B(cx), Val, buf)\n     });\n }\n \n fn PtrDiff(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, buf)\n     });\n }\n@@ -585,12 +585,12 @@ fn Trap(cx: &@block_ctxt) -> ValueRef {\n     let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(b);\n     let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n     let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-    let T: ValueRef = istr::as_buf(~\"llvm.trap\", { |buf|\n+    let T: ValueRef = str::as_buf(~\"llvm.trap\", { |buf|\n         llvm::LLVMGetNamedFunction(M, buf)\n     });\n     assert (T as int != 0);\n     let Args: [ValueRef] = [];\n-    ret istr::as_buf(~\"\", { |buf|\n+    ret str::as_buf(~\"\", { |buf|\n         llvm::LLVMBuildCall(b, T, vec::to_ptr(Args), vec::len(Args), buf)\n     });\n }"}, {"sha": "5a7bb4faf0720de2da406ea7bddadfb2bca1db63", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -6,7 +6,7 @@\n import std::int;\n import std::vec;\n import std::vec::to_ptr;\n-import std::istr;\n+import std::str;\n import std::uint;\n import std::map;\n import std::map::hashmap;\n@@ -547,7 +547,7 @@ fn T_struct(elts: &[TypeRef]) -> TypeRef {\n \n fn T_named_struct(name: &istr) -> TypeRef {\n     let c = llvm::LLVMGetGlobalContext();\n-    ret istr::as_buf(name, { |buf|\n+    ret str::as_buf(name, { |buf|\n         llvm::LLVMStructCreateNamed(c, buf)\n     });\n }\n@@ -767,13 +767,13 @@ fn C_integral(t: TypeRef, u: uint, sign_extend: Bool) -> ValueRef {\n }\n \n fn C_float(s: &istr) -> ValueRef {\n-    ret istr::as_buf(s, { |buf|\n+    ret str::as_buf(s, { |buf|\n         llvm::LLVMConstRealOfString(T_float(), buf)\n     });\n }\n \n fn C_floating(s: &istr, t: TypeRef) -> ValueRef {\n-    ret istr::as_buf(s, { |buf|\n+    ret str::as_buf(s, { |buf|\n         llvm::LLVMConstRealOfString(t, buf)\n     });\n }\n@@ -800,10 +800,10 @@ fn C_u8(i: uint) -> ValueRef { ret C_integral(T_i8(), i, False); }\n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n fn C_cstr(cx: &@crate_ctxt, s: &istr) -> ValueRef {\n-    let sc = istr::as_buf(s, { |buf|\n-        llvm::LLVMConstString(buf, istr::byte_len(s), False)\n+    let sc = str::as_buf(s, { |buf|\n+        llvm::LLVMConstString(buf, str::byte_len(s), False)\n     });\n-    let g = istr::as_buf(cx.names.next(~\"str\"), { |buf|\n+    let g = str::as_buf(cx.names.next(~\"str\"), { |buf|\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf)\n     });\n     llvm::LLVMSetInitializer(g, sc);\n@@ -816,17 +816,17 @@ fn C_cstr(cx: &@crate_ctxt, s: &istr) -> ValueRef {\n // A rust boxed-and-length-annotated string.\n fn C_str(cx: &@crate_ctxt, s: &istr) -> ValueRef {\n     let len =\n-        istr::byte_len(s); // 'alloc'\n+        str::byte_len(s); // 'alloc'\n                           // 'fill'\n                           // 'pad'\n \n-    let cstr = istr::as_buf(s, { |buf|\n+    let cstr = str::as_buf(s, { |buf|\n         llvm::LLVMConstString(buf, len, False)\n     });\n     let box =\n         C_struct([C_int(abi::const_refcount as int), C_int(len + 1u as int),\n                   C_int(len + 1u as int), C_int(0), cstr]);\n-    let g = istr::as_buf(cx.names.next(~\"str\"), { |buf|\n+    let g = str::as_buf(cx.names.next(~\"str\"), { |buf|\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(box), buf)\n     });\n     llvm::LLVMSetInitializer(g, box);\n@@ -837,8 +837,8 @@ fn C_str(cx: &@crate_ctxt, s: &istr) -> ValueRef {\n \n // Returns a Plain Old LLVM String:\n fn C_postr(s: &istr) -> ValueRef {\n-    ret istr::as_buf(s, { |buf|\n-        llvm::LLVMConstString(buf, istr::byte_len(s), False)\n+    ret str::as_buf(s, { |buf|\n+        llvm::LLVMConstString(buf, str::byte_len(s), False)\n     });\n }\n \n@@ -871,7 +871,7 @@ fn C_bytes(bytes: &[u8]) -> ValueRef {\n \n fn C_shape(ccx: &@crate_ctxt, bytes: &[u8]) -> ValueRef {\n     let llshape = C_bytes(bytes);\n-    let llglobal = istr::as_buf(ccx.names.next(~\"shape\"), { |buf|\n+    let llglobal = str::as_buf(ccx.names.next(~\"shape\"), { |buf|\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n     });\n     llvm::LLVMSetInitializer(llglobal, llshape);"}, {"sha": "8beb796fd47af23392c1ecf6ffe4c5c1bbb081f0", "filename": "src/comp/middle/trans_ivec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -114,7 +114,7 @@ fn trans_ivec(bcx: &@block_ctxt, args: &[@ast::expr],\n     ret rslt(bcx, vptr);\n }\n fn trans_istr(bcx: &@block_ctxt, s: istr) -> result {\n-    let veclen = std::istr::byte_len(s) + 1u; // +1 for \\0\n+    let veclen = std::str::byte_len(s) + 1u; // +1 for \\0\n     let {bcx, val: sptr, _} =\n         alloc(bcx, ty::mk_istr(bcx_tcx(bcx)), veclen);\n "}, {"sha": "6c70e8aab9fe3facefb5411739bef3927e8fc6ac", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,6 +1,6 @@\n // Translation of object-related things to LLVM IR.\n \n-import std::istr;\n+import std::str;\n import std::option;\n import std::vec;\n import option::none;\n@@ -396,22 +396,22 @@ tag vtbl_mthd {\n \n // Alphabetize ast::methods by ident.  A helper for create_vtbl.\n fn ast_mthd_lteq(a: &@ast::method, b: &@ast::method) -> bool {\n-    ret istr::lteq(a.node.ident, b.node.ident);\n+    ret str::lteq(a.node.ident, b.node.ident);\n }\n \n // Alphabetize vtbl_mthds by ident.  A helper for create_vtbl.\n fn vtbl_mthd_lteq(a: &vtbl_mthd, b: &vtbl_mthd) -> bool {\n     alt a {\n       normal_mthd(ma) {\n         alt b {\n-          normal_mthd(mb) { ret istr::lteq(ma.node.ident, mb.node.ident); }\n-          fwding_mthd(mb) { ret istr::lteq(ma.node.ident, mb.ident); }\n+          normal_mthd(mb) { ret str::lteq(ma.node.ident, mb.node.ident); }\n+          fwding_mthd(mb) { ret str::lteq(ma.node.ident, mb.ident); }\n         }\n       }\n       fwding_mthd(ma) {\n         alt b {\n-          normal_mthd(mb) { ret istr::lteq(ma.ident, mb.node.ident); }\n-          fwding_mthd(mb) { ret istr::lteq(ma.ident, mb.ident); }\n+          normal_mthd(mb) { ret str::lteq(ma.ident, mb.node.ident); }\n+          fwding_mthd(mb) { ret str::lteq(ma.ident, mb.ident); }\n         }\n       }\n     }\n@@ -430,7 +430,7 @@ fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd, addtl_meths: [@ast::method])\n     alt m {\n       fwding_mthd(fm) {\n         for am: @ast::method in addtl_meths {\n-            if istr::eq(am.node.ident, fm.ident) { ret none; }\n+            if str::eq(am.node.ident, fm.ident) { ret none; }\n         }\n         ret some(fwding_mthd(fm));\n       }\n@@ -570,7 +570,7 @@ fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: &istr) ->\n     let vtbl = C_struct(llmethods);\n     let vtbl_name = mangle_internal_name_by_path(\n         cx.ccx, cx.path + [name]);\n-    let gvar = istr::as_buf(vtbl_name, { |buf|\n+    let gvar = str::as_buf(vtbl_name, { |buf|\n         llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), buf)\n     });\n     llvm::LLVMSetInitializer(gvar, vtbl);"}, {"sha": "0be3d1776ba5a328f05d98f959125a4ee3d07f55", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -4,7 +4,7 @@ import std::option::some;\n import std::option::none;\n import std::int;\n import std::uint;\n-import std::istr;\n+import std::str;\n import syntax::ast::*;\n import syntax::ast_util::pat_binding_ids;\n import syntax::visit;"}, {"sha": "62c883eb9f8fc78fe2c12e2652406e4bb744c052", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,6 +1,6 @@\n import std::vec;\n import std::int::str;\n-import std::istr;\n+import std::str;\n import std::option;\n import std::option::*;\n import std::int;"}, {"sha": "cef36843ea692ab188da0d1de503cbeb64799b65", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -37,7 +37,7 @@ import std::option;\n import std::option::t;\n import std::option::some;\n import std::option::none;\n-import std::istr;\n+import std::str;\n import aux::*;\n import syntax::print::pprust::ty_to_str;\n import util::common::log_stmt_err;"}, {"sha": "4c6ce536d7df1a0874094c7e0a8fb34bfbb3cb9c", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,4 +1,4 @@\n-import std::istr;\n+import std::str;\n import std::uint;\n import std::int;\n import std::vec;"}, {"sha": "a7f385161252e40fc85cf954f39a422d1d9254b7", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,6 +1,6 @@\n \n import std::vec;\n-import std::istr;\n+import std::str;\n import std::option;\n import std::option::none;\n import std::option::some;"}, {"sha": "e6b35121ec2953564f4c6553a850a4c6622bd016", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,7 +1,7 @@\n import syntax::print::pprust::path_to_str;\n import util::ppaux::ty_to_str;\n import std::vec;\n-import std::istr;\n+import std::str;\n import std::option;\n import std::option::get;\n import std::option::is_none;"}, {"sha": "56ccb1b0dc5c61b21da935a508b9d49431ac4e97", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,6 +1,6 @@\n import std::int;\n import std::vec;\n-import std::istr;\n+import std::str;\n import std::uint;\n import std::box;\n import std::ufind;\n@@ -1420,7 +1420,7 @@ fn hash_type_structure(st: &sty) -> uint {\n       ty_native_fn(_, args, rty) { ret hash_fn(28u, args, rty); }\n       ty_obj(methods) {\n         let h = 29u;\n-        for m: method in methods { h += h << 5u + istr::hash(m.ident); }\n+        for m: method in methods { h += h << 5u + str::hash(m.ident); }\n         ret h;\n       }\n       ty_var(v) { ret hash_uint(30u, v as uint); }\n@@ -1447,7 +1447,7 @@ fn hash_type_info(st: &sty, cname_opt: &option::t<istr>) -> uint {\n     let h = hash_type_structure(st);\n     alt cname_opt {\n       none. {/* no-op */ }\n-      some(s) { h += h << 5u + istr::hash(s); }\n+      some(s) { h += h << 5u + str::hash(s); }\n     }\n     ret h;\n }\n@@ -1511,7 +1511,7 @@ fn eq_raw_ty(a: &@raw_t, b: &@raw_t) -> bool {\n       none. { alt b.cname { none. {/* ok */ } _ { ret false; } } }\n       some(s_a) {\n         alt b.cname {\n-          some(s_b) { if !istr::eq(s_a, s_b) { ret false; } }\n+          some(s_b) { if !str::eq(s_a, s_b) { ret false; } }\n           _ { ret false; }\n         }\n       }\n@@ -1708,21 +1708,21 @@ fn stmt_node_id(s: &@ast::stmt) -> ast::node_id {\n fn field_idx(sess: &session::session, sp: &span, id: &ast::ident,\n              fields: &[field]) -> uint {\n     let i: uint = 0u;\n-    for f: field in fields { if istr::eq(f.ident, id) { ret i; } i += 1u; }\n+    for f: field in fields { if str::eq(f.ident, id) { ret i; } i += 1u; }\n     sess.span_fatal(sp, ~\"unknown field '\" +\n                     id + ~\"' of record\");\n }\n \n fn method_idx(sess: &session::session, sp: &span, id: &ast::ident,\n               meths: &[method]) -> uint {\n     let i: uint = 0u;\n-    for m: method in meths { if istr::eq(m.ident, id) { ret i; } i += 1u; }\n+    for m: method in meths { if str::eq(m.ident, id) { ret i; } i += 1u; }\n     sess.span_fatal(sp, ~\"unknown method '\" + id + ~\"' of obj\");\n }\n \n fn sort_methods(meths: &[method]) -> [method] {\n     fn method_lteq(a: &method, b: &method) -> bool {\n-        ret istr::lteq(a.ident, b.ident);\n+        ret str::lteq(a.ident, b.ident);\n     }\n     ret std::sort::merge_sort::<method>(bind method_lteq(_, _), meths);\n }\n@@ -2039,7 +2039,7 @@ mod unify {\n         while i < expected_len {\n             let e_meth = expected_meths[i];\n             let a_meth = actual_meths[i];\n-            if !istr::eq(e_meth.ident, a_meth.ident) {\n+            if !str::eq(e_meth.ident, a_meth.ident) {\n                 ret ures_err(terr_obj_meths(e_meth.ident, a_meth.ident));\n             }\n             let r =\n@@ -2316,7 +2316,7 @@ mod unify {\n                       none. { ret ures_err(terr_record_mutability); }\n                       some(m) { mut = m; }\n                     }\n-                    if !istr::eq(expected_field.ident, actual_field.ident) {\n+                    if !str::eq(expected_field.ident, actual_field.ident) {\n                         let err =\n                             terr_record_fields(expected_field.ident,\n                                                actual_field.ident);"}, {"sha": "15e6301511c3b9d393a73edc6960e36b8f655a93", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -36,7 +36,7 @@ import middle::ty::unify::fix_ok;\n import middle::ty::unify::fix_err;\n import std::int;\n import std::vec;\n-import std::istr;\n+import std::str;\n import std::uint;\n import std::map;\n import std::map::hashmap;\n@@ -1443,7 +1443,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n                      ex_f_count, f_count]);\n         }\n         fn matches(name: &istr, f: &ty::field) -> bool {\n-            ret istr::eq(name, f.ident);\n+            ret str::eq(name, f.ident);\n         }\n         for f: ast::field_pat in fields {\n             alt vec::find(bind matches(f.ident, _), ex_fields) {\n@@ -2233,7 +2233,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             for f: spanned<ty::field> in fields_t {\n                 let found = false;\n                 for bf: ty::field in base_fields {\n-                    if istr::eq(f.node.ident, bf.ident) {\n+                    if str::eq(f.node.ident, bf.ident) {\n                         demand::simple(fcx, f.span, bf.mt.ty, f.node.mt.ty);\n                         found = true;\n                     }\n@@ -2397,7 +2397,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                option::t<ty::method> {\n \n                 for om: @ast::method in outer_obj_methods {\n-                    if istr::eq(om.node.ident, m.ident) {\n+                    if str::eq(om.node.ident, m.ident) {\n                         // We'd better be overriding with one of the same\n                         // type.  Check to make sure.\n                         let new_type = ty_of_method(ccx, om);"}, {"sha": "d82a2302be59b933a5c7ca61f2d974a8177ac0fd", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,4 +1,4 @@\n-import std::istr;\n+import std::str;\n import std::option;\n import codemap::span;\n import ast::*;\n@@ -16,7 +16,7 @@ fn dummy_sp() -> span { ret mk_sp(0u, 0u); }\n fn path_name(p: &path) -> istr { path_name_i(p.node.idents) }\n \n fn path_name_i(idents: &[ident]) -> istr {\n-    istr::connect(idents, ~\"::\")\n+    str::connect(idents, ~\"::\")\n }\n \n fn local_def(id: node_id) -> def_id { ret {crate: local_crate, node: id}; }\n@@ -157,7 +157,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n     for vi: @view_item in m.view_items {\n         alt vi.node {\n           view_item_export(ids, _) {\n-            for id in ids { if istr::eq(i, id) { ret true; } }\n+            for id in ids { if str::eq(i, id) { ret true; } }\n             count += 1u;\n           }\n           _ {/* fall through */ }"}, {"sha": "c56ccc2192191997f38c59061903f7a9389f3afb", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,6 +1,6 @@\n import std::vec;\n import std::uint;\n-import std::istr;\n+import std::str;\n import std::term;\n import std::io;\n import std::option;\n@@ -148,13 +148,13 @@ fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n             io::stdout().write_str(\n                 #ifmt[~\"%s:%u \", fm.name, line + 1u]);\n             let s = get_line(fm, line as int, file);\n-            if !istr::ends_with(s, ~\"\\n\") { s += ~\"\\n\"; }\n+            if !str::ends_with(s, ~\"\\n\") { s += ~\"\\n\"; }\n             io::stdout().write_str(s);\n         }\n         if elided {\n             let last_line = display_lines[vec::len(display_lines) - 1u];\n             let s = #ifmt[~\"%s:%u \", fm.name, last_line + 1u];\n-            let indent = istr::char_len(s);\n+            let indent = str::char_len(s);\n             let out = ~\"\";\n             while indent > 0u { out += ~\" \"; indent -= 1u; }\n             out += ~\"...\\n\";\n@@ -172,16 +172,16 @@ fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n             while num > 0u { num /= 10u; digits += 1u; }\n \n             // indent past |name:## | and the 0-offset column location\n-            let left = istr::char_len(fm.name) + digits + lo.col + 3u;\n+            let left = str::char_len(fm.name) + digits + lo.col + 3u;\n             let s = ~\"\";\n-            while left > 0u { istr::push_char(s, ' '); left -= 1u; }\n+            while left > 0u { str::push_char(s, ' '); left -= 1u; }\n \n             s += ~\"^\";\n             let hi = lookup_char_pos(cm, option::get(sp).hi);\n             if hi.col != lo.col {\n                 // the ^ already takes up one space\n                 let width = hi.col - lo.col - 1u;\n-                while width > 0u { istr::push_char(s, '~'); width -= 1u; }\n+                while width > 0u { str::push_char(s, '~'); width -= 1u; }\n             }\n             io::stdout().write_str(s + ~\"\\n\");\n         }\n@@ -221,12 +221,12 @@ fn get_line(fm: filemap, line: int, file: &istr) -> istr {\n         // If we're not done parsing the file, we're at the limit of what's\n         // parsed. If we just slice the rest of the string, we'll print out\n         // the remainder of the file, which is undesirable.\n-        end = istr::byte_len(file);\n-        let rest = istr::slice(file, begin, end);\n-        let newline = istr::index(rest, '\\n' as u8);\n+        end = str::byte_len(file);\n+        let rest = str::slice(file, begin, end);\n+        let newline = str::index(rest, '\\n' as u8);\n         if newline != -1 { end = begin + (newline as uint); }\n     }\n-    ret istr::slice(file, begin, end);\n+    ret str::slice(file, begin, end);\n }\n \n fn get_filemap(cm: codemap, filename: istr) -> filemap {"}, {"sha": "84d9061c6148211159a7d2d078f6128fc4c7b201", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,4 +1,4 @@\n-import std::istr;\n+import std::str;\n import std::vec;\n import std::option;\n import std::map::hashmap;"}, {"sha": "ed493137369c9ca10e79fcf4d33dd252b102c0a2", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -5,7 +5,7 @@\n  * interface.\n  */\n import std::vec;\n-import std::istr;\n+import std::str;\n import std::option;\n import std::generic_os;\n import base::*;"}, {"sha": "ad58a617f45f01dbc99b2f74e782502bf90dd351", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -5,7 +5,7 @@ import std::option::some;\n \n import std::map::hashmap;\n import std::vec;\n-import std::istr;\n+import std::str;\n \n import syntax::ast::crate;\n import syntax::ast::expr_;"}, {"sha": "d989151831ec185009e1658a5804a98441009182", "filename": "src/comp/syntax/ext/ident_to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,5 +1,5 @@\n import std::vec;\n-import std::istr;\n+import std::str;\n import std::option;\n import base::*;\n import syntax::ast;"}, {"sha": "3b90ebeed13b8722063fed8f631c0cb1a20f165e", "filename": "src/comp/syntax/ext/ifmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fifmt.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -6,7 +6,7 @@\n  * compiler syntax extension plugin interface.\n  */\n import std::vec;\n-import std::istr;\n+import std::str;\n import std::option;\n import std::option::none;\n import std::option::some;\n@@ -103,7 +103,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     }\n     fn make_path_vec(cx: &ext_ctxt, ident: &ast::ident) -> [ast::ident] {\n         fn compiling_std(cx: &ext_ctxt) -> bool {\n-            ret istr::find(cx.crate_file_name(), ~\"std.rc\") >= 0;\n+            ret str::find(cx.crate_file_name(), ~\"std.rc\") >= 0;\n         }\n         if compiling_std(cx) {\n             ret [~\"extifmt\", ~\"rt\", ident];"}, {"sha": "a8fa657c20cb4a099bc0f2d359554e50b2578c26", "filename": "src/comp/syntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,7 +1,7 @@\n import std::option;\n import base::*;\n import syntax::ast;\n-import std::istr;\n+import std::str;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n                      _body: &option::t<istr>) -> @ast::expr {"}, {"sha": "2df629d3f8ce9025f4fcc7e6c2c9e1e7a1231bcc", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -2,7 +2,7 @@ use std;\n \n import codemap::span;\n import std::vec;\n-import std::istr;\n+import std::str;\n import std::option;\n import std::map::hashmap;\n import std::map::new_str_hash;"}, {"sha": "ee7c5a3d3383b3136b4572232841726d293aa86f", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,5 +1,5 @@\n \n-import std::istr;\n+import std::str;\n import std::option;\n import std::option::some;\n import std::option::none;"}, {"sha": "57720422306d3c43c96ffa65404ae720e6b2b333", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -2,7 +2,7 @@\n import std::io;\n import std::int;\n import std::vec;\n-import std::istr;\n+import std::str;\n import std::map;\n import std::map::hashmap;\n import std::option;\n@@ -44,19 +44,19 @@ fn new_reader(cm: &codemap::codemap, src: &istr, filemap: codemap::filemap,\n         fn get_str_from(start: uint) -> istr {\n             // I'm pretty skeptical about this subtraction. What if there's a\n             // multi-byte character before the mark?\n-            ret istr::slice(src, start - 1u, pos - 1u);\n+            ret str::slice(src, start - 1u, pos - 1u);\n         }\n         fn get_chpos() -> uint { ret chpos; }\n         fn get_byte_pos() -> uint { ret pos; }\n         fn curr() -> char { ret ch; }\n         fn next() -> char {\n             if pos < len {\n-                ret istr::char_at(src, pos);\n+                ret str::char_at(src, pos);\n             } else { ret -1 as char; }\n         }\n         fn init() {\n             if pos < len {\n-                let next = istr::char_range_at(src, pos);\n+                let next = str::char_range_at(src, pos);\n                 pos = next.next;\n                 ch = next.ch;\n             }\n@@ -69,7 +69,7 @@ fn new_reader(cm: &codemap::codemap, src: &istr, filemap: codemap::filemap,\n                     codemap::next_line(fm, chpos, pos + fm.start_pos.byte);\n                     col = 0u;\n                 }\n-                let next = istr::char_range_at(src, pos);\n+                let next = str::char_range_at(src, pos);\n                 pos = next.next;\n                 ch = next.ch;\n             } else { ch = -1 as char; }\n@@ -85,7 +85,7 @@ fn new_reader(cm: &codemap::codemap, src: &istr, filemap: codemap::filemap,\n     }\n     let strs: [istr] = [];\n     let rd =\n-        reader(cm, src, istr::byte_len(src), 0u, 0u, -1 as char,\n+        reader(cm, src, str::byte_len(src), 0u, 0u, -1 as char,\n                filemap.start_pos.ch, strs, filemap, itr);\n     rd.init();\n     ret rd;\n@@ -178,15 +178,15 @@ fn scan_exponent(rdr: &reader) -> option::t<istr> {\n     let c = rdr.curr();\n     let rslt = ~\"\";\n     if c == 'e' || c == 'E' {\n-        rslt += istr::unsafe_from_bytes([c as u8]);\n+        rslt += str::unsafe_from_bytes([c as u8]);\n         rdr.bump();\n         c = rdr.curr();\n         if c == '-' || c == '+' {\n-            rslt += istr::unsafe_from_bytes([c as u8]);\n+            rslt += str::unsafe_from_bytes([c as u8]);\n             rdr.bump();\n         }\n         let exponent = scan_dec_digits(rdr);\n-        if istr::byte_len(exponent) > 0u {\n+        if str::byte_len(exponent) > 0u {\n             ret some(rslt + exponent);\n         } else { rdr.err(~\"scan_exponent: bad fp literal\"); fail; }\n     } else { ret none::<istr>; }\n@@ -196,7 +196,7 @@ fn scan_dec_digits(rdr: &reader) -> istr {\n     let c = rdr.curr();\n     let rslt: istr = ~\"\";\n     while is_dec_digit(c) || c == '_' {\n-        if c != '_' { rslt += istr::unsafe_from_bytes([c as u8]); }\n+        if c != '_' { rslt += str::unsafe_from_bytes([c as u8]); }\n         rdr.bump();\n         c = rdr.curr();\n     }\n@@ -348,11 +348,11 @@ fn next_token_inner(rdr: &reader) -> token::token {\n     let c = rdr.curr();\n     if is_alpha(c) || c == '_' {\n         while is_alnum(c) || c == '_' {\n-            istr::push_char(accum_str, c);\n+            str::push_char(accum_str, c);\n             rdr.bump();\n             c = rdr.curr();\n         }\n-        if istr::eq(accum_str, ~\"_\") { ret token::UNDERSCORE; }\n+        if str::eq(accum_str, ~\"_\") { ret token::UNDERSCORE; }\n         let is_mod_name = c == ':' && rdr.next() == ':';\n         ret token::IDENT(interner::intern::<istr>(\n             *rdr.get_interner(),\n@@ -493,20 +493,20 @@ fn next_token_inner(rdr: &reader) -> token::token {\n                 let escaped = rdr.curr();\n                 rdr.bump();\n                 alt escaped {\n-                  'n' { istr::push_byte(accum_str, '\\n' as u8); }\n-                  'r' { istr::push_byte(accum_str, '\\r' as u8); }\n-                  't' { istr::push_byte(accum_str, '\\t' as u8); }\n-                  '\\\\' { istr::push_byte(accum_str, '\\\\' as u8); }\n-                  '\"' { istr::push_byte(accum_str, '\"' as u8); }\n+                  'n' { str::push_byte(accum_str, '\\n' as u8); }\n+                  'r' { str::push_byte(accum_str, '\\r' as u8); }\n+                  't' { str::push_byte(accum_str, '\\t' as u8); }\n+                  '\\\\' { str::push_byte(accum_str, '\\\\' as u8); }\n+                  '\"' { str::push_byte(accum_str, '\"' as u8); }\n                   '\\n' { consume_whitespace(rdr); }\n                   'x' {\n-                    istr::push_char(accum_str, scan_numeric_escape(rdr, 2u));\n+                    str::push_char(accum_str, scan_numeric_escape(rdr, 2u));\n                   }\n                   'u' {\n-                    istr::push_char(accum_str, scan_numeric_escape(rdr, 4u));\n+                    str::push_char(accum_str, scan_numeric_escape(rdr, 4u));\n                   }\n                   'U' {\n-                    istr::push_char(accum_str, scan_numeric_escape(rdr, 8u));\n+                    str::push_char(accum_str, scan_numeric_escape(rdr, 8u));\n                   }\n                   c2 {\n                     rdr.err(\n@@ -516,7 +516,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n                   }\n                 }\n               }\n-              _ { istr::push_char(accum_str, ch); }\n+              _ { str::push_char(accum_str, ch); }\n             }\n         }\n         rdr.bump();\n@@ -569,7 +569,7 @@ type cmnt = {style: cmnt_style, lines: [istr], pos: uint};\n fn read_to_eol(rdr: &reader) -> istr {\n     let val = ~\"\";\n     while rdr.curr() != '\\n' && !rdr.is_eof() {\n-        istr::push_char(val, rdr.curr());\n+        str::push_char(val, rdr.curr());\n         rdr.bump();\n     }\n     if rdr.curr() == '\\n' { rdr.bump(); }\n@@ -634,8 +634,8 @@ fn trim_whitespace_prefix_and_push_line(lines: &mutable [istr], s: &istr,\n                                         col: uint) {\n     let s1;\n     if all_whitespace(s, 0u, col) {\n-        if col < istr::byte_len(s) {\n-            s1 = istr::slice(s, col, istr::byte_len(s));\n+        if col < str::byte_len(s) {\n+            s1 = str::slice(s, col, str::byte_len(s));\n         } else { s1 = ~\"\"; }\n     } else { s1 = s; }\n     log ~\"pushing line: \" + s1;\n@@ -659,7 +659,7 @@ fn read_block_comment(rdr: &reader, code_to_the_left: bool) -> cmnt {\n             curr_line = ~\"\";\n             rdr.bump();\n         } else {\n-            istr::push_char(curr_line, rdr.curr());\n+            str::push_char(curr_line, rdr.curr());\n             if rdr.curr() == '/' && rdr.next() == '*' {\n                 rdr.bump();\n                 rdr.bump();\n@@ -675,7 +675,7 @@ fn read_block_comment(rdr: &reader, code_to_the_left: bool) -> cmnt {\n             }\n         }\n     }\n-    if istr::byte_len(curr_line) != 0u {\n+    if str::byte_len(curr_line) != 0u {\n         trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n     }\n     let style = if code_to_the_left { trailing } else { isolated };\n@@ -722,8 +722,8 @@ type lit = {lit: istr, pos: uint};\n fn gather_comments_and_literals(cm: &codemap::codemap, path: &istr,\n                                 srdr: io::reader) ->\n    {cmnts: [cmnt], lits: [lit]} {\n-    let src = istr::unsafe_from_bytes(srdr.read_whole_stream());\n-    let itr = @interner::mk::<istr>(istr::hash, istr::eq);\n+    let src = str::unsafe_from_bytes(srdr.read_whole_stream());\n+    let itr = @interner::mk::<istr>(str::hash, str::eq);\n     let rdr = new_reader(cm, src,\n                          codemap::new_filemap(\n                              path, 0u, 0u), itr);"}, {"sha": "763172c81fa50f5d903f7a8f02ab759e4976dbf0", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,7 +1,7 @@\n \n import std::io;\n import std::vec;\n-import std::istr;\n+import std::str;\n import std::option;\n import std::option::some;\n import std::option::none;\n@@ -66,7 +66,7 @@ fn new_parser_from_file(sess: parse_sess, cfg: &ast::crate_cfg, path: &istr,\n     let filemap = codemap::new_filemap(\n         path, chpos, byte_pos);\n     sess.cm.files += [filemap];\n-    let itr = @interner::mk(istr::hash, istr::eq);\n+    let itr = @interner::mk(str::hash, str::eq);\n     let rdr = lexer::new_reader(sess.cm, src, filemap, itr);\n     ret new_parser(sess, cfg, rdr, ftype);\n }\n@@ -247,15 +247,15 @@ fn eat(p: &parser, tok: &token::token) -> bool {\n \n fn is_word(p: &parser, word: &istr) -> bool {\n     ret alt p.peek() {\n-          token::IDENT(sid, false) { istr::eq(word, p.get_str(sid)) }\n+          token::IDENT(sid, false) { str::eq(word, p.get_str(sid)) }\n           _ { false }\n         };\n }\n \n fn eat_word(p: &parser, word: &istr) -> bool {\n     alt p.peek() {\n       token::IDENT(sid, false) {\n-        if istr::eq(word, p.get_str(sid)) {\n+        if str::eq(word, p.get_str(sid)) {\n             p.bump();\n             ret true;\n         } else { ret false; }\n@@ -2036,14 +2036,14 @@ fn parse_item_native_mod(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     let abi = ast::native_abi_cdecl;\n     if !is_word(p, ~\"mod\") {\n         let t = parse_str(p);\n-        if istr::eq(t, ~\"cdecl\") {\n-        } else if istr::eq(t, ~\"rust\") {\n+        if str::eq(t, ~\"cdecl\") {\n+        } else if str::eq(t, ~\"rust\") {\n             abi = ast::native_abi_rust;\n-        } else if istr::eq(t, ~\"llvm\") {\n+        } else if str::eq(t, ~\"llvm\") {\n             abi = ast::native_abi_llvm;\n-        } else if istr::eq(t, ~\"rust-intrinsic\") {\n+        } else if str::eq(t, ~\"rust-intrinsic\") {\n             abi = ast::native_abi_rust_intrinsic;\n-        } else if istr::eq(t, ~\"x86stdcall\") {\n+        } else if str::eq(t, ~\"x86stdcall\") {\n             abi = ast::native_abi_x86stdcall;\n         } else { p.fatal(~\"unsupported abi: \" + t); }\n     }\n@@ -2419,8 +2419,8 @@ fn is_view_item(p: &parser) -> bool {\n     alt p.peek() {\n       token::IDENT(sid, false) {\n         let st = p.get_str(sid);\n-        ret istr::eq(st, ~\"use\") || istr::eq(st, ~\"import\") ||\n-                istr::eq(st, ~\"export\");\n+        ret str::eq(st, ~\"use\") || str::eq(st, ~\"import\") ||\n+                str::eq(st, ~\"export\");\n       }\n       _ { ret false; }\n     }\n@@ -2450,7 +2450,7 @@ fn parse_crate_from_source_str(name: &istr, source: &istr,\n     let ftype = SOURCE_FILE;\n     let filemap = codemap::new_filemap(name, 0u, 0u);\n     sess.cm.files += [filemap];\n-    let itr = @interner::mk(istr::hash, istr::eq);\n+    let itr = @interner::mk(str::hash, str::eq);\n     let rdr = lexer::new_reader(sess.cm, source,\n                                 filemap, itr);\n     let p = new_parser(sess, cfg, rdr, ftype);\n@@ -2588,9 +2588,9 @@ fn parse_crate_from_crate_file(input: &istr, cfg: &ast::crate_cfg,\n \n fn parse_crate_from_file(input: &istr, cfg: &ast::crate_cfg,\n                          sess: &parse_sess) -> @ast::crate {\n-    if istr::ends_with(input, ~\".rc\") {\n+    if str::ends_with(input, ~\".rc\") {\n         parse_crate_from_crate_file(input, cfg, sess)\n-    } else if istr::ends_with(input, ~\".rs\") {\n+    } else if str::ends_with(input, ~\".rs\") {\n         parse_crate_from_source_file(input, cfg, sess)\n     } else {\n         codemap::emit_error(none, ~\"unknown input file type: \""}, {"sha": "24d2a3b9a6f74ca36bd20e1c1fa6588472fefef1", "filename": "src/comp/syntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -5,7 +5,7 @@ import std::map::new_str_hash;\n import util::interner;\n import std::int;\n import std::uint;\n-import std::istr;\n+import std::str;\n \n type str_num = uint;\n \n@@ -166,8 +166,8 @@ fn to_str(r: lexer::reader, t: token) -> istr {\n       LIT_CHAR(c) {\n         // FIXME: escape.\n         let tmp = ~\"'\";\n-        istr::push_char(tmp, c);\n-        istr::push_byte(tmp, '\\'' as u8);\n+        str::push_char(tmp, c);\n+        str::push_byte(tmp, '\\'' as u8);\n         ret tmp;\n       }\n       LIT_BOOL(b) { if b { ret ~\"true\"; } else { ret ~\"false\"; } }"}, {"sha": "39e5b59eb613bcba7663d280a25b447930db9f1c", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,7 +1,7 @@\n \n import std::io;\n import std::vec;\n-import std::istr;\n+import std::str;\n \n /*\n  * This pretty-printer is a direct reimplementation of Philip Karlton's\n@@ -496,7 +496,7 @@ fn end(p: printer) { p.pretty_print(END); }\n fn eof(p: printer) { p.pretty_print(EOF); }\n \n fn word(p: printer, wrd: &istr) {\n-    p.pretty_print(STRING(wrd, istr::char_len(wrd) as int));\n+    p.pretty_print(STRING(wrd, str::char_len(wrd) as int));\n }\n \n fn huge_word(p: printer, wrd: &istr) {"}, {"sha": "a78006417a4581bb0125469551b1f26f78ec5008", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -2,7 +2,7 @@\n import std::vec;\n import std::int;\n import std::io;\n-import std::istr;\n+import std::str;\n import std::uint;\n import std::option;\n import parse::lexer;\n@@ -156,7 +156,7 @@ fn head(s: &ps, w: &istr) {\n     // outer-box is consistent\n     cbox(s, indent_unit);\n     // head-box is inconsistent\n-    ibox(s, istr::char_len(w) + 1u);\n+    ibox(s, str::char_len(w) + 1u);\n     // keyword that starts the head\n     word_nbsp(s, w);\n }\n@@ -432,7 +432,7 @@ fn print_item(s: &ps, item: &@ast::item) {\n         }\n         word_nbsp(s, ~\"mod\");\n         word_nbsp(s, item.ident);\n-        if !istr::eq(nmod.native_name, item.ident) {\n+        if !str::eq(nmod.native_name, item.ident) {\n             word_space(s, ~\"=\");\n             print_string(s, nmod.native_name);\n             nbsp(s);\n@@ -458,7 +458,7 @@ fn print_item(s: &ps, item: &@ast::item) {\n       ast::item_tag(variants, params) {\n         let newtype =\n             vec::len(variants) == 1u &&\n-                istr::eq(item.ident, variants[0].node.name) &&\n+                str::eq(item.ident, variants[0].node.name) &&\n                 vec::len(variants[0].node.args) == 1u;\n         if newtype {\n             ibox(s, indent_unit);\n@@ -1318,7 +1318,7 @@ fn print_view_item(s: &ps, item: &@ast::view_item) {\n       }\n       ast::view_item_import(id, ids, _) {\n         head(s, ~\"import\");\n-        if !istr::eq(id, ids[vec::len(ids) - 1u]) {\n+        if !str::eq(id, ids[vec::len(ids) - 1u]) {\n             word_space(s, id);\n             word_space(s, ~\"=\");\n         }\n@@ -1510,7 +1510,7 @@ fn print_literal(s: &ps, lit: &@ast::lit) {\n       }\n       ast::lit_char(ch) {\n         word(s.s,\n-             ~\"'\" + escape_str(istr::unsafe_from_bytes([ch as u8]), '\\'') +\n+             ~\"'\" + escape_str(str::unsafe_from_bytes([ch as u8]), '\\'') +\n                  ~\"'\");\n       }\n       ast::lit_int(val) { word(s.s, int::str(val)); }\n@@ -1572,7 +1572,7 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n         for line: istr in cmnt.lines {\n             // Don't print empty lines because they will end up as trailing\n             // whitespace\n-            if istr::is_not_empty(line) {\n+            if str::is_not_empty(line) {\n                 word(s.s, line);\n             }\n             hardbreak(s.s);\n@@ -1586,7 +1586,7 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n         } else {\n             ibox(s, 0u);\n             for line: istr in cmnt.lines {\n-                if istr::is_not_empty(line) {\n+                if str::is_not_empty(line) {\n                     word(s.s, line);\n                 }\n                 hardbreak(s.s);\n@@ -1615,7 +1615,7 @@ fn print_string(s: &ps, st: &istr) {\n \n fn escape_str(st: &istr, to_escape: char) -> istr {\n     let out: istr = ~\"\";\n-    let len = istr::byte_len(st);\n+    let len = str::byte_len(st);\n     let i = 0u;\n     while i < len {\n         alt st[i] as char {\n@@ -1627,7 +1627,7 @@ fn escape_str(st: &istr, to_escape: char) -> istr {\n             if cur == to_escape { out += ~\"\\\\\"; }\n             // FIXME some (or all?) non-ascii things should be escaped\n \n-            istr::push_char(out, cur);\n+            str::push_char(out, cur);\n           }\n         }\n         i += 1u;"}, {"sha": "89d52834b99c1d4aa854d06840be1e12073138b5", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,4 +1,4 @@\n-import std::istr;\n+import std::str;\n import std::map;\n import std::map::hashmap;\n import std::uint;\n@@ -154,7 +154,7 @@ fn call_kind_str(c: call_kind) -> istr {\n }\n \n fn is_main_name(path: &[ast::ident]) -> bool {\n-    istr::eq(option::get(std::vec::last(path)), ~\"main\")\n+    str::eq(option::get(std::vec::last(path)), ~\"main\")\n }\n \n // FIXME mode this to std::float when editing the stdlib no longer"}, {"sha": "8fec8e547272b1e4150a247f5e9fe85d1933f071", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,5 +1,5 @@\n import std::vec;\n-import std::istr;\n+import std::str;\n import std::int;\n import std::option;\n import std::option::none;\n@@ -44,7 +44,7 @@ fn fn_ident_to_string(id: ast::node_id, i: &ast::fn_ident) -> istr {\n fn get_id_ident(cx: &ctxt, id: ast::def_id) -> istr {\n     if id.crate != ast::local_crate {\n         alt cx.ext_map.find(id) {\n-          some(j) { istr::connect(j, ~\"::\") }\n+          some(j) { str::connect(j, ~\"::\") }\n           _ { fail (~\"get_id_ident: can't find item in ext_map, id.crate = \"\n                     + int::str(id.crate)) }\n         }\n@@ -76,7 +76,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> istr {\n         s += ~\"(\";\n         let strs = [];\n         for a: arg in inputs { strs += [fn_input_to_str(cx, a)]; }\n-        s += istr::connect(strs, ~\", \");\n+        s += str::connect(strs, ~\", \");\n         s += ~\")\";\n         if struct(cx, output) != ty_nil {\n             alt cf {\n@@ -128,19 +128,19 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> istr {\n           ty_rec(elems) {\n             let strs: [istr] = [];\n             for fld: field in elems { strs += [field_to_str(cx, fld)]; }\n-            ~\"{\" + istr::connect(strs, ~\",\") + ~\"}\"\n+            ~\"{\" + str::connect(strs, ~\",\") + ~\"}\"\n           }\n           ty_tup(elems) {\n             let strs = [];\n             for elem in elems { strs += [ty_to_str(cx, elem)]; }\n-            ~\"(\" + istr::connect(strs, ~\",\") + ~\")\"\n+            ~\"(\" + str::connect(strs, ~\",\") + ~\")\"\n           }\n           ty_tag(id, tps) {\n             let s = get_id_ident(cx, id);\n             if vec::len::<t>(tps) > 0u {\n                 let strs: [istr] = [];\n                 for typ: t in tps { strs += [ty_to_str(cx, typ)]; }\n-                s += ~\"[\" + istr::connect(strs, ~\",\") + ~\"]\";\n+                s += ~\"[\" + str::connect(strs, ~\",\") + ~\"]\";\n             }\n             s\n           }\n@@ -154,20 +154,20 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> istr {\n           ty_obj(meths) {\n             let strs = [];\n             for m: method in meths { strs += [method_to_str(cx, m)]; }\n-            ~\"obj {\\n\\t\" + istr::connect(strs, ~\"\\n\\t\") + ~\"\\n}\"\n+            ~\"obj {\\n\\t\" + str::connect(strs, ~\"\\n\\t\") + ~\"\\n}\"\n           }\n           ty_res(id, _, _) { get_id_ident(cx, id) }\n           ty_var(v) { ~\"<T\" + int::str(v) + ~\">\" }\n           ty_param(id, _) {\n-            ~\"'\" + istr::unsafe_from_bytes([('a' as u8) + (id as u8)])\n+            ~\"'\" + str::unsafe_from_bytes([('a' as u8) + (id as u8)])\n           }\n           _ { ty_to_short_str(cx, typ) }\n         }\n }\n \n fn ty_to_short_str(cx: &ctxt, typ: t) -> istr {\n     let s = encoder::encoded_ty(cx, typ);\n-    if istr::byte_len(s) >= 32u { s = istr::substr(s, 0u, 32u); }\n+    if str::byte_len(s) >= 32u { s = str::substr(s, 0u, 32u); }\n     ret s;\n }\n "}, {"sha": "4de76a12abbbdc427d2f77923d901d6b9563620e", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -9,7 +9,7 @@ import std::getopts::opt_str;\n import std::io;\n import std::io::stdout;\n import std::vec;\n-import std::istr;\n+import std::str;\n import std::uint;\n import std::option;\n \n@@ -28,20 +28,20 @@ fn write_file(filename: &istr, content: &istr) {\n \n fn file_contains(filename: &istr, needle: &istr) -> bool {\n     let contents = io::read_whole_file_str(filename);\n-    ret istr::find(contents, needle) != -1;\n+    ret str::find(contents, needle) != -1;\n }\n \n fn contains(haystack: &istr, needle: &istr) -> bool {\n-    istr::find(haystack, needle) != -1\n+    str::find(haystack, needle) != -1\n }\n \n fn find_rust_files(files: &mutable [istr], path: &istr) {\n-    if istr::ends_with(path, ~\".rs\") {\n+    if str::ends_with(path, ~\".rs\") {\n         if file_contains(path, ~\"xfail-test\") {\n             //log_err \"Skipping \" + path + \" because it is marked as xfail-test\";\n         } else { files += [path]; }\n     } else if fs::file_is_dir(path)\n-        && istr::find(path, ~\"compile-fail\") == -1 {\n+        && str::find(path, ~\"compile-fail\") == -1 {\n         for p in fs::list_dir(path) {\n             find_rust_files(files, p);\n         }"}, {"sha": "cdb0e3fb90d3f22c0840b352d8250dbccb89b178", "filename": "src/lib/aio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Faio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Faio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Faio.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -47,8 +47,8 @@ type ctx = chan<request>;\n fn ip_to_sbuf(ip: net::ip_addr) -> *u8 {\n     // FIXME: This is broken. We're creating a vector, getting a pointer\n     // to its buffer, then dropping the vector. On top of that, the vector\n-    // created by istr::bytes is not null-terminated.\n-    vec::to_ptr(istr::bytes(net::format_addr(ip)))\n+    // created by str::bytes is not null-terminated.\n+    vec::to_ptr(str::bytes(net::format_addr(ip)))\n }\n \n fn connect_task(ip: net::ip_addr, portnum: int, evt: chan<socket_event>) {"}, {"sha": "7f363b661da3d0407a1d03e341becfdb13bd4a84", "filename": "src/lib/extifmt.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fextifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fextifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextifmt.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -72,25 +72,25 @@ mod ct {\n \n     fn parse_fmt_string(s: &istr, error: error_fn) -> [piece] {\n         let pieces: [piece] = [];\n-        let lim = istr::byte_len(s);\n+        let lim = str::byte_len(s);\n         let buf = ~\"\";\n         fn flush_buf(buf: &istr, pieces: &mutable [piece]) -> istr {\n-            if istr::byte_len(buf) > 0u {\n+            if str::byte_len(buf) > 0u {\n                 let piece = piece_string(buf);\n                 pieces += [piece];\n             }\n             ret ~\"\";\n         }\n         let i = 0u;\n         while i < lim {\n-            let curr = istr::substr(s, i, 1u);\n-            if istr::eq(curr, ~\"%\") {\n+            let curr = str::substr(s, i, 1u);\n+            if str::eq(curr, ~\"%\") {\n                 i += 1u;\n                 if i >= lim {\n                     error(~\"unterminated conversion at end of string\");\n                 }\n-                let curr2 = istr::substr(s, i, 1u);\n-                if istr::eq(curr2, ~\"%\") {\n+                let curr2 = str::substr(s, i, 1u);\n+                if str::eq(curr2, ~\"%\") {\n                     i += 1u;\n                 } else {\n                     buf = flush_buf(buf, pieces);\n@@ -217,27 +217,27 @@ mod ct {\n     fn parse_type(s: &istr, i: uint, lim: uint, error: error_fn) ->\n        {ty: ty, next: uint} {\n         if i >= lim { error(~\"missing type in conversion\"); }\n-        let tstr = istr::substr(s, i, 1u);\n+        let tstr = str::substr(s, i, 1u);\n         // TODO: Do we really want two signed types here?\n         // How important is it to be printf compatible?\n         let t =\n-            if istr::eq(tstr, ~\"b\") {\n+            if str::eq(tstr, ~\"b\") {\n                 ty_bool\n-            } else if istr::eq(tstr, ~\"s\") {\n+            } else if str::eq(tstr, ~\"s\") {\n                 ty_str\n-            } else if istr::eq(tstr, ~\"c\") {\n+            } else if str::eq(tstr, ~\"c\") {\n                 ty_char\n-            } else if istr::eq(tstr, ~\"d\") || istr::eq(tstr, ~\"i\") {\n+            } else if str::eq(tstr, ~\"d\") || str::eq(tstr, ~\"i\") {\n                 ty_int(signed)\n-            } else if istr::eq(tstr, ~\"u\") {\n+            } else if str::eq(tstr, ~\"u\") {\n                 ty_int(unsigned)\n-            } else if istr::eq(tstr, ~\"x\") {\n+            } else if str::eq(tstr, ~\"x\") {\n                 ty_hex(case_lower)\n-            } else if istr::eq(tstr, ~\"X\") {\n+            } else if str::eq(tstr, ~\"X\") {\n                 ty_hex(case_upper)\n-            } else if istr::eq(tstr, ~\"t\") {\n+            } else if str::eq(tstr, ~\"t\") {\n                 ty_bits\n-            } else if istr::eq(tstr, ~\"o\") {\n+            } else if str::eq(tstr, ~\"o\") {\n                 ty_octal\n             } else { error(~\"unknown type in conversion: \" + tstr) };\n         ret {ty: t, next: i + 1u};\n@@ -289,7 +289,7 @@ mod rt {\n             alt cv.ty {\n               ty_default. { uint_to_str_prec(u, 10u, prec) }\n               ty_hex_lower. { uint_to_str_prec(u, 16u, prec) }\n-              ty_hex_upper. { istr::to_upper(uint_to_str_prec(u, 16u, prec)) }\n+              ty_hex_upper. { str::to_upper(uint_to_str_prec(u, 16u, prec)) }\n               ty_bits. { uint_to_str_prec(u, 2u, prec) }\n               ty_octal. { uint_to_str_prec(u, 8u, prec) }\n             };\n@@ -303,7 +303,7 @@ mod rt {\n         ret conv_str(cv, s);\n     }\n     fn conv_char(cv: &conv, c: char) -> istr {\n-        ret pad(cv, istr::from_char(c), pad_nozero);\n+        ret pad(cv, str::from_char(c), pad_nozero);\n     }\n     fn conv_str(cv: &conv, s: &istr) -> istr {\n         // For strings, precision is the maximum characters\n@@ -314,8 +314,8 @@ mod rt {\n             alt cv.precision {\n               count_implied. { s }\n               count_is(max) {\n-                if max as uint < istr::char_len(s) {\n-                    istr::substr(s, 0u, max as uint)\n+                if max as uint < str::char_len(s) {\n+                    str::substr(s, 0u, max as uint)\n                 } else { s }\n               }\n             };\n@@ -338,7 +338,7 @@ mod rt {\n                 ~\"\"\n             } else {\n                 let s = uint::to_str(num, radix);\n-                let len = istr::char_len(s);\n+                let len = str::char_len(s);\n                 if len < prec {\n                     let diff = prec - len;\n                     let pad = str_init_elt('0', diff);\n@@ -357,7 +357,7 @@ mod rt {\n     fn str_init_elt(c: char, n_elts: uint) -> istr {\n         let svec = vec::init_elt::<u8>(c as u8, n_elts);\n \n-        ret istr::unsafe_from_bytes(svec);\n+        ret str::unsafe_from_bytes(svec);\n     }\n     tag pad_mode { pad_signed; pad_unsigned; pad_nozero; }\n     fn pad(cv: &conv, s: &istr, mode: pad_mode) -> istr {\n@@ -370,7 +370,7 @@ mod rt {\n             uwidth = width as uint;\n           }\n         }\n-        let strlen = istr::char_len(s);\n+        let strlen = str::char_len(s);\n         if uwidth <= strlen { ret s; }\n         let padchar = ' ';\n         let diff = uwidth - strlen;\n@@ -403,12 +403,12 @@ mod rt {\n         // zeros. It may make sense to convert zero padding to a precision\n         // instead.\n \n-        if signed && zero_padding && istr::byte_len(s) > 0u {\n+        if signed && zero_padding && str::byte_len(s) > 0u {\n             let head = s[0];\n             if head == '+' as u8 || head == '-' as u8 || head == ' ' as u8 {\n-                let headstr = istr::unsafe_from_bytes([head]);\n-                let bytelen = istr::byte_len(s);\n-                let numpart = istr::substr(s, 1u, bytelen - 1u);\n+                let headstr = str::unsafe_from_bytes([head]);\n+                let bytelen = str::byte_len(s);\n+                let numpart = str::substr(s, 1u, bytelen - 1u);\n                 ret headstr + padstr + numpart;\n             }\n         }"}, {"sha": "745c30c80b31120709020652af6262b7fa22f4b8", "filename": "src/lib/fs.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -3,37 +3,37 @@ import os::getcwd;\n import os_fs;\n \n native \"rust\" mod rustrt {\n-    fn rust_file_is_dir(path: istr::sbuf) -> int;\n+    fn rust_file_is_dir(path: str::sbuf) -> int;\n }\n \n-fn path_sep() -> istr { ret istr::from_char(os_fs::path_sep); }\n+fn path_sep() -> istr { ret str::from_char(os_fs::path_sep); }\n \n type path = istr;\n \n fn dirname(p: &path) -> path {\n-    let i: int = istr::rindex(p, os_fs::path_sep as u8);\n+    let i: int = str::rindex(p, os_fs::path_sep as u8);\n     if i == -1 {\n-        i = istr::rindex(p, os_fs::alt_path_sep as u8);\n+        i = str::rindex(p, os_fs::alt_path_sep as u8);\n         if i == -1 { ret ~\".\"; }\n     }\n-    ret istr::substr(p, 0u, i as uint);\n+    ret str::substr(p, 0u, i as uint);\n }\n \n fn basename(p: &path) -> path {\n-    let i: int = istr::rindex(p, os_fs::path_sep as u8);\n+    let i: int = str::rindex(p, os_fs::path_sep as u8);\n     if i == -1 {\n-        i = istr::rindex(p, os_fs::alt_path_sep as u8);\n+        i = str::rindex(p, os_fs::alt_path_sep as u8);\n         if i == -1 { ret p; }\n     }\n-    let len = istr::byte_len(p);\n+    let len = str::byte_len(p);\n     if i + 1 as uint >= len { ret p; }\n-    ret istr::slice(p, i + 1 as uint, len);\n+    ret str::slice(p, i + 1 as uint, len);\n }\n \n \n // FIXME: Need some typestate to avoid bounds check when len(pre) == 0\n fn connect(pre: &path, post: &path) -> path {\n-    let len = istr::byte_len(pre);\n+    let len = str::byte_len(pre);\n     ret if pre[len - 1u] == os_fs::path_sep as u8 {\n \n             // Trailing '/'?\n@@ -42,19 +42,19 @@ fn connect(pre: &path, post: &path) -> path {\n }\n \n fn file_is_dir(p: &path) -> bool {\n-    ret istr::as_buf(p, { |buf|\n+    ret str::as_buf(p, { |buf|\n         rustrt::rust_file_is_dir(buf) != 0\n     });\n }\n \n fn list_dir(p: &path) -> [istr] {\n     let p = p;\n-    let pl = istr::byte_len(p);\n+    let pl = str::byte_len(p);\n     if pl == 0u || p[pl - 1u] as char != os_fs::path_sep { p += path_sep(); }\n     let full_paths: [istr] = [];\n     for filename: istr in os_fs::list_dir(p) {\n-        if !istr::eq(filename, ~\".\") {\n-            if !istr::eq(filename, ~\"..\") { full_paths += [p + filename]; }\n+        if !str::eq(filename, ~\".\") {\n+            if !str::eq(filename, ~\"..\") { full_paths += [p + filename]; }\n         }\n     }\n     ret full_paths;"}, {"sha": "169548d106a3e02c66096d36bbcb10962041d751", "filename": "src/lib/generic_os.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgeneric_os.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,27 +1,27 @@\n-import istr::sbuf;\n+import str::sbuf;\n \n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n fn getenv(n: &istr) -> option::t<istr> {\n-    let s = istr::as_buf(n, { |buf|\n+    let s = str::as_buf(n, { |buf|\n         os::libc::getenv(buf)\n     });\n     ret if unsafe::reinterpret_cast(s) == 0 {\n         option::none::<istr>\n     } else {\n         let s = unsafe::reinterpret_cast(s);\n-        option::some::<istr>(istr::str_from_cstr(s))\n+        option::some::<istr>(str::str_from_cstr(s))\n     };\n }\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n fn setenv(n: &istr, v: &istr) {\n     // FIXME (868)\n-    let _: () = istr::as_buf(n, { |nbuf|\n+    let _: () = str::as_buf(n, { |nbuf|\n         // FIXME (868)\n-        let _: () = istr::as_buf(v, { |vbuf|\n+        let _: () = str::as_buf(v, { |vbuf|\n             os::libc::setenv(nbuf, vbuf, 1);\n         });\n     });\n@@ -33,15 +33,15 @@ fn getenv(n: &istr) -> option::t<istr> {\n     while true {\n         let v: [u8] = [];\n         vec::reserve(v, nsize);\n-        let res = istr::as_buf(n, { |nbuf|\n+        let res = str::as_buf(n, { |nbuf|\n             let vbuf = vec::to_ptr(v);\n             os::kernel32::GetEnvironmentVariableA(nbuf, vbuf, nsize)\n         });\n         if res == 0u {\n             ret option::none;\n         } else if res < nsize {\n             vec::unsafe::set_len(v, res);\n-            ret option::some(istr::unsafe_from_bytes(v));\n+            ret option::some(str::unsafe_from_bytes(v));\n         } else { nsize = res; }\n     }\n     fail;\n@@ -50,8 +50,8 @@ fn getenv(n: &istr) -> option::t<istr> {\n #[cfg(target_os = \"win32\")]\n fn setenv(n: &istr, v: &istr) {\n     // FIXME (868)\n-    let _: () = istr::as_buf(n, { |nbuf|\n-        let _: () = istr::as_buf(v, { |vbuf|\n+    let _: () = str::as_buf(n, { |nbuf|\n+        let _: () = str::as_buf(v, { |vbuf|\n             os::kernel32::SetEnvironmentVariableA(nbuf, vbuf);\n         });\n     });"}, {"sha": "3df282206510e13cd15b526902fe3fb70de3d4bb", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -38,8 +38,8 @@ tag occur { req; optional; multi; }\n type opt = {name: name, hasarg: hasarg, occur: occur};\n \n fn mkname(nm: &istr) -> name {\n-    ret if istr::char_len(nm) == 1u {\n-            short(istr::char_at(nm, 0u))\n+    ret if str::char_len(nm) == 1u {\n+            short(str::char_at(nm, 0u))\n         } else { long(nm) };\n }\n \n@@ -68,11 +68,11 @@ tag optval { val(istr); given; }\n type match = {opts: [opt], vals: [mutable [optval]], free: [istr]};\n \n fn is_arg(arg: &istr) -> bool {\n-    ret istr::byte_len(arg) > 1u && arg[0] == '-' as u8;\n+    ret str::byte_len(arg) > 1u && arg[0] == '-' as u8;\n }\n \n fn name_str(nm: &name) -> istr {\n-    ret alt nm { short(ch) { istr::from_char(ch) } long(s) { s } };\n+    ret alt nm { short(ch) { str::from_char(ch) } long(s) { s } };\n }\n \n fn find_opt(opts: &[opt], nm: &name) -> option::t<uint> {\n@@ -117,33 +117,33 @@ fn getopts(args: &[istr], opts: &[opt]) -> result {\n     let i = 0u;\n     while i < l {\n         let cur = args[i];\n-        let curlen = istr::byte_len(cur);\n+        let curlen = str::byte_len(cur);\n         if !is_arg(cur) {\n             free += [cur];\n-        } else if istr::eq(cur, ~\"--\") {\n+        } else if str::eq(cur, ~\"--\") {\n             let j = i + 1u;\n             while j < l { free += [args[j]]; j += 1u; }\n             break;\n         } else {\n             let names;\n             let i_arg = option::none::<istr>;\n             if cur[1] == '-' as u8 {\n-                let tail = istr::slice(cur, 2u, curlen);\n-                let eq = istr::index(tail, '=' as u8);\n+                let tail = str::slice(cur, 2u, curlen);\n+                let eq = str::index(tail, '=' as u8);\n                 if eq == -1 {\n                     names = [long(tail)];\n                 } else {\n-                    names = [long(istr::slice(tail, 0u, eq as uint))];\n+                    names = [long(str::slice(tail, 0u, eq as uint))];\n                     i_arg =\n-                        option::some::<istr>(istr::slice(tail,\n+                        option::some::<istr>(str::slice(tail,\n                                                         (eq as uint) + 1u,\n                                                         curlen - 2u));\n                 }\n             } else {\n                 let j = 1u;\n                 names = [];\n                 while j < curlen {\n-                    let range = istr::char_range_at(cur, j);\n+                    let range = str::char_range_at(cur, j);\n                     names += [short(range.ch)];\n                     j = range.next;\n                 }"}, {"sha": "57ebb806f52e06505fb330708ebe240aedf6ad8e", "filename": "src/lib/io.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -88,7 +88,7 @@ obj new_reader(rdr: buf_reader) {\n \n         }\n         let b0 = c0 as u8;\n-        let w = istr::utf8_char_width(b0);\n+        let w = str::utf8_char_width(b0);\n         assert (w > 0u);\n         if w == 1u { ret b0 as char; }\n         let val = 0u;\n@@ -117,7 +117,7 @@ obj new_reader(rdr: buf_reader) {\n                 go_on = false;\n             } else { buf += [ch as u8]; }\n         }\n-        ret istr::unsafe_from_bytes(buf);\n+        ret str::unsafe_from_bytes(buf);\n     }\n     fn read_c_str() -> istr {\n         let buf: [u8] = [];\n@@ -126,7 +126,7 @@ obj new_reader(rdr: buf_reader) {\n             let ch = rdr.read_byte();\n             if ch < 1 { go_on = false; } else { buf += [ch as u8]; }\n         }\n-        ret istr::unsafe_from_bytes(buf);\n+        ret str::unsafe_from_bytes(buf);\n     }\n \n     // FIXME deal with eof?\n@@ -175,8 +175,8 @@ fn stdin() -> reader {\n }\n \n fn file_reader(path: &istr) -> reader {\n-    let f = istr::as_buf(path, { |pathbuf|\n-        istr::as_buf(~\"r\", { |modebuf|\n+    let f = str::as_buf(path, { |pathbuf|\n+        str::as_buf(~\"r\", { |modebuf|\n             os::libc::fopen(pathbuf, modebuf)\n         })\n     });\n@@ -220,7 +220,7 @@ fn new_byte_buf_reader(buf: &[u8]) -> buf_reader {\n }\n \n fn string_reader(s: &istr) -> reader {\n-    ret new_reader(new_byte_buf_reader(istr::bytes(s)));\n+    ret new_reader(new_byte_buf_reader(str::bytes(s)));\n }\n \n \n@@ -290,7 +290,7 @@ fn file_buf_writer(path: &istr, flags: &[fileflag]) -> buf_writer {\n           none. { }\n         }\n     }\n-    let fd = istr::as_buf(path, { |pathbuf|\n+    let fd = str::as_buf(path, { |pathbuf|\n         os::libc::open(pathbuf, fflags,\n                        os::libc_constants::S_IRUSR() |\n                            os::libc_constants::S_IWUSR())\n@@ -334,19 +334,19 @@ fn uint_to_be_bytes(n: uint, size: uint) -> [u8] {\n \n obj new_writer(out: buf_writer) {\n     fn get_buf_writer() -> buf_writer { ret out; }\n-    fn write_str(s: &istr) { out.write(istr::bytes(s)); }\n+    fn write_str(s: &istr) { out.write(str::bytes(s)); }\n     fn write_line(s: &istr) {\n-        out.write(istr::bytes(s));\n-        out.write(istr::bytes(~\"\\n\"));\n+        out.write(str::bytes(s));\n+        out.write(str::bytes(~\"\\n\"));\n     }\n     fn write_char(ch: char) {\n         // FIXME needlessly consy\n \n-        out.write(istr::bytes(istr::from_char(ch)));\n+        out.write(str::bytes(str::from_char(ch)));\n     }\n-    fn write_int(n: int) { out.write(istr::bytes(\n+    fn write_int(n: int) { out.write(str::bytes(\n         int::to_str(n, 10u))); }\n-    fn write_uint(n: uint) { out.write(istr::bytes(\n+    fn write_uint(n: uint) { out.write(str::bytes(\n         uint::to_str(n, 10u))); }\n     fn write_bytes(bytes: &[u8]) { out.write(bytes); }\n     fn write_le_uint(n: uint, size: uint) {\n@@ -367,8 +367,8 @@ fn file_writer(path: &istr, flags: &[fileflag]) -> writer {\n \n // FIXME: fileflags\n fn buffered_file_buf_writer(path: &istr) -> buf_writer {\n-    let f = istr::as_buf(path, { |pathbuf|\n-        istr::as_buf(~\"w\", { |modebuf|\n+    let f = str::as_buf(path, { |pathbuf|\n+        str::as_buf(~\"w\", { |modebuf|\n             os::libc::fopen(pathbuf, modebuf)\n         })\n     });\n@@ -427,7 +427,7 @@ fn string_writer() -> str_writer {\n     let buf: mutable_byte_buf = @{mutable buf: b, mutable pos: 0u};\n     obj str_writer_wrap(wr: writer, buf: mutable_byte_buf) {\n         fn get_writer() -> writer { ret wr; }\n-        fn get_str() -> istr { ret istr::unsafe_from_bytes(buf.buf); }\n+        fn get_str() -> istr { ret str::unsafe_from_bytes(buf.buf); }\n     }\n     ret str_writer_wrap(new_writer(byte_buf_writer(buf)), buf);\n }\n@@ -448,7 +448,7 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n }\n \n fn read_whole_file_str(file: &istr) -> istr {\n-    istr::unsafe_from_bytes(read_whole_file(file))\n+    str::unsafe_from_bytes(read_whole_file(file))\n }\n \n fn read_whole_file(file: &istr) -> [u8] {"}, {"sha": "0081aa18265943dec49d5aa44d3403a548d365ff", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -7,25 +7,25 @@ native \"cdecl\" mod libc = \"\" {\n     fn write(fd: int, buf: *u8, count: uint) -> int;\n     fn fread(buf: *u8, size: uint, n: uint, f: libc::FILE) -> uint;\n     fn fwrite(buf: *u8, size: uint, n: uint, f: libc::FILE) -> uint;\n-    fn open(s: istr::sbuf, flags: int, mode: uint) -> int;\n+    fn open(s: str::sbuf, flags: int, mode: uint) -> int;\n     fn close(fd: int) -> int;\n     type FILE;\n-    fn fopen(path: istr::sbuf, mode: istr::sbuf) -> FILE;\n-    fn fdopen(fd: int, mode: istr::sbuf) -> FILE;\n+    fn fopen(path: str::sbuf, mode: str::sbuf) -> FILE;\n+    fn fdopen(fd: int, mode: str::sbuf) -> FILE;\n     fn fclose(f: FILE);\n     fn fgetc(f: FILE) -> int;\n     fn ungetc(c: int, f: FILE);\n     fn feof(f: FILE) -> int;\n     fn fseek(f: FILE, offset: int, whence: int) -> int;\n     fn ftell(f: FILE) -> int;\n     type dir;\n-    fn opendir(d: istr::sbuf) -> dir;\n+    fn opendir(d: str::sbuf) -> dir;\n     fn closedir(d: dir) -> int;\n     type dirent;\n     fn readdir(d: dir) -> dirent;\n-    fn getenv(n: istr::sbuf) -> istr::sbuf;\n-    fn setenv(n: istr::sbuf, v: istr::sbuf, overwrite: int) -> int;\n-    fn unsetenv(n: istr::sbuf) -> int;\n+    fn getenv(n: str::sbuf) -> str::sbuf;\n+    fn setenv(n: str::sbuf, v: str::sbuf, overwrite: int) -> int;\n+    fn unsetenv(n: str::sbuf) -> int;\n     fn pipe(buf: *mutable int) -> int;\n     fn waitpid(pid: int, status: &mutable int, options: int) -> int;\n }\n@@ -63,7 +63,7 @@ fn pipe() -> {in: int, out: int} {\n }\n \n fn fd_FILE(fd: int) -> libc::FILE {\n-    ret istr::as_buf(~\"r\", { |modebuf|\n+    ret str::as_buf(~\"r\", { |modebuf|\n         libc::fdopen(fd, modebuf)\n     });\n }"}, {"sha": "2c244048113e470436b3bf7a7951d29a25f89655", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -4,25 +4,25 @@ native \"cdecl\" mod libc = \"\" {\n     fn write(fd: int, buf: *u8, count: uint) -> int;\n     fn fread(buf: *u8, size: uint, n: uint, f: libc::FILE) -> uint;\n     fn fwrite(buf: *u8, size: uint, n: uint, f: libc::FILE) -> uint;\n-    fn open(s: istr::sbuf, flags: int, mode: uint) -> int;\n+    fn open(s: str::sbuf, flags: int, mode: uint) -> int;\n     fn close(fd: int) -> int;\n     type FILE;\n-    fn fopen(path: istr::sbuf, mode: istr::sbuf) -> FILE;\n-    fn fdopen(fd: int, mode: istr::sbuf) -> FILE;\n+    fn fopen(path: str::sbuf, mode: str::sbuf) -> FILE;\n+    fn fdopen(fd: int, mode: str::sbuf) -> FILE;\n     fn fclose(f: FILE);\n     fn fgetc(f: FILE) -> int;\n     fn ungetc(c: int, f: FILE);\n     fn feof(f: FILE) -> int;\n     fn fseek(f: FILE, offset: int, whence: int) -> int;\n     fn ftell(f: FILE) -> int;\n     type dir;\n-    fn opendir(d: istr::sbuf) -> dir;\n+    fn opendir(d: str::sbuf) -> dir;\n     fn closedir(d: dir) -> int;\n     type dirent;\n     fn readdir(d: dir) -> dirent;\n-    fn getenv(n: istr::sbuf) -> istr::sbuf;\n-    fn setenv(n: istr::sbuf, v: istr::sbuf, overwrite: int) -> int;\n-    fn unsetenv(n: istr::sbuf) -> int;\n+    fn getenv(n: str::sbuf) -> str::sbuf;\n+    fn setenv(n: str::sbuf, v: str::sbuf, overwrite: int) -> int;\n+    fn unsetenv(n: str::sbuf) -> int;\n     fn pipe(buf: *mutable int) -> int;\n     fn waitpid(pid: int, status: &mutable int, options: int) -> int;\n }\n@@ -60,7 +60,7 @@ fn pipe() -> {in: int, out: int} {\n }\n \n fn fd_FILE(fd: int) -> libc::FILE {\n-    ret istr::as_buf(~\"r\", { |modebuf|\n+    ret str::as_buf(~\"r\", { |modebuf|\n         libc::fdopen(fd, modebuf)\n     });\n }"}, {"sha": "a608e7b877be90e52a071f96bdcd7ee90fcc81a8", "filename": "src/lib/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -195,7 +195,7 @@ fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n // Hash map constructors for basic types\n \n fn new_str_hash<@V>() -> hashmap<istr, V> {\n-    ret mk_hashmap(istr::hash, istr::eq);\n+    ret mk_hashmap(str::hash, str::eq);\n }\n \n fn new_int_hash<@V>() -> hashmap<int, V> {"}, {"sha": "e7d8d13df2bc24d89ba135d9abee60324a312098", "filename": "src/lib/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fnet.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -15,7 +15,7 @@ fn format_addr(ip: ip_addr) -> istr {\n fn parse_addr(ip: &istr) -> ip_addr {\n     let parts = vec::map(\n         { |&s| uint::from_str(s) },\n-        istr::split(ip, ~\".\"[0]));\n+        str::split(ip, ~\".\"[0]));\n     if vec::len(parts) != 4u { fail \"Too many dots in IP address\"; }\n     for i in parts { if i > 255u { fail \"Invalid IP Address part.\"; } }\n     ipv4(parts[0] as u8, parts[1] as u8, parts[2] as u8, parts[3] as u8)"}, {"sha": "2aebc49619bf763df7d4c66727321a101b68baf0", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -31,7 +31,7 @@ fn list_dir(path: &istr) -> [istr] {\n \n }\n \n-fn path_is_absolute(p: &istr) -> bool { ret istr::char_at(p, 0u) == '/'; }\n+fn path_is_absolute(p: &istr) -> bool { ret str::char_at(p, 0u) == '/'; }\n \n const path_sep: char = '/';\n "}, {"sha": "3558da2388a408cb8f2b8e38d0292cfdfd4db22d", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,5 +1,5 @@\n \n-import istr::sbuf;\n+import str::sbuf;\n \n export program;\n export run_program;\n@@ -13,9 +13,9 @@ native \"rust\" mod rustrt {\n }\n \n fn arg_vec(prog: &istr, args: &[@istr]) -> [sbuf] {\n-    let argptrs = istr::as_buf(prog, { |buf| [buf] });\n+    let argptrs = str::as_buf(prog, { |buf| [buf] });\n     for arg in args {\n-        argptrs += istr::as_buf(*arg, { |buf| [buf] });\n+        argptrs += str::as_buf(*arg, { |buf| [buf] });\n     }\n     argptrs += [unsafe::reinterpret_cast(0)];\n     ret argptrs;\n@@ -106,7 +106,7 @@ fn read_all(rd: &io::reader) -> istr {\n     let buf = ~\"\";\n     while !rd.eof() {\n         let bytes = rd.read_bytes(4096u);\n-        buf += istr::unsafe_from_bytes(bytes);\n+        buf += str::unsafe_from_bytes(bytes);\n     }\n     ret buf;\n }"}, {"sha": "b1c1a2ac22989492a8911625e6de8cc676e78c72", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -215,7 +215,7 @@ fn mk_sha1() -> sha1 {\n             st.computed = false;\n         }\n         fn input(msg: &[u8]) { add_input(st, msg); }\n-        fn input_str(msg: &istr) { add_input(st, istr::bytes(msg)); }\n+        fn input_str(msg: &istr) { add_input(st, str::bytes(msg)); }\n         fn result() -> [u8] { ret mk_result(st); }\n         fn result_str() -> istr {\n             let r = mk_result(st);"}, {"sha": "3f3832f05b463e71535b1c6104e6a8c62efb49b8", "filename": "src/lib/std.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -15,7 +15,7 @@ mod uint;\n mod u8;\n mod u64;\n mod vec;\n-mod istr;\n+mod str;\n \n // General io and system-services modules.\n "}, {"sha": "662d0d0c2285aa21e0f359d30187e4692556a741", "filename": "src/lib/str.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "previous_filename": "src/lib/istr.rs"}, {"sha": "f5189c49a432da5baaab25e3a3c5856482625c27", "filename": "src/lib/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fterm.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -52,7 +52,7 @@ fn color_supported() -> bool {\n     ret alt generic_os::getenv(~\"TERM\") {\n           option::some(env) {\n             for term: istr in supported_terms {\n-                if istr::eq(term, env) { ret true; }\n+                if str::eq(term, env) { ret true; }\n             }\n             false\n           }"}, {"sha": "77936e2b572adba32899f1a9577ce5eb32948d25", "filename": "src/lib/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -265,7 +265,7 @@ fn filter_tests(opts: &test_opts, tests: &[test_desc]) -> [test_desc] {\n             let filter =\n                 bind fn (test: &test_desc, filter_str: &istr) ->\n                         option::t<test_desc> {\n-                         if istr::find(test.name, filter_str) >= 0 {\n+                         if str::find(test.name, filter_str) >= 0 {\n                              ret option::some(test);\n                          } else { ret option::none; }\n                      }(_, filter_str);\n@@ -296,7 +296,7 @@ fn filter_tests(opts: &test_opts, tests: &[test_desc]) -> [test_desc] {\n     filtered =\n         {\n             fn lteq(t1: &test_desc, t2: &test_desc) -> bool {\n-                istr::lteq(t1.name, t2.name)\n+                str::lteq(t1.name, t2.name)\n             }\n             sort::merge_sort(lteq, filtered)\n         };"}, {"sha": "e7f85074ef2f47f7db98244b3ca6c47402184c4d", "filename": "src/lib/uint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -56,7 +56,7 @@ fn parse_buf(buf: &[u8], radix: uint) -> uint {\n     fail;\n }\n \n-fn from_str(s: &istr) -> uint { parse_buf(istr::bytes(s), 10u) }\n+fn from_str(s: &istr) -> uint { parse_buf(str::bytes(s), 10u) }\n \n fn to_str(num: uint, radix: uint) -> istr {\n     let n = num;\n@@ -85,12 +85,12 @@ fn to_str(num: uint, radix: uint) -> istr {\n     if n == 0u { ret ~\"0\"; }\n     let s: istr = ~\"\";\n     while n != 0u {\n-        s += istr::unsafe_from_byte(digit(n % radix) as u8);\n+        s += str::unsafe_from_byte(digit(n % radix) as u8);\n         n /= radix;\n     }\n     let s1: istr = ~\"\";\n-    let len: uint = istr::byte_len(s);\n-    while len != 0u { len -= 1u; s1 += istr::unsafe_from_byte(s[len]); }\n+    let len: uint = str::byte_len(s);\n+    while len != 0u { len -= 1u; s1 += str::unsafe_from_byte(s[len]); }\n     ret s1;\n }\n fn str(i: uint) -> istr { ret to_str(i, 10u); }"}, {"sha": "3633a014ca434846f6cb575c75197690211021c1", "filename": "src/lib/win32_fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fwin32_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fwin32_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_fs.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -11,8 +11,8 @@ fn list_dir(path: &istr) -> [istr] {\n }\n \n fn path_is_absolute(p: &istr) -> bool {\n-    ret istr::char_at(p, 0u) == '/' ||\n-            istr::char_at(p, 1u) == ':' && istr::char_at(p, 2u) == '\\\\';\n+    ret str::char_at(p, 0u) == '/' ||\n+            str::char_at(p, 1u) == ':' && str::char_at(p, 2u) == '\\\\';\n }\n \n /* FIXME: win32 path handling actually accepts '/' or '\\' and has subtly"}, {"sha": "9dccbcc679db8a7da9d8024d6c2e505962572444", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -4,11 +4,11 @@ native \"cdecl\" mod libc = \"\" {\n     fn write(fd: int, buf: *u8, count: uint) -> int;\n     fn fread(buf: *u8, size: uint, n: uint, f: libc::FILE) -> uint;\n     fn fwrite(buf: *u8, size: uint, n: uint, f: libc::FILE) -> uint;\n-    fn open(s: istr::sbuf, flags: int, mode: uint) -> int = \"_open\";\n+    fn open(s: str::sbuf, flags: int, mode: uint) -> int = \"_open\";\n     fn close(fd: int) -> int = \"_close\";\n     type FILE;\n-    fn fopen(path: istr::sbuf, mode: istr::sbuf) -> FILE;\n-    fn _fdopen(fd: int, mode: istr::sbuf) -> FILE;\n+    fn fopen(path: str::sbuf, mode: str::sbuf) -> FILE;\n+    fn _fdopen(fd: int, mode: str::sbuf) -> FILE;\n     fn fclose(f: FILE);\n     fn fgetc(f: FILE) -> int;\n     fn ungetc(c: int, f: FILE);\n@@ -40,9 +40,9 @@ mod libc_constants {\n }\n \n native \"x86stdcall\" mod kernel32 {\n-    fn GetEnvironmentVariableA(n: istr::sbuf, v: istr::sbuf,\n+    fn GetEnvironmentVariableA(n: str::sbuf, v: str::sbuf,\n                                nsize: uint) -> uint;\n-    fn SetEnvironmentVariableA(n: istr::sbuf, v: istr::sbuf) -> int;\n+    fn SetEnvironmentVariableA(n: str::sbuf, v: str::sbuf) -> int;\n }\n \n fn exec_suffix() -> istr { ret ~\".exe\"; }\n@@ -69,7 +69,7 @@ fn pipe() -> {in: int, out: int} {\n }\n \n fn fd_FILE(fd: int) -> libc::FILE {\n-    ret istr::as_buf(~\"r\", { |modebuf|\n+    ret str::as_buf(~\"r\", { |modebuf|\n         libc::_fdopen(fd, modebuf)\n     });\n }"}, {"sha": "fea1420f8bb713e6ac4cb3bdbcf774b20a9c1e35", "filename": "src/test/bench/99bob-iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-iter.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -6,7 +6,7 @@\n  */\n use std;\n import std::int;\n-import std::istr;\n+import std::str;\n \n fn b1() -> istr { ret ~\"# of beer on the wall, # of beer.\"; }\n \n@@ -31,8 +31,8 @@ fn sub(t: &istr, n: int) -> istr {\n       1 { ns = ~\"1 bottle\"; }\n       _ { ns = int::to_str(n, 10u) + ~\" bottles\"; }\n     }\n-    while i < istr::byte_len(t) {\n-        if t[i] == '#' as u8 { b += ns; } else { istr::push_byte(b, t[i]); }\n+    while i < str::byte_len(t) {\n+        if t[i] == '#' as u8 { b += ns; } else { str::push_byte(b, t[i]); }\n         i += 1u;\n     }\n     ret b;"}, {"sha": "a13015fb4f77e9daf4ee5cd085e0064e33659c48", "filename": "src/test/bench/99bob-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2F99bob-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2F99bob-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-pattern.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -6,7 +6,7 @@\n  */\n use std;\n import std::int;\n-import std::istr;\n+import std::str;\n \n tag bottle { none; dual; single; multiple(int); }\n "}, {"sha": "30518c63e2dd20b8c766c4f7a1ba478618e64abe", "filename": "src/test/bench/99bob-simple.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-simple.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -6,7 +6,7 @@\n  */\n use std;\n import std::int;\n-import std::istr;\n+import std::str;\n \n fn b1() -> istr { ret ~\"# of beer on the wall, # of beer.\"; }\n \n@@ -31,8 +31,8 @@ fn sub(t: &istr, n: int) -> istr {\n       1 { ns = ~\"1 bottle\"; }\n       _ { ns = int::to_str(n, 10u) + ~\" bottles\"; }\n     }\n-    while i < istr::byte_len(t) {\n-        if t[i] == '#' as u8 { b += ns; } else { istr::push_byte(b, t[i]); }\n+    while i < str::byte_len(t) {\n+        if t[i] == '#' as u8 { b += ns; } else { str::push_byte(b, t[i]); }\n         i += 1u;\n     }\n     ret b;"}, {"sha": "9ab8973cbceff83b7a2f0c484e4136ee04fb50f4", "filename": "src/test/bench/99bob-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2F99bob-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2F99bob-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-tail.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -4,7 +4,7 @@\n  */\n use std;\n import std::int;\n-import std::istr;\n+import std::str;\n \n fn main() {\n     fn multiple(n: int) {"}, {"sha": "cd29838b378ad5903219f864a8c399f8c03397bb", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -9,7 +9,7 @@ use std;\n import std::vec;\n import std::uint;\n import std::int;\n-import std::istr;\n+import std::str;\n \n fn LINE_LENGTH() -> uint { ret 60u; }\n \n@@ -49,21 +49,21 @@ fn make_random_fasta(id: &istr, desc: &istr,\n     let rng = myrandom(std::rand::mk_rng().next());\n     let op: istr = ~\"\";\n     for each i: uint in uint::range(0u, n as uint) {\n-        istr::push_byte(op, select_random(rng.next(100u32), genelist) as u8);\n-        if istr::byte_len(op) >= LINE_LENGTH() { log op; op = ~\"\"; }\n+        str::push_byte(op, select_random(rng.next(100u32), genelist) as u8);\n+        if str::byte_len(op) >= LINE_LENGTH() { log op; op = ~\"\"; }\n     }\n-    if istr::byte_len(op) > 0u { log op; }\n+    if str::byte_len(op) > 0u { log op; }\n }\n \n fn make_repeat_fasta(id: &istr, desc: &istr, s: &istr, n: int) {\n     log ~\">\" + id + ~\" \" + desc;\n     let op: istr = ~\"\";\n-    let sl: uint = istr::byte_len(s);\n+    let sl: uint = str::byte_len(s);\n     for each i: uint in uint::range(0u, n as uint) {\n-        istr::push_byte(op, s[i % sl]);\n-        if istr::byte_len(op) >= LINE_LENGTH() { log op; op = ~\"\"; }\n+        str::push_byte(op, s[i % sl]);\n+        if str::byte_len(op) >= LINE_LENGTH() { log op; op = ~\"\"; }\n     }\n-    if istr::byte_len(op) > 0u { log op; }\n+    if str::byte_len(op) > 0u { log op; }\n }\n \n fn acid(ch: char, prob: u32) -> aminoacids { ret {ch: ch, prob: prob}; }"}, {"sha": "b9fba948561b9b147c805d15550b0889cae305aa", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -14,7 +14,7 @@ use std;\n import std::vec;\n import std::uint;\n import std::time;\n-import std::istr;\n+import std::str;\n import std::int::range;\n import std::io;\n import std::getopts;\n@@ -91,7 +91,7 @@ fn main(argv: [istr]) {\n         if opts.stress {\n             stress(2);\n         } else {\n-            let max = uint::parse_buf(istr::bytes(argv[1]), 10u) as int;\n+            let max = uint::parse_buf(str::bytes(argv[1]), 10u) as int;\n \n             let num_trials = 10;\n "}, {"sha": "941f01830311015259b3fe16cb9394c21e6797f8", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -2,7 +2,7 @@ use std;\n import std::vec;\n import std::task;\n import std::uint;\n-import std::istr;\n+import std::str;\n \n fn f(n: uint) {\n     let i = 0u;\n@@ -17,7 +17,7 @@ fn main(args: [istr]) {\n     let n =\n         if vec::len(args) < 2u {\n             10u\n-        } else { uint::parse_buf(istr::bytes(args[1]), 10u) };\n+        } else { uint::parse_buf(str::bytes(args[1]), 10u) };\n     let i = 0u;\n     while i < n { task::spawn(bind f(n)); i += 1u; }\n }"}, {"sha": "fd650df660b5c95376d8e799536c3f727a2fff5e", "filename": "src/test/bench/task-perf-vector-party.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2Ftask-perf-vector-party.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2Ftask-perf-vector-party.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-vector-party.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -6,7 +6,7 @@\n use std;\n import std::vec;\n import std::uint;\n-import std::istr;\n+import std::str;\n import std::task;\n \n fn f(n: uint) {\n@@ -20,7 +20,7 @@ fn main(args: [istr]) {\n     let n = if vec::len(args) < 2u {\n         100u\n     } else {\n-        uint::parse_buf(istr::bytes(args[1]), 10u)\n+        uint::parse_buf(str::bytes(args[1]), 10u)\n     };\n     for each i in uint::range(0u, 100u) {\n         task::spawn(bind f(n));"}, {"sha": "5d01e725ed3b8214653401cbbfab4f983414864a", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -13,7 +13,7 @@ use std;\n import option = std::option::t;\n import std::option::some;\n import std::option::none;\n-import std::istr;\n+import std::str;\n import std::treemap;\n import std::vec;\n import std::io;\n@@ -30,11 +30,11 @@ import std::comm::recv;\n import std::comm::send;\n \n fn map(filename: &[u8], emit: &map_reduce::putter<[u8], int>) {\n-    let f = io::file_reader(istr::unsafe_from_bytes(filename));\n+    let f = io::file_reader(str::unsafe_from_bytes(filename));\n \n     while true {\n         alt read_word(f) {\n-          some(w) { emit(istr::bytes(w), 1); }\n+          some(w) { emit(str::bytes(w), 1); }\n           none. { break; }\n         }\n     }\n@@ -212,7 +212,7 @@ fn main(argv: [istr]) {\n \n     let iargs = [];\n     for a in vec::slice(argv, 1u, vec::len(argv)) {\n-        iargs += [istr::bytes(a)];\n+        iargs += [str::bytes(a)];\n     }\n \n     // We can get by with 8k stacks, and we'll probably exhaust our\n@@ -239,7 +239,7 @@ fn read_word(r: io::reader) -> option<istr> {\n \n \n         if is_word_char(c) {\n-            w += istr::from_char(c);\n+            w += str::from_char(c);\n         } else { if w != ~\"\" { ret some(w); } }\n     }\n     ret none;"}, {"sha": "e947d6bd1d9474104ce607d85b20f1e7be1685bd", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -13,7 +13,7 @@ use std;\n import option = std::option::t;\n import std::option::some;\n import std::option::none;\n-import std::istr;\n+import std::str;\n import std::map;\n import std::vec;\n import std::io;\n@@ -227,7 +227,7 @@ fn read_word(r: io::reader) -> option<istr> {\n \n \n         if is_word_char(c) {\n-            w += istr::from_char(c);\n+            w += str::from_char(c);\n         } else { if w != ~\"\" { ret some(w); } }\n     }\n     ret none;"}, {"sha": "dec1df5d4586ed1761bfc189a780a723c48cc451", "filename": "src/test/compile-fail/fn-constraint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,6 +1,6 @@\n // error-pattern:precondition constraint (for example, uint::le(a, b)\n use std;\n-import std::istr::*;\n+import std::str::*;\n \n fn main() {\n     let a: uint = 4u;"}, {"sha": "c01b20042fa39652a2c52542b89f54ee0e856819", "filename": "src/test/compile-fail/no-constraint-prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,6 +1,6 @@\n // error-pattern:Unsatisfied precondition constraint (for example, le(b, d\n use std;\n-import std::istr::*;\n+import std::str::*;\n import std::uint::*;\n \n fn main() {"}, {"sha": "704482749844c753c37acfd515f2a95a83fdcc3a", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -2,7 +2,7 @@ import std::option;\n import std::getopts;\n import std::test;\n import std::fs;\n-import std::istr;\n+import std::str;\n import std::vec;\n import std::task;\n \n@@ -164,11 +164,11 @@ fn is_test(config: &config, testfile: &istr) -> bool {\n     let valid = false;\n \n     for ext in valid_extensions {\n-        if istr::ends_with(name, ext) { valid = true }\n+        if str::ends_with(name, ext) { valid = true }\n     }\n \n     for pre in invalid_prefixes {\n-        if istr::starts_with(name, pre) { valid = false }\n+        if str::starts_with(name, pre) { valid = false }\n     }\n \n     ret valid;\n@@ -210,7 +210,7 @@ fn make_test_closure(testfile: &istr, configchan: chan<[u8]>) ->\n }\n \n fn send_config(testfile: istr, configchan: chan<[u8]>) {\n-    send(configchan, istr::bytes(testfile));\n+    send(configchan, str::bytes(testfile));\n }\n \n /*"}, {"sha": "5a4a0ea095bfa8246d3fc819387fe319246fbba6", "filename": "src/test/compiletest/header.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fheader.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,5 +1,5 @@\n import std::option;\n-import std::istr;\n+import std::str;\n import std::io;\n import std::fs;\n \n@@ -74,8 +74,8 @@ iter iter_header(testfile: &istr) -> istr {\n         // Assume that any directives will be found before the first\n         // module or function. This doesn't seem to be an optimization\n         // with a warm page cache. Maybe with a cold one.\n-        if istr::starts_with(ln, ~\"fn\")\n-            || istr::starts_with(ln, ~\"mod\") {\n+        if str::starts_with(ln, ~\"fn\")\n+            || str::starts_with(ln, ~\"mod\") {\n             break;\n         } else { put ln; }\n     }\n@@ -103,17 +103,17 @@ fn parse_pp_exact(line: &istr, testfile: &istr) -> option::t<istr> {\n }\n \n fn parse_name_directive(line: &istr, directive: &istr) -> bool {\n-    istr::find(line, directive) >= 0\n+    str::find(line, directive) >= 0\n }\n \n fn parse_name_value_directive(line: &istr,\n                               directive: &istr) -> option::t<istr> {\n     let keycolon = directive + ~\":\";\n-    if istr::find(line, keycolon) >= 0 {\n-        let colon = istr::find(line, keycolon) as uint;\n+    if str::find(line, keycolon) >= 0 {\n+        let colon = str::find(line, keycolon) as uint;\n         let value =\n-            istr::slice(line, colon + istr::byte_len(keycolon),\n-                       istr::byte_len(line));\n+            str::slice(line, colon + str::byte_len(keycolon),\n+                       str::byte_len(line));\n         log #ifmt(\"%s: %s\", directive,\n                   value);\n         option::some(value)"}, {"sha": "eb6d467671145bc7b8c61d2a965534e133e26dce", "filename": "src/test/compiletest/procsrv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fprocsrv.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -12,7 +12,7 @@ import std::vec;\n import std::os;\n import std::run;\n import std::io;\n-import std::istr;\n+import std::str;\n import std::comm::chan;\n import std::comm::port;\n import std::comm::send;\n@@ -58,7 +58,7 @@ fn run(handle: &handle, lib_path: &istr, prog: &istr, args: &[istr],\n     let p = port();\n     let ch = chan(p);\n     send(handle.chan,\n-         exec(istr::bytes(lib_path), istr::bytes(prog), clone_vecstr(args),\n+         exec(str::bytes(lib_path), str::bytes(prog), clone_vecstr(args),\n               ch));\n     let resp = recv(p);\n \n@@ -85,7 +85,7 @@ fn readclose(fd: int) -> istr {\n     let buf = ~\"\";\n     while !reader.eof() {\n         let bytes = reader.read_bytes(4096u);\n-        buf += istr::unsafe_from_bytes(bytes);\n+        buf += str::unsafe_from_bytes(bytes);\n     }\n     os::libc::fclose(file);\n     ret buf;\n@@ -114,8 +114,8 @@ fn worker(p: port<request>) {\n                 // the alt discriminant are wrong.\n                 alt recv(p) {\n                   exec(lib_path, prog, args, respchan) {\n-                    {lib_path: istr::unsafe_from_bytes(lib_path),\n-                     prog: istr::unsafe_from_bytes(prog),\n+                    {lib_path: str::unsafe_from_bytes(lib_path),\n+                     prog: str::unsafe_from_bytes(prog),\n                      args: clone_vecu8str(args),\n                      respchan: respchan}\n                   }\n@@ -174,14 +174,14 @@ fn export_lib_path(path: &istr) {\n \n fn clone_vecstr(v: &[istr]) -> [[u8]] {\n     let r = [];\n-    for t: istr in vec::slice(v, 0u, vec::len(v)) { r += [istr::bytes(t)]; }\n+    for t: istr in vec::slice(v, 0u, vec::len(v)) { r += [str::bytes(t)]; }\n     ret r;\n }\n \n fn clone_vecu8str(v: &[[u8]]) -> [istr] {\n     let r = [];\n     for t in vec::slice(v, 0u, vec::len(v)) {\n-        r += [istr::unsafe_from_bytes(t)];\n+        r += [str::unsafe_from_bytes(t)];\n     }\n     ret r;\n }"}, {"sha": "e8e5191968046b39799e61a8ccbbfdcf1cb1326c", "filename": "src/test/compiletest/runtest.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fruntest.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,5 +1,5 @@\n import std::io;\n-import std::istr;\n+import std::str;\n import std::option;\n import std::fs;\n import std::os;\n@@ -19,7 +19,7 @@ import util::logv;\n export run;\n \n fn run(cx: &cx, _testfile: -[u8]) {\n-    let testfile = istr::unsafe_from_bytes(_testfile);\n+    let testfile = str::unsafe_from_bytes(_testfile);\n     if cx.config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n         io::stdout().write_str(~\"\\n\\n\");\n@@ -116,9 +116,9 @@ fn run_pretty_test(cx: &cx, props: &test_props, testfile: &istr) {\n     if option::is_some(props.pp_exact) {\n         // Now we have to care about line endings\n         let cr = ~\"\\r\";\n-        check (istr::is_not_empty(cr));\n-        actual = istr::replace(actual, cr, ~\"\");\n-        expected = istr::replace(expected, cr, ~\"\");\n+        check (str::is_not_empty(cr));\n+        actual = str::replace(actual, cr, ~\"\");\n+        expected = str::replace(expected, cr, ~\"\");\n     }\n \n     compare_source(expected, actual);\n@@ -188,8 +188,8 @@ fn check_error_patterns(props: &test_props, testfile: &istr,\n \n     let next_err_idx = 0u;\n     let next_err_pat = props.error_patterns[next_err_idx];\n-    for line: istr in istr::split(procres.stdout, '\\n' as u8) {\n-        if istr::find(line, next_err_pat) > 0 {\n+    for line: istr in str::split(procres.stdout, '\\n' as u8) {\n+        if str::find(line, next_err_pat) > 0 {\n             log #ifmt[\"found error pattern %s\",\n                       next_err_pat];\n             next_err_idx += 1u;\n@@ -289,7 +289,7 @@ fn split_maybe_args(argstr: &option::t<istr>) -> [istr] {\n     }\n \n     alt argstr {\n-      option::some(s) { rm_whitespace(istr::split(s, ' ' as u8)) }\n+      option::some(s) { rm_whitespace(str::split(s, ' ' as u8)) }\n       option::none. { [] }\n     }\n }\n@@ -315,7 +315,7 @@ fn make_cmdline(libpath: &istr, prog: &istr, args: &[istr]) -> istr {\n     #ifmt[\"%s %s %s\",\n           lib_path_cmd_prefix(libpath),\n           prog,\n-          istr::connect(args, ~\" \")]\n+          str::connect(args, ~\" \")]\n }\n \n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n@@ -357,10 +357,10 @@ fn output_base_name(config: &config, testfile: &istr) -> istr {\n     let base = config.build_base;\n     let filename =\n         {\n-            let parts = istr::split(fs::basename(testfile),\n+            let parts = str::split(fs::basename(testfile),\n                                     '.' as u8);\n             parts = vec::slice(parts, 0u, vec::len(parts) - 1u);\n-            istr::connect(parts, ~\".\")\n+            str::connect(parts, ~\".\")\n         };\n     #ifmt[\"%s%s.%s\", base, filename,\n                         config.stage_id]"}, {"sha": "88320d29dc16eb21323c0b72d0173797889112e5", "filename": "src/test/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Futil.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,7 +1,7 @@\n import std::option;\n import std::generic_os::getenv;\n import std::io;\n-import std::istr;\n+import std::str;\n \n import common::config;\n "}, {"sha": "f55772d2def0e5a3c3fcc64777b778d5ac687e15", "filename": "src/test/run-fail/fn-constraint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffn-constraint.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,6 +1,6 @@\n // error-pattern:Predicate le(a, b) failed\n use std;\n-import std::istr::*;\n+import std::str::*;\n import std::uint::le;\n \n fn main() {"}, {"sha": "a8f4f976872245fbdf3510afa41bda0a810f032f", "filename": "src/test/run-pass/constraint-prop-expr-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::istr::*;\n+import std::str::*;\n import std::uint::*;\n \n fn main() {"}, {"sha": "b691fb75dbdd829302a05f77d9aa3cdaaeb95466", "filename": "src/test/run-pass/constraint-prop-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::istr::*;\n+import std::str::*;\n import std::uint::*;\n \n fn main() {"}, {"sha": "5814f095f664e9f3c0c50bd90a78208fb7f5d16a", "filename": "src/test/run-pass/constraint-prop-swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::istr::*;\n+import std::str::*;\n import std::uint::*;\n \n fn main() {"}, {"sha": "c0a5903f69cdb87727c1ef5ef41e624e9012d22f", "filename": "src/test/run-pass/constraint-prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::istr::*;\n+import std::str::*;\n import std::uint::*;\n \n fn main() {"}, {"sha": "5e2dac48eabe2723420738b5bbc6779a9c50f744", "filename": "src/test/run-pass/fn-constraint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-constraint.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::istr::*;\n+import std::str::*;\n import std::uint::*;\n \n fn main() {"}, {"sha": "81c827bfb22ee4e1ba9fa8674e774ea9fb206e8f", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -9,7 +9,7 @@ use std;\n import option = std::option::t;\n import std::option::some;\n import std::option::none;\n-import std::istr;\n+import std::str;\n import std::vec;\n import std::map;\n import std::task;\n@@ -50,7 +50,7 @@ mod map_reduce {\n               none. {\n                 let p = port();\n                 log_err \"sending find_reducer\";\n-                send(ctrl, find_reducer(istr::bytes(key), chan(p)));\n+                send(ctrl, find_reducer(str::bytes(key), chan(p)));\n                 log_err \"receiving\";\n                 c = recv(p);\n                 log_err c;\n@@ -82,7 +82,7 @@ mod map_reduce {\n               mapper_done. { num_mappers -= 1; }\n               find_reducer(k, cc) {\n                 let c;\n-                alt reducers.find(istr::unsafe_from_bytes(k)) {\n+                alt reducers.find(str::unsafe_from_bytes(k)) {\n                   some(_c) { c = _c; }\n                   none. { c = 0; }\n                 }"}, {"sha": "33ac76300a7a20a645ab55f86c1b98201e5794c6", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -6,13 +6,13 @@\n \n use std;\n \n-import std::istr;\n+import std::str;\n import std::comm;\n import std::task;\n \n type ctx = comm::chan<int>;\n \n-fn iotask(cx: ctx, ip: -istr) { assert (istr::eq(ip, ~\"localhost\")); }\n+fn iotask(cx: ctx, ip: -istr) { assert (str::eq(ip, ~\"localhost\")); }\n \n fn main() {\n     let p = comm::port::<int>();"}, {"sha": "5677f562a2f5858bf1b83223c4e100385b1454a0", "filename": "src/test/run-pass/str-append.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fstr-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fstr-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-append.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -2,7 +2,7 @@\n \n // -*- rust -*-\n use std;\n-import std::istr;\n+import std::str;\n \n fn test1() {\n     let s: istr = ~\"hello\";\n@@ -19,8 +19,8 @@ fn test2() {\n     let b: istr = ~\"ABC\" + ff + ~\"ABC\";\n     log a;\n     log b;\n-    assert (istr::eq(a, ~\"abcABCabc\"));\n-    assert (istr::eq(b, ~\"ABCabcABC\"));\n+    assert (str::eq(a, ~\"abcABCabc\"));\n+    assert (str::eq(b, ~\"ABCabcABC\"));\n }\n \n fn main() { test1(); test2(); }"}, {"sha": "3df1a7d926f8dc1d661198661272692c062328f4", "filename": "src/test/run-pass/str-multiline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fstr-multiline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fstr-multiline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-multiline.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -2,7 +2,7 @@\n \n // -*- rust -*-\n use std;\n-import std::istr;\n+import std::str;\n \n fn main() {\n     let a: istr = ~\"this \\\n@@ -12,6 +12,6 @@ is a test\";\n                is \\\n                another \\\n                test\";\n-    assert (istr::eq(a, ~\"this is a test\"));\n-    assert (istr::eq(b, ~\"this is another test\"));\n+    assert (str::eq(a, ~\"this is a test\"));\n+    assert (str::eq(b, ~\"this is another test\"));\n }"}, {"sha": "29bef1379bbff8c283a48821943bd348dcc9a3d4", "filename": "src/test/run-pass/string-self-append.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fstring-self-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fstring-self-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstring-self-append.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,14 +1,14 @@\n use std;\n-import std::istr;\n+import std::str;\n \n fn main() {\n     // Make sure we properly handle repeated self-appends.\n     let a: istr = ~\"A\";\n     let i = 20;\n     let expected_len = 1u;\n     while i > 0 {\n-        log_err istr::byte_len(a);\n-        assert (istr::byte_len(a) == expected_len);\n+        log_err str::byte_len(a);\n+        assert (str::byte_len(a) == expected_len);\n         a += a;\n         i -= 1;\n         expected_len *= 2u;"}, {"sha": "3ac83d281737cca155f43893bbb3fabb70ef3e8c", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,10 +1,10 @@\n use std;\n-import std::istr;\n+import std::str;\n \n fn test(actual: &istr, expected: &istr) {\n     log actual;\n     log expected;\n-    assert (istr::eq(actual, expected));\n+    assert (str::eq(actual, expected));\n }\n \n fn main() {"}, {"sha": "4b292d1ba867716b62d243cb599a3f896c6722a2", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,31 +1,31 @@\n use std;\n-import std::istr;\n+import std::str;\n import std::vec;\n \n fn main() {\n     // Chars of 1, 2, 3, and 4 bytes\n     let chs: [char] = ['e', '\u00e9', '\u20ac', 0x10000 as char];\n-    let s: istr = istr::from_chars(chs);\n+    let s: istr = str::from_chars(chs);\n \n-    assert (istr::byte_len(s) == 10u);\n-    assert (istr::char_len(s) == 4u);\n-    assert (vec::len::<char>(istr::to_chars(s)) == 4u);\n-    assert (istr::eq(istr::from_chars(istr::to_chars(s)), s));\n-    assert (istr::char_at(s, 0u) == 'e');\n-    assert (istr::char_at(s, 1u) == '\u00e9');\n+    assert (str::byte_len(s) == 10u);\n+    assert (str::char_len(s) == 4u);\n+    assert (vec::len::<char>(str::to_chars(s)) == 4u);\n+    assert (str::eq(str::from_chars(str::to_chars(s)), s));\n+    assert (str::char_at(s, 0u) == 'e');\n+    assert (str::char_at(s, 1u) == '\u00e9');\n \n-    assert (istr::is_utf8(istr::bytes(s)));\n-    assert (!istr::is_utf8([0x80_u8]));\n-    assert (!istr::is_utf8([0xc0_u8]));\n-    assert (!istr::is_utf8([0xc0_u8, 0x10_u8]));\n+    assert (str::is_utf8(str::bytes(s)));\n+    assert (!str::is_utf8([0x80_u8]));\n+    assert (!str::is_utf8([0xc0_u8]));\n+    assert (!str::is_utf8([0xc0_u8, 0x10_u8]));\n \n     let stack = ~\"a\u00d7c\u20ac\";\n-    assert (istr::pop_char(stack) == '\u20ac');\n-    assert (istr::pop_char(stack) == 'c');\n-    istr::push_char(stack, 'u');\n-    assert (istr::eq(stack, ~\"a\u00d7u\"));\n-    assert (istr::shift_char(stack) == 'a');\n-    assert (istr::shift_char(stack) == '\u00d7');\n-    istr::unshift_char(stack, '\u00df');\n-    assert (istr::eq(stack, ~\"\u00dfu\"));\n+    assert (str::pop_char(stack) == '\u20ac');\n+    assert (str::pop_char(stack) == 'c');\n+    str::push_char(stack, 'u');\n+    assert (str::eq(stack, ~\"a\u00d7u\"));\n+    assert (str::shift_char(stack) == 'a');\n+    assert (str::shift_char(stack) == '\u00d7');\n+    str::unshift_char(stack, '\u00df');\n+    assert (str::eq(stack, ~\"\u00dfu\"));\n }"}, {"sha": "bc13e248d0bd749b5ad19e5ce3616eba29d8f600", "filename": "src/test/stdtest/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fstdtest%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fstdtest%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fint.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,7 +1,7 @@\n \n use std;\n import std::int;\n-import std::istr::eq;\n+import std::str::eq;\n \n #[test]\n fn test_to_str() {"}, {"sha": "a66b3bab4641dcc852f2fe18d17e4e30327c96e6", "filename": "src/test/stdtest/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fstdtest%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fstdtest%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fio.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,7 +1,7 @@\n // -*- rust -*-\n use std;\n import std::io;\n-import std::istr;\n+import std::str;\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"win32\")]\n@@ -19,7 +19,7 @@ fn test_simple() {\n     let inp: io::reader = io::file_reader(tmpfile);\n     let frood2: istr = inp.read_c_str();\n     log frood2;\n-    assert (istr::eq(frood, frood2));\n+    assert (str::eq(frood, frood2));\n }\n \n // FIXME (726)"}, {"sha": "585bae03cc95f9344e4c37133eb327b9766099e7", "filename": "src/test/stdtest/map.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fstdtest%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fstdtest%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fmap.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -3,7 +3,7 @@\n // -*- rust -*-\n use std;\n import std::map;\n-import std::istr;\n+import std::str;\n import std::uint;\n import std::util;\n import std::option;\n@@ -14,8 +14,8 @@ fn test_simple() {\n     fn eq_uint(x: &uint, y: &uint) -> bool { ret x == y; }\n     let hasher_uint: map::hashfn<uint> = util::id;\n     let eqer_uint: map::eqfn<uint> = eq_uint;\n-    let hasher_str: map::hashfn<istr> = istr::hash;\n-    let eqer_str: map::eqfn<istr> = istr::eq;\n+    let hasher_str: map::hashfn<istr> = str::hash;\n+    let eqer_str: map::eqfn<istr> = str::eq;\n     log \"uint -> uint\";\n     let hm_uu: map::hashmap<uint, uint> =\n         map::mk_hashmap::<uint, uint>(hasher_uint, eqer_uint);\n@@ -52,26 +52,26 @@ fn test_simple() {\n     assert (hm_us.insert(10u, ~\"twelve\"));\n     assert (hm_us.insert(11u, ~\"thirteen\"));\n     assert (hm_us.insert(12u, ~\"fourteen\"));\n-    assert (istr::eq(hm_us.get(11u), ~\"thirteen\"));\n-    assert (istr::eq(hm_us.get(12u), ~\"fourteen\"));\n-    assert (istr::eq(hm_us.get(10u), ~\"twelve\"));\n+    assert (str::eq(hm_us.get(11u), ~\"thirteen\"));\n+    assert (str::eq(hm_us.get(12u), ~\"fourteen\"));\n+    assert (str::eq(hm_us.get(10u), ~\"twelve\"));\n     assert (!hm_us.insert(12u, ~\"fourteen\"));\n-    assert (istr::eq(hm_us.get(12u), ~\"fourteen\"));\n+    assert (str::eq(hm_us.get(12u), ~\"fourteen\"));\n     assert (!hm_us.insert(12u, ~\"twelve\"));\n-    assert (istr::eq(hm_us.get(12u), ~\"twelve\"));\n+    assert (str::eq(hm_us.get(12u), ~\"twelve\"));\n     log \"str -> str\";\n     let hm_ss: map::hashmap<istr, istr> =\n         map::mk_hashmap::<istr, istr>(hasher_str, eqer_str);\n     assert (hm_ss.insert(ten, ~\"twelve\"));\n     assert (hm_ss.insert(eleven, ~\"thirteen\"));\n     assert (hm_ss.insert(twelve, ~\"fourteen\"));\n-    assert (istr::eq(hm_ss.get(~\"eleven\"), ~\"thirteen\"));\n-    assert (istr::eq(hm_ss.get(~\"twelve\"), ~\"fourteen\"));\n-    assert (istr::eq(hm_ss.get(~\"ten\"), ~\"twelve\"));\n+    assert (str::eq(hm_ss.get(~\"eleven\"), ~\"thirteen\"));\n+    assert (str::eq(hm_ss.get(~\"twelve\"), ~\"fourteen\"));\n+    assert (str::eq(hm_ss.get(~\"ten\"), ~\"twelve\"));\n     assert (!hm_ss.insert(~\"twelve\", ~\"fourteen\"));\n-    assert (istr::eq(hm_ss.get(~\"twelve\"), ~\"fourteen\"));\n+    assert (str::eq(hm_ss.get(~\"twelve\"), ~\"fourteen\"));\n     assert (!hm_ss.insert(~\"twelve\", ~\"twelve\"));\n-    assert (istr::eq(hm_ss.get(~\"twelve\"), ~\"twelve\"));\n+    assert (str::eq(hm_ss.get(~\"twelve\"), ~\"twelve\"));\n     log \"*** finished test_simple\";\n }\n \n@@ -116,8 +116,8 @@ fn test_growth() {\n         i += 1u;\n     }\n     log \"str -> str\";\n-    let hasher_str: map::hashfn<istr> = istr::hash;\n-    let eqer_str: map::eqfn<istr> = istr::eq;\n+    let hasher_str: map::hashfn<istr> = str::hash;\n+    let eqer_str: map::eqfn<istr> = str::eq;\n     let hm_ss: map::hashmap<istr, istr> =\n         map::mk_hashmap::<istr, istr>(hasher_str, eqer_str);\n     i = 0u;\n@@ -133,13 +133,13 @@ fn test_growth() {\n     while i < num_to_insert {\n         log ~\"get(\\\"\" + uint::to_str(i, 2u) + ~\"\\\") = \\\"\" +\n                 hm_ss.get(uint::to_str(i, 2u)) + ~\"\\\"\";\n-        assert (istr::eq(hm_ss.get(uint::to_str(i, 2u)),\n+        assert (str::eq(hm_ss.get(uint::to_str(i, 2u)),\n                         uint::to_str(i * i, 2u)));\n         i += 1u;\n     }\n     assert (hm_ss.insert(uint::to_str(num_to_insert, 2u),\n                          uint::to_str(17u, 2u)));\n-    assert (istr::eq(hm_ss.get(\n+    assert (str::eq(hm_ss.get(\n         uint::to_str(num_to_insert, 2u)),\n                     uint::to_str(17u, 2u)));\n     log \"-----\";\n@@ -148,7 +148,7 @@ fn test_growth() {\n     while i < num_to_insert {\n         log ~\"get(\\\"\" + uint::to_str(i, 2u) + ~\"\\\") = \\\"\" +\n                 hm_ss.get(uint::to_str(i, 2u)) + ~\"\\\"\";\n-        assert (istr::eq(hm_ss.get(uint::to_str(i, 2u)),\n+        assert (str::eq(hm_ss.get(uint::to_str(i, 2u)),\n                         uint::to_str(i * i, 2u)));\n         i += 1u;\n     }\n@@ -249,7 +249,7 @@ fn test_removal() {\n #[test]\n fn test_contains_key() {\n     let key = ~\"k\";\n-    let map = map::mk_hashmap::<istr, istr>(istr::hash, istr::eq);\n+    let map = map::mk_hashmap::<istr, istr>(str::hash, str::eq);\n     assert (!map.contains_key(key));\n     map.insert(key, ~\"val\");\n     assert (map.contains_key(key));\n@@ -258,7 +258,7 @@ fn test_contains_key() {\n #[test]\n fn test_find() {\n     let key = ~\"k\";\n-    let map = map::mk_hashmap::<istr, istr>(istr::hash, istr::eq);\n+    let map = map::mk_hashmap::<istr, istr>(str::hash, str::eq);\n     assert (std::option::is_none(map.find(key)));\n     map.insert(key, ~\"val\");\n     assert (std::option::get(map.find(key)) == ~\"val\");"}, {"sha": "5c62ed3eb0e49c72cf144bfba0480320832a3163", "filename": "src/test/stdtest/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fstdtest%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fstdtest%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Frun.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -3,7 +3,7 @@ import std::run;\n import std::os;\n import std::io;\n import std::option;\n-import std::istr;\n+import std::str;\n import std::vec;\n \n // Regression test for memory leaks\n@@ -60,7 +60,7 @@ fn test_pipes() {\n         let buf = ~\"\";\n         while !reader.eof() {\n             let bytes = reader.read_bytes(4096u);\n-            buf += istr::unsafe_from_bytes(bytes);\n+            buf += str::unsafe_from_bytes(bytes);\n         }\n         os::libc::fclose(file);\n         ret buf;"}, {"sha": "a66b898ddfa3da2260cafd865ccb1d7b599348dd", "filename": "src/test/stdtest/sha1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fstdtest%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fstdtest%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fsha1.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -5,7 +5,7 @@\n use std;\n import std::sha1;\n import std::vec;\n-import std::istr;\n+import std::str;\n \n #[test]\n fn test() {\n@@ -74,11 +74,11 @@ fn test() {\n \n     // Test that it works when accepting the message in pieces\n     for t: test in tests {\n-        let len = istr::byte_len(t.input);\n+        let len = str::byte_len(t.input);\n         let left = len;\n         while left > 0u {\n             let take = (left + 1u) / 2u;\n-            sh.input_str(istr::substr(t.input, len - left, take));\n+            sh.input_str(str::substr(t.input, len - left, take));\n             left = left - take;\n         }\n         let out = sh.result();"}, {"sha": "a559b61d3f2c3b2482da51c99b31769c47d26c08", "filename": "src/test/stdtest/str.rs", "status": "modified", "additions": 98, "deletions": 98, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fstdtest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fstdtest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstr.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,52 +1,52 @@\n-import std::istr;\n+import std::str;\n import std::vec;\n \n #[test]\n fn test_eq() {\n-    assert istr::eq(~\"\", ~\"\");\n-    assert istr::eq(~\"foo\", ~\"foo\");\n-    assert !istr::eq(~\"foo\", ~\"bar\");\n+    assert str::eq(~\"\", ~\"\");\n+    assert str::eq(~\"foo\", ~\"foo\");\n+    assert !str::eq(~\"foo\", ~\"bar\");\n }\n \n #[test]\n fn test_lteq() {\n-    assert istr::lteq(~\"\", ~\"\");\n-    assert istr::lteq(~\"\", ~\"foo\");\n-    assert istr::lteq(~\"foo\", ~\"foo\");\n-    assert !istr::eq(~\"foo\", ~\"bar\");\n+    assert str::lteq(~\"\", ~\"\");\n+    assert str::lteq(~\"\", ~\"foo\");\n+    assert str::lteq(~\"foo\", ~\"foo\");\n+    assert !str::eq(~\"foo\", ~\"bar\");\n }\n \n #[test]\n fn test_bytes_len() {\n-    assert (istr::byte_len(~\"\") == 0u);\n-    assert (istr::byte_len(~\"hello world\") == 11u);\n-    assert (istr::byte_len(~\"\\x63\") == 1u);\n-    assert (istr::byte_len(~\"\\xa2\") == 2u);\n-    assert (istr::byte_len(~\"\\u03c0\") == 2u);\n-    assert (istr::byte_len(~\"\\u2620\") == 3u);\n-    assert (istr::byte_len(~\"\\U0001d11e\") == 4u);\n+    assert (str::byte_len(~\"\") == 0u);\n+    assert (str::byte_len(~\"hello world\") == 11u);\n+    assert (str::byte_len(~\"\\x63\") == 1u);\n+    assert (str::byte_len(~\"\\xa2\") == 2u);\n+    assert (str::byte_len(~\"\\u03c0\") == 2u);\n+    assert (str::byte_len(~\"\\u2620\") == 3u);\n+    assert (str::byte_len(~\"\\U0001d11e\") == 4u);\n }\n \n #[test]\n fn test_index_and_rindex() {\n-    assert (istr::index(~\"hello\", 'e' as u8) == 1);\n-    assert (istr::index(~\"hello\", 'o' as u8) == 4);\n-    assert (istr::index(~\"hello\", 'z' as u8) == -1);\n-    assert (istr::rindex(~\"hello\", 'l' as u8) == 3);\n-    assert (istr::rindex(~\"hello\", 'h' as u8) == 0);\n-    assert (istr::rindex(~\"hello\", 'z' as u8) == -1);\n+    assert (str::index(~\"hello\", 'e' as u8) == 1);\n+    assert (str::index(~\"hello\", 'o' as u8) == 4);\n+    assert (str::index(~\"hello\", 'z' as u8) == -1);\n+    assert (str::rindex(~\"hello\", 'l' as u8) == 3);\n+    assert (str::rindex(~\"hello\", 'h' as u8) == 0);\n+    assert (str::rindex(~\"hello\", 'z' as u8) == -1);\n }\n \n #[test]\n fn test_split() {\n     fn t(s: &istr, c: char, i: int, k: &istr) {\n         log ~\"splitting: \" + s;\n         log i;\n-        let v = istr::split(s, c as u8);\n+        let v = str::split(s, c as u8);\n         log ~\"split to: \";\n         for z: istr in v { log z; }\n         log ~\"comparing: \" + v[i] + ~\" vs. \" + k;\n-        assert (istr::eq(v[i], k));\n+        assert (str::eq(v[i], k));\n     }\n     t(~\"abc.hello.there\", '.', 0, ~\"abc\");\n     t(~\"abc.hello.there\", '.', 1, ~\"hello\");\n@@ -60,7 +60,7 @@ fn test_split() {\n #[test]\n fn test_find() {\n     fn t(haystack: &istr, needle: &istr, i: int) {\n-        let j: int = istr::find(haystack, needle);\n+        let j: int = str::find(haystack, needle);\n         log ~\"searched for \" + needle;\n         log j;\n         assert (i == j);\n@@ -75,8 +75,8 @@ fn test_find() {\n #[test]\n fn test_substr() {\n     fn t(a: &istr, b: &istr, start: int) {\n-        assert (istr::eq(istr::substr(a, start as uint,\n-                                      istr::byte_len(b)), b));\n+        assert (str::eq(str::substr(a, start as uint,\n+                                      str::byte_len(b)), b));\n     }\n     t(~\"hello\", ~\"llo\", 2);\n     t(~\"hello\", ~\"el\", 1);\n@@ -85,7 +85,7 @@ fn test_substr() {\n \n #[test]\n fn test_concat() {\n-    fn t(v: &[istr], s: &istr) { assert (istr::eq(istr::concat(v), s)); }\n+    fn t(v: &[istr], s: &istr) { assert (str::eq(str::concat(v), s)); }\n     t([~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], ~\"youknowI'mnogood\");\n     let v: [istr] = [];\n     t(v, ~\"\");\n@@ -95,7 +95,7 @@ fn test_concat() {\n #[test]\n fn test_connect() {\n     fn t(v: &[istr], sep: &istr, s: &istr) {\n-        assert (istr::eq(istr::connect(v, sep), s));\n+        assert (str::eq(str::connect(v, sep), s));\n     }\n     t([~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], ~\" \",\n       ~\"you know I'm no good\");\n@@ -112,15 +112,15 @@ fn test_to_upper() {\n     let unicode = ~\"\\u65e5\\u672c\";\n     let input = ~\"abcDEF\" + unicode + ~\"xyz:.;\";\n     let expected = ~\"ABCDEF\" + unicode + ~\"XYZ:.;\";\n-    let actual = istr::to_upper(input);\n-    assert (istr::eq(expected, actual));\n+    let actual = str::to_upper(input);\n+    assert (str::eq(expected, actual));\n }\n \n #[test]\n fn test_slice() {\n-    assert (istr::eq(~\"ab\", istr::slice(~\"abc\", 0u, 2u)));\n-    assert (istr::eq(~\"bc\", istr::slice(~\"abc\", 1u, 3u)));\n-    assert (istr::eq(~\"\", istr::slice(~\"abc\", 1u, 1u)));\n+    assert (str::eq(~\"ab\", str::slice(~\"abc\", 0u, 2u)));\n+    assert (str::eq(~\"bc\", str::slice(~\"abc\", 1u, 3u)));\n+    assert (str::eq(~\"\", str::slice(~\"abc\", 1u, 1u)));\n     fn a_million_letter_a() -> istr {\n         let i = 0;\n         let rs = ~\"\";\n@@ -133,143 +133,143 @@ fn test_slice() {\n         while i < 100000 { rs += ~\"aaaaa\"; i += 1; }\n         ret rs;\n     }\n-    assert (istr::eq(half_a_million_letter_a(),\n-                    istr::slice(a_million_letter_a(), 0u, 500000u)));\n+    assert (str::eq(half_a_million_letter_a(),\n+                    str::slice(a_million_letter_a(), 0u, 500000u)));\n }\n \n #[test]\n fn test_starts_with() {\n-    assert (istr::starts_with(~\"\", ~\"\"));\n-    assert (istr::starts_with(~\"abc\", ~\"\"));\n-    assert (istr::starts_with(~\"abc\", ~\"a\"));\n-    assert (!istr::starts_with(~\"a\", ~\"abc\"));\n-    assert (!istr::starts_with(~\"\", ~\"abc\"));\n+    assert (str::starts_with(~\"\", ~\"\"));\n+    assert (str::starts_with(~\"abc\", ~\"\"));\n+    assert (str::starts_with(~\"abc\", ~\"a\"));\n+    assert (!str::starts_with(~\"a\", ~\"abc\"));\n+    assert (!str::starts_with(~\"\", ~\"abc\"));\n }\n \n #[test]\n fn test_ends_with() {\n-    assert (istr::ends_with(~\"\", ~\"\"));\n-    assert (istr::ends_with(~\"abc\", ~\"\"));\n-    assert (istr::ends_with(~\"abc\", ~\"c\"));\n-    assert (!istr::ends_with(~\"a\", ~\"abc\"));\n-    assert (!istr::ends_with(~\"\", ~\"abc\"));\n+    assert (str::ends_with(~\"\", ~\"\"));\n+    assert (str::ends_with(~\"abc\", ~\"\"));\n+    assert (str::ends_with(~\"abc\", ~\"c\"));\n+    assert (!str::ends_with(~\"a\", ~\"abc\"));\n+    assert (!str::ends_with(~\"\", ~\"abc\"));\n }\n \n #[test]\n fn test_is_empty() {\n-    assert (istr::is_empty(~\"\"));\n-    assert (!istr::is_empty(~\"a\"));\n+    assert (str::is_empty(~\"\"));\n+    assert (!str::is_empty(~\"a\"));\n }\n \n #[test]\n fn test_is_not_empty() {\n-    assert (istr::is_not_empty(~\"a\"));\n-    assert (!istr::is_not_empty(~\"\"));\n+    assert (str::is_not_empty(~\"a\"));\n+    assert (!str::is_not_empty(~\"\"));\n }\n \n #[test]\n fn test_replace() {\n     let a = ~\"a\";\n-    check (istr::is_not_empty(a));\n-    assert (istr::replace(~\"\", a, ~\"b\") == ~\"\");\n-    assert (istr::replace(~\"a\", a, ~\"b\") == ~\"b\");\n-    assert (istr::replace(~\"ab\", a, ~\"b\") == ~\"bb\");\n+    check (str::is_not_empty(a));\n+    assert (str::replace(~\"\", a, ~\"b\") == ~\"\");\n+    assert (str::replace(~\"a\", a, ~\"b\") == ~\"b\");\n+    assert (str::replace(~\"ab\", a, ~\"b\") == ~\"bb\");\n     let test = ~\"test\";\n-    check (istr::is_not_empty(test));\n-    assert (istr::replace(~\" test test \", test, ~\"toast\")\n+    check (str::is_not_empty(test));\n+    assert (str::replace(~\" test test \", test, ~\"toast\")\n             == ~\" toast toast \");\n-    assert (istr::replace(~\" test test \", test, ~\"\") == ~\"   \");\n+    assert (str::replace(~\" test test \", test, ~\"\") == ~\"   \");\n }\n \n #[test]\n fn test_char_slice() {\n-    assert (istr::eq(~\"ab\", istr::char_slice(~\"abc\", 0u, 2u)));\n-    assert (istr::eq(~\"bc\", istr::char_slice(~\"abc\", 1u, 3u)));\n-    assert (istr::eq(~\"\", istr::char_slice(~\"abc\", 1u, 1u)));\n-    assert (istr::eq(~\"\\u65e5\", istr::char_slice(~\"\\u65e5\\u672c\", 0u, 1u)));\n+    assert (str::eq(~\"ab\", str::char_slice(~\"abc\", 0u, 2u)));\n+    assert (str::eq(~\"bc\", str::char_slice(~\"abc\", 1u, 3u)));\n+    assert (str::eq(~\"\", str::char_slice(~\"abc\", 1u, 1u)));\n+    assert (str::eq(~\"\\u65e5\", str::char_slice(~\"\\u65e5\\u672c\", 0u, 1u)));\n }\n \n #[test]\n fn trim_left() {\n-    assert (istr::trim_left(~\"\") == ~\"\");\n-    assert (istr::trim_left(~\"a\") == ~\"a\");\n-    assert (istr::trim_left(~\"    \") == ~\"\");\n-    assert (istr::trim_left(~\"     blah\") == ~\"blah\");\n-    assert (istr::trim_left(~\"   \\u3000  wut\") == ~\"wut\");\n-    assert (istr::trim_left(~\"hey \") == ~\"hey \");\n+    assert (str::trim_left(~\"\") == ~\"\");\n+    assert (str::trim_left(~\"a\") == ~\"a\");\n+    assert (str::trim_left(~\"    \") == ~\"\");\n+    assert (str::trim_left(~\"     blah\") == ~\"blah\");\n+    assert (str::trim_left(~\"   \\u3000  wut\") == ~\"wut\");\n+    assert (str::trim_left(~\"hey \") == ~\"hey \");\n }\n \n #[test]\n fn trim_right() {\n-    assert (istr::trim_right(~\"\") == ~\"\");\n-    assert (istr::trim_right(~\"a\") == ~\"a\");\n-    assert (istr::trim_right(~\"    \") == ~\"\");\n-    assert (istr::trim_right(~\"blah     \") == ~\"blah\");\n-    assert (istr::trim_right(~\"wut   \\u3000  \") == ~\"wut\");\n-    assert (istr::trim_right(~\" hey\") == ~\" hey\");\n+    assert (str::trim_right(~\"\") == ~\"\");\n+    assert (str::trim_right(~\"a\") == ~\"a\");\n+    assert (str::trim_right(~\"    \") == ~\"\");\n+    assert (str::trim_right(~\"blah     \") == ~\"blah\");\n+    assert (str::trim_right(~\"wut   \\u3000  \") == ~\"wut\");\n+    assert (str::trim_right(~\" hey\") == ~\" hey\");\n }\n \n #[test]\n fn trim() {\n-    assert (istr::trim(~\"\") == ~\"\");\n-    assert (istr::trim(~\"a\") == ~\"a\");\n-    assert (istr::trim(~\"    \") == ~\"\");\n-    assert (istr::trim(~\"    blah     \") == ~\"blah\");\n-    assert (istr::trim(~\"\\nwut   \\u3000  \") == ~\"wut\");\n-    assert (istr::trim(~\" hey dude \") == ~\"hey dude\");\n+    assert (str::trim(~\"\") == ~\"\");\n+    assert (str::trim(~\"a\") == ~\"a\");\n+    assert (str::trim(~\"    \") == ~\"\");\n+    assert (str::trim(~\"    blah     \") == ~\"blah\");\n+    assert (str::trim(~\"\\nwut   \\u3000  \") == ~\"wut\");\n+    assert (str::trim(~\" hey dude \") == ~\"hey dude\");\n }\n \n #[test]\n fn is_whitespace() {\n-    assert (istr::is_whitespace(~\"\"));\n-    assert (istr::is_whitespace(~\" \"));\n-    assert (istr::is_whitespace(~\"\\u2009\")); // Thin space\n-    assert (istr::is_whitespace(~\"  \\n\\t   \"));\n-    assert (!istr::is_whitespace(~\"   _   \"));\n+    assert (str::is_whitespace(~\"\"));\n+    assert (str::is_whitespace(~\" \"));\n+    assert (str::is_whitespace(~\"\\u2009\")); // Thin space\n+    assert (str::is_whitespace(~\"  \\n\\t   \"));\n+    assert (!str::is_whitespace(~\"   _   \"));\n }\n \n #[test]\n fn is_ascii() {\n-    assert istr::is_ascii(~\"\");\n-    assert istr::is_ascii(~\"a\");\n-    assert !istr::is_ascii(~\"\\u2009\");\n+    assert str::is_ascii(~\"\");\n+    assert str::is_ascii(~\"a\");\n+    assert !str::is_ascii(~\"\\u2009\");\n }\n \n #[test]\n fn shift_byte() {\n     let s = ~\"ABC\";\n-    let b = istr::shift_byte(s);\n+    let b = str::shift_byte(s);\n     assert s == ~\"BC\";\n     assert b == 65u8;\n }\n \n #[test]\n fn pop_byte() {\n     let s = ~\"ABC\";\n-    let b = istr::pop_byte(s);\n+    let b = str::pop_byte(s);\n     assert s == ~\"AB\";\n     assert b == 67u8;\n }\n \n #[test]\n fn unsafe_from_bytes() {\n     let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n-    let b = istr::unsafe_from_bytes(a);\n+    let b = str::unsafe_from_bytes(a);\n     assert b == ~\"AAAAAAA\";\n }\n \n #[test]\n fn str_from_cstr() {\n     let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n     let b = vec::to_ptr(a);\n-    let c = istr::str_from_cstr(b);\n+    let c = str::str_from_cstr(b);\n     assert c == ~\"AAAAAAA\";\n }\n \n #[test]\n fn as_buf() {\n     let a = ~\"Abcdefg\";\n-    let b = istr::as_buf(a, { |buf|\n+    let b = str::as_buf(a, { |buf|\n         assert *buf == 65u8;\n         100\n     });\n@@ -279,7 +279,7 @@ fn as_buf() {\n #[test]\n fn as_buf_small() {\n     let a = ~\"A\";\n-    let b = istr::as_buf(a, { |buf|\n+    let b = str::as_buf(a, { |buf|\n         assert *buf == 65u8;\n         100\n     });\n@@ -289,19 +289,19 @@ fn as_buf_small() {\n #[test]\n fn as_buf2() {\n     let s = ~\"hello\";\n-    let sb = istr::as_buf(s, { |b| b });\n-    let s_cstr = istr::str_from_cstr(sb);\n-    assert (istr::eq(s_cstr, s));\n+    let sb = str::as_buf(s, { |b| b });\n+    let s_cstr = str::str_from_cstr(sb);\n+    assert (str::eq(s_cstr, s));\n }\n \n #[test]\n fn vec_str_conversions() {\n     let s1: istr = ~\"All mimsy were the borogoves\";\n \n-    let v: [u8] = istr::bytes(s1);\n-    let s2: istr = istr::unsafe_from_bytes(v);\n+    let v: [u8] = str::bytes(s1);\n+    let s2: istr = str::unsafe_from_bytes(v);\n     let i: uint = 0u;\n-    let n1: uint = istr::byte_len(s1);\n+    let n1: uint = str::byte_len(s1);\n     let n2: uint = vec::len::<u8>(v);\n     assert (n1 == n2);\n     while i < n1 {"}, {"sha": "cb4b93130291c9cba991ee1b7f25ef2fc2a6b4a2", "filename": "src/test/stdtest/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fstdtest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fstdtest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftest.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -1,5 +1,5 @@\n import std::test;\n-import std::istr;\n+import std::str;\n import std::option;\n import std::either;\n import std::vec;\n@@ -29,7 +29,7 @@ fn first_free_arg_should_be_a_filter() {\n     let args = [~\"progname\", ~\"filter\"];\n     check (vec::is_not_empty(args));\n     let opts = alt test::parse_opts(args) { either::left(o) { o } };\n-    assert (istr::eq(~\"filter\", option::get(opts.filter)));\n+    assert (str::eq(~\"filter\", option::get(opts.filter)));\n }\n \n #[test]"}, {"sha": "9a2ef1e8e6833ac046004aa0c10f39f3bed3e3c5", "filename": "src/test/stdtest/treemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fstdtest%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab6bb035e50f735cb36cc1959e5a097f076a3b74/src%2Ftest%2Fstdtest%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftreemap.rs?ref=ab6bb035e50f735cb36cc1959e5a097f076a3b74", "patch": "@@ -2,7 +2,7 @@ use std;\n import std::treemap::*;\n import std::option::some;\n import std::option::none;\n-import std::istr;\n+import std::str;\n \n #[test]\n fn init_treemap() {\n@@ -63,8 +63,8 @@ fn traverse_in_order() {\n fn u8_map() {\n     let m = init();\n \n-    let k1 = istr::bytes(~\"foo\");\n-    let k2 = istr::bytes(~\"bar\");\n+    let k1 = str::bytes(~\"foo\");\n+    let k2 = str::bytes(~\"bar\");\n \n     insert(m, k1, ~\"foo\");\n     insert(m, k2, ~\"bar\");"}]}