{"sha": "7993f4820995c9b26d73e8a58bb8f3c0e2e79d47", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5OTNmNDgyMDk5NWM5YjI2ZDczZThhNThiYjhmM2MwZTJlNzlkNDc=", "commit": {"author": {"name": "Zack Corr", "email": "zack@z0w0.me", "date": "2012-08-26T12:40:21Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-31T23:20:35Z"}, "message": "jit: Add custom memory manager (still segfaulting)", "tree": {"sha": "449106cbe7bdd17cf03b3c93c0559957b114e099", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/449106cbe7bdd17cf03b3c93c0559957b114e099"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7993f4820995c9b26d73e8a58bb8f3c0e2e79d47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7993f4820995c9b26d73e8a58bb8f3c0e2e79d47", "html_url": "https://github.com/rust-lang/rust/commit/7993f4820995c9b26d73e8a58bb8f3c0e2e79d47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7993f4820995c9b26d73e8a58bb8f3c0e2e79d47/comments", "author": {"login": "z0w0", "id": 676417, "node_id": "MDQ6VXNlcjY3NjQxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/676417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/z0w0", "html_url": "https://github.com/z0w0", "followers_url": "https://api.github.com/users/z0w0/followers", "following_url": "https://api.github.com/users/z0w0/following{/other_user}", "gists_url": "https://api.github.com/users/z0w0/gists{/gist_id}", "starred_url": "https://api.github.com/users/z0w0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/z0w0/subscriptions", "organizations_url": "https://api.github.com/users/z0w0/orgs", "repos_url": "https://api.github.com/users/z0w0/repos", "events_url": "https://api.github.com/users/z0w0/events{/privacy}", "received_events_url": "https://api.github.com/users/z0w0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7aa9918ef1673edcef261da41075203de5b15b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7aa9918ef1673edcef261da41075203de5b15b3", "html_url": "https://github.com/rust-lang/rust/commit/d7aa9918ef1673edcef261da41075203de5b15b3"}], "stats": {"total": 459, "additions": 275, "deletions": 184}, "files": [{"sha": "00b34e4bae5d953c21aad476ee81a42fe75abf67", "filename": "mk/libuv/ia32/win/src/libuv/uv.target.mk.bak", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/d7aa9918ef1673edcef261da41075203de5b15b3/mk%2Flibuv%2Fia32%2Fwin%2Fsrc%2Flibuv%2Fuv.target.mk.bak", "raw_url": "https://github.com/rust-lang/rust/raw/d7aa9918ef1673edcef261da41075203de5b15b3/mk%2Flibuv%2Fia32%2Fwin%2Fsrc%2Flibuv%2Fuv.target.mk.bak", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fia32%2Fwin%2Fsrc%2Flibuv%2Fuv.target.mk.bak?ref=d7aa9918ef1673edcef261da41075203de5b15b3", "patch": "@@ -1,167 +0,0 @@\n-# This file is generated by gyp; do not edit.\n-\n-TOOLSET := target\n-TARGET := uv\n-DEFS_Debug := '-DWIN32' \\\n-\t'-D_CRT_SECURE_NO_DEPRECATE' \\\n-\t'-D_CRT_NONSTDC_NO_DEPRECATE' \\\n-\t'-DHAVE_CONFIG_H' \\\n-\t'-D_WIN32_WINNT=0x0600' \\\n-\t'-DEIO_STACKSIZE=262144' \\\n-\t'-D_GNU_SOURCE' \\\n-\t'-DDEBUG' \\\n-\t'-D_DEBUG'\n-\n-# Flags passed to all source files.\n-CFLAGS_Debug := -g \\\n-\t-O0\n-\n-# Flags passed to only C files.\n-CFLAGS_C_Debug := \n-\n-# Flags passed to only C++ files.\n-CFLAGS_CC_Debug := \n-\n-INCS_Debug := -I$(srcdir)\\src\\libuv\\include \\\n-\t-I$(srcdir)\\src\\libuv\\include\\uv-private \\\n-\t-I$(srcdir)\\src\\libuv\\src \\\n-\t-I$(srcdir)\\src\\libuv\\src\\ares\\config_win32\n-\n-DEFS_Release := '-DWIN32' \\\n-\t'-D_CRT_SECURE_NO_DEPRECATE' \\\n-\t'-D_CRT_NONSTDC_NO_DEPRECATE' \\\n-\t'-DHAVE_CONFIG_H' \\\n-\t'-D_WIN32_WINNT=0x0600' \\\n-\t'-DEIO_STACKSIZE=262144' \\\n-\t'-D_GNU_SOURCE' \\\n-\t'-DNDEBUG'\n-\n-# Flags passed to all source files.\n-CFLAGS_Release := -O3 \\\n-\t-fomit-frame-pointer \\\n-\t-fdata-sections \\\n-\t-ffunction-sections\n-\n-# Flags passed to only C files.\n-CFLAGS_C_Release := \n-\n-# Flags passed to only C++ files.\n-CFLAGS_CC_Release := \n-\n-INCS_Release := -I$(srcdir)\\src\\libuv\\include \\\n-\t-I$(srcdir)\\src\\libuv\\include\\uv-private \\\n-\t-I$(srcdir)\\src\\libuv\\src \\\n-\t-I$(srcdir)\\src\\libuv\\src\\ares\\config_win32\n-\n-OBJS := $(obj).target\\$(TARGET)\\src\\libuv\\src\\uv-common.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_cancel.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares__close_sockets.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_data.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_destroy.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_expand_name.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_expand_string.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_fds.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_free_hostent.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_free_string.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_gethostbyaddr.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_gethostbyname.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares__get_hostent.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_getnameinfo.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_getopt.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_getsock.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_init.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_library_init.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_llist.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_mkquery.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_nowarn.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_options.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_parse_aaaa_reply.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_parse_a_reply.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_parse_mx_reply.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_parse_ns_reply.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_parse_ptr_reply.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_parse_srv_reply.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_parse_txt_reply.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_process.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_query.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares__read_line.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_search.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_send.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_strcasecmp.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_strdup.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_strerror.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_timeout.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares__timeval.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_version.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_writev.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\bitncmp.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\inet_net_pton.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\inet_ntop.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\windows_port.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_getenv.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\ares\\ares_platform.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\async.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\cares.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\core.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\dl.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\error.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\fs.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\fs-event.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\getaddrinfo.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\handle.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\loop-watcher.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\pipe.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\thread.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\process.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\req.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\stream.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\tcp.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\tty.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\threadpool.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\timer.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\udp.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\util.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\winapi.o \\\n-\t$(obj).target\\$(TARGET)\\src\\libuv\\src\\win\\winsock.o\n-\n-# Add to the list of files we specially track dependencies for.\n-all_deps += $(OBJS)\n-\n-# CFLAGS et al overrides must be target-local.\n-# See \"Target-specific Variable Values\" in the GNU Make manual.\n-$(OBJS): TOOLSET := $(TOOLSET)\n-$(OBJS): GYP_CFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE))  $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_C_$(BUILDTYPE))\n-$(OBJS): GYP_CXXFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE))  $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_CC_$(BUILDTYPE))\n-\n-# Suffix rules, putting all outputs into $(obj).\n-\n-$(obj).$(TOOLSET)\\$(TARGET)\\%.o: $(srcdir)\\%.c FORCE_DO_CMD\n-\t@$(call do_cmd,cc,1)\n-\n-# Try building from generated source, too.\n-\n-$(obj).$(TOOLSET)\\$(TARGET)\\%.o: $(obj).$(TOOLSET)\\%.c FORCE_DO_CMD\n-\t@$(call do_cmd,cc,1)\n-\n-$(obj).$(TOOLSET)\\$(TARGET)\\%.o: $(obj)\\%.c FORCE_DO_CMD\n-\t@$(call do_cmd,cc,1)\n-\n-# End of this set of suffix rules\n-### Rules for final target.\n-LDFLAGS_Debug := \n-\n-LDFLAGS_Release := \n-\n-LIBS := \n-\n-$(obj).target\\src\\libuv\\libuv.a: GYP_LDFLAGS := $(LDFLAGS_$(BUILDTYPE))\n-$(obj).target\\src\\libuv\\libuv.a: LIBS := $(LIBS)\n-$(obj).target\\src\\libuv\\libuv.a: TOOLSET := $(TOOLSET)\n-$(obj).target\\src\\libuv\\libuv.a: $(OBJS) FORCE_DO_CMD\n-\t$(call do_cmd,alink)\n-\n-all_deps += $(obj).target\\src\\libuv\\libuv.a\n-# Add target alias\n-.PHONY: uv\n-uv: $(obj).target\\src\\libuv\\libuv.a\n-"}, {"sha": "06d90e982c147319346d89aea376635c08a39553", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7993f4820995c9b26d73e8a58bb8f3c0e2e79d47/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7993f4820995c9b26d73e8a58bb8f3c0e2e79d47/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=7993f4820995c9b26d73e8a58bb8f3c0e2e79d47", "patch": "@@ -160,14 +160,37 @@ mod write {\n                 llvm::LLVMAddCFGSimplificationPass(pm.llpm);*/\n \n                 // JIT execution takes ownership of the module,\n-                // so don't dispose and return.\n+                // so don't dispose and return. Due to a weird bug\n+                // with dynamic libraries, we need to separate jitting\n+                // into two functions and load crates inbetween.\n+\n+                if !llvm::LLVMRustPrepareJIT(pm.llpm,\n+                                             llmod,\n+                                             CodeGenOptLevel,\n+                                             true) {\n+                    llvm_err(sess, ~\"Could not JIT\");\n+                }\n+\n+                // We need to tell LLVM where to resolve all linked\n+                // symbols from. The equivalent of -lstd, -lcore, etc.\n+                /*let cstore = sess.cstore;\n+                for cstore::get_used_crate_files(cstore).each |cratepath| {\n+                    debug!{\"linking: %s\", cratepath};\n+\n+                    let _: () = str::as_c_str(\n+                        cratepath,\n+                        |buf_t| {\n+                            if !llvm::LLVMRustLoadLibrary(buf_t) {\n+                                llvm_err(sess, ~\"Could not link\");\n+                            }\n+                            debug!{\"linked: %s\", cratepath};\n+                        });\n+                }*/\n \n-                if !llvm::LLVMRustJIT(pm.llpm,\n-                                      llmod,\n-                                      CodeGenOptLevel,\n-                                      true) {\n+                if !llvm::LLVMRustExecuteJIT() {\n                     llvm_err(sess, ~\"Could not JIT\");\n                 }\n+\n                 if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n                 return;\n             }"}, {"sha": "ec9c669501b0ee5ec984ed1193c9352a53660146", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7993f4820995c9b26d73e8a58bb8f3c0e2e79d47/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7993f4820995c9b26d73e8a58bb8f3c0e2e79d47/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=7993f4820995c9b26d73e8a58bb8f3c0e2e79d47", "patch": "@@ -986,12 +986,18 @@ extern mod llvm {\n         call. */\n     fn LLVMRustGetLastError() -> *c_char;\n \n-    /** JIT the module. **/\n-    fn LLVMRustJIT(PM: PassManagerRef,\n+    /** Load a shared library to resolve symbols against. */\n+    fn LLVMRustLoadLibrary(Filename: *c_char) -> bool;\n+\n+    /** Create the JIT engine. */\n+    fn LLVMRustPrepareJIT(PM: PassManagerRef,\n                    M: ModuleRef,\n                    OptLevel: c_int,\n                    EnableSegmentedStacks: bool) -> bool;\n \n+    /** Execute the JIT engine. */\n+    fn LLVMRustExecuteJIT() -> bool;\n+\n     /** Parses the bitcode in the given memory buffer. */\n     fn LLVMRustParseBitcode(MemBuf: MemoryBufferRef) -> ModuleRef;\n "}, {"sha": "290f9f135e9649f8b68a39b3f5850d2b466f880d", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 236, "deletions": 9, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/7993f4820995c9b26d73e8a58bb8f3c0e2e79d47/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/7993f4820995c9b26d73e8a58bb8f3c0e2e79d47/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=7993f4820995c9b26d73e8a58bb8f3c0e2e79d47", "patch": "@@ -29,15 +29,26 @@\n #include \"llvm/Support/Host.h\"\n #include \"llvm/Support/Debug.h\"\n #include \"llvm/Support/DynamicLibrary.h\"\n+#include \"llvm/Support/Memory.h\"\n #include \"llvm/ExecutionEngine/ExecutionEngine.h\"\n #include \"llvm/ExecutionEngine/JIT.h\"\n+#include \"llvm/ExecutionEngine/JITMemoryManager.h\"\n+#include \"llvm/ExecutionEngine/MCJIT.h\"\n #include \"llvm/ExecutionEngine/Interpreter.h\"\n #include \"llvm/ExecutionEngine/GenericValue.h\"\n #include \"llvm-c/Core.h\"\n #include \"llvm-c/BitReader.h\"\n #include \"llvm-c/Object.h\"\n #include <cstdlib>\n \n+// Used by RustMCJITMemoryManager::getPointerToNamedFunction()\n+// to get around glibc issues. See the function for more information.\n+#ifdef __linux__\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#endif\n+\n using namespace llvm;\n \n static const char *LLVMRustError;\n@@ -85,7 +96,208 @@ void LLVMInitializeX86AsmParser();\n                              LLVMInitializeX86AsmParser();\n \n extern \"C\" bool\n-LLVMRustJIT(LLVMPassManagerRef PMR,\n+LLVMRustLoadLibrary(const char* file) {\n+  std::string err;\n+\n+  if(llvm::sys::DynamicLibrary::LoadLibraryPermanently(file, &err)) {\n+    LLVMRustError = err.c_str();\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+ExecutionEngine* EE;\n+\n+// Custom memory manager for MCJITting. It needs special features\n+// that the generic JIT memory manager doesn't entail. Based on\n+// code from LLI, change where needed for Rust.\n+class RustMCJITMemoryManager : public JITMemoryManager {\n+public:\n+  SmallVector<sys::MemoryBlock, 16> AllocatedDataMem;\n+  SmallVector<sys::MemoryBlock, 16> AllocatedCodeMem;\n+  SmallVector<sys::MemoryBlock, 16> FreeCodeMem;\n+\n+  RustMCJITMemoryManager() { }\n+  ~RustMCJITMemoryManager();\n+\n+  virtual uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n+                                       unsigned SectionID);\n+\n+  virtual uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n+                                       unsigned SectionID);\n+\n+  virtual void *getPointerToNamedFunction(const std::string &Name,\n+                                          bool AbortOnFailure = true);\n+\n+  // Invalidate instruction cache for code sections. Some platforms with\n+  // separate data cache and instruction cache require explicit cache flush,\n+  // otherwise JIT code manipulations (like resolved relocations) will get to\n+  // the data cache but not to the instruction cache.\n+  virtual void invalidateInstructionCache();\n+\n+  // The MCJITMemoryManager doesn't use the following functions, so we don't\n+  // need implement them.\n+  virtual void setMemoryWritable() {\n+    llvm_unreachable(\"Unimplemented call\");\n+  }\n+  virtual void setMemoryExecutable() {\n+    llvm_unreachable(\"Unimplemented call\");\n+  }\n+  virtual void setPoisonMemory(bool poison) {\n+    llvm_unreachable(\"Unimplemented call\");\n+  }\n+  virtual void AllocateGOT() {\n+    llvm_unreachable(\"Unimplemented call\");\n+  }\n+  virtual uint8_t *getGOTBase() const {\n+    llvm_unreachable(\"Unimplemented call\");\n+    return 0;\n+  }\n+  virtual uint8_t *startFunctionBody(const Function *F,\n+                                     uintptr_t &ActualSize){\n+    llvm_unreachable(\"Unimplemented call\");\n+    return 0;\n+  }\n+  virtual uint8_t *allocateStub(const GlobalValue* F, unsigned StubSize,\n+                                unsigned Alignment) {\n+    llvm_unreachable(\"Unimplemented call\");\n+    return 0;\n+  }\n+  virtual void endFunctionBody(const Function *F, uint8_t *FunctionStart,\n+                               uint8_t *FunctionEnd) {\n+    llvm_unreachable(\"Unimplemented call\");\n+  }\n+  virtual uint8_t *allocateSpace(intptr_t Size, unsigned Alignment) {\n+    llvm_unreachable(\"Unimplemented call\");\n+    return 0;\n+  }\n+  virtual uint8_t *allocateGlobal(uintptr_t Size, unsigned Alignment) {\n+    llvm_unreachable(\"Unimplemented call\");\n+    return 0;\n+  }\n+  virtual void deallocateFunctionBody(void *Body) {\n+    llvm_unreachable(\"Unimplemented call\");\n+  }\n+  virtual uint8_t* startExceptionTable(const Function* F,\n+                                       uintptr_t &ActualSize) {\n+    llvm_unreachable(\"Unimplemented call\");\n+    return 0;\n+  }\n+  virtual void endExceptionTable(const Function *F, uint8_t *TableStart,\n+                                 uint8_t *TableEnd, uint8_t* FrameRegister) {\n+    llvm_unreachable(\"Unimplemented call\");\n+  }\n+  virtual void deallocateExceptionTable(void *ET) {\n+    llvm_unreachable(\"Unimplemented call\");\n+  }\n+};\n+\n+uint8_t *RustMCJITMemoryManager::allocateDataSection(uintptr_t Size,\n+                                                    unsigned Alignment,\n+                                                    unsigned SectionID) {\n+  if (!Alignment)\n+    Alignment = 16;\n+  uint8_t *Addr = (uint8_t*)calloc((Size + Alignment - 1)/Alignment, Alignment);\n+  AllocatedDataMem.push_back(sys::MemoryBlock(Addr, Size));\n+  return Addr;\n+}\n+\n+uint8_t *RustMCJITMemoryManager::allocateCodeSection(uintptr_t Size,\n+                                                    unsigned Alignment,\n+                                                    unsigned SectionID) {\n+  if (!Alignment)\n+    Alignment = 16;\n+  unsigned NeedAllocate = Alignment * ((Size + Alignment - 1)/Alignment + 1);\n+  uintptr_t Addr = 0;\n+  // Look in the list of free code memory regions and use a block there if one\n+  // is available.\n+  for (int i = 0, e = FreeCodeMem.size(); i != e; ++i) {\n+    sys::MemoryBlock &MB = FreeCodeMem[i];\n+    if (MB.size() >= NeedAllocate) {\n+      Addr = (uintptr_t)MB.base();\n+      uintptr_t EndOfBlock = Addr + MB.size();\n+      // Align the address.\n+      Addr = (Addr + Alignment - 1) & ~(uintptr_t)(Alignment - 1);\n+      // Store cutted free memory block.\n+      FreeCodeMem[i] = sys::MemoryBlock((void*)(Addr + Size),\n+                                        EndOfBlock - Addr - Size);\n+      return (uint8_t*)Addr;\n+    }\n+  }\n+\n+  // No pre-allocated free block was large enough. Allocate a new memory region.\n+  sys::MemoryBlock MB = sys::Memory::AllocateRWX(NeedAllocate, 0, 0);\n+\n+  AllocatedCodeMem.push_back(MB);\n+  Addr = (uintptr_t)MB.base();\n+  uintptr_t EndOfBlock = Addr + MB.size();\n+  // Align the address.\n+  Addr = (Addr + Alignment - 1) & ~(uintptr_t)(Alignment - 1);\n+  // The AllocateRWX may allocate much more memory than we need. In this case,\n+  // we store the unused memory as a free memory block.\n+  unsigned FreeSize = EndOfBlock-Addr-Size;\n+  if (FreeSize > 16)\n+    FreeCodeMem.push_back(sys::MemoryBlock((void*)(Addr + Size), FreeSize));\n+\n+  // Return aligned address\n+  return (uint8_t*)Addr;\n+}\n+\n+void RustMCJITMemoryManager::invalidateInstructionCache() {\n+  for (int i = 0, e = AllocatedCodeMem.size(); i != e; ++i)\n+    sys::Memory::InvalidateInstructionCache(AllocatedCodeMem[i].base(),\n+                                            AllocatedCodeMem[i].size());\n+}\n+\n+void *RustMCJITMemoryManager::getPointerToNamedFunction(const std::string &Name,\n+                                                       bool AbortOnFailure) {\n+#ifdef __linux__\n+  // Force the following functions to be linked in to anything that uses the\n+  // JIT. This is a hack designed to work around the all-too-clever Glibc\n+  // strategy of making these functions work differently when inlined vs. when\n+  // not inlined, and hiding their real definitions in a separate archive file\n+  // that the dynamic linker can't see. For more info, search for\n+  // 'libc_nonshared.a' on Google, or read http://llvm.org/PR274.\n+  if (Name == \"stat\") return (void*)(intptr_t)&stat;\n+  if (Name == \"fstat\") return (void*)(intptr_t)&fstat;\n+  if (Name == \"lstat\") return (void*)(intptr_t)&lstat;\n+  if (Name == \"stat64\") return (void*)(intptr_t)&stat64;\n+  if (Name == \"fstat64\") return (void*)(intptr_t)&fstat64;\n+  if (Name == \"lstat64\") return (void*)(intptr_t)&lstat64;\n+  if (Name == \"atexit\") return (void*)(intptr_t)&atexit;\n+  if (Name == \"mknod\") return (void*)(intptr_t)&mknod;\n+#endif\n+\n+  const char *NameStr = Name.c_str();\n+  void *Ptr = sys::DynamicLibrary::SearchForAddressOfSymbol(NameStr);\n+  if (Ptr) return Ptr;\n+\n+  // If it wasn't found and if it starts with an underscore ('_') character,\n+  // try again without the underscore.\n+  if (NameStr[0] == '_') {\n+    Ptr = sys::DynamicLibrary::SearchForAddressOfSymbol(NameStr+1);\n+    if (Ptr) return Ptr;\n+  }\n+\n+  if (AbortOnFailure)\n+    report_fatal_error(\"Program used external function '\" + Name +\n+                      \"' which could not be resolved!\");\n+  return 0;\n+}\n+\n+RustMCJITMemoryManager::~RustMCJITMemoryManager() {\n+  for (unsigned i = 0, e = AllocatedCodeMem.size(); i != e; ++i)\n+    sys::Memory::ReleaseRWX(AllocatedCodeMem[i]);\n+  for (unsigned i = 0, e = AllocatedDataMem.size(); i != e; ++i)\n+    free(AllocatedDataMem[i].base());\n+}\n+\n+// Separated functions because loading libraries before creating\n+// an execution engine seems to break stuff.\n+\n+extern \"C\" bool\n+LLVMRustPrepareJIT(LLVMPassManagerRef PMR,\n             LLVMModuleRef M,\n             CodeGenOpt::Level OptLevel,\n             bool EnableSegmentedStacks) {\n@@ -96,15 +308,16 @@ LLVMRustJIT(LLVMPassManagerRef PMR,\n \n   std::string Err;\n   TargetOptions Options;\n-  Options.NoFramePointerElim = true;\n-  Options.EnableSegmentedStacks = EnableSegmentedStacks;\n+  Options.JITEmitDebugInfo = true;\n+  //Options.NoFramePointerElim = true;\n+  //Options.EnableSegmentedStacks = EnableSegmentedStacks;\n \n-  PassManager *PM = unwrap<PassManager>(PMR);\n-\n-  PM->run(*unwrap(M));\n+  unwrap<PassManager>(PMR)->run(*unwrap(M));\n \n-  ExecutionEngine* EE = EngineBuilder(unwrap(M))\n+  RustMCJITMemoryManager* MM = new RustMCJITMemoryManager();\n+  EE = EngineBuilder(unwrap(M))\n     .setTargetOptions(Options)\n+    .setJITMemoryManager(MM)\n     .setOptLevel(OptLevel)\n     .setUseMCJIT(true)\n     .create();\n@@ -114,16 +327,30 @@ LLVMRustJIT(LLVMPassManagerRef PMR,\n     return false;\n   }\n \n+  MM->invalidateInstructionCache();\n+\n+  return true;\n+}\n+\n+extern \"C\" bool\n+LLVMRustExecuteJIT() {\n+  assert(EE);\n+\n+  std::string Err;\n   Function* func = EE->FindFunctionNamed(\"main\");\n \n   if(!func || Err != \"\") {\n     LLVMRustError = Err.c_str();\n     return false;\n   }\n \n-  std::vector<GenericValue> args;\n+  //std::vector<GenericValue> args;\n+  typedef int (*entry_t)(int, int);\n+  entry_t entry = (entry_t) EE->getPointerToFunction(func);\n \n-  EE->runFunction(func, args);\n+  assert(entry);\n+  entry(0, 0);\n+  //EE->runFunction(func, args);\n \n   return true;\n }"}, {"sha": "0cb047ad5d03caa814df8d71e8cc51b4f21fb59b", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7993f4820995c9b26d73e8a58bb8f3c0e2e79d47/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/7993f4820995c9b26d73e8a58bb8f3c0e2e79d47/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=7993f4820995c9b26d73e8a58bb8f3c0e2e79d47", "patch": "@@ -4,7 +4,9 @@ LLVMRustWriteOutputFile\n LLVMRustGetLastError\n LLVMRustConstSmallInt\n LLVMRustConstInt\n-LLVMRustJIT\n+LLVMRustLoadLibrary\n+LLVMRustPrepareJIT\n+LLVMRustExecuteJIT\n LLVMRustParseBitcode\n LLVMRustParseAssemblyFile\n LLVMRustPrintPassTimings"}]}