{"sha": "b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNzc3Yzk1MmYxNzUyZGUwNzYyZTNmMDg4MmFjNWZmYjZlZWI3ZWU=", "commit": {"author": {"name": "CAD97", "email": "cad97@cad97.com", "date": "2020-02-17T20:32:37Z"}, "committer": {"name": "CAD97", "email": "cad97@cad97.com", "date": "2020-03-02T23:11:53Z"}, "message": "Remove chalk integration", "tree": {"sha": "eb93b50e9e487b9459cb2e9ef5d58e883691c19d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb93b50e9e487b9459cb2e9ef5d58e883691c19d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "html_url": "https://github.com/rust-lang/rust/commit/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/comments", "author": {"login": "CAD97", "id": 5992217, "node_id": "MDQ6VXNlcjU5OTIyMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5992217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CAD97", "html_url": "https://github.com/CAD97", "followers_url": "https://api.github.com/users/CAD97/followers", "following_url": "https://api.github.com/users/CAD97/following{/other_user}", "gists_url": "https://api.github.com/users/CAD97/gists{/gist_id}", "starred_url": "https://api.github.com/users/CAD97/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CAD97/subscriptions", "organizations_url": "https://api.github.com/users/CAD97/orgs", "repos_url": "https://api.github.com/users/CAD97/repos", "events_url": "https://api.github.com/users/CAD97/events{/privacy}", "received_events_url": "https://api.github.com/users/CAD97/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CAD97", "id": 5992217, "node_id": "MDQ6VXNlcjU5OTIyMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5992217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CAD97", "html_url": "https://github.com/CAD97", "followers_url": "https://api.github.com/users/CAD97/followers", "following_url": "https://api.github.com/users/CAD97/following{/other_user}", "gists_url": "https://api.github.com/users/CAD97/gists{/gist_id}", "starred_url": "https://api.github.com/users/CAD97/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CAD97/subscriptions", "organizations_url": "https://api.github.com/users/CAD97/orgs", "repos_url": "https://api.github.com/users/CAD97/repos", "events_url": "https://api.github.com/users/CAD97/events{/privacy}", "received_events_url": "https://api.github.com/users/CAD97/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18c275b423f9f13c0e404ae3804967d2ab66337c", "url": "https://api.github.com/repos/rust-lang/rust/commits/18c275b423f9f13c0e404ae3804967d2ab66337c", "html_url": "https://github.com/rust-lang/rust/commit/18c275b423f9f13c0e404ae3804967d2ab66337c"}], "stats": {"total": 2880, "additions": 20, "deletions": 2860}, "files": [{"sha": "57af0119baa83bcb1eeca1fc10fd0621e7d433f4", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "patch": "@@ -419,25 +419,6 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n-[[package]]\n-name = \"chalk-engine\"\n-version = \"0.9.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"17ec698a6f053a23bfbe646d9f2fde4b02abc19125595270a99e6f44ae0bdd1a\"\n-dependencies = [\n- \"chalk-macros\",\n- \"rustc-hash\",\n-]\n-\n-[[package]]\n-name = \"chalk-macros\"\n-version = \"0.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"295635afd6853aa9f20baeb7f0204862440c0fe994c5a253d5f479dac41d047e\"\n-dependencies = [\n- \"lazy_static 0.2.11\",\n-]\n-\n [[package]]\n name = \"chrono\"\n version = \"0.4.6\"\n@@ -3110,7 +3091,6 @@ dependencies = [\n  \"backtrace\",\n  \"bitflags\",\n  \"byteorder\",\n- \"chalk-engine\",\n  \"jobserver\",\n  \"log\",\n  \"measureme\",\n@@ -4144,7 +4124,6 @@ checksum = \"b725dadae9fabc488df69a287f5a99c5eaf5d10853842a8a3dfac52476f544ee\"\n name = \"rustc_traits\"\n version = \"0.0.0\"\n dependencies = [\n- \"chalk-engine\",\n  \"log\",\n  \"rustc\",\n  \"rustc_ast\","}, {"sha": "9d6e05130e179c0dbaf60ccffb0a9a3b9d4f53cf", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "patch": "@@ -33,7 +33,6 @@ rustc_span = { path = \"../librustc_span\" }\n backtrace = \"0.3.40\"\n parking_lot = \"0.9\"\n byteorder = { version = \"1.3\" }\n-chalk-engine = { version = \"0.9.0\", default-features=false }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"0.7.1\"\n rustc_session = { path = \"../librustc_session\" }"}, {"sha": "9277f5a380b4072031387968eb3345716bef99b2", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "patch": "@@ -1130,16 +1130,6 @@ rustc_queries! {\n             desc { \"evaluating trait selection obligation `{}`\", goal.value.value }\n         }\n \n-        query evaluate_goal(\n-            goal: traits::ChalkCanonicalGoal<'tcx>\n-        ) -> Result<\n-            &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n-            NoSolution\n-        > {\n-            no_force\n-            desc { \"evaluating trait selection obligation `{}`\", goal.value.goal }\n-        }\n-\n         /// Do not call this query directly: part of the `Eq` type-op\n         query type_op_ascribe_user_type(\n             goal: CanonicalTypeOpAscribeUserTypeGoal<'tcx>"}, {"sha": "4e02a1744ff34846aee64f66607c487eb4a5354e", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "patch": "@@ -7,9 +7,7 @@ pub mod select;\n pub mod specialization_graph;\n mod structural_impls;\n \n-use crate::infer::canonical::Canonical;\n use crate::mir::interpret::ErrorHandled;\n-use crate::ty::fold::{TypeFolder, TypeVisitor};\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtKind, List, Ty, TyCtxt};\n \n@@ -25,8 +23,6 @@ use std::rc::Rc;\n \n pub use self::select::{EvaluationCache, EvaluationResult, OverflowError, SelectionCache};\n \n-pub type ChalkCanonicalGoal<'tcx> = Canonical<'tcx, InEnvironment<'tcx, ty::Predicate<'tcx>>>;\n-\n pub use self::ObligationCauseCode::*;\n pub use self::SelectionError::*;\n pub use self::Vtable::*;\n@@ -715,45 +711,6 @@ pub struct VtableTraitAliasData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-pub trait ExClauseFold<'tcx>\n-where\n-    Self: chalk_engine::context::Context + Clone,\n-{\n-    fn fold_ex_clause_with<F: TypeFolder<'tcx>>(\n-        ex_clause: &chalk_engine::ExClause<Self>,\n-        folder: &mut F,\n-    ) -> chalk_engine::ExClause<Self>;\n-\n-    fn visit_ex_clause_with<V: TypeVisitor<'tcx>>(\n-        ex_clause: &chalk_engine::ExClause<Self>,\n-        visitor: &mut V,\n-    ) -> bool;\n-}\n-\n-pub trait ChalkContextLift<'tcx>\n-where\n-    Self: chalk_engine::context::Context + Clone,\n-{\n-    type LiftedExClause: Debug + 'tcx;\n-    type LiftedDelayedLiteral: Debug + 'tcx;\n-    type LiftedLiteral: Debug + 'tcx;\n-\n-    fn lift_ex_clause_to_tcx(\n-        ex_clause: &chalk_engine::ExClause<Self>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedExClause>;\n-\n-    fn lift_delayed_literal_to_tcx(\n-        ex_clause: &chalk_engine::DelayedLiteral<Self>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedDelayedLiteral>;\n-\n-    fn lift_literal_to_tcx(\n-        ex_clause: &chalk_engine::Literal<Self>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedLiteral>;\n-}\n-\n #[derive(Clone, Debug, PartialEq, Eq, Hash, HashStable)]\n pub enum ObjectSafetyViolation {\n     /// `Self: Sized` declared on the trait."}, {"sha": "90b2134af12a7a09e5c50c63539de7f70dcc7e12", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "patch": "@@ -595,42 +595,6 @@ impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n     }\n }\n \n-impl<'tcx, C> Lift<'tcx> for chalk_engine::ExClause<C>\n-where\n-    C: chalk_engine::context::Context + Clone,\n-    C: traits::ChalkContextLift<'tcx>,\n-{\n-    type Lifted = C::LiftedExClause;\n-\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        <C as traits::ChalkContextLift>::lift_ex_clause_to_tcx(self, tcx)\n-    }\n-}\n-\n-impl<'tcx, C> Lift<'tcx> for chalk_engine::DelayedLiteral<C>\n-where\n-    C: chalk_engine::context::Context + Clone,\n-    C: traits::ChalkContextLift<'tcx>,\n-{\n-    type Lifted = C::LiftedDelayedLiteral;\n-\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        <C as traits::ChalkContextLift>::lift_delayed_literal_to_tcx(self, tcx)\n-    }\n-}\n-\n-impl<'tcx, C> Lift<'tcx> for chalk_engine::Literal<C>\n-where\n-    C: chalk_engine::context::Context + Clone,\n-    C: traits::ChalkContextLift<'tcx>,\n-{\n-    type Lifted = C::LiftedLiteral;\n-\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        <C as traits::ChalkContextLift>::lift_literal_to_tcx(self, tcx)\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n \n@@ -674,39 +638,3 @@ impl<'tcx> TypeFoldable<'tcx> for traits::Clauses<'tcx> {\n         self.iter().any(|t| t.visit_with(visitor))\n     }\n }\n-\n-impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::ExClause<C>\n-where\n-    C: traits::ExClauseFold<'tcx>,\n-    C::Substitution: Clone,\n-    C::RegionConstraint: Clone,\n-{\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        <C as traits::ExClauseFold>::fold_ex_clause_with(self, folder)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        <C as traits::ExClauseFold>::visit_ex_clause_with(self, visitor)\n-    }\n-}\n-\n-EnumTypeFoldableImpl! {\n-    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::DelayedLiteral<C> {\n-        (chalk_engine::DelayedLiteral::CannotProve)(a),\n-        (chalk_engine::DelayedLiteral::Negative)(a),\n-        (chalk_engine::DelayedLiteral::Positive)(a, b),\n-    } where\n-        C: chalk_engine::context::Context<CanonicalConstrainedSubst: TypeFoldable<'tcx>> + Clone,\n-}\n-\n-EnumTypeFoldableImpl! {\n-    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::Literal<C> {\n-        (chalk_engine::Literal::Negative)(a),\n-        (chalk_engine::Literal::Positive)(a),\n-    } where\n-        C: chalk_engine::context::Context<GoalInEnvironment: Clone + TypeFoldable<'tcx>> + Clone,\n-}\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    chalk_engine::TableIndex,\n-}"}, {"sha": "4d3f25290e1ab77f992a9e2f9afbaf6465c92cbe", "filename": "src/librustc_infer/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "patch": "@@ -357,10 +357,8 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     // `TyVar(vid)` is unresolved, track its universe index in the canonicalized\n                     // result.\n                     Err(mut ui) => {\n-                        if !self.infcx.unwrap().tcx.sess.opts.debugging_opts.chalk {\n-                            // FIXME: perf problem described in #55921.\n-                            ui = ty::UniverseIndex::ROOT;\n-                        }\n+                        // FIXME: perf problem described in #55921.\n+                        ui = ty::UniverseIndex::ROOT;\n                         self.canonicalize_ty_var(\n                             CanonicalVarInfo {\n                                 kind: CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n@@ -447,10 +445,8 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     // `ConstVar(vid)` is unresolved, track its universe index in the\n                     // canonicalized result\n                     Err(mut ui) => {\n-                        if !self.infcx.unwrap().tcx.sess.opts.debugging_opts.chalk {\n-                            // FIXME: perf problem described in #55921.\n-                            ui = ty::UniverseIndex::ROOT;\n-                        }\n+                        // FIXME: perf problem described in #55921.\n+                        ui = ty::UniverseIndex::ROOT;\n                         return self.canonicalize_const_var(\n                             CanonicalVarInfo { kind: CanonicalVarKind::Const(ui) },\n                             ct,"}, {"sha": "82fa683a290c5d6f7b16c602996295651e86f1ce", "filename": "src/librustc_infer/traits/chalk_fulfill.rs", "status": "removed", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_infer%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_infer%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fchalk_fulfill.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,159 +0,0 @@\n-use crate::infer::canonical::OriginalQueryValues;\n-use crate::infer::InferCtxt;\n-use crate::traits::query::NoSolution;\n-use crate::traits::{\n-    Environment, FulfillmentError, FulfillmentErrorCode, InEnvironment, ObligationCause,\n-    PredicateObligation, SelectionError, TraitEngine,\n-};\n-use rustc::ty::{self, Ty};\n-use rustc_data_structures::fx::FxHashSet;\n-\n-pub use rustc::traits::ChalkCanonicalGoal as CanonicalGoal;\n-\n-pub struct FulfillmentContext<'tcx> {\n-    obligations: FxHashSet<InEnvironment<'tcx, PredicateObligation<'tcx>>>,\n-}\n-\n-impl FulfillmentContext<'tcx> {\n-    crate fn new() -> Self {\n-        FulfillmentContext { obligations: FxHashSet::default() }\n-    }\n-}\n-\n-fn in_environment(\n-    infcx: &InferCtxt<'_, 'tcx>,\n-    obligation: PredicateObligation<'tcx>,\n-) -> InEnvironment<'tcx, PredicateObligation<'tcx>> {\n-    assert!(!infcx.is_in_snapshot());\n-    let obligation = infcx.resolve_vars_if_possible(&obligation);\n-\n-    let environment = match obligation.param_env.def_id {\n-        Some(def_id) => infcx.tcx.environment(def_id),\n-        None if obligation.param_env.caller_bounds.is_empty() => {\n-            Environment { clauses: ty::List::empty() }\n-        }\n-        _ => bug!(\"non-empty `ParamEnv` with no def-id\"),\n-    };\n-\n-    InEnvironment { environment, goal: obligation }\n-}\n-\n-impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n-    fn normalize_projection_type(\n-        &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        _param_env: ty::ParamEnv<'tcx>,\n-        projection_ty: ty::ProjectionTy<'tcx>,\n-        _cause: ObligationCause<'tcx>,\n-    ) -> Ty<'tcx> {\n-        infcx.tcx.mk_ty(ty::Projection(projection_ty))\n-    }\n-\n-    fn register_predicate_obligation(\n-        &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        obligation: PredicateObligation<'tcx>,\n-    ) {\n-        self.obligations.insert(in_environment(infcx, obligation));\n-    }\n-\n-    fn select_all_or_error(\n-        &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n-        self.select_where_possible(infcx)?;\n-\n-        if self.obligations.is_empty() {\n-            Ok(())\n-        } else {\n-            let errors = self\n-                .obligations\n-                .iter()\n-                .map(|obligation| FulfillmentError {\n-                    obligation: obligation.goal.clone(),\n-                    code: FulfillmentErrorCode::CodeAmbiguity,\n-                    points_at_arg_span: false,\n-                })\n-                .collect();\n-            Err(errors)\n-        }\n-    }\n-\n-    fn select_where_possible(\n-        &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n-        let mut errors = Vec::new();\n-        let mut next_round = FxHashSet::default();\n-        let mut making_progress;\n-\n-        loop {\n-            making_progress = false;\n-\n-            // We iterate over all obligations, and record if we are able\n-            // to unambiguously prove at least one obligation.\n-            for obligation in self.obligations.drain() {\n-                let mut orig_values = OriginalQueryValues::default();\n-                let canonical_goal = infcx.canonicalize_query(\n-                    &InEnvironment {\n-                        environment: obligation.environment,\n-                        goal: obligation.goal.predicate,\n-                    },\n-                    &mut orig_values,\n-                );\n-\n-                match infcx.tcx.evaluate_goal(canonical_goal) {\n-                    Ok(response) => {\n-                        if response.is_proven() {\n-                            making_progress = true;\n-\n-                            match infcx.instantiate_query_response_and_region_obligations(\n-                                &obligation.goal.cause,\n-                                obligation.goal.param_env,\n-                                &orig_values,\n-                                &response,\n-                            ) {\n-                                Ok(infer_ok) => next_round.extend(\n-                                    infer_ok\n-                                        .obligations\n-                                        .into_iter()\n-                                        .map(|obligation| in_environment(infcx, obligation)),\n-                                ),\n-\n-                                Err(_err) => errors.push(FulfillmentError {\n-                                    obligation: obligation.goal,\n-                                    code: FulfillmentErrorCode::CodeSelectionError(\n-                                        SelectionError::Unimplemented,\n-                                    ),\n-                                    points_at_arg_span: false,\n-                                }),\n-                            }\n-                        } else {\n-                            // Ambiguous: retry at next round.\n-                            next_round.insert(obligation);\n-                        }\n-                    }\n-\n-                    Err(NoSolution) => errors.push(FulfillmentError {\n-                        obligation: obligation.goal,\n-                        code: FulfillmentErrorCode::CodeSelectionError(\n-                            SelectionError::Unimplemented,\n-                        ),\n-                        points_at_arg_span: false,\n-                    }),\n-                }\n-            }\n-            next_round = std::mem::replace(&mut self.obligations, next_round);\n-\n-            if !making_progress {\n-                break;\n-            }\n-        }\n-\n-        if errors.is_empty() { Ok(()) } else { Err(errors) }\n-    }\n-\n-    fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n-        self.obligations.iter().map(|obligation| obligation.goal.clone()).collect()\n-    }\n-}"}, {"sha": "e23810dd1612da5bfa5af373367c4dd7fb506e4a", "filename": "src/librustc_infer/traits/engine.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_infer%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_infer%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fengine.rs?ref=b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "patch": "@@ -3,7 +3,7 @@ use crate::traits::Obligation;\n use rustc::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_hir::def_id::DefId;\n \n-use super::{ChalkFulfillmentContext, FulfillmentContext, FulfillmentError};\n+use super::{FulfillmentContext, FulfillmentError};\n use super::{ObligationCause, PredicateObligation};\n \n pub trait TraitEngine<'tcx>: 'tcx {\n@@ -78,11 +78,7 @@ impl<T: ?Sized + TraitEngine<'tcx>> TraitEngineExt<'tcx> for T {\n }\n \n impl dyn TraitEngine<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>) -> Box<Self> {\n-        if tcx.sess.opts.debugging_opts.chalk {\n-            Box::new(ChalkFulfillmentContext::new())\n-        } else {\n-            Box::new(FulfillmentContext::new())\n-        }\n+    pub fn new(_tcx: TyCtxt<'tcx>) -> Box<Self> {\n+        Box::new(FulfillmentContext::new())\n     }\n }"}, {"sha": "63c3f827c2ecb246ec0ac207d47709d94a85320a", "filename": "src/librustc_infer/traits/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "patch": "@@ -812,21 +812,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n \n                     ty::Predicate::WellFormed(ty) => {\n-                        if !self.tcx.sess.opts.debugging_opts.chalk {\n-                            // WF predicates cannot themselves make\n-                            // errors. They can only block due to\n-                            // ambiguity; otherwise, they always\n-                            // degenerate into other obligations\n-                            // (which may fail).\n-                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n-                        } else {\n-                            // FIXME: we'll need a better message which takes into account\n-                            // which bounds actually failed to hold.\n-                            self.tcx.sess.struct_span_err(\n-                                span,\n-                                &format!(\"the type `{}` is not well-formed (chalk)\", ty),\n-                            )\n-                        }\n+                        // WF predicates cannot themselves make\n+                        // errors. They can only block due to\n+                        // ambiguity; otherwise, they always\n+                        // degenerate into other obligations\n+                        // (which may fail).\n+                        span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n                     }\n \n                     ty::Predicate::ConstEvaluatable(..) => {"}, {"sha": "61702d74f1a91425dbdc6f754355f980f565783a", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "patch": "@@ -4,7 +4,6 @@\n \n #[allow(dead_code)]\n pub mod auto_trait;\n-mod chalk_fulfill;\n pub mod codegen;\n mod coherence;\n mod engine;\n@@ -74,10 +73,6 @@ pub use self::util::{\n     supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,\n };\n \n-pub use self::chalk_fulfill::{\n-    CanonicalGoal as ChalkCanonicalGoal, FulfillmentContext as ChalkFulfillmentContext,\n-};\n-\n pub use rustc::traits::*;\n \n /// Whether to skip the leak check, as part of a future compatibility warning step."}, {"sha": "4c312c9fce259f39711a7556e70792ecc87af49b", "filename": "src/librustc_infer/traits/select.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_infer%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_infer%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fselect.rs?ref=b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "patch": "@@ -2917,15 +2917,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             trait_ref,\n         )?);\n \n-        // FIXME: Chalk\n-\n-        if !self.tcx().sess.opts.debugging_opts.chalk {\n-            obligations.push(Obligation::new(\n-                obligation.cause.clone(),\n-                obligation.param_env,\n-                ty::Predicate::ClosureKind(closure_def_id, substs, kind),\n-            ));\n-        }\n+        obligations.push(Obligation::new(\n+            obligation.cause.clone(),\n+            obligation.param_env,\n+            ty::Predicate::ClosureKind(closure_def_id, substs, kind),\n+        ));\n \n         Ok(VtableClosureData { closure_def_id, substs: substs, nested: obligations })\n     }"}, {"sha": "a1ecf4e8528beff31ca17171251a398c3e366498", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "patch": "@@ -922,8 +922,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"tell the linker to strip debuginfo when building without debuginfo enabled.\"),\n     share_generics: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"make the current crate share its generic instantiations\"),\n-    chalk: bool = (false, parse_bool, [TRACKED],\n-        \"enable the experimental Chalk-based trait solving engine\"),\n     no_parallel_llvm: bool = (false, parse_bool, [UNTRACKED],\n         \"don't run LLVM in parallel (while keeping codegen-units and ThinLTO)\"),\n     no_leak_check: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "0dc3ad2983333cea13ecd8715434b981aff0e545", "filename": "src/librustc_traits/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "patch": "@@ -17,6 +17,5 @@ rustc_macros = { path = \"../librustc_macros\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n-chalk-engine = { version = \"0.9.0\", default-features=false }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_infer = { path = \"../librustc_infer\" }"}, {"sha": "240a93f0900a4605fd4cee7b6a47992a279601ba", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "removed", "additions": 0, "deletions": 638, "changes": 638, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,638 +0,0 @@\n-mod program_clauses;\n-mod resolvent_ops;\n-mod unify;\n-\n-use chalk_engine::fallible::Fallible;\n-use chalk_engine::forest::Forest;\n-use chalk_engine::{context, hh::HhGoal, DelayedLiteral, ExClause, Literal};\n-use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use rustc::ty::query::Providers;\n-use rustc::ty::subst::{GenericArg, GenericArgKind};\n-use rustc::ty::{self, TyCtxt};\n-use rustc_infer::infer::canonical::{\n-    Canonical, CanonicalVarValues, Certainty, OriginalQueryValues, QueryRegionConstraints,\n-    QueryResponse,\n-};\n-use rustc_infer::infer::{InferCtxt, LateBoundRegionConversionTime, TyCtxtInferExt};\n-use rustc_infer::traits::{\n-    self, ChalkCanonicalGoal, ChalkContextLift, Clause, DomainGoal, Environment, ExClauseFold,\n-    Goal, GoalKind, InEnvironment, QuantifierKind,\n-};\n-use rustc_macros::{Lift, TypeFoldable};\n-use rustc_span::DUMMY_SP;\n-\n-use std::fmt::{self, Debug};\n-use std::marker::PhantomData;\n-\n-use self::unify::*;\n-\n-#[derive(Copy, Clone, Debug)]\n-crate struct ChalkArenas<'tcx> {\n-    _phantom: PhantomData<&'tcx ()>,\n-}\n-\n-#[derive(Copy, Clone)]\n-crate struct ChalkContext<'tcx> {\n-    _arenas: ChalkArenas<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-#[derive(Copy, Clone)]\n-crate struct ChalkInferenceContext<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-crate struct UniverseMap;\n-\n-crate type RegionConstraint<'tcx> = ty::OutlivesPredicate<GenericArg<'tcx>, ty::Region<'tcx>>;\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, TypeFoldable, Lift)]\n-crate struct ConstrainedSubst<'tcx> {\n-    subst: CanonicalVarValues<'tcx>,\n-    constraints: Vec<RegionConstraint<'tcx>>,\n-}\n-\n-impl context::Context for ChalkArenas<'tcx> {\n-    type CanonicalExClause = Canonical<'tcx, ChalkExClause<'tcx>>;\n-\n-    type CanonicalGoalInEnvironment = Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>;\n-\n-    // u-canonicalization not yet implemented\n-    type UCanonicalGoalInEnvironment = Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>;\n-\n-    type CanonicalConstrainedSubst = Canonical<'tcx, ConstrainedSubst<'tcx>>;\n-\n-    // u-canonicalization not yet implemented\n-    type UniverseMap = UniverseMap;\n-\n-    type Solution = Canonical<'tcx, QueryResponse<'tcx, ()>>;\n-\n-    type InferenceNormalizedSubst = CanonicalVarValues<'tcx>;\n-\n-    type GoalInEnvironment = InEnvironment<'tcx, Goal<'tcx>>;\n-\n-    type RegionConstraint = RegionConstraint<'tcx>;\n-\n-    type Substitution = CanonicalVarValues<'tcx>;\n-\n-    type Environment = Environment<'tcx>;\n-\n-    type Goal = Goal<'tcx>;\n-\n-    type DomainGoal = DomainGoal<'tcx>;\n-\n-    type BindersGoal = ty::Binder<Goal<'tcx>>;\n-\n-    type Parameter = GenericArg<'tcx>;\n-\n-    type ProgramClause = Clause<'tcx>;\n-\n-    type ProgramClauses = Vec<Clause<'tcx>>;\n-\n-    type UnificationResult = UnificationResult<'tcx>;\n-\n-    type Variance = ty::Variance;\n-\n-    fn goal_in_environment(\n-        env: &Environment<'tcx>,\n-        goal: Goal<'tcx>,\n-    ) -> InEnvironment<'tcx, Goal<'tcx>> {\n-        env.with(goal)\n-    }\n-}\n-\n-impl context::AggregateOps<ChalkArenas<'tcx>> for ChalkContext<'tcx> {\n-    fn make_solution(\n-        &self,\n-        root_goal: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n-        mut simplified_answers: impl context::AnswerStream<ChalkArenas<'tcx>>,\n-    ) -> Option<Canonical<'tcx, QueryResponse<'tcx, ()>>> {\n-        use chalk_engine::SimplifiedAnswer;\n-\n-        debug!(\"make_solution(root_goal = {:?})\", root_goal);\n-\n-        if simplified_answers.peek_answer().is_none() {\n-            return None;\n-        }\n-\n-        let SimplifiedAnswer { subst: constrained_subst, ambiguous } =\n-            simplified_answers.next_answer().unwrap();\n-\n-        debug!(\"make_solution: ambiguous flag = {}\", ambiguous);\n-\n-        let ambiguous = simplified_answers.peek_answer().is_some() || ambiguous;\n-\n-        let solution = constrained_subst.unchecked_map(|cs| match ambiguous {\n-            true => QueryResponse {\n-                var_values: cs.subst.make_identity(self.tcx),\n-                region_constraints: QueryRegionConstraints::default(),\n-                certainty: Certainty::Ambiguous,\n-                value: (),\n-            },\n-\n-            false => QueryResponse {\n-                var_values: cs.subst,\n-                region_constraints: QueryRegionConstraints::default(),\n-\n-                // FIXME: restore this later once we get better at handling regions\n-                // region_constraints: cs.constraints\n-                //     .into_iter()\n-                //     .map(|c| ty::Binder::bind(c))\n-                //     .collect(),\n-                certainty: Certainty::Proven,\n-                value: (),\n-            },\n-        });\n-\n-        debug!(\"make_solution: solution = {:?}\", solution);\n-\n-        Some(solution)\n-    }\n-}\n-\n-impl context::ContextOps<ChalkArenas<'tcx>> for ChalkContext<'tcx> {\n-    /// Returns `true` if this is a coinductive goal: basically proving that an auto trait\n-    /// is implemented or proving that a trait reference is well-formed.\n-    fn is_coinductive(&self, goal: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>) -> bool {\n-        use rustc::traits::{WellFormed, WhereClause};\n-\n-        let mut goal = goal.value.goal;\n-        loop {\n-            match goal {\n-                GoalKind::DomainGoal(domain_goal) => match domain_goal {\n-                    DomainGoal::WellFormed(WellFormed::Trait(..)) => return true,\n-                    DomainGoal::Holds(WhereClause::Implemented(trait_predicate)) => {\n-                        return self.tcx.trait_is_auto(trait_predicate.def_id());\n-                    }\n-                    _ => return false,\n-                },\n-\n-                GoalKind::Quantified(_, bound_goal) => goal = *bound_goal.skip_binder(),\n-                _ => return false,\n-            }\n-        }\n-    }\n-\n-    /// Creates an inference table for processing a new goal and instantiate that goal\n-    /// in that context, returning \"all the pieces\".\n-    ///\n-    /// More specifically: given a u-canonical goal `arg`, creates a\n-    /// new inference table `T` and populates it with the universes\n-    /// found in `arg`. Then, creates a substitution `S` that maps\n-    /// each bound variable in `arg` to a fresh inference variable\n-    /// from T. Returns:\n-    ///\n-    /// - the table `T`,\n-    /// - the substitution `S`,\n-    /// - the environment and goal found by substitution `S` into `arg`.\n-    fn instantiate_ucanonical_goal<R>(\n-        &self,\n-        arg: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n-        op: impl context::WithInstantiatedUCanonicalGoal<ChalkArenas<'tcx>, Output = R>,\n-    ) -> R {\n-        self.tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, arg, |ref infcx, arg, subst| {\n-            let chalk_infcx = &mut ChalkInferenceContext { infcx };\n-            op.with(chalk_infcx, subst, arg.environment, arg.goal)\n-        })\n-    }\n-\n-    fn instantiate_ex_clause<R>(\n-        &self,\n-        _num_universes: usize,\n-        arg: &Canonical<'tcx, ChalkExClause<'tcx>>,\n-        op: impl context::WithInstantiatedExClause<ChalkArenas<'tcx>, Output = R>,\n-    ) -> R {\n-        self.tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, &arg.upcast(), |ref infcx, arg, _| {\n-            let chalk_infcx = &mut ChalkInferenceContext { infcx };\n-            op.with(chalk_infcx, arg)\n-        })\n-    }\n-\n-    /// Returns `true` if this solution has no region constraints.\n-    fn empty_constraints(ccs: &Canonical<'tcx, ConstrainedSubst<'tcx>>) -> bool {\n-        ccs.value.constraints.is_empty()\n-    }\n-\n-    fn inference_normalized_subst_from_ex_clause(\n-        canon_ex_clause: &'a Canonical<'tcx, ChalkExClause<'tcx>>,\n-    ) -> &'a CanonicalVarValues<'tcx> {\n-        &canon_ex_clause.value.subst\n-    }\n-\n-    fn inference_normalized_subst_from_subst(\n-        canon_subst: &'a Canonical<'tcx, ConstrainedSubst<'tcx>>,\n-    ) -> &'a CanonicalVarValues<'tcx> {\n-        &canon_subst.value.subst\n-    }\n-\n-    fn canonical(\n-        u_canon: &'a Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n-    ) -> &'a Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>> {\n-        u_canon\n-    }\n-\n-    fn is_trivial_substitution(\n-        u_canon: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n-        canonical_subst: &Canonical<'tcx, ConstrainedSubst<'tcx>>,\n-    ) -> bool {\n-        let subst = &canonical_subst.value.subst;\n-        assert_eq!(u_canon.variables.len(), subst.var_values.len());\n-        subst.var_values.iter_enumerated().all(|(cvar, kind)| match kind.unpack() {\n-            GenericArgKind::Lifetime(r) => match r {\n-                &ty::ReLateBound(debruijn, br) => {\n-                    debug_assert_eq!(debruijn, ty::INNERMOST);\n-                    cvar == br.assert_bound_var()\n-                }\n-                _ => false,\n-            },\n-            GenericArgKind::Type(ty) => match ty.kind {\n-                ty::Bound(debruijn, bound_ty) => {\n-                    debug_assert_eq!(debruijn, ty::INNERMOST);\n-                    cvar == bound_ty.var\n-                }\n-                _ => false,\n-            },\n-            GenericArgKind::Const(ct) => match ct.val {\n-                ty::ConstKind::Bound(debruijn, bound_ct) => {\n-                    debug_assert_eq!(debruijn, ty::INNERMOST);\n-                    cvar == bound_ct\n-                }\n-                _ => false,\n-            },\n-        })\n-    }\n-\n-    fn num_universes(canon: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>) -> usize {\n-        canon.max_universe.index() + 1\n-    }\n-\n-    /// Convert a goal G *from* the canonical universes *into* our\n-    /// local universes. This will yield a goal G' that is the same\n-    /// but for the universes of universally quantified names.\n-    fn map_goal_from_canonical(\n-        _map: &UniverseMap,\n-        value: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n-    ) -> Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>> {\n-        *value // FIXME universe maps not implemented yet\n-    }\n-\n-    fn map_subst_from_canonical(\n-        _map: &UniverseMap,\n-        value: &Canonical<'tcx, ConstrainedSubst<'tcx>>,\n-    ) -> Canonical<'tcx, ConstrainedSubst<'tcx>> {\n-        value.clone() // FIXME universe maps not implemented yet\n-    }\n-}\n-\n-impl context::InferenceTable<ChalkArenas<'tcx>, ChalkArenas<'tcx>>\n-    for ChalkInferenceContext<'cx, 'tcx>\n-{\n-    fn into_goal(&self, domain_goal: DomainGoal<'tcx>) -> Goal<'tcx> {\n-        self.infcx.tcx.mk_goal(GoalKind::DomainGoal(domain_goal))\n-    }\n-\n-    fn cannot_prove(&self) -> Goal<'tcx> {\n-        self.infcx.tcx.mk_goal(GoalKind::CannotProve)\n-    }\n-\n-    fn into_hh_goal(&mut self, goal: Goal<'tcx>) -> ChalkHhGoal<'tcx> {\n-        match *goal {\n-            GoalKind::Implies(hypotheses, goal) => {\n-                HhGoal::Implies(hypotheses.iter().cloned().collect(), goal)\n-            }\n-            GoalKind::And(left, right) => HhGoal::And(left, right),\n-            GoalKind::Not(subgoal) => HhGoal::Not(subgoal),\n-            GoalKind::DomainGoal(d) => HhGoal::DomainGoal(d),\n-            GoalKind::Quantified(QuantifierKind::Universal, binder) => HhGoal::ForAll(binder),\n-            GoalKind::Quantified(QuantifierKind::Existential, binder) => HhGoal::Exists(binder),\n-            GoalKind::Subtype(a, b) => HhGoal::Unify(ty::Variance::Covariant, a.into(), b.into()),\n-            GoalKind::CannotProve => HhGoal::CannotProve,\n-        }\n-    }\n-\n-    fn add_clauses(\n-        &mut self,\n-        env: &Environment<'tcx>,\n-        clauses: Vec<Clause<'tcx>>,\n-    ) -> Environment<'tcx> {\n-        Environment {\n-            clauses: self\n-                .infcx\n-                .tcx\n-                .mk_clauses(env.clauses.iter().cloned().chain(clauses.into_iter())),\n-        }\n-    }\n-}\n-\n-impl context::TruncateOps<ChalkArenas<'tcx>, ChalkArenas<'tcx>>\n-    for ChalkInferenceContext<'cx, 'tcx>\n-{\n-    fn truncate_goal(\n-        &mut self,\n-        _subgoal: &InEnvironment<'tcx, Goal<'tcx>>,\n-    ) -> Option<InEnvironment<'tcx, Goal<'tcx>>> {\n-        None // FIXME we should truncate at some point!\n-    }\n-\n-    fn truncate_answer(\n-        &mut self,\n-        _subst: &CanonicalVarValues<'tcx>,\n-    ) -> Option<CanonicalVarValues<'tcx>> {\n-        None // FIXME we should truncate at some point!\n-    }\n-}\n-\n-impl context::UnificationOps<ChalkArenas<'tcx>, ChalkArenas<'tcx>>\n-    for ChalkInferenceContext<'cx, 'tcx>\n-{\n-    fn program_clauses(\n-        &self,\n-        environment: &Environment<'tcx>,\n-        goal: &DomainGoal<'tcx>,\n-    ) -> Vec<Clause<'tcx>> {\n-        self.program_clauses_impl(environment, goal)\n-    }\n-\n-    fn instantiate_binders_universally(&mut self, arg: &ty::Binder<Goal<'tcx>>) -> Goal<'tcx> {\n-        self.infcx.replace_bound_vars_with_placeholders(arg).0\n-    }\n-\n-    fn instantiate_binders_existentially(&mut self, arg: &ty::Binder<Goal<'tcx>>) -> Goal<'tcx> {\n-        self.infcx\n-            .replace_bound_vars_with_fresh_vars(\n-                DUMMY_SP,\n-                LateBoundRegionConversionTime::HigherRankedType,\n-                arg,\n-            )\n-            .0\n-    }\n-\n-    fn debug_ex_clause(&mut self, value: &'v ChalkExClause<'tcx>) -> Box<dyn Debug + 'v> {\n-        let string = format!(\"{:?}\", self.infcx.resolve_vars_if_possible(value));\n-        Box::new(string)\n-    }\n-\n-    fn canonicalize_goal(\n-        &mut self,\n-        value: &InEnvironment<'tcx, Goal<'tcx>>,\n-    ) -> Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>> {\n-        let mut _orig_values = OriginalQueryValues::default();\n-        self.infcx.canonicalize_query(value, &mut _orig_values)\n-    }\n-\n-    fn canonicalize_ex_clause(\n-        &mut self,\n-        value: &ChalkExClause<'tcx>,\n-    ) -> Canonical<'tcx, ChalkExClause<'tcx>> {\n-        self.infcx.canonicalize_response(value)\n-    }\n-\n-    fn canonicalize_constrained_subst(\n-        &mut self,\n-        subst: CanonicalVarValues<'tcx>,\n-        constraints: Vec<RegionConstraint<'tcx>>,\n-    ) -> Canonical<'tcx, ConstrainedSubst<'tcx>> {\n-        self.infcx.canonicalize_response(&ConstrainedSubst { subst, constraints })\n-    }\n-\n-    fn u_canonicalize_goal(\n-        &mut self,\n-        value: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n-    ) -> (Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>, UniverseMap) {\n-        (*value, UniverseMap)\n-    }\n-\n-    fn invert_goal(\n-        &mut self,\n-        _value: &InEnvironment<'tcx, Goal<'tcx>>,\n-    ) -> Option<InEnvironment<'tcx, Goal<'tcx>>> {\n-        panic!(\"goal inversion not yet implemented\")\n-    }\n-\n-    fn unify_parameters(\n-        &mut self,\n-        environment: &Environment<'tcx>,\n-        variance: ty::Variance,\n-        a: &GenericArg<'tcx>,\n-        b: &GenericArg<'tcx>,\n-    ) -> Fallible<UnificationResult<'tcx>> {\n-        self.infcx.commit_if_ok(|_| {\n-            unify(self.infcx, *environment, variance, a, b)\n-                .map_err(|_| chalk_engine::fallible::NoSolution)\n-        })\n-    }\n-\n-    fn sink_answer_subset(\n-        &self,\n-        value: &Canonical<'tcx, ConstrainedSubst<'tcx>>,\n-    ) -> Canonical<'tcx, ConstrainedSubst<'tcx>> {\n-        value.clone()\n-    }\n-\n-    fn lift_delayed_literal(\n-        &self,\n-        value: DelayedLiteral<ChalkArenas<'tcx>>,\n-    ) -> DelayedLiteral<ChalkArenas<'tcx>> {\n-        match self.infcx.tcx.lift(&value) {\n-            Some(literal) => literal,\n-            None => bug!(\"cannot lift {:?}\", value),\n-        }\n-    }\n-\n-    fn into_ex_clause(\n-        &mut self,\n-        result: UnificationResult<'tcx>,\n-        ex_clause: &mut ChalkExClause<'tcx>,\n-    ) {\n-        into_ex_clause(result, ex_clause);\n-    }\n-}\n-\n-crate fn into_ex_clause(result: UnificationResult<'tcx>, ex_clause: &mut ChalkExClause<'tcx>) {\n-    ex_clause.subgoals.extend(result.goals.into_iter().map(Literal::Positive));\n-\n-    // FIXME: restore this later once we get better at handling regions\n-    let _ = result.constraints.len(); // trick `-D dead-code`\n-    // ex_clause.constraints.extend(result.constraints);\n-}\n-\n-type ChalkHhGoal<'tcx> = HhGoal<ChalkArenas<'tcx>>;\n-\n-type ChalkExClause<'tcx> = ExClause<ChalkArenas<'tcx>>;\n-\n-impl Debug for ChalkContext<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"ChalkContext\")\n-    }\n-}\n-\n-impl Debug for ChalkInferenceContext<'cx, 'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"ChalkInferenceContext\")\n-    }\n-}\n-\n-impl ChalkContextLift<'tcx> for ChalkArenas<'a> {\n-    type LiftedExClause = ChalkExClause<'tcx>;\n-    type LiftedDelayedLiteral = DelayedLiteral<ChalkArenas<'tcx>>;\n-    type LiftedLiteral = Literal<ChalkArenas<'tcx>>;\n-\n-    fn lift_ex_clause_to_tcx(\n-        ex_clause: &ChalkExClause<'a>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedExClause> {\n-        Some(ChalkExClause {\n-            subst: tcx.lift(&ex_clause.subst)?,\n-            delayed_literals: tcx.lift(&ex_clause.delayed_literals)?,\n-            constraints: tcx.lift(&ex_clause.constraints)?,\n-            subgoals: tcx.lift(&ex_clause.subgoals)?,\n-        })\n-    }\n-\n-    fn lift_delayed_literal_to_tcx(\n-        literal: &DelayedLiteral<ChalkArenas<'a>>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedDelayedLiteral> {\n-        Some(match literal {\n-            DelayedLiteral::CannotProve(()) => DelayedLiteral::CannotProve(()),\n-            DelayedLiteral::Negative(index) => DelayedLiteral::Negative(*index),\n-            DelayedLiteral::Positive(index, subst) => {\n-                DelayedLiteral::Positive(*index, tcx.lift(subst)?)\n-            }\n-        })\n-    }\n-\n-    fn lift_literal_to_tcx(\n-        literal: &Literal<ChalkArenas<'a>>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedLiteral> {\n-        Some(match literal {\n-            Literal::Negative(goal) => Literal::Negative(tcx.lift(goal)?),\n-            Literal::Positive(goal) => Literal::Positive(tcx.lift(goal)?),\n-        })\n-    }\n-}\n-\n-impl ExClauseFold<'tcx> for ChalkArenas<'tcx> {\n-    fn fold_ex_clause_with<F: TypeFolder<'tcx>>(\n-        ex_clause: &ChalkExClause<'tcx>,\n-        folder: &mut F,\n-    ) -> ChalkExClause<'tcx> {\n-        ExClause {\n-            subst: ex_clause.subst.fold_with(folder),\n-            delayed_literals: ex_clause.delayed_literals.fold_with(folder),\n-            constraints: ex_clause.constraints.fold_with(folder),\n-            subgoals: ex_clause.subgoals.fold_with(folder),\n-        }\n-    }\n-\n-    fn visit_ex_clause_with<V: TypeVisitor<'tcx>>(\n-        ex_clause: &ExClause<Self>,\n-        visitor: &mut V,\n-    ) -> bool {\n-        let ExClause { subst, delayed_literals, constraints, subgoals } = ex_clause;\n-        subst.visit_with(visitor)\n-            || delayed_literals.visit_with(visitor)\n-            || constraints.visit_with(visitor)\n-            || subgoals.visit_with(visitor)\n-    }\n-}\n-\n-trait Upcast<'tcx>: 'tcx {\n-    type Upcasted: 'tcx;\n-\n-    fn upcast(&self) -> Self::Upcasted;\n-}\n-\n-impl<'tcx> Upcast<'tcx> for DelayedLiteral<ChalkArenas<'tcx>> {\n-    type Upcasted = DelayedLiteral<ChalkArenas<'tcx>>;\n-\n-    fn upcast(&self) -> Self::Upcasted {\n-        match self {\n-            &DelayedLiteral::CannotProve(..) => DelayedLiteral::CannotProve(()),\n-            &DelayedLiteral::Negative(index) => DelayedLiteral::Negative(index),\n-            DelayedLiteral::Positive(index, subst) => {\n-                DelayedLiteral::Positive(*index, subst.clone())\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> Upcast<'tcx> for Literal<ChalkArenas<'tcx>> {\n-    type Upcasted = Literal<ChalkArenas<'tcx>>;\n-\n-    fn upcast(&self) -> Self::Upcasted {\n-        match self {\n-            &Literal::Negative(goal) => Literal::Negative(goal),\n-            &Literal::Positive(goal) => Literal::Positive(goal),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Upcast<'tcx> for ExClause<ChalkArenas<'tcx>> {\n-    type Upcasted = ExClause<ChalkArenas<'tcx>>;\n-\n-    fn upcast(&self) -> Self::Upcasted {\n-        ExClause {\n-            subst: self.subst.clone(),\n-            delayed_literals: self.delayed_literals.iter().map(|l| l.upcast()).collect(),\n-            constraints: self.constraints.clone(),\n-            subgoals: self.subgoals.iter().map(|g| g.upcast()).collect(),\n-        }\n-    }\n-}\n-\n-impl<'tcx, T> Upcast<'tcx> for Canonical<'tcx, T>\n-where\n-    T: Upcast<'tcx>,\n-{\n-    type Upcasted = Canonical<'tcx, T::Upcasted>;\n-\n-    fn upcast(&self) -> Self::Upcasted {\n-        Canonical {\n-            max_universe: self.max_universe,\n-            value: self.value.upcast(),\n-            variables: self.variables,\n-        }\n-    }\n-}\n-\n-crate fn provide(p: &mut Providers<'_>) {\n-    *p = Providers { evaluate_goal, ..*p };\n-}\n-\n-crate fn evaluate_goal<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    goal: ChalkCanonicalGoal<'tcx>,\n-) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, traits::query::NoSolution> {\n-    use crate::lowering::Lower;\n-    use rustc::traits::WellFormed;\n-\n-    let goal = goal.unchecked_map(|goal| InEnvironment {\n-        environment: goal.environment,\n-        goal: match goal.goal {\n-            ty::Predicate::WellFormed(ty) => {\n-                tcx.mk_goal(GoalKind::DomainGoal(DomainGoal::WellFormed(WellFormed::Ty(ty))))\n-            }\n-\n-            ty::Predicate::Subtype(predicate) => tcx.mk_goal(GoalKind::Quantified(\n-                QuantifierKind::Universal,\n-                predicate.map_bound(|pred| tcx.mk_goal(GoalKind::Subtype(pred.a, pred.b))),\n-            )),\n-\n-            other => tcx.mk_goal(GoalKind::from_poly_domain_goal(other.lower(), tcx)),\n-        },\n-    });\n-\n-    debug!(\"evaluate_goal(goal = {:?})\", goal);\n-\n-    let context = ChalkContext { _arenas: ChalkArenas { _phantom: PhantomData }, tcx };\n-\n-    let mut forest = Forest::new(context);\n-    let solution = forest.solve(&goal);\n-\n-    debug!(\"evaluate_goal: solution = {:?}\", solution);\n-\n-    solution.map(|ok| Ok(&*tcx.arena.alloc(ok))).unwrap_or(Err(traits::query::NoSolution))\n-}"}, {"sha": "7512cbbd88218e410c68c1ae6a1e011de1c41866", "filename": "src/librustc_traits/chalk_context/program_clauses/builtin.rs", "status": "removed", "additions": 0, "deletions": 316, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,316 +0,0 @@\n-use crate::generic_types;\n-use crate::lowering::Lower;\n-use rustc::traits::{Clause, GoalKind, ProgramClause, ProgramClauseCategory};\n-use rustc::ty::subst::{GenericArg, InternalSubsts, Subst};\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-\n-/// Returns a predicate of the form\n-/// `Implemented(ty: Trait) :- Implemented(nested: Trait)...`\n-/// where `Trait` is specified by `trait_def_id`.\n-fn builtin_impl_clause(\n-    tcx: TyCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n-    nested: &[GenericArg<'tcx>],\n-    trait_def_id: DefId,\n-) -> ProgramClause<'tcx> {\n-    ProgramClause {\n-        goal: ty::TraitPredicate {\n-            trait_ref: ty::TraitRef { def_id: trait_def_id, substs: tcx.mk_substs_trait(ty, &[]) },\n-        }\n-        .lower(),\n-        hypotheses: tcx.mk_goals(\n-            nested\n-                .iter()\n-                .cloned()\n-                .map(|nested_ty| ty::TraitRef {\n-                    def_id: trait_def_id,\n-                    substs: tcx.mk_substs_trait(nested_ty.expect_ty(), &[]),\n-                })\n-                .map(|trait_ref| ty::TraitPredicate { trait_ref })\n-                .map(|pred| GoalKind::DomainGoal(pred.lower()))\n-                .map(|goal_kind| tcx.mk_goal(goal_kind)),\n-        ),\n-        category: ProgramClauseCategory::Other,\n-    }\n-}\n-\n-crate fn assemble_builtin_unsize_impls<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    unsize_def_id: DefId,\n-    source: Ty<'tcx>,\n-    target: Ty<'tcx>,\n-    clauses: &mut Vec<Clause<'tcx>>,\n-) {\n-    match (&source.kind, &target.kind) {\n-        (ty::Dynamic(data_a, ..), ty::Dynamic(data_b, ..)) => {\n-            if data_a.principal_def_id() != data_b.principal_def_id()\n-                || data_b.auto_traits().any(|b| data_a.auto_traits().all(|a| a != b))\n-            {\n-                return;\n-            }\n-\n-            // FIXME: rules for trait upcast\n-        }\n-\n-        (_, &ty::Dynamic(..)) => {\n-            // FIXME: basically, we should have something like:\n-            // ```\n-            // forall<T> {\n-            //     Implemented(T: Unsize< for<...> dyn Trait<...> >) :-\n-            //         for<...> Implemented(T: Trait<...>).\n-            // }\n-            // ```\n-            // The question is: how to correctly handle the higher-ranked\n-            // `for<...>` binder in order to have a generic rule?\n-            // (Having generic rules is useful for caching, as we may be able\n-            // to turn this function and others into tcx queries later on).\n-        }\n-\n-        (ty::Array(_, length), ty::Slice(_)) => {\n-            let ty_param = generic_types::bound(tcx, 0);\n-            let array_ty = tcx.mk_ty(ty::Array(ty_param, length));\n-            let slice_ty = tcx.mk_ty(ty::Slice(ty_param));\n-\n-            // `forall<T> { Implemented([T; N]: Unsize<[T]>). }`\n-            let clause = ProgramClause {\n-                goal: ty::TraitPredicate {\n-                    trait_ref: ty::TraitRef {\n-                        def_id: unsize_def_id,\n-                        substs: tcx.mk_substs_trait(array_ty, &[slice_ty.into()]),\n-                    },\n-                }\n-                .lower(),\n-                hypotheses: ty::List::empty(),\n-                category: ProgramClauseCategory::Other,\n-            };\n-\n-            clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n-        }\n-\n-        (ty::Infer(ty::TyVar(_)), _) | (_, ty::Infer(ty::TyVar(_))) => {\n-            // FIXME: ambiguous\n-        }\n-\n-        (ty::Adt(def_id_a, ..), ty::Adt(def_id_b, ..)) => {\n-            if def_id_a != def_id_b {\n-                return;\n-            }\n-\n-            // FIXME: rules for struct unsizing\n-        }\n-\n-        (&ty::Tuple(tys_a), &ty::Tuple(tys_b)) => {\n-            if tys_a.len() != tys_b.len() {\n-                return;\n-            }\n-\n-            // FIXME: rules for tuple unsizing\n-        }\n-\n-        _ => (),\n-    }\n-}\n-\n-crate fn assemble_builtin_sized_impls<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    sized_def_id: DefId,\n-    ty: Ty<'tcx>,\n-    clauses: &mut Vec<Clause<'tcx>>,\n-) {\n-    let mut push_builtin_impl = |ty: Ty<'tcx>, nested: &[GenericArg<'tcx>]| {\n-        let clause = builtin_impl_clause(tcx, ty, nested, sized_def_id);\n-        // Bind innermost bound vars that may exist in `ty` and `nested`.\n-        clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n-    };\n-\n-    match &ty.kind {\n-        // Non parametric primitive types.\n-        ty::Bool\n-        | ty::Char\n-        | ty::Int(..)\n-        | ty::Uint(..)\n-        | ty::Float(..)\n-        | ty::Infer(ty::IntVar(_))\n-        | ty::Infer(ty::FloatVar(_))\n-        | ty::Error\n-        | ty::Never => push_builtin_impl(ty, &[]),\n-\n-        // These ones are always `Sized`.\n-        &ty::Array(_, length) => {\n-            push_builtin_impl(tcx.mk_ty(ty::Array(generic_types::bound(tcx, 0), length)), &[]);\n-        }\n-        ty::RawPtr(ptr) => {\n-            push_builtin_impl(generic_types::raw_ptr(tcx, ptr.mutbl), &[]);\n-        }\n-        &ty::Ref(_, _, mutbl) => {\n-            push_builtin_impl(generic_types::ref_ty(tcx, mutbl), &[]);\n-        }\n-        ty::FnPtr(fn_ptr) => {\n-            let fn_ptr = fn_ptr.skip_binder();\n-            let fn_ptr = generic_types::fn_ptr(\n-                tcx,\n-                fn_ptr.inputs_and_output.len(),\n-                fn_ptr.c_variadic,\n-                fn_ptr.unsafety,\n-                fn_ptr.abi,\n-            );\n-            push_builtin_impl(fn_ptr, &[]);\n-        }\n-        &ty::FnDef(def_id, ..) => {\n-            push_builtin_impl(generic_types::fn_def(tcx, def_id), &[]);\n-        }\n-        &ty::Closure(def_id, ..) => {\n-            push_builtin_impl(generic_types::closure(tcx, def_id), &[]);\n-        }\n-        &ty::Generator(def_id, ..) => {\n-            push_builtin_impl(generic_types::generator(tcx, def_id), &[]);\n-        }\n-\n-        // `Sized` if the last type is `Sized` (because else we will get a WF error anyway).\n-        &ty::Tuple(type_list) => {\n-            let type_list = generic_types::type_list(tcx, type_list.len());\n-            push_builtin_impl(tcx.mk_ty(ty::Tuple(type_list)), &type_list);\n-        }\n-\n-        // Struct def\n-        ty::Adt(adt_def, _) => {\n-            let substs = InternalSubsts::bound_vars_for_item(tcx, adt_def.did);\n-            let adt = tcx.mk_ty(ty::Adt(adt_def, substs));\n-            let sized_constraint = adt_def\n-                .sized_constraint(tcx)\n-                .iter()\n-                .map(|ty| GenericArg::from(ty.subst(tcx, substs)))\n-                .collect::<Vec<_>>();\n-            push_builtin_impl(adt, &sized_constraint);\n-        }\n-\n-        // Artificially trigger an ambiguity by adding two possible types to\n-        // unify against.\n-        ty::Infer(ty::TyVar(_)) => {\n-            push_builtin_impl(tcx.types.i32, &[]);\n-            push_builtin_impl(tcx.types.f32, &[]);\n-        }\n-\n-        ty::Projection(_projection_ty) => {\n-            // FIXME: add builtin impls from the associated type values found in\n-            // trait impls of `projection_ty.trait_ref(tcx)`.\n-        }\n-\n-        // The `Sized` bound can only come from the environment.\n-        ty::Param(..) | ty::Placeholder(..) | ty::UnnormalizedProjection(..) => (),\n-\n-        // Definitely not `Sized`.\n-        ty::Foreign(..) | ty::Str | ty::Slice(..) | ty::Dynamic(..) | ty::Opaque(..) => (),\n-\n-        ty::Bound(..)\n-        | ty::GeneratorWitness(..)\n-        | ty::Infer(ty::FreshTy(_))\n-        | ty::Infer(ty::FreshIntTy(_))\n-        | ty::Infer(ty::FreshFloatTy(_)) => bug!(\"unexpected type {:?}\", ty),\n-    }\n-}\n-\n-crate fn assemble_builtin_copy_clone_impls<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_def_id: DefId,\n-    ty: Ty<'tcx>,\n-    clauses: &mut Vec<Clause<'tcx>>,\n-) {\n-    let mut push_builtin_impl = |ty: Ty<'tcx>, nested: &[GenericArg<'tcx>]| {\n-        let clause = builtin_impl_clause(tcx, ty, nested, trait_def_id);\n-        // Bind innermost bound vars that may exist in `ty` and `nested`.\n-        clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n-    };\n-\n-    match &ty.kind {\n-        // Implementations provided in libcore.\n-        ty::Bool\n-        | ty::Char\n-        | ty::Int(..)\n-        | ty::Uint(..)\n-        | ty::Float(..)\n-        | ty::RawPtr(..)\n-        | ty::Never\n-        | ty::Ref(_, _, hir::Mutability::Not) => (),\n-\n-        // Non parametric primitive types.\n-        ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) | ty::Error => {\n-            push_builtin_impl(ty, &[])\n-        }\n-\n-        // These implement `Copy`/`Clone` if their element types do.\n-        &ty::Array(_, length) => {\n-            let element_ty = generic_types::bound(tcx, 0);\n-            push_builtin_impl(\n-                tcx.mk_ty(ty::Array(element_ty, length)),\n-                &[GenericArg::from(element_ty)],\n-            );\n-        }\n-        &ty::Tuple(type_list) => {\n-            let type_list = generic_types::type_list(tcx, type_list.len());\n-            push_builtin_impl(tcx.mk_ty(ty::Tuple(type_list)), &**type_list);\n-        }\n-        &ty::Closure(def_id, ..) => {\n-            let closure_ty = generic_types::closure(tcx, def_id);\n-            let upvar_tys: Vec<_> = match &closure_ty.kind {\n-                ty::Closure(_, substs) => substs\n-                    .as_closure()\n-                    .upvar_tys(def_id, tcx)\n-                    .map(|ty| GenericArg::from(ty))\n-                    .collect(),\n-                _ => bug!(),\n-            };\n-            push_builtin_impl(closure_ty, &upvar_tys);\n-        }\n-\n-        // These ones are always `Clone`.\n-        ty::FnPtr(fn_ptr) => {\n-            let fn_ptr = fn_ptr.skip_binder();\n-            let fn_ptr = generic_types::fn_ptr(\n-                tcx,\n-                fn_ptr.inputs_and_output.len(),\n-                fn_ptr.c_variadic,\n-                fn_ptr.unsafety,\n-                fn_ptr.abi,\n-            );\n-            push_builtin_impl(fn_ptr, &[]);\n-        }\n-        &ty::FnDef(def_id, ..) => {\n-            push_builtin_impl(generic_types::fn_def(tcx, def_id), &[]);\n-        }\n-\n-        // These depend on whatever user-defined impls might exist.\n-        ty::Adt(_, _) => (),\n-\n-        // Artificially trigger an ambiguity by adding two possible types to\n-        // unify against.\n-        ty::Infer(ty::TyVar(_)) => {\n-            push_builtin_impl(tcx.types.i32, &[]);\n-            push_builtin_impl(tcx.types.f32, &[]);\n-        }\n-\n-        ty::Projection(_projection_ty) => {\n-            // FIXME: add builtin impls from the associated type values found in\n-            // trait impls of `projection_ty.trait_ref(tcx)`.\n-        }\n-\n-        // The `Copy`/`Clone` bound can only come from the environment.\n-        ty::Param(..) | ty::Placeholder(..) | ty::UnnormalizedProjection(..) | ty::Opaque(..) => (),\n-\n-        // Definitely not `Copy`/`Clone`.\n-        ty::Dynamic(..)\n-        | ty::Foreign(..)\n-        | ty::Generator(..)\n-        | ty::Str\n-        | ty::Slice(..)\n-        | ty::Ref(_, _, hir::Mutability::Mut) => (),\n-\n-        ty::Bound(..)\n-        | ty::GeneratorWitness(..)\n-        | ty::Infer(ty::FreshTy(_))\n-        | ty::Infer(ty::FreshIntTy(_))\n-        | ty::Infer(ty::FreshFloatTy(_)) => bug!(\"unexpected type {:?}\", ty),\n-    }\n-}"}, {"sha": "38a4a729648431daa39743b77a900334e738fd13", "filename": "src/librustc_traits/chalk_context/program_clauses/mod.rs", "status": "removed", "additions": 0, "deletions": 300, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,300 +0,0 @@\n-mod builtin;\n-mod primitive;\n-\n-use super::ChalkInferenceContext;\n-use rustc::traits::{\n-    Clause, DomainGoal, Environment, FromEnv, ProgramClause, ProgramClauseCategory, WellFormed,\n-};\n-use rustc::ty::{self, TyCtxt};\n-use rustc_hir::def_id::DefId;\n-use std::iter;\n-\n-use self::builtin::*;\n-use self::primitive::*;\n-\n-fn assemble_clauses_from_impls<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_def_id: DefId,\n-    clauses: &mut Vec<Clause<'tcx>>,\n-) {\n-    tcx.for_each_impl(trait_def_id, |impl_def_id| {\n-        clauses.extend(tcx.program_clauses_for(impl_def_id).into_iter().cloned());\n-    });\n-}\n-\n-fn assemble_clauses_from_assoc_ty_values<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_def_id: DefId,\n-    clauses: &mut Vec<Clause<'tcx>>,\n-) {\n-    tcx.for_each_impl(trait_def_id, |impl_def_id| {\n-        for def_id in tcx.associated_item_def_ids(impl_def_id).iter() {\n-            clauses.extend(tcx.program_clauses_for(*def_id).into_iter().cloned());\n-        }\n-    });\n-}\n-\n-impl ChalkInferenceContext<'cx, 'tcx> {\n-    pub(super) fn program_clauses_impl(\n-        &self,\n-        environment: &Environment<'tcx>,\n-        goal: &DomainGoal<'tcx>,\n-    ) -> Vec<Clause<'tcx>> {\n-        use rustc::infer::canonical::OriginalQueryValues;\n-        use rustc::traits::WhereClause::*;\n-\n-        let goal = self.infcx.resolve_vars_if_possible(goal);\n-\n-        debug!(\"program_clauses(goal = {:?})\", goal);\n-\n-        let mut clauses = match goal {\n-            DomainGoal::Holds(Implemented(trait_predicate)) => {\n-                // These come from:\n-                // * implementations of the trait itself (rule `Implemented-From-Impl`)\n-                // * the trait decl (rule `Implemented-From-Env`)\n-\n-                let mut clauses = vec![];\n-\n-                assemble_clauses_from_impls(self.infcx.tcx, trait_predicate.def_id(), &mut clauses);\n-\n-                if Some(trait_predicate.def_id()) == self.infcx.tcx.lang_items().sized_trait() {\n-                    assemble_builtin_sized_impls(\n-                        self.infcx.tcx,\n-                        trait_predicate.def_id(),\n-                        trait_predicate.self_ty(),\n-                        &mut clauses,\n-                    );\n-                }\n-\n-                if Some(trait_predicate.def_id()) == self.infcx.tcx.lang_items().unsize_trait() {\n-                    let source = trait_predicate.self_ty();\n-                    let target = trait_predicate.trait_ref.substs.type_at(1);\n-                    assemble_builtin_unsize_impls(\n-                        self.infcx.tcx,\n-                        trait_predicate.def_id(),\n-                        source,\n-                        target,\n-                        &mut clauses,\n-                    );\n-                }\n-\n-                if Some(trait_predicate.def_id()) == self.infcx.tcx.lang_items().copy_trait() {\n-                    assemble_builtin_copy_clone_impls(\n-                        self.infcx.tcx,\n-                        trait_predicate.def_id(),\n-                        trait_predicate.self_ty(),\n-                        &mut clauses,\n-                    );\n-                }\n-\n-                if Some(trait_predicate.def_id()) == self.infcx.tcx.lang_items().clone_trait() {\n-                    // For all builtin impls, the conditions for `Copy` and\n-                    // `Clone` are the same.\n-                    assemble_builtin_copy_clone_impls(\n-                        self.infcx.tcx,\n-                        trait_predicate.def_id(),\n-                        trait_predicate.self_ty(),\n-                        &mut clauses,\n-                    );\n-                }\n-\n-                // FIXME: we need to add special rules for other builtin impls:\n-                // * `Generator`\n-                // * `FnOnce` / `FnMut` / `Fn`\n-                // * trait objects\n-                // * auto traits\n-\n-                // Rule `Implemented-From-Env` will be computed from the environment.\n-                clauses\n-            }\n-\n-            DomainGoal::Holds(ProjectionEq(projection_predicate)) => {\n-                // These come from:\n-                // * the assoc type definition (rule `ProjectionEq-Placeholder`)\n-                // * normalization of the assoc ty values (rule `ProjectionEq-Normalize`)\n-                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n-                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n-\n-                let clauses = self\n-                    .infcx\n-                    .tcx\n-                    .program_clauses_for(projection_predicate.projection_ty.item_def_id)\n-                    .into_iter()\n-                    // only select `ProjectionEq-Placeholder` and `ProjectionEq-Normalize`\n-                    .filter(|clause| clause.category() == ProgramClauseCategory::Other)\n-                    .cloned()\n-                    .collect::<Vec<_>>();\n-\n-                // Rules `Implied-Bound-From-Trait` and `Implied-Bound-From-Type` will be computed\n-                // from the environment.\n-                clauses\n-            }\n-\n-            // For outlive requirements, just assume they hold. `ResolventOps::resolvent_clause`\n-            // will register them as actual region constraints later.\n-            DomainGoal::Holds(RegionOutlives(..)) | DomainGoal::Holds(TypeOutlives(..)) => {\n-                vec![Clause::Implies(ProgramClause {\n-                    goal,\n-                    hypotheses: ty::List::empty(),\n-                    category: ProgramClauseCategory::Other,\n-                })]\n-            }\n-\n-            DomainGoal::WellFormed(WellFormed::Trait(trait_predicate)) => {\n-                // These come from -- the trait decl (rule `WellFormed-TraitRef`).\n-                self.infcx\n-                    .tcx\n-                    .program_clauses_for(trait_predicate.def_id())\n-                    .into_iter()\n-                    // only select `WellFormed-TraitRef`\n-                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n-                    .cloned()\n-                    .collect()\n-            }\n-\n-            DomainGoal::WellFormed(WellFormed::Ty(ty)) => {\n-                // These come from:\n-                // * the associated type definition if `ty` refers to an unnormalized\n-                //   associated type (rule `WellFormed-AssocTy`)\n-                // * custom rules for built-in types\n-                // * the type definition otherwise (rule `WellFormed-Type`)\n-                let clauses = match ty.kind {\n-                    ty::Projection(data) => self.infcx.tcx.program_clauses_for(data.item_def_id),\n-\n-                    // These types are always WF.\n-                    ty::Bool\n-                    | ty::Char\n-                    | ty::Int(..)\n-                    | ty::Uint(..)\n-                    | ty::Float(..)\n-                    | ty::Str\n-                    | ty::Param(..)\n-                    | ty::Placeholder(..)\n-                    | ty::Error\n-                    | ty::Never => {\n-                        let wf_clause = ProgramClause {\n-                            goal,\n-                            hypotheses: ty::List::empty(),\n-                            category: ProgramClauseCategory::WellFormed,\n-                        };\n-                        let wf_clause = Clause::Implies(wf_clause);\n-\n-                        self.infcx.tcx.mk_clauses(iter::once(wf_clause))\n-                    }\n-\n-                    // Always WF (recall that we do not check for parameters to be WF).\n-                    ty::RawPtr(ptr) => wf_clause_for_raw_ptr(self.infcx.tcx, ptr.mutbl),\n-\n-                    // Always WF (recall that we do not check for parameters to be WF).\n-                    ty::FnPtr(fn_ptr) => {\n-                        let fn_ptr = fn_ptr.skip_binder();\n-                        wf_clause_for_fn_ptr(\n-                            self.infcx.tcx,\n-                            fn_ptr.inputs_and_output.len(),\n-                            fn_ptr.c_variadic,\n-                            fn_ptr.unsafety,\n-                            fn_ptr.abi,\n-                        )\n-                    }\n-\n-                    // WF if inner type is `Sized`.\n-                    ty::Slice(..) => wf_clause_for_slice(self.infcx.tcx),\n-\n-                    // WF if inner type is `Sized`.\n-                    ty::Array(_, length) => wf_clause_for_array(self.infcx.tcx, length),\n-\n-                    // WF if all types but the last one are `Sized`.\n-                    ty::Tuple(types) => wf_clause_for_tuple(self.infcx.tcx, types.len()),\n-\n-                    // WF if `sub_ty` outlives `region`.\n-                    ty::Ref(_, _, mutbl) => wf_clause_for_ref(self.infcx.tcx, mutbl),\n-\n-                    ty::FnDef(def_id, ..) => wf_clause_for_fn_def(self.infcx.tcx, def_id),\n-\n-                    ty::Dynamic(..) => {\n-                        // FIXME: no rules yet for trait objects\n-                        ty::List::empty()\n-                    }\n-\n-                    ty::Adt(def, ..) => self.infcx.tcx.program_clauses_for(def.did),\n-\n-                    // FIXME: these are probably wrong\n-                    ty::Foreign(def_id)\n-                    | ty::Closure(def_id, ..)\n-                    | ty::Generator(def_id, ..)\n-                    | ty::Opaque(def_id, ..) => self.infcx.tcx.program_clauses_for(def_id),\n-\n-                    // Artificially trigger an ambiguity.\n-                    ty::Infer(..) => {\n-                        let tcx = self.infcx.tcx;\n-                        let types = [tcx.types.i32, tcx.types.u32, tcx.types.f32, tcx.types.f64];\n-                        let clauses = types\n-                            .iter()\n-                            .cloned()\n-                            .map(|ty| ProgramClause {\n-                                goal: DomainGoal::WellFormed(WellFormed::Ty(ty)),\n-                                hypotheses: ty::List::empty(),\n-                                category: ProgramClauseCategory::WellFormed,\n-                            })\n-                            .map(|clause| Clause::Implies(clause));\n-                        tcx.mk_clauses(clauses)\n-                    }\n-\n-                    ty::GeneratorWitness(..) | ty::UnnormalizedProjection(..) | ty::Bound(..) => {\n-                        bug!(\"unexpected type {:?}\", ty)\n-                    }\n-                };\n-\n-                clauses\n-                    .into_iter()\n-                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n-                    .cloned()\n-                    .collect()\n-            }\n-\n-            DomainGoal::FromEnv(FromEnv::Trait(..)) => {\n-                // These come from:\n-                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n-                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n-                // * implied bounds from assoc type defs (rules `Implied-Trait-From-AssocTy`,\n-                //   `Implied-Bound-From-AssocTy` and `Implied-WC-From-AssocTy`)\n-\n-                // All of these rules are computed in the environment.\n-                vec![]\n-            }\n-\n-            DomainGoal::FromEnv(FromEnv::Ty(..)) => {\n-                // There are no `FromEnv::Ty(..) :- ...` rules (this predicate only\n-                // comes from the environment).\n-                vec![]\n-            }\n-\n-            DomainGoal::Normalize(projection_predicate) => {\n-                // These come from -- assoc ty values (rule `Normalize-From-Impl`).\n-                let mut clauses = vec![];\n-\n-                assemble_clauses_from_assoc_ty_values(\n-                    self.infcx.tcx,\n-                    projection_predicate.projection_ty.trait_ref(self.infcx.tcx).def_id,\n-                    &mut clauses,\n-                );\n-\n-                clauses\n-            }\n-        };\n-\n-        debug!(\"program_clauses: clauses = {:?}\", clauses);\n-        debug!(\"program_clauses: adding clauses from environment = {:?}\", environment);\n-\n-        let mut _orig_query_values = OriginalQueryValues::default();\n-        let canonical_environment =\n-            self.infcx.canonicalize_query(environment, &mut _orig_query_values).value;\n-        let env_clauses = self.infcx.tcx.program_clauses_for_env(canonical_environment);\n-\n-        debug!(\"program_clauses: env_clauses = {:?}\", env_clauses);\n-\n-        clauses.extend(env_clauses.into_iter().cloned());\n-        clauses.extend(environment.clauses.iter().cloned());\n-        clauses\n-    }\n-}"}, {"sha": "ae4afe58436d6218f572cdb4837fa20a48888f39", "filename": "src/librustc_traits/chalk_context/program_clauses/primitive.rs", "status": "removed", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,168 +0,0 @@\n-use crate::generic_types;\n-use crate::lowering::Lower;\n-use rustc::traits::{\n-    Clause, Clauses, DomainGoal, GoalKind, ProgramClause, ProgramClauseCategory, WellFormed,\n-};\n-use rustc::ty::{self, TyCtxt};\n-use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_target::spec::abi;\n-use std::iter;\n-\n-crate fn wf_clause_for_raw_ptr(tcx: TyCtxt<'_>, mutbl: hir::Mutability) -> Clauses<'_> {\n-    let ptr_ty = generic_types::raw_ptr(tcx, mutbl);\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(ptr_ty)),\n-        hypotheses: ty::List::empty(),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::Implies(wf_clause);\n-\n-    // `forall<T> { WellFormed(*const T). }`\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-crate fn wf_clause_for_fn_ptr(\n-    tcx: TyCtxt<'_>,\n-    arity_and_output: usize,\n-    variadic: bool,\n-    unsafety: hir::Unsafety,\n-    abi: abi::Abi,\n-) -> Clauses<'_> {\n-    let fn_ptr = generic_types::fn_ptr(tcx, arity_and_output, variadic, unsafety, abi);\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(fn_ptr)),\n-        hypotheses: ty::List::empty(),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // `forall <T1, ..., Tn+1> { WellFormed(for<> fn(T1, ..., Tn) -> Tn+1). }`\n-    // where `n + 1` == `arity_and_output`\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-crate fn wf_clause_for_slice(tcx: TyCtxt<'_>) -> Clauses<'_> {\n-    let ty = generic_types::bound(tcx, 0);\n-    let slice_ty = tcx.mk_slice(ty);\n-\n-    let sized_trait = match tcx.lang_items().sized_trait() {\n-        Some(def_id) => def_id,\n-        None => return ty::List::empty(),\n-    };\n-    let sized_implemented =\n-        ty::TraitRef { def_id: sized_trait, substs: tcx.mk_substs_trait(ty, ty::List::empty()) };\n-    let sized_implemented: DomainGoal<'_> =\n-        ty::TraitPredicate { trait_ref: sized_implemented }.lower();\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(slice_ty)),\n-        hypotheses: tcx.mk_goals(iter::once(tcx.mk_goal(GoalKind::DomainGoal(sized_implemented)))),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // `forall<T> { WellFormed([T]) :- Implemented(T: Sized). }`\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-crate fn wf_clause_for_array<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    length: &'tcx ty::Const<'tcx>,\n-) -> Clauses<'tcx> {\n-    let ty = generic_types::bound(tcx, 0);\n-    let array_ty = tcx.mk_ty(ty::Array(ty, length));\n-\n-    let sized_trait = match tcx.lang_items().sized_trait() {\n-        Some(def_id) => def_id,\n-        None => return ty::List::empty(),\n-    };\n-    let sized_implemented =\n-        ty::TraitRef { def_id: sized_trait, substs: tcx.mk_substs_trait(ty, ty::List::empty()) };\n-    let sized_implemented: DomainGoal<'_> =\n-        ty::TraitPredicate { trait_ref: sized_implemented }.lower();\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(array_ty)),\n-        hypotheses: tcx.mk_goals(iter::once(tcx.mk_goal(GoalKind::DomainGoal(sized_implemented)))),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // `forall<T> { WellFormed([T; length]) :- Implemented(T: Sized). }`\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-crate fn wf_clause_for_tuple(tcx: TyCtxt<'_>, arity: usize) -> Clauses<'_> {\n-    let type_list = generic_types::type_list(tcx, arity);\n-    let tuple_ty = tcx.mk_ty(ty::Tuple(type_list));\n-\n-    let sized_trait = match tcx.lang_items().sized_trait() {\n-        Some(def_id) => def_id,\n-        None => return ty::List::empty(),\n-    };\n-\n-    // If `arity == 0` (i.e. the unit type) or `arity == 1`, this list of\n-    // hypotheses is actually empty.\n-    let sized_implemented = type_list[0..std::cmp::max(arity, 1) - 1]\n-        .iter()\n-        .map(|ty| ty::TraitRef {\n-            def_id: sized_trait,\n-            substs: tcx.mk_substs_trait(ty.expect_ty(), ty::List::empty()),\n-        })\n-        .map(|trait_ref| ty::TraitPredicate { trait_ref })\n-        .map(|predicate| predicate.lower());\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(tuple_ty)),\n-        hypotheses: tcx.mk_goals(\n-            sized_implemented.map(|domain_goal| tcx.mk_goal(GoalKind::DomainGoal(domain_goal))),\n-        ),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // ```\n-    // forall<T1, ..., Tn-1, Tn> {\n-    //     WellFormed((T1, ..., Tn)) :-\n-    //         Implemented(T1: Sized),\n-    //         ...\n-    //         Implemented(Tn-1: Sized).\n-    // }\n-    // ```\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-crate fn wf_clause_for_ref(tcx: TyCtxt<'_>, mutbl: hir::Mutability) -> Clauses<'_> {\n-    let region = tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0)));\n-    let ty = generic_types::bound(tcx, 1);\n-    let ref_ty = tcx.mk_ref(region, ty::TypeAndMut { ty, mutbl });\n-\n-    let outlives: DomainGoal<'_> = ty::OutlivesPredicate(ty, region).lower();\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(ref_ty)),\n-        hypotheses: tcx.mk_goals(iter::once(tcx.mk_goal(outlives.into_goal()))),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // `forall<'a, T> { WellFormed(&'a T) :- Outlives(T: 'a). }`\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}\n-\n-crate fn wf_clause_for_fn_def(tcx: TyCtxt<'_>, def_id: DefId) -> Clauses<'_> {\n-    let fn_def = generic_types::fn_def(tcx, def_id);\n-\n-    let wf_clause = ProgramClause {\n-        goal: DomainGoal::WellFormed(WellFormed::Ty(fn_def)),\n-        hypotheses: ty::List::empty(),\n-        category: ProgramClauseCategory::WellFormed,\n-    };\n-    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n-\n-    // `forall <T1, ..., Tn+1> { WellFormed(fn some_fn(T1, ..., Tn) -> Tn+1). }`\n-    // where `def_id` maps to the `some_fn` function definition\n-    tcx.mk_clauses(iter::once(wf_clause))\n-}"}, {"sha": "796ce6085fdbe25085f819e695f689ee07c483f8", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "removed", "additions": 0, "deletions": 297, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,297 +0,0 @@\n-use chalk_engine::fallible::{Fallible, NoSolution};\n-use chalk_engine::{context, ExClause, Literal};\n-use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n-use rustc::ty::subst::GenericArg;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc_infer::infer::{InferCtxt, LateBoundRegionConversionTime};\n-use rustc_infer::traits::{\n-    Clause, DomainGoal, Environment, Goal, GoalKind, InEnvironment, ProgramClause, WhereClause,\n-};\n-use rustc_span::DUMMY_SP;\n-\n-use super::unify::*;\n-use super::{ChalkArenas, ChalkExClause, ChalkInferenceContext, ConstrainedSubst};\n-\n-impl context::ResolventOps<ChalkArenas<'tcx>, ChalkArenas<'tcx>>\n-    for ChalkInferenceContext<'cx, 'tcx>\n-{\n-    fn resolvent_clause(\n-        &mut self,\n-        environment: &Environment<'tcx>,\n-        goal: &DomainGoal<'tcx>,\n-        subst: &CanonicalVarValues<'tcx>,\n-        clause: &Clause<'tcx>,\n-    ) -> Fallible<Canonical<'tcx, ChalkExClause<'tcx>>> {\n-        use chalk_engine::context::UnificationOps;\n-\n-        debug!(\"resolvent_clause(goal = {:?}, clause = {:?})\", goal, clause);\n-\n-        let result = self.infcx.probe(|_| {\n-            let ProgramClause { goal: consequence, hypotheses, .. } = match clause {\n-                Clause::Implies(program_clause) => *program_clause,\n-                Clause::ForAll(program_clause) => {\n-                    self.infcx\n-                        .replace_bound_vars_with_fresh_vars(\n-                            DUMMY_SP,\n-                            LateBoundRegionConversionTime::HigherRankedType,\n-                            program_clause,\n-                        )\n-                        .0\n-                }\n-            };\n-\n-            let result =\n-                unify(self.infcx, *environment, ty::Variance::Invariant, goal, &consequence)\n-                    .map_err(|_| NoSolution)?;\n-\n-            let mut ex_clause = ExClause {\n-                subst: subst.clone(),\n-                delayed_literals: vec![],\n-                constraints: vec![],\n-                subgoals: vec![],\n-            };\n-\n-            self.into_ex_clause(result, &mut ex_clause);\n-\n-            ex_clause.subgoals.extend(hypotheses.iter().map(|g| match g {\n-                GoalKind::Not(g) => Literal::Negative(environment.with(*g)),\n-                g => Literal::Positive(environment.with(*g)),\n-            }));\n-\n-            // If we have a goal of the form `T: 'a` or `'a: 'b`, then just\n-            // assume it is true (no subgoals) and register it as a constraint\n-            // instead.\n-            match goal {\n-                DomainGoal::Holds(WhereClause::RegionOutlives(pred)) => {\n-                    assert_eq!(ex_clause.subgoals.len(), 0);\n-                    ex_clause.constraints.push(ty::OutlivesPredicate(pred.0.into(), pred.1));\n-                }\n-\n-                DomainGoal::Holds(WhereClause::TypeOutlives(pred)) => {\n-                    assert_eq!(ex_clause.subgoals.len(), 0);\n-                    ex_clause.constraints.push(ty::OutlivesPredicate(pred.0.into(), pred.1));\n-                }\n-\n-                _ => (),\n-            };\n-\n-            let canonical_ex_clause = self.canonicalize_ex_clause(&ex_clause);\n-            Ok(canonical_ex_clause)\n-        });\n-\n-        debug!(\"resolvent_clause: result = {:?}\", result);\n-        result\n-    }\n-\n-    fn apply_answer_subst(\n-        &mut self,\n-        ex_clause: ChalkExClause<'tcx>,\n-        selected_goal: &InEnvironment<'tcx, Goal<'tcx>>,\n-        answer_table_goal: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n-        canonical_answer_subst: &Canonical<'tcx, ConstrainedSubst<'tcx>>,\n-    ) -> Fallible<ChalkExClause<'tcx>> {\n-        debug!(\n-            \"apply_answer_subst(ex_clause = {:?}, selected_goal = {:?})\",\n-            self.infcx.resolve_vars_if_possible(&ex_clause),\n-            self.infcx.resolve_vars_if_possible(selected_goal)\n-        );\n-\n-        let (answer_subst, _) = self\n-            .infcx\n-            .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, canonical_answer_subst);\n-\n-        let mut substitutor = AnswerSubstitutor {\n-            infcx: self.infcx,\n-            environment: selected_goal.environment,\n-            answer_subst: answer_subst.subst,\n-            binder_index: ty::INNERMOST,\n-            ex_clause,\n-        };\n-\n-        substitutor.relate(&answer_table_goal.value, &selected_goal).map_err(|_| NoSolution)?;\n-\n-        let mut ex_clause = substitutor.ex_clause;\n-        ex_clause.constraints.extend(answer_subst.constraints);\n-\n-        debug!(\"apply_answer_subst: ex_clause = {:?}\", ex_clause);\n-        Ok(ex_clause)\n-    }\n-}\n-\n-struct AnswerSubstitutor<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n-    environment: Environment<'tcx>,\n-    answer_subst: CanonicalVarValues<'tcx>,\n-    binder_index: ty::DebruijnIndex,\n-    ex_clause: ChalkExClause<'tcx>,\n-}\n-\n-impl AnswerSubstitutor<'cx, 'tcx> {\n-    fn unify_free_answer_var(\n-        &mut self,\n-        answer_var: ty::BoundVar,\n-        pending: GenericArg<'tcx>,\n-    ) -> RelateResult<'tcx, ()> {\n-        let answer_param = &self.answer_subst.var_values[answer_var];\n-        let pending =\n-            &ty::fold::shift_out_vars(self.infcx.tcx, &pending, self.binder_index.as_u32());\n-\n-        super::into_ex_clause(\n-            unify(self.infcx, self.environment, ty::Variance::Invariant, answer_param, pending)?,\n-            &mut self.ex_clause,\n-        );\n-\n-        Ok(())\n-    }\n-}\n-\n-impl TypeRelation<'tcx> for AnswerSubstitutor<'cx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n-        // FIXME(oli-obk): learn chalk and create param envs\n-        ty::ParamEnv::empty()\n-    }\n-\n-    fn tag(&self) -> &'static str {\n-        \"chalk_context::answer_substitutor\"\n-    }\n-\n-    fn a_is_expected(&self) -> bool {\n-        true\n-    }\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(\n-        &mut self,\n-        _variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n-    ) -> RelateResult<'tcx, T> {\n-        // We don't care about variance.\n-        self.relate(a, b)\n-    }\n-\n-    fn binders<T: Relate<'tcx>>(\n-        &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>> {\n-        self.binder_index.shift_in(1);\n-        let result = self.relate(a.skip_binder(), b.skip_binder())?;\n-        self.binder_index.shift_out(1);\n-        Ok(ty::Binder::bind(result))\n-    }\n-\n-    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        let b = self.infcx.shallow_resolve(b);\n-        debug!(\"AnswerSubstitutor::tys(a = {:?}, b = {:?})\", a, b);\n-\n-        if let &ty::Bound(debruijn, bound_ty) = &a.kind {\n-            // Free bound var\n-            if debruijn == self.binder_index {\n-                self.unify_free_answer_var(bound_ty.var, b.into())?;\n-                return Ok(b);\n-            }\n-        }\n-\n-        match (&a.kind, &b.kind) {\n-            (&ty::Bound(a_debruijn, a_bound), &ty::Bound(b_debruijn, b_bound)) => {\n-                assert_eq!(a_debruijn, b_debruijn);\n-                assert_eq!(a_bound.var, b_bound.var);\n-                Ok(a)\n-            }\n-\n-            // Those should have been canonicalized away.\n-            (ty::Placeholder(..), _) => {\n-                bug!(\"unexpected placeholder ty in `AnswerSubstitutor`: {:?} \", a);\n-            }\n-\n-            // Everything else should just be a perfect match as well,\n-            // and we forbid inference variables.\n-            _ => match ty::relate::super_relate_tys(self, a, b) {\n-                Ok(ty) => Ok(ty),\n-                Err(err) => bug!(\"type mismatch in `AnswerSubstitutor`: {}\", err),\n-            },\n-        }\n-    }\n-\n-    fn regions(\n-        &mut self,\n-        a: ty::Region<'tcx>,\n-        b: ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        let b = match b {\n-            &ty::ReVar(vid) => self\n-                .infcx\n-                .inner\n-                .borrow_mut()\n-                .unwrap_region_constraints()\n-                .opportunistic_resolve_var(self.infcx.tcx, vid),\n-\n-            other => other,\n-        };\n-\n-        if let &ty::ReLateBound(debruijn, bound) = a {\n-            // Free bound region\n-            if debruijn == self.binder_index {\n-                self.unify_free_answer_var(bound.assert_bound_var(), b.into())?;\n-                return Ok(b);\n-            }\n-        }\n-\n-        match (a, b) {\n-            (&ty::ReLateBound(a_debruijn, a_bound), &ty::ReLateBound(b_debruijn, b_bound)) => {\n-                assert_eq!(a_debruijn, b_debruijn);\n-                assert_eq!(a_bound.assert_bound_var(), b_bound.assert_bound_var());\n-            }\n-\n-            (ty::ReStatic, ty::ReStatic) | (ty::ReErased, ty::ReErased) => (),\n-\n-            (ty::ReEmpty(a_ui), ty::ReEmpty(b_ui)) => {\n-                assert_eq!(a_ui, b_ui);\n-            }\n-\n-            (&ty::ReFree(a_free), &ty::ReFree(b_free)) => {\n-                assert_eq!(a_free, b_free);\n-            }\n-\n-            _ => bug!(\"unexpected regions in `AnswerSubstitutor`: {:?}, {:?}\", a, b),\n-        }\n-\n-        Ok(a)\n-    }\n-\n-    fn consts(\n-        &mut self,\n-        a: &'tcx ty::Const<'tcx>,\n-        b: &'tcx ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        if let ty::Const { val: ty::ConstKind::Bound(debruijn, bound_ct), .. } = a {\n-            if *debruijn == self.binder_index {\n-                self.unify_free_answer_var(*bound_ct, b.into())?;\n-                return Ok(b);\n-            }\n-        }\n-\n-        match (a, b) {\n-            (\n-                ty::Const { val: ty::ConstKind::Bound(a_debruijn, a_bound), .. },\n-                ty::Const { val: ty::ConstKind::Bound(b_debruijn, b_bound), .. },\n-            ) => {\n-                assert_eq!(a_debruijn, b_debruijn);\n-                assert_eq!(a_bound, b_bound);\n-                Ok(a)\n-            }\n-\n-            // Everything else should just be a perfect match as well,\n-            // and we forbid inference variables.\n-            _ => match ty::relate::super_relate_consts(self, a, b) {\n-                Ok(ct) => Ok(ct),\n-                Err(err) => bug!(\"const mismatch in `AnswerSubstitutor`: {}\", err),\n-            },\n-        }\n-    }\n-}"}, {"sha": "3274a301bb6694c35b53bd948808acf907c07a01", "filename": "src/librustc_traits/chalk_context/unify.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,85 +0,0 @@\n-use rustc::ty;\n-use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n-use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n-use rustc_infer::infer::{InferCtxt, RegionVariableOrigin};\n-use rustc_infer::traits::{DomainGoal, Environment, Goal, InEnvironment};\n-use rustc_span::DUMMY_SP;\n-\n-crate struct UnificationResult<'tcx> {\n-    crate goals: Vec<InEnvironment<'tcx, Goal<'tcx>>>,\n-    crate constraints: Vec<super::RegionConstraint<'tcx>>,\n-}\n-\n-crate fn unify<'me, 'tcx, T: Relate<'tcx>>(\n-    infcx: &'me InferCtxt<'me, 'tcx>,\n-    environment: Environment<'tcx>,\n-    variance: ty::Variance,\n-    a: &T,\n-    b: &T,\n-) -> RelateResult<'tcx, UnificationResult<'tcx>> {\n-    debug!(\n-        \"unify(\n-        a = {:?},\n-        b = {:?},\n-        environment = {:?},\n-    )\",\n-        a, b, environment\n-    );\n-\n-    let mut delegate = ChalkTypeRelatingDelegate::new(infcx, environment);\n-\n-    TypeRelating::new(infcx, &mut delegate, variance).relate(a, b)?;\n-\n-    debug!(\"unify: goals = {:?}, constraints = {:?}\", delegate.goals, delegate.constraints);\n-\n-    Ok(UnificationResult { goals: delegate.goals, constraints: delegate.constraints })\n-}\n-\n-struct ChalkTypeRelatingDelegate<'me, 'tcx> {\n-    infcx: &'me InferCtxt<'me, 'tcx>,\n-    environment: Environment<'tcx>,\n-    goals: Vec<InEnvironment<'tcx, Goal<'tcx>>>,\n-    constraints: Vec<super::RegionConstraint<'tcx>>,\n-}\n-\n-impl ChalkTypeRelatingDelegate<'me, 'tcx> {\n-    fn new(infcx: &'me InferCtxt<'me, 'tcx>, environment: Environment<'tcx>) -> Self {\n-        Self { infcx, environment, goals: Vec::new(), constraints: Vec::new() }\n-    }\n-}\n-\n-impl TypeRelatingDelegate<'tcx> for &mut ChalkTypeRelatingDelegate<'_, 'tcx> {\n-    fn create_next_universe(&mut self) -> ty::UniverseIndex {\n-        self.infcx.create_next_universe()\n-    }\n-\n-    fn next_existential_region_var(&mut self, _was_placeholder: bool) -> ty::Region<'tcx> {\n-        self.infcx.next_region_var(RegionVariableOrigin::MiscVariable(DUMMY_SP))\n-    }\n-\n-    fn next_placeholder_region(&mut self, placeholder: ty::PlaceholderRegion) -> ty::Region<'tcx> {\n-        self.infcx.tcx.mk_region(ty::RePlaceholder(placeholder))\n-    }\n-\n-    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n-        self.infcx\n-            .next_region_var_in_universe(RegionVariableOrigin::MiscVariable(DUMMY_SP), universe)\n-    }\n-\n-    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n-        self.constraints.push(ty::OutlivesPredicate(sup.into(), sub));\n-    }\n-\n-    fn push_domain_goal(&mut self, domain_goal: DomainGoal<'tcx>) {\n-        let goal = self.environment.with(self.infcx.tcx.mk_goal(domain_goal.into_goal()));\n-        self.goals.push(goal);\n-    }\n-\n-    fn normalization() -> NormalizationStrategy {\n-        NormalizationStrategy::Lazy\n-    }\n-\n-    fn forbid_inference_vars() -> bool {\n-        false\n-    }\n-}"}, {"sha": "44a2c5464cdb56c732c42c1369ff191cbb788b17", "filename": "src/librustc_traits/generic_types.rs", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_traits%2Fgeneric_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Flibrustc_traits%2Fgeneric_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fgeneric_types.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,65 +0,0 @@\n-//! Utilities for creating generic types with bound vars in place of parameter values.\n-\n-use rustc::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_target::spec::abi;\n-\n-crate fn bound(tcx: TyCtxt<'tcx>, index: u32) -> Ty<'tcx> {\n-    let ty = ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(index).into());\n-    tcx.mk_ty(ty)\n-}\n-\n-crate fn raw_ptr(tcx: TyCtxt<'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n-    tcx.mk_ptr(ty::TypeAndMut { ty: bound(tcx, 0), mutbl })\n-}\n-\n-crate fn fn_ptr(\n-    tcx: TyCtxt<'tcx>,\n-    arity_and_output: usize,\n-    c_variadic: bool,\n-    unsafety: hir::Unsafety,\n-    abi: abi::Abi,\n-) -> Ty<'tcx> {\n-    let inputs_and_output = tcx.mk_type_list(\n-        (0..arity_and_output)\n-            .map(|i| ty::BoundVar::from(i))\n-            // DebruijnIndex(1) because we are going to inject these in a `PolyFnSig`\n-            .map(|var| tcx.mk_ty(ty::Bound(ty::DebruijnIndex::from(1usize), var.into()))),\n-    );\n-\n-    let fn_sig = ty::Binder::bind(ty::FnSig { inputs_and_output, c_variadic, unsafety, abi });\n-    tcx.mk_fn_ptr(fn_sig)\n-}\n-\n-crate fn type_list(tcx: TyCtxt<'tcx>, arity: usize) -> SubstsRef<'tcx> {\n-    tcx.mk_substs(\n-        (0..arity)\n-            .map(|i| ty::BoundVar::from(i))\n-            .map(|var| tcx.mk_ty(ty::Bound(ty::INNERMOST, var.into())))\n-            .map(|ty| GenericArg::from(ty)),\n-    )\n-}\n-\n-crate fn ref_ty(tcx: TyCtxt<'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n-    let region = tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0)));\n-\n-    tcx.mk_ref(region, ty::TypeAndMut { ty: bound(tcx, 1), mutbl })\n-}\n-\n-crate fn fn_def(tcx: TyCtxt<'tcx>, def_id: DefId) -> Ty<'tcx> {\n-    tcx.mk_ty(ty::FnDef(def_id, InternalSubsts::bound_vars_for_item(tcx, def_id)))\n-}\n-\n-crate fn closure(tcx: TyCtxt<'tcx>, def_id: DefId) -> Ty<'tcx> {\n-    tcx.mk_closure(def_id, InternalSubsts::bound_vars_for_item(tcx, def_id))\n-}\n-\n-crate fn generator(tcx: TyCtxt<'tcx>, def_id: DefId) -> Ty<'tcx> {\n-    tcx.mk_generator(\n-        def_id,\n-        InternalSubsts::bound_vars_for_item(tcx, def_id),\n-        hir::Movability::Movable,\n-    )\n-}"}, {"sha": "894e3ef3a8f83853196529f043794e40d39a07c1", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "patch": "@@ -11,10 +11,8 @@ extern crate log;\n #[macro_use]\n extern crate rustc;\n \n-mod chalk_context;\n mod dropck_outlives;\n mod evaluate_obligation;\n-mod generic_types;\n mod implied_outlives_bounds;\n pub mod lowering;\n mod normalize_erasing_regions;\n@@ -28,7 +26,6 @@ pub fn provide(p: &mut Providers<'_>) {\n     evaluate_obligation::provide(p);\n     implied_outlives_bounds::provide(p);\n     lowering::provide(p);\n-    chalk_context::provide(p);\n     normalize_projection_ty::provide(p);\n     normalize_erasing_regions::provide(p);\n     type_op::provide(p);"}, {"sha": "6bc29d0493e685334fd4e84cb563502fe557bd90", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3777c952f1752de0762e3f0882ac5ffb6eeb7ee/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=b3777c952f1752de0762e3f0882ac5ffb6eeb7ee", "patch": "@@ -252,11 +252,8 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     // are any errors at that point, so after type checking you can be\n     // sure that this will succeed without errors anyway.\n \n-    let unnormalized_env = ty::ParamEnv::new(\n-        tcx.intern_predicates(&predicates),\n-        traits::Reveal::UserFacing,\n-        tcx.sess.opts.debugging_opts.chalk.then_some(def_id),\n-    );\n+    let unnormalized_env =\n+        ty::ParamEnv::new(tcx.intern_predicates(&predicates), traits::Reveal::UserFacing, None);\n \n     let body_id = tcx.hir().as_local_hir_id(def_id).map_or(hir::DUMMY_HIR_ID, |id| {\n         tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.hir_id)"}, {"sha": "df25bad622b3d09e83d3d6090f176f5cf914e887", "filename": "src/test/compile-fail/chalkify/chalk_initial_program.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fchalk_initial_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fchalk_initial_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fchalk_initial_program.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,16 +0,0 @@\n-// compile-flags: -Z chalk\n-\n-trait Foo { }\n-\n-impl Foo for i32 { }\n-\n-impl Foo for u32 { }\n-\n-fn gimme<F: Foo>() { }\n-\n-// Note: this also tests that `std::process::Termination` is implemented for `()`.\n-fn main() {\n-    gimme::<i32>();\n-    gimme::<u32>();\n-    gimme::<f32>(); //~ERROR the trait bound `f32: Foo` is not satisfied\n-}"}, {"sha": "d70c6f8055ddf92adfd332a3d1963888ed08ce93", "filename": "src/test/compile-fail/chalkify/generic_impls.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fgeneric_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fgeneric_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fgeneric_impls.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,18 +0,0 @@\n-// compile-flags: -Z chalk\n-\n-trait Foo { }\n-\n-impl<T> Foo for (T, u32) { }\n-\n-fn gimme<F: Foo>() { }\n-\n-fn foo<T>() {\n-    gimme::<(T, u32)>();\n-    gimme::<(Option<T>, u32)>();\n-    gimme::<(Option<T>, f32)>(); //~ ERROR\n-}\n-\n-fn main() {\n-    gimme::<(i32, u32)>();\n-    gimme::<(i32, f32)>(); //~ ERROR\n-}"}, {"sha": "6bb4cf86e7986aef58f568d368dd25e5b1516961", "filename": "src/test/compile-fail/chalkify/impl_wf.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fimpl_wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fimpl_wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fimpl_wf.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,39 +0,0 @@\n-// compile-flags: -Z chalk\n-\n-trait Foo: Sized { }\n-\n-trait Bar {\n-    type Item: Foo;\n-}\n-\n-impl Foo for i32 { }\n-\n-impl Foo for str { }\n-//~^ ERROR the size for values of type `str` cannot be known at compilation time\n-\n-// Implicit `T: Sized` bound.\n-impl<T> Foo for Option<T> { }\n-\n-impl Bar for () {\n-    type Item = i32;\n-}\n-\n-impl<T> Bar for Option<T> {\n-    type Item = Option<T>;\n-}\n-\n-impl Bar for f32 {\n-//~^ ERROR the trait bound `f32: Foo` is not satisfied\n-    type Item = f32;\n-    //~^ ERROR the trait bound `f32: Foo` is not satisfied\n-}\n-\n-trait Baz<U: ?Sized> where U: Foo { }\n-\n-impl Baz<i32> for i32 { }\n-\n-impl Baz<f32> for f32 { }\n-//~^ ERROR the trait bound `f32: Foo` is not satisfied\n-\n-fn main() {\n-}"}, {"sha": "861f86e61658aed0fb02b4ee4bebb55b337cc0be", "filename": "src/test/compile-fail/chalkify/recursive_where_clause_on_type.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fcompile-fail%2Fchalkify%2Frecursive_where_clause_on_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fcompile-fail%2Fchalkify%2Frecursive_where_clause_on_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchalkify%2Frecursive_where_clause_on_type.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,28 +0,0 @@\n-// compile-flags: -Z chalk\n-\n-#![feature(trivial_bounds)]\n-\n-trait Bar {\n-    fn foo();\n-}\n-trait Foo: Bar { }\n-\n-struct S where S: Foo;\n-\n-impl Foo for S {\n-}\n-\n-fn bar<T: Bar>() {\n-    T::foo();\n-}\n-\n-fn foo<T: Foo>() {\n-    bar::<T>()\n-}\n-\n-fn main() {\n-    // For some reason, the error is duplicated...\n-\n-    foo::<S>() //~ ERROR the type `S` is not well-formed (chalk)\n-    //~^ ERROR the type `S` is not well-formed (chalk)\n-}"}, {"sha": "d1aa975ddc24d701a54f68b7b67db019dd53a7cf", "filename": "src/test/compile-fail/chalkify/type_wf.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fcompile-fail%2Fchalkify%2Ftype_wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fcompile-fail%2Fchalkify%2Ftype_wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchalkify%2Ftype_wf.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,24 +0,0 @@\n-// compile-flags: -Z chalk\n-\n-trait Foo { }\n-\n-struct S<T: Foo> {\n-    x: T,\n-}\n-\n-impl Foo for i32 { }\n-impl<T> Foo for Option<T> { }\n-\n-fn main() {\n-    let s = S {\n-       x: 5,\n-    };\n-\n-    let s = S { //~ ERROR the trait bound `{float}: Foo` is not satisfied\n-        x: 5.0,\n-    };\n-\n-    let s = S {\n-        x: Some(5.0),\n-    };\n-}"}, {"sha": "d403514b553b079d4ac6c1cb782c6e6742a9dadc", "filename": "src/test/ui/chalkify/builtin-copy-clone.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Fbuiltin-copy-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Fbuiltin-copy-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fbuiltin-copy-clone.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,44 +0,0 @@\n-// run-pass\n-// compile-flags: -Z chalk\n-\n-// Test that `Clone` is correctly implemented for builtin types.\n-\n-#[derive(Copy, Clone)]\n-struct S(i32);\n-\n-fn test_clone<T: Clone>(arg: T) {\n-    let _ = arg.clone();\n-}\n-\n-fn test_copy<T: Copy>(arg: T) {\n-    let _ = arg;\n-    let _ = arg;\n-}\n-\n-fn test_copy_clone<T: Copy + Clone>(arg: T) {\n-    test_copy(arg);\n-    test_clone(arg);\n-}\n-\n-fn foo() { }\n-\n-fn main() {\n-    test_copy_clone(foo);\n-    let f: fn() = foo;\n-    test_copy_clone(f);\n-    // FIXME: add closures when they're considered WF\n-    test_copy_clone([1; 56]);\n-    test_copy_clone((1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1));\n-    test_copy_clone((1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, true, 'a', 1.1));\n-    test_copy_clone(());\n-    test_copy_clone(((1, 1), (1, 1, 1), (1.1, 1, 1, 'a'), ()));\n-\n-    let a = (\n-        (S(1), S(0)),\n-        (\n-            (S(0), S(0), S(1)),\n-            S(0)\n-        )\n-    );\n-    test_copy_clone(a);\n-}"}, {"sha": "44e120c1eebbaabfd4bd162118ff3943199b5303", "filename": "src/test/ui/chalkify/inherent_impl.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,42 +0,0 @@\n-// run-pass\n-// compile-flags: -Z chalk\n-\n-trait Foo { }\n-\n-impl Foo for i32 { }\n-\n-struct S<T: Foo> {\n-    x: T,\n-}\n-\n-fn only_foo<T: Foo>(_x: &T) { }\n-\n-impl<T> S<T> {\n-    // Test that we have the correct environment inside an inherent method.\n-    fn dummy_foo(&self) {\n-        only_foo(&self.x)\n-    }\n-}\n-\n-trait Bar { }\n-impl Bar for u32 { }\n-\n-fn only_bar<T: Bar>() { }\n-\n-impl<T> S<T> {\n-    // Test that the environment of `dummy_bar` adds up with the environment\n-    // of the inherent impl.\n-    fn dummy_bar<U: Bar>(&self) {\n-        only_foo(&self.x);\n-        only_bar::<U>();\n-    }\n-}\n-\n-fn main() {\n-    let s = S {\n-        x: 5,\n-    };\n-\n-    s.dummy_foo();\n-    s.dummy_bar::<u32>();\n-}"}, {"sha": "afb6bddbf26a54ca92e2cdddf70a3e874dca7e30", "filename": "src/test/ui/chalkify/lower_env1.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,14 +0,0 @@\n-#![feature(rustc_attrs)]\n-#![allow(dead_code)]\n-\n-trait Foo { }\n-\n-#[rustc_dump_program_clauses] //~ ERROR program clause dump\n-trait Bar where Self: Foo { }\n-\n-#[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n-fn bar<T: Bar + ?Sized>() {\n-}\n-\n-fn main() {\n-}"}, {"sha": "bc426e0707b7c22ffead810fbe78cfa865f7163b", "filename": "src/test/ui/chalkify/lower_env1.stderr", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.stderr?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,22 +0,0 @@\n-error: program clause dump\n-  --> $DIR/lower_env1.rs:6:1\n-   |\n-LL | #[rustc_dump_program_clauses]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: forall<Self> { FromEnv(Self: Foo) :- FromEnv(Self: Bar). }\n-   = note: forall<Self> { Implemented(Self: Bar) :- FromEnv(Self: Bar). }\n-   = note: forall<Self> { WellFormed(Self: Bar) :- Implemented(Self: Bar), WellFormed(Self: Foo). }\n-\n-error: program clause dump\n-  --> $DIR/lower_env1.rs:9:1\n-   |\n-LL | #[rustc_dump_env_program_clauses]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: forall<Self> { FromEnv(Self: Foo) :- FromEnv(Self: Bar). }\n-   = note: forall<Self> { Implemented(Self: Bar) :- FromEnv(Self: Bar). }\n-   = note: forall<Self> { Implemented(Self: Foo) :- FromEnv(Self: Foo). }\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "a067575a9cfd2bfc5d1e9e41d3c7b6270612f2b5", "filename": "src/test/ui/chalkify/lower_env2.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,16 +0,0 @@\n-#![feature(rustc_attrs)]\n-#![allow(dead_code)]\n-\n-trait Foo { }\n-\n-#[rustc_dump_program_clauses] //~ ERROR program clause dump\n-struct S<'a, T: ?Sized> where T: Foo {\n-    data: &'a T,\n-}\n-\n-#[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n-fn bar<T: Foo>(_x: S<'_, T>) { // note that we have an implicit `T: Sized` bound\n-}\n-\n-fn main() {\n-}"}, {"sha": "613a568a8549c95a7711747f48791d80750bb2db", "filename": "src/test/ui/chalkify/lower_env2.stderr", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.stderr?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,23 +0,0 @@\n-error: program clause dump\n-  --> $DIR/lower_env2.rs:6:1\n-   |\n-LL | #[rustc_dump_program_clauses]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: forall<'a, T> { FromEnv(T: Foo) :- FromEnv(S<'a, T>). }\n-   = note: forall<'a, T> { TypeOutlives(T: 'a) :- FromEnv(S<'a, T>). }\n-   = note: forall<'a, T> { WellFormed(S<'a, T>) :- WellFormed(T: Foo), TypeOutlives(T: 'a). }\n-\n-error: program clause dump\n-  --> $DIR/lower_env2.rs:11:1\n-   |\n-LL | #[rustc_dump_env_program_clauses]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: forall<'a, T> { FromEnv(T: Foo) :- FromEnv(S<'a, T>). }\n-   = note: forall<'a, T> { TypeOutlives(T: 'a) :- FromEnv(S<'a, T>). }\n-   = note: forall<Self> { Implemented(Self: Foo) :- FromEnv(Self: Foo). }\n-   = note: forall<Self> { Implemented(Self: std::marker::Sized) :- FromEnv(Self: std::marker::Sized). }\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "61ed3cbb277815c5e9e1a455b6e9b3cff4ca5a92", "filename": "src/test/ui/chalkify/lower_env3.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,16 +0,0 @@\n-#![feature(rustc_attrs)]\n-#![allow(dead_code)]\n-\n-trait Foo {\n-    #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n-    fn foo(&self);\n-}\n-\n-impl<T> Foo for T where T: Clone {\n-    #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n-    fn foo(&self) {\n-    }\n-}\n-\n-fn main() {\n-}"}, {"sha": "a1fc83bfea8a3a0b5a6c7d4a034e92b6cb451eba", "filename": "src/test/ui/chalkify/lower_env3.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.stderr?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,20 +0,0 @@\n-error: program clause dump\n-  --> $DIR/lower_env3.rs:5:5\n-   |\n-LL |     #[rustc_dump_env_program_clauses]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: forall<Self> { Implemented(Self: Foo) :- FromEnv(Self: Foo). }\n-\n-error: program clause dump\n-  --> $DIR/lower_env3.rs:10:5\n-   |\n-LL |     #[rustc_dump_env_program_clauses]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: forall<Self> { FromEnv(Self: std::marker::Sized) :- FromEnv(Self: std::clone::Clone). }\n-   = note: forall<Self> { Implemented(Self: std::clone::Clone) :- FromEnv(Self: std::clone::Clone). }\n-   = note: forall<Self> { Implemented(Self: std::marker::Sized) :- FromEnv(Self: std::marker::Sized). }\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "1bd44a9f49895f3dec0b3e01b0de120be446f82b", "filename": "src/test/ui/chalkify/lower_impl.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,19 +0,0 @@\n-#![feature(rustc_attrs)]\n-\n-trait Foo { }\n-\n-#[rustc_dump_program_clauses] //~ ERROR program clause dump\n-impl<T: 'static> Foo for T where T: Iterator<Item = i32> { }\n-\n-trait Bar {\n-    type Assoc;\n-}\n-\n-impl<T> Bar for T where T: Iterator<Item = i32> {\n-    #[rustc_dump_program_clauses] //~ ERROR program clause dump\n-    type Assoc = Vec<T>;\n-}\n-\n-fn main() {\n-    println!(\"hello\");\n-}"}, {"sha": "d6827fbff3dd73e091f02ac16969dbf3101098d7", "filename": "src/test/ui/chalkify/lower_impl.stderr", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.stderr?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,18 +0,0 @@\n-error: program clause dump\n-  --> $DIR/lower_impl.rs:5:1\n-   |\n-LL | #[rustc_dump_program_clauses]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: forall<T> { Implemented(T: Foo) :- ProjectionEq(<T as std::iter::Iterator>::Item == i32), TypeOutlives(T: 'static), Implemented(T: std::iter::Iterator), Implemented(T: std::marker::Sized). }\n-\n-error: program clause dump\n-  --> $DIR/lower_impl.rs:13:5\n-   |\n-LL |     #[rustc_dump_program_clauses]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: forall<T> { Normalize(<T as Bar>::Assoc -> std::vec::Vec<T>) :- Implemented(T: Bar). }\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "aecccea5c142c25407f44b1b1d93c205b7fbbefe", "filename": "src/test/ui/chalkify/lower_struct.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,8 +0,0 @@\n-#![feature(rustc_attrs)]\n-\n-#[rustc_dump_program_clauses] //~ ERROR program clause dump\n-struct Foo<'a, T> where Box<T>: Clone {\n-    _x: std::marker::PhantomData<&'a T>,\n-}\n-\n-fn main() { }"}, {"sha": "0331c2fca16db3bb5987a3668978734d513bcd05", "filename": "src/test/ui/chalkify/lower_struct.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.stderr?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,13 +0,0 @@\n-error: program clause dump\n-  --> $DIR/lower_struct.rs:3:1\n-   |\n-LL | #[rustc_dump_program_clauses]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: forall<'a, T> { FromEnv(T: std::marker::Sized) :- FromEnv(Foo<'a, T>). }\n-   = note: forall<'a, T> { FromEnv(std::boxed::Box<T>: std::clone::Clone) :- FromEnv(Foo<'a, T>). }\n-   = note: forall<'a, T> { TypeOutlives(T: 'a) :- FromEnv(Foo<'a, T>). }\n-   = note: forall<'a, T> { WellFormed(Foo<'a, T>) :- WellFormed(T: std::marker::Sized), WellFormed(std::boxed::Box<T>: std::clone::Clone), TypeOutlives(T: 'a). }\n-\n-error: aborting due to previous error\n-"}, {"sha": "0e1956022f9fe5f61458ceb1078de82122dc0a67", "filename": "src/test/ui/chalkify/lower_trait.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,13 +0,0 @@\n-#![feature(rustc_attrs)]\n-\n-trait Bar { }\n-\n-#[rustc_dump_program_clauses] //~ ERROR program clause dump\n-trait Foo<S, T: ?Sized> {\n-    #[rustc_dump_program_clauses] //~ ERROR program clause dump\n-    type Assoc: Bar + ?Sized;\n-}\n-\n-fn main() {\n-    println!(\"hello\");\n-}"}, {"sha": "ed3bded398ae3955f9876f0ef1e967903e2cbfbe", "filename": "src/test/ui/chalkify/lower_trait.stderr", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.stderr?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,24 +0,0 @@\n-error: program clause dump\n-  --> $DIR/lower_trait.rs:5:1\n-   |\n-LL | #[rustc_dump_program_clauses]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: forall<Self, S, T> { FromEnv(<Self as Foo<S, T>>::Assoc: Bar) :- FromEnv(Self: Foo<S, T>). }\n-   = note: forall<Self, S, T> { FromEnv(S: std::marker::Sized) :- FromEnv(Self: Foo<S, T>). }\n-   = note: forall<Self, S, T> { Implemented(Self: Foo<S, T>) :- FromEnv(Self: Foo<S, T>). }\n-   = note: forall<Self, S, T> { WellFormed(Self: Foo<S, T>) :- Implemented(Self: Foo<S, T>), WellFormed(S: std::marker::Sized), WellFormed(<Self as Foo<S, T>>::Assoc: Bar). }\n-\n-error: program clause dump\n-  --> $DIR/lower_trait.rs:7:5\n-   |\n-LL |     #[rustc_dump_program_clauses]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: forall<Self, S, T, ^3> { ProjectionEq(<Self as Foo<S, T>>::Assoc == ^3) :- Normalize(<Self as Foo<S, T>>::Assoc -> ^3). }\n-   = note: forall<Self, S, T> { FromEnv(Self: Foo<S, T>) :- FromEnv(Unnormalized(<Self as Foo<S, T>>::Assoc)). }\n-   = note: forall<Self, S, T> { ProjectionEq(<Self as Foo<S, T>>::Assoc == Unnormalized(<Self as Foo<S, T>>::Assoc)). }\n-   = note: forall<Self, S, T> { WellFormed(Unnormalized(<Self as Foo<S, T>>::Assoc)) :- WellFormed(Self: Foo<S, T>). }\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "715f09632bd7e7f0fd814dcded009963301f73c6", "filename": "src/test/ui/chalkify/lower_trait_higher_rank.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,10 +0,0 @@\n-#![feature(rustc_attrs)]\n-\n-#[rustc_dump_program_clauses] //~ ERROR program clause dump\n-trait Foo<F: ?Sized> where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8\n-{\n-}\n-\n-fn main() {\n-    println!(\"hello\");\n-}"}, {"sha": "79bbc9fa6b3a63249d927f3f9e221df25b984446", "filename": "src/test/ui/chalkify/lower_trait_higher_rank.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.stderr?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,13 +0,0 @@\n-error: program clause dump\n-  --> $DIR/lower_trait_higher_rank.rs:3:1\n-   |\n-LL | #[rustc_dump_program_clauses]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: forall<'a, Self, F> { FromEnv(F: std::ops::Fn<(&'a (u8, u16),)>) :- FromEnv(Self: Foo<F>). }\n-   = note: forall<'a, Self, F> { ProjectionEq(<F as std::ops::FnOnce<(&'a (u8, u16),)>>::Output == &'a u8) :- FromEnv(Self: Foo<F>). }\n-   = note: forall<Self, F> { Implemented(Self: Foo<F>) :- FromEnv(Self: Foo<F>). }\n-   = note: forall<Self, F> { WellFormed(Self: Foo<F>) :- Implemented(Self: Foo<F>), forall<'a> { WellFormed(F: std::ops::Fn<(&'a (u8, u16),)>) }, forall<'a> { ProjectionEq(<F as std::ops::FnOnce<(&'a (u8, u16),)>>::Output == &'a u8) }. }\n-\n-error: aborting due to previous error\n-"}, {"sha": "78fa39f1dc1253388ee138ef14cc3cfd6c6bf619", "filename": "src/test/ui/chalkify/lower_trait_where_clause.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,17 +0,0 @@\n-#![feature(rustc_attrs)]\n-\n-use std::borrow::Borrow;\n-\n-#[rustc_dump_program_clauses] //~ ERROR program clause dump\n-trait Foo<'a, 'b, T, U>\n-where\n-    T: Borrow<U> + ?Sized,\n-    U: ?Sized + 'b,\n-    'a: 'b,\n-    Box<T>:, // NOTE(#53696) this checks an empty list of bounds.\n-{\n-}\n-\n-fn main() {\n-    println!(\"hello\");\n-}"}, {"sha": "408f3712a707004080b1397be39334f1276dedb1", "filename": "src/test/ui/chalkify/lower_trait_where_clause.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.stderr?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,15 +0,0 @@\n-error: program clause dump\n-  --> $DIR/lower_trait_where_clause.rs:5:1\n-   |\n-LL | #[rustc_dump_program_clauses]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: forall<'a, 'b, Self, T, U> { FromEnv(T: std::borrow::Borrow<U>) :- FromEnv(Self: Foo<'a, 'b, T, U>). }\n-   = note: forall<'a, 'b, Self, T, U> { Implemented(Self: Foo<'a, 'b, T, U>) :- FromEnv(Self: Foo<'a, 'b, T, U>). }\n-   = note: forall<'a, 'b, Self, T, U> { RegionOutlives('a: 'b) :- FromEnv(Self: Foo<'a, 'b, T, U>). }\n-   = note: forall<'a, 'b, Self, T, U> { TypeOutlives(U: 'b) :- FromEnv(Self: Foo<'a, 'b, T, U>). }\n-   = note: forall<'a, 'b, Self, T, U> { TypeOutlives(std::boxed::Box<T>: '<empty>) :- FromEnv(Self: Foo<'a, 'b, T, U>). }\n-   = note: forall<'a, 'b, Self, T, U> { WellFormed(Self: Foo<'a, 'b, T, U>) :- Implemented(Self: Foo<'a, 'b, T, U>), WellFormed(T: std::borrow::Borrow<U>), TypeOutlives(U: 'b), RegionOutlives('a: 'b), TypeOutlives(std::boxed::Box<T>: '<empty>). }\n-\n-error: aborting due to previous error\n-"}, {"sha": "d6a8dd7a4a20317ddadfd00f2659683b1cd8bbae", "filename": "src/test/ui/chalkify/projection.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fprojection.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,25 +0,0 @@\n-// run-pass\n-// compile-flags: -Z chalk\n-\n-trait Foo { }\n-\n-trait Bar {\n-    type Item: Foo;\n-}\n-\n-impl Foo for i32 { }\n-impl Bar for i32 {\n-    type Item = i32;\n-}\n-\n-fn only_foo<T: Foo>() { }\n-\n-fn only_bar<T: Bar>() {\n-    // `T` implements `Bar` hence `<T as Bar>::Item` must also implement `Bar`\n-    only_foo::<T::Item>()\n-}\n-\n-fn main() {\n-    only_bar::<i32>();\n-    only_foo::<<i32 as Bar>::Item>();\n-}"}, {"sha": "eeff9fd9b80a36098d7f90944fab6d08f56ab092", "filename": "src/test/ui/chalkify/super_trait.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Fsuper_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Fsuper_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fsuper_trait.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,19 +0,0 @@\n-// run-pass\n-// compile-flags: -Z chalk\n-\n-trait Foo { }\n-trait Bar: Foo { }\n-\n-impl Foo for i32 { }\n-impl Bar for i32 { }\n-\n-fn only_foo<T: Foo>() { }\n-\n-fn only_bar<T: Bar>() {\n-    // `T` implements `Bar` hence `T` must also implement `Foo`\n-    only_foo::<T>()\n-}\n-\n-fn main() {\n-    only_bar::<i32>()\n-}"}, {"sha": "8a2e1cf599008acd80bcb98765711110013d3642", "filename": "src/test/ui/chalkify/trait_implied_bound.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Ftrait_implied_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Ftrait_implied_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftrait_implied_bound.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,18 +0,0 @@\n-// run-pass\n-// compile-flags: -Z chalk\n-\n-trait Foo { }\n-trait Bar<U> where U: Foo { }\n-\n-impl Foo for i32 { }\n-impl Bar<i32> for i32 { }\n-\n-fn only_foo<T: Foo>() { }\n-\n-fn only_bar<U, T: Bar<U>>() {\n-    only_foo::<U>()\n-}\n-\n-fn main() {\n-    only_bar::<i32, i32>()\n-}"}, {"sha": "8673f5319bdf05c55bf580eb1fb33967590b1ed6", "filename": "src/test/ui/chalkify/type_implied_bound.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Ftype_implied_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Ftype_implied_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_implied_bound.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,29 +0,0 @@\n-// run-pass\n-// compile-flags: -Z chalk\n-\n-trait Eq { }\n-trait Hash: Eq { }\n-\n-impl Eq for i32 { }\n-impl Hash for i32 { }\n-\n-struct Set<T: Hash> {\n-    _x: T,\n-}\n-\n-fn only_eq<T: Eq>() { }\n-\n-fn take_a_set<T>(_: &Set<T>) {\n-    // `Set<T>` is an input type of `take_a_set`, hence we know that\n-    // `T` must implement `Hash`, and we know in turn that `T` must\n-    // implement `Eq`.\n-    only_eq::<T>()\n-}\n-\n-fn main() {\n-    let set = Set {\n-        _x: 5,\n-    };\n-\n-    take_a_set(&set);\n-}"}, {"sha": "62a53ec0317b3f5942c100ca2e2db3ec3e7cd5fc", "filename": "src/test/ui/chalkify/type_inference.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,26 +0,0 @@\n-// compile-flags: -Z chalk\n-\n-trait Foo { }\n-impl Foo for i32 { }\n-\n-trait Bar { }\n-impl Bar for i32 { }\n-impl Bar for u32 { }\n-\n-fn only_foo<T: Foo>(_x: T) { }\n-\n-fn only_bar<T: Bar>(_x: T) { }\n-\n-fn main() {\n-    let x = 5.0;\n-\n-    // The only type which implements `Foo` is `i32`, so the chalk trait solver\n-    // is expecting a variable of type `i32`. This behavior differs from the\n-    // old-style trait solver. I guess this will change, that's why I'm\n-    // adding that test.\n-    only_foo(x); //~ ERROR mismatched types\n-\n-    // Here we have two solutions so we get back the behavior of the old-style\n-    // trait solver.\n-    only_bar(x); //~ ERROR the trait bound `{float}: Bar` is not satisfied\n-}"}, {"sha": "b8152caf3d29f21dd57b210240747dc2f28da230", "filename": "src/test/ui/chalkify/type_inference.stderr", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,23 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/type_inference.rs:21:14\n-   |\n-LL |     only_foo(x);\n-   |              ^ expected `i32`, found floating-point number\n-\n-error[E0277]: the trait bound `{float}: Bar` is not satisfied\n-  --> $DIR/type_inference.rs:25:5\n-   |\n-LL | fn only_bar<T: Bar>(_x: T) { }\n-   |    --------    --- required by this bound in `only_bar`\n-...\n-LL |     only_bar(x);\n-   |     ^^^^^^^^ the trait `Bar` is not implemented for `{float}`\n-   |\n-   = help: the following implementations were found:\n-             <i32 as Bar>\n-             <u32 as Bar>\n-\n-error: aborting due to 2 previous errors\n-\n-Some errors have detailed explanations: E0277, E0308.\n-For more information about an error, try `rustc --explain E0277`."}, {"sha": "3ca527313f93f9f38c3acb8a1201e83e504f1314", "filename": "src/test/ui/const-generics/issues/issue-65675.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.rs?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,10 +0,0 @@\n-// run-pass\n-// compile-flags: -Z chalk\n-\n-#![feature(const_generics)]\n-//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n-\n-pub struct Foo<T, const N: usize>([T; N]);\n-impl<T, const N: usize> Foo<T, {N}> {}\n-\n-fn main() {}"}, {"sha": "60b388e62783e9da22f85f155b03fb2db61a09b7", "filename": "src/test/ui/const-generics/issues/issue-65675.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18c275b423f9f13c0e404ae3804967d2ab66337c/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-65675.stderr?ref=18c275b423f9f13c0e404ae3804967d2ab66337c", "patch": "@@ -1,8 +0,0 @@\n-warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n-  --> $DIR/issue-65675.rs:4:12\n-   |\n-LL | #![feature(const_generics)]\n-   |            ^^^^^^^^^^^^^^\n-   |\n-   = note: `#[warn(incomplete_features)]` on by default\n-"}]}