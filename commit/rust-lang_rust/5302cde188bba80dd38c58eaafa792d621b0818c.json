{"sha": "5302cde188bba80dd38c58eaafa792d621b0818c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMDJjZGUxODhiYmE4MGRkMzhjNThlYWFmYTc5MmQ2MjFiMDgxOGM=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-26T01:00:37Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-28T17:47:28Z"}, "message": "Made task threads wait instead of sleep, so they can be woken up. This appears to give us much better parallel performance.\n\nAlso, commented out one more unsafe log and updated rust_kernel.cpp to compile under g++", "tree": {"sha": "663ca3e81a7254548e756ea0dfef66d4362f971a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/663ca3e81a7254548e756ea0dfef66d4362f971a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5302cde188bba80dd38c58eaafa792d621b0818c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5302cde188bba80dd38c58eaafa792d621b0818c", "html_url": "https://github.com/rust-lang/rust/commit/5302cde188bba80dd38c58eaafa792d621b0818c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5302cde188bba80dd38c58eaafa792d621b0818c/comments", "author": null, "committer": null, "parents": [{"sha": "e697a52359874c2b7387be96e664b1f94b14255b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e697a52359874c2b7387be96e664b1f94b14255b", "html_url": "https://github.com/rust-lang/rust/commit/e697a52359874c2b7387be96e664b1f94b14255b"}], "stats": {"total": 83, "additions": 61, "deletions": 22}, "files": [{"sha": "ba098bbee3f20eb3fad245a461af3d64186fd6b1", "filename": "src/rt/circular_buffer.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5302cde188bba80dd38c58eaafa792d621b0818c/src%2Frt%2Fcircular_buffer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5302cde188bba80dd38c58eaafa792d621b0818c/src%2Frt%2Fcircular_buffer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fcircular_buffer.cpp?ref=5302cde188bba80dd38c58eaafa792d621b0818c", "patch": "@@ -123,7 +123,7 @@ circular_buffer::dequeue(void *dst) {\n     if (dst != NULL) {\n         memcpy(dst, &_buffer[_next], unit_sz);\n     }\n-    DLOG(sched, mem, \"shifted data from index %d\", _next);\n+    //DLOG(sched, mem, \"shifted data from index %d\", _next);\n     _unread -= unit_sz;\n     _next += unit_sz;\n     if (_next == _buffer_sz) {"}, {"sha": "9cdf07cd759f93dfa24ead3ce116701e8384201e", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5302cde188bba80dd38c58eaafa792d621b0818c/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5302cde188bba80dd38c58eaafa792d621b0818c/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=5302cde188bba80dd38c58eaafa792d621b0818c", "patch": "@@ -53,13 +53,13 @@ rust_kernel::destroy_scheduler(rust_scheduler *sched) {\n }\n \n void rust_kernel::create_schedulers() {\n-    for(int i = 0; i < num_threads; ++i) {\n+    for(size_t i = 0; i < num_threads; ++i) {\n         threads.push(create_scheduler(i));\n     }\n }\n \n void rust_kernel::destroy_schedulers() {\n-    for(int i = 0; i < num_threads; ++i) {\n+    for(size_t i = 0; i < num_threads; ++i) {\n         destroy_scheduler(threads[i]);\n     }\n }\n@@ -106,7 +106,7 @@ rust_kernel::get_port_handle(rust_port *port) {\n \n void\n rust_kernel::log_all_scheduler_state() {\n-    for(int i = 0; i < num_threads; ++i) {\n+    for(size_t i = 0; i < num_threads; ++i) {\n         threads[i]->log_state();\n     }\n }\n@@ -252,12 +252,12 @@ rust_kernel::signal_kernel_lock() {\n \n int rust_kernel::start_task_threads()\n {\n-    for(int i = 0; i < num_threads; ++i) {\n+    for(size_t i = 0; i < num_threads; ++i) {\n         rust_scheduler *thread = threads[i];\n         thread->start();\n     }\n \n-    for(int i = 0; i < num_threads; ++i) {\n+    for(size_t i = 0; i < num_threads; ++i) {\n         rust_scheduler *thread = threads[i];\n         thread->join();\n     }\n@@ -271,6 +271,12 @@ rust_kernel::create_task(rust_task *spawner, const char *name) {\n     return threads[rand(&rctx) % num_threads]->create_task(spawner, name);\n }\n \n+void rust_kernel::wakeup_schedulers() {\n+    for(size_t i = 0; i < num_threads; ++i) {\n+        threads[i]->lock.signal_all();\n+    }\n+}\n+\n #ifdef __WIN32__\n void\n rust_kernel::win32_require(LPCTSTR fn, BOOL ok) {"}, {"sha": "cf9d88e00164a7c4c0516ea401e3cb79cf8c5c2e", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5302cde188bba80dd38c58eaafa792d621b0818c/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/5302cde188bba80dd38c58eaafa792d621b0818c/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=5302cde188bba80dd38c58eaafa792d621b0818c", "patch": "@@ -106,6 +106,7 @@ class rust_kernel : public rust_thread {\n     bool is_deadlocked();\n \n     void signal_kernel_lock();\n+    void wakeup_schedulers();\n \n     /**\n      * Notifies the kernel whenever a message has been enqueued . This gives"}, {"sha": "4f19b0c681b1a5a43e0c330b310f77e7182ae1bf", "filename": "src/rt/rust_scheduler.cpp", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5302cde188bba80dd38c58eaafa792d621b0818c/src%2Frt%2Frust_scheduler.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5302cde188bba80dd38c58eaafa792d621b0818c/src%2Frt%2Frust_scheduler.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.cpp?ref=5302cde188bba80dd38c58eaafa792d621b0818c", "patch": "@@ -87,17 +87,21 @@ rust_scheduler::reap_dead_tasks(int id) {\n     I(this, lock.lock_held_by_current_thread());\n     for (size_t i = 0; i < dead_tasks.length(); ) {\n         rust_task *task = dead_tasks[i];\n+        task->lock.lock();\n         // Make sure this task isn't still running somewhere else...\n         if (task->ref_count == 0 && task->can_schedule(id)) {\n             I(this, task->tasks_waiting_to_join.is_empty());\n             dead_tasks.remove(task);\n             DLOG(this, task,\n                 \"deleting unreferenced dead task %s @0x%\" PRIxPTR,\n                 task->name, task);\n+            task->lock.unlock();\n             delete task;\n             sync::decrement(kernel->live_tasks);\n+            kernel->wakeup_schedulers();\n             continue;\n         }\n+        task->lock.unlock();\n         ++i;\n     }\n }\n@@ -206,21 +210,15 @@ rust_scheduler::start_main_loop() {\n \n         rust_task *scheduled_task = schedule_task(id);\n \n-        // The scheduler busy waits until a task is available for scheduling.\n-        // Eventually we'll want a smarter way to do this, perhaps sleep\n-        // for a minimum amount of time.\n-\n         if (scheduled_task == NULL) {\n             log_state();\n             DLOG(this, task,\n                  \"all tasks are blocked, scheduler id %d yielding ...\",\n                  id);\n-            lock.unlock();\n-            sync::sleep(100);\n-            lock.lock();\n-            DLOG(this, task,\n-                \"scheduler resuming ...\");\n+            lock.timed_wait(100000);\n             reap_dead_tasks(id);\n+            DLOG(this, task,\n+                 \"scheduler %d resuming ...\", id);\n             continue;\n         }\n "}, {"sha": "05efc12e4d43bbe2ee821b7e6cb17df31ba23831", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5302cde188bba80dd38c58eaafa792d621b0818c/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5302cde188bba80dd38c58eaafa792d621b0818c/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=5302cde188bba80dd38c58eaafa792d621b0818c", "patch": "@@ -105,7 +105,7 @@ rust_task::~rust_task()\n \n     /* FIXME: tighten this up, there are some more\n        assertions that hold at task-lifecycle events. */\n-    // I(sched, ref_count == 0 ||\n+    I(sched, ref_count == 0); // ||\n     //   (ref_count == 1 && this == sched->root_task));\n \n     del_stk(this, stk);\n@@ -167,6 +167,7 @@ rust_task::start(uintptr_t spawnee_fn,\n \n     yield_timer.reset_us(0);\n     transition(&sched->newborn_tasks, &sched->running_tasks);\n+    sched->lock.signal();\n }\n \n void\n@@ -212,6 +213,8 @@ rust_task::kill() {\n     if (NULL == supervisor && propagate_failure)\n         sched->fail();\n \n+    sched->lock.signal();\n+\n     LOG(this, task, \"preparing to unwind task: 0x%\" PRIxPTR, this);\n     // run_on_resume(rust_unwind_glue);\n }\n@@ -442,12 +445,15 @@ rust_task::wakeup(rust_cond *from) {\n     if(_on_wakeup) {\n         _on_wakeup->on_wakeup();\n     }\n+\n+    sched->lock.signal();\n }\n \n void\n rust_task::die() {\n     scoped_lock with(lock);\n     transition(&sched->running_tasks, &sched->dead_tasks);\n+    sched->lock.signal();\n }\n \n void"}, {"sha": "f4c3778837d058a631217a51f6a2359cc103c188", "filename": "src/rt/sync/lock_and_signal.cpp", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5302cde188bba80dd38c58eaafa792d621b0818c/src%2Frt%2Fsync%2Flock_and_signal.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5302cde188bba80dd38c58eaafa792d621b0818c/src%2Frt%2Fsync%2Flock_and_signal.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.cpp?ref=5302cde188bba80dd38c58eaafa792d621b0818c", "patch": "@@ -10,7 +10,9 @@\n #include \"lock_and_signal.h\"\n \n #if defined(__WIN32__)\n-lock_and_signal::lock_and_signal() {\n+lock_and_signal::lock_and_signal() \n+    : alive(true)\n+{\n     // FIXME: In order to match the behavior of pthread_cond_broadcast on\n     // Windows, we create manual reset events. This however breaks the\n     // behavior of pthread_cond_signal, fixing this is quite involved:\n@@ -22,7 +24,7 @@ lock_and_signal::lock_and_signal() {\n \n #else\n lock_and_signal::lock_and_signal()\n-    : _locked(false)\n+    : _locked(false), alive(true)\n {\n     CHECKED(pthread_cond_init(&_cond, NULL));\n     CHECKED(pthread_mutex_init(&_mutex, NULL));\n@@ -36,6 +38,7 @@ lock_and_signal::~lock_and_signal() {\n     CHECKED(pthread_cond_destroy(&_cond));\n     CHECKED(pthread_mutex_destroy(&_mutex));\n #endif\n+    alive = false;\n }\n \n void lock_and_signal::lock() {\n@@ -65,11 +68,14 @@ void lock_and_signal::wait() {\n     timed_wait(0);\n }\n \n-void lock_and_signal::timed_wait(size_t timeout_in_ns) {\n+bool lock_and_signal::timed_wait(size_t timeout_in_ns) {\n+    _locked = false;\n+    bool rv = true;\n #if defined(__WIN32__)\n     LeaveCriticalSection(&_cs);\n     WaitForSingleObject(_event, INFINITE);\n     EnterCriticalSection(&_cs);\n+    _holding_thread = GetCurrentThreadId();\n #else\n     if (timeout_in_ns == 0) {\n         CHECKED(pthread_cond_wait(&_cond, &_mutex));\n@@ -79,9 +85,29 @@ void lock_and_signal::timed_wait(size_t timeout_in_ns) {\n         timespec time_spec;\n         time_spec.tv_sec = time_val.tv_sec + 0;\n         time_spec.tv_nsec = time_val.tv_usec * 1000 + timeout_in_ns;\n-        CHECKED(pthread_cond_timedwait(&_cond, &_mutex, &time_spec));\n+        if(time_spec.tv_nsec >= 1000000000) {\n+            time_spec.tv_sec++;\n+            time_spec.tv_nsec -= 1000000000;\n+        }\n+        int cond_wait_status\n+            = pthread_cond_timedwait(&_cond, &_mutex, &time_spec);\n+        switch(cond_wait_status) {\n+        case 0:\n+            // successfully grabbed the lock.\n+            break;\n+        case ETIMEDOUT:\n+            // Oops, we timed out.\n+            rv = false;\n+            break;\n+        default:\n+            // Error\n+            CHECKED(cond_wait_status);\n+        }\n     }\n+    _holding_thread = pthread_self();\n #endif\n+    _locked = true;\n+    return rv;\n }\n \n /**"}, {"sha": "6e656017115d27cb1e0b1760246a235a8d41ba99", "filename": "src/rt/sync/lock_and_signal.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5302cde188bba80dd38c58eaafa792d621b0818c/src%2Frt%2Fsync%2Flock_and_signal.h", "raw_url": "https://github.com/rust-lang/rust/raw/5302cde188bba80dd38c58eaafa792d621b0818c/src%2Frt%2Fsync%2Flock_and_signal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.h?ref=5302cde188bba80dd38c58eaafa792d621b0818c", "patch": "@@ -14,14 +14,17 @@ class lock_and_signal {\n     pthread_t _holding_thread;\n #endif\n     bool _locked;\n+\n+    bool alive;\n+\n public:\n     lock_and_signal();\n     virtual ~lock_and_signal();\n \n     void lock();\n     void unlock();\n     void wait();\n-    void timed_wait(size_t timeout_in_ns);\n+    bool timed_wait(size_t timeout_in_ns);\n     void signal();\n     void signal_all();\n "}, {"sha": "0a6b94c7f2ed22736f9673725ec28091f2eb1c27", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5302cde188bba80dd38c58eaafa792d621b0818c/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5302cde188bba80dd38c58eaafa792d621b0818c/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=5302cde188bba80dd38c58eaafa792d621b0818c", "patch": "@@ -184,7 +184,6 @@ mod map_reduce {\n             let m;\n             ctrl |> m;\n \n-\n             alt m {\n               mapper_done. {\n                 // log_err \"received mapper terminated.\";"}]}