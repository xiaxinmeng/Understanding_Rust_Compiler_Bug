{"sha": "7dc79cc49b5c134ed3a14005831b9958ae83a555", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkYzc5Y2M0OWI1YzEzNGVkM2ExNDAwNTgzMWI5OTU4YWU4M2E1NTU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-17T06:47:22Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-17T14:34:54Z"}, "message": "miri: pass pointer alignments directly instead of contextually.", "tree": {"sha": "a8081983b074313f4cc0b268293e9e34d634a45d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8081983b074313f4cc0b268293e9e34d634a45d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7dc79cc49b5c134ed3a14005831b9958ae83a555", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7dc79cc49b5c134ed3a14005831b9958ae83a555", "html_url": "https://github.com/rust-lang/rust/commit/7dc79cc49b5c134ed3a14005831b9958ae83a555", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7dc79cc49b5c134ed3a14005831b9958ae83a555/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08646c6c2c167d4c04897660dc524623d349bdb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/08646c6c2c167d4c04897660dc524623d349bdb1", "html_url": "https://github.com/rust-lang/rust/commit/08646c6c2c167d4c04897660dc524623d349bdb1"}], "stats": {"total": 332, "additions": 137, "deletions": 195}, "files": [{"sha": "054cb2340ada3eb37da870f9f742c88445b6b4bf", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7dc79cc49b5c134ed3a14005831b9958ae83a555/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc79cc49b5c134ed3a14005831b9958ae83a555/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=7dc79cc49b5c134ed3a14005831b9958ae83a555", "patch": "@@ -13,11 +13,10 @@ pub use self::error::{EvalError, EvalResult, EvalErrorKind};\n pub use self::value::{PrimVal, PrimValKind, Value, Pointer, bytes_to_f32, bytes_to_f64};\n \n use std::collections::BTreeMap;\n-use ty::layout::HasDataLayout;\n use std::fmt;\n-use ty::layout;\n use mir;\n use ty;\n+use ty::layout::{self, Align, HasDataLayout};\n use middle::region;\n use std::iter;\n \n@@ -166,7 +165,7 @@ pub struct Allocation {\n     /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n     pub undef_mask: UndefMask,\n     /// The alignment of the allocation to detect unaligned reads.\n-    pub align: u64,\n+    pub align: Align,\n }\n \n impl Allocation {\n@@ -177,7 +176,7 @@ impl Allocation {\n             bytes: slice.to_owned(),\n             relocations: BTreeMap::new(),\n             undef_mask,\n-            align: 1,\n+            align: Align::from_bytes(1, 1).unwrap(),\n         }\n     }\n }"}, {"sha": "c0cce6a461832884c5639afd7b5588b1c0cc5d7a", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7dc79cc49b5c134ed3a14005831b9958ae83a555/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc79cc49b5c134ed3a14005831b9958ae83a555/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=7dc79cc49b5c134ed3a14005831b9958ae83a555", "patch": "@@ -66,7 +66,7 @@ pub fn eval_body<'a, 'tcx>(\n         assert!(!layout.is_unsized());\n         let ptr = ecx.memory.allocate(\n             layout.size.bytes(),\n-            layout.align.abi(),\n+            layout.align,\n             None,\n         )?;\n         tcx.interpret_interner.borrow_mut().cache(cid, ptr.into());\n@@ -95,7 +95,7 @@ pub fn eval_body_as_integer<'a, 'tcx>(\n     let ptr_ty = eval_body(tcx, instance, param_env);\n     let (ptr, ty) = ptr_ty?;\n     let ecx = mk_eval_cx(tcx, instance, param_env)?;\n-    let prim = match ecx.try_read_value(ptr, ty)? {\n+    let prim = match ecx.try_read_value(ptr, ecx.layout_of(ty)?.align, ty)? {\n         Some(Value::ByVal(prim)) => prim.to_bytes()?,\n         _ => return err!(TypeNotPrimitive(ty)),\n     };"}, {"sha": "89d0e91a7ec86ceb93904347db468adb2f0ec9a0", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 44, "deletions": 57, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/7dc79cc49b5c134ed3a14005831b9958ae83a555/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc79cc49b5c134ed3a14005831b9958ae83a555/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7dc79cc49b5c134ed3a14005831b9958ae83a555", "patch": "@@ -211,8 +211,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         assert!(!layout.is_unsized(), \"cannot alloc memory for unsized type\");\n \n         let size = layout.size.bytes();\n-        let align = layout.align.abi();\n-        self.memory.allocate(size, align, Some(MemoryKind::Stack))\n+        self.memory.allocate(size, layout.align, Some(MemoryKind::Stack))\n     }\n \n     pub fn memory(&self) -> &Memory<'a, 'tcx, M> {\n@@ -612,12 +611,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let elem_size = self.layout_of(elem_ty)?.size.bytes();\n                 let value = self.eval_operand(operand)?.value;\n \n-                let dest = Pointer::from(self.force_allocation(dest)?.to_ptr()?);\n+                let (dest, dest_align) = self.force_allocation(dest)?.to_ptr_align();\n \n                 // FIXME: speed up repeat filling\n                 for i in 0..length {\n                     let elem_dest = dest.offset(i * elem_size, &self)?;\n-                    self.write_value_to_ptr(value, elem_dest, elem_ty)?;\n+                    self.write_value_to_ptr(value, elem_dest, dest_align, elem_ty)?;\n                 }\n             }\n \n@@ -955,15 +954,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                      layout.align)\n     }\n \n-    fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n-        let layout = self.layout_of(ty)?;\n-        assert!(!layout.is_unsized(), \"cannot copy from an unsized type\");\n-        let size = layout.size.bytes();\n-        let align = layout.align.abi();\n-        self.memory.copy(src, dest, size, align, false)?;\n-        Ok(())\n-    }\n-\n     pub fn force_allocation(&mut self, place: Place) -> EvalResult<'tcx, Place> {\n         let new_place = match place {\n             Place::Local { frame, local } => {\n@@ -984,8 +974,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         let ptr = self.alloc_ptr(ty)?;\n                         self.stack[frame].locals[local.index() - 1] =\n                             Some(Value::ByRef(ptr.into(), layout.align)); // it stays live\n-                        self.write_value_to_ptr(val, ptr.into(), ty)?;\n-                        Place::from_ptr(ptr, layout.align)\n+                        let place = Place::from_ptr(ptr, layout.align);\n+                        self.write_value(ValTy { value: val, ty }, place)?;\n+                        place\n                     }\n                 }\n             }\n@@ -1002,7 +993,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     ) -> EvalResult<'tcx, Value> {\n         match value {\n             Value::ByRef(ptr, align) => {\n-                self.read_with_align(align, |ectx| ectx.read_value(ptr, ty))\n+                self.read_value(ptr, align, ty)\n             }\n             other => Ok(other),\n         }\n@@ -1059,8 +1050,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         match dest {\n             Place::Ptr { ptr, align, extra } => {\n                 assert_eq!(extra, PlaceExtra::None);\n-                self.write_with_align_mut(align,\n-                    |ectx| ectx.write_value_to_ptr(src_val, ptr, dest_ty))\n+                self.write_value_to_ptr(src_val, ptr, align, dest_ty)\n             }\n \n             Place::Local { frame, local } => {\n@@ -1091,10 +1081,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             //\n             // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n             // knew for certain that there were no outstanding pointers to this allocation.\n-            self.write_with_align_mut(align, |ectx| {\n-                ectx.write_value_to_ptr(src_val, dest_ptr, dest_ty)\n-            })?;\n-\n+            self.write_value_to_ptr(src_val, dest_ptr, align, dest_ty)?;\n         } else if let Value::ByRef(src_ptr, align) = src_val {\n             // If the value is not `ByRef`, then we know there are no pointers to it\n             // and we can simply overwrite the `Value` in the locals array directly.\n@@ -1107,18 +1094,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // It is a valid optimization to attempt reading a primitive value out of the\n             // source and write that into the destination without making an allocation, so\n             // we do so here.\n-            self.read_with_align_mut(align, |ectx| {\n-                if let Ok(Some(src_val)) = ectx.try_read_value(src_ptr, dest_ty) {\n-                    write_dest(ectx, src_val)?;\n-                } else {\n-                    let dest_ptr = ectx.alloc_ptr(dest_ty)?.into();\n-                    ectx.copy(src_ptr, dest_ptr, dest_ty)?;\n-                    let layout = ectx.layout_of(dest_ty)?;\n-                    write_dest(ectx, Value::ByRef(dest_ptr, layout.align))?;\n-                }\n-                Ok(())\n-            })?;\n-\n+            if let Ok(Some(src_val)) = self.try_read_value(src_ptr, align, dest_ty) {\n+                write_dest(self, src_val)?;\n+            } else {\n+                let dest_ptr = self.alloc_ptr(dest_ty)?.into();\n+                let layout = self.layout_of(dest_ty)?;\n+                self.memory.copy(src_ptr, align.min(layout.align), dest_ptr, layout.align, layout.size.bytes(), false)?;\n+                write_dest(self, Value::ByRef(dest_ptr, layout.align))?;\n+            }\n         } else {\n             // Finally, we have the simple case where neither source nor destination are\n             // `ByRef`. We may simply copy the source value over the the destintion.\n@@ -1131,26 +1114,26 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         &mut self,\n         value: Value,\n         dest: Pointer,\n+        dest_align: Align,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"write_value_to_ptr: {:#?}\", value);\n+        let layout = self.layout_of(dest_ty)?;\n         match value {\n             Value::ByRef(ptr, align) => {\n-                self.read_with_align_mut(align, |ectx| ectx.copy(ptr, dest, dest_ty))\n+                self.memory.copy(ptr, align.min(layout.align), dest, dest_align.min(layout.align), layout.size.bytes(), false)\n             }\n             Value::ByVal(primval) => {\n-                let layout = self.layout_of(dest_ty)?;\n                 match layout.abi {\n                     layout::Abi::Scalar(_) => {}\n                     _ if primval.is_undef() => {}\n                     _ => bug!(\"write_value_to_ptr: invalid ByVal layout: {:#?}\", layout)\n                 }\n                 // TODO: Do we need signedness?\n-                self.memory.write_primval(dest.to_ptr()?, primval, layout.size.bytes(), false)\n+                self.memory.write_primval(dest.to_ptr()?, dest_align, primval, layout.size.bytes(), false)\n             }\n             Value::ByValPair(a_val, b_val) => {\n                 let ptr = dest.to_ptr()?;\n-                let mut layout = self.layout_of(dest_ty)?;\n                 trace!(\"write_value_to_ptr valpair: {:#?}\", layout);\n                 let (a, b) = match layout.abi {\n                     layout::Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n@@ -1161,9 +1144,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let b_offset = a_size.abi_align(b.align(&self));\n                 let b_ptr = ptr.offset(b_offset.bytes(), &self)?.into();\n                 // TODO: What about signedess?\n-                self.memory.write_primval(a_ptr, a_val, a_size.bytes(), false)?;\n-                self.memory.write_primval(b_ptr, b_val, b_size.bytes(), false)?;\n-                Ok(())\n+                self.memory.write_primval(a_ptr, dest_align, a_val, a_size.bytes(), false)?;\n+                self.memory.write_primval(b_ptr, dest_align, b_val, b_size.bytes(), false)\n             }\n         }\n     }\n@@ -1246,8 +1228,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn read_value(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n-        if let Some(val) = self.try_read_value(ptr, ty)? {\n+    pub fn read_value(&self, ptr: Pointer, align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+        if let Some(val) = self.try_read_value(ptr, align, ty)? {\n             Ok(val)\n         } else {\n             bug!(\"primitive read failed for type: {:?}\", ty);\n@@ -1257,34 +1239,35 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(crate) fn read_ptr(\n         &self,\n         ptr: MemoryPointer,\n+        ptr_align: Align,\n         pointee_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n         let ptr_size = self.memory.pointer_size();\n-        let p : Pointer = self.memory.read_ptr_sized_unsigned(ptr)?.into();\n+        let p: Pointer = self.memory.read_ptr_sized_unsigned(ptr, ptr_align)?.into();\n         if self.type_is_sized(pointee_ty) {\n             Ok(p.to_value())\n         } else {\n             trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n             let extra = ptr.offset(ptr_size, self)?;\n             match self.tcx.struct_tail(pointee_ty).sty {\n                 ty::TyDynamic(..) => Ok(p.to_value_with_vtable(\n-                    self.memory.read_ptr_sized_unsigned(extra)?.to_ptr()?,\n+                    self.memory.read_ptr_sized_unsigned(extra, ptr_align)?.to_ptr()?,\n                 )),\n                 ty::TySlice(..) | ty::TyStr => Ok(\n-                    p.to_value_with_len(self.memory.read_ptr_sized_unsigned(extra)?.to_bytes()? as u64),\n+                    p.to_value_with_len(self.memory.read_ptr_sized_unsigned(extra, ptr_align)?.to_bytes()? as u64),\n                 ),\n                 _ => bug!(\"unsized primval ptr read from {:?}\", pointee_ty),\n             }\n         }\n     }\n \n-    pub fn try_read_value(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n+    pub fn try_read_value(&self, ptr: Pointer, ptr_align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n         use syntax::ast::FloatTy;\n \n         let ptr = ptr.to_ptr()?;\n         let val = match ty.sty {\n             ty::TyBool => {\n-                let val = self.memory.read_primval(ptr, 1, false)?;\n+                let val = self.memory.read_primval(ptr, ptr_align, 1, false)?;\n                 let val = match val {\n                     PrimVal::Bytes(0) => false,\n                     PrimVal::Bytes(1) => true,\n@@ -1294,7 +1277,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 PrimVal::from_bool(val)\n             }\n             ty::TyChar => {\n-                let c = self.memory.read_primval(ptr, 4, false)?.to_bytes()? as u32;\n+                let c = self.memory.read_primval(ptr, ptr_align, 4, false)?.to_bytes()? as u32;\n                 match ::std::char::from_u32(c) {\n                     Some(ch) => PrimVal::from_char(ch),\n                     None => return err!(InvalidChar(c as u128)),\n@@ -1311,7 +1294,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     I128 => 16,\n                     Is => self.memory.pointer_size(),\n                 };\n-                self.memory.read_primval(ptr, size, true)?\n+                self.memory.read_primval(ptr, ptr_align, size, true)?\n             }\n \n             ty::TyUint(uint_ty) => {\n@@ -1324,19 +1307,23 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     U128 => 16,\n                     Us => self.memory.pointer_size(),\n                 };\n-                self.memory.read_primval(ptr, size, false)?\n+                self.memory.read_primval(ptr, ptr_align, size, false)?\n             }\n \n-            ty::TyFloat(FloatTy::F32) => PrimVal::Bytes(self.memory.read_primval(ptr, 4, false)?.to_bytes()?),\n-            ty::TyFloat(FloatTy::F64) => PrimVal::Bytes(self.memory.read_primval(ptr, 8, false)?.to_bytes()?),\n+            ty::TyFloat(FloatTy::F32) => {\n+                PrimVal::Bytes(self.memory.read_primval(ptr, ptr_align, 4, false)?.to_bytes()?)\n+            }\n+            ty::TyFloat(FloatTy::F64) => {\n+                PrimVal::Bytes(self.memory.read_primval(ptr, ptr_align, 8, false)?.to_bytes()?)\n+            }\n \n-            ty::TyFnPtr(_) => self.memory.read_ptr_sized_unsigned(ptr)?,\n+            ty::TyFnPtr(_) => self.memory.read_ptr_sized_unsigned(ptr, ptr_align)?,\n             ty::TyRef(_, ref tam) |\n-            ty::TyRawPtr(ref tam) => return self.read_ptr(ptr, tam.ty).map(Some),\n+            ty::TyRawPtr(ref tam) => return self.read_ptr(ptr, ptr_align, tam.ty).map(Some),\n \n             ty::TyAdt(def, _) => {\n                 if def.is_box() {\n-                    return self.read_ptr(ptr, ty.boxed_ty()).map(Some);\n+                    return self.read_ptr(ptr, ptr_align, ty.boxed_ty()).map(Some);\n                 }\n \n                 if let layout::Abi::Scalar(ref scalar) = self.layout_of(ty)?.abi {\n@@ -1345,7 +1332,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         signed = s;\n                     }\n                     let size = scalar.value.size(self).bytes();\n-                    self.memory.read_primval(ptr, size, signed)?\n+                    self.memory.read_primval(ptr, ptr_align, size, signed)?\n                 } else {\n                     return Ok(None);\n                 }"}, {"sha": "671fe29c0e1bc0cfcc11b62c852bf04943ce8a77", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 71, "deletions": 121, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/7dc79cc49b5c134ed3a14005831b9958ae83a555/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc79cc49b5c134ed3a14005831b9958ae83a555/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=7dc79cc49b5c134ed3a14005831b9958ae83a555", "patch": "@@ -1,7 +1,6 @@\n use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n use std::{ptr, mem, io};\n-use std::cell::Cell;\n \n use rustc::ty::{Instance, TyCtxt};\n use rustc::ty::layout::{self, Align, TargetDataLayout};\n@@ -51,11 +50,6 @@ pub struct Memory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     /// Maximum number of virtual bytes that may be allocated.\n     memory_size: u64,\n \n-    /// To avoid having to pass flags to every single memory access, we have some global state saying how\n-    /// alignment checking is currently enforced for read and/or write accesses.\n-    read_align_override: Cell<Option<Align>>,\n-    write_align_override: Cell<Option<Align>>,\n-\n     /// The current stack frame.  Used to check accesses against locks.\n     pub cur_frame: usize,\n \n@@ -72,8 +66,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             tcx,\n             memory_size: max_memory,\n             memory_usage: 0,\n-            read_align_override: Cell::new(None),\n-            write_align_override: Cell::new(None),\n             cur_frame: usize::max_value(),\n         }\n     }\n@@ -98,12 +90,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     pub fn allocate(\n         &mut self,\n         size: u64,\n-        align: u64,\n+        align: Align,\n         kind: Option<MemoryKind<M::MemoryKinds>>,\n     ) -> EvalResult<'tcx, MemoryPointer> {\n-        assert_ne!(align, 0);\n-        assert!(align.is_power_of_two());\n-\n         if self.memory_size - self.memory_usage < size {\n             return err!(OutOfMemory {\n                 allocation_size: size,\n@@ -139,13 +128,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         &mut self,\n         ptr: MemoryPointer,\n         old_size: u64,\n-        old_align: u64,\n+        old_align: Align,\n         new_size: u64,\n-        new_align: u64,\n+        new_align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, MemoryPointer> {\n-        use std::cmp::min;\n-\n         if ptr.offset != 0 {\n             return err!(ReallocateNonBasePtr);\n         }\n@@ -163,9 +150,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         let new_ptr = self.allocate(new_size, new_align, Some(kind))?;\n         self.copy(\n             ptr.into(),\n+            old_align,\n             new_ptr.into(),\n-            min(old_size, new_size),\n-            min(old_align, new_align),\n+            new_align,\n+            old_size.min(new_size),\n             /*nonoverlapping*/\n             true,\n         )?;\n@@ -190,7 +178,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     pub fn deallocate(\n         &mut self,\n         ptr: MemoryPointer,\n-        size_and_align: Option<(u64, u64)>,\n+        size_and_align: Option<(u64, Align)>,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx> {\n         if ptr.offset != 0 {\n@@ -236,7 +224,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n         if let Some((size, align)) = size_and_align {\n             if size != alloc.bytes.len() as u64 || align != alloc.align {\n-                return err!(IncorrectAllocationInformation(size, alloc.bytes.len(), align, alloc.align));\n+                return err!(IncorrectAllocationInformation(size, alloc.bytes.len(), align.abi(), alloc.align.abi()));\n             }\n         }\n \n@@ -255,7 +243,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     /// Check that the pointer is aligned AND non-NULL.\n-    pub fn check_align(&self, ptr: Pointer, align: u64, access: Option<AccessKind>) -> EvalResult<'tcx> {\n+    pub fn check_align(&self, ptr: Pointer, required_align: Align) -> EvalResult<'tcx> {\n         // Check non-NULL/Undef, extract offset\n         let (offset, alloc_align) = match ptr.into_inner_primval() {\n             PrimVal::Ptr(ptr) => {\n@@ -267,30 +255,24 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 if v == 0 {\n                     return err!(InvalidNullPointerUsage);\n                 }\n-                (v, align) // the base address if the \"integer allocation\" is 0 and hence always aligned\n+                // the base address if the \"integer allocation\" is 0 and hence always aligned\n+                (v, required_align)\n             }\n             PrimVal::Undef => return err!(ReadUndefBytes),\n         };\n-        // See if alignment checking is disabled\n-        let align_override = match access {\n-            Some(AccessKind::Read) => self.read_align_override.get(),\n-            Some(AccessKind::Write) => self.write_align_override.get(),\n-            None => None,\n-        };\n-        let align = align_override.map_or(align, |o| o.abi().min(align));\n         // Check alignment\n-        if alloc_align < align {\n+        if alloc_align.abi() < required_align.abi() {\n             return err!(AlignmentCheckFailed {\n-                has: alloc_align,\n-                required: align,\n+                has: alloc_align.abi(),\n+                required: required_align.abi(),\n             });\n         }\n-        if offset % align == 0 {\n+        if offset % required_align.abi() == 0 {\n             Ok(())\n         } else {\n             err!(AlignmentCheckFailed {\n-                has: offset % align,\n-                required: align,\n+                has: offset % required_align.abi(),\n+                required: required_align.abi(),\n             })\n         }\n     }\n@@ -435,7 +417,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 \"{}({} bytes, alignment {}){}\",\n                 msg,\n                 alloc.bytes.len(),\n-                alloc.align,\n+                alloc.align.abi(),\n                 immutable\n             );\n \n@@ -480,10 +462,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         &self,\n         ptr: MemoryPointer,\n         size: u64,\n-        align: u64,\n+        align: Align,\n     ) -> EvalResult<'tcx, &[u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n-        self.check_align(ptr.into(), align, Some(AccessKind::Read))?;\n+        self.check_align(ptr.into(), align)?;\n         if size == 0 {\n             return Ok(&[]);\n         }\n@@ -500,10 +482,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         &mut self,\n         ptr: MemoryPointer,\n         size: u64,\n-        align: u64,\n+        align: Align,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n-        self.check_align(ptr.into(), align, Some(AccessKind::Write))?;\n+        self.check_align(ptr.into(), align)?;\n         if size == 0 {\n             return Ok(&mut []);\n         }\n@@ -516,7 +498,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(&mut alloc.bytes[offset..offset + size as usize])\n     }\n \n-    fn get_bytes(&self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n+    fn get_bytes(&self, ptr: MemoryPointer, size: u64, align: Align) -> EvalResult<'tcx, &[u8]> {\n         assert_ne!(size, 0);\n         if self.relocations(ptr, size)?.count() != 0 {\n             return err!(ReadPointerAsBytes);\n@@ -529,7 +511,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         &mut self,\n         ptr: MemoryPointer,\n         size: u64,\n-        align: u64,\n+        align: Align,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n         assert_ne!(size, 0);\n         self.clear_relocations(ptr, size)?;\n@@ -627,14 +609,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     pub fn copy(\n         &mut self,\n         src: Pointer,\n+        src_align: Align,\n         dest: Pointer,\n+        dest_align: Align,\n         size: u64,\n-        align: u64,\n         nonoverlapping: bool,\n     ) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be aligned\n-        self.check_align(src, align, Some(AccessKind::Read))?;\n-        self.check_align(dest, align, Some(AccessKind::Write))?;\n+        self.check_align(src, src_align)?;\n+        self.check_align(dest, dest_align)?;\n         if size == 0 {\n             return Ok(());\n         }\n@@ -653,8 +636,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             })\n             .collect();\n \n-        let src_bytes = self.get_bytes_unchecked(src, size, align)?.as_ptr();\n-        let dest_bytes = self.get_bytes_mut(dest, size, align)?.as_mut_ptr();\n+        let src_bytes = self.get_bytes_unchecked(src, size, src_align)?.as_ptr();\n+        let dest_bytes = self.get_bytes_mut(dest, size, dest_align)?.as_mut_ptr();\n \n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes\n         // behind `src` and `dest`. Also, we use the overlapping-safe `ptr::copy` if `src` and\n@@ -703,41 +686,44 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n     pub fn read_bytes(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, &[u8]> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        self.check_align(ptr, 1, Some(AccessKind::Read))?;\n+        let align = Align::from_bytes(1, 1).unwrap();\n+        self.check_align(ptr, align)?;\n         if size == 0 {\n             return Ok(&[]);\n         }\n-        self.get_bytes(ptr.to_ptr()?, size, 1)\n+        self.get_bytes(ptr.to_ptr()?, size, align)\n     }\n \n     pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        self.check_align(ptr, 1, Some(AccessKind::Write))?;\n+        let align = Align::from_bytes(1, 1).unwrap();\n+        self.check_align(ptr, align)?;\n         if src.is_empty() {\n             return Ok(());\n         }\n-        let bytes = self.get_bytes_mut(ptr.to_ptr()?, src.len() as u64, 1)?;\n+        let bytes = self.get_bytes_mut(ptr.to_ptr()?, src.len() as u64, align)?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n     pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: u64) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-        self.check_align(ptr, 1, Some(AccessKind::Write))?;\n+        let align = Align::from_bytes(1, 1).unwrap();\n+        self.check_align(ptr, align)?;\n         if count == 0 {\n             return Ok(());\n         }\n-        let bytes = self.get_bytes_mut(ptr.to_ptr()?, count, 1)?;\n+        let bytes = self.get_bytes_mut(ptr.to_ptr()?, count, align)?;\n         for b in bytes {\n             *b = val;\n         }\n         Ok(())\n     }\n \n-    pub fn read_primval(&self, ptr: MemoryPointer, size: u64, signed: bool) -> EvalResult<'tcx, PrimVal> {\n+    pub fn read_primval(&self, ptr: MemoryPointer, ptr_align: Align, size: u64, signed: bool) -> EvalResult<'tcx, PrimVal> {\n         self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n         let endianess = self.endianess();\n-        let bytes = self.get_bytes_unchecked(ptr, size, self.int_align(size))?;\n+        let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n@@ -765,11 +751,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(PrimVal::Bytes(bytes))\n     }\n \n-    pub fn read_ptr_sized_unsigned(&self, ptr: MemoryPointer) -> EvalResult<'tcx, PrimVal> {\n-        self.read_primval(ptr, self.pointer_size(), false)\n+    pub fn read_ptr_sized_unsigned(&self, ptr: MemoryPointer, ptr_align: Align) -> EvalResult<'tcx, PrimVal> {\n+        self.read_primval(ptr, ptr_align, self.pointer_size(), false)\n     }\n \n-    pub fn write_primval(&mut self, ptr: MemoryPointer, val: PrimVal, size: u64, signed: bool) -> EvalResult<'tcx> {\n+    pub fn write_primval(&mut self, ptr: MemoryPointer, ptr_align: Align, val: PrimVal, size: u64, signed: bool) -> EvalResult<'tcx> {\n         let endianess = self.endianess();\n \n         let bytes = match val {\n@@ -800,7 +786,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n         {\n             let align = self.int_align(size);\n-            let dst = self.get_bytes_mut(ptr, size, align)?;\n+            let dst = self.get_bytes_mut(ptr, size, ptr_align.min(align))?;\n             if signed {\n                 write_target_int(endianess, dst, bytes as i128).unwrap();\n             } else {\n@@ -822,22 +808,23 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn write_ptr_sized_unsigned(&mut self, ptr: MemoryPointer, val: PrimVal) -> EvalResult<'tcx> {\n+    pub fn write_ptr_sized_unsigned(&mut self, ptr: MemoryPointer, ptr_align: Align, val: PrimVal) -> EvalResult<'tcx> {\n         let ptr_size = self.pointer_size();\n-        self.write_primval(ptr, val, ptr_size, false)\n+        self.write_primval(ptr, ptr_align, val, ptr_size, false)\n     }\n \n-    fn int_align(&self, size: u64) -> u64 {\n+    fn int_align(&self, size: u64) -> Align {\n         // We assume pointer-sized integers have the same alignment as pointers.\n         // We also assume signed and unsigned integers of the same size have the same alignment.\n-        match size {\n-            1 => self.tcx.data_layout.i8_align.abi(),\n-            2 => self.tcx.data_layout.i16_align.abi(),\n-            4 => self.tcx.data_layout.i32_align.abi(),\n-            8 => self.tcx.data_layout.i64_align.abi(),\n-            16 => self.tcx.data_layout.i128_align.abi(),\n+        let ity = match size {\n+            1 => layout::I8,\n+            2 => layout::I16,\n+            4 => layout::I32,\n+            8 => layout::I64,\n+            16 => layout::I128,\n             _ => bug!(\"bad integer size: {}\", size),\n-        }\n+        };\n+        ity.align(self)\n     }\n }\n \n@@ -1002,43 +989,6 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M>;\n     fn memory(&self) -> &Memory<'a, 'tcx, M>;\n \n-    // These are not supposed to be overriden.\n-    fn read_with_align<F, T>(&self, align: Align, f: F) -> EvalResult<'tcx, T>\n-    where\n-        F: FnOnce(&Self) -> EvalResult<'tcx, T>,\n-    {\n-        let old = self.memory().read_align_override.get();\n-        // Do alignment checking for the minimum align out of *all* nested calls.\n-        self.memory().read_align_override.set(Some(old.map_or(align, |old| old.min(align))));\n-        let t = f(self);\n-        self.memory().read_align_override.set(old);\n-        t\n-    }\n-\n-    fn read_with_align_mut<F, T>(&mut self, align: Align, f: F) -> EvalResult<'tcx, T>\n-    where\n-        F: FnOnce(&mut Self) -> EvalResult<'tcx, T>,\n-    {\n-        let old = self.memory().read_align_override.get();\n-        // Do alignment checking for the minimum align out of *all* nested calls.\n-        self.memory().read_align_override.set(Some(old.map_or(align, |old| old.min(align))));\n-        let t = f(self);\n-        self.memory().read_align_override.set(old);\n-        t\n-    }\n-\n-    fn write_with_align_mut<F, T>(&mut self, align: Align, f: F) -> EvalResult<'tcx, T>\n-    where\n-        F: FnOnce(&mut Self) -> EvalResult<'tcx, T>,\n-    {\n-        let old = self.memory().write_align_override.get();\n-        // Do alignment checking for the minimum align out of *all* nested calls.\n-        self.memory().write_align_override.set(Some(old.map_or(align, |old| old.min(align))));\n-        let t = f(self);\n-        self.memory().write_align_override.set(old);\n-        t\n-    }\n-\n     /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n     /// this may have to perform a load.\n     fn into_ptr(\n@@ -1047,7 +997,7 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     ) -> EvalResult<'tcx, Pointer> {\n         Ok(match value {\n             Value::ByRef(ptr, align) => {\n-                self.memory().read_with_align(align, |mem| mem.read_ptr_sized_unsigned(ptr.to_ptr()?))?\n+                self.memory().read_ptr_sized_unsigned(ptr.to_ptr()?, align)?\n             }\n             Value::ByVal(ptr) |\n             Value::ByValPair(ptr, _) => ptr,\n@@ -1060,13 +1010,13 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n         match value {\n             Value::ByRef(ref_ptr, align) => {\n-                self.memory().read_with_align(align, |mem| {\n-                    let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?)?.into();\n-                    let vtable = mem.read_ptr_sized_unsigned(\n-                        ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n-                    )?.to_ptr()?;\n-                    Ok((ptr, vtable))\n-                })\n+                let mem = self.memory();\n+                let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?, align)?.into();\n+                let vtable = mem.read_ptr_sized_unsigned(\n+                    ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n+                    align\n+                )?.to_ptr()?;\n+                Ok((ptr, vtable))\n             }\n \n             Value::ByValPair(ptr, vtable) => Ok((ptr.into(), vtable.to_ptr()?)),\n@@ -1082,13 +1032,13 @@ pub trait HasMemory<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     ) -> EvalResult<'tcx, (Pointer, u64)> {\n         match value {\n             Value::ByRef(ref_ptr, align) => {\n-                self.memory().read_with_align(align, |mem| {\n-                    let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?)?.into();\n-                    let len = mem.read_ptr_sized_unsigned(\n-                        ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n-                    )?.to_bytes()? as u64;\n-                    Ok((ptr, len))\n-                })\n+                let mem = self.memory();\n+                let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?, align)?.into();\n+                let len = mem.read_ptr_sized_unsigned(\n+                    ref_ptr.offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n+                    align\n+                )?.to_bytes()? as u64;\n+                Ok((ptr, len))\n             }\n             Value::ByValPair(ptr, val) => {\n                 let len = val.to_u128()?;"}, {"sha": "0b5801c3539953c064d627983321ba91094761e3", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7dc79cc49b5c134ed3a14005831b9958ae83a555/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc79cc49b5c134ed3a14005831b9958ae83a555/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=7dc79cc49b5c134ed3a14005831b9958ae83a555", "patch": "@@ -179,7 +179,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         assert!(!layout.is_unsized());\n         let ptr = self.memory.allocate(\n             layout.size.bytes(),\n-            layout.align.abi(),\n+            layout.align,\n             None,\n         )?;\n         self.tcx.interpret_interner.borrow_mut().cache(cid, ptr.into());\n@@ -264,7 +264,7 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n                     assert!(!layout.is_unsized());\n                     let ptr = this.ecx.memory.allocate(\n                         layout.size.bytes(),\n-                        layout.align.abi(),\n+                        layout.align,\n                         None,\n                     )?;\n                     this.ecx.tcx.interpret_interner.borrow_mut().cache(cid, ptr.into());"}, {"sha": "1f6e4a7cde7836ec85ef7b8443926a0fc5d605ab", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7dc79cc49b5c134ed3a14005831b9958ae83a555/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc79cc49b5c134ed3a14005831b9958ae83a555/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=7dc79cc49b5c134ed3a14005831b9958ae83a555", "patch": "@@ -400,9 +400,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n+                let ptr_align = self.tcx.data_layout.pointer_align;\n                 let (ptr, vtable) = self.into_ptr_vtable_pair(args[0].value)?;\n                 let fn_ptr = self.memory.read_ptr_sized_unsigned(\n-                    vtable.offset(ptr_size * (idx as u64 + 3), &self)?\n+                    vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n+                    ptr_align\n                 )?.to_ptr()?;\n                 let instance = self.memory.get_fn(fn_ptr)?;\n                 let mut args = args.to_vec();"}, {"sha": "22417201f0dc5d0f36ba5796b0e26597f53ad0ce", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7dc79cc49b5c134ed3a14005831b9958ae83a555/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc79cc49b5c134ed3a14005831b9958ae83a555/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=7dc79cc49b5c134ed3a14005831b9958ae83a555", "patch": "@@ -26,28 +26,29 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let align = layout.align.abi();\n \n         let ptr_size = self.memory.pointer_size();\n+        let ptr_align = self.tcx.data_layout.pointer_align;\n         let methods = self.tcx.vtable_methods(trait_ref);\n         let vtable = self.memory.allocate(\n             ptr_size * (3 + methods.len() as u64),\n-            ptr_size,\n+            ptr_align,\n             None,\n         )?;\n \n         let drop = eval_context::resolve_drop_in_place(self.tcx, ty);\n         let drop = self.memory.create_fn_alloc(drop);\n-        self.memory.write_ptr_sized_unsigned(vtable, PrimVal::Ptr(drop))?;\n+        self.memory.write_ptr_sized_unsigned(vtable, ptr_align, PrimVal::Ptr(drop))?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n-        self.memory.write_ptr_sized_unsigned(size_ptr, PrimVal::Bytes(size as u128))?;\n+        self.memory.write_ptr_sized_unsigned(size_ptr, ptr_align, PrimVal::Bytes(size as u128))?;\n         let align_ptr = vtable.offset(ptr_size * 2, &self)?;\n-        self.memory.write_ptr_sized_unsigned(align_ptr, PrimVal::Bytes(align as u128))?;\n+        self.memory.write_ptr_sized_unsigned(align_ptr, ptr_align, PrimVal::Bytes(align as u128))?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 let instance = self.resolve(def_id, substs)?;\n                 let fn_ptr = self.memory.create_fn_alloc(instance);\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &self)?;\n-                self.memory.write_ptr_sized_unsigned(method_ptr, PrimVal::Ptr(fn_ptr))?;\n+                self.memory.write_ptr_sized_unsigned(method_ptr, ptr_align, PrimVal::Ptr(fn_ptr))?;\n             }\n         }\n \n@@ -64,7 +65,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         vtable: MemoryPointer,\n     ) -> EvalResult<'tcx, Option<ty::Instance<'tcx>>> {\n         // we don't care about the pointee type, we just want a pointer\n-        match self.read_ptr(vtable, self.tcx.mk_nil_ptr())? {\n+        let pointer_align = self.tcx.data_layout.pointer_align;\n+        match self.read_ptr(vtable, pointer_align, self.tcx.mk_nil_ptr())? {\n             // some values don't need to call a drop impl, so the value is null\n             Value::ByVal(PrimVal::Bytes(0)) => Ok(None),\n             Value::ByVal(PrimVal::Ptr(drop_fn)) => self.memory.get_fn(drop_fn).map(Some),\n@@ -77,9 +79,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         vtable: MemoryPointer,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.memory.pointer_size();\n-        let size = self.memory.read_ptr_sized_unsigned(vtable.offset(pointer_size, self)?)?.to_bytes()? as u64;\n+        let pointer_align = self.tcx.data_layout.pointer_align;\n+        let size = self.memory.read_ptr_sized_unsigned(vtable.offset(pointer_size, self)?, pointer_align)?.to_bytes()? as u64;\n         let align = self.memory.read_ptr_sized_unsigned(\n-            vtable.offset(pointer_size * 2, self)?\n+            vtable.offset(pointer_size * 2, self)?,\n+            pointer_align\n         )?.to_bytes()? as u64;\n         Ok((Size::from_bytes(size), Align::from_bytes(align, align).unwrap()))\n     }"}]}