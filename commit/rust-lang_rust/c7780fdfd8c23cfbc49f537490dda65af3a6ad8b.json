{"sha": "c7780fdfd8c23cfbc49f537490dda65af3a6ad8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NzgwZmRmZDhjMjNjZmJjNDlmNTM3NDkwZGRhNjVhZjNhNmFkOGI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-13T20:36:59Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-13T21:05:42Z"}, "message": "Be careful about where we change braces in closures\n\nAnd some general refactoring of closure code.\n\nFixes #863", "tree": {"sha": "bf1d8a4d007b809d3497fc37a6ac06a24fc88b22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf1d8a4d007b809d3497fc37a6ac06a24fc88b22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7780fdfd8c23cfbc49f537490dda65af3a6ad8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7780fdfd8c23cfbc49f537490dda65af3a6ad8b", "html_url": "https://github.com/rust-lang/rust/commit/c7780fdfd8c23cfbc49f537490dda65af3a6ad8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7780fdfd8c23cfbc49f537490dda65af3a6ad8b/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09440b55ef678c630a5f1c8d414de3afca05f78f", "url": "https://api.github.com/repos/rust-lang/rust/commits/09440b55ef678c630a5f1c8d414de3afca05f78f", "html_url": "https://github.com/rust-lang/rust/commit/09440b55ef678c630a5f1c8d414de3afca05f78f"}], "stats": {"total": 197, "additions": 134, "deletions": 63}, "files": [{"sha": "6cc8c3aa4a906406250d8a3a203504882d239209", "filename": "src/expr.rs", "status": "modified", "additions": 83, "deletions": 35, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/c7780fdfd8c23cfbc49f537490dda65af3a6ad8b/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7780fdfd8c23cfbc49f537490dda65af3a6ad8b/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=c7780fdfd8c23cfbc49f537490dda65af3a6ad8b", "patch": "@@ -21,7 +21,7 @@ use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTacti\n             DefinitiveListTactic, definitive_tactic, ListItem, format_item_list};\n use string::{StringFormat, rewrite_string};\n use utils::{CodeMapSpanUtils, extra_offset, last_line_width, wrap_str, binary_search,\n-            first_line_width, semicolon_for_stmt, trimmed_last_line_width};\n+            first_line_width, semicolon_for_stmt, trimmed_last_line_width, left_most_sub_expr};\n use visitor::FmtVisitor;\n use config::{Config, StructLitStyle, MultilineStyle};\n use comment::{FindUncommented, rewrite_comment, contains_comment, recover_comment_removed};\n@@ -32,6 +32,7 @@ use macros::rewrite_macro;\n \n use syntax::{ast, ptr};\n use syntax::codemap::{CodeMap, Span, BytePos, mk_sp};\n+use syntax::parse::classify;\n use syntax::visit::Visitor;\n \n impl Rewrite for ast::Expr {\n@@ -308,8 +309,13 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n     Some(format!(\"[{}]\", list_str))\n }\n \n-// This functions is pretty messy because of the wrapping and unwrapping of\n-// expressions into and from blocks. See rust issue #27872.\n+// This functions is pretty messy because of the rules around closures and blocks:\n+//   * the body of a closure is represented by an ast::Block, but that does not\n+//     imply there are `{}` (unless the block is empty) (see rust issue #27872),\n+//   * if there is a return type, then there must be braces,\n+//   * if the first expression in the body ends with a block (i.e., is a\n+//     statement without needing a semi-colon), then adding or removing braces\n+//     can change whether it is treated as an expression or statement.\n fn rewrite_closure(capture: ast::CaptureBy,\n                    fn_decl: &ast::FnDecl,\n                    body: &ast::Block,\n@@ -331,6 +337,8 @@ fn rewrite_closure(capture: ast::CaptureBy,\n     // 1 = |\n     let argument_offset = offset + 1;\n     let ret_str = try_opt!(fn_decl.output.rewrite(context, budget, argument_offset));\n+    let force_block = !ret_str.is_empty();\n+\n     // 1 = space between arguments and return type.\n     let horizontal_budget = budget.checked_sub(ret_str.len() + 1).unwrap_or(0);\n \n@@ -371,51 +379,91 @@ fn rewrite_closure(capture: ast::CaptureBy,\n         prefix.push_str(&ret_str);\n     }\n \n-    // Try to format closure body as a single line expression without braces.\n-    if is_simple_block(body, context.codemap) && !prefix.contains('\\n') {\n-        let (spacer, closer) = if ret_str.is_empty() {\n-            (\" \", \"\")\n-        } else {\n-            (\" { \", \" }\")\n-        };\n-        let expr = body.expr.as_ref().unwrap();\n-        // All closure bodies are blocks in the eyes of the AST, but we may not\n-        // want to unwrap them when they only contain a single expression.\n-        let inner_expr = match expr.node {\n-            ast::ExprKind::Block(ref inner) if inner.stmts.is_empty() && inner.expr.is_some() &&\n-                                               inner.rules == ast::BlockCheckMode::Default => {\n-                inner.expr.as_ref().unwrap()\n+    assert!(body.stmts.is_empty(),\n+            \"unexpected statements in closure: `{}`\",\n+            context.snippet(span));\n+\n+    if body.expr.is_none() {\n+        return Some(format!(\"{} {{}}\", prefix));\n+    }\n+\n+    // 1 = space between `|...|` and body.\n+    let extra_offset = extra_offset(&prefix, offset) + 1;\n+    let budget = try_opt!(width.checked_sub(extra_offset));\n+\n+    // This is where we figure out whether to use braces or not.\n+    let mut had_braces = false;\n+    let mut inner_block = body;\n+    if let ast::ExprKind::Block(ref inner) = inner_block.expr.as_ref().unwrap().node {\n+        had_braces = true;\n+        inner_block = inner;\n+    };\n+    assert!(!force_block || !had_braces,\n+            \"Closure requires braces, but they weren't present. How did this parse? `{}`\",\n+            context.snippet(span));\n+\n+    let try_single_line = is_simple_block(inner_block, context.codemap) &&\n+                          inner_block.rules == ast::BlockCheckMode::Default;\n+\n+    if try_single_line && !force_block {\n+        let must_preserve_braces =\n+            !classify::expr_requires_semi_to_be_stmt(left_most_sub_expr(inner_block.expr\n+                                                                                   .as_ref()\n+                                                                                   .unwrap()));\n+        if !(must_preserve_braces && had_braces) &&\n+           (must_preserve_braces || !prefix.contains('\\n')) {\n+            // If we got here, then we can try to format without braces.\n+\n+            let inner_expr = inner_block.expr.as_ref().unwrap();\n+            let mut rewrite = inner_expr.rewrite(context, budget, offset + extra_offset);\n+\n+            if must_preserve_braces {\n+                // If we are here, then failure to rewrite is unacceptable.\n+                if rewrite.is_none() {\n+                    return None;\n+                }\n+            } else {\n+                // Checks if rewrite succeeded and fits on a single line.\n+                rewrite = and_one_line(rewrite);\n             }\n-            _ => expr,\n-        };\n-        let extra_offset = extra_offset(&prefix, offset) + spacer.len();\n-        let budget = try_opt!(width.checked_sub(extra_offset + closer.len()));\n-        let rewrite = inner_expr.rewrite(context, budget, offset + extra_offset);\n+\n+            if let Some(rewrite) = rewrite {\n+                return Some(format!(\"{} {}\", prefix, rewrite));\n+            }\n+        }\n+    }\n+\n+    // If we fell through the above block, then we need braces, but we might\n+    // still prefer a one-liner (we might also have fallen through because of\n+    // lack of space).\n+    if try_single_line && !prefix.contains('\\n') {\n+        let inner_expr = inner_block.expr.as_ref().unwrap();\n+        // 4 = braces and spaces.\n+        let mut rewrite = inner_expr.rewrite(context, budget - 4, offset + extra_offset);\n \n         // Checks if rewrite succeeded and fits on a single line.\n-        let accept_rewrite = rewrite.as_ref().map_or(false, |result| !result.contains('\\n'));\n+        rewrite = and_one_line(rewrite);\n \n-        if accept_rewrite {\n-            return Some(format!(\"{}{}{}{}\", prefix, spacer, rewrite.unwrap(), closer));\n+        if let Some(rewrite) = rewrite {\n+            return Some(format!(\"{} {{ {} }}\", prefix, rewrite));\n         }\n     }\n \n     // We couldn't format the closure body as a single line expression; fall\n     // back to block formatting.\n-    let body_rewrite = body.expr\n-                           .as_ref()\n-                           .and_then(|body_expr| {\n-                               if let ast::ExprKind::Block(ref inner) = body_expr.node {\n-                                   Some(inner.rewrite(&context, 2, Indent::empty()))\n-                               } else {\n-                                   None\n-                               }\n-                           })\n-                           .unwrap_or_else(|| body.rewrite(&context, 2, Indent::empty()));\n+    let body_rewrite = inner_block.rewrite(&context, budget, Indent::empty());\n \n     Some(format!(\"{} {}\", prefix, try_opt!(body_rewrite)))\n }\n \n+fn and_one_line(x: Option<String>) -> Option<String> {\n+    x.and_then(|x| if x.contains('\\n') {\n+        None\n+    } else {\n+        Some(x)\n+    })\n+}\n+\n fn nop_block_collapse(block_str: Option<String>, budget: usize) -> Option<String> {\n     block_str.map(|block_str| {\n         if block_str.starts_with(\"{\") && budget >= 2 &&"}, {"sha": "a3c7c036879d66be2abb3a5f3645883cfeab9ca8", "filename": "src/utils.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c7780fdfd8c23cfbc49f537490dda65af3a6ad8b/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7780fdfd8c23cfbc49f537490dda65af3a6ad8b/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=c7780fdfd8c23cfbc49f537490dda65af3a6ad8b", "patch": "@@ -334,3 +334,22 @@ fn bin_search_test() {\n     assert_eq!(Some(()), binary_search(4, 125, &closure));\n     assert_eq!(None, binary_search(6, 100, &closure));\n }\n+\n+pub fn left_most_sub_expr(e: &ast::Expr) -> &ast::Expr {\n+    match e.node {\n+        ast::ExprKind::InPlace(ref e, _) |\n+        ast::ExprKind::Call(ref e, _) |\n+        ast::ExprKind::Binary(_, ref e, _) |\n+        ast::ExprKind::Cast(ref e, _) |\n+        ast::ExprKind::Type(ref e, _) |\n+        ast::ExprKind::Assign(ref e, _) |\n+        ast::ExprKind::AssignOp(_, ref e, _) |\n+        ast::ExprKind::Field(ref e, _) |\n+        ast::ExprKind::TupField(ref e, _) |\n+        ast::ExprKind::Index(ref e, _) |\n+        ast::ExprKind::Range(Some(ref e), _, _) => left_most_sub_expr(e),\n+        // FIXME needs Try in Syntex\n+        // ast::ExprKind::Try(ref f) => left_most_sub_expr(e),\n+        _ => e,\n+    }\n+}"}, {"sha": "e125a683dc69b316a4a21699b0ccae4bd8cd0d42", "filename": "tests/source/closure.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c7780fdfd8c23cfbc49f537490dda65af3a6ad8b/tests%2Fsource%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7780fdfd8c23cfbc49f537490dda65af3a6ad8b/tests%2Fsource%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fclosure.rs?ref=c7780fdfd8c23cfbc49f537490dda65af3a6ad8b", "patch": "@@ -50,3 +50,10 @@ fn issue311() {\n \n     (func)(0.0);\n }\n+\n+fn issue863() {\n+    let closure = |x| match x {\n+        0 => true,\n+        _ => false,\n+    } == true;\n+}"}, {"sha": "2479157bb4fe9f63a736d18fca99edab764ddf7f", "filename": "tests/target/chains-no-overflow.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c7780fdfd8c23cfbc49f537490dda65af3a6ad8b/tests%2Ftarget%2Fchains-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7780fdfd8c23cfbc49f537490dda65af3a6ad8b/tests%2Ftarget%2Fchains-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-no-overflow.rs?ref=c7780fdfd8c23cfbc49f537490dda65af3a6ad8b", "patch": "@@ -9,20 +9,16 @@ fn main() {\n                        .ddddddddddddddddddddddddddd\n                        .eeeeeeee();\n \n-    x().y(|| {\n-           match cond() {\n-               true => (),\n-               false => (),\n-           }\n+    x().y(|| match cond() {\n+           true => (),\n+           false => (),\n        });\n \n     loong_func()\n-        .quux(move || {\n-            if true {\n-                1\n-            } else {\n-                2\n-            }\n+        .quux(move || if true {\n+            1\n+        } else {\n+            2\n         });\n \n     fffffffffffffffffffffffffffffffffff(a,"}, {"sha": "392ff355b8693101739e80adde61246906673c00", "filename": "tests/target/chains.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c7780fdfd8c23cfbc49f537490dda65af3a6ad8b/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7780fdfd8c23cfbc49f537490dda65af3a6ad8b/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=c7780fdfd8c23cfbc49f537490dda65af3a6ad8b", "patch": "@@ -16,19 +16,15 @@ fn main() {\n \n     // Test case where first chain element isn't a path, but is shorter than\n     // the size of a tab.\n-    x().y(|| {\n-        match cond() {\n-            true => (),\n-            false => (),\n-        }\n+    x().y(|| match cond() {\n+        true => (),\n+        false => (),\n     });\n \n-    loong_func().quux(move || {\n-        if true {\n-            1\n-        } else {\n-            2\n-        }\n+    loong_func().quux(move || if true {\n+        1\n+    } else {\n+        2\n     });\n \n     some_fuuuuuuuuunction().method_call_a(aaaaa, bbbbb, |c| {"}, {"sha": "467b07b38cac27a4b76bbe38ce0c5b5ceb1c5c21", "filename": "tests/target/closure.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c7780fdfd8c23cfbc49f537490dda65af3a6ad8b/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7780fdfd8c23cfbc49f537490dda65af3a6ad8b/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=c7780fdfd8c23cfbc49f537490dda65af3a6ad8b", "patch": "@@ -26,12 +26,10 @@ fn main() {\n         }\n     };\n \n-    let block_me = |field| {\n-        if true_story() {\n-            1\n-        } else {\n-            2\n-        }\n+    let block_me = |field| if true_story() {\n+        1\n+    } else {\n+        2\n     };\n \n     let unblock_me = |trivial| closure();\n@@ -77,3 +75,10 @@ fn issue311() {\n \n     (func)(0.0);\n }\n+\n+fn issue863() {\n+    let closure = |x| match x {\n+        0 => true,\n+        _ => false,\n+    } == true;\n+}"}]}