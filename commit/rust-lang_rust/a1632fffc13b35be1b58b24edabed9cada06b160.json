{"sha": "a1632fffc13b35be1b58b24edabed9cada06b160", "node_id": "C_kwDOAAsO6NoAKGExNjMyZmZmYzEzYjM1YmUxYjU4YjI0ZWRhYmVkOWNhZGEwNmIxNjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-16T00:47:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-16T00:47:10Z"}, "message": "Auto merge of #8761 - tamaroning:fix_8505, r=Jarcho\n\n`undocumented_unsafe_blocks` does not trigger on unsafe trait impls\n\nCloses #8505\n\nchangelog: This lint checks unsafe impls NOT from macro expansions and checks ones in macro declarations.\n~~`unsafe impl`s from macro invocations don't trigger the lint for now.~~\n~~This lint checks unsafe impls from/not from macro expansions~~", "tree": {"sha": "6b15543ad036014facebd9b6ad4f5b85d787a887", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b15543ad036014facebd9b6ad4f5b85d787a887"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1632fffc13b35be1b58b24edabed9cada06b160", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1632fffc13b35be1b58b24edabed9cada06b160", "html_url": "https://github.com/rust-lang/rust/commit/a1632fffc13b35be1b58b24edabed9cada06b160", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1632fffc13b35be1b58b24edabed9cada06b160/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ec735962f0c948e6971f12fc5f4279f7c1a8c28", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ec735962f0c948e6971f12fc5f4279f7c1a8c28", "html_url": "https://github.com/rust-lang/rust/commit/6ec735962f0c948e6971f12fc5f4279f7c1a8c28"}, {"sha": "9e66f2d05844fb6e6972f347629bd77e08fee8d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e66f2d05844fb6e6972f347629bd77e08fee8d4", "html_url": "https://github.com/rust-lang/rust/commit/9e66f2d05844fb6e6972f347629bd77e08fee8d4"}], "stats": {"total": 467, "additions": 437, "deletions": 30}, "files": [{"sha": "5a8677f90be413bbdb9052104a7023242e674909", "filename": "clippy_lints/src/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 168, "deletions": 28, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/a1632fffc13b35be1b58b24edabed9cada06b160/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1632fffc13b35be1b58b24edabed9cada06b160/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs?ref=a1632fffc13b35be1b58b24edabed9cada06b160", "patch": "@@ -1,17 +1,18 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::is_lint_allowed;\n use clippy_utils::source::walk_span_to_context;\n+use clippy_utils::{get_parent_node, is_lint_allowed};\n use rustc_data_structures::sync::Lrc;\n-use rustc_hir::{Block, BlockCheckMode, UnsafeSource};\n+use rustc_hir as hir;\n+use rustc_hir::{Block, BlockCheckMode, ItemKind, Node, UnsafeSource};\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{BytePos, Pos, SyntaxContext};\n+use rustc_span::{BytePos, Pos, Span, SyntaxContext};\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for `unsafe` blocks without a `// SAFETY: ` comment\n+    /// Checks for `unsafe` blocks and impls without a `// SAFETY: ` comment\n     /// explaining why the unsafe operations performed inside\n     /// the block are safe.\n     ///\n@@ -34,7 +35,7 @@ declare_clippy_lint! {\n     /// ```\n     ///\n     /// ### Why is this bad?\n-    /// Undocumented unsafe blocks can make it difficult to\n+    /// Undocumented unsafe blocks and impls can make it difficult to\n     /// read and maintain code, as well as uncover unsoundness\n     /// and bugs.\n     ///\n@@ -66,7 +67,7 @@ impl LateLintPass<'_> for UndocumentedUnsafeBlocks {\n         if block.rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided)\n             && !in_external_macro(cx.tcx.sess, block.span)\n             && !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, block.hir_id)\n-            && !is_unsafe_from_proc_macro(cx, block)\n+            && !is_unsafe_from_proc_macro(cx, block.span)\n             && !block_has_safety_comment(cx, block)\n         {\n             let source_map = cx.tcx.sess.source_map();\n@@ -86,11 +87,37 @@ impl LateLintPass<'_> for UndocumentedUnsafeBlocks {\n             );\n         }\n     }\n+\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n+        if let hir::ItemKind::Impl(imple) = item.kind\n+            && imple.unsafety == hir::Unsafety::Unsafe\n+            && !in_external_macro(cx.tcx.sess, item.span)\n+            && !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, item.hir_id())\n+            && !is_unsafe_from_proc_macro(cx, item.span)\n+            && !item_has_safety_comment(cx, item)\n+        {\n+            let source_map = cx.tcx.sess.source_map();\n+            let span = if source_map.is_multiline(item.span) {\n+                source_map.span_until_char(item.span, '\\n')\n+            } else {\n+                item.span\n+            };\n+\n+            span_lint_and_help(\n+                cx,\n+                UNDOCUMENTED_UNSAFE_BLOCKS,\n+                span,\n+                \"unsafe impl missing a safety comment\",\n+                None,\n+                \"consider adding a safety comment on the preceding line\",\n+            );\n+        }\n+    }\n }\n \n-fn is_unsafe_from_proc_macro(cx: &LateContext<'_>, block: &Block<'_>) -> bool {\n+fn is_unsafe_from_proc_macro(cx: &LateContext<'_>, span: Span) -> bool {\n     let source_map = cx.sess().source_map();\n-    let file_pos = source_map.lookup_byte_offset(block.span.lo());\n+    let file_pos = source_map.lookup_byte_offset(span.lo());\n     file_pos\n         .sf\n         .src\n@@ -100,7 +127,7 @@ fn is_unsafe_from_proc_macro(cx: &LateContext<'_>, block: &Block<'_>) -> bool {\n }\n \n /// Checks if the lines immediately preceding the block contain a safety comment.\n-fn block_has_safety_comment(cx: &LateContext<'_>, block: &Block<'_>) -> bool {\n+fn block_has_safety_comment(cx: &LateContext<'_>, block: &hir::Block<'_>) -> bool {\n     // This intentionally ignores text before the start of a function so something like:\n     // ```\n     //     // SAFETY: reason\n@@ -109,13 +136,115 @@ fn block_has_safety_comment(cx: &LateContext<'_>, block: &Block<'_>) -> bool {\n     // won't work. This is to avoid dealing with where such a comment should be place relative to\n     // attributes and doc comments.\n \n+    span_from_macro_expansion_has_safety_comment(cx, block.span) || span_in_body_has_safety_comment(cx, block.span)\n+}\n+\n+/// Checks if the lines immediately preceding the item contain a safety comment.\n+#[allow(clippy::collapsible_match)]\n+fn item_has_safety_comment(cx: &LateContext<'_>, item: &hir::Item<'_>) -> bool {\n+    if span_from_macro_expansion_has_safety_comment(cx, item.span) {\n+        return true;\n+    }\n+\n+    if item.span.ctxt() == SyntaxContext::root() {\n+        if let Some(parent_node) = get_parent_node(cx.tcx, item.hir_id()) {\n+            let comment_start = match parent_node {\n+                Node::Crate(parent_mod) => {\n+                    comment_start_before_impl_in_mod(cx, parent_mod, parent_mod.spans.inner_span, item)\n+                },\n+                Node::Item(parent_item) => {\n+                    if let ItemKind::Mod(parent_mod) = &parent_item.kind {\n+                        comment_start_before_impl_in_mod(cx, parent_mod, parent_item.span, item)\n+                    } else {\n+                        // Doesn't support impls in this position. Pretend a comment was found.\n+                        return true;\n+                    }\n+                },\n+                Node::Stmt(stmt) => {\n+                    if let Some(stmt_parent) = get_parent_node(cx.tcx, stmt.hir_id) {\n+                        match stmt_parent {\n+                            Node::Block(block) => walk_span_to_context(block.span, SyntaxContext::root()).map(Span::lo),\n+                            _ => {\n+                                // Doesn't support impls in this position. Pretend a comment was found.\n+                                return true;\n+                            },\n+                        }\n+                    } else {\n+                        // Problem getting the parent node. Pretend a comment was found.\n+                        return true;\n+                    }\n+                },\n+                _ => {\n+                    // Doesn't support impls in this position. Pretend a comment was found.\n+                    return true;\n+                },\n+            };\n+\n+            let source_map = cx.sess().source_map();\n+            if let Some(comment_start) = comment_start\n+                && let Ok(unsafe_line) = source_map.lookup_line(item.span.lo())\n+                && let Ok(comment_start_line) = source_map.lookup_line(comment_start)\n+                && Lrc::ptr_eq(&unsafe_line.sf, &comment_start_line.sf)\n+                && let Some(src) = unsafe_line.sf.src.as_deref()\n+            {\n+                comment_start_line.line < unsafe_line.line && text_has_safety_comment(\n+                    src,\n+                    &unsafe_line.sf.lines[comment_start_line.line + 1..=unsafe_line.line],\n+                    unsafe_line.sf.start_pos.to_usize(),\n+                )\n+            } else {\n+                // Problem getting source text. Pretend a comment was found.\n+                true\n+            }\n+        } else {\n+            // No parent node. Pretend a comment was found.\n+            true\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+fn comment_start_before_impl_in_mod(\n+    cx: &LateContext<'_>,\n+    parent_mod: &hir::Mod<'_>,\n+    parent_mod_span: Span,\n+    imple: &hir::Item<'_>,\n+) -> Option<BytePos> {\n+    parent_mod.item_ids.iter().enumerate().find_map(|(idx, item_id)| {\n+        if *item_id == imple.item_id() {\n+            if idx == 0 {\n+                // mod A { /* comment */ unsafe impl T {} ... }\n+                // ^------------------------------------------^ returns the start of this span\n+                // ^---------------------^ finally checks comments in this range\n+                if let Some(sp) = walk_span_to_context(parent_mod_span, SyntaxContext::root()) {\n+                    return Some(sp.lo());\n+                }\n+            } else {\n+                // some_item /* comment */ unsafe impl T {}\n+                // ^-------^ returns the end of this span\n+                //         ^---------------^ finally checks comments in this range\n+                let prev_item = cx.tcx.hir().item(parent_mod.item_ids[idx - 1]);\n+                if let Some(sp) = walk_span_to_context(prev_item.span, SyntaxContext::root()) {\n+                    return Some(sp.hi());\n+                }\n+            }\n+        }\n+        None\n+    })\n+}\n+\n+fn span_from_macro_expansion_has_safety_comment(cx: &LateContext<'_>, span: Span) -> bool {\n     let source_map = cx.sess().source_map();\n-    let ctxt = block.span.ctxt();\n-    if ctxt != SyntaxContext::root() {\n-        // From a macro expansion. Get the text from the start of the macro declaration to start of the unsafe block.\n+    let ctxt = span.ctxt();\n+    if ctxt == SyntaxContext::root() {\n+        false\n+    } else {\n+        // From a macro expansion. Get the text from the start of the macro declaration to start of the\n+        // unsafe block.\n         //     macro_rules! foo { () => { stuff }; (x) => { unsafe { stuff } }; }\n         //     ^--------------------------------------------^\n-        if let Ok(unsafe_line) = source_map.lookup_line(block.span.lo())\n+        if let Ok(unsafe_line) = source_map.lookup_line(span.lo())\n             && let Ok(macro_line) = source_map.lookup_line(ctxt.outer_expn_data().def_site.lo())\n             && Lrc::ptr_eq(&unsafe_line.sf, &macro_line.sf)\n             && let Some(src) = unsafe_line.sf.src.as_deref()\n@@ -129,24 +258,35 @@ fn block_has_safety_comment(cx: &LateContext<'_>, block: &Block<'_>) -> bool {\n             // Problem getting source text. Pretend a comment was found.\n             true\n         }\n-    } else if let Ok(unsafe_line) = source_map.lookup_line(block.span.lo())\n+    }\n+}\n+\n+fn span_in_body_has_safety_comment(cx: &LateContext<'_>, span: Span) -> bool {\n+    let source_map = cx.sess().source_map();\n+    let ctxt = span.ctxt();\n+    if ctxt == SyntaxContext::root()\n         && let Some(body) = cx.enclosing_body\n-        && let Some(body_span) = walk_span_to_context(cx.tcx.hir().body(body).value.span, SyntaxContext::root())\n-        && let Ok(body_line) = source_map.lookup_line(body_span.lo())\n-        && Lrc::ptr_eq(&unsafe_line.sf, &body_line.sf)\n-        && let Some(src) = unsafe_line.sf.src.as_deref()\n     {\n-        // Get the text from the start of function body to the unsafe block.\n-        //     fn foo() { some_stuff; unsafe { stuff }; other_stuff; }\n-        //              ^-------------^\n-        body_line.line < unsafe_line.line && text_has_safety_comment(\n-            src,\n-            &unsafe_line.sf.lines[body_line.line + 1..=unsafe_line.line],\n-            unsafe_line.sf.start_pos.to_usize(),\n-        )\n+        if let Ok(unsafe_line) = source_map.lookup_line(span.lo())\n+            && let Some(body_span) = walk_span_to_context(cx.tcx.hir().body(body).value.span, SyntaxContext::root())\n+            && let Ok(body_line) = source_map.lookup_line(body_span.lo())\n+            && Lrc::ptr_eq(&unsafe_line.sf, &body_line.sf)\n+            && let Some(src) = unsafe_line.sf.src.as_deref()\n+        {\n+            // Get the text from the start of function body to the unsafe block.\n+            //     fn foo() { some_stuff; unsafe { stuff }; other_stuff; }\n+            //              ^-------------^\n+            body_line.line < unsafe_line.line && text_has_safety_comment(\n+                src,\n+                &unsafe_line.sf.lines[body_line.line + 1..=unsafe_line.line],\n+                unsafe_line.sf.start_pos.to_usize(),\n+            )\n+        } else {\n+            // Problem getting source text. Pretend a comment was found.\n+            true\n+        }\n     } else {\n-        // Problem getting source text. Pretend a comment was found.\n-        true\n+        false\n     }\n }\n "}, {"sha": "33b6a82f9d2c32cefabdc09ca2c4ec6786039e4b", "filename": "tests/ui/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 152, "deletions": 1, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/a1632fffc13b35be1b58b24edabed9cada06b160/tests%2Fui%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1632fffc13b35be1b58b24edabed9cada06b160/tests%2Fui%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundocumented_unsafe_blocks.rs?ref=a1632fffc13b35be1b58b24edabed9cada06b160", "patch": "@@ -1,7 +1,7 @@\n // aux-build:proc_macro_unsafe.rs\n \n #![warn(clippy::undocumented_unsafe_blocks)]\n-#![allow(clippy::let_unit_value)]\n+#![allow(clippy::let_unit_value, clippy::missing_safety_doc)]\n \n extern crate proc_macro_unsafe;\n \n@@ -334,4 +334,155 @@ pub fn print_binary_tree() {\n     println!(\"{}\", unsafe { String::from_utf8_unchecked(vec![]) });\n }\n \n+mod unsafe_impl_smoke_test {\n+    unsafe trait A {}\n+\n+    // error: no safety comment\n+    unsafe impl A for () {}\n+\n+    // Safety: ok\n+    unsafe impl A for (i32) {}\n+\n+    mod sub_mod {\n+        // error:\n+        unsafe impl B for (u32) {}\n+        unsafe trait B {}\n+    }\n+\n+    #[rustfmt::skip]\n+    mod sub_mod2 {\n+        // \n+        // SAFETY: ok\n+        // \n+\n+        unsafe impl B for (u32) {}\n+        unsafe trait B {}\n+    }\n+}\n+\n+mod unsafe_impl_from_macro {\n+    unsafe trait T {}\n+\n+    // error\n+    macro_rules! no_safety_comment {\n+        ($t:ty) => {\n+            unsafe impl T for $t {}\n+        };\n+    }\n+\n+    // ok\n+    no_safety_comment!(());\n+\n+    // ok\n+    macro_rules! with_safety_comment {\n+        ($t:ty) => {\n+            // SAFETY:\n+            unsafe impl T for $t {}\n+        };\n+    }\n+\n+    // ok\n+    with_safety_comment!((i32));\n+}\n+\n+mod unsafe_impl_macro_and_not_macro {\n+    unsafe trait T {}\n+\n+    // error\n+    macro_rules! no_safety_comment {\n+        ($t:ty) => {\n+            unsafe impl T for $t {}\n+        };\n+    }\n+\n+    // ok\n+    no_safety_comment!(());\n+\n+    // error\n+    unsafe impl T for (i32) {}\n+\n+    // ok\n+    no_safety_comment!(u32);\n+\n+    // error\n+    unsafe impl T for (bool) {}\n+}\n+\n+#[rustfmt::skip]\n+mod unsafe_impl_valid_comment {\n+    unsafe trait SaFety {}\n+    // SaFety:\n+    unsafe impl SaFety for () {}\n+\n+    unsafe trait MultiLineComment {}\n+    // The following impl is safe\n+    // ...\n+    // Safety: reason\n+    unsafe impl MultiLineComment for () {}\n+\n+    unsafe trait NoAscii {}\n+    // \u5b89\u5168 SAFETY: \u4ee5\u4e0b\u306e\u30b3\u30fc\u30c9\u306f\u5b89\u5168\u3067\u3059\n+    unsafe impl NoAscii for () {}\n+\n+    unsafe trait InlineAndPrecedingComment {}\n+    // SAFETY:\n+    /* comment */ unsafe impl InlineAndPrecedingComment for () {}\n+\n+    unsafe trait BuriedSafety {}\n+    // Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor\n+    // incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation\n+    // ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in\n+    // reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint\n+    // occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est\n+    // laborum. Safety:\n+    // Tellus elementum sagittis vitae et leo duis ut diam quam. Sit amet nulla facilisi\n+    // morbi tempus iaculis urna. Amet luctus venenatis lectus magna. At quis risus sed vulputate odio\n+    // ut. Luctus venenatis lectus magna fringilla urna. Tortor id aliquet lectus proin nibh nisl\n+    // condimentum id venenatis. Vulputate dignissim suspendisse in est ante in nibh mauris cursus.\n+    unsafe impl BuriedSafety for () {}\n+\n+    unsafe trait MultiLineBlockComment {}\n+    /* This is a description\n+     * Safety: */\n+    unsafe impl MultiLineBlockComment for () {}\n+}\n+\n+#[rustfmt::skip]\n+mod unsafe_impl_invalid_comment {\n+    unsafe trait NoComment {}\n+\n+    unsafe impl NoComment for () {}\n+\n+    unsafe trait InlineComment {}\n+\n+    /* SAFETY: */ unsafe impl InlineComment for () {}\n+\n+    unsafe trait TrailingComment {}\n+\n+    unsafe impl TrailingComment for () {} // SAFETY:\n+\n+    unsafe trait Interference {}\n+    // SAFETY:\n+    const BIG_NUMBER: i32 = 1000000;\n+    unsafe impl Interference for () {}\n+}\n+\n+unsafe trait ImplInFn {}\n+\n+fn impl_in_fn() {\n+    // error\n+    unsafe impl ImplInFn for () {}\n+\n+    // SAFETY: ok\n+    unsafe impl ImplInFn for (i32) {}\n+}\n+\n+unsafe trait CrateRoot {}\n+\n+// error\n+unsafe impl CrateRoot for () {}\n+\n+// SAFETY: ok\n+unsafe impl CrateRoot for (i32) {}\n+\n fn main() {}"}, {"sha": "b79949e9d06d6af18a3602f980fe15f5fe30a6ec", "filename": "tests/ui/undocumented_unsafe_blocks.stderr", "status": "modified", "additions": 117, "deletions": 1, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/a1632fffc13b35be1b58b24edabed9cada06b160/tests%2Fui%2Fundocumented_unsafe_blocks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1632fffc13b35be1b58b24edabed9cada06b160/tests%2Fui%2Fundocumented_unsafe_blocks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundocumented_unsafe_blocks.stderr?ref=a1632fffc13b35be1b58b24edabed9cada06b160", "patch": "@@ -147,5 +147,121 @@ LL |     println!(\"{}\", unsafe { String::from_utf8_unchecked(vec![]) });\n    |\n    = help: consider adding a safety comment on the preceding line\n \n-error: aborting due to 18 previous errors\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:341:5\n+   |\n+LL |     unsafe impl A for () {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:348:9\n+   |\n+LL |         unsafe impl B for (u32) {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:369:13\n+   |\n+LL |             unsafe impl T for $t {}\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     no_safety_comment!(());\n+   |     ---------------------- in this macro invocation\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+   = note: this error originates in the macro `no_safety_comment` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:394:13\n+   |\n+LL |             unsafe impl T for $t {}\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     no_safety_comment!(());\n+   |     ---------------------- in this macro invocation\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+   = note: this error originates in the macro `no_safety_comment` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:402:5\n+   |\n+LL |     unsafe impl T for (i32) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:394:13\n+   |\n+LL |             unsafe impl T for $t {}\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     no_safety_comment!(u32);\n+   |     ----------------------- in this macro invocation\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+   = note: this error originates in the macro `no_safety_comment` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:408:5\n+   |\n+LL |     unsafe impl T for (bool) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:454:5\n+   |\n+LL |     unsafe impl NoComment for () {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:458:19\n+   |\n+LL |     /* SAFETY: */ unsafe impl InlineComment for () {}\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:462:5\n+   |\n+LL |     unsafe impl TrailingComment for () {} // SAFETY:\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:467:5\n+   |\n+LL |     unsafe impl Interference for () {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:474:5\n+   |\n+LL |     unsafe impl ImplInFn for () {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:483:1\n+   |\n+LL | unsafe impl CrateRoot for () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: aborting due to 31 previous errors\n "}]}